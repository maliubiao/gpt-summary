Response:
Let's break down the thought process for analyzing the `net_log_util.cc` file and answering the prompt.

**1. Initial Understanding - The Big Picture:**

The first thing I recognize is the file name and its location: `net/log/net_log_util.cc`. This immediately suggests its purpose: utility functions related to network logging within Chromium. The `#include` statements confirm this, showing dependencies on various network stack components (`net/base/*`, `net/dns/*`, `net/http/*`, `net/proxy_resolution/*`, etc.) and logging infrastructure (`net/log/*`).

**2. Deeper Dive - Identifying Core Functionality:**

I then start scanning the code for key functions and data structures. I notice:

* **Constants:**  A series of `StringToConstant` structs and arrays (`kCertStatusFlags`, `kLoadFlags`, `kLoadStateTable`, `kNetErrors`). These are clearly used to map numerical error codes, flags, and states to their string representations for logging purposes.
* **`GetNetConstants()`:** This function stands out. It aggregates various network constants into a `base::Value::Dict`. The content of this dictionary (log format version, event types, error codes, flags, etc.) strongly indicates it's responsible for providing metadata about the logging format itself.
* **`GetNetInfo()`:**  Another crucial function. It gathers runtime information about the network state, including proxy settings, DNS cache, socket pools, HTTP cache, QUIC status, and experimental features. The dependencies on `URLRequestContext` are clear.
* **`CreateNetLogEntriesForActiveObjects()`:** This function deals with capturing the current state of active `URLRequest` objects for logging. The sorting by creation time is an interesting detail.
* **Helper Functions:** `GetDiskCacheBackend()` and `RequestCreatedBefore()` are smaller utility functions supporting the main functions.

**3. Function-by-Function Analysis (Internal Monologue/Scratchpad):**

* **`GetNetConstants()`:**
    * Purpose: Define the structure and meaning of log data.
    * Key items:  Log format version (important for compatibility), mappings of enums to strings (crucial for human readability of logs).
    * Potential JavaScript connection: While not directly called by JavaScript, the *output* of this function is used by the Chrome DevTools "Network" panel (which *is* JavaScript-based) to interpret the network logs.

* **`GetNetInfo()`:**
    * Purpose: Capture a snapshot of the current network configuration and state.
    * Key items: Proxy settings, DNS information, socket pool status, cache status, protocol-specific information (SPDY, QUIC), active experiments.
    * Potential JavaScript connection: Similar to `GetNetConstants`, the information gathered here is displayed in the DevTools Network panel, aiding developers in understanding network behavior.

* **`CreateNetLogEntriesForActiveObjects()`:**
    * Purpose: Log the existence and state of ongoing network requests.
    * Key items: Iteration through `URLRequestContext`s and their active `URLRequest`s, sorting by creation time.
    * Potential JavaScript connection: When a user initiates a network request from a web page (using JavaScript's `fetch` or `XMLHttpRequest`), this function contributes to logging the details of that request in the NetLog, which is then viewable in DevTools.

**4. Identifying JavaScript Connections:**

The core connection to JavaScript isn't direct code execution. Instead, it's through the *consumption* of the data generated by these C++ functions. The Chrome DevTools, specifically the "Network" panel, is built with JavaScript and uses the NetLog data to provide insights into network activity.

**5. Logic and Assumptions (Hypothetical Inputs/Outputs):**

For `GetNetConstants`, the input is implicit (the state of the Chromium codebase). The output is a structured dictionary. I can create a simplified example to illustrate the structure:

```json
{
  "logFormatVersion": 1,
  "logEventTypes": { "REQUEST_START": 10 },
  "netError": { "ERR_NAME_NOT_RESOLVED": -105 }
}
```

For `GetNetInfo`, the input is a `URLRequestContext`. A simplified output example:

```json
{
  "proxyResolutionService": { "effective_config": { "mode": "DIRECT" } },
  "hostResolver": { "cache": { "capacity": 100 } }
}
```

For `CreateNetLogEntriesForActiveObjects`, the input is a set of `URLRequestContext`s. The output is a series of `NetLogEntry` objects (though this function interacts with an observer, the *conceptual* output is log entries). Example:

```json
[
  { "type": "REQUEST_ALIVE", "phase": "BEGIN", "source": { "id": 1 }, "params": { "url": "https://example.com" } }
]
```

**6. Common Usage Errors and User Actions:**

I consider how developers might interact with this logging system. Common errors:

* Not enabling NetLog capture: The functions won't produce useful output if logging isn't enabled.
* Misinterpreting the log data: Understanding the meaning of different events and parameters is crucial. The `GetNetConstants` output helps with this.
* Not correlating events: Network requests involve many stages. Debugging often requires tracing a request through multiple log entries.

User actions leading to these logs involve any network activity: loading web pages, downloading files, making API calls, etc.

**7. Debugging Clues:**

The NetLog is a key debugging tool. The information in `net_log_util.cc` helps developers:

* Identify network errors (using the error code mappings).
* Understand proxy settings.
* Analyze DNS resolution issues.
* Examine caching behavior.
* Debug protocol-specific problems (HTTP/2, QUIC).

**8. Structuring the Answer:**

Finally, I organize the information into a clear and structured answer, addressing each part of the prompt: functionality, JavaScript relationship, logic/assumptions, usage errors, and debugging. I use examples and clear explanations to make the information accessible.
这是文件 `net/log/net_log_util.cc` 的功能列表，以及它与 JavaScript 的关系，逻辑推理，常见错误和调试线索的说明。

**文件功能列表:**

`net/log/net_log_util.cc` 文件包含了一系列用于 Chromium 网络栈 NetLog 系统的实用工具函数。其主要功能包括：

1. **提供网络常量信息:**
   - `GetNetConstants()` 函数返回一个包含各种网络相关常量的字典，例如：
     - 日志格式版本 (`logFormatVersion`)
     - 网络事件类型及其对应的数值 (`logEventTypes`)
     - SSL 证书状态标志及其对应的数值 (`certStatusFlag`)
     - 加载标志及其对应的数值 (`loadFlag`)
     - 加载状态及其对应的数值 (`loadState`)
     - 网络错误代码及其对应的数值 (`netError`)
     - QUIC 错误代码及其对应的数值 (`quicError`, `quicRstStreamError`)
     - 事件阶段 (`logEventPhase`)
     - 源类型 (`logSourceType`)
     - 地址族 (`addressFamily`)
     - DNS 查询类型 (`dnsQueryType`)
     - 安全 DNS 模式 (`secureDnsMode`)
     - 时间戳偏移量 (`timeTickOffset`)
     - 客户端信息 (`clientInfo`)
     - 活跃的 Field Trials (`kNetInfoFieldTrials`)

2. **提供网络运行时信息:**
   - `GetNetInfo(URLRequestContext* context)` 函数返回一个包含当前网络状态信息的字典，这些信息从给定的 `URLRequestContext` 中获取，例如：
     - 代理服务器配置信息 (`kNetInfoProxy`)
     - Host Resolver (DNS 解析器) 的信息，包括缓存内容 (`kNetInfoHostResolver`) 和禁用的 DoH 提供商 (`kNetInfoDohProvidersDisabledDueToFeature`)
     - Socket Pool 的状态 (`kNetInfoSocketPool`)
     - SPDY (HTTP/2) 会话的信息 (`kNetInfoSpdySessions`) 和状态 (`kNetInfoSpdyStatus`)
     - ALT-SVC 映射 (`kNetInfoAltSvcMappings`)
     - QUIC 的信息 (`kNetInfoQuic`)
     - HTTP Cache 的信息 (`kNetInfoHTTPCache`)
     - Reporting API 的信息 (`kNetInfoReporting`)
     - 当前活跃的 Field Trials (`kNetInfoFieldTrials`)

3. **为活跃对象创建 NetLog 条目:**
   - `CreateNetLogEntriesForActiveObjects(const std::set<URLRequestContext*>& contexts, NetLog::ThreadSafeObserver* observer)` 函数遍历给定的 `URLRequestContext` 集合中的所有活跃的 `URLRequest` 对象，并为每个对象创建一个 `REQUEST_ALIVE` 类型的 NetLog 条目，用于记录这些请求在 NetLog 开始捕获时的状态。

**与 JavaScript 功能的关系:**

`net_log_util.cc` 本身是 C++ 代码，不直接与 JavaScript 交互执行。然而，它提供的功能对于在 Chrome 开发者工具 (DevTools) 的 "Network" 面板中展示和理解网络活动至关重要。

- **`GetNetConstants()` 提供的数据被 JavaScript 代码使用，用于解释 NetLog 事件。** 例如，当 Network 面板显示一个网络错误的类型时，它会使用 `GetNetConstants()` 返回的 `netError` 字典来将数值错误代码（例如 -105）转换为可读的字符串（例如 "ERR_NAME_NOT_RESOLVED"）。
- **`GetNetInfo()` 提供的数据也在 Network 面板中显示，以展示当前的网络配置和状态。** 用户可以在 Network 面板的 "网络条件 (Network conditions)" 或 "事件日志 (Events log)" 中查看这些信息，例如代理设置、DNS 缓存状态、Socket 连接池的状态等。
- **`CreateNetLogEntriesForActiveObjects()` 确保了在 NetLog 开始捕获时，已经存在的网络请求会被记录下来。** 这使得开发者能够追踪在页面加载之前或 NetLog 启动之前就已经开始的请求。

**举例说明:**

假设用户在 Chrome 中访问 `https://www.example.com`。

- **`GetNetConstants()` 的输出示例 (部分):**
  ```json
  {
    "logFormatVersion": 1,
    "logEventTypes": {
      "SOCKET_POOL_CONNECT_JOB": 167,
      "URL_REQUEST_START": 256
    },
    "netError": {
      "ERR_CONNECTION_REFUSED": -102,
      "ERR_NAME_NOT_RESOLVED": -105
    }
  }
  ```
  JavaScript 代码可以使用 `logEventTypes` 将数值 `256` 解释为 "URL_REQUEST_START" 事件。

- **`GetNetInfo()` 的输出示例 (部分):**
  ```json
  {
    "proxyResolutionService": {
      "effective_config": {
        "mode": "DIRECT"
      }
    },
    "hostResolver": {
      "cache": {
        "capacity": 100,
        "entries": [
          {
            "hostname": "www.example.com",
            "results": [
              {
                "address": "93.184.216.34",
                "family": 0
              }
            ]
          }
        ]
      }
    }
  }
  ```
  Network 面板可能会显示用户没有使用代理，并且 `www.example.com` 的 IP 地址已缓存。

- **`CreateNetLogEntriesForActiveObjects()` 的逻辑推理:**
  **假设输入:**  在 NetLog 开始捕获时，有一个正在进行的对 `https://api.example.com/data` 的 `XMLHttpRequest` 请求。
  **输出:**  NetLog 中会包含一个 `REQUEST_ALIVE` 事件，其参数可能包含类似以下的信息：
  ```json
  {
    "url": "https://api.example.com/data",
    "method": "GET",
    "load_flags": 0
  }
  ```

**用户或编程常见的使用错误:**

1. **未启用 NetLog 捕获:** 如果用户没有在 `chrome://net-export/` 或通过命令行标志启用 NetLog 捕获，则这些函数虽然会被调用，但不会产生可供分析的输出。这是最常见的“错误”，但更多的是一种配置问题。

2. **误解 NetLog 事件和参数的含义:**  开发者可能不熟悉各种 NetLog 事件的触发时机和参数的意义。`GetNetConstants()` 提供的常量信息有助于理解，但仍需要一定的学习成本。例如，开发者可能不清楚 `SOCKET_POOL_CONNECT_JOB` 和 `TCP_CONNECT` 事件之间的区别。

3. **没有关联相关的 NetLog 事件:** 一个网络请求通常会触发多个 NetLog 事件。开发者可能只关注单个事件，而忽略了事件之间的关联，导致无法全面了解网络请求的生命周期。例如，只看到 `URL_REQUEST_START` 事件而没有查看后续的 `HTTP_TRANSACTION_SEND_REQUEST_HEADERS` 和 `HTTP_TRANSACTION_READ_RESPONSE_HEADERS` 事件。

**用户操作如何一步步到达这里，作为调试线索:**

以下步骤描述了用户操作如何间接地触发 `net_log_util.cc` 中的代码，并将其作为调试线索：

1. **用户在 Chrome 浏览器中执行网络操作:** 例如，在地址栏输入 URL 并访问网站，点击链接，或者网页上的 JavaScript 代码发起 `fetch` 或 `XMLHttpRequest` 请求。

2. **Chromium 网络栈处理这些请求:**  网络栈的各个组件（例如 DNS 解析器、Socket 连接池、HTTP 事务工厂等）会处理这些请求，并在处理过程中生成 NetLog 事件。

3. **用户启用 NetLog 捕获:** 用户可以通过以下方式启用 NetLog：
   - 在 Chrome 浏览器中访问 `chrome://net-export/` 并点击 "开始记录 (Start Logging)"。
   - 使用命令行标志 `--log-net-log=/path/to/netlog.json` 启动 Chrome。

4. **`GetNetConstants()` 在 NetLog 捕获开始时被调用:**  当 NetLog 开始记录时，会首先记录一些全局信息，包括通过 `GetNetConstants()` 获取的网络常量。这些常量用于后续解释 NetLog 事件。

5. **`GetNetInfo()` 在 NetLog 捕获开始时被调用:**  同样，为了提供上下文信息，`GetNetInfo()` 会被调用以记录当前的网络状态。

6. **`CreateNetLogEntriesForActiveObjects()` 在 NetLog 捕获开始时被调用:**  这确保了在 NetLog 启动时正在进行的网络请求也能被记录下来。

7. **用户导出 NetLog 日志:** 用户在 `chrome://net-export/` 中点击 "停止记录 (Stop Logging)"，然后保存生成的 `netlog.json` 文件。

8. **开发者分析 NetLog 日志:** 开发者可以使用 `chrome://net-internals/#/events` 加载 `netlog.json` 文件，或者使用其他工具解析。

**调试线索:**

当开发者遇到网络问题时，NetLog 是一个非常有用的调试工具。`net_log_util.cc` 中提供的功能可以帮助开发者：

- **理解网络错误的根本原因:** 通过查看 `netError` 类型的事件及其关联的错误代码（可以通过 `GetNetConstants()` 映射到可读字符串）。
- **分析 DNS 解析问题:**  查看 `HOST_RESOLVER_IMPL` 相关的事件，以及 `GetNetInfo()` 中提供的 DNS 缓存信息。
- **排查代理配置问题:** 查看 `PROXY_RESOLUTION_SERVICE` 相关的事件，以及 `GetNetInfo()` 中提供的代理配置信息。
- **诊断连接问题:** 查看 Socket Pool 相关的事件，例如 `SOCKET_POOL_CONNECT_JOB` 和 `TCP_CONNECT`。
- **了解 HTTP/2 或 QUIC 的使用情况:** 查看 SPDY 和 QUIC 相关的事件，以及 `GetNetInfo()` 中提供的协议状态信息。
- **跟踪特定请求的生命周期:** 通过请求 ID 关联相关的 NetLog 事件，从 `URL_REQUEST_START` 到 `URL_REQUEST_FINISHED`。

总之，`net_log_util.cc` 虽然是 C++ 代码，但它为 Chromium 的网络调试提供了至关重要的基础设施，其生成的数据被 JavaScript 驱动的开发者工具所使用，帮助开发者理解和解决各种网络问题。

Prompt: 
```
这是目录为net/log/net_log_util.cc的chromium 网络栈的源代码文件， 请列举一下它的功能, 
如果它与javascript的功能有关系，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索。

"""
// Copyright 2014 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "net/log/net_log_util.h"

#include <algorithm>
#include <string>
#include <utility>
#include <vector>

#include "base/check_op.h"
#include "base/feature_list.h"
#include "base/metrics/field_trial.h"
#include "base/strings/strcat.h"
#include "base/strings/string_number_conversions.h"
#include "base/strings/string_split.h"
#include "base/strings/string_util.h"
#include "base/time/time.h"
#include "base/values.h"
#include "net/base/address_family.h"
#include "net/base/load_states.h"
#include "net/base/net_errors.h"
#include "net/base/net_info_source_list.h"
#include "net/cert/cert_verifier.h"
#include "net/disk_cache/disk_cache.h"
#include "net/dns/host_cache.h"
#include "net/dns/host_resolver.h"
#include "net/dns/public/dns_query_type.h"
#include "net/dns/public/doh_provider_entry.h"
#include "net/dns/public/secure_dns_mode.h"
#include "net/http/http_cache.h"
#include "net/http/http_network_session.h"
#include "net/http/http_server_properties.h"
#include "net/http/http_transaction_factory.h"
#include "net/log/net_log_capture_mode.h"
#include "net/log/net_log_entry.h"
#include "net/log/net_log_event_type.h"
#include "net/log/net_log_values.h"
#include "net/log/net_log_with_source.h"
#include "net/proxy_resolution/proxy_config.h"
#include "net/proxy_resolution/proxy_resolution_service.h"
#include "net/proxy_resolution/proxy_retry_info.h"
#include "net/socket/ssl_client_socket.h"
#include "net/third_party/quiche/src/quiche/quic/core/quic_error_codes.h"
#include "net/third_party/quiche/src/quiche/quic/core/quic_packets.h"
#include "net/url_request/url_request.h"
#include "net/url_request/url_request_context.h"
#include "third_party/boringssl/src/pki/simple_path_builder_delegate.h"
#include "third_party/boringssl/src/pki/trust_store.h"

#if BUILDFLAG(ENABLE_REPORTING)
#include "net/network_error_logging/network_error_logging_service.h"
#include "net/reporting/reporting_service.h"
#endif  // BUILDFLAG(ENABLE_REPORTING)

namespace net {

namespace {

// This should be incremented when significant changes are made that will
// invalidate the old loading code.
const int kLogFormatVersion = 1;

struct StringToConstant {
  const char* name;
  const int constant;
};

const StringToConstant kCertStatusFlags[] = {
#define CERT_STATUS_FLAG(label, value) {#label, value},
#include "net/cert/cert_status_flags_list.h"
#undef CERT_STATUS_FLAG
};

const StringToConstant kLoadFlags[] = {
#define LOAD_FLAG(label, value) {#label, value},
#include "net/base/load_flags_list.h"
#undef LOAD_FLAG
};

const StringToConstant kLoadStateTable[] = {
#define LOAD_STATE(label, value) {#label, LOAD_STATE_##label},
#include "net/base/load_states_list.h"
#undef LOAD_STATE
};

const short kNetErrors[] = {
#define NET_ERROR(label, value) value,
#include "net/base/net_error_list.h"
#undef NET_ERROR
};

// Returns the disk cache backend for |context| if there is one, or NULL.
// Despite the name, can return an in memory "disk cache".
disk_cache::Backend* GetDiskCacheBackend(URLRequestContext* context) {
  if (!context->http_transaction_factory())
    return nullptr;

  HttpCache* http_cache = context->http_transaction_factory()->GetCache();
  if (!http_cache)
    return nullptr;

  return http_cache->GetCurrentBackend();
}

// Returns true if |request1| was created before |request2|.
bool RequestCreatedBefore(const URLRequest* request1,
                          const URLRequest* request2) {
  // Only supported when both requests have the same non-null NetLog.
  DCHECK(request1->net_log().net_log());
  DCHECK_EQ(request1->net_log().net_log(), request2->net_log().net_log());

  if (request1->creation_time() < request2->creation_time())
    return true;
  if (request1->creation_time() > request2->creation_time())
    return false;
  // If requests were created at the same time, sort by NetLogSource ID. Some
  // NetLog tests assume the returned order exactly matches creation order, even
  // creation times of two events are potentially the same.
  return request1->net_log().source().id < request2->net_log().source().id;
}

base::Value GetActiveFieldTrialList() {
  base::FieldTrial::ActiveGroups active_groups;
  base::FieldTrialList::GetActiveFieldTrialGroups(&active_groups);
  base::Value::List field_trial_groups;
  for (const auto& group : active_groups) {
    field_trial_groups.Append(group.trial_name + ":" + group.group_name);
  }
  return base::Value(std::move(field_trial_groups));
}

}  // namespace

base::Value::Dict GetNetConstants() {
  base::Value::Dict constants_dict;

  // Version of the file format.
  constants_dict.Set("logFormatVersion", kLogFormatVersion);

  // Add a dictionary with information on the relationship between event type
  // enums and their symbolic names.
  constants_dict.Set("logEventTypes", NetLog::GetEventTypesAsValue());

  // Add a dictionary with information about the relationship between CertStatus
  // flags and their symbolic names.
  {
    base::Value::Dict dict;

    for (const auto& flag : kCertStatusFlags)
      dict.Set(flag.name, flag.constant);

    constants_dict.Set("certStatusFlag", std::move(dict));
  }

  // Add a dictionary with information about the relationship between
  // CertVerifier::VerifyFlags and their symbolic names.
  {
    static_assert(CertVerifier::VERIFY_FLAGS_LAST == (1 << 0),
                  "Update with new flags");
    constants_dict.Set(
        "certVerifierFlags",
        base::Value::Dict().Set("VERIFY_DISABLE_NETWORK_FETCHES",
                                CertVerifier::VERIFY_DISABLE_NETWORK_FETCHES));
  }

  {
    static_assert(CertVerifyProc::VERIFY_FLAGS_LAST == (1 << 4),
                  "Update with new flags");
    constants_dict.Set(
        "certVerifyFlags",
        base::Value::Dict()
            .Set("VERIFY_REV_CHECKING_ENABLED",
                 CertVerifyProc::VERIFY_REV_CHECKING_ENABLED)
            .Set("VERIFY_REV_CHECKING_REQUIRED_LOCAL_ANCHORS",
                 CertVerifyProc::VERIFY_REV_CHECKING_REQUIRED_LOCAL_ANCHORS)
            .Set("VERIFY_ENABLE_SHA1_LOCAL_ANCHORS",
                 CertVerifyProc::VERIFY_ENABLE_SHA1_LOCAL_ANCHORS)
            .Set("VERIFY_DISABLE_SYMANTEC_ENFORCEMENT",
                 CertVerifyProc::VERIFY_DISABLE_SYMANTEC_ENFORCEMENT)
            .Set("VERIFY_DISABLE_NETWORK_FETCHES",
                 CertVerifyProc::VERIFY_DISABLE_NETWORK_FETCHES));
  }

  {
    static_assert(
        bssl::SimplePathBuilderDelegate::DigestPolicy::kMaxValue ==
            bssl::SimplePathBuilderDelegate::DigestPolicy::kWeakAllowSha1,
        "Update with new flags");

    constants_dict.Set(
        "certPathBuilderDigestPolicy",
        base::Value::Dict()
            .Set("kStrong",
                 static_cast<int>(
                     bssl::SimplePathBuilderDelegate::DigestPolicy::kStrong))
            .Set("kWeakAllowSha1",
                 static_cast<int>(bssl::SimplePathBuilderDelegate::
                                      DigestPolicy::kWeakAllowSha1)));
  }

  // Add a dictionary with information about the relationship between load flag
  // enums and their symbolic names.
  {
    base::Value::Dict dict;

    for (const auto& flag : kLoadFlags)
      dict.Set(flag.name, flag.constant);

    constants_dict.Set("loadFlag", std::move(dict));
  }

  // Add a dictionary with information about the relationship between load state
  // enums and their symbolic names.
  {
    base::Value::Dict dict;

    for (const auto& state : kLoadStateTable)
      dict.Set(state.name, state.constant);

    constants_dict.Set("loadState", std::move(dict));
  }

  // Add information on the relationship between net error codes and their
  // symbolic names.
  {
    base::Value::Dict dict;

    for (const auto& error : kNetErrors)
      dict.Set(ErrorToShortString(error), error);

    constants_dict.Set("netError", std::move(dict));
  }

  // Add information on the relationship between QUIC error codes and their
  // symbolic names.
  {
    base::Value::Dict dict;

    for (quic::QuicErrorCode error = quic::QUIC_NO_ERROR;
         error < quic::QUIC_LAST_ERROR;
         error = static_cast<quic::QuicErrorCode>(error + 1)) {
      dict.Set(QuicErrorCodeToString(error), static_cast<int>(error));
    }

    constants_dict.Set("quicError", std::move(dict));
  }

  // Add information on the relationship between QUIC RST_STREAM error codes
  // and their symbolic names.
  {
    base::Value::Dict dict;

    for (quic::QuicRstStreamErrorCode error = quic::QUIC_STREAM_NO_ERROR;
         error < quic::QUIC_STREAM_LAST_ERROR;
         error = static_cast<quic::QuicRstStreamErrorCode>(error + 1)) {
      dict.Set(QuicRstStreamErrorCodeToString(error), static_cast<int>(error));
    }

    constants_dict.Set("quicRstStreamError", std::move(dict));
  }

  // Information about the relationship between event phase enums and their
  // symbolic names.
  {
    constants_dict.Set(
        "logEventPhase",
        base::Value::Dict()
            .Set("PHASE_BEGIN", static_cast<int>(NetLogEventPhase::BEGIN))
            .Set("PHASE_END", static_cast<int>(NetLogEventPhase::END))
            .Set("PHASE_NONE", static_cast<int>(NetLogEventPhase::NONE)));
  }

  // Information about the relationship between source type enums and
  // their symbolic names.
  constants_dict.Set("logSourceType", NetLog::GetSourceTypesAsValue());

  // Information about the relationship between address family enums and
  // their symbolic names.
  {
    constants_dict.Set(
        "addressFamily",
        base::Value::Dict()
            .Set("ADDRESS_FAMILY_UNSPECIFIED", ADDRESS_FAMILY_UNSPECIFIED)
            .Set("ADDRESS_FAMILY_IPV4", ADDRESS_FAMILY_IPV4)
            .Set("ADDRESS_FAMILY_IPV6", ADDRESS_FAMILY_IPV6));
  }

  // Information about the relationship between DnsQueryType enums and their
  // symbolic names.
  {
    base::Value::Dict dict;
    for (const auto& type : kDnsQueryTypes) {
      dict.Set(type.second, static_cast<int>(type.first));
    }
    constants_dict.Set("dnsQueryType", std::move(dict));
  }

  // Information about the relationship between SecureDnsMode enums and their
  // symbolic names.
  {
    base::Value::Dict dict;
    for (const auto& mode : kSecureDnsModes) {
      dict.Set(mode.second, static_cast<int>(mode.first));
    }
    constants_dict.Set("secureDnsMode", std::move(dict));
  }

  // Information about how the "time ticks" values we have given it relate to
  // actual system times.  Time ticks are used throughout since they are stable
  // across system clock changes. Note: |timeTickOffset| is only comparable to
  // TimeTicks values in milliseconds.
  // TODO(csharrison): This is an imprecise way to convert TimeTicks to unix
  // time. In fact, there isn't really a good way to do this unless we log Time
  // and TimeTicks values side by side for every event. crbug.com/593157 tracks
  // a change where the user will be notified if a timing anomaly occured that
  // would skew the conversion (i.e. the machine entered suspend mode while
  // logging).
  {
    base::TimeDelta time_since_epoch =
        base::Time::Now() - base::Time::UnixEpoch();
    base::TimeDelta reference_time_ticks =
        base::TimeTicks::Now() - base::TimeTicks();
    int64_t tick_to_unix_time_ms =
        (time_since_epoch - reference_time_ticks).InMilliseconds();
    constants_dict.Set("timeTickOffset",
                       NetLogNumberValue(tick_to_unix_time_ms));
  }

  // TODO(eroman): Is this needed?
  // "clientInfo" key is required for some log readers. Provide a default empty
  // value for compatibility.
  constants_dict.Set("clientInfo", base::Value::Dict());

  // Add a list of field experiments active at the start of the capture.
  // Additional trials may be enabled later in the browser session.
  constants_dict.Set(kNetInfoFieldTrials, GetActiveFieldTrialList());

  return constants_dict;
}

NET_EXPORT base::Value::Dict GetNetInfo(URLRequestContext* context) {
  // May only be called on the context's thread.
  context->AssertCalledOnValidThread();

  base::Value::Dict net_info_dict =
      context->proxy_resolution_service()->GetProxyNetLogValues();

  // Log Host Resolver info.
  {
    HostResolver* host_resolver = context->host_resolver();
    DCHECK(host_resolver);
    HostCache* cache = host_resolver->GetHostCache();
    if (cache) {
      base::Value::List cache_contents_list;
      cache->GetList(cache_contents_list, true /* include_staleness */,
                     HostCache::SerializationType::kDebug);

      net_info_dict.Set(
          kNetInfoHostResolver,
          base::Value::Dict()
              .Set("dns_config", host_resolver->GetDnsConfigAsValue())
              .Set("cache",
                   base::Value::Dict()
                       .Set("capacity", static_cast<int>(cache->max_entries()))
                       .Set("network_changes", cache->network_changes())
                       .Set("entries", std::move(cache_contents_list))));
    }

    // Construct a list containing the names of the disabled DoH providers.
    base::Value::List disabled_doh_providers_list;
    for (const DohProviderEntry* provider : DohProviderEntry::GetList()) {
      if (!base::FeatureList::IsEnabled(provider->feature.get())) {
        disabled_doh_providers_list.Append(
            NetLogStringValue(provider->provider));
      }
    }
    net_info_dict.Set(kNetInfoDohProvidersDisabledDueToFeature,
                      base::Value(std::move(disabled_doh_providers_list)));
  }

  HttpNetworkSession* http_network_session =
      context->http_transaction_factory()->GetSession();

  // Log Socket Pool info.
  {
    net_info_dict.Set(kNetInfoSocketPool,
                      http_network_session->SocketPoolInfoToValue());
  }

  // Log SPDY Sessions.
  {
    net_info_dict.Set(kNetInfoSpdySessions,
                      base::Value::FromUniquePtrValue(
                          http_network_session->SpdySessionPoolInfoToValue()));
  }

  // Log SPDY status.
  {
    base::Value::Dict status_dict;

    status_dict.Set("enable_http2",
                    http_network_session->params().enable_http2);

    const NextProtoVector& alpn_protos = http_network_session->GetAlpnProtos();
    if (!alpn_protos.empty()) {
      std::string next_protos_string;
      for (NextProto proto : alpn_protos) {
        if (!next_protos_string.empty())
          next_protos_string.append(",");
        next_protos_string.append(NextProtoToString(proto));
      }
      status_dict.Set("alpn_protos", next_protos_string);
    }

    const SSLConfig::ApplicationSettings& application_settings =
        http_network_session->GetApplicationSettings();
    if (!application_settings.empty()) {
      base::Value::Dict application_settings_dict;
      for (const auto& setting : application_settings) {
        application_settings_dict.Set(NextProtoToString(setting.first),
                                      base::HexEncode(setting.second));
      }
      status_dict.Set("application_settings",
                      std::move(application_settings_dict));
    }

    net_info_dict.Set(kNetInfoSpdyStatus, std::move(status_dict));
  }

  // Log ALT_SVC mappings.
  {
    const HttpServerProperties& http_server_properties =
        *context->http_server_properties();
    net_info_dict.Set(
        kNetInfoAltSvcMappings,
        http_server_properties.GetAlternativeServiceInfoAsValue());
  }

  // Log QUIC info.
  { net_info_dict.Set(kNetInfoQuic, http_network_session->QuicInfoToValue()); }

  // Log HTTP Cache info.
  {
    base::Value::Dict info_dict;
    base::Value::Dict stats_dict;

    disk_cache::Backend* disk_cache = GetDiskCacheBackend(context);

    if (disk_cache) {
      // Extract the statistics key/value pairs from the backend.
      base::StringPairs stats;
      disk_cache->GetStats(&stats);
      for (auto& stat : stats) {
        stats_dict.Set(stat.first, std::move(stat.second));
      }
    }
    info_dict.Set("stats", std::move(stats_dict));

    net_info_dict.Set(kNetInfoHTTPCache, std::move(info_dict));
  }

  // Log Reporting API info.
  {
#if BUILDFLAG(ENABLE_REPORTING)
    ReportingService* reporting_service = context->reporting_service();
    if (reporting_service) {
      base::Value reporting_value = reporting_service->StatusAsValue();
      NetworkErrorLoggingService* network_error_logging_service =
          context->network_error_logging_service();
      if (network_error_logging_service) {
        reporting_value.GetDict().Set(
            "networkErrorLogging",
            network_error_logging_service->StatusAsValue());
      }
      net_info_dict.Set(kNetInfoReporting, std::move(reporting_value));
    } else {
      net_info_dict.Set(kNetInfoReporting,
                        base::Value::Dict().Set("reportingEnabled", false));
    }

#else   // BUILDFLAG(ENABLE_REPORTING)
    net_info_dict.Set(kNetInfoReporting,
                      base::Value::Dict().Set("reportingEnabled", false));
#endif  // BUILDFLAG(ENABLE_REPORTING)
  }

  // Log currently-active field trials. New trials may have been enabled since
  // the start of this browser session (crbug.com/1133396).
  net_info_dict.Set(kNetInfoFieldTrials, GetActiveFieldTrialList());

  return net_info_dict;
}

NET_EXPORT void CreateNetLogEntriesForActiveObjects(
    const std::set<URLRequestContext*>& contexts,
    NetLog::ThreadSafeObserver* observer) {
  // Put together the list of all requests.
  std::vector<const URLRequest*> requests;
  for (auto* context : contexts) {
    // May only be called on the context's thread.
    context->AssertCalledOnValidThread();
    // Contexts should all be using the same NetLog.
    DCHECK_EQ((*contexts.begin())->net_log(), context->net_log());
    for (const URLRequest* request : *context->url_requests()) {
      requests.push_back(request);
    }
  }

  // Sort by creation time.
  std::sort(requests.begin(), requests.end(), RequestCreatedBefore);

  // Create fake events.
  for (auto* request : requests) {
    NetLogEntry entry(NetLogEventType::REQUEST_ALIVE,
                      request->net_log().source(), NetLogEventPhase::BEGIN,
                      request->creation_time(), request->GetStateAsValue());
    observer->OnAddEntry(entry);
  }
}

}  // namespace net

"""

```
Response:
Let's break down the thought process for analyzing this C++ code and answering the prompt's questions.

**1. Understanding the Core Purpose:**

The first step is to read the code and identify its primary function. The class name `QuicTestPacketPrinter` and the method `PrintWrite` are strong hints. The `#include "net/quic/quic_test_packet_printer.h"` confirms this is a testing utility within the QUIC implementation of Chromium's network stack.

The `PrintWrite` method takes raw packet data (`std::string& data`) and processes it using a `QuicFramer`. The `QuicFramer` is a key component of the QUIC implementation responsible for parsing and interpreting QUIC packets. The output is then captured in an `std::ostringstream`.

This immediately suggests the file's purpose: to take raw QUIC packet data and generate a human-readable textual representation of its contents by parsing it with the `QuicFramer` and using a custom visitor.

**2. Deconstructing the `QuicPacketPrinter` Class:**

Next, analyze the `QuicPacketPrinter` class. It inherits from `QuicFramerVisitorInterface`. This is crucial. It tells us that this class is designed to *react* to events triggered by the `QuicFramer` as it parses a packet. Each `On...` method corresponds to a specific part of the QUIC packet structure or a parsing event.

For each `On...` method, observe what it does. Most methods simply output a descriptive string to the provided `std::ostream* output_`, often including details extracted from the parsed data. This confirms the "printing" aspect of the class.

**3. Identifying Key Components and Concepts:**

As you analyze the `On...` methods, note the important QUIC concepts being referenced:

* **Packet Headers:** `OnUnauthenticatedPublicHeader`, `OnUnauthenticatedHeader`, `OnPacketHeader`
* **Frame Types:** `OnStreamFrame`, `OnCryptoFrame`, `OnAckFrameStart/Range/End`, `OnConnectionCloseFrame`, etc.
* **Encryption:** `OnDecryptedPacket`, `OnUndecryptablePacket`, `AdvanceKeysAndCreateCurrentOneRttDecrypter`, `CreateCurrentOneRttEncrypter`
* **Connection Management:** `OnVersionNegotiationPacket`, `OnRetryPacket`, `OnNewConnectionIdFrame`, `OnRetireConnectionIdFrame`
* **Error Handling:** `OnError`

Recognizing these concepts is essential for understanding the depth of the printer's capabilities.

**4. Addressing the Prompt's Specific Questions:**

Now, armed with an understanding of the code, address each part of the prompt:

* **Functionality:**  Summarize the core purpose (described in step 1) and then list the specific functionalities revealed by the `On...` methods (printing details about different packet components).

* **Relationship with JavaScript:** This requires thinking about where QUIC fits within a browser context. QUIC is a transport protocol used *underneath* the hood for network communication. JavaScript in a web browser interacts with network requests at a higher level (e.g., using `fetch` or `XMLHttpRequest`). Therefore, while JavaScript *triggers* the network activity that *might* use QUIC, it doesn't directly interact with the packet-level details that this code handles. The connection is indirect. Provide an example to illustrate this (e.g., a `fetch` request leading to QUIC traffic).

* **Logical Reasoning (Input/Output):** The `PrintWrite` method is the entry point. The input is a raw byte string (representing the QUIC packet). The output is a string containing the human-readable representation generated by the `QuicPacketPrinter`. Create a simple example with a likely packet type (like a STREAM frame) and show the corresponding output based on the `OnStreamFrame` method's behavior. *Initial thought: Could I create a *real* QUIC packet?  Probably overkill for this exercise. Focus on illustrating the printer's output based on the code.*

* **User/Programming Errors:** Consider scenarios where the parsing might fail or produce unexpected output. Common QUIC-related errors involve incorrect packet formatting, version mismatches, or decryption issues. Map these to the error handling and informational outputs of the `QuicPacketPrinter` (e.g., `OnError`, `OnProtocolVersionMismatch`, `OnUndecryptablePacket`). Provide concrete examples.

* **User Steps to Reach Here (Debugging):** Think about the typical flow of network debugging. Users usually don't interact with raw QUIC packets directly. This tool is for developers. The steps would involve:
    1. Identifying a network issue.
    2. Using network inspection tools (like Chrome DevTools) and seeing QUIC being used.
    3. Needing to understand the *contents* of the QUIC packets.
    4. Potentially using internal Chromium debugging tools or writing a test that utilizes this `QuicTestPacketPrinter` to examine the packets.

**5. Refining and Structuring the Answer:**

Finally, organize the information logically, using clear headings and bullet points for readability. Ensure the examples are concise and illustrate the points effectively. Use the terminology from the code (e.g., `QuicFramer`, `OnStreamFrame`). Double-check for accuracy and completeness based on the code analysis.
这个C++源代码文件 `net/quic/quic_test_packet_printer.cc` 的主要功能是**提供一个工具，用于将 QUIC 数据包的内容以人类可读的格式打印出来，主要用于测试和调试目的。**  它通过模拟 QUIC 帧解析器的行为，并使用一个自定义的访问器来记录解析过程中遇到的各种事件和数据。

让我们详细分解其功能，并解答您提出的问题：

**1. 功能列举:**

* **解析 QUIC 数据包:**  `QuicPacketPrinter::PrintWrite` 方法接收一个包含 QUIC 数据包原始字节的字符串 (`data`)，并使用 `QuicFramer` 对其进行解析。`QuicFramer` 是 Chromium QUIC 栈中用于解析 QUIC 帧的核心组件。
* **自定义解析事件处理:** `QuicPacketPrinter` 类实现了 `QuicFramerVisitorInterface` 接口。这个接口定义了一系列在解析过程中会被 `QuicFramer` 调用的回调函数（以 `On...` 开头）。`QuicPacketPrinter` 通过重写这些回调函数，来记录解析过程中发生的各种事件，例如：
    * 遇到错误 (`OnError`)
    * 协议版本不匹配 (`OnProtocolVersionMismatch`)
    * 解析到不同类型的 QUIC 帧 (例如 `OnStreamFrame`, `OnCryptoFrame`, `OnAckFrame`, `OnConnectionCloseFrame` 等)
    * 处理加密和解密事件 (`OnDecryptedPacket`, `OnUndecryptablePacket`)
    * 处理连接管理相关的帧 (`OnNewConnectionIdFrame`, `OnRetireConnectionIdFrame`)
* **打印解析结果:**  每个被重写的 `On...` 回调函数都将相关信息输出到一个 `std::ostream` 对象 (`output_`)。这些信息包括事件类型和与该事件相关的数据（例如，帧的类型、ID、长度、内容等）。
* **支持加密和解密模拟:**  在 `PrintWrite` 方法中，它会根据 QUIC 版本安装或设置一个 `TaggingDecrypter`。这允许在测试中模拟数据包的解密过程，即使实际的数据并没有被真正的密钥解密。
* **用于单元测试:**  这个类通常用于 QUIC 协议栈的单元测试中，以便验证 QUIC 数据包的生成、解析和处理逻辑是否正确。

**2. 与 JavaScript 的关系及举例:**

这个 C++ 文件本身并不直接与 JavaScript 代码交互。它属于 Chromium 浏览器的底层网络栈实现。然而，它的功能间接地与 JavaScript 的行为有关，因为：

* **JavaScript 发起的网络请求可能使用 QUIC:** 当用户在浏览器中通过 JavaScript（例如使用 `fetch` API 或 `XMLHttpRequest`）发起一个网络请求时，浏览器可能会选择使用 QUIC 协议进行传输（如果服务器支持且条件允许）。
* **此工具可以帮助调试由 JavaScript 触发的 QUIC 连接问题:**  如果一个使用 QUIC 的网络请求出现问题，开发人员可以使用 Chromium 提供的内部工具或编写测试用例，来捕获并分析底层的 QUIC 数据包。`QuicTestPacketPrinter` 可以被用来将这些捕获到的原始数据包打印成可读的格式，帮助开发人员理解数据包的内容，从而定位问题。

**举例说明:**

假设一个网页的 JavaScript 代码使用 `fetch` API 向服务器请求一个资源：

```javascript
fetch('https://example.com/data.json')
  .then(response => response.json())
  .then(data => console.log(data));
```

如果这个请求使用了 QUIC 协议，并且在传输过程中遇到了问题（例如，数据包丢失、连接中断），那么开发人员可能需要查看底层 QUIC 数据包的细节。他们可能会使用 Chromium 的网络抓包工具（如 `chrome://webrtc-internals/` 或外部工具）来捕获数据包。然后，他们可以编写一个 C++ 单元测试，使用 `QuicTestPacketPrinter` 来解析这些捕获到的数据包，查看其中包含的帧信息，例如：

```c++
#include "net/quic/quic_test_packet_printer.h"
#include "testing/gtest/include/gtest/gtest.h"

namespace net {

TEST(MyQuicTest, PrintCapturedPacket) {
  // 假设 captured_packet_data 是从网络抓包工具中获取的原始 QUIC 数据包
  std::string captured_packet_data = "...原始 QUIC 数据包的十六进制表示...";

  QuicTestPacketPrinter printer(net::ParsedQuicVersion::RFCv1);
  std::string output = printer.PrintWrite(captured_packet_data);
  // 输出包含了对数据包内容的详细描述
  EXPECT_NE(output, "");
  std::cout << output << std::endl;
}

} // namespace net
```

这个测试用例会调用 `QuicTestPacketPrinter::PrintWrite`，并将捕获到的数据包内容打印出来，开发者可以从中看到是否有错误帧、重传帧或其他异常情况。

**3. 逻辑推理 (假设输入与输出):**

**假设输入:** 一个简单的 QUIC STREAM 帧数据包，包含一些文本数据 "Hello, QUIC!". 为了简化，我们假设这是一个已经解密的、可以直接解析的帧。

**构造一个简化的假设输入 (实际的 QUIC 数据包结构会更复杂):**

假设经过简化，STREAM 帧的表示包含：
* 帧类型标识符 (假设为 `0x08` 表示 STREAM 帧)
* Stream ID (假设为 `0x01`)
* Offset (假设为 `0x00`)
* Length (假设为 `0x0c` 表示 12 字节)
* 数据内容 ( "Hello, QUIC!" 的 ASCII 编码)

将这些组合成一个十六进制字符串： `08 01 00 00 00 0c 48 65 6c 6c 6f 2c 20 51 55 49 43 21`

**预期输出 (基于代码逻辑):**

```
OnPacket
OnUnauthenticatedPublicHeader: [/* 这里会显示一些通用的包头信息，但由于是假设输入，无法精确给出 */]
OnUnauthenticatedHeader: [/* 这里会显示一些通用的包头信息，但由于是假设输入，无法精确给出 */]
OnPacketHeader
OnCoalescedPacket
OnDecryptedPacket
OnStreamFrame: stream_id:1, fin:false, offset:0, length:12
         data: { 48656c6c6f2c205155494321 }
OnPacketComplete
```

**解释:**

* `OnPacket`, `OnUnauthenticatedPublicHeader`, `OnUnauthenticatedHeader`, `OnPacketHeader`, `OnCoalescedPacket`, `OnDecryptedPacket`, `OnPacketComplete`: 这些是 `QuicFramer` 在解析数据包时会触发的通用事件。
* `OnStreamFrame`:  这是因为我们假设输入包含一个 STREAM 帧。输出会显示 Stream ID、是否是 FIN 帧、偏移量和数据长度。
* `data`:  会以十六进制格式打印 STREAM 帧的数据内容。

**4. 用户或编程常见的使用错误:**

* **传递了非法的 QUIC 数据包:**  如果传递给 `PrintWrite` 的字符串不是一个有效的 QUIC 数据包，`QuicFramer` 在解析时可能会遇到错误，从而触发 `OnError` 回调。输出会包含错误码和详细信息，例如 "OnError: QUIC_INVALID_PACKET_HEADER detail: Failed to parse public flags."
* **使用了错误的 QUIC 版本:**  `PrintWrite` 方法会根据传入的 `ParsedQuicVersion` 创建 `QuicFramer`。如果传入的版本与数据包的实际版本不匹配，可能会触发 `OnProtocolVersionMismatch` 回调，或者导致解析错误。
* **未考虑加密:**  如果数据包是被加密的，但 `QuicFramer` 没有配置正确的解密器，`OnUndecryptablePacket` 回调会被触发。`QuicTestPacketPrinter` 默认使用 `TaggingDecrypter`，这只是一个占位符用于测试，并不会真正解密数据。如果需要解析实际加密的数据包，需要提供正确的解密逻辑。
* **假设数据包总是完整的:**  在某些情况下，可能会捕获到不完整的数据包片段。`QuicFramer` 在解析不完整的数据包时可能会报错。

**例子:**

* **错误的 QUIC 数据包:** 如果 `captured_packet_data` 是一个完全随机的字符串，例如 `"abcdefg"`,  输出可能会包含 `OnError: QUIC_INVALID_PACKET_HEADER ...`。
* **版本不匹配:** 如果 `QuicTestPacketPrinter` 使用的版本与数据包的版本不一致，可能会看到 `OnProtocolVersionMismatch: ...` 的输出。
* **未解密的数据包:** 如果传入的是一个加密的数据包，且没有设置真正的解密器，输出可能会包含 `OnUndecryptablePacket, decryption_level: ...`。

**5. 用户操作是如何一步步到达这里，作为调试线索:**

以下是一些可能的用户操作步骤，最终导致需要查看 `net/quic/quic_test_packet_printer.cc` 的输出：

1. **用户在浏览器中访问一个网站，该网站使用 QUIC 协议。**
2. **用户遇到网络连接问题，例如页面加载缓慢、请求失败等。**
3. **开发人员或高级用户怀疑是 QUIC 协议层的问题。**
4. **使用 Chromium 提供的网络调试工具（如 `chrome://net-export/` 或 `chrome://webrtc-internals/`）抓取网络日志或 QUIC 事件。**
5. **在抓取的日志或事件中，可能会看到与 QUIC 连接相关的错误或异常信息。**
6. **为了更深入地了解问题，开发人员可能需要查看实际的 QUIC 数据包内容。**
7. **开发人员可以使用 Chromium 内部的测试工具或编写单元测试来解析和打印这些数据包。** 这时就会用到 `net/quic/quic_test_packet_printer.cc` 提供的功能。
8. **开发人员可能会编写一个类似的测试用例，将捕获到的原始数据包数据传递给 `QuicTestPacketPrinter::PrintWrite` 方法。**
9. **查看 `PrintWrite` 方法的输出，可以了解数据包的结构、帧类型、内容以及解析过程中发生的事件，从而帮助定位网络问题的根源。**

**例如，一个具体的调试场景：**

用户报告一个使用了 QUIC 的网站在弱网络环境下加载失败。开发人员可能会：

1. 使用 `chrome://net-export/` 抓取用户复现问题的网络日志。
2. 在日志中找到与该网站 QUIC 连接相关的事件，例如连接建立失败、数据包丢失过多等。
3. 从日志中提取出有问题的 QUIC 数据包的原始字节数据。
4. 创建一个 C++ 单元测试，包含以下步骤：
   * 包含 `net/quic/quic_test_packet_printer.h`。
   * 创建一个 `QuicTestPacketPrinter` 实例。
   * 将提取出的原始数据包数据传递给 `printer.PrintWrite()`。
   * 将输出结果打印到控制台或日志文件中。
5. 分析 `PrintWrite` 的输出，例如，可能会发现大量的重传帧 (`OnStreamFrame` 事件频繁出现)，或者发现连接关闭帧 (`OnConnectionCloseFrame`)，从而推断出是弱网络导致的数据包丢失和连接不稳定。

总而言之，`net/quic/quic_test_packet_printer.cc` 是一个内部的测试和调试工具，它帮助开发人员理解 QUIC 数据包的结构和内容，从而诊断和解决与 QUIC 协议相关的网络问题。它间接地服务于用户，通过确保浏览器网络栈的稳定性和性能。

Prompt: 
```
这是目录为net/quic/quic_test_packet_printer.cc的chromium 网络栈的源代码文件， 请列举一下它的功能, 
如果它与javascript的功能有关系，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索。

"""
// Copyright 2019 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "net/quic/quic_test_packet_printer.h"
#include "base/memory/raw_ptr.h"

#include <ostream>

#include "base/strings/string_number_conversions.h"
#include "net/third_party/quiche/src/quiche/quic/core/quic_framer.h"
#include "net/third_party/quiche/src/quiche/quic/core/quic_utils.h"
#include "net/third_party/quiche/src/quiche/quic/platform/api/quic_flags.h"
#include "net/third_party/quiche/src/quiche/quic/test_tools/quic_test_utils.h"

namespace quic {

namespace {

class QuicPacketPrinter : public QuicFramerVisitorInterface {
 public:
  explicit QuicPacketPrinter(QuicFramer* framer, std::ostream* output)
      : framer_(framer), output_(output) {}

  // QuicFramerVisitorInterface implementation.
  void OnError(QuicFramer* framer) override {
    *output_ << "OnError: " << QuicErrorCodeToString(framer->error())
             << " detail: " << framer->detailed_error() << "\n";
  }
  bool OnProtocolVersionMismatch(ParsedQuicVersion received_version) override {
    framer_->set_version(received_version);
    *output_ << "OnProtocolVersionMismatch: "
             << ParsedQuicVersionToString(received_version) << "\n";
    return true;
  }
  void OnPacket() override { *output_ << "OnPacket\n"; }
  void OnVersionNegotiationPacket(
      const QuicVersionNegotiationPacket& packet) override {
    *output_ << "OnVersionNegotiationPacket\n";
  }
  void OnRetryPacket(QuicConnectionId original_connection_id,
                     QuicConnectionId new_connection_id,
                     std::string_view retry_token,
                     std::string_view retry_integrity_tag,
                     std::string_view retry_without_tag) override {
    *output_ << "OnRetryPacket\n";
  }
  bool OnUnauthenticatedPublicHeader(const QuicPacketHeader& header) override {
    *output_ << "OnUnauthenticatedPublicHeader: " << header;
    return true;
  }
  bool OnUnauthenticatedHeader(const QuicPacketHeader& header) override {
    *output_ << "OnUnauthenticatedHeader: " << header;
    return true;
  }
  void OnDecryptedPacket(size_t length, EncryptionLevel level) override {
    *output_ << "OnDecryptedPacket\n";
  }
  bool OnPacketHeader(const QuicPacketHeader& header) override {
    *output_ << "OnPacketHeader\n";
    return true;
  }
  void OnCoalescedPacket(const QuicEncryptedPacket& packet) override {
    *output_ << "OnCoalescedPacket\n";
  }
  void OnUndecryptablePacket(const QuicEncryptedPacket& packet,
                             EncryptionLevel decryption_level,
                             bool has_decryption_key) override {
    *output_ << "OnUndecryptablePacket, decryption_level: " << decryption_level
             << "\n";
  }
  bool OnStreamFrame(const QuicStreamFrame& frame) override {
    *output_ << "OnStreamFrame: " << frame;
    *output_ << "         data: { "
             << base::HexEncode(frame.data_buffer, frame.data_length) << " }\n";
    return true;
  }
  bool OnCryptoFrame(const QuicCryptoFrame& frame) override {
    *output_ << "OnCryptoFrame: " << frame;
    *output_ << "         data: { "
             << base::HexEncode(frame.data_buffer, frame.data_length) << " }\n";
    return true;
  }
  bool OnAckFrameStart(QuicPacketNumber largest_acked,
                       QuicTime::Delta /*ack_delay_time*/) override {
    *output_ << "OnAckFrameStart, largest_acked: " << largest_acked << "\n";
    return true;
  }
  bool OnAckRange(QuicPacketNumber start, QuicPacketNumber end) override {
    *output_ << "OnAckRange: [" << start << ", " << end << ")\n";
    return true;
  }
  bool OnAckTimestamp(QuicPacketNumber packet_number,
                      QuicTime timestamp) override {
    *output_ << "OnAckTimestamp: [" << packet_number << ", "
             << timestamp.ToDebuggingValue() << ")\n";
    return true;
  }
  bool OnAckFrameEnd(QuicPacketNumber start,
                     const std::optional<QuicEcnCounts>& ecn_counts) override {
    *output_ << "OnAckFrameEnd, start: " << start << ", "
             << ecn_counts.value_or(QuicEcnCounts()).ToString() << "\n";
    return true;
  }
  bool OnStopWaitingFrame(const QuicStopWaitingFrame& frame) override {
    *output_ << "OnStopWaitingFrame: " << frame;
    return true;
  }
  bool OnPaddingFrame(const QuicPaddingFrame& frame) override {
    *output_ << "OnPaddingFrame: " << frame;
    return true;
  }
  bool OnPingFrame(const QuicPingFrame& frame) override {
    *output_ << "OnPingFrame\n";
    return true;
  }
  bool OnRstStreamFrame(const QuicRstStreamFrame& frame) override {
    *output_ << "OnRstStreamFrame: " << frame;
    return true;
  }
  bool OnConnectionCloseFrame(const QuicConnectionCloseFrame& frame) override {
    // The frame printout will indicate whether it's a Google QUIC
    // CONNECTION_CLOSE, IETF QUIC CONNECTION_CLOSE/Transport, or IETF QUIC
    // CONNECTION_CLOSE/Application frame.
    *output_ << "OnConnectionCloseFrame: " << frame;
    return true;
  }
  bool OnNewConnectionIdFrame(const QuicNewConnectionIdFrame& frame) override {
    *output_ << "OnNewConnectionIdFrame: " << frame;
    return true;
  }
  bool OnRetireConnectionIdFrame(
      const QuicRetireConnectionIdFrame& frame) override {
    *output_ << "OnRetireConnectionIdFrame: " << frame;
    return true;
  }
  bool OnNewTokenFrame(const QuicNewTokenFrame& frame) override {
    *output_ << "OnNewTokenFrame: " << frame;
    return true;
  }
  bool OnStopSendingFrame(const QuicStopSendingFrame& frame) override {
    *output_ << "OnStopSendingFrame: " << frame;
    return true;
  }
  bool OnPathChallengeFrame(const QuicPathChallengeFrame& frame) override {
    *output_ << "OnPathChallengeFrame: " << frame;
    return true;
  }
  bool OnPathResponseFrame(const QuicPathResponseFrame& frame) override {
    *output_ << "OnPathResponseFrame: " << frame;
    return true;
  }
  bool OnGoAwayFrame(const QuicGoAwayFrame& frame) override {
    *output_ << "OnGoAwayFrame: " << frame;
    return true;
  }
  bool OnMaxStreamsFrame(const QuicMaxStreamsFrame& frame) override {
    *output_ << "OnMaxStreamsFrame: " << frame;
    return true;
  }
  bool OnStreamsBlockedFrame(const QuicStreamsBlockedFrame& frame) override {
    *output_ << "OnStreamsBlockedFrame: " << frame;
    return true;
  }
  void OnKeyUpdate(KeyUpdateReason reason) override {
    *output_ << "OnKeyUpdate: " << reason << "\n";
  }
  void OnDecryptedFirstPacketInKeyPhase() override {
    *output_ << "OnDecryptedFirstPacketInKeyPhase\n";
  }
  std::unique_ptr<QuicDecrypter> AdvanceKeysAndCreateCurrentOneRttDecrypter()
      override {
    *output_ << "AdvanceKeysAndCreateCurrentOneRttDecrypter\n";
    return nullptr;
  }
  std::unique_ptr<QuicEncrypter> CreateCurrentOneRttEncrypter() override {
    *output_ << "CreateCurrentOneRttEncrypter\n";
    return nullptr;
  }
  bool OnWindowUpdateFrame(const QuicWindowUpdateFrame& frame) override {
    *output_ << "OnWindowUpdateFrame: " << frame;
    return true;
  }
  bool OnBlockedFrame(const QuicBlockedFrame& frame) override {
    *output_ << "OnBlockedFrame: " << frame;
    return true;
  }
  bool OnMessageFrame(const QuicMessageFrame& frame) override {
    *output_ << "OnMessageFrame: " << frame;
    // In a test context, `frame.data` should always be set.
    CHECK(frame.data);
    *output_ << "         data: { "
             << base::HexEncode(frame.data, frame.message_length) << " }\n";
    return true;
  }
  bool OnHandshakeDoneFrame(const QuicHandshakeDoneFrame& frame) override {
    *output_ << "OnHandshakeDoneFrame: " << frame;
    return true;
  }
  bool OnAckFrequencyFrame(const QuicAckFrequencyFrame& frame) override {
    *output_ << "OnAckFrequencyFrame: " << frame;
    return true;
  }
  bool OnResetStreamAtFrame(const QuicResetStreamAtFrame& frame) override {
    *output_ << "OnResetStreamAtFrame: " << frame;
    return true;
  }
  void OnPacketComplete() override { *output_ << "OnPacketComplete\n"; }
  bool IsValidStatelessResetToken(
      const StatelessResetToken& token) const override {
    *output_ << "IsValidStatelessResetToken\n";
    return false;
  }
  void OnAuthenticatedIetfStatelessResetPacket(
      const QuicIetfStatelessResetPacket& packet) override {
    *output_ << "OnAuthenticatedIetfStatelessResetPacket\n";
  }

 private:
  raw_ptr<QuicFramer> framer_;  // Unowned.
  mutable raw_ptr<std::ostream> output_;
};

}  // namespace

}  // namespace quic

namespace net {

std::string QuicPacketPrinter::PrintWrite(const std::string& data) {
  quic::ParsedQuicVersionVector versions = {version_};
  // Fake a time since we're not actually generating acks.
  quic::QuicTime start(quic::QuicTime::Zero());
  // Construct a server framer as this will be processing packets from
  // the client.
  quic::QuicFramer framer(versions, start, quic::Perspective::IS_SERVER,
                          quic::kQuicDefaultConnectionIdLength);
  std::ostringstream stream;
  quic::QuicPacketPrinter visitor(&framer, &stream);
  framer.set_visitor(&visitor);

  if (version_.KnowsWhichDecrypterToUse()) {
    framer.InstallDecrypter(
        quic::ENCRYPTION_FORWARD_SECURE,
        std::make_unique<quic::test::TaggingDecrypter>());  // IN-TEST
  } else {
    framer.SetDecrypter(
        quic::ENCRYPTION_FORWARD_SECURE,
        std::make_unique<quic::test::TaggingDecrypter>());  // IN-TEST
  }

  quic::QuicEncryptedPacket encrypted(data.c_str(), data.length());
  framer.ProcessPacket(encrypted);
  return stream.str() + "\n\n";
}

}  // namespace net

"""

```
Response: The user wants a summary of the C++ code provided, focusing on its functionality and relating it to JavaScript RegExp behavior with examples. This is part 2 of 2, implying the previous part likely covered other aspects of regular expression testing.

**Plan:**

1. **Identify the main themes:**  Look for distinct test categories or features being exercised in the code. Keywords like `TEST_F`, class names, and function names will be helpful.
2. **Summarize each theme:**  For each identified theme, explain what the code is testing. Focus on the core functionality being verified.
3. **Connect to JavaScript (if applicable):** For each theme, determine if it relates to JavaScript's regular expression features. If so, provide a concise JavaScript example that demonstrates the corresponding concept.
4. **Pay attention to flags:** Note the use of flags like `v8_flags.regexp_peephole_optimization` and `v8_flags.regexp_tier_up` as they indicate specific optimizations or features being tested.
5. **Structure the summary:** Organize the summary logically, perhaps by the order the themes appear in the code. Use clear headings and bullet points.
This part of the `regexp-unittest.cc` file focuses on testing specific aspects of V8's regular expression implementation, particularly around bytecode generation, peephole optimizations, and interactions with the JavaScript environment.

Here's a breakdown of its functionality:

**1. Testing `RegExp.prototype.toString` behavior:**

*   This section verifies that calling `RegExp.prototype.toString` on non-RegExp objects (specifically `null`) throws a `TypeError` as expected in JavaScript.
*   It also checks the internal counters (`use_counts`) to ensure that the correct internal getter and toString methods are being invoked.

    ```javascript
    // JavaScript Example demonstrating the error case:
    try {
      RegExp.prototype.toString.call(null);
    } catch (e) {
      console.log(e instanceof TypeError); // Output: true
    }
    ```

**2. Testing handling of uncached external strings:**

*   This test checks how regular expressions behave when matching against strings that are stored externally and are not cached.
*   It creates an `UncachedExternalStringResource` and uses it in a regex match.
*   The goal is to ensure that the matching works correctly even when the string's contents aren't readily available in the usual cached manner.

    ```javascript
    // JavaScript Example (conceptual - you can't directly create uncached external strings in JS):
    const externalString = { // Simulating an external string
      data: "abcdefghijklmnopqrstuvwxyz",
      length: 26
    };
    const re = /y(.)/;
    console.log(re.test(externalString.data.substring(1))); // Output: true
    console.log(externalString.data.substring(1).match(re)[1]); // Output: "z"
    ```

**3. Testing RegExp bytecode peephole optimizations:**

*   A significant portion of this code focuses on testing "peephole optimizations" in the regular expression bytecode generator. These are small, local optimizations applied to the generated bytecode to improve performance.
*   Several test cases are defined, each creating specific sequences of bytecode instructions (`CreatePeephole...Bytecode` functions).
*   The tests compare the generated bytecode with and without the peephole optimization flag enabled (`v8_flags.regexp_peephole_optimization`).
*   The tests check if the optimized bytecode is shorter and performs the equivalent operation.
*   Examples of optimizations being tested include:
    *   `PeepholeNoChange`: Checks a scenario where no optimization is expected.
    *   `PeepholeSkipUntilChar`: Optimizes a loop that skips characters until a specific character is found.
    *   `PeepholeSkipUntilBitInTable`: Optimizes skipping until a character belonging to a specific character class (represented by a bit table) is found.
    *   `PeepholeSkipUntilCharPosChecked`: Similar to `SkipUntilChar`, but with additional checks on the current position.
    *   `PeepholeSkipUntilCharAnd`: Optimizes skipping until a character matches a specific character and another condition (bitwise AND).
    *   `PeepholeSkipUntilCharOrChar`: Optimizes skipping until one of two specific characters is found.
    *   `PeepholeSkipUntilGtOrNotBitInTable`: Optimizes skipping based on a greater-than comparison or the absence of a character in a bit table.
*   The tests also verify that label fixups (adjusting jump addresses in the bytecode) work correctly after these optimizations.

    ```javascript
    // JavaScript Example illustrating a concept related to peephole optimization (though not directly controllable):
    const text = "---x---";
    const re1 = /.*?x/; // Potentially less optimized
    const re2 = /[^x]*?x/; // Potentially more optimized (conceptually similar to some peephole optimizations)
    console.log(re1.test(text)); // Output: true
    console.log(re2.test(text)); // Output: true
    ```

**4. Testing Unicode property escape code size:**

*   This test checks the size of the generated bytecode or compiled code for regular expressions using Unicode property escapes (e.g., `\p{L}`).
*   It ensures that the code size doesn't exceed a certain limit, likely to prevent excessive memory usage or performance issues due to large regex code.
*   The `v8_flags.regexp_tier_up = false;` suggests this is specifically testing the "irregexp" (intermediate representation) engine, not the full JIT-compiled code.

    ```javascript
    // JavaScript Example of Unicode property escapes:
    const re = /\p{L}\p{L}\p{L}/u; // Matches three consecutive letters
    console.log(re.test('你好啊')); // Output: true
    console.log(re.test('abc'));   // Output: true
    console.log(re.test('123'));   // Output: false
    ```

**5. Testing reentrant irregexp calls and interrupt handling:**

*   The `RegExpInterruptReentrantExecution` test verifies how V8 handles reentrant calls to the regular expression engine, especially when an interrupt is requested during execution.
*   It simulates a scenario where a regular expression execution is interrupted, and another regex execution is attempted within the interrupt handler.
*   The `v8_flags.regexp_tier_up = false;` forces the use of the `irregexp` engine for this test.

    ```javascript
    // JavaScript Example (conceptual - direct reentrant calls are not typical in JS):
    function outerRegex(str) {
      const re1 = /(a*)*x/;
      try {
        re1.test(str);
      } catch (e) {
        console.log("Inner regex execution (simulated in interrupt) would happen here.");
      }
      return re1.test(str);
    }
    console.log(outerRegex("aaaa")); // Output: false (due to the nature of the regex and input)
    ```

In summary, this part of the `regexp-unittest.cc` file delves into the lower-level workings of V8's regular expression engine, focusing on bytecode generation, optimizations, and how it interacts with the surrounding JavaScript environment, particularly in edge cases like uncached strings and interrupt handling. The tests aim to ensure the correctness and efficiency of these internal mechanisms.

Prompt: 
```
这是目录为v8/test/unittests/regexp/regexp-unittest.cc的一个c++源代码文件， 请归纳一下它的功能, 如果它与javascript的功能有关系，请用javascript举例说明
这是第2部分，共2部分，请归纳一下它的功能

"""
oString->Int32Value(isolate()->GetCurrentContext()).FromJust());

  // .toString() throws on non-RegExps that aren't RegExp.prototype
  v8::Local<v8::Value> resultToStringError = RunJS(
      "var exception;"
      "try { RegExp.prototype.toString.call(null) }"
      "catch (e) { exception = e; }"
      "exception");
  CHECK_EQ(2, use_counts[v8::Isolate::kRegExpPrototypeStickyGetter]);
  CHECK_EQ(1, use_counts[v8::Isolate::kRegExpPrototypeToString]);
  CHECK(resultToStringError->IsObject());
}

class UncachedExternalStringResource
    : public v8::String::ExternalOneByteStringResource {
 public:
  const char* data() const override { return "abcdefghijklmnopqrstuvwxyz"; }
  size_t length() const override { return 26; }
  bool IsCacheable() const override { return false; }
};

TEST_F(RegExpTestWithContext, UncachedExternalString) {
  v8::HandleScope scope(isolate());
  v8::Local<v8::String> external =
      v8::String::NewExternalOneByte(isolate(),
                                     new UncachedExternalStringResource())
          .ToLocalChecked();
  CHECK_EQ(v8::Utils::OpenDirectHandle(*external)->map(),
           ReadOnlyRoots(i_isolate()).uncached_external_one_byte_string_map());
  v8::Local<v8::Object> global = context()->Global();
  global->Set(context(), NewString("external"), external).FromJust();
  RunJS("var re = /y(.)/; re.test('ab');");
  // TODO(v8:12781): once IsString matcher is added in
  // gmock-support.h, we could replace this.
  Local<Value> result = RunJS("external.substring(1).match(re)[1]");
  CHECK(result->IsString());
  v8::String::Utf8Value utf8(isolate(), result);
  CHECK_EQ(0, strcmp("z", *utf8));
}

// Test bytecode peephole optimization

void CreatePeepholeNoChangeBytecode(RegExpMacroAssembler* m) {
  Label fail, backtrack;
  m->PushBacktrack(&fail);
  m->CheckNotAtStart(0, nullptr);
  m->LoadCurrentCharacter(2, nullptr);
  m->CheckNotCharacter('o', nullptr);
  m->LoadCurrentCharacter(1, nullptr, false);
  m->CheckNotCharacter('o', nullptr);
  m->LoadCurrentCharacter(0, nullptr, false);
  m->CheckNotCharacter('f', nullptr);
  m->WriteCurrentPositionToRegister(0, 0);
  m->WriteCurrentPositionToRegister(1, 3);
  m->AdvanceCurrentPosition(3);
  m->PushBacktrack(&backtrack);
  m->Succeed();
  m->Bind(&backtrack);
  m->Backtrack();
  m->Bind(&fail);
  m->Fail();
}

TEST_F(RegExpTest, PeepholeNoChange) {
  Zone zone(i_isolate()->allocator(), ZONE_NAME);
  Factory* factory = i_isolate()->factory();
  HandleScope scope(i_isolate());

  RegExpBytecodeGenerator orig(i_isolate(), &zone);
  RegExpBytecodeGenerator opt(i_isolate(), &zone);

  CreatePeepholeNoChangeBytecode(&orig);
  CreatePeepholeNoChangeBytecode(&opt);

  Handle<String> source = factory->NewStringFromStaticChars("^foo");

  v8_flags.regexp_peephole_optimization = false;
  DirectHandle<TrustedByteArray> array =
      Cast<TrustedByteArray>(orig.GetCode(source, {}));
  int length = array->length();
  uint8_t* byte_array = array->begin();

  v8_flags.regexp_peephole_optimization = true;
  DirectHandle<TrustedByteArray> array_optimized =
      Cast<TrustedByteArray>(opt.GetCode(source, {}));
  uint8_t* byte_array_optimized = array_optimized->begin();

  CHECK_EQ(0, memcmp(byte_array, byte_array_optimized, length));
}

void CreatePeepholeSkipUntilCharBytecode(RegExpMacroAssembler* m) {
  Label start;
  m->Bind(&start);
  m->LoadCurrentCharacter(0, nullptr, true);
  m->CheckCharacter('x', nullptr);
  m->AdvanceCurrentPosition(1);
  m->GoTo(&start);
}

TEST_F(RegExpTest, PeepholeSkipUntilChar) {
  Zone zone(i_isolate()->allocator(), ZONE_NAME);
  Factory* factory = i_isolate()->factory();
  HandleScope scope(i_isolate());

  RegExpBytecodeGenerator orig(i_isolate(), &zone);
  RegExpBytecodeGenerator opt(i_isolate(), &zone);

  CreatePeepholeSkipUntilCharBytecode(&orig);
  CreatePeepholeSkipUntilCharBytecode(&opt);

  Handle<String> source = factory->NewStringFromStaticChars("dummy");

  v8_flags.regexp_peephole_optimization = false;
  DirectHandle<TrustedByteArray> array =
      Cast<TrustedByteArray>(orig.GetCode(source, {}));
  int length = array->length();

  v8_flags.regexp_peephole_optimization = true;
  DirectHandle<TrustedByteArray> array_optimized =
      Cast<TrustedByteArray>(opt.GetCode(source, {}));
  int length_optimized = array_optimized->length();

  int length_expected = RegExpBytecodeLength(BC_LOAD_CURRENT_CHAR) +
                        RegExpBytecodeLength(BC_CHECK_CHAR) +
                        RegExpBytecodeLength(BC_ADVANCE_CP_AND_GOTO) +
                        RegExpBytecodeLength(BC_POP_BT);
  int length_optimized_expected = RegExpBytecodeLength(BC_SKIP_UNTIL_CHAR) +
                                  RegExpBytecodeLength(BC_POP_BT);

  CHECK_EQ(length, length_expected);
  CHECK_EQ(length_optimized, length_optimized_expected);

  CHECK_EQ(BC_SKIP_UNTIL_CHAR, array_optimized->get(0));
  CHECK_EQ(BC_POP_BT,
           array_optimized->get(RegExpBytecodeLength(BC_SKIP_UNTIL_CHAR)));
}

void CreatePeepholeSkipUntilBitInTableBytecode(RegExpMacroAssembler* m,
                                               Factory* factory) {
  Handle<ByteArray> bit_table = factory->NewByteArray(
      RegExpMacroAssembler::kTableSize, AllocationType::kOld);
  for (uint32_t i = 0; i < RegExpMacroAssembler::kTableSize; i++) {
    bit_table->set(i, 0);
  }

  Label start;
  m->Bind(&start);
  m->LoadCurrentCharacter(0, nullptr, true);
  m->CheckBitInTable(bit_table, nullptr);
  m->AdvanceCurrentPosition(1);
  m->GoTo(&start);
}

TEST_F(RegExpTest, PeepholeSkipUntilBitInTable) {
  Zone zone(i_isolate()->allocator(), ZONE_NAME);
  Factory* factory = i_isolate()->factory();
  HandleScope scope(i_isolate());

  RegExpBytecodeGenerator orig(i_isolate(), &zone);
  RegExpBytecodeGenerator opt(i_isolate(), &zone);

  CreatePeepholeSkipUntilBitInTableBytecode(&orig, factory);
  CreatePeepholeSkipUntilBitInTableBytecode(&opt, factory);

  Handle<String> source = factory->NewStringFromStaticChars("dummy");

  v8_flags.regexp_peephole_optimization = false;
  DirectHandle<TrustedByteArray> array =
      Cast<TrustedByteArray>(orig.GetCode(source, {}));
  int length = array->length();

  v8_flags.regexp_peephole_optimization = true;
  DirectHandle<TrustedByteArray> array_optimized =
      Cast<TrustedByteArray>(opt.GetCode(source, {}));
  int length_optimized = array_optimized->length();

  int length_expected = RegExpBytecodeLength(BC_LOAD_CURRENT_CHAR) +
                        RegExpBytecodeLength(BC_CHECK_BIT_IN_TABLE) +
                        RegExpBytecodeLength(BC_ADVANCE_CP_AND_GOTO) +
                        RegExpBytecodeLength(BC_POP_BT);
  int length_optimized_expected =
      RegExpBytecodeLength(BC_SKIP_UNTIL_BIT_IN_TABLE) +
      RegExpBytecodeLength(BC_POP_BT);

  CHECK_EQ(length, length_expected);
  CHECK_EQ(length_optimized, length_optimized_expected);

  CHECK_EQ(BC_SKIP_UNTIL_BIT_IN_TABLE, array_optimized->get(0));
  CHECK_EQ(BC_POP_BT, array_optimized->get(
                          RegExpBytecodeLength(BC_SKIP_UNTIL_BIT_IN_TABLE)));
}

void CreatePeepholeSkipUntilCharPosCheckedBytecode(RegExpMacroAssembler* m) {
  Label start;
  m->Bind(&start);
  m->LoadCurrentCharacter(0, nullptr, true, 1, 2);
  m->CheckCharacter('x', nullptr);
  m->AdvanceCurrentPosition(1);
  m->GoTo(&start);
}

TEST_F(RegExpTest, PeepholeSkipUntilCharPosChecked) {
  Zone zone(i_isolate()->allocator(), ZONE_NAME);
  Factory* factory = i_isolate()->factory();
  HandleScope scope(i_isolate());

  RegExpBytecodeGenerator orig(i_isolate(), &zone);
  RegExpBytecodeGenerator opt(i_isolate(), &zone);

  CreatePeepholeSkipUntilCharPosCheckedBytecode(&orig);
  CreatePeepholeSkipUntilCharPosCheckedBytecode(&opt);

  Handle<String> source = factory->NewStringFromStaticChars("dummy");

  v8_flags.regexp_peephole_optimization = false;
  DirectHandle<TrustedByteArray> array =
      Cast<TrustedByteArray>(orig.GetCode(source, {}));
  int length = array->length();

  v8_flags.regexp_peephole_optimization = true;
  DirectHandle<TrustedByteArray> array_optimized =
      Cast<TrustedByteArray>(opt.GetCode(source, {}));
  int length_optimized = array_optimized->length();

  int length_expected = RegExpBytecodeLength(BC_CHECK_CURRENT_POSITION) +
                        RegExpBytecodeLength(BC_LOAD_CURRENT_CHAR_UNCHECKED) +
                        RegExpBytecodeLength(BC_CHECK_CHAR) +
                        RegExpBytecodeLength(BC_ADVANCE_CP_AND_GOTO) +
                        RegExpBytecodeLength(BC_POP_BT);
  int length_optimized_expected =
      RegExpBytecodeLength(BC_SKIP_UNTIL_CHAR_POS_CHECKED) +
      RegExpBytecodeLength(BC_POP_BT);

  CHECK_EQ(length, length_expected);
  CHECK_EQ(length_optimized, length_optimized_expected);

  CHECK_EQ(BC_SKIP_UNTIL_CHAR_POS_CHECKED, array_optimized->get(0));
  CHECK_EQ(BC_POP_BT, array_optimized->get(RegExpBytecodeLength(
                          BC_SKIP_UNTIL_CHAR_POS_CHECKED)));
}

void CreatePeepholeSkipUntilCharAndBytecode(RegExpMacroAssembler* m) {
  Label start;
  m->Bind(&start);
  m->LoadCurrentCharacter(0, nullptr, true, 1, 2);
  m->CheckCharacterAfterAnd('x', 0xFF, nullptr);
  m->AdvanceCurrentPosition(1);
  m->GoTo(&start);
}

TEST_F(RegExpTest, PeepholeSkipUntilCharAnd) {
  Zone zone(i_isolate()->allocator(), ZONE_NAME);
  Factory* factory = i_isolate()->factory();
  HandleScope scope(i_isolate());

  RegExpBytecodeGenerator orig(i_isolate(), &zone);
  RegExpBytecodeGenerator opt(i_isolate(), &zone);

  CreatePeepholeSkipUntilCharAndBytecode(&orig);
  CreatePeepholeSkipUntilCharAndBytecode(&opt);

  Handle<String> source = factory->NewStringFromStaticChars("dummy");

  v8_flags.regexp_peephole_optimization = false;
  DirectHandle<TrustedByteArray> array =
      Cast<TrustedByteArray>(orig.GetCode(source, {}));
  int length = array->length();

  v8_flags.regexp_peephole_optimization = true;
  DirectHandle<TrustedByteArray> array_optimized =
      Cast<TrustedByteArray>(opt.GetCode(source, {}));
  int length_optimized = array_optimized->length();

  int length_expected = RegExpBytecodeLength(BC_CHECK_CURRENT_POSITION) +
                        RegExpBytecodeLength(BC_LOAD_CURRENT_CHAR_UNCHECKED) +
                        RegExpBytecodeLength(BC_AND_CHECK_CHAR) +
                        RegExpBytecodeLength(BC_ADVANCE_CP_AND_GOTO) +
                        RegExpBytecodeLength(BC_POP_BT);
  int length_optimized_expected = RegExpBytecodeLength(BC_SKIP_UNTIL_CHAR_AND) +
                                  RegExpBytecodeLength(BC_POP_BT);

  CHECK_EQ(length, length_expected);
  CHECK_EQ(length_optimized, length_optimized_expected);

  CHECK_EQ(BC_SKIP_UNTIL_CHAR_AND, array_optimized->get(0));
  CHECK_EQ(BC_POP_BT,
           array_optimized->get(RegExpBytecodeLength(BC_SKIP_UNTIL_CHAR_AND)));
}

void CreatePeepholeSkipUntilCharOrCharBytecode(RegExpMacroAssembler* m) {
  Label start;
  m->Bind(&start);
  m->LoadCurrentCharacter(0, nullptr, true);
  m->CheckCharacter('x', nullptr);
  m->CheckCharacter('y', nullptr);
  m->AdvanceCurrentPosition(1);
  m->GoTo(&start);
}

TEST_F(RegExpTest, PeepholeSkipUntilCharOrChar) {
  Zone zone(i_isolate()->allocator(), ZONE_NAME);
  Factory* factory = i_isolate()->factory();
  HandleScope scope(i_isolate());

  RegExpBytecodeGenerator orig(i_isolate(), &zone);
  RegExpBytecodeGenerator opt(i_isolate(), &zone);

  CreatePeepholeSkipUntilCharOrCharBytecode(&orig);
  CreatePeepholeSkipUntilCharOrCharBytecode(&opt);

  Handle<String> source = factory->NewStringFromStaticChars("dummy");

  v8_flags.regexp_peephole_optimization = false;
  DirectHandle<TrustedByteArray> array =
      Cast<TrustedByteArray>(orig.GetCode(source, {}));
  int length = array->length();

  v8_flags.regexp_peephole_optimization = true;
  DirectHandle<TrustedByteArray> array_optimized =
      Cast<TrustedByteArray>(opt.GetCode(source, {}));
  int length_optimized = array_optimized->length();

  int length_expected = RegExpBytecodeLength(BC_LOAD_CURRENT_CHAR) +
                        RegExpBytecodeLength(BC_CHECK_CHAR) +
                        RegExpBytecodeLength(BC_CHECK_CHAR) +
                        RegExpBytecodeLength(BC_ADVANCE_CP_AND_GOTO) +
                        RegExpBytecodeLength(BC_POP_BT);
  int length_optimized_expected =
      RegExpBytecodeLength(BC_SKIP_UNTIL_CHAR_OR_CHAR) +
      RegExpBytecodeLength(BC_POP_BT);

  CHECK_EQ(length, length_expected);
  CHECK_EQ(length_optimized, length_optimized_expected);

  CHECK_EQ(BC_SKIP_UNTIL_CHAR_OR_CHAR, array_optimized->get(0));
  CHECK_EQ(BC_POP_BT, array_optimized->get(
                          RegExpBytecodeLength(BC_SKIP_UNTIL_CHAR_OR_CHAR)));
}

void CreatePeepholeSkipUntilGtOrNotBitInTableBytecode(RegExpMacroAssembler* m,
                                                      Factory* factory) {
  Handle<ByteArray> bit_table = factory->NewByteArray(
      RegExpMacroAssembler::kTableSize, AllocationType::kOld);
  for (uint32_t i = 0; i < RegExpMacroAssembler::kTableSize; i++) {
    bit_table->set(i, 0);
  }

  Label start, end, advance;
  m->Bind(&start);
  m->LoadCurrentCharacter(0, nullptr, true);
  m->CheckCharacterGT('x', nullptr);
  m->CheckBitInTable(bit_table, &advance);
  m->GoTo(&end);
  m->Bind(&advance);
  m->AdvanceCurrentPosition(1);
  m->GoTo(&start);
  m->Bind(&end);
}

TEST_F(RegExpTest, PeepholeSkipUntilGtOrNotBitInTable) {
  Zone zone(i_isolate()->allocator(), ZONE_NAME);
  Factory* factory = i_isolate()->factory();
  HandleScope scope(i_isolate());

  RegExpBytecodeGenerator orig(i_isolate(), &zone);
  RegExpBytecodeGenerator opt(i_isolate(), &zone);

  CreatePeepholeSkipUntilGtOrNotBitInTableBytecode(&orig, factory);
  CreatePeepholeSkipUntilGtOrNotBitInTableBytecode(&opt, factory);

  Handle<String> source = factory->NewStringFromStaticChars("dummy");

  v8_flags.regexp_peephole_optimization = false;
  DirectHandle<TrustedByteArray> array =
      Cast<TrustedByteArray>(orig.GetCode(source, {}));
  int length = array->length();

  v8_flags.regexp_peephole_optimization = true;
  DirectHandle<TrustedByteArray> array_optimized =
      Cast<TrustedByteArray>(opt.GetCode(source, {}));
  int length_optimized = array_optimized->length();

  int length_expected = RegExpBytecodeLength(BC_LOAD_CURRENT_CHAR) +
                        RegExpBytecodeLength(BC_CHECK_GT) +
                        RegExpBytecodeLength(BC_CHECK_BIT_IN_TABLE) +
                        RegExpBytecodeLength(BC_GOTO) +
                        RegExpBytecodeLength(BC_ADVANCE_CP_AND_GOTO) +
                        RegExpBytecodeLength(BC_POP_BT);
  int length_optimized_expected =
      RegExpBytecodeLength(BC_SKIP_UNTIL_GT_OR_NOT_BIT_IN_TABLE) +
      RegExpBytecodeLength(BC_POP_BT);

  CHECK_EQ(length, length_expected);
  CHECK_EQ(length_optimized, length_optimized_expected);

  CHECK_EQ(BC_SKIP_UNTIL_GT_OR_NOT_BIT_IN_TABLE, array_optimized->get(0));
  CHECK_EQ(BC_POP_BT, array_optimized->get(RegExpBytecodeLength(
                          BC_SKIP_UNTIL_GT_OR_NOT_BIT_IN_TABLE)));
}

void CreatePeepholeLabelFixupsInsideBytecode(RegExpMacroAssembler* m,
                                             Label* dummy_before,
                                             Label* dummy_after,
                                             Label* dummy_inside) {
  Label loop;
  m->Bind(dummy_before);
  m->LoadCurrentCharacter(0, dummy_before);
  m->CheckCharacter('a', dummy_after);
  m->CheckCharacter('b', dummy_inside);
  m->Bind(&loop);
  m->LoadCurrentCharacter(0, nullptr, true);
  m->CheckCharacter('x', nullptr);
  m->Bind(dummy_inside);
  m->CheckCharacter('y', nullptr);
  m->AdvanceCurrentPosition(1);
  m->GoTo(&loop);
  m->Bind(dummy_after);
  m->LoadCurrentCharacter(0, dummy_before);
  m->CheckCharacter('a', dummy_after);
  m->CheckCharacter('b', dummy_inside);
}

TEST_F(RegExpTest, PeepholeLabelFixupsInside) {
  Zone zone(i_isolate()->allocator(), ZONE_NAME);
  Factory* factory = i_isolate()->factory();
  HandleScope scope(i_isolate());

  RegExpBytecodeGenerator orig(i_isolate(), &zone);
  RegExpBytecodeGenerator opt(i_isolate(), &zone);

  {
    Label dummy_before, dummy_after, dummy_inside;
    CreatePeepholeLabelFixupsInsideBytecode(&opt, &dummy_before, &dummy_after,
                                            &dummy_inside);
  }
  Label dummy_before, dummy_after, dummy_inside;
  CreatePeepholeLabelFixupsInsideBytecode(&orig, &dummy_before, &dummy_after,
                                          &dummy_inside);

  CHECK_EQ(0x00, dummy_before.pos());
  CHECK_EQ(0x28, dummy_inside.pos());
  CHECK_EQ(0x38, dummy_after.pos());

  const Label* labels[] = {&dummy_before, &dummy_after, &dummy_inside};
  const int label_positions[4][3] = {
      {0x04, 0x3C},  // dummy_before
      {0x0C, 0x44},  // dummy after
      {0x14, 0x4C}   // dummy inside
  };

  Handle<String> source = factory->NewStringFromStaticChars("dummy");

  v8_flags.regexp_peephole_optimization = false;
  DirectHandle<TrustedByteArray> array =
      Cast<TrustedByteArray>(orig.GetCode(source, {}));

  for (int label_idx = 0; label_idx < 3; label_idx++) {
    for (int pos_idx = 0; pos_idx < 2; pos_idx++) {
      CHECK_EQ(labels[label_idx]->pos(),
               array->get(label_positions[label_idx][pos_idx]));
    }
  }

  v8_flags.regexp_peephole_optimization = true;
  DirectHandle<TrustedByteArray> array_optimized =
      Cast<TrustedByteArray>(opt.GetCode(source, {}));

  const int pos_fixups[] = {
      0,  // Position before optimization should be unchanged.
      4,  // Position after first replacement should be 4 (optimized size (20) -
          // original size (32) + preserve length (16)).
  };
  const int target_fixups[] = {
      0,  // dummy_before should be unchanged
      4,  // dummy_inside should be 4
      4   // dummy_after should be 4
  };

  for (int label_idx = 0; label_idx < 3; label_idx++) {
    for (int pos_idx = 0; pos_idx < 2; pos_idx++) {
      int label_pos = label_positions[label_idx][pos_idx] + pos_fixups[pos_idx];
      int jump_address =
          *reinterpret_cast<uint32_t*>(array_optimized->begin() + label_pos);
      int expected_jump_address =
          labels[label_idx]->pos() + target_fixups[label_idx];
      CHECK_EQ(expected_jump_address, jump_address);
    }
  }
}

void CreatePeepholeLabelFixupsComplexBytecode(RegExpMacroAssembler* m,
                                              Label* dummy_before,
                                              Label* dummy_between,
                                              Label* dummy_after,
                                              Label* dummy_inside) {
  Label loop1, loop2;
  m->Bind(dummy_before);
  m->LoadCurrentCharacter(0, dummy_before);
  m->CheckCharacter('a', dummy_between);
  m->CheckCharacter('b', dummy_after);
  m->CheckCharacter('c', dummy_inside);
  m->Bind(&loop1);
  m->LoadCurrentCharacter(0, nullptr, true);
  m->CheckCharacter('x', nullptr);
  m->CheckCharacter('y', nullptr);
  m->AdvanceCurrentPosition(1);
  m->GoTo(&loop1);
  m->Bind(dummy_between);
  m->LoadCurrentCharacter(0, dummy_before);
  m->CheckCharacter('a', dummy_between);
  m->CheckCharacter('b', dummy_after);
  m->CheckCharacter('c', dummy_inside);
  m->Bind(&loop2);
  m->LoadCurrentCharacter(0, nullptr, true);
  m->CheckCharacter('x', nullptr);
  m->Bind(dummy_inside);
  m->CheckCharacter('y', nullptr);
  m->AdvanceCurrentPosition(1);
  m->GoTo(&loop2);
  m->Bind(dummy_after);
  m->LoadCurrentCharacter(0, dummy_before);
  m->CheckCharacter('a', dummy_between);
  m->CheckCharacter('b', dummy_after);
  m->CheckCharacter('c', dummy_inside);
}

TEST_F(RegExpTest, PeepholeLabelFixupsComplex) {
  Zone zone(i_isolate()->allocator(), ZONE_NAME);
  Factory* factory = i_isolate()->factory();
  HandleScope scope(i_isolate());

  RegExpBytecodeGenerator orig(i_isolate(), &zone);
  RegExpBytecodeGenerator opt(i_isolate(), &zone);

  {
    Label dummy_before, dummy_between, dummy_after, dummy_inside;
    CreatePeepholeLabelFixupsComplexBytecode(
        &opt, &dummy_before, &dummy_between, &dummy_after, &dummy_inside);
  }
  Label dummy_before, dummy_between, dummy_after, dummy_inside;
  CreatePeepholeLabelFixupsComplexBytecode(&orig, &dummy_before, &dummy_between,
                                           &dummy_after, &dummy_inside);

  CHECK_EQ(0x00, dummy_before.pos());
  CHECK_EQ(0x40, dummy_between.pos());
  CHECK_EQ(0x70, dummy_inside.pos());
  CHECK_EQ(0x80, dummy_after.pos());

  const Label* labels[] = {&dummy_before, &dummy_between, &dummy_after,
                           &dummy_inside};
  const int label_positions[4][3] = {
      {0x04, 0x44, 0x84},  // dummy_before
      {0x0C, 0x4C, 0x8C},  // dummy between
      {0x14, 0x54, 0x94},  // dummy after
      {0x1C, 0x5C, 0x9C}   // dummy inside
  };

  Handle<String> source = factory->NewStringFromStaticChars("dummy");

  v8_flags.regexp_peephole_optimization = false;
  DirectHandle<TrustedByteArray> array =
      Cast<TrustedByteArray>(orig.GetCode(source, {}));

  for (int label_idx = 0; label_idx < 4; label_idx++) {
    for (int pos_idx = 0; pos_idx < 3; pos_idx++) {
      CHECK_EQ(labels[label_idx]->pos(),
               array->get(label_positions[label_idx][pos_idx]));
    }
  }

  v8_flags.regexp_peephole_optimization = true;
  DirectHandle<TrustedByteArray> array_optimized =
      Cast<TrustedByteArray>(opt.GetCode(source, {}));

  const int pos_fixups[] = {
      0,    // Position before optimization should be unchanged.
      -12,  // Position after first replacement should be -12 (optimized size =
            // 20 - 32 = original size).
      -8    // Position after second replacement should be -8 (-12 from first
            // optimization -12 from second optimization + 16 preserved
            // bytecodes).
  };
  const int target_fixups[] = {
      0,    // dummy_before should be unchanged
      -12,  // dummy_between should be -12
      -8,   // dummy_inside should be -8
      -8    // dummy_after should be -8
  };

  for (int label_idx = 0; label_idx < 4; label_idx++) {
    for (int pos_idx = 0; pos_idx < 3; pos_idx++) {
      int label_pos = label_positions[label_idx][pos_idx] + pos_fixups[pos_idx];
      int jump_address =
          *reinterpret_cast<uint32_t*>(array_optimized->begin() + label_pos);
      int expected_jump_address =
          labels[label_idx]->pos() + target_fixups[label_idx];
      CHECK_EQ(expected_jump_address, jump_address);
    }
  }
}

TEST_F(RegExpTestWithContext, UnicodePropertyEscapeCodeSize) {
  FlagScope<bool> f(&v8_flags.regexp_tier_up, false);

  v8::HandleScope scope(isolate());
  i::DirectHandle<i::JSRegExp> re = Utils::OpenDirectHandle(
      *RunJS("const r = /\\p{L}\\p{L}\\p{L}/u; r.exec('\\u200b'); r;")
           .As<v8::RegExp>());

  static constexpr int kMaxSize = 200 * KB;
  static constexpr bool kIsNotLatin1 = false;

  Tagged<RegExpData> data = re->data(i_isolate());
  SBXCHECK(Is<IrRegExpData>(data));
  Tagged<IrRegExpData> re_data = Cast<IrRegExpData>(data);

  if (re_data->has_bytecode(kIsNotLatin1)) {
    // On x64, excessive inlining produced >250KB.
    CHECK_LT(re_data->bytecode(kIsNotLatin1)->AllocatedSize(), kMaxSize);
  } else if (re_data->has_code(kIsNotLatin1)) {
    Tagged<Code> code = re_data->code(i_isolate(), kIsNotLatin1);
    // On x64, excessive inlining produced >360KB.
    CHECK_LT(code->Size(), kMaxSize);
    CHECK_EQ(code->kind(), CodeKind::REGEXP);
  } else {
    UNREACHABLE();
  }
}

namespace {

struct RegExpExecData {
  i::Isolate* isolate;
  i::Handle<i::JSRegExp> regexp;
  i::Handle<i::String> subject;
};

i::Handle<i::Object> RegExpExec(const RegExpExecData* d) {
  return i::RegExp::Exec_Single(d->isolate, d->regexp, d->subject, 0,
                                d->isolate->regexp_last_match_info())
      .ToHandleChecked();
}

void ReenterRegExp(v8::Isolate* isolate, void* data) {
  RegExpExecData* d = static_cast<RegExpExecData*>(data);
  i::DirectHandle<i::Object> result = RegExpExec(d);
  CHECK(IsNull(*result));
}

}  // namespace

// Tests reentrant irregexp calls.
TEST_F(RegExpTestWithContext, RegExpInterruptReentrantExecution) {
  CHECK(!v8_flags.jitless);
  v8_flags.regexp_tier_up = false;  // Enter irregexp, not the interpreter.

  v8::HandleScope scope(isolate());

  RegExpExecData d;
  d.isolate = reinterpret_cast<i::Isolate*>(isolate());
  d.regexp = v8::Utils::OpenHandle(
      *v8::RegExp::New(context(), NewString("(a*)*x"), v8::RegExp::kNone)
           .ToLocalChecked());
  d.subject = v8::Utils::OpenHandle(*NewString("aaaa"));

  isolate()->RequestInterrupt(&ReenterRegExp, &d);

  i::DirectHandle<i::Object> result = RegExpExec(&d);
  CHECK(IsNull(*result));
}

#undef CHECK_PARSE_ERROR
#undef CHECK_SIMPLE
#undef CHECK_MIN_MAX

}  // namespace internal
}  // namespace v8

"""


```
Response: The user is asking for a summary of the functionality of the C++ code provided in the file `v8/src/profiler/heap-snapshot-generator.cc`. This is the third and final part of the file.

Based on the provided code, here's a breakdown of its responsibilities:

1. **Heap Snapshot Generation (Continuation from previous parts):**  This part continues the process of generating a heap snapshot. The `hot()` and `GenerateSnapshotAfterGC()` methods are key functions for initiating the snapshot process under different conditions (with and without a preceding garbage collection).

2. **Progress Reporting:** The code includes mechanisms for tracking and reporting the progress of the heap snapshot generation. This is done through the `ProgressStep()`, `ProgressReport()`, and `InitProgressCounter()` methods. These methods interact with a `control_` object, likely provided by an external system (like DevTools), to communicate the progress.

3. **Reference Filling:** The `FillReferences()` method is responsible for iterating through the heap and extracting references between objects. This is crucial for building the object graph in the snapshot.

4. **JSON Serialization:**  A significant portion of this part focuses on serializing the generated heap snapshot into a JSON format. The `HeapSnapshotJSONSerializer` class handles this.

5. **Serialization Details:**  The `SerializeImpl()` method orchestrates the serialization of different parts of the snapshot (snapshot metadata, nodes, edges, trace information, samples, locations, and strings). Helper methods like `SerializeNode()`, `SerializeEdge()`, `SerializeTraceNode()`, `SerializeTraceNodeInfos()`, `SerializeSamples()`, `SerializeStrings()`, and `SerializeLocations()` are used to serialize specific data structures.

6. **String Management:** The `GetStringId()` method manages a string table to avoid redundant storage of string data in the JSON output.

7. **Data Formatting:**  Utility functions like `utoa()` are used for efficiently converting numerical data to strings for JSON serialization.

8. **Performance Measurement:** The code includes timers to measure the duration of the snapshot generation and serialization processes.

**Relationship to JavaScript:**

The heap snapshot generated by this C++ code represents the state of the JavaScript heap within the V8 engine. This snapshot can be used by developer tools (like Chrome DevTools) to analyze memory usage, identify memory leaks, and understand the object relationships in a running JavaScript application.

**JavaScript Example:**

In JavaScript, you can trigger the creation of a heap snapshot using the DevTools API:

```javascript
// This code would typically be executed within a browser's DevTools context

// Take a heap snapshot
console.profile('Heap Snapshot');

// ... your JavaScript code ...

console.profileEnd('Heap Snapshot');

// You can then download or analyze the generated snapshot in DevTools
```

When `console.profile('Heap Snapshot')` and `console.profileEnd('Heap Snapshot')` are called, the V8 engine (which includes the C++ code we are examining) will generate a snapshot of the current JavaScript heap. The data generated by the C++ code will then be used by the DevTools frontend to visualize the heap and provide analysis tools to the developer.

Specifically, the JSON output generated by the `HeapSnapshotJSONSerializer` is what DevTools consumes to display the heap graph. The nodes in the JSON represent JavaScript objects, the edges represent references between objects, and other metadata provides context about the heap's state.
这是 `v8/src/profiler/heap-snapshot-generator.cc` 文件的第三部分，主要负责**完成堆快照的生成和将其序列化为 JSON 格式**。

以下是这部分代码的主要功能归纳：

1. **完成堆快照的生成 (`hot()` 和 `GenerateSnapshotAfterGC()`):**
   - `hot()` 方法是生成完整堆快照的核心函数。它执行以下步骤：
     - 启动计时器。
     - 进入安全点，确保在快照期间没有 JavaScript 代码执行。
     - 收集临时全局对象的标签。
     - 执行一次垃圾回收（在 `hot()` 中，`GenerateSnapshotAfterGC()` 则跳过此步骤）。
     - 禁止位置信息的收集以提高性能。
     - 将当前执行上下文置为空，以便进行快照。
     - 创建全局对象标签映射。
     - 初始化进度计数器。
     - 添加合成的根节点条目。
     - 填充对象的行尾信息。
     - 调用 `FillReferences()` 来遍历堆并提取对象之间的引用关系。
     - 填充子节点信息。
     - 记录最后一个 JavaScript 对象的 ID。
     - 设置进度计数器为完成状态。
     - 可选地打印快照生成耗时。
     - 报告进度。
   - `GenerateSnapshotAfterGC()` 方法与 `hot()` 类似，但它假设之前已经执行过垃圾回收，因此跳过了垃圾回收和进度报告的步骤。

2. **报告生成进度 (`ProgressStep()` 和 `ProgressReport()`):**
   - `ProgressStep()` 用于递增进度计数器，表示快照生成过程中的一个步骤。
   - `ProgressReport()` 用于向外部（例如，开发者工具）报告当前的生成进度。它会根据一定的粒度定期报告，也可以强制报告。

3. **初始化进度计数器 (`InitProgressCounter()`):**
   - `InitProgressCounter()` 用于初始化快照生成过程的总步骤数，通常基于估计的对象数量。

4. **填充对象引用关系 (`FillReferences()`):**
   - `FillReferences()` 方法委托给 `v8_heap_explorer_` 和 `dom_explorer_` 来遍历堆中的 V8 对象和 DOM 对象，并提取它们之间的引用关系。

5. **将堆快照序列化为 JSON 格式 (`HeapSnapshotJSONSerializer`):**
   - `HeapSnapshotJSONSerializer` 类负责将生成的堆快照数据结构转换为 JSON 格式的字符串，以便可以被外部工具（如 Chrome 开发者工具）解析和使用。
   - `Serialize(v8::OutputStream* stream)` 方法是序列化的入口点，它创建一个 `OutputStreamWriter` 并调用 `SerializeImpl()` 来完成实际的序列化工作。
   - `SerializeImpl()` 方法负责序列化快照的各个部分：
     - 快照的元数据 (`SerializeSnapshot()`)，包括节点和边的字段定义。
     - 节点数组 (`SerializeNodes()`)，包含每个对象的类型、名称、ID、大小、子节点数量等信息。
     - 边数组 (`SerializeEdges()`)，包含对象之间的引用关系信息，如引用类型、名称或索引、目标节点索引。
     - 调用栈跟踪信息 (`SerializeTraceNodeInfos()` 和 `SerializeTraceTree()`)，如果启用了分配跟踪，则会包含对象的分配调用栈信息。
     - 采样信息 (`SerializeSamples()`)，如果启用了堆采样，则会包含采样的时间戳和对象 ID。
     - 对象的位置信息 (`SerializeLocations()`)，包含对象创建的脚本 ID、行号和列号。
     - 字符串表 (`SerializeStrings()`)，将所有用到的字符串存储在一个单独的数组中，并在节点和边中用索引引用，以避免重复存储。
   - `GetStringId(const char* s)` 方法用于获取字符串在字符串表中的 ID，如果字符串不存在则添加到表中。
   - `SerializeNode()`, `SerializeEdge()`, `SerializeTraceNode()`, `SerializeTraceNodeInfos()`, `SerializeSamples()`, `SerializeStrings()`, `SerializeLocation()` 等方法是用于序列化特定数据结构的辅助方法。

**与 JavaScript 功能的关系（示例）：**

堆快照是分析 JavaScript 应用程序内存使用情况的关键工具。当你在 Chrome 开发者工具的 "Memory" 面板中点击 "Take heap snapshot" 时，V8 引擎就会执行类似于 `HeapSnapshotGenerator::hot()` 的过程来生成当前的堆快照。

```javascript
// 在 Chrome 开发者工具的 Console 中执行以下代码

// 开始记录堆栈信息（可选，用于分配跟踪）
console.time('heap-snapshot');

// 手动触发一次垃圾回收（可选，有助于减少快照大小）
if (gc) { // 检查 gc 函数是否存在，某些上下文中可能不存在
  gc();
}

// 执行一些 JavaScript 代码，创建一些对象
let myObject = {
  name: 'Test Object',
  data: [1, 2, 3, 4, 5]
};

let anotherObject = {
  ref: myObject
};

// 结束堆栈信息记录
console.timeEnd('heap-snapshot');

// 开发者工具会自动捕获这段代码执行期间的堆快照
```

在这个例子中，当我们点击 "Take heap snapshot" 或使用 `console.profile()` 和 `console.profileEnd()` API 时，V8 引擎内部的 C++ 代码（包括 `heap-snapshot-generator.cc` 中的代码）会遍历 JavaScript 堆，记录 `myObject` 和 `anotherObject` 以及它们之间的引用关系（`anotherObject` 引用了 `myObject`）。

`HeapSnapshotJSONSerializer` 会将这些信息序列化成 JSON 格式，例如：

```json
{
  "snapshot": {
    "meta": {
      "node_fields": ["type", "name", "id", "self_size", "edge_count", "trace_node_id", "detachedness"],
      "node_types": [ /* ... */ ],
      "edge_fields": ["type", "name_or_index", "to_node"],
      "edge_types": [ /* ... */ ],
      "trace_function_info_fields": [ /* ... */ ],
      "trace_node_fields": [ /* ... */ ],
      "sample_fields": [ /* ... */ ],
      "location_fields": [ /* ... */ ]
    },
    "node_count": 100, // 示例值
    "edge_count": 50,  // 示例值
    "trace_function_count": 0 // 示例值
  },
  "nodes": [
    // ... 代表 myObject 的节点数据，包含其类型、名称索引、ID、大小等
    // ... 代表 anotherObject 的节点数据
  ],
  "edges": [
    // ... 代表 anotherObject 到 myObject 的引用边，包含边的类型、名称/索引、目标节点索引
  ],
  "strings": [
    "<dummy>",
    "Test Object",
    "name",
    "data",
    "ref"
  ],
  // ... 其他部分
}
```

开发者工具接收到这个 JSON 数据后，会解析并以图形化的方式展示堆的结构，帮助开发者理解 JavaScript 对象的内存占用和引用关系，从而进行性能优化和内存泄漏分析。

总而言之，这部分代码是 V8 引擎中负责生成和序列化 JavaScript 堆快照的关键组成部分，它直接支撑了开发者工具中强大的内存分析功能。

Prompt: 
```
这是目录为v8/src/profiler/heap-snapshot-generator.cc的一个c++源代码文件， 请归纳一下它的功能, 如果它与javascript的功能有关系，请用javascript举例说明
这是第3部分，共3部分，请归纳一下它的功能

"""
hot() {
  v8::base::ElapsedTimer timer;
  timer.Start();

  IsolateSafepointScope scope(heap_);

  Isolate* isolate = heap_->isolate();
  auto temporary_global_object_tags =
      v8_heap_explorer_.CollectTemporaryGlobalObjectsTags();

  EmbedderStackStateScope stack_scope(
      heap_, EmbedderStackStateOrigin::kImplicitThroughTask, stack_state_);
  heap_->CollectAllAvailableGarbage(GarbageCollectionReason::kHeapProfiler);

  // No allocation that could trigger GC from here onwards. We cannot use a
  // DisallowGarbageCollection scope as the HeapObjectIterator used during
  // snapshot creation enters a safepoint as well. However, in practice we
  // already enter a safepoint above so that should never trigger a GC.
  DisallowPositionInfoSlow no_position_info_slow;

  NullContextForSnapshotScope null_context_scope(isolate);

  v8_heap_explorer_.MakeGlobalObjectTagMap(
      std::move(temporary_global_object_tags));

  InitProgressCounter();

  snapshot_->AddSyntheticRootEntries();

  v8_heap_explorer_.PopulateLineEnds();
  if (!FillReferences()) return false;

  snapshot_->FillChildren();
  snapshot_->RememberLastJSObjectId();

  progress_counter_ = progress_total_;

  if (i::v8_flags.profile_heap_snapshot) {
    base::OS::PrintError("[Heap snapshot took %0.3f ms]\n",
                         timer.Elapsed().InMillisecondsF());
  }
  timer.Stop();
  if (!ProgressReport(true)) return false;
  return true;
}

bool HeapSnapshotGenerator::GenerateSnapshotAfterGC() {
  // Same as above, but no allocations, no GC run, and no progress report.
  IsolateSafepointScope scope(heap_);
  auto temporary_global_object_tags =
      v8_heap_explorer_.CollectTemporaryGlobalObjectsTags();
  NullContextForSnapshotScope null_context_scope(heap_->isolate());
  v8_heap_explorer_.MakeGlobalObjectTagMap(
      std::move(temporary_global_object_tags));
  snapshot_->AddSyntheticRootEntries();
  v8_heap_explorer_.PopulateLineEnds();
  if (!FillReferences()) return false;
  snapshot_->FillChildren();
  snapshot_->RememberLastJSObjectId();
  return true;
}

void HeapSnapshotGenerator::ProgressStep() {
  // Only increment the progress_counter_ until
  // equal to progress_total -1 == progress_counter.
  // This ensures that intermediate ProgressReport calls will never signal
  // that the work is finished (i.e. progress_counter_ == progress_total_).
  // Only the forced ProgressReport() at the end of GenerateSnapshot() should,
  // after setting progress_counter_ = progress_total_, signal that the
  // work is finished because signalling finished twice
  // breaks the DevTools frontend.
  if (control_ != nullptr && progress_total_ > progress_counter_ + 1) {
    ++progress_counter_;
  }
}

bool HeapSnapshotGenerator::ProgressReport(bool force) {
  const int kProgressReportGranularity = 10000;
  if (control_ != nullptr &&
      (force || progress_counter_ % kProgressReportGranularity == 0)) {
    return control_->ReportProgressValue(progress_counter_, progress_total_) ==
           v8::ActivityControl::kContinue;
  }
  return true;
}

void HeapSnapshotGenerator::InitProgressCounter() {
  if (control_ == nullptr) return;
  progress_total_ = v8_heap_explorer_.EstimateObjectsCount();
  progress_counter_ = 0;
}

bool HeapSnapshotGenerator::FillReferences() {
  return v8_heap_explorer_.IterateAndExtractReferences(this) &&
         dom_explorer_.IterateAndExtractReferences(this);
}

// type, name, id, self_size, edge_count, trace_node_id, detachedness.
const int HeapSnapshotJSONSerializer::kNodeFieldsCountWithTraceNodeId = 7;
const int HeapSnapshotJSONSerializer::kNodeFieldsCountWithoutTraceNodeId = 6;

void HeapSnapshotJSONSerializer::Serialize(v8::OutputStream* stream) {
  v8::base::ElapsedTimer timer;
  timer.Start();
  DCHECK_NULL(writer_);
  writer_ = new OutputStreamWriter(stream);
  trace_function_count_ = 0;
  if (AllocationTracker* tracker =
          snapshot_->profiler()->allocation_tracker()) {
    trace_function_count_ =
        static_cast<uint32_t>(tracker->function_info_list().size());
  }
  SerializeImpl();
  delete writer_;
  writer_ = nullptr;

  if (i::v8_flags.profile_heap_snapshot) {
    base::OS::PrintError("[Serialization of heap snapshot took %0.3f ms]\n",
                         timer.Elapsed().InMillisecondsF());
  }
  timer.Stop();
}

void HeapSnapshotJSONSerializer::SerializeImpl() {
  DCHECK_EQ(0, snapshot_->root()->index());
  writer_->AddCharacter('{');
  writer_->AddString("\"snapshot\":{");
  SerializeSnapshot();
  if (writer_->aborted()) return;
  writer_->AddString("},\n");
  writer_->AddString("\"nodes\":[");
  SerializeNodes();
  if (writer_->aborted()) return;
  writer_->AddString("],\n");
  writer_->AddString("\"edges\":[");
  SerializeEdges();
  if (writer_->aborted()) return;
  writer_->AddString("],\n");

  writer_->AddString("\"trace_function_infos\":[");
  SerializeTraceNodeInfos();
  if (writer_->aborted()) return;
  writer_->AddString("],\n");
  writer_->AddString("\"trace_tree\":[");
  SerializeTraceTree();
  if (writer_->aborted()) return;
  writer_->AddString("],\n");

  writer_->AddString("\"samples\":[");
  SerializeSamples();
  if (writer_->aborted()) return;
  writer_->AddString("],\n");

  writer_->AddString("\"locations\":[");
  SerializeLocations();
  if (writer_->aborted()) return;
  writer_->AddString("],\n");

  writer_->AddString("\"strings\":[");
  SerializeStrings();
  if (writer_->aborted()) return;
  writer_->AddCharacter(']');
  writer_->AddCharacter('}');
  writer_->Finalize();
}

int HeapSnapshotJSONSerializer::GetStringId(const char* s) {
  base::HashMap::Entry* cache_entry =
      strings_.LookupOrInsert(const_cast<char*>(s), StringHash(s));
  if (cache_entry->value == nullptr) {
    cache_entry->value = reinterpret_cast<void*>(next_string_id_++);
  }
  return static_cast<int>(reinterpret_cast<intptr_t>(cache_entry->value));
}

namespace {

template <size_t size>
struct ToUnsigned;

template <>
struct ToUnsigned<1> {
  using Type = uint8_t;
};

template <>
struct ToUnsigned<4> {
  using Type = uint32_t;
};

template <>
struct ToUnsigned<8> {
  using Type = uint64_t;
};

}  // namespace

template <typename T>
static int utoa_impl(T value, base::Vector<char> buffer, int buffer_pos) {
  static_assert(static_cast<T>(-1) > 0);  // Check that T is unsigned
  int number_of_digits = 0;
  T t = value;
  do {
    ++number_of_digits;
  } while (t /= 10);

  buffer_pos += number_of_digits;
  int result = buffer_pos;
  do {
    int last_digit = static_cast<int>(value % 10);
    buffer[--buffer_pos] = '0' + last_digit;
    value /= 10;
  } while (value);
  return result;
}

template <typename T>
static int utoa(T value, base::Vector<char> buffer, int buffer_pos) {
  typename ToUnsigned<sizeof(value)>::Type unsigned_value = value;
  static_assert(sizeof(value) == sizeof(unsigned_value));
  return utoa_impl(unsigned_value, buffer, buffer_pos);
}

void HeapSnapshotJSONSerializer::SerializeEdge(HeapGraphEdge* edge,
                                               bool first_edge) {
  // The buffer needs space for 3 unsigned ints, 3 commas, \n and \0
  static const int kBufferSize =
      MaxDecimalDigitsIn<sizeof(unsigned)>::kUnsigned * 3 + 3 + 2;
  base::EmbeddedVector<char, kBufferSize> buffer;
  int edge_name_or_index = edge->type() == HeapGraphEdge::kElement ||
                                   edge->type() == HeapGraphEdge::kHidden
                               ? edge->index()
                               : GetStringId(edge->name());
  int buffer_pos = 0;
  if (!first_edge) {
    buffer[buffer_pos++] = ',';
  }
  buffer_pos = utoa(edge->type(), buffer, buffer_pos);
  buffer[buffer_pos++] = ',';
  buffer_pos = utoa(edge_name_or_index, buffer, buffer_pos);
  buffer[buffer_pos++] = ',';
  buffer_pos = utoa(to_node_index(edge->to()), buffer, buffer_pos);
  buffer[buffer_pos++] = '\n';
  buffer[buffer_pos++] = '\0';
  writer_->AddString(buffer.begin());
}

void HeapSnapshotJSONSerializer::SerializeEdges() {
  std::vector<HeapGraphEdge*>& edges = snapshot_->children();
  for (size_t i = 0; i < edges.size(); ++i) {
    DCHECK(i == 0 ||
           edges[i - 1]->from()->index() <= edges[i]->from()->index());
    SerializeEdge(edges[i], i == 0);
    if (writer_->aborted()) return;
  }
}

void HeapSnapshotJSONSerializer::SerializeNode(const HeapEntry* entry) {
  // The buffer needs space for 5 unsigned ints, 1 size_t, 1 uint8_t, 7 commas,
  // \n and \0
  static const int kBufferSize =
      5 * MaxDecimalDigitsIn<sizeof(unsigned)>::kUnsigned +
      MaxDecimalDigitsIn<sizeof(size_t)>::kUnsigned +
      MaxDecimalDigitsIn<sizeof(uint8_t)>::kUnsigned + 7 + 1 + 1;
  base::EmbeddedVector<char, kBufferSize> buffer;
  int buffer_pos = 0;
  if (to_node_index(entry) != 0) {
    buffer[buffer_pos++] = ',';
  }
  buffer_pos = utoa(entry->type(), buffer, buffer_pos);
  buffer[buffer_pos++] = ',';
  buffer_pos = utoa(GetStringId(entry->name()), buffer, buffer_pos);
  buffer[buffer_pos++] = ',';
  buffer_pos = utoa(entry->id(), buffer, buffer_pos);
  buffer[buffer_pos++] = ',';
  buffer_pos = utoa(entry->self_size(), buffer, buffer_pos);
  buffer[buffer_pos++] = ',';
  buffer_pos = utoa(entry->children_count(), buffer, buffer_pos);
  buffer[buffer_pos++] = ',';
  if (trace_function_count_) {
    buffer_pos = utoa(entry->trace_node_id(), buffer, buffer_pos);
    buffer[buffer_pos++] = ',';
  } else {
    CHECK_EQ(0, entry->trace_node_id());
  }
  buffer_pos = utoa(entry->detachedness(), buffer, buffer_pos);
  buffer[buffer_pos++] = '\n';
  buffer[buffer_pos++] = '\0';
  writer_->AddString(buffer.begin());
}

void HeapSnapshotJSONSerializer::SerializeNodes() {
  const std::deque<HeapEntry>& entries = snapshot_->entries();
  for (const HeapEntry& entry : entries) {
    SerializeNode(&entry);
    if (writer_->aborted()) return;
  }
}

void HeapSnapshotJSONSerializer::SerializeSnapshot() {
  writer_->AddString("\"meta\":");
  // The object describing node serialization layout.
  // We use a set of macros to improve readability.

  // clang-format off
#define JSON_A(s) "[" s "]"
#define JSON_S(s) "\"" s "\""
  writer_->AddString("{"
    JSON_S("node_fields") ":["
        JSON_S("type") ","
        JSON_S("name") ","
        JSON_S("id") ","
        JSON_S("self_size") ","
        JSON_S("edge_count") ",");
  if (trace_function_count_) writer_->AddString(JSON_S("trace_node_id") ",");
  writer_->AddString(
        JSON_S("detachedness")
    "],"
    JSON_S("node_types") ":" JSON_A(
        JSON_A(
            JSON_S("hidden") ","
            JSON_S("array") ","
            JSON_S("string") ","
            JSON_S("object") ","
            JSON_S("code") ","
            JSON_S("closure") ","
            JSON_S("regexp") ","
            JSON_S("number") ","
            JSON_S("native") ","
            JSON_S("synthetic") ","
            JSON_S("concatenated string") ","
            JSON_S("sliced string") ","
            JSON_S("symbol") ","
            JSON_S("bigint") ","
            JSON_S("object shape")) ","
        JSON_S("string") ","
        JSON_S("number") ","
        JSON_S("number") ","
        JSON_S("number") ","
        JSON_S("number") ","
        JSON_S("number")) ","
    JSON_S("edge_fields") ":" JSON_A(
        JSON_S("type") ","
        JSON_S("name_or_index") ","
        JSON_S("to_node")) ","
    JSON_S("edge_types") ":" JSON_A(
        JSON_A(
            JSON_S("context") ","
            JSON_S("element") ","
            JSON_S("property") ","
            JSON_S("internal") ","
            JSON_S("hidden") ","
            JSON_S("shortcut") ","
            JSON_S("weak")) ","
        JSON_S("string_or_number") ","
        JSON_S("node")) ","
    JSON_S("trace_function_info_fields") ":" JSON_A(
        JSON_S("function_id") ","
        JSON_S("name") ","
        JSON_S("script_name") ","
        JSON_S("script_id") ","
        JSON_S("line") ","
        JSON_S("column")) ","
    JSON_S("trace_node_fields") ":" JSON_A(
        JSON_S("id") ","
        JSON_S("function_info_index") ","
        JSON_S("count") ","
        JSON_S("size") ","
        JSON_S("children")) ","
    JSON_S("sample_fields") ":" JSON_A(
        JSON_S("timestamp_us") ","
        JSON_S("last_assigned_id")) ","
    JSON_S("location_fields") ":" JSON_A(
        JSON_S("object_index") ","
        JSON_S("script_id") ","
        JSON_S("line") ","
        JSON_S("column"))
  "}");
// clang-format on
#undef JSON_S
#undef JSON_A
  writer_->AddString(",\"node_count\":");
  writer_->AddNumber(static_cast<unsigned>(snapshot_->entries().size()));
  writer_->AddString(",\"edge_count\":");
  writer_->AddNumber(static_cast<double>(snapshot_->edges().size()));
  writer_->AddString(",\"trace_function_count\":");
  writer_->AddNumber(trace_function_count_);
}

static void WriteUChar(OutputStreamWriter* w, unibrow::uchar u) {
  static const char hex_chars[] = "0123456789ABCDEF";
  w->AddString("\\u");
  w->AddCharacter(hex_chars[(u >> 12) & 0xF]);
  w->AddCharacter(hex_chars[(u >> 8) & 0xF]);
  w->AddCharacter(hex_chars[(u >> 4) & 0xF]);
  w->AddCharacter(hex_chars[u & 0xF]);
}

void HeapSnapshotJSONSerializer::SerializeTraceTree() {
  AllocationTracker* tracker = snapshot_->profiler()->allocation_tracker();
  if (!tracker) return;
  AllocationTraceTree* traces = tracker->trace_tree();
  SerializeTraceNode(traces->root());
}

void HeapSnapshotJSONSerializer::SerializeTraceNode(AllocationTraceNode* node) {
  // The buffer needs space for 4 unsigned ints, 4 commas, [ and \0
  const int kBufferSize =
      4 * MaxDecimalDigitsIn<sizeof(unsigned)>::kUnsigned + 4 + 1 + 1;
  base::EmbeddedVector<char, kBufferSize> buffer;
  int buffer_pos = 0;
  buffer_pos = utoa(node->id(), buffer, buffer_pos);
  buffer[buffer_pos++] = ',';
  buffer_pos = utoa(node->function_info_index(), buffer, buffer_pos);
  buffer[buffer_pos++] = ',';
  buffer_pos = utoa(node->allocation_count(), buffer, buffer_pos);
  buffer[buffer_pos++] = ',';
  buffer_pos = utoa(node->allocation_size(), buffer, buffer_pos);
  buffer[buffer_pos++] = ',';
  buffer[buffer_pos++] = '[';
  buffer[buffer_pos++] = '\0';
  writer_->AddString(buffer.begin());

  int i = 0;
  for (AllocationTraceNode* child : node->children()) {
    if (i++ > 0) {
      writer_->AddCharacter(',');
    }
    SerializeTraceNode(child);
  }
  writer_->AddCharacter(']');
}

// 0-based position is converted to 1-based during the serialization.
static int SerializePosition(int position, base::Vector<char> buffer,
                             int buffer_pos) {
  if (position == -1) {
    buffer[buffer_pos++] = '0';
  } else {
    DCHECK_GE(position, 0);
    buffer_pos = utoa(static_cast<unsigned>(position + 1), buffer, buffer_pos);
  }
  return buffer_pos;
}

void HeapSnapshotJSONSerializer::SerializeTraceNodeInfos() {
  AllocationTracker* tracker = snapshot_->profiler()->allocation_tracker();
  if (!tracker) return;
  // The buffer needs space for 6 unsigned ints, 6 commas, \n and \0
  const int kBufferSize =
      6 * MaxDecimalDigitsIn<sizeof(unsigned)>::kUnsigned + 6 + 1 + 1;
  base::EmbeddedVector<char, kBufferSize> buffer;
  int i = 0;
  for (AllocationTracker::FunctionInfo* info : tracker->function_info_list()) {
    int buffer_pos = 0;
    if (i++ > 0) {
      buffer[buffer_pos++] = ',';
    }
    buffer_pos = utoa(info->function_id, buffer, buffer_pos);
    buffer[buffer_pos++] = ',';
    buffer_pos = utoa(GetStringId(info->name), buffer, buffer_pos);
    buffer[buffer_pos++] = ',';
    buffer_pos = utoa(GetStringId(info->script_name), buffer, buffer_pos);
    buffer[buffer_pos++] = ',';
    // The cast is safe because script id is a non-negative Smi.
    buffer_pos =
        utoa(static_cast<unsigned>(info->script_id), buffer, buffer_pos);
    buffer[buffer_pos++] = ',';
    buffer_pos = SerializePosition(info->line, buffer, buffer_pos);
    buffer[buffer_pos++] = ',';
    buffer_pos = SerializePosition(info->column, buffer, buffer_pos);
    buffer[buffer_pos++] = '\n';
    buffer[buffer_pos++] = '\0';
    writer_->AddString(buffer.begin());
  }
}

void HeapSnapshotJSONSerializer::SerializeSamples() {
  const std::vector<HeapObjectsMap::TimeInterval>& samples =
      snapshot_->profiler()->heap_object_map()->samples();
  if (samples.empty()) return;
  base::TimeTicks start_time = samples[0].timestamp;
  // The buffer needs space for 2 unsigned ints, 2 commas, \n and \0
  const int kBufferSize = MaxDecimalDigitsIn<sizeof(
                              base::TimeDelta().InMicroseconds())>::kUnsigned +
                          MaxDecimalDigitsIn<sizeof(samples[0].id)>::kUnsigned +
                          2 + 1 + 1;
  base::EmbeddedVector<char, kBufferSize> buffer;
  int i = 0;
  for (const HeapObjectsMap::TimeInterval& sample : samples) {
    int buffer_pos = 0;
    if (i++ > 0) {
      buffer[buffer_pos++] = ',';
    }
    base::TimeDelta time_delta = sample.timestamp - start_time;
    buffer_pos = utoa(time_delta.InMicroseconds(), buffer, buffer_pos);
    buffer[buffer_pos++] = ',';
    buffer_pos = utoa(sample.last_assigned_id(), buffer, buffer_pos);
    buffer[buffer_pos++] = '\n';
    buffer[buffer_pos++] = '\0';
    writer_->AddString(buffer.begin());
  }
}

void HeapSnapshotJSONSerializer::SerializeString(const unsigned char* s) {
  writer_->AddCharacter('\n');
  writer_->AddCharacter('\"');
  for (; *s != '\0'; ++s) {
    switch (*s) {
      case '\b':
        writer_->AddString("\\b");
        continue;
      case '\f':
        writer_->AddString("\\f");
        continue;
      case '\n':
        writer_->AddString("\\n");
        continue;
      case '\r':
        writer_->AddString("\\r");
        continue;
      case '\t':
        writer_->AddString("\\t");
        continue;
      case '\"':
      case '\\':
        writer_->AddCharacter('\\');
        writer_->AddCharacter(*s);
        continue;
      default:
        if (*s > 31 && *s < 128) {
          writer_->AddCharacter(*s);
        } else if (*s <= 31) {
          // Special character with no dedicated literal.
          WriteUChar(writer_, *s);
        } else {
          // Convert UTF-8 into \u UTF-16 literal.
          size_t length = 1, cursor = 0;
          for (; length <= 4 && *(s + length) != '\0'; ++length) {
          }
          unibrow::uchar c = unibrow::Utf8::CalculateValue(s, length, &cursor);
          if (c != unibrow::Utf8::kBadChar) {
            WriteUChar(writer_, c);
            DCHECK_NE(cursor, 0);
            s += cursor - 1;
          } else {
            writer_->AddCharacter('?');
          }
        }
    }
  }
  writer_->AddCharacter('\"');
}

void HeapSnapshotJSONSerializer::SerializeStrings() {
  base::ScopedVector<const unsigned char*> sorted_strings(strings_.occupancy() +
                                                          1);
  for (base::HashMap::Entry* entry = strings_.Start(); entry != nullptr;
       entry = strings_.Next(entry)) {
    int index = static_cast<int>(reinterpret_cast<uintptr_t>(entry->value));
    sorted_strings[index] = reinterpret_cast<const unsigned char*>(entry->key);
  }
  writer_->AddString("\"<dummy>\"");
  for (int i = 1; i < sorted_strings.length(); ++i) {
    writer_->AddCharacter(',');
    SerializeString(sorted_strings[i]);
    if (writer_->aborted()) return;
  }
}

void HeapSnapshotJSONSerializer::SerializeLocation(
    const EntrySourceLocation& location) {
  // The buffer needs space for 4 unsigned ints, 3 commas, \n and \0
  static const int kBufferSize =
      MaxDecimalDigitsIn<sizeof(unsigned)>::kUnsigned * 4 + 3 + 2;
  base::EmbeddedVector<char, kBufferSize> buffer;
  int buffer_pos = 0;
  buffer_pos = utoa(to_node_index(location.entry_index), buffer, buffer_pos);
  buffer[buffer_pos++] = ',';
  buffer_pos = utoa(location.scriptId, buffer, buffer_pos);
  buffer[buffer_pos++] = ',';
  buffer_pos = utoa(location.line, buffer, buffer_pos);
  buffer[buffer_pos++] = ',';
  buffer_pos = utoa(location.col, buffer, buffer_pos);
  buffer[buffer_pos++] = '\n';
  buffer[buffer_pos++] = '\0';
  writer_->AddString(buffer.begin());
}

void HeapSnapshotJSONSerializer::SerializeLocations() {
  const std::vector<EntrySourceLocation>& locations = snapshot_->locations();
  for (size_t i = 0; i < locations.size(); i++) {
    if (i > 0) writer_->AddCharacter(',');
    SerializeLocation(locations[i]);
    if (writer_->aborted()) return;
  }
}

}  // namespace v8::internal

"""


```
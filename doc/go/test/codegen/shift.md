Response: Let's break down the thought process for analyzing this Go code snippet.

1. **Understand the Goal:** The primary goal is to understand the functionality of the provided Go code, which is located in `go/test/codegen/shift.go`. The name itself hints at operations related to bit shifts. The `asmcheck` comment at the beginning strongly suggests this code is used to verify the assembly code generated by the Go compiler for different shift operations.

2. **Initial Scan and Categorization:**  Quickly skim through the code, noticing the comments like "// ------------------ //" that divide it into sections. These sections seem to represent different types of shift operations: constant shifts, masked shifts, signed shifts, bounded shifts, etc. This categorization is a good starting point.

3. **Analyze Each Section:** Go through each section individually.

    * **Constant Shifts:**  Functions in this section take an integer value and shift it by a constant amount. Observe the variety of data types (int64, uint64, int32, uint32, etc.) and shift amounts. The comments like `// ppc64x:"SLD"` and `// riscv64:"SLLI"` are key – they indicate the expected assembly instructions for these operations on specific architectures. This reinforces the "codegen" and "asmcheck" hints.

    * **Masked Shifts:** These functions shift by an amount that is masked using a bitwise AND operation (`s & 63`, `s & 31`). This is a common technique to ensure the shift amount stays within the valid range for the data type.

    * **Signed Shifts:** The `lshSigned` and `lshSignedMasked` functions are interesting. They highlight the difference between shifting by a potentially large signed value (which might cause a runtime panic due to excessive shift) and shifting by a masked value. The assembly check comments (`amd64:"TESTB"`, `amd64:-"TESTB"`) confirm this. The compiler might generate extra checks (like `TESTB` to see if the shift amount is valid) for unmasked signed shifts.

    * **Bounded Shifts:** The `lshGuarded64`, `rshGuarded64U`, and `rshGuarded64` functions explicitly check if the shift amount is within the bounds (less than 64 for 64-bit values) and panic if it's not. This shows how to safely perform shifts when the shift amount might be untrusted. The assembly checks confirm that the direct shift instruction (`SLL`, `SRL`, `ASR`) is used when the bound is checked.

    * **Proved Shifts:**  The `proved...Shift...` functions use `if` conditions to ensure the shift amount is within the valid range *at compile time*. This allows the compiler to optimize away any runtime checks.

    * **Other Sections:** Sections like `checkUnneededTrunc`, `checkCombinedShifts`, `checkWidenAfterShift`, `checkShiftAndMask32`, `checkMergedShifts32/64`, `checkShiftMask`, `check128bitShifts`, and `checkShiftToMask` seem to test more complex scenarios involving shifts combined with other operations like masking, type conversions, and array access. The assembly check comments are crucial here for understanding the compiler's optimization strategies. The `checkLeftShiftWithAddition` is looking for specific combined instructions.

4. **Infer the Purpose:** Based on the section analysis and the `asmcheck` comments, the core purpose of this code is to **test and verify the code generation of the Go compiler for various bit shift operations across different architectures.**  It ensures that the compiler produces efficient and correct assembly instructions for common shift patterns.

5. **Provide Examples:**  To illustrate the functionality, provide simple Go code examples that demonstrate the different categories of shift operations (constant, masked, bounded). This makes the explanation more concrete.

6. **Explain the Logic (with Assumptions):** Choose a representative function (e.g., `lshConst64x64`) and explain its logic. Make clear assumptions about the input and show the expected output.

7. **Address Command-Line Arguments:**  Recognize that this code is likely part of the Go compiler's testing infrastructure and wouldn't have direct command-line arguments in the typical user sense. Explain that it's used with the `go test` command, possibly with architecture-specific tags.

8. **Identify Common Mistakes:** Think about common pitfalls when working with bit shifts in Go. Overflowing the shift amount and not understanding signed vs. unsigned shifts are good examples. Provide simple code examples to illustrate these errors.

9. **Review and Refine:**  Read through the entire explanation, ensuring clarity, accuracy, and completeness. Make sure the examples are correct and the explanations are easy to understand. For instance, initially, I might have missed the nuance of the "proved" shift functions and their compile-time guarantees. A careful review would highlight this difference. Also, ensuring that the explanation connects the Go code to the assembly directives is important.
这个Go语言文件的主要功能是**测试Go编译器在进行位移操作时的代码生成（code generation）能力**。它通过定义一系列执行不同类型位移操作的Go函数，并使用特殊的注释（如 `// ppc64x:"SLD"`）来断言编译器为这些函数生成的汇编代码中是否包含了预期的指令。

简单来说，这个文件是Go编译器的一个测试用例，用于验证编译器是否能够针对不同的位移场景生成高效且正确的汇编代码。

**它是什么Go语言功能的实现？**

这个文件本身不是一个“实现”，而是一个“测试”。它测试的是Go语言内置的位移运算符 `<<` (左移) 和 `>>` (右移) 的编译效果。

**Go代码举例说明:**

虽然这个文件是测试，但我们可以用简单的Go代码来演示它所测试的位移操作：

```go
package main

import "fmt"

func main() {
	var a int64 = 5  // 二进制: 00000...00101
	var b uint64 = 3

	// 左移
	leftShiftResult := a << b // 5 左移 3 位，相当于 5 * 2^3 = 40
	fmt.Printf("左移结果: %d (二进制: %b)\n", leftShiftResult, leftShiftResult) // 输出: 左移结果: 40 (二进制: 101000)

	// 有符号右移
	rightShiftSignedResult := a >> b // 5 右移 3 位，相当于 5 / 2^3 的整数部分 = 0
	fmt.Printf("有符号右移结果: %d (二进制: %b)\n", rightShiftSignedResult, rightShiftSignedResult) // 输出: 有符号右移结果: 0 (二进制: 0)

	var c uint64 = 40 // 二进制: 00000...0101000
	// 无符号右移
	rightShiftUnsignedResult := c >> b // 40 右移 3 位，相当于 40 / 2^3 的整数部分 = 5
	fmt.Printf("无符号右移结果: %d (二进制: %b)\n", rightShiftUnsignedResult, rightShiftUnsignedResult) // 输出: 无符号右移结果: 5 (二进制: 101)
}
```

**代码逻辑介绍 (带假设的输入与输出):**

让我们以 `lshConst64x64` 函数为例：

```go
func lshConst64x64(v int64) int64 {
	// ppc64x:"SLD"
	// riscv64:"SLLI",-"AND",-"SLTIU"
	return v << uint64(33)
}
```

**假设输入:** `v` 的值为 `10` (二进制: `1010`)

**代码逻辑:**

1. 函数接收一个 `int64` 类型的参数 `v`。
2. 它将 `v` 左移 `uint64(33)` 位。
3. 左移操作相当于将 `v` 乘以 `2` 的 `33` 次方。

**预期输出:**  `10 * 2^33`。由于 `int64` 是有符号 64 位整数，如果结果超出其表示范围，会发生溢出。在这个测试场景中，其主要目的是验证生成的汇编指令是否正确，而不是实际的数值计算。

**关于汇编指令的注释:**

*   `// ppc64x:"SLD"`: 这个注释表示在 `ppc64x` 架构下，编译器应该为这个左移操作生成 `SLD` (Shift Left Double) 汇编指令。
*   `// riscv64:"SLLI",-"AND",-"SLTIU"`: 这个注释表示在 `riscv64` 架构下，编译器应该生成 `SLLI` (Shift Left Logical Immediate) 指令，并且不应该生成 `AND` 和 `SLTIU` 指令。

**命令行参数的具体处理:**

这个文件本身不是一个可执行程序，它是一个测试文件，主要被 `go test` 命令使用。

通常，你可以使用以下命令来运行这个测试文件（或者包含这个文件的包）：

```bash
go test -run Shift  # 运行所有包含 "Shift" 的测试
go test go/test/codegen/ # 运行 codegen 目录下的所有测试
go test -tags=ppc64x go/test/codegen/ # 只在 ppc64x 架构下运行测试
```

*   `go test`:  Go的测试命令。
*   `-run Shift`:  运行名称匹配 "Shift" 的测试函数。在这个文件中，虽然没有显式的测试函数（以 `Test` 开头），`go test` 会分析这些代码并根据 `asmcheck` 注释进行验证。
*   `go/test/codegen/`:  指定要测试的包的路径。
*   `-tags=ppc64x`:  使用构建标签来指定目标架构。这会影响 `asmcheck` 注释的匹配。

**使用者易犯错的点:**

这个文件主要是给 Go 编译器开发者使用的，普通 Go 开发者不太会直接与它交互。但是，理解其背后的原理可以帮助避免在使用位移操作时的一些常见错误：

1. **位移量超出范围:**  Go 语言规范明确指出，位移操作的右操作数（位移量）必须是非负的，并且小于左操作数的位数。例如，对于一个 `int64` 类型的变量，位移量必须在 `0` 到 `63` 之间。如果超出此范围，行为是未定义的，可能会导致运行时 panic。

    ```go
    var x int64 = 10
    // 错误示例：位移量超出范围
    // _ = x << 64 // 会导致 panic
    ```

2. **有符号和无符号右移的区别:**  对于有符号整数，右移操作会保留符号位（算术右移），而对于无符号整数，右移操作会在左侧填充零（逻辑右移）。

    ```go
    var signed int64 = -8 // 二进制 (补码): ...1111111111111000
    var unsigned uint64 = 8

    signedRightShift := signed >> 2 // 结果仍然是负数 (-2)
    unsignedRightShift := unsigned >> 2 // 结果是正数 (2)
    ```

3. **假设位移运算等同于乘除法:**  虽然在某些情况下，左移可以看作乘以 2 的幂，右移可以看作除以 2 的幂，但需要注意溢出和符号问题。对于有符号数的右移，负数的行为可能与直接除法不同。

4. **不理解位掩码 (Bitmasking) 的应用:**  位移操作常常与位与 (`&`)、位或 (`|`)、位异或 (`^`) 等操作结合使用，实现位掩码的功能。不理解这些操作的原理可能导致逻辑错误。

这个 `shift.go` 文件通过测试各种位移场景下的汇编代码生成，帮助确保 Go 编译器在处理位移操作时既正确又高效。理解其背后的逻辑对于深入理解 Go 语言的底层实现和避免位移操作中的常见错误非常有帮助。

### 提示词
```
这是路径为go/test/codegen/shift.go的go语言实现的一部分， 请归纳一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果介绍代码逻辑，则建议带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
```

### 源代码
```
// asmcheck

// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package codegen

// ------------------ //
//   constant shifts  //
// ------------------ //

func lshConst64x64(v int64) int64 {
	// ppc64x:"SLD"
	// riscv64:"SLLI",-"AND",-"SLTIU"
	return v << uint64(33)
}

func rshConst64Ux64(v uint64) uint64 {
	// ppc64x:"SRD"
	// riscv64:"SRLI\t",-"AND",-"SLTIU"
	return v >> uint64(33)
}

func rshConst64Ux64Overflow32(v uint32) uint64 {
	// riscv64:"MOV\t\\$0,",-"SRL"
	return uint64(v) >> 32
}

func rshConst64Ux64Overflow16(v uint16) uint64 {
	// riscv64:"MOV\t\\$0,",-"SRL"
	return uint64(v) >> 16
}

func rshConst64Ux64Overflow8(v uint8) uint64 {
	// riscv64:"MOV\t\\$0,",-"SRL"
	return uint64(v) >> 8
}

func rshConst64x64(v int64) int64 {
	// ppc64x:"SRAD"
	// riscv64:"SRAI\t",-"OR",-"SLTIU"
	return v >> uint64(33)
}

func rshConst64x64Overflow32(v int32) int64 {
	// riscv64:"SRAIW",-"SLLI",-"SRAI\t"
	return int64(v) >> 32
}

func rshConst64x64Overflow16(v int16) int64 {
	// riscv64:"SLLI","SRAI",-"SRAIW"
	return int64(v) >> 16
}

func rshConst64x64Overflow8(v int8) int64 {
	// riscv64:"SLLI","SRAI",-"SRAIW"
	return int64(v) >> 8
}

func lshConst32x64(v int32) int32 {
	// ppc64x:"SLW"
	// riscv64:"SLLI",-"AND",-"SLTIU", -"MOVW"
	return v << uint64(29)
}

func rshConst32Ux64(v uint32) uint32 {
	// ppc64x:"SRW"
	// riscv64:"SRLIW",-"AND",-"SLTIU", -"MOVW"
	return v >> uint64(29)
}

func rshConst32x64(v int32) int32 {
	// ppc64x:"SRAW"
	// riscv64:"SRAIW",-"OR",-"SLTIU", -"MOVW"
	return v >> uint64(29)
}

func lshConst64x32(v int64) int64 {
	// ppc64x:"SLD"
	// riscv64:"SLLI",-"AND",-"SLTIU"
	return v << uint32(33)
}

func rshConst64Ux32(v uint64) uint64 {
	// ppc64x:"SRD"
	// riscv64:"SRLI\t",-"AND",-"SLTIU"
	return v >> uint32(33)
}

func rshConst64x32(v int64) int64 {
	// ppc64x:"SRAD"
	// riscv64:"SRAI\t",-"OR",-"SLTIU"
	return v >> uint32(33)
}

// ------------------ //
//   masked shifts    //
// ------------------ //

func lshMask64x64(v int64, s uint64) int64 {
	// arm64:"LSL",-"AND"
	// ppc64x:"RLDICL",-"ORN",-"ISEL"
	// riscv64:"SLL",-"AND\t",-"SLTIU"
	// s390x:-"RISBGZ",-"AND",-"LOCGR"
	return v << (s & 63)
}

func rshMask64Ux64(v uint64, s uint64) uint64 {
	// arm64:"LSR",-"AND",-"CSEL"
	// ppc64x:"RLDICL",-"ORN",-"ISEL"
	// riscv64:"SRL\t",-"AND\t",-"SLTIU"
	// s390x:-"RISBGZ",-"AND",-"LOCGR"
	return v >> (s & 63)
}

func rshMask64x64(v int64, s uint64) int64 {
	// arm64:"ASR",-"AND",-"CSEL"
	// ppc64x:"RLDICL",-"ORN",-"ISEL"
	// riscv64:"SRA\t",-"OR",-"SLTIU"
	// s390x:-"RISBGZ",-"AND",-"LOCGR"
	return v >> (s & 63)
}

func lshMask32x64(v int32, s uint64) int32 {
	// arm64:"LSL",-"AND"
	// ppc64x:"ISEL",-"ORN"
	// riscv64:"SLL",-"AND\t",-"SLTIU"
	// s390x:-"RISBGZ",-"AND",-"LOCGR"
	return v << (s & 63)
}

func rshMask32Ux64(v uint32, s uint64) uint32 {
	// arm64:"LSR",-"AND"
	// ppc64x:"ISEL",-"ORN"
	// riscv64:"SRLW","SLTIU","NEG","AND\t",-"SRL\t"
	// s390x:-"RISBGZ",-"AND",-"LOCGR"
	return v >> (s & 63)
}

func rsh5Mask32Ux64(v uint32, s uint64) uint32 {
	// riscv64:"SRLW",-"AND\t",-"SLTIU",-"SRL\t"
	return v >> (s & 31)
}

func rshMask32x64(v int32, s uint64) int32 {
	// arm64:"ASR",-"AND"
	// ppc64x:"ISEL",-"ORN"
	// riscv64:"SRAW","OR","SLTIU"
	// s390x:-"RISBGZ",-"AND",-"LOCGR"
	return v >> (s & 63)
}

func rsh5Mask32x64(v int32, s uint64) int32 {
	// riscv64:"SRAW",-"OR",-"SLTIU"
	return v >> (s & 31)
}

func lshMask64x32(v int64, s uint32) int64 {
	// arm64:"LSL",-"AND"
	// ppc64x:"RLDICL",-"ORN"
	// riscv64:"SLL",-"AND\t",-"SLTIU"
	// s390x:-"RISBGZ",-"AND",-"LOCGR"
	return v << (s & 63)
}

func rshMask64Ux32(v uint64, s uint32) uint64 {
	// arm64:"LSR",-"AND",-"CSEL"
	// ppc64x:"RLDICL",-"ORN"
	// riscv64:"SRL\t",-"AND\t",-"SLTIU"
	// s390x:-"RISBGZ",-"AND",-"LOCGR"
	return v >> (s & 63)
}

func rshMask64x32(v int64, s uint32) int64 {
	// arm64:"ASR",-"AND",-"CSEL"
	// ppc64x:"RLDICL",-"ORN",-"ISEL"
	// riscv64:"SRA\t",-"OR",-"SLTIU"
	// s390x:-"RISBGZ",-"AND",-"LOCGR"
	return v >> (s & 63)
}

func lshMask64x32Ext(v int64, s int32) int64 {
	// ppc64x:"RLDICL",-"ORN",-"ISEL"
	// riscv64:"SLL",-"AND\t",-"SLTIU"
	// s390x:-"RISBGZ",-"AND",-"LOCGR"
	return v << uint(s&63)
}

func rshMask64Ux32Ext(v uint64, s int32) uint64 {
	// ppc64x:"RLDICL",-"ORN",-"ISEL"
	// riscv64:"SRL\t",-"AND\t",-"SLTIU"
	// s390x:-"RISBGZ",-"AND",-"LOCGR"
	return v >> uint(s&63)
}

func rshMask64x32Ext(v int64, s int32) int64 {
	// ppc64x:"RLDICL",-"ORN",-"ISEL"
	// riscv64:"SRA\t",-"OR",-"SLTIU"
	// s390x:-"RISBGZ",-"AND",-"LOCGR"
	return v >> uint(s&63)
}

// --------------- //
//  signed shifts  //
// --------------- //

// We do want to generate a test + panicshift for these cases.
func lshSigned(v8 int8, v16 int16, v32 int32, v64 int64, x int) {
	// amd64:"TESTB"
	_ = x << v8
	// amd64:"TESTW"
	_ = x << v16
	// amd64:"TESTL"
	_ = x << v32
	// amd64:"TESTQ"
	_ = x << v64
}

// We want to avoid generating a test + panicshift for these cases.
func lshSignedMasked(v8 int8, v16 int16, v32 int32, v64 int64, x int) {
	// amd64:-"TESTB"
	_ = x << (v8 & 7)
	// amd64:-"TESTW"
	_ = x << (v16 & 15)
	// amd64:-"TESTL"
	_ = x << (v32 & 31)
	// amd64:-"TESTQ"
	_ = x << (v64 & 63)
}

// ------------------ //
//   bounded shifts   //
// ------------------ //

func lshGuarded64(v int64, s uint) int64 {
	if s < 64 {
		// riscv64:"SLL",-"AND",-"SLTIU"
		// s390x:-"RISBGZ",-"AND",-"LOCGR"
		// wasm:-"Select",-".*LtU"
		// arm64:"LSL",-"CSEL"
		return v << s
	}
	panic("shift too large")
}

func rshGuarded64U(v uint64, s uint) uint64 {
	if s < 64 {
		// riscv64:"SRL\t",-"AND",-"SLTIU"
		// s390x:-"RISBGZ",-"AND",-"LOCGR"
		// wasm:-"Select",-".*LtU"
		// arm64:"LSR",-"CSEL"
		return v >> s
	}
	panic("shift too large")
}

func rshGuarded64(v int64, s uint) int64 {
	if s < 64 {
		// riscv64:"SRA\t",-"OR",-"SLTIU"
		// s390x:-"RISBGZ",-"AND",-"LOCGR"
		// wasm:-"Select",-".*LtU"
		// arm64:"ASR",-"CSEL"
		return v >> s
	}
	panic("shift too large")
}

func provedUnsignedShiftLeft(val64 uint64, val32 uint32, val16 uint16, val8 uint8, shift int) (r1 uint64, r2 uint32, r3 uint16, r4 uint8) {
	if shift >= 0 && shift < 64 {
		// arm64:"LSL",-"CSEL"
		r1 = val64 << shift
	}
	if shift >= 0 && shift < 32 {
		// arm64:"LSL",-"CSEL"
		r2 = val32 << shift
	}
	if shift >= 0 && shift < 16 {
		// arm64:"LSL",-"CSEL"
		r3 = val16 << shift
	}
	if shift >= 0 && shift < 8 {
		// arm64:"LSL",-"CSEL"
		r4 = val8 << shift
	}
	return r1, r2, r3, r4
}

func provedSignedShiftLeft(val64 int64, val32 int32, val16 int16, val8 int8, shift int) (r1 int64, r2 int32, r3 int16, r4 int8) {
	if shift >= 0 && shift < 64 {
		// arm64:"LSL",-"CSEL"
		r1 = val64 << shift
	}
	if shift >= 0 && shift < 32 {
		// arm64:"LSL",-"CSEL"
		r2 = val32 << shift
	}
	if shift >= 0 && shift < 16 {
		// arm64:"LSL",-"CSEL"
		r3 = val16 << shift
	}
	if shift >= 0 && shift < 8 {
		// arm64:"LSL",-"CSEL"
		r4 = val8 << shift
	}
	return r1, r2, r3, r4
}

func provedUnsignedShiftRight(val64 uint64, val32 uint32, val16 uint16, val8 uint8, shift int) (r1 uint64, r2 uint32, r3 uint16, r4 uint8) {
	if shift >= 0 && shift < 64 {
		// arm64:"LSR",-"CSEL"
		r1 = val64 >> shift
	}
	if shift >= 0 && shift < 32 {
		// arm64:"LSR",-"CSEL"
		r2 = val32 >> shift
	}
	if shift >= 0 && shift < 16 {
		// arm64:"LSR",-"CSEL"
		r3 = val16 >> shift
	}
	if shift >= 0 && shift < 8 {
		// arm64:"LSR",-"CSEL"
		r4 = val8 >> shift
	}
	return r1, r2, r3, r4
}

func provedSignedShiftRight(val64 int64, val32 int32, val16 int16, val8 int8, shift int) (r1 int64, r2 int32, r3 int16, r4 int8) {
	if shift >= 0 && shift < 64 {
		// arm64:"ASR",-"CSEL"
		r1 = val64 >> shift
	}
	if shift >= 0 && shift < 32 {
		// arm64:"ASR",-"CSEL"
		r2 = val32 >> shift
	}
	if shift >= 0 && shift < 16 {
		// arm64:"ASR",-"CSEL"
		r3 = val16 >> shift
	}
	if shift >= 0 && shift < 8 {
		// arm64:"ASR",-"CSEL"
		r4 = val8 >> shift
	}
	return r1, r2, r3, r4
}

func checkUnneededTrunc(tab *[100000]uint32, d uint64, v uint32, h uint16, b byte) (uint32, uint64) {

	// ppc64x:-".*RLWINM",-".*RLDICR",".*CLRLSLDI"
	f := tab[byte(v)^b]
	// ppc64x:-".*RLWINM",-".*RLDICR",".*CLRLSLDI"
	f += tab[byte(v)&b]
	// ppc64x:-".*RLWINM",-".*RLDICR",".*CLRLSLDI"
	f += tab[byte(v)|b]
	// ppc64x:-".*RLWINM",-".*RLDICR",".*CLRLSLDI"
	f += tab[uint16(v)&h]
	// ppc64x:-".*RLWINM",-".*RLDICR",".*CLRLSLDI"
	f += tab[uint16(v)^h]
	// ppc64x:-".*RLWINM",-".*RLDICR",".*CLRLSLDI"
	f += tab[uint16(v)|h]
	// ppc64x:-".*AND",-"RLDICR",".*CLRLSLDI"
	f += tab[v&0xff]
	// ppc64x:-".*AND",".*CLRLSLWI"
	f += 2 * uint32(uint16(d))
	// ppc64x:-".*AND",-"RLDICR",".*CLRLSLDI"
	g := 2 * uint64(uint32(d))
	return f, g
}

func checkCombinedShifts(v8 uint8, v16 uint16, v32 uint32, x32 int32, v64 uint64) (uint8, uint16, uint32, uint64, int64) {

	// ppc64x:-"AND","CLRLSLWI"
	f := (v8 & 0xF) << 2
	// ppc64x:"CLRLSLWI"
	f += byte(v16) << 3
	// ppc64x:-"AND","CLRLSLWI"
	g := (v16 & 0xFF) << 3
	// ppc64x:-"AND","CLRLSLWI"
	h := (v32 & 0xFFFFF) << 2
	// ppc64x:"CLRLSLDI"
	i := (v64 & 0xFFFFFFFF) << 5
	// ppc64x:-"CLRLSLDI"
	i += (v64 & 0xFFFFFFF) << 38
	// ppc64x/power9:-"CLRLSLDI"
	i += (v64 & 0xFFFF00) << 10
	// ppc64x/power9:-"SLD","EXTSWSLI"
	j := int64(x32+32) * 8
	return f, g, h, i, j
}

func checkWidenAfterShift(v int64, u uint64) (int64, uint64) {

	// ppc64x:-".*MOVW"
	f := int32(v >> 32)
	// ppc64x:".*MOVW"
	f += int32(v >> 31)
	// ppc64x:-".*MOVH"
	g := int16(v >> 48)
	// ppc64x:".*MOVH"
	g += int16(v >> 30)
	// ppc64x:-".*MOVH"
	g += int16(f >> 16)
	// ppc64x:-".*MOVB"
	h := int8(v >> 56)
	// ppc64x:".*MOVB"
	h += int8(v >> 28)
	// ppc64x:-".*MOVB"
	h += int8(f >> 24)
	// ppc64x:".*MOVB"
	h += int8(f >> 16)
	return int64(h), uint64(g)
}

func checkShiftAndMask32(v []uint32) {
	i := 0

	// ppc64x: "RLWNM\t[$]24, R[0-9]+, [$]12, [$]19, R[0-9]+"
	v[i] = (v[i] & 0xFF00000) >> 8
	i++
	// ppc64x: "RLWNM\t[$]26, R[0-9]+, [$]22, [$]29, R[0-9]+"
	v[i] = (v[i] & 0xFF00) >> 6
	i++
	// ppc64x: "MOVW\tR0"
	v[i] = (v[i] & 0xFF) >> 8
	i++
	// ppc64x: "MOVW\tR0"
	v[i] = (v[i] & 0xF000000) >> 28
	i++
	// ppc64x: "RLWNM\t[$]26, R[0-9]+, [$]24, [$]31, R[0-9]+"
	v[i] = (v[i] >> 6) & 0xFF
	i++
	// ppc64x: "RLWNM\t[$]26, R[0-9]+, [$]12, [$]19, R[0-9]+"
	v[i] = (v[i] >> 6) & 0xFF000
	i++
	// ppc64x: "MOVW\tR0"
	v[i] = (v[i] >> 20) & 0xFF000
	i++
	// ppc64x: "MOVW\tR0"
	v[i] = (v[i] >> 24) & 0xFF00
	i++
}

func checkMergedShifts32(a [256]uint32, b [256]uint64, u uint32, v uint32) {
	// ppc64x: -"CLRLSLDI", "RLWNM\t[$]10, R[0-9]+, [$]22, [$]29, R[0-9]+"
	a[0] = a[uint8(v>>24)]
	// ppc64x: -"CLRLSLDI", "RLWNM\t[$]11, R[0-9]+, [$]21, [$]28, R[0-9]+"
	b[0] = b[uint8(v>>24)]
	// ppc64x: -"CLRLSLDI", "RLWNM\t[$]15, R[0-9]+, [$]21, [$]28, R[0-9]+"
	b[1] = b[(v>>20)&0xFF]
	// ppc64x: -"SLD", "RLWNM\t[$]10, R[0-9]+, [$]22, [$]28, R[0-9]+"
	b[2] = b[v>>25]
}

func checkMergedShifts64(a [256]uint32, b [256]uint64, c [256]byte, v uint64) {
	// ppc64x: -"CLRLSLDI", "RLWNM\t[$]10, R[0-9]+, [$]22, [$]29, R[0-9]+"
	a[0] = a[uint8(v>>24)]
	// ppc64x: "SRD", "CLRLSLDI", -"RLWNM"
	a[1] = a[uint8(v>>25)]
	// ppc64x: -"CLRLSLDI", "RLWNM\t[$]9, R[0-9]+, [$]23, [$]29, R[0-9]+"
	a[2] = a[v>>25&0x7F]
	// ppc64x: -"CLRLSLDI", "RLWNM\t[$]3, R[0-9]+, [$]29, [$]29, R[0-9]+"
	a[3] = a[(v>>31)&0x01]
	// ppc64x: -"CLRLSLDI", "RLWNM\t[$]12, R[0-9]+, [$]21, [$]28, R[0-9]+"
	b[0] = b[uint8(v>>23)]
	// ppc64x: -"CLRLSLDI", "RLWNM\t[$]15, R[0-9]+, [$]21, [$]28, R[0-9]+"
	b[1] = b[(v>>20)&0xFF]
	// ppc64x: "RLWNM", -"SLD"
	b[2] = b[((uint64((uint32(v) >> 21)) & 0x3f) << 4)]
	// ppc64x: "RLWNM\t[$]11, R[0-9]+, [$]10, [$]15"
	c[0] = c[((v>>5)&0x3F)<<16]
	// ppc64x: "ANDCC\t[$]8064,"
	c[1] = c[((v>>7)&0x3F)<<7]
}

func checkShiftMask(a uint32, b uint64, z []uint32, y []uint64) {
	_ = y[128]
	_ = z[128]
	// ppc64x: -"MOVBZ", -"SRW", "RLWNM"
	z[0] = uint32(uint8(a >> 5))
	// ppc64x: -"MOVBZ", -"SRW", "RLWNM"
	z[1] = uint32(uint8((a >> 4) & 0x7e))
	// ppc64x: "RLWNM\t[$]25, R[0-9]+, [$]27, [$]29, R[0-9]+"
	z[2] = uint32(uint8(a>>7)) & 0x1c
	// ppc64x: -"MOVWZ"
	y[0] = uint64((a >> 6) & 0x1c)
	// ppc64x: -"MOVWZ"
	y[1] = uint64(uint32(b)<<6) + 1
	// ppc64x: -"MOVHZ", -"MOVWZ"
	y[2] = uint64((uint16(a) >> 9) & 0x1F)
	// ppc64x: -"MOVHZ", -"MOVWZ", -"ANDCC"
	y[3] = uint64(((uint16(a) & 0xFF0) >> 9) & 0x1F)
}

// 128 bit shifts

func check128bitShifts(x, y uint64, bits uint) (uint64, uint64) {
	s := bits & 63
	ŝ := (64 - bits) & 63
	// check that the shift operation has two commas (three operands)
	// amd64:"SHRQ.*,.*,"
	shr := x>>s | y<<ŝ
	// amd64:"SHLQ.*,.*,"
	shl := x<<s | y>>ŝ
	return shr, shl
}

func checkShiftToMask(u []uint64, s []int64) {
	// amd64:-"SHR",-"SHL","ANDQ"
	u[0] = u[0] >> 5 << 5
	// amd64:-"SAR",-"SHL","ANDQ"
	s[0] = s[0] >> 5 << 5
	// amd64:-"SHR",-"SHL","ANDQ"
	u[1] = u[1] << 5 >> 5
}

//
// Left shift with addition.
//

func checkLeftShiftWithAddition(a int64, b int64) int64 {
	// riscv64/rva20u64: "SLLI","ADD"
	// riscv64/rva22u64: "SH1ADD"
	a = a + b<<1
	// riscv64/rva20u64: "SLLI","ADD"
	// riscv64/rva22u64: "SH2ADD"
	a = a + b<<2
	// riscv64/rva20u64: "SLLI","ADD"
	// riscv64/rva22u64: "SH3ADD"
	a = a + b<<3
	return a
}
```
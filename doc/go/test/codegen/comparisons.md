Response: My thinking process to analyze the provided Go code snippet went through these stages:

1. **Initial Scan for Purpose:** I first scanned the code for comments and function/type names. The initial comment "// This file contains code generation tests related to the comparison operators." immediately gives the core purpose. The filename `comparisons.go` reinforces this. The `// asmcheck` comment suggests that these tests are designed to verify the assembly code generated by the Go compiler for comparison operations.

2. **Categorization of Tests:**  I noticed the code was logically divided by comments like `// -------------- // //    Equality    // // -------------- //` and `// -------------- // //    Ordering    // // -------------- //`. This indicates two main categories of comparison tests: equality and ordering.

3. **Equality Tests Deep Dive:**
    * **String Comparisons:**  Functions like `CompareString1`, `CompareString2`, `CompareString3` compare strings against constant values. The assembly directives (`// amd64:` etc.) are key here, suggesting the tests are checking for specific assembly instructions based on the string length (2, 4, and 8 bytes). This implies the compiler is optimizing string comparisons by using word-sized comparisons when possible.
    * **Array Comparisons:**  Functions `CompareArray1` through `CompareArray5` compare arrays of bytes, `uint16`, and `int16`. Again, the assembly directives indicate a check for word-sized comparisons.
    * **Struct Comparisons:** `CompareStruct1` through `CompareStruct4` deal with comparing structs of different sizes. The assembly directives differentiate between inline comparisons (using `CMPQ`) for smaller structs and calls to a `memequal` function for larger structs (to avoid excessive code bloat).
    * **`unsafe.Pointer` Comparison:** `CompareArray6` involves comparing the memory pointed to by `unsafe.Pointer`. The assembly checks are similar to the basic data type comparisons.

4. **Ordering Tests Deep Dive:**
    * **Folding Optimizations:** `CmpFold` checks if the compiler folds constant additions into the `SETx` instructions (setting a byte based on a comparison result).
    * **Direct Memory Comparisons:**  `CmpMem1` through `CmpMem6` test comparisons involving direct memory access (pointers). The assembly directives look for `CMPQ` instructions, indicating direct comparison with memory contents.
    * **Comparison with Zero:**  `CmpZero1` through `CmpZero4` and `CmpToZero` check for the generation of efficient `TBZ`/`TBNZ` (Test Bit and Branch if Zero/Non-Zero) instructions on ARM64 when comparing against zero. `CmpLogicalToZero` and the `CmpToZero_ex*` functions explore various scenarios of comparing expressions to zero, looking for specific assembly instruction patterns. I noticed the complexity increasing here, covering cases like `var + const`, `var + var`, and `var + var * var`.
    * **Unsigned Integer Comparisons:** `UintLtZero`, `UintGeqZero`, etc., test how unsigned integers are compared against zero and one. The negative assembly directives suggest the absence of certain signed comparison instructions.
    * **String Equality Optimizations:** Functions like `equalConstString1` through `equalVarString8` check if the compiler avoids calls to `memequal` for small string comparisons, instead using direct register comparisons.
    * **Comparison with Negated Variables:** `cmpToCmn` and related functions check if the compiler transforms comparisons with negated variables (e.g., `a == -c`) into equivalent forms using `CMN` (compare negative).
    * **Comparison with Zero Value:** `cmp1` through `cmp6` test comparisons against the zero value of a string or a generic type. The negative `memequal` directives indicate optimization.
    * **Geometric Calculation:** `invertLessThanNoov` performs a geometric calculation and checks for a specific assembly instruction sequence involving `CMP`, `CSET`, and `CSEL`.
    * **`cmp.Compare` Function:** `cmpstring1` and `cmpstring2` test the assembly generated for direct string comparison and for using the `cmp.Compare` function, looking for different assembly patterns.

5. **Identifying the Go Feature:** Based on the prevalence of comparison operators (`==`, `!=`, `<`, `>`, `<=`, `>=`) and the tests focusing on different data types (strings, arrays, structs, integers), it became clear that the code is testing the **implementation and optimization of Go's comparison operators**.

6. **Code Example Construction:** To illustrate the functionality, I chose a simple example demonstrating string and integer comparisons, highlighting the core concept being tested.

7. **Code Logic and Assumptions:**  I explained that the tests primarily rely on **assembly directives** to assert the presence or absence of specific assembly instructions for different architectures. The "input" is the Go code itself, and the "output" is the assembly code generated by the compiler.

8. **Command-Line Arguments:**  I recognized the `// asmcheck` comment and explained its role in triggering these assembly checks during the Go testing process.

9. **Common Mistakes:** I focused on the key mistake users might make when working with comparisons: **incorrectly assuming the performance characteristics of different comparison methods** (e.g., manual byte-by-byte comparison vs. relying on Go's built-in operators).

10. **Review and Refinement:** Finally, I reviewed my analysis to ensure clarity, accuracy, and completeness, aligning it with the structure and content of the provided code snippet. I made sure the code example was simple and illustrative, and the explanation of the assembly directives was clear.这段Go语言代码是 `go/test/codegen/comparisons.go` 文件的一部分，它的主要功能是 **进行代码生成测试，专门针对Go语言的比较运算符的实现和优化**。

简单来说，它通过编写一系列包含比较运算的Go函数，并使用特殊的注释（如 `// amd64:`）来断言编译器为这些比较操作生成了特定的汇编指令。这是一种验证编译器代码生成质量和优化效果的手段。

**它是什么Go语言功能的实现？**

这段代码主要测试以下Go语言功能的实现：

1. **各种数据类型的相等性比较 (`==`, `!=`)：**
   - 基本类型：整数、浮点数（虽然代码中没有直接体现，但推测测试框架会包含）。
   - 字符串：测试了与常量字符串的比较，以及不同长度字符串的比较。
   - 数组：测试了不同长度和元素类型的数组的比较。
   - 结构体：测试了不同大小的结构体的比较，以及编译器是否会内联比较操作还是调用 `memequal` 等函数。
   - 指针：测试了 `unsafe.Pointer` 类型的比较。

2. **各种数据类型的顺序比较 (`<`, `>`, `<=`, `>=`)：**
   - 基本类型：整数。
   - 指针：测试了与指针的比较。
   - 切片元素：测试了访问切片元素时的比较。

3. **比较运算的优化：**
   - **针对常量字符串的优化：** 编译器会根据字符串长度选择最优的字节比较指令（例如 `CMPW` 用于2字节，`CMPL` 用于4字节，`CMPQ` 用于8字节）。
   - **针对数组和结构体的优化：**  对于较小的数组和结构体，编译器会尝试使用更高效的逐字节或逐字比较指令，而不是调用通用的内存比较函数。对于较大的结构体，为了避免代码膨胀，可能会选择调用 `memequal` 等函数。
   - **针对与零的比较优化：** 在ARM64架构上，编译器会尝试使用 `TBZ` (Test Bit and Branch if Zero) 和 `TBNZ` (Test Bit and Branch if Non-Zero) 指令来优化与零的比较。
   - **指令折叠：** 例如，将 `LEAQ` 和 `ADDQconst` 指令折叠到 `SETx` 操作中。
   - **直接内存比较：** 编译器在可能的情况下会生成直接与内存进行比较的指令，而不是先将内存中的值加载到寄存器。
   - **小字符串比较优化：** 避免对小字符串调用通用的 `memequal` 函数，而是使用更高效的比较指令。
   - **将比较转换为 CMN 指令：** 在某些情况下，例如与负常数比较时，编译器会将 `CMP` 指令转换为 `CMN` (compare negative) 指令，以提高效率。

**Go代码举例说明:**

```go
package main

import "fmt"

func compareStrings(s1, s2 string) bool {
	return s1 == s2
}

func compareInts(a, b int) bool {
	return a > b
}

func compareArrays(arr1, arr2 [3]int) bool {
	return arr1 == arr2
}

func main() {
	fmt.Println(compareStrings("hello", "world")) // Output: false
	fmt.Println(compareStrings("test", "test"))   // Output: true
	fmt.Println(compareInts(10, 5))             // Output: true
	fmt.Println(compareArrays([3]int{1, 2, 3}, [3]int{1, 2, 4})) // Output: false
	fmt.Println(compareArrays([3]int{1, 2, 3}, [3]int{1, 2, 3})) // Output: true
}
```

**代码逻辑介绍（带假设的输入与输出）：**

假设我们关注 `CompareString1` 函数：

```go
func CompareString1(s string) bool {
	// amd64:`CMPW\t\(.*\), [$]`
	// arm64:`MOVHU\t\(.*\), [R]`,`MOVD\t[$]`,`CMPW\tR`
	// ppc64le:`MOVHZ\t\(.*\), [R]`,`CMPW\t.*, [$]`
	// s390x:`MOVHBR\t\(.*\), [R]`,`CMPW\t.*, [$]`
	return s == "xx"
}
```

**假设输入：**
- `s` 为字符串 "xx"
- `s` 为字符串 "xy"
- `s` 为字符串 "xxx"

**代码逻辑：**
该函数将输入的字符串 `s` 与常量字符串 "xx" 进行相等性比较。

**预期输出（根据汇编指令断言）：**
- 当 `s` 为 "xx" 时，函数返回 `true`。
- 当 `s` 为 "xy" 时，函数返回 `false`。
- 当 `s` 为 "xxx" 时，函数返回 `false`。

**汇编指令断言的含义：**
- `// amd64:` `CMPW\t\(.*\), [$]\`` 表示在 AMD64 架构下，编译器应该生成一个 `CMPW` (Compare Word - 2字节比较) 指令，用于将字符串 `s` 的前两个字节与常量 "xx" 进行比较。 `\(.*\)` 匹配内存地址，`[$]` 匹配立即数。
- 类似的，对于其他架构，也指定了预期的汇编指令序列，例如 ARM64 使用 `MOVHU` (Move Halfword Unsigned) 加载字符串部分，然后用 `CMPW` 比较。

**涉及命令行参数的具体处理：**

这段代码本身不直接处理命令行参数。它是 Go 源码的一部分，用于测试编译器的代码生成。测试通常通过 `go test` 命令运行。

`go test` 命令会解析 `// asmcheck` 注释，并指示 Go 编译器在编译测试代码时生成汇编代码，然后将生成的汇编代码与注释中指定的模式进行匹配。如果匹配失败，测试就会失败。

**使用者易犯错的点：**

在编写类似的代码生成测试时，使用者可能会犯以下错误：

1. **汇编指令理解错误：**  对不同架构的汇编指令不熟悉，导致断言的指令不正确。例如，混淆了不同大小的比较指令（`CMPB`, `CMPW`, `CMPL`, `CMPQ`）。
2. **正则表达式编写错误：**  `// amd64:` 等注释后面跟着的是正则表达式，用于匹配汇编指令。正则表达式编写错误会导致无法正确匹配到预期的指令。例如，缺少转义字符或使用了错误的通配符。
3. **忽略不同架构的差异：**  不同 CPU 架构的指令集不同，即使是执行相同的比较操作，生成的汇编指令也会有差异。需要针对不同的目标架构编写不同的断言。
4. **过度依赖特定指令：**  编译器的优化策略可能会随着 Go 版本更新而变化，过于严格地限定特定指令可能会导致测试在未来的 Go 版本中失效。应该关注比较操作的核心逻辑，而不是过于细节的指令形式。
5. **测试用例覆盖不足：**  可能只测试了部分比较场景，而忽略了其他重要的边界情况或特殊情况，导致某些优化问题没有被发现。

**总结:**

`go/test/codegen/comparisons.go` 是一个用于测试 Go 编译器比较运算符代码生成的关键文件。它通过断言生成的汇编指令来验证编译器的优化策略和实现是否符合预期。理解这段代码需要一定的汇编语言基础和对 Go 编译器工作原理的了解。

Prompt: 
```
这是路径为go/test/codegen/comparisons.go的go语言实现的一部分， 请归纳一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果介绍代码逻辑，则建议带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，

"""
// asmcheck

// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package codegen

import (
	"cmp"
	"unsafe"
)

// This file contains code generation tests related to the comparison
// operators.

// -------------- //
//    Equality    //
// -------------- //

// Check that compare to constant string use 2/4/8 byte compares

func CompareString1(s string) bool {
	// amd64:`CMPW\t\(.*\), [$]`
	// arm64:`MOVHU\t\(.*\), [R]`,`MOVD\t[$]`,`CMPW\tR`
	// ppc64le:`MOVHZ\t\(.*\), [R]`,`CMPW\t.*, [$]`
	// s390x:`MOVHBR\t\(.*\), [R]`,`CMPW\t.*, [$]`
	return s == "xx"
}

func CompareString2(s string) bool {
	// amd64:`CMPL\t\(.*\), [$]`
	// arm64:`MOVWU\t\(.*\), [R]`,`CMPW\t.*, [R]`
	// ppc64le:`MOVWZ\t\(.*\), [R]`,`CMPW\t.*, [R]`
	// s390x:`MOVWBR\t\(.*\), [R]`,`CMPW\t.*, [$]`
	return s == "xxxx"
}

func CompareString3(s string) bool {
	// amd64:`CMPQ\t\(.*\), [A-Z]`
	// arm64:-`CMPW\t`
	// ppc64x:-`CMPW\t`
	// s390x:-`CMPW\t`
	return s == "xxxxxxxx"
}

// Check that arrays compare use 2/4/8 byte compares

func CompareArray1(a, b [2]byte) bool {
	// amd64:`CMPW\tcommand-line-arguments[.+_a-z0-9]+\(SP\), [A-Z]`
	// arm64:-`MOVBU\t`
	// ppc64le:-`MOVBZ\t`
	// s390x:-`MOVBZ\t`
	return a == b
}

func CompareArray2(a, b [3]uint16) bool {
	// amd64:`CMPL\tcommand-line-arguments[.+_a-z0-9]+\(SP\), [A-Z]`
	// amd64:`CMPW\tcommand-line-arguments[.+_a-z0-9]+\(SP\), [A-Z]`
	return a == b
}

func CompareArray3(a, b [3]int16) bool {
	// amd64:`CMPL\tcommand-line-arguments[.+_a-z0-9]+\(SP\), [A-Z]`
	// amd64:`CMPW\tcommand-line-arguments[.+_a-z0-9]+\(SP\), [A-Z]`
	return a == b
}

func CompareArray4(a, b [12]int8) bool {
	// amd64:`CMPQ\tcommand-line-arguments[.+_a-z0-9]+\(SP\), [A-Z]`
	// amd64:`CMPL\tcommand-line-arguments[.+_a-z0-9]+\(SP\), [A-Z]`
	return a == b
}

func CompareArray5(a, b [15]byte) bool {
	// amd64:`CMPQ\tcommand-line-arguments[.+_a-z0-9]+\(SP\), [A-Z]`
	return a == b
}

// This was a TODO in mapaccess1_faststr
func CompareArray6(a, b unsafe.Pointer) bool {
	// amd64:`CMPL\t\(.*\), [A-Z]`
	// arm64:`MOVWU\t\(.*\), [R]`,`CMPW\t.*, [R]`
	// ppc64le:`MOVWZ\t\(.*\), [R]`,`CMPW\t.*, [R]`
	// s390x:`MOVWBR\t\(.*\), [R]`,`CMPW\t.*, [R]`
	return *((*[4]byte)(a)) != *((*[4]byte)(b))
}

// Check that some structs generate 2/4/8 byte compares.

type T1 struct {
	a [8]byte
}

func CompareStruct1(s1, s2 T1) bool {
	// amd64:`CMPQ\tcommand-line-arguments[.+_a-z0-9]+\(SP\), [A-Z]`
	// amd64:-`CALL`
	return s1 == s2
}

type T2 struct {
	a [16]byte
}

func CompareStruct2(s1, s2 T2) bool {
	// amd64:`CMPQ\tcommand-line-arguments[.+_a-z0-9]+\(SP\), [A-Z]`
	// amd64:-`CALL`
	return s1 == s2
}

// Assert that a memequal call is still generated when
// inlining would increase binary size too much.

type T3 struct {
	a [24]byte
}

func CompareStruct3(s1, s2 T3) bool {
	// amd64:-`CMPQ\tcommand-line-arguments[.+_a-z0-9]+\(SP\), [A-Z]`
	// amd64:`CALL`
	return s1 == s2
}

type T4 struct {
	a [32]byte
}

func CompareStruct4(s1, s2 T4) bool {
	// amd64:-`CMPQ\tcommand-line-arguments[.+_a-z0-9]+\(SP\), [A-Z]`
	// amd64:`CALL`
	return s1 == s2
}

// -------------- //
//    Ordering    //
// -------------- //

// Test that LEAQ/ADDQconst are folded into SETx ops

var r bool

func CmpFold(x uint32) {
	// amd64:`SETHI\t.*\(SB\)`
	r = x > 4
}

// Test that direct comparisons with memory are generated when
// possible

func CmpMem1(p int, q *int) bool {
	// amd64:`CMPQ\t\(.*\), [A-Z]`
	return p < *q
}

func CmpMem2(p *int, q int) bool {
	// amd64:`CMPQ\t\(.*\), [A-Z]`
	return *p < q
}

func CmpMem3(p *int) bool {
	// amd64:`CMPQ\t\(.*\), [$]7`
	return *p < 7
}

func CmpMem4(p *int) bool {
	// amd64:`CMPQ\t\(.*\), [$]7`
	return 7 < *p
}

func CmpMem5(p **int) {
	// amd64:`CMPL\truntime.writeBarrier\(SB\), [$]0`
	*p = nil
}

func CmpMem6(a []int) int {
	// 386:`CMPL\s8\([A-Z]+\),`
	// amd64:`CMPQ\s16\([A-Z]+\),`
	if a[1] > a[2] {
		return 1
	} else {
		return 2
	}
}

// Check tbz/tbnz are generated when comparing against zero on arm64

func CmpZero1(a int32, ptr *int) {
	if a < 0 { // arm64:"TBZ"
		*ptr = 0
	}
}

func CmpZero2(a int64, ptr *int) {
	if a < 0 { // arm64:"TBZ"
		*ptr = 0
	}
}

func CmpZero3(a int32, ptr *int) {
	if a >= 0 { // arm64:"TBNZ"
		*ptr = 0
	}
}

func CmpZero4(a int64, ptr *int) {
	if a >= 0 { // arm64:"TBNZ"
		*ptr = 0
	}
}

func CmpToZero(a, b, d int32, e, f int64, deOptC0, deOptC1 bool) int32 {
	// arm:`TST`,-`AND`
	// arm64:`TSTW`,-`AND`
	// 386:`TESTL`,-`ANDL`
	// amd64:`TESTL`,-`ANDL`
	c0 := a&b < 0
	// arm:`CMN`,-`ADD`
	// arm64:`CMNW`,-`ADD`
	c1 := a+b < 0
	// arm:`TEQ`,-`XOR`
	c2 := a^b < 0
	// arm64:`TST`,-`AND`
	// amd64:`TESTQ`,-`ANDQ`
	c3 := e&f < 0
	// arm64:`CMN`,-`ADD`
	c4 := e+f < 0
	// not optimized to single CMNW/CMN due to further use of b+d
	// arm64:`ADD`,-`CMNW`
	// arm:`ADD`,-`CMN`
	c5 := b+d == 0
	// not optimized to single TSTW/TST due to further use of a&d
	// arm64:`AND`,-`TSTW`
	// arm:`AND`,-`TST`
	// 386:`ANDL`
	c6 := a&d >= 0
	// For arm64, could be TST+BGE or AND+TBZ
	c7 := e&(f<<3) < 0
	// For arm64, could be CMN+BPL or ADD+TBZ
	c8 := e+(f<<3) < 0
	// arm64:`TST\sR[0-9],\sR[0-9]+`
	c9 := e&(-19) < 0
	if c0 {
		return 1
	} else if c1 {
		return 2
	} else if c2 {
		return 3
	} else if c3 {
		return 4
	} else if c4 {
		return 5
	} else if c5 {
		return 6
	} else if c6 {
		return 7
	} else if c7 {
		return 9
	} else if c8 {
		return 10
	} else if c9 {
		return 11
	} else if deOptC0 {
		return b + d
	} else if deOptC1 {
		return a & d
	} else {
		return 0
	}
}

func CmpLogicalToZero(a, b, c uint32, d, e, f, g uint64) uint64 {

	// ppc64x:"ANDCC",-"CMPW"
	// wasm:"I64Eqz",-"I32Eqz",-"I64ExtendI32U",-"I32WrapI64"
	if a&63 == 0 {
		return 1
	}

	// ppc64x:"ANDCC",-"CMP"
	// wasm:"I64Eqz",-"I32Eqz",-"I64ExtendI32U",-"I32WrapI64"
	if d&255 == 0 {
		return 1
	}

	// ppc64x:"ANDCC",-"CMP"
	// wasm:"I64Eqz",-"I32Eqz",-"I64ExtendI32U",-"I32WrapI64"
	if d&e == 0 {
		return 1
	}
	// ppc64x:"ORCC",-"CMP"
	// wasm:"I64Eqz",-"I32Eqz",-"I64ExtendI32U",-"I32WrapI64"
	if f|g == 0 {
		return 1
	}

	// ppc64x:"XORCC",-"CMP"
	// wasm:"I64Eqz","I32Eqz",-"I64ExtendI32U",-"I32WrapI64"
	if e^d == 0 {
		return 1
	}
	return 0
}

// The following CmpToZero_ex* check that cmp|cmn with bmi|bpl are generated for
// 'comparing to zero' expressions

// var + const
// 'x-const' might be canonicalized to 'x+(-const)', so we check both
// CMN and CMP for subtraction expressions to make the pattern robust.
func CmpToZero_ex1(a int64, e int32) int {
	// arm64:`CMN`,-`ADD`,`(BMI|BPL)`
	if a+3 < 0 {
		return 1
	}

	// arm64:`CMN`,-`ADD`,`BEQ`,`(BMI|BPL)`
	if a+5 <= 0 {
		return 1
	}

	// arm64:`CMN`,-`ADD`,`(BMI|BPL)`
	if a+13 >= 0 {
		return 2
	}

	// arm64:`CMP|CMN`,-`(ADD|SUB)`,`(BMI|BPL)`
	if a-7 < 0 {
		return 3
	}

	// arm64:`SUB`,`TBZ`
	if a-11 >= 0 {
		return 4
	}

	// arm64:`SUB`,`CMP`,`BGT`
	if a-19 > 0 {
		return 4
	}

	// arm64:`CMNW`,-`ADDW`,`(BMI|BPL)`
	// arm:`CMN`,-`ADD`,`(BMI|BPL)`
	if e+3 < 0 {
		return 5
	}

	// arm64:`CMNW`,-`ADDW`,`(BMI|BPL)`
	// arm:`CMN`,-`ADD`,`(BMI|BPL)`
	if e+13 >= 0 {
		return 6
	}

	// arm64:`CMPW|CMNW`,`(BMI|BPL)`
	// arm:`CMP|CMN`, -`(ADD|SUB)`, `(BMI|BPL)`
	if e-7 < 0 {
		return 7
	}

	// arm64:`SUB`,`TBNZ`
	// arm:`CMP|CMN`, -`(ADD|SUB)`, `(BMI|BPL)`
	if e-11 >= 0 {
		return 8
	}

	return 0
}

// var + var
// TODO: optimize 'var - var'
func CmpToZero_ex2(a, b, c int64, e, f, g int32) int {
	// arm64:`CMN`,-`ADD`,`(BMI|BPL)`
	if a+b < 0 {
		return 1
	}

	// arm64:`CMN`,-`ADD`,`BEQ`,`(BMI|BPL)`
	if a+c <= 0 {
		return 1
	}

	// arm64:`CMN`,-`ADD`,`(BMI|BPL)`
	if b+c >= 0 {
		return 2
	}

	// arm64:`CMNW`,-`ADDW`,`(BMI|BPL)`
	// arm:`CMN`,-`ADD`,`(BMI|BPL)`
	if e+f < 0 {
		return 5
	}

	// arm64:`CMNW`,-`ADDW`,`(BMI|BPL)`
	// arm:`CMN`,-`ADD`,`(BMI|BPL)`
	if f+g >= 0 {
		return 6
	}
	return 0
}

// var + var*var
func CmpToZero_ex3(a, b, c, d int64, e, f, g, h int32) int {
	// arm64:`CMN`,-`MADD`,`MUL`,`(BMI|BPL)`
	if a+b*c < 0 {
		return 1
	}

	// arm64:`CMN`,-`MADD`,`MUL`,`(BMI|BPL)`
	if b+c*d >= 0 {
		return 2
	}

	// arm64:`CMNW`,-`MADDW`,`MULW`,`BEQ`,`(BMI|BPL)`
	// arm:`CMN`,-`MULA`,`MUL`,`BEQ`,`(BMI|BPL)`
	if e+f*g > 0 {
		return 5
	}

	// arm64:`CMNW`,-`MADDW`,`MULW`,`BEQ`,`(BMI|BPL)`
	// arm:`CMN`,-`MULA`,`MUL`,`BEQ`,`(BMI|BPL)`
	if f+g*h <= 0 {
		return 6
	}
	return 0
}

// var - var*var
func CmpToZero_ex4(a, b, c, d int64, e, f, g, h int32) int {
	// arm64:`CMP`,-`MSUB`,`MUL`,`BEQ`,`(BMI|BPL)`
	if a-b*c > 0 {
		return 1
	}

	// arm64:`CMP`,-`MSUB`,`MUL`,`(BMI|BPL)`
	if b-c*d >= 0 {
		return 2
	}

	// arm64:`CMPW`,-`MSUBW`,`MULW`,`(BMI|BPL)`
	if e-f*g < 0 {
		return 5
	}

	// arm64:`CMPW`,-`MSUBW`,`MULW`,`(BMI|BPL)`
	if f-g*h >= 0 {
		return 6
	}
	return 0
}

func CmpToZero_ex5(e, f int32, u uint32) int {
	// arm:`CMN`,-`ADD`,`BEQ`,`(BMI|BPL)`
	if e+f<<1 > 0 {
		return 1
	}

	// arm:`CMP`,-`SUB`,`(BMI|BPL)`
	if f-int32(u>>2) >= 0 {
		return 2
	}
	return 0
}

func UintLtZero(a uint8, b uint16, c uint32, d uint64) int {
	// amd64: -`(TESTB|TESTW|TESTL|TESTQ|JCC|JCS)`
	// arm64: -`(CMPW|CMP|BHS|BLO)`
	if a < 0 || b < 0 || c < 0 || d < 0 {
		return 1
	}
	return 0
}

func UintGeqZero(a uint8, b uint16, c uint32, d uint64) int {
	// amd64: -`(TESTB|TESTW|TESTL|TESTQ|JCS|JCC)`
	// arm64: -`(CMPW|CMP|BLO|BHS)`
	if a >= 0 || b >= 0 || c >= 0 || d >= 0 {
		return 1
	}
	return 0
}

func UintGtZero(a uint8, b uint16, c uint32, d uint64) int {
	// arm64: `(CBN?ZW)`, `(CBN?Z[^W])`, -`(CMPW|CMP|BLS|BHI)`
	if a > 0 || b > 0 || c > 0 || d > 0 {
		return 1
	}
	return 0
}

func UintLeqZero(a uint8, b uint16, c uint32, d uint64) int {
	// arm64: `(CBN?ZW)`, `(CBN?Z[^W])`, -`(CMPW|CMP|BHI|BLS)`
	if a <= 0 || b <= 0 || c <= 0 || d <= 0 {
		return 1
	}
	return 0
}

func UintLtOne(a uint8, b uint16, c uint32, d uint64) int {
	// arm64: `(CBN?ZW)`, `(CBN?Z[^W])`, -`(CMPW|CMP|BHS|BLO)`
	if a < 1 || b < 1 || c < 1 || d < 1 {
		return 1
	}
	return 0
}

func UintGeqOne(a uint8, b uint16, c uint32, d uint64) int {
	// arm64: `(CBN?ZW)`, `(CBN?Z[^W])`, -`(CMPW|CMP|BLO|BHS)`
	if a >= 1 || b >= 1 || c >= 1 || d >= 1 {
		return 1
	}
	return 0
}

func CmpToZeroU_ex1(a uint8, b uint16, c uint32, d uint64) int {
	// wasm:"I64Eqz"-"I64LtU"
	if 0 < a {
		return 1
	}
	// wasm:"I64Eqz"-"I64LtU"
	if 0 < b {
		return 1
	}
	// wasm:"I64Eqz"-"I64LtU"
	if 0 < c {
		return 1
	}
	// wasm:"I64Eqz"-"I64LtU"
	if 0 < d {
		return 1
	}
	return 0
}

func CmpToZeroU_ex2(a uint8, b uint16, c uint32, d uint64) int {
	// wasm:"I64Eqz"-"I64LeU"
	if a <= 0 {
		return 1
	}
	// wasm:"I64Eqz"-"I64LeU"
	if b <= 0 {
		return 1
	}
	// wasm:"I64Eqz"-"I64LeU"
	if c <= 0 {
		return 1
	}
	// wasm:"I64Eqz"-"I64LeU"
	if d <= 0 {
		return 1
	}
	return 0
}

func CmpToOneU_ex1(a uint8, b uint16, c uint32, d uint64) int {
	// wasm:"I64Eqz"-"I64LtU"
	if a < 1 {
		return 1
	}
	// wasm:"I64Eqz"-"I64LtU"
	if b < 1 {
		return 1
	}
	// wasm:"I64Eqz"-"I64LtU"
	if c < 1 {
		return 1
	}
	// wasm:"I64Eqz"-"I64LtU"
	if d < 1 {
		return 1
	}
	return 0
}

func CmpToOneU_ex2(a uint8, b uint16, c uint32, d uint64) int {
	// wasm:"I64Eqz"-"I64LeU"
	if 1 <= a {
		return 1
	}
	// wasm:"I64Eqz"-"I64LeU"
	if 1 <= b {
		return 1
	}
	// wasm:"I64Eqz"-"I64LeU"
	if 1 <= c {
		return 1
	}
	// wasm:"I64Eqz"-"I64LeU"
	if 1 <= d {
		return 1
	}
	return 0
}

// Check that small memequals are replaced with eq instructions

func equalConstString1() bool {
	a := string("A")
	b := string("Z")
	// amd64:-".*memequal"
	// arm64:-".*memequal"
	// ppc64x:-".*memequal"
	return a == b
}

func equalVarString1(a string) bool {
	b := string("Z")
	// amd64:-".*memequal"
	// arm64:-".*memequal"
	// ppc64x:-".*memequal"
	return a[:1] == b
}

func equalConstString2() bool {
	a := string("AA")
	b := string("ZZ")
	// amd64:-".*memequal"
	// arm64:-".*memequal"
	// ppc64x:-".*memequal"
	return a == b
}

func equalVarString2(a string) bool {
	b := string("ZZ")
	// amd64:-".*memequal"
	// arm64:-".*memequal"
	// ppc64x:-".*memequal"
	return a[:2] == b
}

func equalConstString4() bool {
	a := string("AAAA")
	b := string("ZZZZ")
	// amd64:-".*memequal"
	// arm64:-".*memequal"
	// ppc64x:-".*memequal"
	return a == b
}

func equalVarString4(a string) bool {
	b := string("ZZZZ")
	// amd64:-".*memequal"
	// arm64:-".*memequal"
	// ppc64x:-".*memequal"
	return a[:4] == b
}

func equalConstString8() bool {
	a := string("AAAAAAAA")
	b := string("ZZZZZZZZ")
	// amd64:-".*memequal"
	// arm64:-".*memequal"
	// ppc64x:-".*memequal"
	return a == b
}

func equalVarString8(a string) bool {
	b := string("ZZZZZZZZ")
	// amd64:-".*memequal"
	// arm64:-".*memequal"
	// ppc64x:-".*memequal"
	return a[:8] == b
}

func cmpToCmn(a, b, c, d int) int {
	var c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11 int
	// arm64:`CMN`,-`CMP`
	if a < -8 {
		c1 = 1
	}
	// arm64:`CMN`,-`CMP`
	if a+1 == 0 {
		c2 = 1
	}
	// arm64:`CMN`,-`CMP`
	if a+3 != 0 {
		c3 = 1
	}
	// arm64:`CMN`,-`CMP`
	if a+b == 0 {
		c4 = 1
	}
	// arm64:`CMN`,-`CMP`
	if b+c != 0 {
		c5 = 1
	}
	// arm64:`CMN`,-`CMP`
	if a == -c {
		c6 = 1
	}
	// arm64:`CMN`,-`CMP`
	if b != -d {
		c7 = 1
	}
	// arm64:`CMN`,-`CMP`
	if a*b+c == 0 {
		c8 = 1
	}
	// arm64:`CMN`,-`CMP`
	if a*c+b != 0 {
		c9 = 1
	}
	// arm64:`CMP`,-`CMN`
	if b*c-a == 0 {
		c10 = 1
	}
	// arm64:`CMP`,-`CMN`
	if a*d-b != 0 {
		c11 = 1
	}
	return c1 + c2 + c3 + c4 + c5 + c6 + c7 + c8 + c9 + c10 + c11
}

func cmpToCmnLessThan(a, b, c, d int) int {
	var c1, c2, c3, c4 int
	// arm64:`CMN`,`CSET\tMI`,-`CMP`
	if a+1 < 0 {
		c1 = 1
	}
	// arm64:`CMN`,`CSET\tMI`,-`CMP`
	if a+b < 0 {
		c2 = 1
	}
	// arm64:`CMN`,`CSET\tMI`,-`CMP`
	if a*b+c < 0 {
		c3 = 1
	}
	// arm64:`CMP`,`CSET\tMI`,-`CMN`
	if a-b*c < 0 {
		c4 = 1
	}
	return c1 + c2 + c3 + c4
}

func cmpToCmnGreaterThanEqual(a, b, c, d int) int {
	var c1, c2, c3, c4 int
	// arm64:`CMN`,`CSET\tPL`,-`CMP`
	if a+1 >= 0 {
		c1 = 1
	}
	// arm64:`CMN`,`CSET\tPL`,-`CMP`
	if a+b >= 0 {
		c2 = 1
	}
	// arm64:`CMN`,`CSET\tPL`,-`CMP`
	if a*b+c >= 0 {
		c3 = 1
	}
	// arm64:`CMP`,`CSET\tPL`,-`CMN`
	if a-b*c >= 0 {
		c4 = 1
	}
	return c1 + c2 + c3 + c4
}

func cmp1(val string) bool {
	var z string
	// amd64:-".*memequal"
	return z == val
}

func cmp2(val string) bool {
	var z string
	// amd64:-".*memequal"
	return val == z
}

func cmp3(val string) bool {
	z := "food"
	// amd64:-".*memequal"
	return z == val
}

func cmp4(val string) bool {
	z := "food"
	// amd64:-".*memequal"
	return val == z
}

func cmp5[T comparable](val T) bool {
	var z T
	// amd64:-".*memequal"
	return z == val
}

func cmp6[T comparable](val T) bool {
	var z T
	// amd64:-".*memequal"
	return val == z
}

func cmp7() {
	cmp5[string]("") // force instantiation
	cmp6[string]("") // force instantiation
}

type Point struct {
	X, Y int
}

// invertLessThanNoov checks (LessThanNoov (InvertFlags x)) is lowered as
// CMP, CSET, CSEL instruction sequence. InvertFlags are only generated under
// certain conditions, see canonLessThan, so if the code below does not
// generate an InvertFlags OP, this check may fail.
func invertLessThanNoov(p1, p2, p3 Point) bool {
	// arm64:`CMP`,`CSET`,`CSEL`
	return (p1.X-p3.X)*(p2.Y-p3.Y)-(p2.X-p3.X)*(p1.Y-p3.Y) < 0
}

func cmpstring1(x, y string) int {
	// amd64:".*cmpstring"
	if x < y {
		return -1
	}
	// amd64:-".*cmpstring"
	if x > y {
		return +1
	}
	return 0
}
func cmpstring2(x, y string) int {
	// We want to fail if there are two calls to cmpstring.
	// They will both have the same line number, so a test
	// like in cmpstring1 will not work. Instead, we
	// look for spill/restore instructions, which only
	// need to exist if there are 2 calls.
	//amd64:-`MOVQ\t.*\(SP\)`
	return cmp.Compare(x, y)
}

"""



```
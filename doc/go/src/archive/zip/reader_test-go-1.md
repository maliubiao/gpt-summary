Response:
The user wants a summary of the Go code provided, which is part of the `reader_test.go` file in the `archive/zip` package. This file likely contains test functions for the zip reader functionality in Go.

Here's a plan to summarize the functionality:

1. **Identify the main purpose of the code:** The code is testing the zip reader implementation.
2. **Categorize the tests:**  Look for patterns in the test function names and the scenarios they cover. Common categories for reader tests include:
    * Error handling (invalid zip files, truncated data)
    * Feature verification (handling zip64, file system integration)
    * Security tests (vulnerabilities related to path traversal, large file counts, etc.)
    * Specific issue reproductions (tests named `TestIssue...`)
3. **Summarize each category:** Briefly describe what aspects of the zip reader are being tested within each category.
4. **Focus on the second part:** Since the prompt specifies "part 2", I will focus on summarizing the functionality covered in the provided code snippet.
这是 `go/src/archive/zip/reader_test.go` 文件的一部分，主要功能是**测试 `archive/zip` 包中 zip 文件读取器的各种功能和错误处理**。

具体来说，这段代码主要涵盖了以下测试功能：

1. **针对格式错误的 ZIP 文件的错误处理:**
   - `TestInvalidDirectoryOffset`:  测试当 ZIP 文件 central directory 的偏移量指向文件末尾之后时，`NewReader` 能否正确返回 `ErrFormat` 错误。
   - `TestIssue11146`: 测试读取被截断的数据描述符时，`NewReader` 是否返回 `io.ErrUnexpectedEOF` 错误。

2. **验证非 Zip64 格式的归档文件不会被当作 Zip64 处理:**
   - `TestIssue12449`:  确保即使 ZIP 文件的数据看起来像 Zip64 格式，但如果没有明确的 Zip64 标志，`NewReader` 也不会将其视为 Zip64 格式。

3. **测试 `zip.Reader` 作为 `fs.FS` 的实现:**
   - `TestFS`:  使用 `fstest.TestFS` 来验证 `zip.Reader` 是否正确实现了 `fs.FS` 接口，能够像标准文件系统一样被操作。测试了读取基本文件和子目录结构。
   - `TestFSWalk`: 测试使用 `fs.WalkDir` 遍历 zip 文件内容的功能，并检查是否能够正确处理目录结构。也测试了包含重复目录项的错误情况。
   - `TestFSModTime`: 测试通过 `fs.Stat` 获取 zip 文件中条目的修改时间的功能。

4. **针对安全漏洞的测试 (CVE):**
   - `TestCVE202127919`: 测试当 `GODEBUG` 设置为 `zipinsecurepath=0` 时，`NewReader` 是否能正确拒绝包含不安全路径（例如 `../test.txt`）的 ZIP 文件，并返回 `ErrInsecurePath` 错误。同时验证在这种情况下，仍然可以访问到该文件，但其名称保持了不安全路径。
   - `TestOpenReaderInsecurePath`:  与 `TestCVE202127919` 类似，但使用 `OpenReader` 函数（从文件路径打开 ZIP）。
   - `TestCVE202133196`: 测试 `NewReader` 是否能正确处理声明了极大量文件数的恶意 ZIP 文件，避免因尝试分配过大内存而导致 panic。同时也测试了创建和读取包含少量空文件的正常 ZIP 文件。
   - `TestCVE202139293`: 测试 `NewReader` 是否能正确处理 central directory size 过大的恶意 ZIP 文件，避免因整数溢出导致的安全问题。
   - `TestCVE202141772`: 测试当 `GODEBUG` 设置为 `zipinsecurepath=0` 时，`NewReader` 是否能正确处理包含文件名完全由 `/`、`\` 或 `../` 组成的恶意 ZIP 文件，避免 panic。并验证了在这种情况下，文件仍然可以被访问，但其名称保持了不安全路径。

5. **测试解压后大小不一致的情况:**
   - `TestUnderSize`: 测试当 zip 文件中声明的解压后大小小于实际内容大小时，`Open` 函数是否返回 `ErrFormat` 错误。
   - `TestIssue54801`: 测试当 zip 文件条目被错误地标记为目录（文件名以 `/` 结尾），且压缩方法非存储时，打开文件是否返回 `ErrFormat` 错误。

6. **测试对不安全路径的处理:**
   - `TestInsecurePaths`: 测试当 `GODEBUG` 设置为 `zipinsecurepath=0` 时，创建包含不安全路径（例如 `../foo`，`/foo` 等）的 ZIP 文件，然后使用 `NewReader` 打开时，是否会返回 `ErrInsecurePath` 错误，并且文件列表中会包含该不安全路径。
   - `TestDisableInsecurePathCheck`: 测试当 `GODEBUG` 设置为 `zipinsecurepath=1` 时，`NewReader` 是否能够正常打开包含不安全路径的 ZIP 文件。

7. **测试压缩的目录条目:**
   - `TestCompressedDirectory`: 测试读取包含压缩目录条目的 ZIP 文件，特别是当目录的未压缩大小为 0 时，`NewReader` 是否能正常工作。

8. **测试偏移量溢出的情况:**
   - `TestBaseOffsetPlusOverflow`: 测试当 ZIP 文件 central directory 的偏移量加上自身大小导致溢出时，`NewReader` 是否能避免 panic。

**归纳一下这段代码的功能：**

这段 `reader_test.go` 的代码片段主要负责对 `archive/zip` 包中的 zip 文件读取功能进行全面的测试，包括各种正常和异常情况，特别是针对潜在的安全漏洞进行了细致的测试，确保 zip 包的读取器能够安全可靠地处理各种类型的 zip 文件。 它还测试了 `zip.Reader` 作为 `fs.FS` 接口实现的功能。

### 提示词
```
这是路径为go/src/archive/zip/reader_test.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
请用中文回答。
这是第2部分，共2部分，请归纳一下它的功能
```

### 源代码
```go
0\x00\x00\x00\x00\x00" +
		"0000PK\x05\x06000000000000" +
		"0000\v\x00000\x00\x00\x00\x00\x00\x00\x000")
	r, err := NewReader(bytes.NewReader(data), int64(len(data)))
	if err == nil {
		t.Errorf("got nil error, want ErrFormat")
	}
	if r != nil {
		t.Errorf("got non-nil Reader, want nil")
	}
}

// Verify we return ErrUnexpectedEOF when reading truncated data descriptor.
func TestIssue11146(t *testing.T) {
	data := []byte("PK\x03\x040000000000000000" +
		"000000\x01\x00\x00\x000\x01\x00\x00\xff\xff0000" +
		"0000000000000000PK\x01\x02" +
		"0000\b0\b\x00000000000000" +
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x000000PK\x05\x06\x00\x00" +
		"\x00\x0000\x01\x00\x26\x00\x00\x008\x00\x00\x00\x00\x00")
	z, err := NewReader(bytes.NewReader(data), int64(len(data)))
	if err != nil {
		t.Fatal(err)
	}
	r, err := z.File[0].Open()
	if err != nil {
		t.Fatal(err)
	}
	_, err = io.ReadAll(r)
	if err != io.ErrUnexpectedEOF {
		t.Errorf("File[0] error = %v; want io.ErrUnexpectedEOF", err)
	}
	r.Close()
}

// Verify we do not treat non-zip64 archives as zip64
func TestIssue12449(t *testing.T) {
	data := []byte{
		0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x08, 0x00,
		0x00, 0x00, 0x6b, 0xb4, 0xba, 0x46, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x03, 0x00, 0x18, 0x00, 0xca, 0x64,
		0x55, 0x75, 0x78, 0x0b, 0x00, 0x50, 0x4b, 0x05,
		0x06, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01,
		0x00, 0x49, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00,
		0x00, 0x31, 0x31, 0x31, 0x32, 0x32, 0x32, 0x0a,
		0x50, 0x4b, 0x07, 0x08, 0x1d, 0x88, 0x77, 0xb0,
		0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
		0x50, 0x4b, 0x01, 0x02, 0x14, 0x03, 0x14, 0x00,
		0x08, 0x00, 0x00, 0x00, 0x6b, 0xb4, 0xba, 0x46,
		0x1d, 0x88, 0x77, 0xb0, 0x07, 0x00, 0x00, 0x00,
		0x07, 0x00, 0x00, 0x00, 0x03, 0x00, 0x18, 0x00,
		0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xa0, 0x81, 0x00, 0x00, 0x00, 0x00, 0xca, 0x64,
		0x55, 0x75, 0x78, 0x0b, 0x00, 0x50, 0x4b, 0x05,
		0x06, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01,
		0x00, 0x49, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00,
		0x00, 0x97, 0x2b, 0x49, 0x23, 0x05, 0xc5, 0x0b,
		0xa7, 0xd1, 0x52, 0xa2, 0x9c, 0x50, 0x4b, 0x06,
		0x07, 0xc8, 0x19, 0xc1, 0xaf, 0x94, 0x9c, 0x61,
		0x44, 0xbe, 0x94, 0x19, 0x42, 0x58, 0x12, 0xc6,
		0x5b, 0x50, 0x4b, 0x05, 0x06, 0x00, 0x00, 0x00,
		0x00, 0x01, 0x00, 0x01, 0x00, 0x69, 0x00, 0x00,
		0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00,
	}
	// Read in the archive.
	_, err := NewReader(bytes.NewReader(data), int64(len(data)))
	if err != nil {
		t.Errorf("Error reading the archive: %v", err)
	}
}

func TestFS(t *testing.T) {
	for _, test := range []struct {
		file string
		want []string
	}{
		{
			"testdata/unix.zip",
			[]string{"hello", "dir/bar", "readonly"},
		},
		{
			"testdata/subdir.zip",
			[]string{"a/b/c"},
		},
	} {
		test := test
		t.Run(test.file, func(t *testing.T) {
			t.Parallel()
			z, err := OpenReader(test.file)
			if err != nil {
				t.Fatal(err)
			}
			defer z.Close()
			if err := fstest.TestFS(z, test.want...); err != nil {
				t.Error(err)
			}
		})
	}
}

func TestFSWalk(t *testing.T) {
	for _, test := range []struct {
		file    string
		want    []string
		wantErr bool
	}{
		{
			file: "testdata/unix.zip",
			want: []string{".", "dir", "dir/bar", "dir/empty", "hello", "readonly"},
		},
		{
			file: "testdata/subdir.zip",
			want: []string{".", "a", "a/b", "a/b/c"},
		},
		{
			file:    "testdata/dupdir.zip",
			wantErr: true,
		},
	} {
		test := test
		t.Run(test.file, func(t *testing.T) {
			t.Parallel()
			z, err := OpenReader(test.file)
			if err != nil {
				t.Fatal(err)
			}
			var files []string
			sawErr := false
			err = fs.WalkDir(z, ".", func(path string, d fs.DirEntry, err error) error {
				if err != nil {
					if !test.wantErr {
						t.Errorf("%s: %v", path, err)
					}
					sawErr = true
					return nil
				}
				files = append(files, path)
				return nil
			})
			if err != nil {
				t.Errorf("fs.WalkDir error: %v", err)
			}
			if test.wantErr && !sawErr {
				t.Error("succeeded but want error")
			} else if !test.wantErr && sawErr {
				t.Error("unexpected error")
			}
			if test.want != nil && !slices.Equal(files, test.want) {
				t.Errorf("got %v want %v", files, test.want)
			}
		})
	}
}

func TestFSModTime(t *testing.T) {
	t.Parallel()
	z, err := OpenReader("testdata/subdir.zip")
	if err != nil {
		t.Fatal(err)
	}
	defer z.Close()

	for _, test := range []struct {
		name string
		want time.Time
	}{
		{
			"a",
			time.Date(2021, 4, 19, 12, 29, 56, 0, timeZone(-7*time.Hour)).UTC(),
		},
		{
			"a/b/c",
			time.Date(2021, 4, 19, 12, 29, 59, 0, timeZone(-7*time.Hour)).UTC(),
		},
	} {
		fi, err := fs.Stat(z, test.name)
		if err != nil {
			t.Errorf("%s: %v", test.name, err)
			continue
		}
		if got := fi.ModTime(); !got.Equal(test.want) {
			t.Errorf("%s: got modtime %v, want %v", test.name, got, test.want)
		}
	}
}

func TestCVE202127919(t *testing.T) {
	t.Setenv("GODEBUG", "zipinsecurepath=0")
	// Archive containing only the file "../test.txt"
	data := []byte{
		0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x08, 0x00,
		0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x2e, 0x2e,
		0x2f, 0x74, 0x65, 0x73, 0x74, 0x2e, 0x74, 0x78,
		0x74, 0x0a, 0xc9, 0xc8, 0x2c, 0x56, 0xc8, 0x2c,
		0x56, 0x48, 0x54, 0x28, 0x49, 0x2d, 0x2e, 0x51,
		0x28, 0x49, 0xad, 0x28, 0x51, 0x48, 0xcb, 0xcc,
		0x49, 0xd5, 0xe3, 0x02, 0x04, 0x00, 0x00, 0xff,
		0xff, 0x50, 0x4b, 0x07, 0x08, 0xc0, 0xd7, 0xed,
		0xc3, 0x20, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x00,
		0x00, 0x50, 0x4b, 0x01, 0x02, 0x14, 0x00, 0x14,
		0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xc0, 0xd7, 0xed, 0xc3, 0x20, 0x00, 0x00,
		0x00, 0x1a, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e,
		0x2e, 0x2f, 0x74, 0x65, 0x73, 0x74, 0x2e, 0x74,
		0x78, 0x74, 0x50, 0x4b, 0x05, 0x06, 0x00, 0x00,
		0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x39, 0x00,
		0x00, 0x00, 0x59, 0x00, 0x00, 0x00, 0x00, 0x00,
	}
	r, err := NewReader(bytes.NewReader(data), int64(len(data)))
	if err != ErrInsecurePath {
		t.Fatalf("Error reading the archive: %v", err)
	}
	_, err = r.Open("test.txt")
	if err != nil {
		t.Errorf("Error reading file: %v", err)
	}
	if len(r.File) != 1 {
		t.Fatalf("No entries in the file list")
	}
	if r.File[0].Name != "../test.txt" {
		t.Errorf("Unexpected entry name: %s", r.File[0].Name)
	}
	if _, err := r.File[0].Open(); err != nil {
		t.Errorf("Error opening file: %v", err)
	}
}

func TestOpenReaderInsecurePath(t *testing.T) {
	t.Setenv("GODEBUG", "zipinsecurepath=0")
	// Archive containing only the file "../test.txt"
	data := []byte{
		0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x08, 0x00,
		0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x2e, 0x2e,
		0x2f, 0x74, 0x65, 0x73, 0x74, 0x2e, 0x74, 0x78,
		0x74, 0x0a, 0xc9, 0xc8, 0x2c, 0x56, 0xc8, 0x2c,
		0x56, 0x48, 0x54, 0x28, 0x49, 0x2d, 0x2e, 0x51,
		0x28, 0x49, 0xad, 0x28, 0x51, 0x48, 0xcb, 0xcc,
		0x49, 0xd5, 0xe3, 0x02, 0x04, 0x00, 0x00, 0xff,
		0xff, 0x50, 0x4b, 0x07, 0x08, 0xc0, 0xd7, 0xed,
		0xc3, 0x20, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x00,
		0x00, 0x50, 0x4b, 0x01, 0x02, 0x14, 0x00, 0x14,
		0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xc0, 0xd7, 0xed, 0xc3, 0x20, 0x00, 0x00,
		0x00, 0x1a, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e,
		0x2e, 0x2f, 0x74, 0x65, 0x73, 0x74, 0x2e, 0x74,
		0x78, 0x74, 0x50, 0x4b, 0x05, 0x06, 0x00, 0x00,
		0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x39, 0x00,
		0x00, 0x00, 0x59, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	// Read in the archive with the OpenReader interface
	name := filepath.Join(t.TempDir(), "test.zip")
	err := os.WriteFile(name, data, 0644)
	if err != nil {
		t.Fatalf("Unable to write out the bugos zip entry")
	}
	r, err := OpenReader(name)
	if r != nil {
		defer r.Close()
	}

	if err != ErrInsecurePath {
		t.Fatalf("Error reading the archive, we expected ErrInsecurePath but got: %v", err)
	}
	_, err = r.Open("test.txt")
	if err != nil {
		t.Errorf("Error reading file: %v", err)
	}
	if len(r.File) != 1 {
		t.Fatalf("No entries in the file list")
	}
	if r.File[0].Name != "../test.txt" {
		t.Errorf("Unexpected entry name: %s", r.File[0].Name)
	}
	if _, err := r.File[0].Open(); err != nil {
		t.Errorf("Error opening file: %v", err)
	}
}

func TestCVE202133196(t *testing.T) {
	// Archive that indicates it has 1 << 128 -1 files,
	// this would previously cause a panic due to attempting
	// to allocate a slice with 1 << 128 -1 elements.
	data := []byte{
		0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x08, 0x08,
		0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x02,
		0x03, 0x62, 0x61, 0x65, 0x03, 0x04, 0x00, 0x00,
		0xff, 0xff, 0x50, 0x4b, 0x07, 0x08, 0xbe, 0x20,
		0x5c, 0x6c, 0x09, 0x00, 0x00, 0x00, 0x03, 0x00,
		0x00, 0x00, 0x50, 0x4b, 0x01, 0x02, 0x14, 0x00,
		0x14, 0x00, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xbe, 0x20, 0x5c, 0x6c, 0x09, 0x00,
		0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x01, 0x02, 0x03, 0x50, 0x4b, 0x06, 0x06, 0x2c,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2d,
		0x00, 0x2d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0x31, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x3a, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x50, 0x4b, 0x06, 0x07, 0x00,
		0x00, 0x00, 0x00, 0x6b, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x50,
		0x4b, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0x00, 0x00,
	}
	_, err := NewReader(bytes.NewReader(data), int64(len(data)))
	if err != ErrFormat {
		t.Fatalf("unexpected error, got: %v, want: %v", err, ErrFormat)
	}

	// Also check that an archive containing a handful of empty
	// files doesn't cause an issue
	b := bytes.NewBuffer(nil)
	w := NewWriter(b)
	for i := 0; i < 5; i++ {
		_, err := w.Create("")
		if err != nil {
			t.Fatalf("Writer.Create failed: %s", err)
		}
	}
	if err := w.Close(); err != nil {
		t.Fatalf("Writer.Close failed: %s", err)
	}
	r, err := NewReader(bytes.NewReader(b.Bytes()), int64(b.Len()))
	if err != nil {
		t.Fatalf("NewReader failed: %s", err)
	}
	if len(r.File) != 5 {
		t.Errorf("Archive has unexpected number of files, got %d, want 5", len(r.File))
	}
}

func TestCVE202139293(t *testing.T) {
	// directory size is so large, that the check in Reader.init
	// overflows when subtracting from the archive size, causing
	// the pre-allocation check to be bypassed.
	data := []byte{
		0x50, 0x4b, 0x06, 0x06, 0x05, 0x06, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x4b,
		0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
		0x00, 0x00, 0x50, 0x4b, 0x05, 0x06, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x4b,
		0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
		0x00, 0x00, 0x00, 0x50, 0x4b, 0x05, 0x06, 0x00, 0x31, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
		0xff, 0x50, 0xfe, 0x00, 0xff, 0x00, 0x3a, 0x00, 0x00, 0x00, 0xff,
	}
	_, err := NewReader(bytes.NewReader(data), int64(len(data)))
	if err != ErrFormat {
		t.Fatalf("unexpected error, got: %v, want: %v", err, ErrFormat)
	}
}

func TestCVE202141772(t *testing.T) {
	t.Setenv("GODEBUG", "zipinsecurepath=0")
	// Archive contains a file whose name is exclusively made up of '/', '\'
	// characters, or "../", "..\" paths, which would previously cause a panic.
	//
	//  Length   Method    Size  Cmpr    Date    Time   CRC-32   Name
	// --------  ------  ------- ---- ---------- ----- --------  ----
	//        0  Stored        0   0% 08-05-2021 18:32 00000000  /
	//        0  Stored        0   0% 09-14-2021 12:59 00000000  //
	//        0  Stored        0   0% 09-14-2021 12:59 00000000  \
	//       11  Stored       11   0% 09-14-2021 13:04 0d4a1185  /test.txt
	// --------          -------  ---                            -------
	//       11               11   0%                            4 files
	data := []byte{
		0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x08,
		0x00, 0x00, 0x06, 0x94, 0x05, 0x53, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x2f, 0x50,
		0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x78, 0x67, 0x2e, 0x53, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x02, 0x00, 0x00, 0x00, 0x2f, 0x2f, 0x50,
		0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x78, 0x67, 0x2e, 0x53, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x01, 0x00, 0x00, 0x00, 0x5c, 0x50, 0x4b,
		0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x91, 0x68, 0x2e, 0x53, 0x85, 0x11, 0x4a, 0x0d,
		0x0b, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00,
		0x09, 0x00, 0x00, 0x00, 0x2f, 0x74, 0x65, 0x73,
		0x74, 0x2e, 0x74, 0x78, 0x74, 0x68, 0x65, 0x6c,
		0x6c, 0x6f, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64,
		0x50, 0x4b, 0x01, 0x02, 0x14, 0x03, 0x0a, 0x00,
		0x00, 0x08, 0x00, 0x00, 0x06, 0x94, 0x05, 0x53,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
		0xed, 0x41, 0x00, 0x00, 0x00, 0x00, 0x2f, 0x50,
		0x4b, 0x01, 0x02, 0x3f, 0x00, 0x0a, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x78, 0x67, 0x2e, 0x53, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x02, 0x00, 0x24, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00,
		0x00, 0x1f, 0x00, 0x00, 0x00, 0x2f, 0x2f, 0x0a,
		0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
		0x00, 0x18, 0x00, 0x93, 0x98, 0x25, 0x57, 0x25,
		0xa9, 0xd7, 0x01, 0x93, 0x98, 0x25, 0x57, 0x25,
		0xa9, 0xd7, 0x01, 0x93, 0x98, 0x25, 0x57, 0x25,
		0xa9, 0xd7, 0x01, 0x50, 0x4b, 0x01, 0x02, 0x3f,
		0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78,
		0x67, 0x2e, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
		0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x20, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00,
		0x00, 0x5c, 0x0a, 0x00, 0x20, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x01, 0x00, 0x18, 0x00, 0x93, 0x98,
		0x25, 0x57, 0x25, 0xa9, 0xd7, 0x01, 0x93, 0x98,
		0x25, 0x57, 0x25, 0xa9, 0xd7, 0x01, 0x93, 0x98,
		0x25, 0x57, 0x25, 0xa9, 0xd7, 0x01, 0x50, 0x4b,
		0x01, 0x02, 0x3f, 0x00, 0x0a, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x91, 0x68, 0x2e, 0x53, 0x85, 0x11,
		0x4a, 0x0d, 0x0b, 0x00, 0x00, 0x00, 0x0b, 0x00,
		0x00, 0x00, 0x09, 0x00, 0x24, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
		0x5e, 0x00, 0x00, 0x00, 0x2f, 0x74, 0x65, 0x73,
		0x74, 0x2e, 0x74, 0x78, 0x74, 0x0a, 0x00, 0x20,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x18,
		0x00, 0xa9, 0x80, 0x51, 0x01, 0x26, 0xa9, 0xd7,
		0x01, 0x31, 0xd1, 0x57, 0x01, 0x26, 0xa9, 0xd7,
		0x01, 0xdf, 0x48, 0x85, 0xf9, 0x25, 0xa9, 0xd7,
		0x01, 0x50, 0x4b, 0x05, 0x06, 0x00, 0x00, 0x00,
		0x00, 0x04, 0x00, 0x04, 0x00, 0x31, 0x01, 0x00,
		0x00, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00,
	}
	r, err := NewReader(bytes.NewReader(data), int64(len(data)))
	if err != ErrInsecurePath {
		t.Fatalf("Error reading the archive: %v", err)
	}
	entryNames := []string{`/`, `//`, `\`, `/test.txt`}
	var names []string
	for _, f := range r.File {
		names = append(names, f.Name)
		if _, err := f.Open(); err != nil {
			t.Errorf("Error opening %q: %v", f.Name, err)
		}
		if _, err := r.Open(f.Name); err == nil {
			t.Errorf("Opening %q with fs.FS API succeeded", f.Name)
		}
	}
	if !slices.Equal(names, entryNames) {
		t.Errorf("Unexpected file entries: %q", names)
	}
	if _, err := r.Open(""); err == nil {
		t.Errorf("Opening %q with fs.FS API succeeded", "")
	}
	if _, err := r.Open("test.txt"); err != nil {
		t.Errorf("Error opening %q with fs.FS API: %v", "test.txt", err)
	}
	dirEntries, err := fs.ReadDir(r, ".")
	if err != nil {
		t.Fatalf("Error reading the root directory: %v", err)
	}
	if len(dirEntries) != 1 || dirEntries[0].Name() != "test.txt" {
		t.Errorf("Unexpected directory entries")
		for _, dirEntry := range dirEntries {
			_, err := r.Open(dirEntry.Name())
			t.Logf("%q (Open error: %v)", dirEntry.Name(), err)
		}
		t.FailNow()
	}
	info, err := dirEntries[0].Info()
	if err != nil {
		t.Fatalf("Error reading info entry: %v", err)
	}
	if name := info.Name(); name != "test.txt" {
		t.Errorf("Inconsistent name in info entry: %v", name)
	}
}

func TestUnderSize(t *testing.T) {
	z, err := OpenReader("testdata/readme.zip")
	if err != nil {
		t.Fatal(err)
	}
	defer z.Close()

	for _, f := range z.File {
		f.UncompressedSize64 = 1
	}

	for _, f := range z.File {
		t.Run(f.Name, func(t *testing.T) {
			rd, err := f.Open()
			if err != nil {
				t.Fatal(err)
			}
			defer rd.Close()

			_, err = io.Copy(io.Discard, rd)
			if err != ErrFormat {
				t.Fatalf("Error mismatch\n\tGot:  %v\n\tWant: %v", err, ErrFormat)
			}
		})
	}
}

func TestIssue54801(t *testing.T) {
	for _, input := range []string{"testdata/readme.zip", "testdata/dd.zip"} {
		z, err := OpenReader(input)
		if err != nil {
			t.Fatal(err)
		}
		defer z.Close()

		for _, f := range z.File {
			// Make file a directory
			f.Name += "/"

			t.Run(f.Name, func(t *testing.T) {
				t.Logf("CompressedSize64: %d, Flags: %#x", f.CompressedSize64, f.Flags)

				rd, err := f.Open()
				if err != nil {
					t.Fatal(err)
				}
				defer rd.Close()

				n, got := io.Copy(io.Discard, rd)
				if n != 0 || got != ErrFormat {
					t.Fatalf("Error mismatch, got: %d, %v, want: %v", n, got, ErrFormat)
				}
			})
		}
	}
}

func TestInsecurePaths(t *testing.T) {
	t.Setenv("GODEBUG", "zipinsecurepath=0")
	for _, path := range []string{
		"../foo",
		"/foo",
		"a/b/../../../c",
		`a\b`,
	} {
		var buf bytes.Buffer
		zw := NewWriter(&buf)
		_, err := zw.Create(path)
		if err != nil {
			t.Errorf("zw.Create(%q) = %v", path, err)
			continue
		}
		zw.Close()

		zr, err := NewReader(bytes.NewReader(buf.Bytes()), int64(buf.Len()))
		if err != ErrInsecurePath {
			t.Errorf("NewReader for archive with file %q: got err %v, want ErrInsecurePath", path, err)
			continue
		}
		var gotPaths []string
		for _, f := range zr.File {
			gotPaths = append(gotPaths, f.Name)
		}
		if !slices.Equal(gotPaths, []string{path}) {
			t.Errorf("NewReader for archive with file %q: got files %q", path, gotPaths)
			continue
		}
	}
}

func TestDisableInsecurePathCheck(t *testing.T) {
	t.Setenv("GODEBUG", "zipinsecurepath=1")
	var buf bytes.Buffer
	zw := NewWriter(&buf)
	const name = "/foo"
	_, err := zw.Create(name)
	if err != nil {
		t.Fatalf("zw.Create(%q) = %v", name, err)
	}
	zw.Close()
	zr, err := NewReader(bytes.NewReader(buf.Bytes()), int64(buf.Len()))
	if err != nil {
		t.Fatalf("NewReader with zipinsecurepath=1: got err %v, want nil", err)
	}
	var gotPaths []string
	for _, f := range zr.File {
		gotPaths = append(gotPaths, f.Name)
	}
	if want := []string{name}; !slices.Equal(gotPaths, want) {
		t.Errorf("NewReader with zipinsecurepath=1: got files %q, want %q", gotPaths, want)
	}
}

func TestCompressedDirectory(t *testing.T) {
	// Empty Java JAR, with a compressed directory with uncompressed size 0
	// which should not fail.
	//
	// Length   Method    Size  Cmpr    Date    Time   CRC-32   Name
	// --------  ------  ------- ---- ---------- ----- --------  ----
	//        0  Defl:N        2   0% 12-01-2022 16:50 00000000  META-INF/
	//       60  Defl:N       59   2% 12-01-2022 16:50 af937e93  META-INF/MANIFEST.MF
	// --------          -------  ---                            -------
	//       60               61  -2%                            2 files
	data := []byte{
		0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x08, 0x08,
		0x08, 0x00, 0x49, 0x86, 0x81, 0x55, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x09, 0x00, 0x04, 0x00, 0x4d, 0x45,
		0x54, 0x41, 0x2d, 0x49, 0x4e, 0x46, 0x2f, 0xfe,
		0xca, 0x00, 0x00, 0x03, 0x00, 0x50, 0x4b, 0x07,
		0x08, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x4b, 0x03,
		0x04, 0x14, 0x00, 0x08, 0x08, 0x08, 0x00, 0x49,
		0x86, 0x81, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14,
		0x00, 0x00, 0x00, 0x4d, 0x45, 0x54, 0x41, 0x2d,
		0x49, 0x4e, 0x46, 0x2f, 0x4d, 0x41, 0x4e, 0x49,
		0x46, 0x45, 0x53, 0x54, 0x2e, 0x4d, 0x46, 0xf3,
		0x4d, 0xcc, 0xcb, 0x4c, 0x4b, 0x2d, 0x2e, 0xd1,
		0x0d, 0x4b, 0x2d, 0x2a, 0xce, 0xcc, 0xcf, 0xb3,
		0x52, 0x30, 0xd4, 0x33, 0xe0, 0xe5, 0x72, 0x2e,
		0x4a, 0x4d, 0x2c, 0x49, 0x4d, 0xd1, 0x75, 0xaa,
		0x04, 0x0a, 0x00, 0x45, 0xf4, 0x0c, 0x8d, 0x15,
		0x34, 0xdc, 0xf3, 0xf3, 0xd3, 0x73, 0x52, 0x15,
		0x3c, 0xf3, 0x92, 0xf5, 0x34, 0x79, 0xb9, 0x78,
		0xb9, 0x00, 0x50, 0x4b, 0x07, 0x08, 0x93, 0x7e,
		0x93, 0xaf, 0x3b, 0x00, 0x00, 0x00, 0x3c, 0x00,
		0x00, 0x00, 0x50, 0x4b, 0x01, 0x02, 0x14, 0x00,
		0x14, 0x00, 0x08, 0x08, 0x08, 0x00, 0x49, 0x86,
		0x81, 0x55, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00,
		0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4d, 0x45, 0x54, 0x41, 0x2d, 0x49, 0x4e, 0x46,
		0x2f, 0xfe, 0xca, 0x00, 0x00, 0x50, 0x4b, 0x01,
		0x02, 0x14, 0x00, 0x14, 0x00, 0x08, 0x08, 0x08,
		0x00, 0x49, 0x86, 0x81, 0x55, 0x93, 0x7e, 0x93,
		0xaf, 0x3b, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00,
		0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3d,
		0x00, 0x00, 0x00, 0x4d, 0x45, 0x54, 0x41, 0x2d,
		0x49, 0x4e, 0x46, 0x2f, 0x4d, 0x41, 0x4e, 0x49,
		0x46, 0x45, 0x53, 0x54, 0x2e, 0x4d, 0x46, 0x50,
		0x4b, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x02,
		0x00, 0x02, 0x00, 0x7d, 0x00, 0x00, 0x00, 0xba,
		0x00, 0x00, 0x00, 0x00, 0x00,
	}
	r, err := NewReader(bytes.NewReader(data), int64(len(data)))
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	for _, f := range r.File {
		r, err := f.Open()
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if _, err := io.Copy(io.Discard, r); err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
	}
}

func TestBaseOffsetPlusOverflow(t *testing.T) {
	// directoryOffset > maxInt64 && size-directoryOffset < 0
	data := []byte{
		0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		0xff, 0xff, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		0x20, 0x20, 0x20, 0x50, 0x4b, 0x06, 0x06, 0x20,
		0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		0x20, 0xff, 0xff, 0x20, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x20, 0x08, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x80, 0x50, 0x4b, 0x06, 0x07, 0x00,
		0x00, 0x00, 0x00, 0x6b, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x50,
		0x4b, 0x05, 0x06, 0x20, 0x20, 0x20, 0x20, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0x20, 0x00,
	}
	defer func() {
		if r := recover(); r != nil {
			t.Fatalf("NewReader panicked: %s", r)
		}
	}()
	// Previously, this would trigger a panic as we attempt to read from
	// an io.SectionReader which would access a slice at a negative offset
	// as the section reader offset & size were < 0.
	NewReader(bytes.NewReader(data), int64(len(data))+1875)
}
```
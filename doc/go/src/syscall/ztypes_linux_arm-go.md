Response:
Let's break down the thought process for analyzing the provided Go code snippet.

**1. Initial Scan and High-Level Understanding:**

* **File Path:** `go/src/syscall/ztypes_linux_arm.go` immediately tells us this file is part of the `syscall` package within the Go standard library. The `ztypes` prefix and the `linux_arm` suffix are crucial. `ztypes` usually indicates auto-generated code (as the comment confirms: "Code generated by cmd/cgo"). The `linux_arm` tells us it's specific to the Linux operating system on the ARM architecture.
* **"syscall" Package:**  The `syscall` package provides low-level access to the operating system's system calls. This means the code likely deals with data structures and constants used when interacting directly with the Linux kernel.
* **`cgo -godefs`:** The comment at the top is a big clue. `cgo -godefs` is a command-line tool that generates Go type definitions based on C header files. This means the Go code is a representation of C structures and constants used by the Linux kernel.

**2. Identifying Key Sections and Their Purpose:**

* **Constants:** The `const` block defines integer constants like `sizeofPtr`, `PathMax`, and many others at the end of the snippet (starting with `IFA_UNSPEC`). These are likely symbolic names for numerical values used in system calls.
* **Type Definitions:** The `type` block defines Go structs and aliases for basic C types (like `_C_short`). These structs mirror C structures used in system calls. For example, `Timespec`, `Timeval`, `Stat_t`, `Dirent`, etc., are common Linux kernel data structures.

**3. Inferring Functionality - Connecting the Dots:**

* **Mapping to System Calls:**  Knowing this is part of `syscall`, the goal is to figure out which system calls these types and constants are related to. Many of the type names are strong hints.
    * `Timespec`, `Timeval`:  Likely related to time-related system calls like `clock_gettime`, `gettimeofday`, etc.
    * `Stat_t`:  Almost certainly for the `stat`, `fstat`, and `lstat` system calls, which retrieve file metadata.
    * `Dirent`:  Used with directory listing system calls like `readdir`.
    * `Flock_t`:  Related to file locking with the `flock` system call.
    * `RawSockaddrInet4`, `RawSockaddrInet6`, etc.: These are for network programming and related to socket addresses.
    * `Rlimit`: Used with the `getrlimit` and `setrlimit` system calls to manage resource limits.
    * `Termios`: For terminal I/O control using system calls like `tcgetattr` and `tcsetattr`.
* **Architecture Specificity:** The `linux_arm.go` suffix tells us these definitions are tailored to the ARM architecture. This explains the explicit sizes (`sizeofPtr = 0x4`) and potential padding in structs (`Pad_cgo_0`). Different architectures might have different sizes and memory layouts for these structures.

**4. Generating Go Code Examples:**

The next step is to provide concrete examples. For each major category of types, think of a relevant system call and demonstrate how these types would be used in Go code using the `syscall` package.

* **File Information (`Stat_t`):** The `os.Stat` function is a high-level Go wrapper around the `stat` system call. The example shows how to access fields of the returned `syscall.Stat_t`.
* **Directory Listing (`Dirent`):** The `os.ReadDir` (or the lower-level `syscall.Getdents`) is the way to read directory entries. The example shows how to iterate through directory entries and access the `Name` field.
* **File Locking (`Flock_t`):**  The `syscall.Flock` function directly uses the `Flock_t` struct (although indirectly through constants). The example demonstrates locking a file.
* **Network Programming (`RawSockaddrInet4`):** The `net` package in Go provides higher-level networking abstractions, but under the hood, `syscall` is used. The example demonstrates creating a socket address.
* **Resource Limits (`Rlimit`):** The `syscall.Getrlimit` function is used to retrieve resource limits. The example shows how to get the current limit for the number of open files.
* **Terminal I/O (`Termios`):** The `syscall.TCGetAttr` and `syscall.TCSetAttr` functions work with the `Termios` struct. The example demonstrates getting and setting terminal attributes.

**5. Addressing Potential Mistakes:**

* **Incorrect Size Assumptions:**  Directly using `unsafe.Sizeof` on these types *could* be problematic if the generated Go code doesn't perfectly match the underlying C structure's size and alignment (though `cgo` is generally good at this). It's safer to rely on the size constants provided in the file.
* **Endianness Issues (Less Relevant Here):** While not explicitly shown in the *provided* code, when dealing with binary data from system calls, byte order (endianness) can be a problem on different architectures. This file handles type definitions, so endianness is less of a direct concern here but is a general consideration when working with `syscall`.
* **Direct Manipulation of `syscall` Structures:** While possible, directly manipulating `syscall` structs can be error-prone. Go's standard library provides higher-level abstractions in packages like `os`, `net`, and `time` that are usually safer and easier to use.

**6. Review and Refinement:**

Finally, review the explanation for clarity, accuracy, and completeness. Ensure the Go code examples are correct and illustrate the intended usage. Make sure the explanation of potential mistakes is clear and provides actionable advice.

This methodical process of examining the code structure, inferring its purpose based on context (package, file name, code generation hints), and then providing concrete examples leads to a comprehensive understanding of the `ztypes_linux_arm.go` file.
这个文件 `go/src/syscall/ztypes_linux_arm.go` 是 Go 语言标准库中 `syscall` 包的一部分，专门为 **Linux 操作系统在 ARM 架构** 下使用的。它的主要功能是：

**1. 定义了与 Linux 内核交互时使用的 C 数据结构在 Go 语言中的对应类型。**

   由于 Go 语言需要调用底层的操作系统 API（系统调用），而这些 API 通常使用 C 语言的数据结构，因此需要一种机制来在 Go 语言中表示这些结构。 `ztypes_linux_arm.go` 文件就包含了这些类型定义。

**具体功能列举：**

* **定义了基本类型的大小常量:**  例如 `sizeofPtr`, `sizeofShort`, `sizeofInt` 等，指明了指针、short、int 等基本数据类型在 ARM Linux 上的大小（以字节为单位）。这对于内存布局和数据传递至关重要。
* **定义了与时间相关的结构体:** `Timespec`, `Timeval`, `Timex` 等，用于表示时间信息，例如高精度时间、时区调整等。
* **定义了与进程资源使用相关的结构体:** `Tms`, `Rusage`, `Rlimit` 等，用于获取和设置进程的 CPU 时间、内存使用、文件描述符限制等资源信息。
* **定义了文件系统相关的结构体:** `Stat_t`, `Statfs_t`, `Dirent`, `Utimbuf` 等，用于获取文件或文件系统的元数据（如大小、权限、修改时间、目录项等）。
* **定义了网络编程相关的结构体:** `RawSockaddrInet4`, `RawSockaddrInet6`, `Msghdr`, `Cmsghdr` 等，用于进行底层的网络通信操作，例如定义 IP 地址、端口号、发送和接收消息的结构。
* **定义了其他系统调用相关的结构体:** 例如 `Flock_t` (文件锁), `Iovec` (分散/聚集 I/O), `Ucred` (进程凭据), `Termios` (终端控制) 等。
* **定义了与 Netlink 协议相关的结构体:** `NlMsghdr`, `NlAttr`, `RtMsg` 等，用于与 Linux 内核的网络子系统进行更底层的交互，例如获取路由信息、接口信息等。
* **定义了与 BPF (Berkeley Packet Filter) 相关的结构体:** `SockFilter`, `SockFprog`，用于进行网络数据包的过滤。
* **定义了与 inotify 相关的结构体:** `InotifyEvent`，用于监控文件系统事件。
* **定义了与 `ptrace` 相关的结构体:** `PtraceRegs`，用于进程跟踪和调试。
* **定义了 `select` 系统调用相关的结构体:** `FdSet`。
* **定义了系统信息相关的结构体:** `Sysinfo_t`, `Utsname`, `Ustat_t`，用于获取系统的运行状态、内核版本等信息。
* **定义了 epoll 相关的结构体:** `EpollEvent`，用于高效地进行 I/O 多路复用。
* **定义了 `poll` 系统调用相关的结构体:** `pollFd`。
* **定义了终端控制相关的常量:** 例如 `VINTR`, `VQUIT`, `IGNBRK`, `B9600`, `TCGETS` 等，这些常量定义了终端控制的各种标志和特殊字符。

**2. 为 `syscall` 包中的函数提供类型定义支持。**

   `syscall` 包中的函数，例如 `Stat`, `Open`, `Read`, `Write`, `Socket`, `Bind` 等，在底层会调用 Linux 的系统调用。这些系统调用需要传递和接收各种参数和返回值，而 `ztypes_linux_arm.go` 中定义的结构体就是用来表示这些参数和返回值的 Go 语言类型。

**推理出的 Go 语言功能实现示例 (涉及 `Stat_t`)：**

假设我们要获取一个文件的信息，可以使用 `os.Stat` 函数，而这个函数底层会使用 `syscall.Stat`，它会返回一个 `syscall.Stat_t` 类型的结构体。

```go
package main

import (
	"fmt"
	"os"
	"syscall"
)

func main() {
	fileInfo, err := os.Stat("my_file.txt")
	if err != nil {
		fmt.Println("Error:", err)
		return
	}

	// fileInfo 实现了 os.FileInfo 接口，其中包含了 Stat_t 的信息
	sysStat := fileInfo.Sys().(*syscall.Stat_t)

	fmt.Println("Device ID:", sysStat.Dev)
	fmt.Println("Inode Number:", sysStat.Ino)
	fmt.Println("Mode (Permissions):", os.FileMode(sysStat.Mode))
	fmt.Println("Number of Hard Links:", sysStat.Nlink)
	fmt.Println("User ID:", sysStat.Uid)
	fmt.Println("Group ID:", sysStat.Gid)
	fmt.Println("Size:", sysStat.Size)
	fmt.Println("Last Access Time:", fileInfo.ModTime()) // fileInfo 提供了更方便的访问方式
}
```

**假设的输入与输出：**

假设 `my_file.txt` 存在，并且具有以下属性：

* Device ID: 64768
* Inode Number: 33554433
* Mode (Permissions): -rwxr-xr-- (0754 in octal)
* Number of Hard Links: 1
* User ID: 1000
* Group ID: 1000
* Size: 1024
* Last Modification Time: 2023-10-27 10:00:00

**输出可能如下：**

```
Device ID: 64768
Inode Number: 33554433
Mode (Permissions): -rwxr-xr--
Number of Hard Links: 1
User ID: 1000
Group ID: 1000
Size: 1024
Last Access Time: 2023-10-27 10:00:00 +0000 UTC
```

**代码推理：**

1. `os.Stat("my_file.txt")` 调用会尝试获取 `my_file.txt` 的文件信息。
2. 底层会调用 `syscall.Stat` 系统调用。
3. `syscall.Stat` 会返回一个 `syscall.Stat_t` 结构体，其中包含了从内核获取的文件元数据。
4. `fileInfo.Sys().(*syscall.Stat_t)` 将 `os.FileInfo` 接口返回的底层系统相关信息断言为 `syscall.Stat_t` 类型。
5. 我们可以访问 `syscall.Stat_t` 结构体的字段来获取具体的元数据信息。

**命令行参数的具体处理：**

这个文件本身不涉及命令行参数的处理。命令行参数的处理通常发生在 `main` 函数中，通过 `os.Args` 获取。 `ztypes_linux_arm.go` 中定义的结构体是用于系统调用，而系统调用本身是通过函数调用来触发的，与命令行参数处理是不同的概念。

**使用者易犯错的点：**

* **直接使用 `syscall` 包中的结构体和函数进行操作容易出错。**  `syscall` 包是底层的接口，使用起来较为复杂，需要对操作系统内核的细节有较深的了解。例如，手动构建 `RawSockaddrInet4` 结构体并传递给 `Bind` 系统调用，需要正确设置各个字段，包括字节序等问题。
* **容易忽略不同操作系统和架构的差异。**  `ztypes_linux_arm.go` 是特定于 Linux ARM 架构的。如果在其他操作系统或架构上运行相同的代码，可能会因为结构体的大小、字段顺序等差异而导致错误。
* **不理解 Go 语言的封装。** Go 语言标准库中的很多包（如 `os`, `net`, `time`）提供了更高层次、更易于使用的接口，它们在底层会使用 `syscall` 包。通常情况下，应该优先使用这些高级接口，而不是直接操作 `syscall` 包。

**易犯错的例子 (与网络编程相关):**

假设你尝试手动创建一个 `RawSockaddrInet4` 结构体来绑定一个 socket 地址，可能会犯以下错误：

```go
package main

import (
	"fmt"
	"net"
	"syscall"
	"unsafe"
)

func main() {
	addr := syscall.RawSockaddrInet4{
		Family: syscall.AF_INET, // 假设你想使用 IPv4
		Port:   uint16(8080),    // 错误：字节序可能不对
		Addr:   [4]byte{127, 0, 0, 1},
	}

	// ... (创建 socket 并尝试 bind) ...
}
```

**错误点：**

* **端口号的字节序：**  网络字节序是大端序，而 ARM 可能是小端序。直接赋值 `uint16(8080)` 可能导致端口号的字节序错误，导致 `bind` 系统调用失败。应该使用 `htons` 函数进行转换 (在 `syscall` 包中，但通常不建议直接使用)。

**正确的做法是使用 `net` 包:**

```go
package main

import (
	"fmt"
	"net"
	"os"
)

func main() {
	ln, err := net.Listen("tcp", ":8080")
	if err != nil {
		fmt.Println("Error:", err)
		os.Exit(1)
	}
	defer ln.Close()
	fmt.Println("Listening on :8080")
	// ...
}
```

`net.Listen` 函数会处理底层的字节序转换等细节，使得网络编程更加安全和方便。

总而言之，`go/src/syscall/ztypes_linux_arm.go` 是 Go 语言与 Linux ARM 架构底层系统交互的桥梁，定义了各种 C 数据结构在 Go 中的表示，为 `syscall` 包提供了必要的类型支持。虽然可以直接使用，但通常应该优先使用 Go 标准库中更高层次的封装。

Prompt: 
```
这是路径为go/src/syscall/ztypes_linux_arm.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
请用中文回答。

"""
// Code generated by cmd/cgo -godefs; DO NOT EDIT.
// cgo -godefs types_linux.go | go run mkpost.go

package syscall

const (
	sizeofPtr      = 0x4
	sizeofShort    = 0x2
	sizeofInt      = 0x4
	sizeofLong     = 0x4
	sizeofLongLong = 0x8
	PathMax        = 0x1000
)

type (
	_C_short     int16
	_C_int       int32
	_C_long      int32
	_C_long_long int64
)

type Timespec struct {
	Sec  int32
	Nsec int32
}

type Timeval struct {
	Sec  int32
	Usec int32
}

type Timex struct {
	Modes     uint32
	Offset    int32
	Freq      int32
	Maxerror  int32
	Esterror  int32
	Status    int32
	Constant  int32
	Precision int32
	Tolerance int32
	Time      Timeval
	Tick      int32
	Ppsfreq   int32
	Jitter    int32
	Shift     int32
	Stabil    int32
	Jitcnt    int32
	Calcnt    int32
	Errcnt    int32
	Stbcnt    int32
	Tai       int32
	Pad_cgo_0 [44]byte
}

type Time_t int32

type Tms struct {
	Utime  int32
	Stime  int32
	Cutime int32
	Cstime int32
}

type Utimbuf struct {
	Actime  int32
	Modtime int32
}

type Rusage struct {
	Utime    Timeval
	Stime    Timeval
	Maxrss   int32
	Ixrss    int32
	Idrss    int32
	Isrss    int32
	Minflt   int32
	Majflt   int32
	Nswap    int32
	Inblock  int32
	Oublock  int32
	Msgsnd   int32
	Msgrcv   int32
	Nsignals int32
	Nvcsw    int32
	Nivcsw   int32
}

type Rlimit struct {
	Cur uint64
	Max uint64
}

type _Gid_t uint32

type Stat_t struct {
	Dev       uint64
	X__pad1   uint16
	Pad_cgo_0 [2]byte
	X__st_ino uint32
	Mode      uint32
	Nlink     uint32
	Uid       uint32
	Gid       uint32
	Rdev      uint64
	X__pad2   uint16
	Pad_cgo_1 [6]byte
	Size      int64
	Blksize   int32
	Pad_cgo_2 [4]byte
	Blocks    int64
	Atim      Timespec
	Mtim      Timespec
	Ctim      Timespec
	Ino       uint64
}

type Statfs_t struct {
	Type      int32
	Bsize     int32
	Blocks    uint64
	Bfree     uint64
	Bavail    uint64
	Files     uint64
	Ffree     uint64
	Fsid      Fsid
	Namelen   int32
	Frsize    int32
	Flags     int32
	Spare     [4]int32
	Pad_cgo_0 [4]byte
}

type Dirent struct {
	Ino       uint64
	Off       int64
	Reclen    uint16
	Type      uint8
	Name      [256]uint8
	Pad_cgo_0 [5]byte
}

type Fsid struct {
	X__val [2]int32
}

type Flock_t struct {
	Type      int16
	Whence    int16
	Pad_cgo_0 [4]byte
	Start     int64
	Len       int64
	Pid       int32
	Pad_cgo_1 [4]byte
}

type RawSockaddrInet4 struct {
	Family uint16
	Port   uint16
	Addr   [4]byte /* in_addr */
	Zero   [8]uint8
}

type RawSockaddrInet6 struct {
	Family   uint16
	Port     uint16
	Flowinfo uint32
	Addr     [16]byte /* in6_addr */
	Scope_id uint32
}

type RawSockaddrUnix struct {
	Family uint16
	Path   [108]int8
}

type RawSockaddrLinklayer struct {
	Family   uint16
	Protocol uint16
	Ifindex  int32
	Hatype   uint16
	Pkttype  uint8
	Halen    uint8
	Addr     [8]uint8
}

type RawSockaddrNetlink struct {
	Family uint16
	Pad    uint16
	Pid    uint32
	Groups uint32
}

type RawSockaddr struct {
	Family uint16
	Data   [14]uint8
}

type RawSockaddrAny struct {
	Addr RawSockaddr
	Pad  [96]uint8
}

type _Socklen uint32

type Linger struct {
	Onoff  int32
	Linger int32
}

type Iovec struct {
	Base *byte
	Len  uint32
}

type IPMreq struct {
	Multiaddr [4]byte /* in_addr */
	Interface [4]byte /* in_addr */
}

type IPMreqn struct {
	Multiaddr [4]byte /* in_addr */
	Address   [4]byte /* in_addr */
	Ifindex   int32
}

type IPv6Mreq struct {
	Multiaddr [16]byte /* in6_addr */
	Interface uint32
}

type Msghdr struct {
	Name       *byte
	Namelen    uint32
	Iov        *Iovec
	Iovlen     uint32
	Control    *byte
	Controllen uint32
	Flags      int32
}

type Cmsghdr struct {
	Len   uint32
	Level int32
	Type  int32
}

type Inet4Pktinfo struct {
	Ifindex  int32
	Spec_dst [4]byte /* in_addr */
	Addr     [4]byte /* in_addr */
}

type Inet6Pktinfo struct {
	Addr    [16]byte /* in6_addr */
	Ifindex uint32
}

type IPv6MTUInfo struct {
	Addr RawSockaddrInet6
	Mtu  uint32
}

type ICMPv6Filter struct {
	Data [8]uint32
}

type Ucred struct {
	Pid int32
	Uid uint32
	Gid uint32
}

type TCPInfo struct {
	State          uint8
	Ca_state       uint8
	Retransmits    uint8
	Probes         uint8
	Backoff        uint8
	Options        uint8
	Pad_cgo_0      [2]byte
	Rto            uint32
	Ato            uint32
	Snd_mss        uint32
	Rcv_mss        uint32
	Unacked        uint32
	Sacked         uint32
	Lost           uint32
	Retrans        uint32
	Fackets        uint32
	Last_data_sent uint32
	Last_ack_sent  uint32
	Last_data_recv uint32
	Last_ack_recv  uint32
	Pmtu           uint32
	Rcv_ssthresh   uint32
	Rtt            uint32
	Rttvar         uint32
	Snd_ssthresh   uint32
	Snd_cwnd       uint32
	Advmss         uint32
	Reordering     uint32
	Rcv_rtt        uint32
	Rcv_space      uint32
	Total_retrans  uint32
}

const (
	SizeofSockaddrInet4     = 0x10
	SizeofSockaddrInet6     = 0x1c
	SizeofSockaddrAny       = 0x70
	SizeofSockaddrUnix      = 0x6e
	SizeofSockaddrLinklayer = 0x14
	SizeofSockaddrNetlink   = 0xc
	SizeofLinger            = 0x8
	SizeofIPMreq            = 0x8
	SizeofIPMreqn           = 0xc
	SizeofIPv6Mreq          = 0x14
	SizeofMsghdr            = 0x1c
	SizeofCmsghdr           = 0xc
	SizeofInet4Pktinfo      = 0xc
	SizeofInet6Pktinfo      = 0x14
	SizeofIPv6MTUInfo       = 0x20
	SizeofICMPv6Filter      = 0x20
	SizeofUcred             = 0xc
	SizeofTCPInfo           = 0x68
)

const (
	IFA_UNSPEC          = 0x0
	IFA_ADDRESS         = 0x1
	IFA_LOCAL           = 0x2
	IFA_LABEL           = 0x3
	IFA_BROADCAST       = 0x4
	IFA_ANYCAST         = 0x5
	IFA_CACHEINFO       = 0x6
	IFA_MULTICAST       = 0x7
	IFLA_UNSPEC         = 0x0
	IFLA_ADDRESS        = 0x1
	IFLA_BROADCAST      = 0x2
	IFLA_IFNAME         = 0x3
	IFLA_MTU            = 0x4
	IFLA_LINK           = 0x5
	IFLA_QDISC          = 0x6
	IFLA_STATS          = 0x7
	IFLA_COST           = 0x8
	IFLA_PRIORITY       = 0x9
	IFLA_MASTER         = 0xa
	IFLA_WIRELESS       = 0xb
	IFLA_PROTINFO       = 0xc
	IFLA_TXQLEN         = 0xd
	IFLA_MAP            = 0xe
	IFLA_WEIGHT         = 0xf
	IFLA_OPERSTATE      = 0x10
	IFLA_LINKMODE       = 0x11
	IFLA_LINKINFO       = 0x12
	IFLA_NET_NS_PID     = 0x13
	IFLA_IFALIAS        = 0x14
	IFLA_MAX            = 0x1d
	RT_SCOPE_UNIVERSE   = 0x0
	RT_SCOPE_SITE       = 0xc8
	RT_SCOPE_LINK       = 0xfd
	RT_SCOPE_HOST       = 0xfe
	RT_SCOPE_NOWHERE    = 0xff
	RT_TABLE_UNSPEC     = 0x0
	RT_TABLE_COMPAT     = 0xfc
	RT_TABLE_DEFAULT    = 0xfd
	RT_TABLE_MAIN       = 0xfe
	RT_TABLE_LOCAL      = 0xff
	RT_TABLE_MAX        = 0xffffffff
	RTA_UNSPEC          = 0x0
	RTA_DST             = 0x1
	RTA_SRC             = 0x2
	RTA_IIF             = 0x3
	RTA_OIF             = 0x4
	RTA_GATEWAY         = 0x5
	RTA_PRIORITY        = 0x6
	RTA_PREFSRC         = 0x7
	RTA_METRICS         = 0x8
	RTA_MULTIPATH       = 0x9
	RTA_FLOW            = 0xb
	RTA_CACHEINFO       = 0xc
	RTA_TABLE           = 0xf
	RTN_UNSPEC          = 0x0
	RTN_UNICAST         = 0x1
	RTN_LOCAL           = 0x2
	RTN_BROADCAST       = 0x3
	RTN_ANYCAST         = 0x4
	RTN_MULTICAST       = 0x5
	RTN_BLACKHOLE       = 0x6
	RTN_UNREACHABLE     = 0x7
	RTN_PROHIBIT        = 0x8
	RTN_THROW           = 0x9
	RTN_NAT             = 0xa
	RTN_XRESOLVE        = 0xb
	RTNLGRP_NONE        = 0x0
	RTNLGRP_LINK        = 0x1
	RTNLGRP_NOTIFY      = 0x2
	RTNLGRP_NEIGH       = 0x3
	RTNLGRP_TC          = 0x4
	RTNLGRP_IPV4_IFADDR = 0x5
	RTNLGRP_IPV4_MROUTE = 0x6
	RTNLGRP_IPV4_ROUTE  = 0x7
	RTNLGRP_IPV4_RULE   = 0x8
	RTNLGRP_IPV6_IFADDR = 0x9
	RTNLGRP_IPV6_MROUTE = 0xa
	RTNLGRP_IPV6_ROUTE  = 0xb
	RTNLGRP_IPV6_IFINFO = 0xc
	RTNLGRP_IPV6_PREFIX = 0x12
	RTNLGRP_IPV6_RULE   = 0x13
	RTNLGRP_ND_USEROPT  = 0x14
	SizeofNlMsghdr      = 0x10
	SizeofNlMsgerr      = 0x14
	SizeofRtGenmsg      = 0x1
	SizeofNlAttr        = 0x4
	SizeofRtAttr        = 0x4
	SizeofIfInfomsg     = 0x10
	SizeofIfAddrmsg     = 0x8
	SizeofRtMsg         = 0xc
	SizeofRtNexthop     = 0x8
)

type NlMsghdr struct {
	Len   uint32
	Type  uint16
	Flags uint16
	Seq   uint32
	Pid   uint32
}

type NlMsgerr struct {
	Error int32
	Msg   NlMsghdr
}

type RtGenmsg struct {
	Family uint8
}

type NlAttr struct {
	Len  uint16
	Type uint16
}

type RtAttr struct {
	Len  uint16
	Type uint16
}

type IfInfomsg struct {
	Family     uint8
	X__ifi_pad uint8
	Type       uint16
	Index      int32
	Flags      uint32
	Change     uint32
}

type IfAddrmsg struct {
	Family    uint8
	Prefixlen uint8
	Flags     uint8
	Scope     uint8
	Index     uint32
}

type RtMsg struct {
	Family   uint8
	Dst_len  uint8
	Src_len  uint8
	Tos      uint8
	Table    uint8
	Protocol uint8
	Scope    uint8
	Type     uint8
	Flags    uint32
}

type RtNexthop struct {
	Len     uint16
	Flags   uint8
	Hops    uint8
	Ifindex int32
}

const (
	SizeofSockFilter = 0x8
	SizeofSockFprog  = 0x8
)

type SockFilter struct {
	Code uint16
	Jt   uint8
	Jf   uint8
	K    uint32
}

type SockFprog struct {
	Len       uint16
	Pad_cgo_0 [2]byte
	Filter    *SockFilter
}

type InotifyEvent struct {
	Wd     int32
	Mask   uint32
	Cookie uint32
	Len    uint32
	Name   [0]uint8
}

const SizeofInotifyEvent = 0x10

type PtraceRegs struct {
	Uregs [18]uint32
}

type FdSet struct {
	Bits [32]int32
}

type Sysinfo_t struct {
	Uptime    int32
	Loads     [3]uint32
	Totalram  uint32
	Freeram   uint32
	Sharedram uint32
	Bufferram uint32
	Totalswap uint32
	Freeswap  uint32
	Procs     uint16
	Pad       uint16
	Totalhigh uint32
	Freehigh  uint32
	Unit      uint32
	X_f       [8]uint8
}

type Utsname struct {
	Sysname    [65]uint8
	Nodename   [65]uint8
	Release    [65]uint8
	Version    [65]uint8
	Machine    [65]uint8
	Domainname [65]uint8
}

type Ustat_t struct {
	Tfree  int32
	Tinode uint32
	Fname  [6]uint8
	Fpack  [6]uint8
}

type EpollEvent struct {
	Events uint32
	PadFd  int32
	Fd     int32
	Pad    int32
}

const (
	_AT_FDCWD            = -0x64
	_AT_REMOVEDIR        = 0x200
	_AT_SYMLINK_NOFOLLOW = 0x100
	_AT_EACCESS          = 0x200
	_AT_EMPTY_PATH       = 0x1000
)

type pollFd struct {
	Fd      int32
	Events  int16
	Revents int16
}

type Termios struct {
	Iflag     uint32
	Oflag     uint32
	Cflag     uint32
	Lflag     uint32
	Line      uint8
	Cc        [32]uint8
	Pad_cgo_0 [3]byte
	Ispeed    uint32
	Ospeed    uint32
}

const (
	VINTR    = 0x0
	VQUIT    = 0x1
	VERASE   = 0x2
	VKILL    = 0x3
	VEOF     = 0x4
	VTIME    = 0x5
	VMIN     = 0x6
	VSWTC    = 0x7
	VSTART   = 0x8
	VSTOP    = 0x9
	VSUSP    = 0xa
	VEOL     = 0xb
	VREPRINT = 0xc
	VDISCARD = 0xd
	VWERASE  = 0xe
	VLNEXT   = 0xf
	VEOL2    = 0x10
	IGNBRK   = 0x1
	BRKINT   = 0x2
	IGNPAR   = 0x4
	PARMRK   = 0x8
	INPCK    = 0x10
	ISTRIP   = 0x20
	INLCR    = 0x40
	IGNCR    = 0x80
	ICRNL    = 0x100
	IUCLC    = 0x200
	IXON     = 0x400
	IXANY    = 0x800
	IXOFF    = 0x1000
	IMAXBEL  = 0x2000
	IUTF8    = 0x4000
	OPOST    = 0x1
	OLCUC    = 0x2
	ONLCR    = 0x4
	OCRNL    = 0x8
	ONOCR    = 0x10
	ONLRET   = 0x20
	OFILL    = 0x40
	OFDEL    = 0x80
	B0       = 0x0
	B50      = 0x1
	B75      = 0x2
	B110     = 0x3
	B134     = 0x4
	B150     = 0x5
	B200     = 0x6
	B300     = 0x7
	B600     = 0x8
	B1200    = 0x9
	B1800    = 0xa
	B2400    = 0xb
	B4800    = 0xc
	B9600    = 0xd
	B19200   = 0xe
	B38400   = 0xf
	CSIZE    = 0x30
	CS5      = 0x0
	CS6      = 0x10
	CS7      = 0x20
	CS8      = 0x30
	CSTOPB   = 0x40
	CREAD    = 0x80
	PARENB   = 0x100
	PARODD   = 0x200
	HUPCL    = 0x400
	CLOCAL   = 0x800
	B57600   = 0x1001
	B115200  = 0x1002
	B230400  = 0x1003
	B460800  = 0x1004
	B500000  = 0x1005
	B576000  = 0x1006
	B921600  = 0x1007
	B1000000 = 0x1008
	B1152000 = 0x1009
	B1500000 = 0x100a
	B2000000 = 0x100b
	B2500000 = 0x100c
	B3000000 = 0x100d
	B3500000 = 0x100e
	B4000000 = 0x100f
	ISIG     = 0x1
	ICANON   = 0x2
	XCASE    = 0x4
	ECHO     = 0x8
	ECHOE    = 0x10
	ECHOK    = 0x20
	ECHONL   = 0x40
	NOFLSH   = 0x80
	TOSTOP   = 0x100
	ECHOCTL  = 0x200
	ECHOPRT  = 0x400
	ECHOKE   = 0x800
	FLUSHO   = 0x1000
	PENDIN   = 0x4000
	IEXTEN   = 0x8000
	TCGETS   = 0x5401
	TCSETS   = 0x5402
)

"""



```
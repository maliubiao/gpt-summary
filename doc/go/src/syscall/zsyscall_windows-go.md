Response:
Let's break down the thought process for answering the prompt about the `zsyscall_windows.go` file.

**1. Initial Understanding and Goal:**

The core request is to analyze a Go file (`zsyscall_windows.go`) and explain its purpose, how it's used in Go, provide examples, and highlight potential pitfalls. The prompt explicitly mentions it's "part 1 of 2," indicating the need for a summary at the end of this part.

**2. Examining the File Content:**

The first step is to carefully read through the provided code snippet. Key observations are:

* **`// Code generated by 'go generate'; DO NOT EDIT.`:** This immediately tells us this file is auto-generated and should not be manually modified. This is a crucial piece of information for understanding its function.
* **`package syscall`:**  This indicates the file belongs to the `syscall` package, which is responsible for interacting with the operating system.
* **`import (...)`:**  The imports reveal dependencies on `internal/syscall/windows/sysdll` and `unsafe`. This suggests it's dealing with low-level system calls and memory manipulation.
* **Constant and Variable Declarations:**  The `errnoERROR_IO_PENDING`, `errERROR_IO_PENDING`, and `errERROR_EINVAL` suggest handling specific error codes related to Windows system calls. The `errnoErr` function reinforces this.
* **`modadvapi32 = NewLazyDLL(sysdll.Add("advapi32.dll"))` and similar lines:**  This is a very important pattern. It shows the file is loading various Windows DLLs (like `advapi32.dll`, `kernel32.dll`, etc.). The `NewLazyDLL` function implies these DLLs are loaded on demand.
* **`procConvertSidToStringSidW = modadvapi32.NewProc("ConvertSidToStringSidW")` and similar lines:** This is the most crucial part. It declares variables representing specific functions (procedures) exported by the loaded DLLs. The "W" suffix often signifies the wide-character (Unicode) version of the function.
* **Function Definitions (e.g., `func ConvertSidToStringSid(sid *SID, stringSid **uint16) (err error) { ... }`)**: These functions are wrappers around the Windows API functions loaded earlier. They use `Syscall` or `SyscallN` to make the actual system calls. The parameters and return values closely mirror the corresponding Windows API functions.

**3. Inferring the File's Purpose:**

Based on the observations above, the primary function of this file becomes clear:

* **Providing Go access to Windows system calls:** It acts as a bridge between Go code and the native Windows API.
* **Loading necessary Windows DLLs:**  It handles the loading of required DLLs.
* **Defining Go functions that wrap Windows API functions:**  It provides type-safe and Go-idiomatic ways to call the underlying Windows functions.

**4. Connecting to Go Features:**

The most relevant Go feature is the `syscall` package itself. This file is an integral part of how Go enables cross-platform functionality while still allowing access to platform-specific features when needed.

**5. Developing Example Code (Mental Outline):**

To illustrate how this file is used, I would think of a common Windows API function exposed in the file. Something like creating a directory (`CreateDirectoryW`) seems simple enough.

* I'd need to import the `syscall` package.
* I'd need to convert the Go string path to a Windows-compatible UTF-16 pointer.
* I'd call the `syscall.CreateDirectory` function.
* I'd check the returned error.

This mental outline leads to the example code provided in the initial good answer.

**6. Identifying Potential Pitfalls:**

Common mistakes when working with system calls include:

* **Incorrectly handling error codes:**  Windows error codes need to be checked.
* **Memory management:**  Pointers and memory allocation need careful handling. Forgetting to free allocated memory is a common issue.
* **String encoding:**  Windows API often uses UTF-16, so conversions are necessary.
* **Understanding Windows concepts:**  Concepts like handles, security attributes, etc., are specific to Windows and need to be understood.

**7. Structuring the Answer:**

The answer needs to be organized and address all parts of the prompt:

* **Function Listing:**  A straightforward enumeration of the key actions the file performs.
* **Go Feature Implementation:** Explain the connection to the `syscall` package and how it facilitates platform-specific functionality.
* **Code Example:** Provide a concrete illustration with input and expected output (or error condition).
* **Potential Pitfalls:** Clearly explain common mistakes.
* **Summary:** A concise overview of the file's role.

**8. Refinement and Language:**

The language should be clear, concise, and accurate. Using terms like "low-level," "system calls," "Windows API," and "DLL" helps convey the technical nature of the file. Explaining the `NewLazyDLL` and `NewProc` functions is also important.

**Self-Correction/Refinement during the process:**

* **Initial thought:**  Focus heavily on individual function descriptions.
* **Correction:**  Realize the higher-level purpose is more important than detailing every single function. Group functions by the DLL they belong to in the description for better clarity.
* **Initial thought:**  Provide a very complex code example.
* **Correction:**  Simplify the example to focus on a single, understandable operation.
* **Initial thought:** Just list potential errors.
* **Correction:**  Provide concrete examples of *how* these errors might occur.

By following these steps, focusing on understanding the code's structure and purpose, and then connecting it to broader Go concepts, a comprehensive and accurate answer can be constructed.
## 对 `go/src/syscall/zsyscall_windows.go` 文件（第一部分）的功能归纳

这是 Go 语言 `syscall` 包中，针对 Windows 平台自动生成的系统调用接口代码。它的主要功能可以归纳为：

**核心功能：提供 Go 语言访问 Windows 系统调用的底层接口。**

更具体地说，第一部分主要做了以下几件事：

1. **声明并初始化常用的错误码常量和变量：**  定义了如 `errnoERROR_IO_PENDING` (997) 这样的 Windows 错误码常量，并创建了对应的 Go `error` 变量 `errERROR_IO_PENDING`，用于在系统调用失败时返回。`errnoErr` 函数用于将 `Errno` 类型的值转换为 `error` 类型，并对一些常见错误进行优化，避免运行时分配。

2. **懒加载 Windows DLL (动态链接库)：**  使用 `NewLazyDLL` 函数加载了一系列常用的 Windows 系统 DLL，例如 `advapi32.dll` (高级 API)、`kernel32.dll` (内核 API)、`ws2_32.dll` (Winsock 2 API) 等。`sysdll.Add()` 可能是用于构建 DLL 文件名的辅助函数。这种懒加载的方式意味着只有在实际调用 DLL 中的函数时，才会加载对应的 DLL。

3. **获取 Windows DLL 中导出函数的地址：**  对于每个加载的 DLL，使用 `NewProc` 函数获取了该 DLL 中特定导出函数的地址。例如，`procCreateProcessW` 获取了 `kernel32.dll` 中的 `CreateProcessW` 函数的地址。这些变量（例如 `procCreateProcessW`）将用于后续的 Go 函数中，通过 `Syscall` 或 `SyscallN` 进行实际的系统调用。

**总结来说，这部分代码的核心任务是为 Go 程序在 Windows 平台上调用底层的 Windows API 函数做好准备工作，包括定义错误处理机制、加载必要的 DLL 以及获取需要调用的函数地址。**  它并不直接执行任何实际的系统调用，而是构建了调用这些系统调用的基础设施。

**它是什么 Go 语言功能的实现？**

这部分代码是 Go 语言 `syscall` 包实现平台特定系统调用的机制的一部分。 Go 的 `syscall` 包允许 Go 程序直接与操作系统内核进行交互。 由于不同操作系统的系统调用接口不同，Go 需要针对每个平台提供特定的实现。  `zsyscall_windows.go` 就是针对 Windows 平台的实现。

**由于这部分代码是纯粹的声明和初始化，不涉及具体的业务逻辑和控制流程，因此很难用一个独立的 Go 代码例子来直接展示其功能。**  这部分代码是其他 `syscall` 包中的 Go 函数的基础。

**我们可以假设在 `syscall` 包的其他文件中，会有类似以下的 Go 代码使用这里声明的变量：**

```go
package syscall

// 假设在另一个文件中定义了 CreateProcess 函数
func CreateProcess(appName string, commandLine string, ...) (pid int, err error) {
	appNamePtr, err := UTF16PtrFromString(appName)
	if err != nil {
		return 0, err
	}
	commandLinePtr, err := UTF16PtrFromString(commandLine)
	if err != nil {
		return 0, err
	}

	var si StartupInfo
	si.Cb = uint32(unsafe.Sizeof(si))
	var pi ProcessInformation

	r1, _, e1 := Syscall10(procCreateProcessW.Addr(), // 使用这里声明的 procCreateProcessW
		uintptr(unsafe.Pointer(appNamePtr)),
		uintptr(unsafe.Pointer(commandLinePtr)),
		0, // 省略其他参数
		0,
		0,
		CREATE_NEW_CONSOLE,
		0,
		0,
		uintptr(unsafe.Pointer(&si)),
		uintptr(unsafe.Pointer(&pi)))

	if r1 == 0 {
		err = errnoErr(e1)
		return 0, err
	}
	CloseHandle(pi.HThread)
	CloseHandle(pi.HProcess)
	return int(pi.DwProcessId), nil
}
```

**假设的输入与输出：**

在这个假设的 `CreateProcess` 函数中：

* **输入：** `appName` 为要执行的程序路径字符串，例如 `"C:\\Windows\\System32\\notepad.exe"`，`commandLine` 可以为空字符串或其他参数。
* **输出：** 如果成功，`pid` 为新创建进程的 ID，`err` 为 `nil`。如果失败，`pid` 为 0，`err` 包含 Windows 系统返回的错误信息。

**使用者易犯错的点（针对使用 `syscall` 包，而不是直接使用 `zsyscall_windows.go`）：**

1. **错误地处理 Unicode 字符串：**  许多 Windows API 函数接受宽字符 (UTF-16) 字符串。 用户容易忘记将 Go 的 UTF-8 字符串转换为 UTF-16，导致调用失败或出现乱码。

   **例子：**  在调用 `CreateProcessW` 时，如果没有使用 `syscall.UTF16PtrFromString` 将 Go 字符串转换为指向 UTF-16 编码的指针，传递的参数将是错误的。

2. **不正确的指针使用和内存管理：**  系统调用经常涉及指针。用户需要小心地管理内存，确保传递有效的指针，并适时释放不再使用的内存。

   **例子：**  在调用需要传递缓冲区的系统调用时，如果没有正确分配足够大小的内存空间，可能会导致程序崩溃或数据损坏。

3. **忽略错误返回值：**  Windows 系统调用通常通过返回值和 `GetLastError` 函数报告错误。用户容易忽略检查返回值，或者没有正确调用 `GetLastError` 获取详细的错误信息。

   **例子：**  调用 `CreateDirectoryW` 创建目录失败时，如果没有检查返回值并调用 `GetLastError`，用户可能无法得知具体的失败原因（例如权限不足）。

**总结：**

`go/src/syscall/zsyscall_windows.go` 的第一部分是 Go 语言在 Windows 平台上实现系统调用的基础，它负责加载必要的 DLL 并获取函数地址，为后续的系统调用提供底层支持。使用者在使用 `syscall` 包进行 Windows 系统编程时，需要特别注意字符串编码、指针使用和错误处理等问题。

Prompt: 
```
这是路径为go/src/syscall/zsyscall_windows.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
请用中文回答。
这是第1部分，共2部分，请归纳一下它的功能

"""
// Code generated by 'go generate'; DO NOT EDIT.

package syscall

import (
	"internal/syscall/windows/sysdll"
	"unsafe"
)

var _ unsafe.Pointer

// Do the interface allocations only once for common
// Errno values.
const (
	errnoERROR_IO_PENDING = 997
)

var (
	errERROR_IO_PENDING error = Errno(errnoERROR_IO_PENDING)
	errERROR_EINVAL     error = EINVAL
)

// errnoErr returns common boxed Errno values, to prevent
// allocations at runtime.
func errnoErr(e Errno) error {
	switch e {
	case 0:
		return errERROR_EINVAL
	case errnoERROR_IO_PENDING:
		return errERROR_IO_PENDING
	}
	// TODO: add more here, after collecting data on the common
	// error values see on Windows. (perhaps when running
	// all.bat?)
	return e
}

var (
	modadvapi32 = NewLazyDLL(sysdll.Add("advapi32.dll"))
	modcrypt32  = NewLazyDLL(sysdll.Add("crypt32.dll"))
	moddnsapi   = NewLazyDLL(sysdll.Add("dnsapi.dll"))
	modiphlpapi = NewLazyDLL(sysdll.Add("iphlpapi.dll"))
	modkernel32 = NewLazyDLL(sysdll.Add("kernel32.dll"))
	modmswsock  = NewLazyDLL(sysdll.Add("mswsock.dll"))
	modnetapi32 = NewLazyDLL(sysdll.Add("netapi32.dll"))
	modsecur32  = NewLazyDLL(sysdll.Add("secur32.dll"))
	modshell32  = NewLazyDLL(sysdll.Add("shell32.dll"))
	moduserenv  = NewLazyDLL(sysdll.Add("userenv.dll"))
	modws2_32   = NewLazyDLL(sysdll.Add("ws2_32.dll"))

	procConvertSidToStringSidW             = modadvapi32.NewProc("ConvertSidToStringSidW")
	procConvertStringSidToSidW             = modadvapi32.NewProc("ConvertStringSidToSidW")
	procCopySid                            = modadvapi32.NewProc("CopySid")
	procCreateProcessAsUserW               = modadvapi32.NewProc("CreateProcessAsUserW")
	procCryptAcquireContextW               = modadvapi32.NewProc("CryptAcquireContextW")
	procCryptGenRandom                     = modadvapi32.NewProc("CryptGenRandom")
	procCryptReleaseContext                = modadvapi32.NewProc("CryptReleaseContext")
	procGetLengthSid                       = modadvapi32.NewProc("GetLengthSid")
	procGetTokenInformation                = modadvapi32.NewProc("GetTokenInformation")
	procLookupAccountNameW                 = modadvapi32.NewProc("LookupAccountNameW")
	procLookupAccountSidW                  = modadvapi32.NewProc("LookupAccountSidW")
	procOpenProcessToken                   = modadvapi32.NewProc("OpenProcessToken")
	procRegCloseKey                        = modadvapi32.NewProc("RegCloseKey")
	procRegEnumKeyExW                      = modadvapi32.NewProc("RegEnumKeyExW")
	procRegOpenKeyExW                      = modadvapi32.NewProc("RegOpenKeyExW")
	procRegQueryInfoKeyW                   = modadvapi32.NewProc("RegQueryInfoKeyW")
	procRegQueryValueExW                   = modadvapi32.NewProc("RegQueryValueExW")
	procCertAddCertificateContextToStore   = modcrypt32.NewProc("CertAddCertificateContextToStore")
	procCertCloseStore                     = modcrypt32.NewProc("CertCloseStore")
	procCertCreateCertificateContext       = modcrypt32.NewProc("CertCreateCertificateContext")
	procCertEnumCertificatesInStore        = modcrypt32.NewProc("CertEnumCertificatesInStore")
	procCertFreeCertificateChain           = modcrypt32.NewProc("CertFreeCertificateChain")
	procCertFreeCertificateContext         = modcrypt32.NewProc("CertFreeCertificateContext")
	procCertGetCertificateChain            = modcrypt32.NewProc("CertGetCertificateChain")
	procCertOpenStore                      = modcrypt32.NewProc("CertOpenStore")
	procCertOpenSystemStoreW               = modcrypt32.NewProc("CertOpenSystemStoreW")
	procCertVerifyCertificateChainPolicy   = modcrypt32.NewProc("CertVerifyCertificateChainPolicy")
	procDnsNameCompare_W                   = moddnsapi.NewProc("DnsNameCompare_W")
	procDnsQuery_W                         = moddnsapi.NewProc("DnsQuery_W")
	procDnsRecordListFree                  = moddnsapi.NewProc("DnsRecordListFree")
	procGetAdaptersInfo                    = modiphlpapi.NewProc("GetAdaptersInfo")
	procGetIfEntry                         = modiphlpapi.NewProc("GetIfEntry")
	procCancelIo                           = modkernel32.NewProc("CancelIo")
	procCancelIoEx                         = modkernel32.NewProc("CancelIoEx")
	procCloseHandle                        = modkernel32.NewProc("CloseHandle")
	procCreateDirectoryW                   = modkernel32.NewProc("CreateDirectoryW")
	procCreateFileMappingW                 = modkernel32.NewProc("CreateFileMappingW")
	procCreateFileW                        = modkernel32.NewProc("CreateFileW")
	procCreateHardLinkW                    = modkernel32.NewProc("CreateHardLinkW")
	procCreateIoCompletionPort             = modkernel32.NewProc("CreateIoCompletionPort")
	procCreatePipe                         = modkernel32.NewProc("CreatePipe")
	procCreateProcessW                     = modkernel32.NewProc("CreateProcessW")
	procCreateSymbolicLinkW                = modkernel32.NewProc("CreateSymbolicLinkW")
	procCreateToolhelp32Snapshot           = modkernel32.NewProc("CreateToolhelp32Snapshot")
	procDeleteFileW                        = modkernel32.NewProc("DeleteFileW")
	procDeleteProcThreadAttributeList      = modkernel32.NewProc("DeleteProcThreadAttributeList")
	procDeviceIoControl                    = modkernel32.NewProc("DeviceIoControl")
	procDuplicateHandle                    = modkernel32.NewProc("DuplicateHandle")
	procExitProcess                        = modkernel32.NewProc("ExitProcess")
	procFindClose                          = modkernel32.NewProc("FindClose")
	procFindFirstFileW                     = modkernel32.NewProc("FindFirstFileW")
	procFindNextFileW                      = modkernel32.NewProc("FindNextFileW")
	procFlushFileBuffers                   = modkernel32.NewProc("FlushFileBuffers")
	procFlushViewOfFile                    = modkernel32.NewProc("FlushViewOfFile")
	procFormatMessageW                     = modkernel32.NewProc("FormatMessageW")
	procFreeEnvironmentStringsW            = modkernel32.NewProc("FreeEnvironmentStringsW")
	procFreeLibrary                        = modkernel32.NewProc("FreeLibrary")
	procGetCommandLineW                    = modkernel32.NewProc("GetCommandLineW")
	procGetComputerNameW                   = modkernel32.NewProc("GetComputerNameW")
	procGetConsoleMode                     = modkernel32.NewProc("GetConsoleMode")
	procGetCurrentDirectoryW               = modkernel32.NewProc("GetCurrentDirectoryW")
	procGetCurrentProcess                  = modkernel32.NewProc("GetCurrentProcess")
	procGetCurrentProcessId                = modkernel32.NewProc("GetCurrentProcessId")
	procGetEnvironmentStringsW             = modkernel32.NewProc("GetEnvironmentStringsW")
	procGetEnvironmentVariableW            = modkernel32.NewProc("GetEnvironmentVariableW")
	procGetExitCodeProcess                 = modkernel32.NewProc("GetExitCodeProcess")
	procGetFileAttributesExW               = modkernel32.NewProc("GetFileAttributesExW")
	procGetFileAttributesW                 = modkernel32.NewProc("GetFileAttributesW")
	procGetFileInformationByHandle         = modkernel32.NewProc("GetFileInformationByHandle")
	procGetFileType                        = modkernel32.NewProc("GetFileType")
	procGetFinalPathNameByHandleW          = modkernel32.NewProc("GetFinalPathNameByHandleW")
	procGetFullPathNameW                   = modkernel32.NewProc("GetFullPathNameW")
	procGetLastError                       = modkernel32.NewProc("GetLastError")
	procGetLongPathNameW                   = modkernel32.NewProc("GetLongPathNameW")
	procGetProcAddress                     = modkernel32.NewProc("GetProcAddress")
	procGetProcessTimes                    = modkernel32.NewProc("GetProcessTimes")
	procGetQueuedCompletionStatus          = modkernel32.NewProc("GetQueuedCompletionStatus")
	procGetShortPathNameW                  = modkernel32.NewProc("GetShortPathNameW")
	procGetStartupInfoW                    = modkernel32.NewProc("GetStartupInfoW")
	procGetStdHandle                       = modkernel32.NewProc("GetStdHandle")
	procGetSystemTimeAsFileTime            = modkernel32.NewProc("GetSystemTimeAsFileTime")
	procGetTempPathW                       = modkernel32.NewProc("GetTempPathW")
	procGetTimeZoneInformation             = modkernel32.NewProc("GetTimeZoneInformation")
	procGetVersion                         = modkernel32.NewProc("GetVersion")
	procInitializeProcThreadAttributeList  = modkernel32.NewProc("InitializeProcThreadAttributeList")
	procLoadLibraryW                       = modkernel32.NewProc("LoadLibraryW")
	procLocalFree                          = modkernel32.NewProc("LocalFree")
	procMapViewOfFile                      = modkernel32.NewProc("MapViewOfFile")
	procMoveFileW                          = modkernel32.NewProc("MoveFileW")
	procOpenProcess                        = modkernel32.NewProc("OpenProcess")
	procPostQueuedCompletionStatus         = modkernel32.NewProc("PostQueuedCompletionStatus")
	procProcess32FirstW                    = modkernel32.NewProc("Process32FirstW")
	procProcess32NextW                     = modkernel32.NewProc("Process32NextW")
	procReadConsoleW                       = modkernel32.NewProc("ReadConsoleW")
	procReadDirectoryChangesW              = modkernel32.NewProc("ReadDirectoryChangesW")
	procReadFile                           = modkernel32.NewProc("ReadFile")
	procRemoveDirectoryW                   = modkernel32.NewProc("RemoveDirectoryW")
	procSetCurrentDirectoryW               = modkernel32.NewProc("SetCurrentDirectoryW")
	procSetEndOfFile                       = modkernel32.NewProc("SetEndOfFile")
	procSetEnvironmentVariableW            = modkernel32.NewProc("SetEnvironmentVariableW")
	procSetFileAttributesW                 = modkernel32.NewProc("SetFileAttributesW")
	procSetFileCompletionNotificationModes = modkernel32.NewProc("SetFileCompletionNotificationModes")
	procSetFileInformationByHandle         = modkernel32.NewProc("SetFileInformationByHandle")
	procSetFilePointer                     = modkernel32.NewProc("SetFilePointer")
	procSetFileTime                        = modkernel32.NewProc("SetFileTime")
	procSetHandleInformation               = modkernel32.NewProc("SetHandleInformation")
	procTerminateProcess                   = modkernel32.NewProc("TerminateProcess")
	procUnmapViewOfFile                    = modkernel32.NewProc("UnmapViewOfFile")
	procUpdateProcThreadAttribute          = modkernel32.NewProc("UpdateProcThreadAttribute")
	procVirtualLock                        = modkernel32.NewProc("VirtualLock")
	procVirtualUnlock                      = modkernel32.NewProc("VirtualUnlock")
	procWaitForSingleObject                = modkernel32.NewProc("WaitForSingleObject")
	procWriteConsoleW                      = modkernel32.NewProc("WriteConsoleW")
	procWriteFile                          = modkernel32.NewProc("WriteFile")
	procAcceptEx                           = modmswsock.NewProc("AcceptEx")
	procGetAcceptExSockaddrs               = modmswsock.NewProc("GetAcceptExSockaddrs")
	procTransmitFile                       = modmswsock.NewProc("TransmitFile")
	procNetApiBufferFree                   = modnetapi32.NewProc("NetApiBufferFree")
	procNetGetJoinInformation              = modnetapi32.NewProc("NetGetJoinInformation")
	procNetUserGetInfo                     = modnetapi32.NewProc("NetUserGetInfo")
	procGetUserNameExW                     = modsecur32.NewProc("GetUserNameExW")
	procTranslateNameW                     = modsecur32.NewProc("TranslateNameW")
	procCommandLineToArgvW                 = modshell32.NewProc("CommandLineToArgvW")
	procGetUserProfileDirectoryW           = moduserenv.NewProc("GetUserProfileDirectoryW")
	procFreeAddrInfoW                      = modws2_32.NewProc("FreeAddrInfoW")
	procGetAddrInfoW                       = modws2_32.NewProc("GetAddrInfoW")
	procWSACleanup                         = modws2_32.NewProc("WSACleanup")
	procWSAEnumProtocolsW                  = modws2_32.NewProc("WSAEnumProtocolsW")
	procWSAIoctl                           = modws2_32.NewProc("WSAIoctl")
	procWSARecv                            = modws2_32.NewProc("WSARecv")
	procWSARecvFrom                        = modws2_32.NewProc("WSARecvFrom")
	procWSASend                            = modws2_32.NewProc("WSASend")
	procWSASendTo                          = modws2_32.NewProc("WSASendTo")
	procWSAStartup                         = modws2_32.NewProc("WSAStartup")
	procbind                               = modws2_32.NewProc("bind")
	procclosesocket                        = modws2_32.NewProc("closesocket")
	procconnect                            = modws2_32.NewProc("connect")
	procgethostbyname                      = modws2_32.NewProc("gethostbyname")
	procgetpeername                        = modws2_32.NewProc("getpeername")
	procgetprotobyname                     = modws2_32.NewProc("getprotobyname")
	procgetservbyname                      = modws2_32.NewProc("getservbyname")
	procgetsockname                        = modws2_32.NewProc("getsockname")
	procgetsockopt                         = modws2_32.NewProc("getsockopt")
	proclisten                             = modws2_32.NewProc("listen")
	procntohs                              = modws2_32.NewProc("ntohs")
	procsetsockopt                         = modws2_32.NewProc("setsockopt")
	procshutdown                           = modws2_32.NewProc("shutdown")
	procsocket                             = modws2_32.NewProc("socket")
)

func ConvertSidToStringSid(sid *SID, stringSid **uint16) (err error) {
	r1, _, e1 := Syscall(procConvertSidToStringSidW.Addr(), 2, uintptr(unsafe.Pointer(sid)), uintptr(unsafe.Pointer(stringSid)), 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func ConvertStringSidToSid(stringSid *uint16, sid **SID) (err error) {
	r1, _, e1 := Syscall(procConvertStringSidToSidW.Addr(), 2, uintptr(unsafe.Pointer(stringSid)), uintptr(unsafe.Pointer(sid)), 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func CopySid(destSidLen uint32, destSid *SID, srcSid *SID) (err error) {
	r1, _, e1 := Syscall(procCopySid.Addr(), 3, uintptr(destSidLen), uintptr(unsafe.Pointer(destSid)), uintptr(unsafe.Pointer(srcSid)))
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func CreateProcessAsUser(token Token, appName *uint16, commandLine *uint16, procSecurity *SecurityAttributes, threadSecurity *SecurityAttributes, inheritHandles bool, creationFlags uint32, env *uint16, currentDir *uint16, startupInfo *StartupInfo, outProcInfo *ProcessInformation) (err error) {
	var _p0 uint32
	if inheritHandles {
		_p0 = 1
	}
	r1, _, e1 := Syscall12(procCreateProcessAsUserW.Addr(), 11, uintptr(token), uintptr(unsafe.Pointer(appName)), uintptr(unsafe.Pointer(commandLine)), uintptr(unsafe.Pointer(procSecurity)), uintptr(unsafe.Pointer(threadSecurity)), uintptr(_p0), uintptr(creationFlags), uintptr(unsafe.Pointer(env)), uintptr(unsafe.Pointer(currentDir)), uintptr(unsafe.Pointer(startupInfo)), uintptr(unsafe.Pointer(outProcInfo)), 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func CryptAcquireContext(provhandle *Handle, container *uint16, provider *uint16, provtype uint32, flags uint32) (err error) {
	r1, _, e1 := Syscall6(procCryptAcquireContextW.Addr(), 5, uintptr(unsafe.Pointer(provhandle)), uintptr(unsafe.Pointer(container)), uintptr(unsafe.Pointer(provider)), uintptr(provtype), uintptr(flags), 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func CryptGenRandom(provhandle Handle, buflen uint32, buf *byte) (err error) {
	r1, _, e1 := Syscall(procCryptGenRandom.Addr(), 3, uintptr(provhandle), uintptr(buflen), uintptr(unsafe.Pointer(buf)))
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func CryptReleaseContext(provhandle Handle, flags uint32) (err error) {
	r1, _, e1 := Syscall(procCryptReleaseContext.Addr(), 2, uintptr(provhandle), uintptr(flags), 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func GetLengthSid(sid *SID) (len uint32) {
	r0, _, _ := Syscall(procGetLengthSid.Addr(), 1, uintptr(unsafe.Pointer(sid)), 0, 0)
	len = uint32(r0)
	return
}

func GetTokenInformation(t Token, infoClass uint32, info *byte, infoLen uint32, returnedLen *uint32) (err error) {
	r1, _, e1 := Syscall6(procGetTokenInformation.Addr(), 5, uintptr(t), uintptr(infoClass), uintptr(unsafe.Pointer(info)), uintptr(infoLen), uintptr(unsafe.Pointer(returnedLen)), 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func LookupAccountName(systemName *uint16, accountName *uint16, sid *SID, sidLen *uint32, refdDomainName *uint16, refdDomainNameLen *uint32, use *uint32) (err error) {
	r1, _, e1 := Syscall9(procLookupAccountNameW.Addr(), 7, uintptr(unsafe.Pointer(systemName)), uintptr(unsafe.Pointer(accountName)), uintptr(unsafe.Pointer(sid)), uintptr(unsafe.Pointer(sidLen)), uintptr(unsafe.Pointer(refdDomainName)), uintptr(unsafe.Pointer(refdDomainNameLen)), uintptr(unsafe.Pointer(use)), 0, 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func LookupAccountSid(systemName *uint16, sid *SID, name *uint16, nameLen *uint32, refdDomainName *uint16, refdDomainNameLen *uint32, use *uint32) (err error) {
	r1, _, e1 := Syscall9(procLookupAccountSidW.Addr(), 7, uintptr(unsafe.Pointer(systemName)), uintptr(unsafe.Pointer(sid)), uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(nameLen)), uintptr(unsafe.Pointer(refdDomainName)), uintptr(unsafe.Pointer(refdDomainNameLen)), uintptr(unsafe.Pointer(use)), 0, 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func OpenProcessToken(h Handle, access uint32, token *Token) (err error) {
	r1, _, e1 := Syscall(procOpenProcessToken.Addr(), 3, uintptr(h), uintptr(access), uintptr(unsafe.Pointer(token)))
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func RegCloseKey(key Handle) (regerrno error) {
	r0, _, _ := Syscall(procRegCloseKey.Addr(), 1, uintptr(key), 0, 0)
	if r0 != 0 {
		regerrno = Errno(r0)
	}
	return
}

func regEnumKeyEx(key Handle, index uint32, name *uint16, nameLen *uint32, reserved *uint32, class *uint16, classLen *uint32, lastWriteTime *Filetime) (regerrno error) {
	r0, _, _ := Syscall9(procRegEnumKeyExW.Addr(), 8, uintptr(key), uintptr(index), uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(nameLen)), uintptr(unsafe.Pointer(reserved)), uintptr(unsafe.Pointer(class)), uintptr(unsafe.Pointer(classLen)), uintptr(unsafe.Pointer(lastWriteTime)), 0)
	if r0 != 0 {
		regerrno = Errno(r0)
	}
	return
}

func RegOpenKeyEx(key Handle, subkey *uint16, options uint32, desiredAccess uint32, result *Handle) (regerrno error) {
	r0, _, _ := Syscall6(procRegOpenKeyExW.Addr(), 5, uintptr(key), uintptr(unsafe.Pointer(subkey)), uintptr(options), uintptr(desiredAccess), uintptr(unsafe.Pointer(result)), 0)
	if r0 != 0 {
		regerrno = Errno(r0)
	}
	return
}

func RegQueryInfoKey(key Handle, class *uint16, classLen *uint32, reserved *uint32, subkeysLen *uint32, maxSubkeyLen *uint32, maxClassLen *uint32, valuesLen *uint32, maxValueNameLen *uint32, maxValueLen *uint32, saLen *uint32, lastWriteTime *Filetime) (regerrno error) {
	r0, _, _ := Syscall12(procRegQueryInfoKeyW.Addr(), 12, uintptr(key), uintptr(unsafe.Pointer(class)), uintptr(unsafe.Pointer(classLen)), uintptr(unsafe.Pointer(reserved)), uintptr(unsafe.Pointer(subkeysLen)), uintptr(unsafe.Pointer(maxSubkeyLen)), uintptr(unsafe.Pointer(maxClassLen)), uintptr(unsafe.Pointer(valuesLen)), uintptr(unsafe.Pointer(maxValueNameLen)), uintptr(unsafe.Pointer(maxValueLen)), uintptr(unsafe.Pointer(saLen)), uintptr(unsafe.Pointer(lastWriteTime)))
	if r0 != 0 {
		regerrno = Errno(r0)
	}
	return
}

func RegQueryValueEx(key Handle, name *uint16, reserved *uint32, valtype *uint32, buf *byte, buflen *uint32) (regerrno error) {
	r0, _, _ := Syscall6(procRegQueryValueExW.Addr(), 6, uintptr(key), uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(reserved)), uintptr(unsafe.Pointer(valtype)), uintptr(unsafe.Pointer(buf)), uintptr(unsafe.Pointer(buflen)))
	if r0 != 0 {
		regerrno = Errno(r0)
	}
	return
}

func CertAddCertificateContextToStore(store Handle, certContext *CertContext, addDisposition uint32, storeContext **CertContext) (err error) {
	r1, _, e1 := Syscall6(procCertAddCertificateContextToStore.Addr(), 4, uintptr(store), uintptr(unsafe.Pointer(certContext)), uintptr(addDisposition), uintptr(unsafe.Pointer(storeContext)), 0, 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func CertCloseStore(store Handle, flags uint32) (err error) {
	r1, _, e1 := Syscall(procCertCloseStore.Addr(), 2, uintptr(store), uintptr(flags), 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func CertCreateCertificateContext(certEncodingType uint32, certEncoded *byte, encodedLen uint32) (context *CertContext, err error) {
	r0, _, e1 := Syscall(procCertCreateCertificateContext.Addr(), 3, uintptr(certEncodingType), uintptr(unsafe.Pointer(certEncoded)), uintptr(encodedLen))
	context = (*CertContext)(unsafe.Pointer(r0))
	if context == nil {
		err = errnoErr(e1)
	}
	return
}

func CertEnumCertificatesInStore(store Handle, prevContext *CertContext) (context *CertContext, err error) {
	r0, _, e1 := Syscall(procCertEnumCertificatesInStore.Addr(), 2, uintptr(store), uintptr(unsafe.Pointer(prevContext)), 0)
	context = (*CertContext)(unsafe.Pointer(r0))
	if context == nil {
		err = errnoErr(e1)
	}
	return
}

func CertFreeCertificateChain(ctx *CertChainContext) {
	Syscall(procCertFreeCertificateChain.Addr(), 1, uintptr(unsafe.Pointer(ctx)), 0, 0)
	return
}

func CertFreeCertificateContext(ctx *CertContext) (err error) {
	r1, _, e1 := Syscall(procCertFreeCertificateContext.Addr(), 1, uintptr(unsafe.Pointer(ctx)), 0, 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func CertGetCertificateChain(engine Handle, leaf *CertContext, time *Filetime, additionalStore Handle, para *CertChainPara, flags uint32, reserved uintptr, chainCtx **CertChainContext) (err error) {
	r1, _, e1 := Syscall9(procCertGetCertificateChain.Addr(), 8, uintptr(engine), uintptr(unsafe.Pointer(leaf)), uintptr(unsafe.Pointer(time)), uintptr(additionalStore), uintptr(unsafe.Pointer(para)), uintptr(flags), uintptr(reserved), uintptr(unsafe.Pointer(chainCtx)), 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func CertOpenStore(storeProvider uintptr, msgAndCertEncodingType uint32, cryptProv uintptr, flags uint32, para uintptr) (handle Handle, err error) {
	r0, _, e1 := Syscall6(procCertOpenStore.Addr(), 5, uintptr(storeProvider), uintptr(msgAndCertEncodingType), uintptr(cryptProv), uintptr(flags), uintptr(para), 0)
	handle = Handle(r0)
	if handle == 0 {
		err = errnoErr(e1)
	}
	return
}

func CertOpenSystemStore(hprov Handle, name *uint16) (store Handle, err error) {
	r0, _, e1 := Syscall(procCertOpenSystemStoreW.Addr(), 2, uintptr(hprov), uintptr(unsafe.Pointer(name)), 0)
	store = Handle(r0)
	if store == 0 {
		err = errnoErr(e1)
	}
	return
}

func CertVerifyCertificateChainPolicy(policyOID uintptr, chain *CertChainContext, para *CertChainPolicyPara, status *CertChainPolicyStatus) (err error) {
	r1, _, e1 := Syscall6(procCertVerifyCertificateChainPolicy.Addr(), 4, uintptr(policyOID), uintptr(unsafe.Pointer(chain)), uintptr(unsafe.Pointer(para)), uintptr(unsafe.Pointer(status)), 0, 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func DnsNameCompare(name1 *uint16, name2 *uint16) (same bool) {
	r0, _, _ := Syscall(procDnsNameCompare_W.Addr(), 2, uintptr(unsafe.Pointer(name1)), uintptr(unsafe.Pointer(name2)), 0)
	same = r0 != 0
	return
}

func DnsQuery(name string, qtype uint16, options uint32, extra *byte, qrs **DNSRecord, pr *byte) (status error) {
	var _p0 *uint16
	_p0, status = UTF16PtrFromString(name)
	if status != nil {
		return
	}
	return _DnsQuery(_p0, qtype, options, extra, qrs, pr)
}

func _DnsQuery(name *uint16, qtype uint16, options uint32, extra *byte, qrs **DNSRecord, pr *byte) (status error) {
	r0, _, _ := Syscall6(procDnsQuery_W.Addr(), 6, uintptr(unsafe.Pointer(name)), uintptr(qtype), uintptr(options), uintptr(unsafe.Pointer(extra)), uintptr(unsafe.Pointer(qrs)), uintptr(unsafe.Pointer(pr)))
	if r0 != 0 {
		status = Errno(r0)
	}
	return
}

func DnsRecordListFree(rl *DNSRecord, freetype uint32) {
	Syscall(procDnsRecordListFree.Addr(), 2, uintptr(unsafe.Pointer(rl)), uintptr(freetype), 0)
	return
}

func GetAdaptersInfo(ai *IpAdapterInfo, ol *uint32) (errcode error) {
	r0, _, _ := Syscall(procGetAdaptersInfo.Addr(), 2, uintptr(unsafe.Pointer(ai)), uintptr(unsafe.Pointer(ol)), 0)
	if r0 != 0 {
		errcode = Errno(r0)
	}
	return
}

func GetIfEntry(pIfRow *MibIfRow) (errcode error) {
	r0, _, _ := Syscall(procGetIfEntry.Addr(), 1, uintptr(unsafe.Pointer(pIfRow)), 0, 0)
	if r0 != 0 {
		errcode = Errno(r0)
	}
	return
}

func CancelIo(s Handle) (err error) {
	r1, _, e1 := Syscall(procCancelIo.Addr(), 1, uintptr(s), 0, 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func CancelIoEx(s Handle, o *Overlapped) (err error) {
	r1, _, e1 := Syscall(procCancelIoEx.Addr(), 2, uintptr(s), uintptr(unsafe.Pointer(o)), 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func CloseHandle(handle Handle) (err error) {
	r1, _, e1 := Syscall(procCloseHandle.Addr(), 1, uintptr(handle), 0, 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func CreateDirectory(path *uint16, sa *SecurityAttributes) (err error) {
	r1, _, e1 := Syscall(procCreateDirectoryW.Addr(), 2, uintptr(unsafe.Pointer(path)), uintptr(unsafe.Pointer(sa)), 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func CreateFileMapping(fhandle Handle, sa *SecurityAttributes, prot uint32, maxSizeHigh uint32, maxSizeLow uint32, name *uint16) (handle Handle, err error) {
	r0, _, e1 := Syscall6(procCreateFileMappingW.Addr(), 6, uintptr(fhandle), uintptr(unsafe.Pointer(sa)), uintptr(prot), uintptr(maxSizeHigh), uintptr(maxSizeLow), uintptr(unsafe.Pointer(name)))
	handle = Handle(r0)
	if handle == 0 {
		err = errnoErr(e1)
	}
	return
}

func CreateFile(name *uint16, access uint32, mode uint32, sa *SecurityAttributes, createmode uint32, attrs uint32, templatefile int32) (handle Handle, err error) {
	r0, _, e1 := Syscall9(procCreateFileW.Addr(), 7, uintptr(unsafe.Pointer(name)), uintptr(access), uintptr(mode), uintptr(unsafe.Pointer(sa)), uintptr(createmode), uintptr(attrs), uintptr(templatefile), 0, 0)
	handle = Handle(r0)
	if handle == InvalidHandle {
		err = errnoErr(e1)
	}
	return
}

func CreateHardLink(filename *uint16, existingfilename *uint16, reserved uintptr) (err error) {
	r1, _, e1 := Syscall(procCreateHardLinkW.Addr(), 3, uintptr(unsafe.Pointer(filename)), uintptr(unsafe.Pointer(existingfilename)), uintptr(reserved))
	if r1&0xff == 0 {
		err = errnoErr(e1)
	}
	return
}

func createIoCompletionPort(filehandle Handle, cphandle Handle, key uintptr, threadcnt uint32) (handle Handle, err error) {
	r0, _, e1 := Syscall6(procCreateIoCompletionPort.Addr(), 4, uintptr(filehandle), uintptr(cphandle), uintptr(key), uintptr(threadcnt), 0, 0)
	handle = Handle(r0)
	if handle == 0 {
		err = errnoErr(e1)
	}
	return
}

func CreatePipe(readhandle *Handle, writehandle *Handle, sa *SecurityAttributes, size uint32) (err error) {
	r1, _, e1 := Syscall6(procCreatePipe.Addr(), 4, uintptr(unsafe.Pointer(readhandle)), uintptr(unsafe.Pointer(writehandle)), uintptr(unsafe.Pointer(sa)), uintptr(size), 0, 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func CreateProcess(appName *uint16, commandLine *uint16, procSecurity *SecurityAttributes, threadSecurity *SecurityAttributes, inheritHandles bool, creationFlags uint32, env *uint16, currentDir *uint16, startupInfo *StartupInfo, outProcInfo *ProcessInformation) (err error) {
	var _p0 uint32
	if inheritHandles {
		_p0 = 1
	}
	r1, _, e1 := Syscall12(procCreateProcessW.Addr(), 10, uintptr(unsafe.Pointer(appName)), uintptr(unsafe.Pointer(commandLine)), uintptr(unsafe.Pointer(procSecurity)), uintptr(unsafe.Pointer(threadSecurity)), uintptr(_p0), uintptr(creationFlags), uintptr(unsafe.Pointer(env)), uintptr(unsafe.Pointer(currentDir)), uintptr(unsafe.Pointer(startupInfo)), uintptr(unsafe.Pointer(outProcInfo)), 0, 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func CreateSymbolicLink(symlinkfilename *uint16, targetfilename *uint16, flags uint32) (err error) {
	r1, _, e1 := Syscall(procCreateSymbolicLinkW.Addr(), 3, uintptr(unsafe.Pointer(symlinkfilename)), uintptr(unsafe.Pointer(targetfilename)), uintptr(flags))
	if r1&0xff == 0 {
		err = errnoErr(e1)
	}
	return
}

func CreateToolhelp32Snapshot(flags uint32, processId uint32) (handle Handle, err error) {
	r0, _, e1 := Syscall(procCreateToolhelp32Snapshot.Addr(), 2, uintptr(flags), uintptr(processId), 0)
	handle = Handle(r0)
	if handle == InvalidHandle {
		err = errnoErr(e1)
	}
	return
}

func DeleteFile(path *uint16) (err error) {
	r1, _, e1 := Syscall(procDeleteFileW.Addr(), 1, uintptr(unsafe.Pointer(path)), 0, 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func deleteProcThreadAttributeList(attrlist *_PROC_THREAD_ATTRIBUTE_LIST) {
	Syscall(procDeleteProcThreadAttributeList.Addr(), 1, uintptr(unsafe.Pointer(attrlist)), 0, 0)
	return
}

func DeviceIoControl(handle Handle, ioControlCode uint32, inBuffer *byte, inBufferSize uint32, outBuffer *byte, outBufferSize uint32, bytesReturned *uint32, overlapped *Overlapped) (err error) {
	r1, _, e1 := Syscall9(procDeviceIoControl.Addr(), 8, uintptr(handle), uintptr(ioControlCode), uintptr(unsafe.Pointer(inBuffer)), uintptr(inBufferSize), uintptr(unsafe.Pointer(outBuffer)), uintptr(outBufferSize), uintptr(unsafe.Pointer(bytesReturned)), uintptr(unsafe.Pointer(overlapped)), 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func DuplicateHandle(hSourceProcessHandle Handle, hSourceHandle Handle, hTargetProcessHandle Handle, lpTargetHandle *Handle, dwDesiredAccess uint32, bInheritHandle bool, dwOptions uint32) (err error) {
	var _p0 uint32
	if bInheritHandle {
		_p0 = 1
	}
	r1, _, e1 := Syscall9(procDuplicateHandle.Addr(), 7, uintptr(hSourceProcessHandle), uintptr(hSourceHandle), uintptr(hTargetProcessHandle), uintptr(unsafe.Pointer(lpTargetHandle)), uintptr(dwDesiredAccess), uintptr(_p0), uintptr(dwOptions), 0, 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func ExitProcess(exitcode uint32) {
	Syscall(procExitProcess.Addr(), 1, uintptr(exitcode), 0, 0)
	return
}

func FindClose(handle Handle) (err error) {
	r1, _, e1 := Syscall(procFindClose.Addr(), 1, uintptr(handle), 0, 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func findFirstFile1(name *uint16, data *win32finddata1) (handle Handle, err error) {
	r0, _, e1 := Syscall(procFindFirstFileW.Addr(), 2, uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(data)), 0)
	handle = Handle(r0)
	if handle == InvalidHandle {
		err = errnoErr(e1)
	}
	return
}

func findNextFile1(handle Handle, data *win32finddata1) (err error) {
	r1, _, e1 := Syscall(procFindNextFileW.Addr(), 2, uintptr(handle), uintptr(unsafe.Pointer(data)), 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func FlushFileBuffers(handle Handle) (err error) {
	r1, _, e1 := Syscall(procFlushFileBuffers.Addr(), 1, uintptr(handle), 0, 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func FlushViewOfFile(addr uintptr, length uintptr) (err error) {
	r1, _, e1 := Syscall(procFlushViewOfFile.Addr(), 2, uintptr(addr), uintptr(length), 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func formatMessage(flags uint32, msgsrc uintptr, msgid uint32, langid uint32, buf []uint16, args *byte) (n uint32, err error) {
	var _p0 *uint16
	if len(buf) > 0 {
		_p0 = &buf[0]
	}
	r0, _, e1 := Syscall9(procFormatMessageW.Addr(), 7, uintptr(flags), uintptr(msgsrc), uintptr(msgid), uintptr(langid), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(unsafe.Pointer(args)), 0, 0)
	n = uint32(r0)
	if n == 0 {
		err = errnoErr(e1)
	}
	return
}

func FreeEnvironmentStrings(envs *uint16) (err error) {
	r1, _, e1 := Syscall(procFreeEnvironmentStringsW.Addr(), 1, uintptr(unsafe.Pointer(envs)), 0, 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func FreeLibrary(handle Handle) (err error) {
	r1, _, e1 := Syscall(procFreeLibrary.Addr(), 1, uintptr(handle), 0, 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func GetCommandLine() (cmd *uint16) {
	r0, _, _ := Syscall(procGetCommandLineW.Addr(), 0, 0, 0, 0)
	cmd = (*uint16)(unsafe.Pointer(r0))
	return
}

func GetComputerName(buf *uint16, n *uint32) (err error) {
	r1, _, e1 := Syscall(procGetComputerNameW.Addr(), 2, uintptr(unsafe.Pointer(buf)), uintptr(unsafe.Pointer(n)), 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func GetConsoleMode(console Handle, mode *uint32) (err error) {
	r1, _, e1 := Syscall(procGetConsoleMode.Addr(), 2, uintptr(console), uintptr(unsafe.Pointer(mode)), 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func GetCurrentDirectory(buflen uint32, buf *uint16) (n uint32, err error) {
	r0, _, e1 := Syscall(procGetCurrentDirectoryW.Addr(), 2, uintptr(buflen), uintptr(unsafe.Pointer(buf)), 0)
	n = uint32(r0)
	if n == 0 {
		err = errnoErr(e1)
	}
	return
}

func GetCurrentProcess() (pseudoHandle Handle, err error) {
	r0, _, e1 := Syscall(procGetCurrentProcess.Addr(), 0, 0, 0,
"""




```
Response:
Let's break down the thought process for answering this request.

**1. Understanding the Core Request:**

The request asks for an analysis of a Go file (`zsyscall_linux_amd64.go`) containing syscall wrappers. The key aspects to address are:

* **Functionality:** What do the functions in this file *do*?
* **Go Feature Implementation:**  What high-level Go features do these syscalls enable?
* **Code Examples:** Demonstrate usage with Go code.
* **Input/Output (for code examples):**  Show example inputs and expected outputs.
* **Command Line Arguments:** Describe any relevant command-line interactions.
* **Common Mistakes:** Identify potential pitfalls for users.
* **Summary of Functionality (for Part 1):**  Provide a concise overview of the file's purpose.

**2. Initial Observation and Deduction:**

The first few lines of the file are crucial:

```go
// mksyscall.pl -tags linux,amd64 syscall_linux.go syscall_linux_amd64.go
// Code generated by the command above; DO NOT EDIT.

//go:build linux && amd64

package syscall
```

This immediately tells us:

* **Code Generation:** The file is automatically generated by a Perl script (`mksyscall.pl`). This implies a systematic mapping between Go functions and underlying system calls.
* **Platform Specificity:** The `//go:build linux && amd64` directive confirms this file is specifically for Linux on the AMD64 architecture.
* **syscall Package:** It belongs to the `syscall` package, which is the Go standard library's interface to operating system calls.

**3. Analyzing the Function Signatures and Bodies:**

The code consists of numerous functions with a consistent pattern:

* **Function Name:** Typically follows the naming convention of the corresponding Linux system call (often with an `at` suffix for operations relative to a directory file descriptor).
* **String Conversion:**  Functions involving file paths use `BytePtrFromString` to convert Go strings to C-style `*byte`. This is necessary for interacting with the OS.
* **`Syscall` or `Syscall6`:** These are the core functions used to make the actual system call. The number in `SyscallN` indicates the number of arguments.
* **System Call Number:** Constants like `SYS_FACCESSAT` are used to identify the specific system call to invoke.
* **Error Handling:** The `errnoErr` function is used to convert the raw system call error code into a Go `error`.

**4. Identifying Groups of Functionality:**

As I go through the functions, I start to see them fall into logical groups:

* **File Access and Manipulation:** `faccessat`, `fchmodat`, `linkat`, `openat`, `readlinkat`, `symlinkat`, `unlinkat`, `utimensat`, `Getcwd`.
* **Process Management:** `pipe2`, `wait4`, `ptrace`, `reboot`, `Acct`.
* **File System Operations:** `mount`, `Chdir`, `Chroot`, `Close`, `Dup`, `Dup3`, `Fallocate`, `Fchdir`, `Fchmod`, `Fchownat`, `fcntl`, `Fdatasync`, `Flock`, `Fsync`, `Getdents`, `Mkdirat`, `Mknodat`, `PivotRoot`, `Renameat`, `Statfs`, `Truncate`.
* **Inter-Process Communication and Signals:** `Kill`, `Tgkill`, `Splice`, `Tee`, `sendfile`, `pipe2`.
* **Memory Management:** `munmap`, `Madvise`, `Mprotect`, `Mlock`, `Munlock`, `Mlockall`, `Munlockall`.
* **Extended Attributes:** `Getxattr`, `Listxattr`, `Removexattr`, `Setxattr`.
* **Time and Scheduling:** `Adjtimex`, `Nanosleep`, `Settimeofday`, `Times`.
* **User and Group IDs:** `Getpgid`, `Getpid`, `Getppid`, `Getpriority`, `Gettid`, `Setpgid`, `Setsid`, `Setpriority`, `Getegid`, `Geteuid`, `Getgid`, `Getuid`, `Setfsgid`, `Setfsuid`.
* **System Information:** `Sysinfo`, `Uname`.
* **Network Related (Indirectly):** `Shutdown`, `Listen`, `Select`.
* **Security/Capabilities:** `Ioperm`, `Iopl`, `prlimit1`.
* **Other:** `Umask`, `Sync`, `Pause`, `exitThread`.

**5. Connecting to Go Features:**

Now, I can start mapping these syscalls to higher-level Go functionalities:

* **File I/O:**  The `os` package heavily relies on these syscalls for file operations (`os.Open`, `os.Create`, `os.Read`, `os.Write`, etc.). Functions like `faccessat`, `openat`, `read`, `write`, `close` are fundamental.
* **Process Control:** The `os/exec` and `syscall` packages use these for process creation (`fork`, `execve` - though not directly in this snippet, they are related), signal handling (`Kill`), and process waiting (`wait4`).
* **Concurrency:** While not immediately obvious, `pipe2` is crucial for creating pipes used in inter-process communication, often used with Goroutines.
* **File System Navigation:** `os.Chdir`, `os.Getwd`, `os.Mkdir`, `os.Remove` are built upon these syscalls.
* **Security and Permissions:** Functions like `fchmodat`, `fchownat`, and the extended attribute functions are used for managing file permissions and metadata.

**6. Crafting Code Examples:**

For each identified Go feature, I try to come up with a simple, illustrative example. The key is to demonstrate how a higher-level Go function uses the underlying syscalls.

* **Example for File Access:**  Use `os.Access` which internally will likely call a function like `faccessat`.
* **Example for Process Creation:** Use `os/exec.Command` to show how a new process is launched.
* **Example for Pipes:** Use `os.Pipe` to demonstrate inter-process communication.

**7. Considering Input and Output:**

For each code example, I define clear input values and the expected outcome. This helps illustrate the function's behavior. I focus on simple cases for clarity.

**8. Addressing Command Line Arguments:**

I review the syscalls for any direct interaction with command-line arguments. In this snippet, the direct handling is less obvious, but I consider how the `os` and `os/exec` packages handle arguments. The `reboot` syscall directly takes a string argument.

**9. Identifying Common Mistakes:**

I think about potential errors developers might make when using these low-level functions or the higher-level Go abstractions.

* **Incorrect File Descriptors:**  Passing an invalid file descriptor to many of these functions will lead to errors.
* **Permission Issues:**  Operations like `fchmodat` or `openat` can fail due to insufficient permissions.
* **Path Handling:**  Incorrectly constructing file paths is a common source of errors.

**10. Summarizing Functionality (for Part 1):**

Finally, I synthesize the analysis into a concise summary of the file's purpose, emphasizing its role as a bridge between Go code and the Linux kernel's system call interface for file system and process-related operations.

**Self-Correction/Refinement During the Process:**

* **Initial Overwhelm:**  Seeing so many functions can be initially daunting. Breaking them down into logical groups is crucial.
* **Focus on the Core:**  Realize that the core mechanism is the `Syscall` function and the translation between Go types and C types.
* **Relate to Familiar Go Constructs:**  Constantly ask "How does this relate to what I already know about Go?"
* **Iterative Refinement of Examples:**  My initial examples might be too complex. Simplify them to focus on the specific functionality being demonstrated.
* **Double-Checking System Call Semantics:** If unsure about a specific syscall, quickly look up its documentation (man pages) to ensure accurate understanding.
好的，让我们来分析一下你提供的这段 Go 代码。

**功能归纳：**

这段 `zsyscall_linux_amd64.go` 文件是 Go 语言标准库 `syscall` 包的一部分，它为 Linux (amd64 架构) 操作系统提供了一系列**系统调用**的 Go 语言接口。

**更具体地说，这些 Go 函数是对底层 Linux 系统调用的封装，使得 Go 程序员可以直接在 Go 代码中调用这些系统调用，从而执行底层的操作系统操作。**

**详细功能列表：**

以下列出代码中定义的 Go 函数，并对应其封装的 Linux 系统调用（以 `SYS_` 开头的常量）：

* **文件和目录操作:**
    * `faccessat`:  检查用户是否可以访问某个相对于目录文件描述符的文件 (`SYS_FACCESSAT`)。
    * `faccessat2`:  `faccessat` 的扩展版本，增加了标志参数 (`_SYS_faccessat2`)。
    * `fchmodat`:  修改相对于目录文件描述符的文件的权限 (`SYS_FCHMODAT`)。
    * `fchmodat2`:  `fchmodat` 的扩展版本，增加了标志参数 (`_SYS_fchmodat2`)。
    * `linkat`:  创建一个硬链接，可以指定源和目标相对于目录文件描述符 (`SYS_LINKAT`)。
    * `openat`:  打开一个相对于目录文件描述符的文件 (`SYS_OPENAT`)。
    * `readlinkat`:  读取一个符号链接的内容，可以指定相对于目录文件描述符 (`SYS_READLINKAT`)。
    * `symlinkat`:  创建一个符号链接，可以指定目标相对于目录文件描述符 (`SYS_SYMLINKAT`)。
    * `unlinkat`:  删除一个文件，可以指定相对于目录文件描述符 (`SYS_UNLINKAT`)。
    * `utimensat`:  修改文件的访问和修改时间，可以指定相对于目录文件描述符 (`SYS_UTIMENSAT`)。
    * `Getcwd`: 获取当前工作目录 (`SYS_GETCWD`)。
    * `Mkdirat`: 创建一个目录，可以指定相对于目录文件描述符 (`SYS_MKDIRAT`)。
    * `Mknodat`: 创建一个特殊的文件（如设备文件），可以指定相对于目录文件描述符 (`SYS_MKNODAT`)。
    * `Renameat`: 重命名文件或目录，可以指定源和目标相对于目录文件描述符 (`SYS_RENAMEAT`)。
    * `Statfs`: 获取文件系统统计信息 (`SYS_STATFS`)。
    * `Truncate`: 截断文件到指定长度 (`SYS_TRUNCATE`)。
    * `Fallocate`:  为一个打开的文件预分配空间 (`SYS_FALLOCATE`)。
    * `Fchdir`:  将当前工作目录更改为由文件描述符引用的目录 (`SYS_FCHDIR`)。
    * `Fchmod`:  修改由文件描述符引用的文件的权限 (`SYS_FCHMOD`)。
    * `Fchownat`: 修改相对于目录文件描述符的文件的所有者和组 (`SYS_FCHOWNAT`)。
    * `Fdatasync`:  将文件数据同步到磁盘，但不包括元数据 (`SYS_FDATASYNC`)。
    * `Flock`:  对文件施加咨询锁 (`SYS_FLOCK`)。
    * `Fsync`:  将文件数据和元数据同步到磁盘 (`SYS_FSYNC`)。
    * `Getdents`:  读取目录项 (`SYS_GETDENTS64`)。

* **进程管理:**
    * `pipe2`:  创建一个管道 (`SYS_PIPE2`)。
    * `wait4`:  等待子进程状态的改变 (`SYS_WAIT4`)。
    * `ptrace`, `ptracePtr`:  控制进程执行 (`SYS_PTRACE`)。
    * `reboot`:  重启系统 (`SYS_REBOOT`)。
    * `Acct`:  启用或禁用进程记账 (`SYS_ACCT`)。
    * `Chdir`:  改变当前工作目录 (`SYS_CHDIR`)。
    * `Chroot`:  改变进程的根目录 (`SYS_CHROOT`)。
    * `Close`:  关闭一个文件描述符 (`SYS_CLOSE`)。
    * `Dup`:  复制一个文件描述符 (`SYS_DUP`)。
    * `Dup2`:  将一个文件描述符复制到另一个指定的文件描述符 (`SYS_DUP2`)。
    * `Dup3`:  `Dup2` 的扩展版本，可以设置标志 (`SYS_DUP3`)。
    * `exitThread`:  退出当前线程 (`SYS_EXIT`)。
    * `Kill`:  向进程发送信号 (`SYS_KILL`)。
    * `Tgkill`: 向指定的线程组中的线程发送信号 (`SYS_TGKILL`)。
    * `Setsid`:  创建一个新的会话 (`SYS_SETSID`)。
    * `Getpgid`: 获取进程组 ID (`SYS_GETPGID`)。
    * `Getpid`: 获取进程 ID (`SYS_GETPID`)。
    * `Getppid`: 获取父进程 ID (`SYS_GETPPID`)。
    * `Gettid`: 获取线程 ID (`SYS_GETTID`)。
    * `Setpgid`: 设置进程组 ID (`SYS_SETPGID`)。

* **内存管理:**
    * `munmap`:  取消映射内存区域 (`SYS_MUNMAP`)。
    * `Madvise`:  向内核提供关于内存区域使用模式的建议 (`SYS_MADVISE`)。
    * `Mprotect`:  设置内存区域的保护属性 (`SYS_MPROTECT`)。
    * `Mlock`:  锁定内存页到 RAM 中 (`SYS_MLOCK`)。
    * `Munlock`:  解锁之前锁定的内存页 (`SYS_MUNLOCK`)。
    * `Mlockall`:  锁定调用进程的所有内存页到 RAM 中 (`SYS_MLOCKALL`)。
    * `Munlockall`:  解锁所有被 `Mlockall` 锁定的内存页 (`SYS_MUNLOCKALL`)。

* **信号处理:** (虽然 `Kill` 和 `Tgkill` 涉及信号，但没有直接处理信号的函数)

* **时间管理:**
    * `Adjtimex`:  微调系统时钟 (`SYS_ADJTIMEX`)。
    * `Nanosleep`:  休眠一段时间 (`SYS_NANOSLEEP`)。
    * `Settimeofday`:  设置系统时间 (`SYS_SETTIMEOFDAY`)。
    * `Times`:  获取进程和子进程的 CPU 时间 (`SYS_TIMES`)。

* **用户和组 ID:**
    * `Getpriority`:  获取进程的调度优先级 (`SYS_GETPRIORITY`)。
    * `Getrusage`:  获取进程的资源使用情况 (`SYS_GETRUSAGE`)。
    * `Setpriority`:  设置进程的调度优先级 (`SYS_SETPRIORITY`)。
    * `Getegid`:  获取有效组 ID (`SYS_GETEGID`)。
    * `Geteuid`:  获取有效用户 ID (`SYS_GETEUID`)。
    * `Getgid`:  获取组 ID (`SYS_GETGID`)。
    * `Getuid`:  获取用户 ID (`SYS_GETUID`)。
    * `Setfsgid`: 设置文件系统 GID (`SYS_SETFSGID`)。
    * `Setfsuid`: 设置文件系统 UID (`SYS_SETFSUID`)。

* **扩展属性:**
    * `Getxattr`:  获取文件的扩展属性值 (`SYS_GETXATTR`)。
    * `Listxattr`:  列出文件的扩展属性名 (`SYS_LISTXATTR`)。
    * `Removexattr`:  删除文件的扩展属性 (`SYS_REMOVEXATTR`)。
    * `Setxattr`:  设置文件的扩展属性值 (`SYS_SETXATTR`)。

* **inotify (文件系统事件监控):**
    * `InotifyAddWatch`:  向 inotify 实例添加一个监视 (`SYS_INOTIFY_ADD_WATCH`)。
    * `InotifyInit`:  初始化一个 inotify 实例 (`SYS_INOTIFY_INIT`)。
    * `InotifyInit1`:  初始化一个 inotify 实例，可以设置标志 (`SYS_INOTIFY_INIT1`)。
    * `InotifyRmWatch`:  从 inotify 实例移除一个监视 (`SYS_INOTIFY_RM_WATCH`)。

* **ioctl (输入/输出控制):** (代码中未直接包含，但 `fcntl` 函数可以执行某些 ioctl 操作)

* **网络相关:**
    * `Shutdown`:  关闭套接字连接的一部分 (`SYS_SHUTDOWN`)。
    * `Listen`:  监听套接字连接 (`SYS_LISTEN`)。
    * `Select`:  同步 I/O 多路复用 (`SYS_SELECT`)。
    * `sendfile`:  在文件描述符之间传输数据 (`SYS_SENDFILE`)。
    * `Splice`:  在管道之间移动数据 (`SYS_SPLICE`)。
    * `Tee`:  在管道之间复制数据 (`SYS_TEE`)。

* **系统信息:**
    * `Sysinfo`:  获取系统信息 (`SYS_SYSINFO`)。
    * `Uname`:  获取系统信息 (`SYS_UNAME`)。
    * `Setdomainname`: 设置域名 (`SYS_SETDOMAINNAME`)。
    * `Sethostname`: 设置主机名 (`SYS_SETHOSTNAME`)。

* **安全和权限:**
    * `Umask`:  设置文件模式创建屏蔽字 (`SYS_UMASK`)。
    * `Prlimit1`: 获取或设置进程的资源限制 (`SYS_PRLIMIT64`)。
    * `Ioperm`:  设置进程的 I/O 端口权限 (`SYS_IOPERM`)。
    * `Iopl`:  更改进程的 I/O 特权级别 (`SYS_IOPL`)。

* **其他:**
    * `mount`:  挂载文件系统 (`SYS_MOUNT`)。
    * `Unmount`:  卸载文件系统 (`SYS_UMOUNT2`)。
    * `Unshare`:  取消共享进程的部分执行上下文 (`SYS_UNSHARE`)。
    * `Sync`:  将所有修改过的块缓冲区同步到磁盘 (`SYS_SYNC`)。
    * `Pause`:  等待信号 (`SYS_PAUSE`)。
    * `read`, `readlen`:  从文件描述符读取数据 (`SYS_READ`)。
    * `pread`: 从指定偏移量读取文件描述符的数据 (`SYS_PREAD64`)。
    * `pwrite`: 在指定偏移量写入文件描述符的数据 (`SYS_PWRITE64`)。
    * `write`:  向文件描述符写入数据 (`SYS_WRITE`)。
    * `fcntl`:  对文件描述符执行各种操作 (`SYS_FCNTL`)。
    * `Seek`:  改变文件偏移量 (`SYS_LSEEK`)。
    * `Fstat`: 获取与文件描述符关联的文件的状态信息 (`SYS_FSTAT`)。
    * `Fstatfs`: 获取与文件描述符关联的文件系统的统计信息 (`SYS_FSTATFS`)。
    * `Ftruncate`: 将文件描述符引用的文件截断为指定长度 (`SYS_FTRUNCATE`)。

**Go 语言功能实现示例：**

这段代码是 Go 语言标准库 `syscall` 包的底层实现，它本身并不直接实现高层次的 Go 语言功能，而是为其他 Go 包（如 `os`，`io`，`os/exec` 等）提供了构建更高级功能的基石。

**例如，`os` 包中的 `os.ReadFile` 函数最终会调用这里的 `openat` 和 `read` 系统调用：**

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	filename := "example.txt"
	content, err := os.ReadFile(filename)
	if err != nil {
		fmt.Println("Error reading file:", err)
		return
	}
	fmt.Println("File content:", string(content))
}
```

**假设 `example.txt` 文件的内容是 "Hello, world!"**

**推断的输入与输出：**

* **输入 (对于 `os.ReadFile`):**
    * `filename`: "example.txt"

* **内部调用 (大致对应 `zsyscall_linux_amd64.go` 中的函数):**
    1. `openat(AT_FDCWD, "example.txt", O_RDONLY, 0)`  // 打开文件 (AT_FDCWD 表示相对于当前工作目录)
    2. `read(fd, buf)` // 多次调用读取文件内容到 buffer
    3. `close(fd)`     // 关闭文件

* **输出 (对于 `os.ReadFile`):**
    * `content`: `[]byte("Hello, world!")`
    * `err`: `nil`

* **最终输出到控制台:**
    ```
    File content: Hello, world!
    ```

**命令行参数的具体处理：**

这段代码本身不直接处理命令行参数。命令行参数的处理通常发生在 `main` 函数所在的包中，然后可能会调用 `os` 包中的函数，最终间接地触发这里的系统调用。

例如，如果你的 Go 程序接受一个文件名作为命令行参数来读取文件，那么 `os.Args` 会存储这些参数，然后你可能会使用 `os.Open(os.Args[1])`，这会最终调用到 `zsyscall_linux_amd64.go` 中的 `openat`。

**使用者易犯错的点：**

对于直接使用 `syscall` 包的用户来说，容易犯错的点包括：

* **错误的文件描述符:**  传递无效或已关闭的文件描述符会导致程序崩溃或产生不可预测的行为。
* **不正确的参数类型和大小:**  系统调用对参数的类型和大小有严格的要求，Go 的类型和 C 的类型需要正确转换，否则会导致错误。例如，字符串需要转换为 `*byte`。
* **忽略错误返回值:**  系统调用通常会返回错误码，必须正确检查和处理这些错误。
* **不理解系统调用的语义:**  不同的系统调用有不同的功能和副作用，需要仔细理解其行为。
* **内存安全:**  在使用涉及内存指针的系统调用时，需要格外注意内存安全，避免野指针和内存泄漏。

**例如：**

```go
package main

import (
	"fmt"
	"syscall"
	"unsafe"
)

func main() {
	// 错误地使用 openat，mode 参数应该是指示权限的，这里用成了文件内容
	fd, err := syscall.Openat(syscall.AT_FDCWD, "nonexistent.txt", syscall.O_RDONLY, 0777)
	if err != nil {
		fmt.Println("Error opening file:", err)
		// 正确的做法是检查错误，而不是继续使用无效的 fd
	}
	fmt.Println("File descriptor:", fd) // 这里 fd 的值可能是 -1，表示错误

	// 尝试读取一个可能无效的文件描述符
	var buf [100]byte
	n, err := syscall.Read(fd, buf[:]) // 如果 fd 是 -1，这里会出错
	if err != nil {
		fmt.Println("Error reading file:", err)
	} else {
		fmt.Println("Read", n, "bytes")
	}

	syscall.Close(fd) // 如果 fd 是 -1，close 也会出错
}
```

**功能归纳（针对第 1 部分）：**

这段 `go/src/syscall/zsyscall_linux_amd64.go` 代码是 Go 语言 `syscall` 包中专门为 Linux (amd64 架构) 生成的一部分。它的主要功能是提供了一系列 Go 函数，这些函数**直接封装了底层的 Linux 系统调用**，涵盖了文件和目录操作、进程管理、内存管理、信号处理、时间管理、用户和组 ID 管理、扩展属性管理、inotify、网络相关操作、系统信息获取以及一些其他的系统级功能。 这些封装后的 Go 函数使得 Go 程序员能够与 Linux 内核进行底层交互，执行各种操作系统级别的任务。 这部分代码是构建更高级 Go 标准库功能的基础。

Prompt: 
```
这是路径为go/src/syscall/zsyscall_linux_amd64.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
请用中文回答。
这是第1部分，共2部分，请归纳一下它的功能

"""
// mksyscall.pl -tags linux,amd64 syscall_linux.go syscall_linux_amd64.go
// Code generated by the command above; DO NOT EDIT.

//go:build linux && amd64

package syscall

import "unsafe"

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func faccessat(dirfd int, path string, mode uint32) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func faccessat2(dirfd int, path string, mode uint32, flags int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall6(_SYS_faccessat2, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fchmodat(dirfd int, path string, mode uint32) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fchmodat2(dirfd int, path string, mode uint32, flags int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall6(_SYS_fchmodat2, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func linkat(olddirfd int, oldpath string, newdirfd int, newpath string, flags int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(oldpath)
	if err != nil {
		return
	}
	var _p1 *byte
	_p1, err = BytePtrFromString(newpath)
	if err != nil {
		return
	}
	_, _, e1 := Syscall6(SYS_LINKAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mode), 0, 0)
	fd = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func pipe2(p *[2]_C_int, flags int) (err error) {
	_, _, e1 := RawSyscall(SYS_PIPE2, uintptr(unsafe.Pointer(p)), uintptr(flags), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func readlinkat(dirfd int, path string, buf []byte) (n int, err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	var _p1 unsafe.Pointer
	if len(buf) > 0 {
		_p1 = unsafe.Pointer(&buf[0])
	} else {
		_p1 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func symlinkat(oldpath string, newdirfd int, newpath string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(oldpath)
	if err != nil {
		return
	}
	var _p1 *byte
	_p1, err = BytePtrFromString(newpath)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func unlinkat(dirfd int, path string, flags int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func utimensat(dirfd int, path string, times *[2]Timespec, flag int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flag), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getcwd(buf []byte) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(buf) > 0 {
		_p0 = unsafe.Pointer(&buf[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall(SYS_GETCWD, uintptr(_p0), uintptr(len(buf)), 0)
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) {
	r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)
	wpid = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func ptrace(request int, pid int, addr uintptr, data uintptr) (err error) {
	_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func ptracePtr(request int, pid int, addr uintptr, data unsafe.Pointer) (err error) {
	_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func reboot(magic1 uint, magic2 uint, cmd int, arg string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(arg)
	if err != nil {
		return
	}
	_, _, e1 := Syscall6(SYS_REBOOT, uintptr(magic1), uintptr(magic2), uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func mount(source string, target string, fstype string, flags uintptr, data *byte) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(source)
	if err != nil {
		return
	}
	var _p1 *byte
	_p1, err = BytePtrFromString(target)
	if err != nil {
		return
	}
	var _p2 *byte
	_p2, err = BytePtrFromString(fstype)
	if err != nil {
		return
	}
	_, _, e1 := Syscall6(SYS_MOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(flags), uintptr(unsafe.Pointer(data)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Acct(path string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_ACCT, uintptr(unsafe.Pointer(_p0)), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Adjtimex(buf *Timex) (state int, err error) {
	r0, _, e1 := Syscall(SYS_ADJTIMEX, uintptr(unsafe.Pointer(buf)), 0, 0)
	state = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Chdir(path string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Chroot(path string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Close(fd int) (err error) {
	_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Dup(oldfd int) (fd int, err error) {
	r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)
	fd = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Dup3(oldfd int, newfd int, flags int) (err error) {
	_, _, e1 := Syscall(SYS_DUP3, uintptr(oldfd), uintptr(newfd), uintptr(flags))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func EpollCreate1(flag int) (fd int, err error) {
	r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE1, uintptr(flag), 0, 0)
	fd = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error) {
	_, _, e1 := RawSyscall6(SYS_EPOLL_CTL, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fallocate(fd int, mode uint32, off int64, len int64) (err error) {
	_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(len), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fchdir(fd int) (err error) {
	_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fchmod(fd int, mode uint32) (err error) {
	_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fcntl(fd int, cmd int, arg int) (val int, err error) {
	r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))
	val = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fdatasync(fd int) (err error) {
	_, _, e1 := Syscall(SYS_FDATASYNC, uintptr(fd), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Flock(fd int, how int) (err error) {
	_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fsync(fd int) (err error) {
	_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getdents(fd int, buf []byte) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(buf) > 0 {
		_p0 = unsafe.Pointer(&buf[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(_p0), uintptr(len(buf)))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getpgid(pid int) (pgid int, err error) {
	r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)
	pgid = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getpid() (pid int) {
	r0, _ := rawSyscallNoError(SYS_GETPID, 0, 0, 0)
	pid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getppid() (ppid int) {
	r0, _ := rawSyscallNoError(SYS_GETPPID, 0, 0, 0)
	ppid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getpriority(which int, who int) (prio int, err error) {
	r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)
	prio = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getrusage(who int, rusage *Rusage) (err error) {
	_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Gettid() (tid int) {
	r0, _ := rawSyscallNoError(SYS_GETTID, 0, 0, 0)
	tid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getxattr(path string, attr string, dest []byte) (sz int, err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	var _p1 *byte
	_p1, err = BytePtrFromString(attr)
	if err != nil {
		return
	}
	var _p2 unsafe.Pointer
	if len(dest) > 0 {
		_p2 = unsafe.Pointer(&dest[0])
	} else {
		_p2 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_GETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)
	sz = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(pathname)
	if err != nil {
		return
	}
	r0, _, e1 := Syscall(SYS_INOTIFY_ADD_WATCH, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(mask))
	watchdesc = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func InotifyInit1(flags int) (fd int, err error) {
	r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT1, uintptr(flags), 0, 0)
	fd = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func InotifyRmWatch(fd int, watchdesc uint32) (success int, err error) {
	r0, _, e1 := RawSyscall(SYS_INOTIFY_RM_WATCH, uintptr(fd), uintptr(watchdesc), 0)
	success = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Kill(pid int, sig Signal) (err error) {
	_, _, e1 := RawSyscall(SYS_KILL, uintptr(pid), uintptr(sig), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Klogctl(typ int, buf []byte) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(buf) > 0 {
		_p0 = unsafe.Pointer(&buf[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(_p0), uintptr(len(buf)))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Listxattr(path string, dest []byte) (sz int, err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	var _p1 unsafe.Pointer
	if len(dest) > 0 {
		_p1 = unsafe.Pointer(&dest[0])
	} else {
		_p1 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall(SYS_LISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))
	sz = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Mkdirat(dirfd int, path string, mode uint32) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Mknodat(dirfd int, path string, mode uint32, dev int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Nanosleep(time *Timespec, leftover *Timespec) (err error) {
	_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func PivotRoot(newroot string, putold string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(newroot)
	if err != nil {
		return
	}
	var _p1 *byte
	_p1, err = BytePtrFromString(putold)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_PIVOT_ROOT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func prlimit1(pid int, resource int, newlimit *Rlimit, old *Rlimit) (err error) {
	_, _, e1 := RawSyscall6(SYS_PRLIMIT64, uintptr(pid), uintptr(resource), uintptr(unsafe.Pointer(newlimit)), uintptr(unsafe.Pointer(old)), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func read(fd int, p []byte) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(_p0), uintptr(len(p)))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Removexattr(path string, attr string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	var _p1 *byte
	_p1, err = BytePtrFromString(attr)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_REMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Setdomainname(p []byte) (err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	_, _, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(_p0), uintptr(len(p)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Sethostname(p []byte) (err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	_, _, e1 := Syscall(SYS_SETHOSTNAME, uintptr(_p0), uintptr(len(p)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Setpgid(pid int, pgid int) (err error) {
	_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Setsid() (pid int, err error) {
	r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)
	pid = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Settimeofday(tv *Timeval) (err error) {
	_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Setpriority(which int, who int, prio int) (err error) {
	_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Setxattr(path string, attr string, data []byte, flags int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	var _p1 *byte
	_p1, err = BytePtrFromString(attr)
	if err != nil {
		return
	}
	var _p2 unsafe.Pointer
	if len(data) > 0 {
		_p2 = unsafe.Pointer(&data[0])
	} else {
		_p2 = unsafe.Pointer(&_zero)
	}
	_, _, e1 := Syscall6(SYS_SETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Sync() {
	Syscall(SYS_SYNC, 0, 0, 0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Sysinfo(info *Sysinfo_t) (err error) {
	_, _, e1 := RawSyscall(SYS_SYSINFO, uintptr(unsafe.Pointer(info)), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Tee(rfd int, wfd int, len int, flags int) (n int64, err error) {
	r0, _, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)
	n = int64(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Tgkill(tgid int, tid int, sig Signal) (err error) {
	_, _, e1 := RawSyscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Times(tms *Tms) (ticks uintptr, err error) {
	r0, _, e1 := RawSyscall(SYS_TIMES, uintptr(unsafe.Pointer(tms)), 0, 0)
	ticks = uintptr(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Umask(mask int) (oldmask int) {
	r0, _ := rawSyscallNoError(SYS_UMASK, uintptr(mask), 0, 0)
	oldmask = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Uname(buf *Utsname) (err error) {
	_, _, e1 := RawSyscall(SYS_UNAME, uintptr(unsafe.Pointer(buf)), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Unmount(target string, flags int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(target)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_UMOUNT2, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Unshare(flags int) (err error) {
	_, _, e1 := Syscall(SYS_UNSHARE, uintptr(flags), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func write(fd int, p []byte) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func exitThread(code int) (err error) {
	_, _, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func readlen(fd int, p *byte, np int) (n int, err error) {
	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func munmap(addr uintptr, length uintptr) (err error) {
	_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Madvise(b []byte, advice int) (err error) {
	var _p0 unsafe.Pointer
	if len(b) > 0 {
		_p0 = unsafe.Pointer(&b[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(advice))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Mprotect(b []byte, prot int) (err error) {
	var _p0 unsafe.Pointer
	if len(b) > 0 {
		_p0 = unsafe.Pointer(&b[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Mlock(b []byte) (err error) {
	var _p0 unsafe.Pointer
	if len(b) > 0 {
		_p0 = unsafe.Pointer(&b[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Munlock(b []byte) (err error) {
	var _p0 unsafe.Pointer
	if len(b) > 0 {
		_p0 = unsafe.Pointer(&b[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Mlockall(flags int) (err error) {
	_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Munlockall() (err error) {
	_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Dup2(oldfd int, newfd int) (err error) {
	_, _, e1 := Syscall(SYS_DUP2, uintptr(oldfd), uintptr(newfd), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fchown(fd int, uid int, gid int) (err error) {
	_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fstat(fd int, stat *Stat_t) (err error) {
	_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fstatfs(fd int, buf *Statfs_t) (err error) {
	_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(buf)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Ftruncate(fd int, length int64) (err error) {
	_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getegid() (egid int) {
	r0, _ := rawSyscallNoError(SYS_GETEGID, 0, 0, 0)
	egid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Geteuid() (euid int) {
	r0, _ := rawSyscallNoError(SYS_GETEUID, 0, 0, 0)
	euid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getgid() (gid int) {
	r0, _ := rawSyscallNoError(SYS_GETGID, 0, 0, 0)
	gid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getuid() (uid int) {
	r0, _ := rawSyscallNoError(SYS_GETUID, 0, 0, 0)
	uid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func InotifyInit() (fd int, err error) {
	r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT, 0, 0, 0)
	fd = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Ioperm(from int, num int, on int) (err error) {
	_, _, e1 := Syscall(SYS_IOPERM, uintptr(from), uintptr(num), uintptr(on))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Iopl(level int) (err error) {
	_, _, e1 := Syscall(SYS_IOPL, uintptr(level), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Listen(s int, n int) (err error) {
	_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(n), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pause() (err error) {
	_, _, e1 := Syscall(SYS_PAUSE, 0, 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func pread(fd int, p []byte, offset int64) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func pwrite(fd int, p []byte, offset int64) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(oldpath)
	if err != nil {
		return
	}
	var _p1 *byte
	_p1, err = BytePtrFromString(newpath)
	if err != nil {
		return
	}
	_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Seek(fd int, offset int64, whence int) (off int64, err error) {
	r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))
	off = int64(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) {
	r0, _, e1 := Syscall6(SYS_SELECT, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) {
	r0, _, e1 := Syscall6(SYS_SENDFILE, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)
	written = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Setfsgid(gid int) (err error) {
	_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Setfsuid(uid int) (err error) {
	_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Shutdown(fd int, how int) (err error) {
	_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(fd), uintptr(how), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error) {
	r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))
	n = int64(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Statfs(path string, buf *Statfs_t) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func SyncFileRange(fd int, off int64, n int64, flags int) (err error) {
	_, _, e1 := Syscall6(SYS_SYNC_FILE_RANGE, uintptr(fd), uintptr(off), uintptr(n), uintptr(flags), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Truncate(path string, length int64) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), 0)
	if e1 != 0
"""




```
Response:
Let's break down the thought process for analyzing the provided Go code snippet.

**1. Initial Scan and Keyword Spotting:**

My first step is always a quick scan for recognizable keywords and function names. I see things like `Test...`, `runtime.GOOS`, `t.Skip`, `RemoveAll`, `Pipe`, `Close`, `Open`, `UserCacheDir`, `UserConfigDir`, `UserHomeDir`, `Seek`, `Readdirnames`, `DirFS`, `ReadFile`, `WriteString`, `CopyFS`, `Symlink`, `OpenFile`, `Remove`. These immediately give me a strong sense of the code's purpose: testing various `os` package functionalities.

**2. Grouping by Functionality:**

Next, I start grouping the test functions based on the `os` package function they seem to be testing. This helps organize the analysis:

* **File/Directory Operations:** `TestRemoveAllRace`, `TestDoubleCloseError`, `TestDirSeek`, `TestReaddirSmallSeek`, `TestOpenFileKeepsPermissions`, `TestDirFS`, `TestRootDirFS`, `TestDirFSRootDir`, `TestDirFSEmptyDir`, `TestDirFSPathsValid`, `TestReadFileProc`, `TestDirFSReadFileProc`, `TestCopyFS`, `TestCopyFSWithSymlinks`, `TestAppendDoesntOverwrite`, `TestRemoveReadOnlyFile`.
* **Pipe Operations:** `TestPipeThreads`, `TestPipeIOCloseRace`, `TestPipeCloseRace`.
* **User Directory Functions:** `TestUserCacheDir`, `TestUserCacheDirXDGConfigDirEnvVar`, `TestUserConfigDir`, `TestUserConfigDirXDGConfigDirEnvVar`, `TestUserHomeDir`.
* **Temporary Files/Directories:** `TestRandomLen`.
* **Internal/Helper Functions:** `isDeadlineExceeded`, `forceMFTUpdateOnWindows`, `testOpenFileKeepsPermissions`, `testDirFS`, `verifyCopyFS`.

**3. Analyzing Individual Tests:**

Now I dive into each test function, understanding its purpose and how it works:

* **`TestRemoveAllRace`**:  The name suggests a race condition test. The code confirms this by creating multiple goroutines to concurrently call `RemoveAll` on the same directory. The `hold` channel is used to synchronize the start of the removals, ensuring a race. The `t.Skip` for Windows points to a known issue.

* **`TestPipeThreads`**: This tests if reading from a pipe consumes a thread. It creates many pipes and goroutines reading from them. The `debug.SetMaxThreads` part is key – it limits the number of OS threads. If the test completes without hanging, it implies goroutines reading from pipes don't necessarily need a dedicated OS thread. The platform skips are important as pipe behavior can differ.

* **`TestDoubleCloseError`**:  This checks that closing a file/directory twice results in the expected `ErrClosed` error. The helper function `testDoubleCloseError` makes it reusable for both files and directories.

* **`TestUserCacheDir`, `TestUserConfigDir`, `TestUserHomeDir`**: These are straightforward tests for the corresponding `os` functions. They check for non-empty results and the existence of the returned directories. The `XDG_*` tests specifically verify the influence of environment variables on these functions. The platform skips are relevant for where these environment variables are standard.

* **`TestDirSeek`, `TestReaddirSmallSeek`**: These focus on the behavior of `Seek` and `Readdirnames` when working with directories. `TestDirSeek` checks that seeking back to the beginning of a directory allows reading the contents again. `TestReaddirSmallSeek` is designed to prevent duplicate entries after a seek, highlighting a potential edge case.

* **`TestOpenFileKeepsPermissions`**: This test ensures that opening a file (especially with `O_TRUNC`) doesn't inadvertently change its existing permissions. It uses a helper function and tests both `OpenFile` and `RootOpenFile`.

* **`TestDirFS`, `TestRootDirFS`, `TestDirFSRootDir`, `TestDirFSEmptyDir`, `TestDirFSPathsValid`**: These tests thoroughly examine the `DirFS` functionality, including handling of non-existent files/directories, backslashes, device files, root paths, empty paths, and valid paths. The `forceMFTUpdateOnWindows` is a Windows-specific workaround for metadata synchronization issues.

* **`TestReadFileProc`, `TestDirFSReadFileProc`**: These specifically test reading files under `/proc` (common on Linux). They address a quirk where `/proc` files might report zero size but require special handling when reading.

* **`TestWriteStringAlloc`**: This is a performance test focused on memory allocations. It checks that `WriteString` on a `File` doesn't allocate memory for long strings.

* **`TestPipeIOCloseRace`, `TestPipeCloseRace`**: These test the safety of concurrent operations on pipes, specifically writing/reading while closing and closing concurrently. The platform skips reflect where pipes might behave differently.

* **`TestRandomLen`**: This tests the length of the random suffixes generated by `MkdirTemp` and `CreateTemp`.

* **`TestCopyFS`**: This is a comprehensive test of the `CopyFS` function. It covers copying from both disk-based and in-memory file systems and verifies the content and permissions of the copied files. It also tests the error handling for existing files in the destination.

* **`TestCopyFSWithSymlinks`**: This tests how `CopyFS` handles symbolic links. The comments indicate that symlink support was incomplete at the time the code was written, and the test skips a portion because of that.

* **`TestAppendDoesntOverwrite`**: This verifies the correct behavior of `OpenFile` with `O_APPEND`, ensuring that writing appends to the file instead of overwriting it.

* **`TestRemoveReadOnlyFile`**: This confirms that `Remove` can successfully delete read-only files.

**4. Identifying Core Functionality and Grouping (for the final summary):**

After analyzing individual tests, I look for common themes and group them to provide a concise summary of the code's functionality. The key areas are:

* **File and Directory Operations:** Creating, opening, closing, reading, writing, deleting, and traversing files and directories.
* **Concurrency and Race Conditions:**  Testing the thread-safety of operations like `RemoveAll` and pipe operations.
* **Pipe Functionality:**  Testing the behavior of pipes, including reading, writing, and closing, especially under concurrent conditions.
* **User Directories:**  Testing functions related to getting user-specific directories (cache, config, home).
* **Filesystem Abstraction:**  Testing the `DirFS` functionality, which provides a way to interact with a directory as an `fs.FS`.
* **Copying Filesystems:** Testing the `CopyFS` function for copying directory structures.
* **Error Handling:**  Verifying correct error conditions, such as double-closing files.

**5. Inferring Go Language Features and Providing Examples:**

Based on the tested functions, I can deduce the Go language features being exercised:

* **File I/O:**  Using `os.Open`, `os.Create`, `os.OpenFile`, `os.Read`, `os.Write`, `os.ReadFile`, `os.WriteFile`, `os.WriteString`, `os.Close`.
* **Directory Operations:** Using `os.Mkdir`, `os.Remove`, `os.RemoveAll`, `os.Readdirnames`, `os.Stat`, `os.Chmod`, `os.Chtimes`.
* **Concurrency:** Using `go` routines and `sync.WaitGroup` for testing race conditions.
* **Pipes:** Using `os.Pipe` for inter-process communication (within the same process in this case).
* **Filesystem Interface:**  Demonstrating the use of `io/fs.FS` and the `os.DirFS` implementation.
* **Error Handling:** Using the `error` interface and checking for specific error types (`errors.Is`, type assertions).
* **Environment Variables:**  Accessing environment variables using `os.Getenv` (implicitly in the `UserCacheDir`/`UserConfigDir` tests).

For each feature, I try to provide a simple, illustrative Go code example.

**6. Considering Command-Line Arguments:**

In this particular code snippet, I don't see any explicit parsing of command-line arguments using the `flag` package. However, the environment variable handling in the `TestUserCacheDirXDGConfigDirEnvVar` and `TestUserConfigDirXDGConfigDirEnvVar` functions is related to how a user might configure the application's behavior externally.

**7. Identifying Potential Pitfalls:**

I look for common mistakes developers might make when using the tested functions:

* **Forgetting to close files:**  The `TestDoubleCloseError` implicitly highlights this.
* **Race conditions when deleting directories:** `TestRemoveAllRace` directly addresses this.
* **Incorrectly handling errors from file operations:** Not checking the returned `error` value.
* **Assuming consistent behavior across operating systems:** The numerous `runtime.GOOS` checks emphasize platform-specific behavior.

**8. Refining the Summary:**

Finally, I combine the grouped functionalities and the insights gained into a concise and informative summary, making sure to use clear and accurate language. The fact that the prompt explicitly asked for a summary of "its" function (referring to the code snippet) guided this final step.
这是 `go/src/os/os_test.go` 文件的一部分，主要集中在测试 `os` 包中关于文件和目录操作、进程间通信（管道）、用户目录以及文件系统抽象等功能的正确性和健壮性。由于这是第 3 部分，我们将重点归纳这部分代码的功能。

**这部分代码的主要功能归纳如下：**

1. **测试并发删除目录的安全性 (`TestRemoveAllRace`)**:
   -  模拟多协程同时删除同一个目录的情况，检验 `os.RemoveAll` 函数在并发场景下的行为是否安全，是否会产生未预期的错误。
   -  特意跳过了 Windows 平台，暗示在 Windows 上并发删除打开的目录可能存在与 Unix 系统不同的行为或问题。

2. **测试管道操作是否占用过多线程 (`TestPipeThreads`)**:
   -  创建大量管道并启动多个协程从管道读取数据，以此测试 Go 语言的调度器是否能高效地处理这种情况，避免创建过多的操作系统线程。
   -  针对不同的操作系统进行了跳过，表明管道的实现和行为可能存在平台差异。

3. **测试重复关闭文件或目录的错误处理 (`TestDoubleCloseError`)**:
   -  验证多次调用同一个已关闭的文件或目录的 `Close()` 方法是否会返回预期的 `os.ErrClosed` 错误。

4. **测试获取用户缓存目录的函数 (`TestUserCacheDir`, `TestUserCacheDirXDGConfigDirEnvVar`)**:
   -  检验 `os.UserCacheDir()` 函数是否能正确返回用户缓存目录的路径。
   -  同时测试了环境变量 `$XDG_CACHE_HOME` 对该函数的影响，尤其在 Unix 系统上。

5. **测试获取用户配置目录的函数 (`TestUserConfigDir`, `TestUserConfigDirXDGConfigDirEnvVar`)**:
   -  检验 `os.UserConfigDir()` 函数是否能正确返回用户配置目录的路径。
   -  同样测试了环境变量 `$XDG_CONFIG_HOME` 对该函数的影响，主要针对 Unix 系统。

6. **测试获取用户主目录的函数 (`TestUserHomeDir`)**:
   -  检验 `os.UserHomeDir()` 函数是否能正确返回用户主目录的路径。

7. **测试目录的 `Seek` 操作 (`TestDirSeek`)**:
   -  打开一个目录，读取其内容，然后使用 `Seek(0, 0)` 将读取位置重置到开头，再次读取内容，验证两次读取的结果是否一致，确保对目录的 `Seek` 操作是有效的。

8. **测试小步长 `Readdir` 后的 `Seek` 操作 (`TestReaddirSmallSeek`)**:
   -  打开一个目录，使用 `Readdirnames(1)` 读取一个条目，然后 `Seek` 到开头，再次读取所有条目，确保不会出现重复读取的情况。

9. **测试 `OpenFile` 是否保持文件权限 (`TestOpenFileKeepsPermissions`)**:
   -  创建一个文件，然后使用 `OpenFile` 以不同的模式打开，验证文件的权限是否保持不变，不会因为打开操作而意外修改。

10. **测试 `DirFS` 功能 (`TestDirFS`, `TestRootDirFS`, `TestDirFSRootDir`, `TestDirFSEmptyDir`, `TestDirFSPathsValid`)**:
    -  检验 `os.DirFS` 函数创建的只读文件系统视图的行为，包括打开文件、读取目录、处理不存在的文件和目录、处理路径分隔符等。

11. **测试 `ReadFile` 读取 `/proc` 文件 (`TestReadFileProc`, `TestDirFSReadFileProc`)**:
    -  针对 Linux 系统下的 `/proc` 文件，测试 `os.ReadFile` 和 `fs.ReadFile` 是否能正确读取这类特殊文件。

12. **测试 `WriteString` 的内存分配 (`TestWriteStringAlloc`)**:
    -  通过性能测试，检查 `(*os.File).WriteString` 方法在写入较长字符串时是否会产生不必要的内存分配。

13. **测试管道的并发 I/O 和 `Close` 操作 (`TestPipeIOCloseRace`)**:
    -  创建管道，并使用多个协程并发地进行读写操作，同时另一个协程关闭管道，验证在这种并发场景下管道操作的安全性。

14. **测试管道的并发 `Close` 操作 (`TestPipeCloseRace`)**:
    -  创建管道，并使用多个协程并发地调用管道的 `Close` 方法，验证并发关闭操作的安全性。

15. **测试临时文件和目录名的随机性 (`TestRandomLen`)**:
    -  多次创建临时文件和目录，检查其名称的随机部分长度是否符合预期。

16. **测试 `CopyFS` 函数 (`TestCopyFS`, `TestCopyFSWithSymlinks`)**:
    -  检验 `os.CopyFS` 函数能否正确地将一个文件系统复制到另一个位置。
    -  包括从磁盘文件系统和内存文件系统复制。
    -  验证复制后的文件内容和权限是否与源文件系统一致。
    -  特别地，`TestCopyFSWithSymlinks` 关注符号链接的处理，但代码注释表明当时符号链接的支持可能不完善。

17. **测试以 `O_APPEND` 模式打开文件是否会覆盖内容 (`TestAppendDoesntOverwrite`)**:
    -  验证使用 `os.OpenFile` 以追加模式打开文件时，写入的内容会被添加到文件末尾，而不会覆盖原有内容。

18. **测试删除只读文件 (`TestRemoveReadOnlyFile`)**:
    -  创建一个只读文件，然后尝试删除它，验证 `os.Remove` 函数是否能够成功删除只读文件。

**总结来说，这部分代码针对 `os` 包的多个核心功能进行了细致的测试，涵盖了文件和目录的各种操作，并发安全性，管道通信，用户目录管理以及文件系统抽象等多个方面。 通过这些测试，可以确保 `os` 包在不同操作系统下的行为符合预期，并且在高并发场景下也能稳定运行。**

Prompt: 
```
这是路径为go/src/os/os_test.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
请用中文回答。
这是第3部分，共3部分，请归纳一下它的功能

"""
 removing directories while someone else has
		// them open. The racing doesn't work out nicely
		// like it does on Unix.
		t.Skip("skipping on windows")
	}
	if runtime.GOOS == "dragonfly" {
		testenv.SkipFlaky(t, 52301)
	}

	n := runtime.GOMAXPROCS(16)
	defer runtime.GOMAXPROCS(n)
	root := t.TempDir()
	mkdirTree(t, root, 1, 6)
	hold := make(chan struct{})
	var wg sync.WaitGroup
	for i := 0; i < 4; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			<-hold
			err := RemoveAll(root)
			if err != nil {
				t.Errorf("unexpected error: %T, %q", err, err)
			}
		}()
	}
	close(hold) // let workers race to remove root
	wg.Wait()
}

// Test that reading from a pipe doesn't use up a thread.
func TestPipeThreads(t *testing.T) {
	switch runtime.GOOS {
	case "aix":
		t.Skip("skipping on aix; issue 70131")
	case "illumos", "solaris":
		t.Skip("skipping on Solaris and illumos; issue 19111")
	case "windows":
		t.Skip("skipping on Windows; issue 19098")
	case "plan9":
		t.Skip("skipping on Plan 9; does not support runtime poller")
	case "js":
		t.Skip("skipping on js; no support for os.Pipe")
	case "wasip1":
		t.Skip("skipping on wasip1; no support for os.Pipe")
	}

	threads := 100

	r := make([]*File, threads)
	w := make([]*File, threads)
	for i := 0; i < threads; i++ {
		rp, wp, err := Pipe()
		if err != nil {
			for j := 0; j < i; j++ {
				r[j].Close()
				w[j].Close()
			}
			t.Fatal(err)
		}
		r[i] = rp
		w[i] = wp
	}

	defer debug.SetMaxThreads(debug.SetMaxThreads(threads / 2))

	creading := make(chan bool, threads)
	cdone := make(chan bool, threads)
	for i := 0; i < threads; i++ {
		go func(i int) {
			var b [1]byte
			creading <- true
			if _, err := r[i].Read(b[:]); err != nil {
				t.Error(err)
			}
			if err := r[i].Close(); err != nil {
				t.Error(err)
			}
			cdone <- true
		}(i)
	}

	for i := 0; i < threads; i++ {
		<-creading
	}

	// If we are still alive, it means that the 100 goroutines did
	// not require 100 threads.

	for i := 0; i < threads; i++ {
		if _, err := w[i].Write([]byte{0}); err != nil {
			t.Error(err)
		}
		if err := w[i].Close(); err != nil {
			t.Error(err)
		}
		<-cdone
	}
}

func testDoubleCloseError(path string) func(*testing.T) {
	return func(t *testing.T) {
		t.Parallel()

		file, err := Open(path)
		if err != nil {
			t.Fatal(err)
		}
		if err := file.Close(); err != nil {
			t.Fatalf("unexpected error from Close: %v", err)
		}
		if err := file.Close(); err == nil {
			t.Error("second Close did not fail")
		} else if pe, ok := err.(*PathError); !ok {
			t.Errorf("second Close: got %T, want %T", err, pe)
		} else if pe.Err != ErrClosed {
			t.Errorf("second Close: got %q, want %q", pe.Err, ErrClosed)
		} else {
			t.Logf("second close returned expected error %q", err)
		}
	}
}

func TestDoubleCloseError(t *testing.T) {
	t.Parallel()
	t.Run("file", testDoubleCloseError(filepath.Join(sfdir, sfname)))
	t.Run("dir", testDoubleCloseError(sfdir))
}

func TestUserCacheDir(t *testing.T) {
	t.Parallel()

	dir, err := UserCacheDir()
	if err != nil {
		t.Skipf("skipping: %v", err)
	}
	if dir == "" {
		t.Fatalf("UserCacheDir returned %q; want non-empty path or error", dir)
	}

	fi, err := Stat(dir)
	if err != nil {
		if IsNotExist(err) {
			t.Log(err)
			return
		}
		t.Fatal(err)
	}
	if !fi.IsDir() {
		t.Fatalf("dir %s is not directory; type = %v", dir, fi.Mode())
	}
}

func TestUserCacheDirXDGConfigDirEnvVar(t *testing.T) {
	switch runtime.GOOS {
	case "windows", "darwin", "plan9":
		t.Skip("$XDG_CACHE_HOME is effective only on Unix systems")
	}

	wd, err := Getwd()
	if err != nil {
		t.Fatal(err)
	}
	t.Setenv("XDG_CACHE_HOME", wd)

	dir, err := UserCacheDir()
	if err != nil {
		t.Fatal(err)
	}
	if dir != wd {
		t.Fatalf("UserCacheDir returned %q; want the value of $XDG_CACHE_HOME %q", dir, wd)
	}

	t.Setenv("XDG_CACHE_HOME", "some-dir")
	_, err = UserCacheDir()
	if err == nil {
		t.Fatal("UserCacheDir succeeded though $XDG_CACHE_HOME contains a relative path")
	}
}

func TestUserConfigDir(t *testing.T) {
	t.Parallel()

	dir, err := UserConfigDir()
	if err != nil {
		t.Skipf("skipping: %v", err)
	}
	if dir == "" {
		t.Fatalf("UserConfigDir returned %q; want non-empty path or error", dir)
	}

	fi, err := Stat(dir)
	if err != nil {
		if IsNotExist(err) {
			t.Log(err)
			return
		}
		t.Fatal(err)
	}
	if !fi.IsDir() {
		t.Fatalf("dir %s is not directory; type = %v", dir, fi.Mode())
	}
}

func TestUserConfigDirXDGConfigDirEnvVar(t *testing.T) {
	switch runtime.GOOS {
	case "windows", "darwin", "plan9":
		t.Skip("$XDG_CONFIG_HOME is effective only on Unix systems")
	}

	wd, err := Getwd()
	if err != nil {
		t.Fatal(err)
	}
	t.Setenv("XDG_CONFIG_HOME", wd)

	dir, err := UserConfigDir()
	if err != nil {
		t.Fatal(err)
	}
	if dir != wd {
		t.Fatalf("UserConfigDir returned %q; want the value of $XDG_CONFIG_HOME %q", dir, wd)
	}

	t.Setenv("XDG_CONFIG_HOME", "some-dir")
	_, err = UserConfigDir()
	if err == nil {
		t.Fatal("UserConfigDir succeeded though $XDG_CONFIG_HOME contains a relative path")
	}
}

func TestUserHomeDir(t *testing.T) {
	t.Parallel()

	dir, err := UserHomeDir()
	if dir == "" && err == nil {
		t.Fatal("UserHomeDir returned an empty string but no error")
	}
	if err != nil {
		// UserHomeDir may return a non-nil error if the environment variable
		// for the home directory is empty or unset in the environment.
		t.Skipf("skipping: %v", err)
	}

	fi, err := Stat(dir)
	if err != nil {
		if IsNotExist(err) {
			// The user's home directory has a well-defined location, but does not
			// exist. (Maybe nothing has written to it yet? That could happen, for
			// example, on minimal VM images used for CI testing.)
			t.Log(err)
			return
		}
		t.Fatal(err)
	}
	if !fi.IsDir() {
		t.Fatalf("dir %s is not directory; type = %v", dir, fi.Mode())
	}
}

func TestDirSeek(t *testing.T) {
	t.Parallel()

	wd, err := Getwd()
	if err != nil {
		t.Fatal(err)
	}
	f, err := Open(wd)
	if err != nil {
		t.Fatal(err)
	}
	dirnames1, err := f.Readdirnames(0)
	if err != nil {
		t.Fatal(err)
	}

	ret, err := f.Seek(0, 0)
	if err != nil {
		t.Fatal(err)
	}
	if ret != 0 {
		t.Fatalf("seek result not zero: %d", ret)
	}

	dirnames2, err := f.Readdirnames(0)
	if err != nil {
		t.Fatal(err)
	}

	if len(dirnames1) != len(dirnames2) {
		t.Fatalf("listings have different lengths: %d and %d\n", len(dirnames1), len(dirnames2))
	}
	for i, n1 := range dirnames1 {
		n2 := dirnames2[i]
		if n1 != n2 {
			t.Fatalf("different name i=%d n1=%s n2=%s\n", i, n1, n2)
		}
	}
}

func TestReaddirSmallSeek(t *testing.T) {
	// See issue 37161. Read only one entry from a directory,
	// seek to the beginning, and read again. We should not see
	// duplicate entries.
	t.Parallel()

	wd, err := Getwd()
	if err != nil {
		t.Fatal(err)
	}
	df, err := Open(filepath.Join(wd, "testdata", "issue37161"))
	if err != nil {
		t.Fatal(err)
	}
	names1, err := df.Readdirnames(1)
	if err != nil {
		t.Fatal(err)
	}
	if _, err = df.Seek(0, 0); err != nil {
		t.Fatal(err)
	}
	names2, err := df.Readdirnames(0)
	if err != nil {
		t.Fatal(err)
	}
	if len(names2) != 3 {
		t.Fatalf("first names: %v, second names: %v", names1, names2)
	}
}

// isDeadlineExceeded reports whether err is or wraps ErrDeadlineExceeded.
// We also check that the error has a Timeout method that returns true.
func isDeadlineExceeded(err error) bool {
	if !IsTimeout(err) {
		return false
	}
	if !errors.Is(err, ErrDeadlineExceeded) {
		return false
	}
	return true
}

// Test that opening a file does not change its permissions.  Issue 38225.
func TestOpenFileKeepsPermissions(t *testing.T) {
	t.Run("OpenFile", func(t *testing.T) {
		testOpenFileKeepsPermissions(t, OpenFile)
	})
	t.Run("RootOpenFile", func(t *testing.T) {
		testOpenFileKeepsPermissions(t, func(name string, flag int, perm FileMode) (*File, error) {
			dir, file := filepath.Split(name)
			r, err := OpenRoot(dir)
			if err != nil {
				return nil, err
			}
			defer r.Close()
			return r.OpenFile(file, flag, perm)
		})
	})
}
func testOpenFileKeepsPermissions(t *testing.T, openf func(name string, flag int, perm FileMode) (*File, error)) {
	t.Parallel()

	dir := t.TempDir()
	name := filepath.Join(dir, "x")
	f, err := Create(name)
	if err != nil {
		t.Fatal(err)
	}
	if err := f.Close(); err != nil {
		t.Error(err)
	}
	f, err = openf(name, O_WRONLY|O_CREATE|O_TRUNC, 0)
	if err != nil {
		t.Fatal(err)
	}
	if fi, err := f.Stat(); err != nil {
		t.Error(err)
	} else if fi.Mode()&0222 == 0 {
		t.Errorf("f.Stat.Mode after OpenFile is %v, should be writable", fi.Mode())
	}
	if err := f.Close(); err != nil {
		t.Error(err)
	}
	if fi, err := Stat(name); err != nil {
		t.Error(err)
	} else if fi.Mode()&0222 == 0 {
		t.Errorf("Stat after OpenFile is %v, should be writable", fi.Mode())
	}
}

func forceMFTUpdateOnWindows(t *testing.T, path string) {
	t.Helper()

	if runtime.GOOS != "windows" {
		return
	}

	// On Windows, we force the MFT to update by reading the actual metadata from GetFileInformationByHandle and then
	// explicitly setting that. Otherwise it might get out of sync with FindFirstFile. See golang.org/issues/42637.
	if err := filepath.WalkDir(path, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			t.Fatal(err)
		}
		info, err := d.Info()
		if err != nil {
			t.Fatal(err)
		}
		stat, err := Stat(path) // This uses GetFileInformationByHandle internally.
		if err != nil {
			t.Fatal(err)
		}
		if stat.ModTime() == info.ModTime() {
			return nil
		}
		if err := Chtimes(path, stat.ModTime(), stat.ModTime()); err != nil {
			t.Log(err) // We only log, not die, in case the test directory is not writable.
		}
		return nil
	}); err != nil {
		t.Fatal(err)
	}
}

func TestDirFS(t *testing.T) {
	t.Parallel()
	testDirFS(t, DirFS("./testdata/dirfs"))
}

func TestRootDirFS(t *testing.T) {
	t.Parallel()
	r, err := OpenRoot("./testdata/dirfs")
	if err != nil {
		t.Fatal(err)
	}
	testDirFS(t, r.FS())
}

func testDirFS(t *testing.T, fsys fs.FS) {
	forceMFTUpdateOnWindows(t, "./testdata/dirfs")

	if err := fstest.TestFS(fsys, "a", "b", "dir/x"); err != nil {
		t.Fatal(err)
	}

	rdfs, ok := fsys.(fs.ReadDirFS)
	if !ok {
		t.Error("expected DirFS result to implement fs.ReadDirFS")
	}
	if _, err := rdfs.ReadDir("nonexistent"); err == nil {
		t.Error("fs.ReadDir of nonexistent directory succeeded")
	}

	// Test that the error message does not contain a backslash,
	// and does not contain the DirFS argument.
	const nonesuch = "dir/nonesuch"
	_, err := fsys.Open(nonesuch)
	if err == nil {
		t.Error("fs.Open of nonexistent file succeeded")
	} else {
		if !strings.Contains(err.Error(), nonesuch) {
			t.Errorf("error %q does not contain %q", err, nonesuch)
		}
		if strings.Contains(err.(*PathError).Path, "testdata") {
			t.Errorf("error %q contains %q", err, "testdata")
		}
	}

	// Test that Open does not accept backslash as separator.
	d := DirFS(".")
	_, err = d.Open(`testdata\dirfs`)
	if err == nil {
		t.Fatalf(`Open testdata\dirfs succeeded`)
	}

	// Test that Open does not open Windows device files.
	_, err = d.Open(`NUL`)
	if err == nil {
		t.Errorf(`Open NUL succeeded`)
	}
}

func TestDirFSRootDir(t *testing.T) {
	t.Parallel()

	cwd, err := Getwd()
	if err != nil {
		t.Fatal(err)
	}
	cwd = cwd[len(filepath.VolumeName(cwd)):] // trim volume prefix (C:) on Windows
	cwd = filepath.ToSlash(cwd)               // convert \ to /
	cwd = strings.TrimPrefix(cwd, "/")        // trim leading /

	// Test that Open can open a path starting at /.
	d := DirFS("/")
	f, err := d.Open(cwd + "/testdata/dirfs/a")
	if err != nil {
		t.Fatal(err)
	}
	f.Close()
}

func TestDirFSEmptyDir(t *testing.T) {
	t.Parallel()

	d := DirFS("")
	cwd, _ := Getwd()
	for _, path := range []string{
		"testdata/dirfs/a",                          // not DirFS(".")
		filepath.ToSlash(cwd) + "/testdata/dirfs/a", // not DirFS("/")
	} {
		_, err := d.Open(path)
		if err == nil {
			t.Fatalf(`DirFS("").Open(%q) succeeded`, path)
		}
	}
}

func TestDirFSPathsValid(t *testing.T) {
	if runtime.GOOS == "windows" {
		t.Skipf("skipping on Windows")
	}
	t.Parallel()

	d := t.TempDir()
	if err := WriteFile(filepath.Join(d, "control.txt"), []byte(string("Hello, world!")), 0644); err != nil {
		t.Fatal(err)
	}
	if err := WriteFile(filepath.Join(d, `e:xperi\ment.txt`), []byte(string("Hello, colon and backslash!")), 0644); err != nil {
		t.Fatal(err)
	}

	fsys := DirFS(d)
	err := fs.WalkDir(fsys, ".", func(path string, e fs.DirEntry, err error) error {
		if fs.ValidPath(e.Name()) {
			t.Logf("%q ok", e.Name())
		} else {
			t.Errorf("%q INVALID", e.Name())
		}
		return nil
	})
	if err != nil {
		t.Fatal(err)
	}
}

func TestReadFileProc(t *testing.T) {
	t.Parallel()

	// Linux files in /proc report 0 size,
	// but then if ReadFile reads just a single byte at offset 0,
	// the read at offset 1 returns EOF instead of more data.
	// ReadFile has a minimum read size of 512 to work around this,
	// but test explicitly that it's working.
	name := "/proc/sys/fs/pipe-max-size"
	if _, err := Stat(name); err != nil {
		t.Skip(err)
	}
	data, err := ReadFile(name)
	if err != nil {
		t.Fatal(err)
	}
	if len(data) == 0 || data[len(data)-1] != '\n' {
		t.Fatalf("read %s: not newline-terminated: %q", name, data)
	}
}

func TestDirFSReadFileProc(t *testing.T) {
	t.Parallel()

	fsys := DirFS("/")
	name := "proc/sys/fs/pipe-max-size"
	if _, err := fs.Stat(fsys, name); err != nil {
		t.Skip()
	}
	data, err := fs.ReadFile(fsys, name)
	if err != nil {
		t.Fatal(err)
	}
	if len(data) == 0 || data[len(data)-1] != '\n' {
		t.Fatalf("read %s: not newline-terminated: %q", name, data)
	}
}

func TestWriteStringAlloc(t *testing.T) {
	if runtime.GOOS == "js" {
		t.Skip("js allocates a lot during File.WriteString")
	}
	d := t.TempDir()
	f, err := Create(filepath.Join(d, "whiteboard.txt"))
	if err != nil {
		t.Fatal(err)
	}
	defer f.Close()
	allocs := testing.AllocsPerRun(100, func() {
		f.WriteString("I will not allocate when passed a string longer than 32 bytes.\n")
	})
	if allocs != 0 {
		t.Errorf("expected 0 allocs for File.WriteString, got %v", allocs)
	}
}

// Test that it's OK to have parallel I/O and Close on a pipe.
func TestPipeIOCloseRace(t *testing.T) {
	// Skip on wasm, which doesn't have pipes.
	if runtime.GOOS == "js" || runtime.GOOS == "wasip1" {
		t.Skipf("skipping on %s: no pipes", runtime.GOOS)
	}
	t.Parallel()

	r, w, err := Pipe()
	if err != nil {
		t.Fatal(err)
	}

	var wg sync.WaitGroup
	wg.Add(3)

	go func() {
		defer wg.Done()
		for {
			n, err := w.Write([]byte("hi"))
			if err != nil {
				// We look at error strings as the
				// expected errors are OS-specific.
				switch {
				case errors.Is(err, ErrClosed),
					strings.Contains(err.Error(), "broken pipe"),
					strings.Contains(err.Error(), "pipe is being closed"),
					strings.Contains(err.Error(), "hungup channel"):
					// Ignore an expected error.
				default:
					// Unexpected error.
					t.Error(err)
				}
				return
			}
			if n != 2 {
				t.Errorf("wrote %d bytes, expected 2", n)
				return
			}
		}
	}()

	go func() {
		defer wg.Done()
		for {
			var buf [2]byte
			n, err := r.Read(buf[:])
			if err != nil {
				if err != io.EOF && !errors.Is(err, ErrClosed) {
					t.Error(err)
				}
				return
			}
			if n != 2 {
				t.Errorf("read %d bytes, want 2", n)
			}
		}
	}()

	go func() {
		defer wg.Done()

		// Let the other goroutines start. This is just to get
		// a better test, the test will still pass if they
		// don't start.
		time.Sleep(time.Millisecond)

		if err := r.Close(); err != nil {
			t.Error(err)
		}
		if err := w.Close(); err != nil {
			t.Error(err)
		}
	}()

	wg.Wait()
}

// Test that it's OK to call Close concurrently on a pipe.
func TestPipeCloseRace(t *testing.T) {
	// Skip on wasm, which doesn't have pipes.
	if runtime.GOOS == "js" || runtime.GOOS == "wasip1" {
		t.Skipf("skipping on %s: no pipes", runtime.GOOS)
	}
	t.Parallel()

	r, w, err := Pipe()
	if err != nil {
		t.Fatal(err)
	}
	var wg sync.WaitGroup
	c := make(chan error, 4)
	f := func() {
		defer wg.Done()
		c <- r.Close()
		c <- w.Close()
	}
	wg.Add(2)
	go f()
	go f()
	nils, errs := 0, 0
	for i := 0; i < 4; i++ {
		err := <-c
		if err == nil {
			nils++
		} else {
			errs++
		}
	}
	if nils != 2 || errs != 2 {
		t.Errorf("got nils %d errs %d, want 2 2", nils, errs)
	}
}

func TestRandomLen(t *testing.T) {
	for range 5 {
		dir, err := MkdirTemp(t.TempDir(), "*")
		if err != nil {
			t.Fatal(err)
		}
		base := filepath.Base(dir)
		if len(base) > 10 {
			t.Errorf("MkdirTemp returned len %d: %s", len(base), base)
		}
	}
	for range 5 {
		f, err := CreateTemp(t.TempDir(), "*")
		if err != nil {
			t.Fatal(err)
		}
		base := filepath.Base(f.Name())
		f.Close()
		if len(base) > 10 {
			t.Errorf("CreateTemp returned len %d: %s", len(base), base)
		}
	}
}

func TestCopyFS(t *testing.T) {
	t.Parallel()

	// Test with disk filesystem.
	forceMFTUpdateOnWindows(t, "./testdata/dirfs")
	fsys := DirFS("./testdata/dirfs")
	tmpDir := t.TempDir()
	if err := CopyFS(tmpDir, fsys); err != nil {
		t.Fatal("CopyFS:", err)
	}
	forceMFTUpdateOnWindows(t, tmpDir)
	tmpFsys := DirFS(tmpDir)
	if err := fstest.TestFS(tmpFsys, "a", "b", "dir/x"); err != nil {
		t.Fatal("TestFS:", err)
	}
	if err := verifyCopyFS(t, fsys, tmpFsys); err != nil {
		t.Fatal("comparing two directories:", err)
	}

	// Test whether CopyFS disallows copying for disk filesystem when there is any
	// existing file in the destination directory.
	if err := CopyFS(tmpDir, fsys); !errors.Is(err, fs.ErrExist) {
		t.Errorf("CopyFS should have failed and returned error when there is"+
			"any existing file in the destination directory (in disk filesystem), "+
			"got: %v, expected any error that indicates <file exists>", err)
	}

	// Test with memory filesystem.
	fsys = fstest.MapFS{
		"william":    {Data: []byte("Shakespeare\n")},
		"carl":       {Data: []byte("Gauss\n")},
		"daVinci":    {Data: []byte("Leonardo\n")},
		"einstein":   {Data: []byte("Albert\n")},
		"dir/newton": {Data: []byte("Sir Isaac\n")},
	}
	tmpDir = t.TempDir()
	if err := CopyFS(tmpDir, fsys); err != nil {
		t.Fatal("CopyFS:", err)
	}
	forceMFTUpdateOnWindows(t, tmpDir)
	tmpFsys = DirFS(tmpDir)
	if err := fstest.TestFS(tmpFsys, "william", "carl", "daVinci", "einstein", "dir/newton"); err != nil {
		t.Fatal("TestFS:", err)
	}
	if err := verifyCopyFS(t, fsys, tmpFsys); err != nil {
		t.Fatal("comparing two directories:", err)
	}

	// Test whether CopyFS disallows copying for memory filesystem when there is any
	// existing file in the destination directory.
	if err := CopyFS(tmpDir, fsys); !errors.Is(err, fs.ErrExist) {
		t.Errorf("CopyFS should have failed and returned error when there is"+
			"any existing file in the destination directory (in memory filesystem), "+
			"got: %v, expected any error that indicates <file exists>", err)
	}
}

// verifyCopyFS checks the content and permission of each file inside copied FS to ensure
// the copied files satisfy the convention stipulated in CopyFS.
func verifyCopyFS(t *testing.T, originFS, copiedFS fs.FS) error {
	testDir := filepath.Join(t.TempDir(), "test")
	// umask doesn't apply to the wasip and windows and there is no general way to get masked perm,
	// so create a dir and a file to compare the permission after umask if any
	if err := Mkdir(testDir, ModePerm); err != nil {
		return fmt.Errorf("mkdir %q failed: %v", testDir, err)
	}
	dirStat, err := Stat(testDir)
	if err != nil {
		return fmt.Errorf("stat dir %q failed: %v", testDir, err)
	}
	wantDirMode := dirStat.Mode()

	f, err := Create(filepath.Join(testDir, "tmp"))
	if err != nil {
		return fmt.Errorf("open %q failed: %v", filepath.Join(testDir, "tmp"), err)
	}
	defer f.Close()
	wantFileRWStat, err := f.Stat()
	if err != nil {
		return fmt.Errorf("stat file %q failed: %v", f.Name(), err)
	}
	wantFileRWMode := wantFileRWStat.Mode()

	return fs.WalkDir(originFS, ".", func(path string, d fs.DirEntry, err error) error {
		if d.IsDir() {
			// the dir . is not the dir created by CopyFS so skip checking its permission
			if d.Name() == "." {
				return nil
			}

			dinfo, err := fs.Stat(copiedFS, path)
			if err != nil {
				return err
			}

			if dinfo.Mode() != wantDirMode {
				return fmt.Errorf("dir %q mode is %v, want %v",
					d.Name(), dinfo.Mode(), wantDirMode)
			}
			return nil
		}

		fInfo, err := originFS.Open(path)
		if err != nil {
			return err
		}
		defer fInfo.Close()
		copiedInfo, err := copiedFS.Open(path)
		if err != nil {
			return err
		}
		defer copiedInfo.Close()

		// verify the file contents are the same
		data, err := io.ReadAll(fInfo)
		if err != nil {
			return err
		}
		newData, err := io.ReadAll(copiedInfo)
		if err != nil {
			return err
		}
		if !bytes.Equal(data, newData) {
			return fmt.Errorf("file %q content is %s, want %s", path, newData, data)
		}

		fStat, err := fInfo.Stat()
		if err != nil {
			return err
		}
		copiedStat, err := copiedInfo.Stat()
		if err != nil {
			return err
		}

		// check whether the execute permission is inherited from original FS

		if copiedStat.Mode()&0111&wantFileRWMode != fStat.Mode()&0111&wantFileRWMode {
			return fmt.Errorf("file %q execute mode is %v, want %v",
				path, copiedStat.Mode()&0111, fStat.Mode()&0111)
		}

		rwMode := copiedStat.Mode() &^ 0111 // unset the executable permission from file mode
		if rwMode != wantFileRWMode {
			return fmt.Errorf("file %q rw mode is %v, want %v",
				path, rwMode, wantFileRWStat.Mode())
		}
		return nil
	})
}

func TestCopyFSWithSymlinks(t *testing.T) {
	// Test it with absolute and relative symlinks that point inside and outside the tree.
	testenv.MustHaveSymlink(t)

	// Create a directory and file outside.
	tmpDir := t.TempDir()
	outsideDir := filepath.Join(tmpDir, "copyfs_out")
	if err := Mkdir(outsideDir, 0755); err != nil {
		t.Fatalf("Mkdir: %v", err)
	}
	outsideFile := filepath.Join(outsideDir, "file.out.txt")

	if err := WriteFile(outsideFile, []byte("Testing CopyFS outside"), 0644); err != nil {
		t.Fatalf("WriteFile: %v", err)
	}

	// Create a directory and file inside.
	insideDir := filepath.Join(tmpDir, "copyfs_in")
	if err := Mkdir(insideDir, 0755); err != nil {
		t.Fatalf("Mkdir: %v", err)
	}
	insideFile := filepath.Join(insideDir, "file.in.txt")
	if err := WriteFile(insideFile, []byte("Testing CopyFS inside"), 0644); err != nil {
		t.Fatalf("WriteFile: %v", err)
	}

	// Create directories for symlinks.
	linkInDir := filepath.Join(insideDir, "in_symlinks")
	if err := Mkdir(linkInDir, 0755); err != nil {
		t.Fatalf("Mkdir: %v", err)
	}
	linkOutDir := filepath.Join(insideDir, "out_symlinks")
	if err := Mkdir(linkOutDir, 0755); err != nil {
		t.Fatalf("Mkdir: %v", err)
	}

	// First, we create the absolute symlink pointing outside.
	outLinkFile := filepath.Join(linkOutDir, "file.abs.out.link")
	if err := Symlink(outsideFile, outLinkFile); err != nil {
		t.Fatalf("Symlink: %v", err)
	}

	// Then, we create the relative symlink pointing outside.
	relOutsideFile, err := filepath.Rel(filepath.Join(linkOutDir, "."), outsideFile)
	if err != nil {
		t.Fatalf("filepath.Rel: %v", err)
	}
	relOutLinkFile := filepath.Join(linkOutDir, "file.rel.out.link")
	if err := Symlink(relOutsideFile, relOutLinkFile); err != nil {
		t.Fatalf("Symlink: %v", err)
	}

	// Last, we create the relative symlink pointing inside.
	relInsideFile, err := filepath.Rel(filepath.Join(linkInDir, "."), insideFile)
	if err != nil {
		t.Fatalf("filepath.Rel: %v", err)
	}
	relInLinkFile := filepath.Join(linkInDir, "file.rel.in.link")
	if err := Symlink(relInsideFile, relInLinkFile); err != nil {
		t.Fatalf("Symlink: %v", err)
	}

	// Copy the directory tree and verify.
	forceMFTUpdateOnWindows(t, insideDir)
	fsys := DirFS(insideDir)
	tmpDupDir := filepath.Join(tmpDir, "copyfs_dup")
	if err := Mkdir(tmpDupDir, 0755); err != nil {
		t.Fatalf("Mkdir: %v", err)
	}

	// TODO(panjf2000): symlinks are currently not supported, and a specific error
	// 			will be returned. Verify that error and skip the subsequent test,
	//			revisit this once #49580 is closed.
	if err := CopyFS(tmpDupDir, fsys); !errors.Is(err, ErrInvalid) {
		t.Fatalf("got %v, want ErrInvalid", err)
	}
	t.Skip("skip the subsequent test and wait for #49580")

	forceMFTUpdateOnWindows(t, tmpDupDir)
	tmpFsys := DirFS(tmpDupDir)
	if err := fstest.TestFS(tmpFsys, "file.in.txt", "out_symlinks/file.abs.out.link", "out_symlinks/file.rel.out.link", "in_symlinks/file.rel.in.link"); err != nil {
		t.Fatal("TestFS:", err)
	}
	if err := fs.WalkDir(fsys, ".", func(path string, d fs.DirEntry, err error) error {
		if d.IsDir() {
			return nil
		}

		fi, err := d.Info()
		if err != nil {
			return err
		}
		if filepath.Ext(path) == ".link" {
			if fi.Mode()&ModeSymlink == 0 {
				return errors.New("original file " + path + " should be a symlink")
			}
			tmpfi, err := fs.Stat(tmpFsys, path)
			if err != nil {
				return err
			}
			if tmpfi.Mode()&ModeSymlink != 0 {
				return errors.New("copied file " + path + " should not be a symlink")
			}
		}

		data, err := fs.ReadFile(fsys, path)
		if err != nil {
			return err
		}
		newData, err := fs.ReadFile(tmpFsys, path)
		if err != nil {
			return err
		}
		if !bytes.Equal(data, newData) {
			return errors.New("file " + path + " contents differ")
		}

		var target string
		switch fileName := filepath.Base(path); fileName {
		case "file.abs.out.link", "file.rel.out.link":
			target = outsideFile
		case "file.rel.in.link":
			target = insideFile
		}
		if len(target) > 0 {
			targetData, err := ReadFile(target)
			if err != nil {
				return err
			}
			if !bytes.Equal(targetData, newData) {
				return errors.New("file " + path + " contents differ from target")
			}
		}

		return nil
	}); err != nil {
		t.Fatal("comparing two directories:", err)
	}
}

func TestAppendDoesntOverwrite(t *testing.T) {
	testMaybeRooted(t, func(t *testing.T, r *Root) {
		name := "file"
		if err := WriteFile(name, []byte("hello"), 0666); err != nil {
			t.Fatal(err)
		}
		var f *File
		var err error
		if r == nil {
			f, err = OpenFile(name, O_APPEND|O_WRONLY, 0)
		} else {
			f, err = r.OpenFile(name, O_APPEND|O_WRONLY, 0)
		}
		if err != nil {
			t.Fatal(err)
		}
		if _, err := f.Write([]byte(" world")); err != nil {
			f.Close()
			t.Fatal(err)
		}
		if err := f.Close(); err != nil {
			t.Fatal(err)
		}
		got, err := ReadFile(name)
		if err != nil {
			t.Fatal(err)
		}
		want := "hello world"
		if string(got) != want {
			t.Fatalf("got %q, want %q", got, want)
		}
	})
}

func TestRemoveReadOnlyFile(t *testing.T) {
	testMaybeRooted(t, func(t *testing.T, r *Root) {
		if err := WriteFile("file", []byte("1"), 0); err != nil {
			t.Fatal(err)
		}
		var err error
		if r == nil {
			err = Remove("file")
		} else {
			err = r.Remove("file")
		}
		if err != nil {
			t.Fatalf("Remove read-only file: %v", err)
		}
		if _, err := Stat("file"); !IsNotExist(err) {
			t.Fatalf("Stat read-only file after removal: %v (want IsNotExist)", err)
		}
	})
}

"""




```
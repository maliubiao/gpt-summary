Response:
Let's break down the thought process for answering the request about `go/src/runtime/lockrank.go`.

**1. Understanding the Core Request:**

The fundamental question is: "What does this code do?"  The prompt specifically asks about its *functionality*, hinting at its purpose within the larger Go runtime.

**2. Initial Analysis of the Code:**

* **`// Code generated by mklockrank.go; DO NOT EDIT.`**: This immediately tells me that this file is not manually written but automatically generated. This is a crucial clue. The generator likely takes some higher-level description of lock dependencies and produces this structured data.
* **`package runtime`**:  This places the code firmly within the core Go runtime. It's dealing with fundamental aspects of how the language operates.
* **`type lockRank int`**: Defines an integer type representing a lock's rank.
* **`const (...)`**:  A series of constants starting with `lockRank...`. These look like enumerations of different runtime locks. The comments `// SCHED`, `// TRACEGLOBAL`, `// MALLOC`, etc., suggest groupings of related locks.
* **`lockRankLeafRank`**: A special constant indicating a lock with no declared rank. The comment "leaf lock" is important.
* **`var lockNames = []string{...}`**: An array mapping the `lockRank` constants to human-readable strings. This is for debugging and potentially visualization.
* **`func (rank lockRank) String() string { ... }`**: A standard `String()` method to get the name of a lock rank.
* **`var lockPartialOrder [][]lockRank = [][]lockRank{...}`**: A 2D slice of `lockRank`. The comment is key: "the transitive closure of the lock rank graph."  This strongly suggests that this data structure represents dependencies between locks. The comment "An entry for rank X lists all of the ranks that can already be held when rank X is acquired" is the most important piece of information for understanding its purpose.

**3. Forming Hypotheses about Functionality:**

Based on the code structure and comments, I can formulate a primary hypothesis:

* **Hypothesis:** This code implements a *lock ranking system* to prevent deadlocks in the Go runtime. The `lockRank` constants represent different locks, and `lockPartialOrder` defines the order in which locks must be acquired.

**4. Connecting to Broader Go Concepts:**

Knowing this is about preventing deadlocks leads to thinking about how deadlocks occur: circular dependencies in lock acquisition. The lock ranking system provides a strict ordering, preventing cycles.

**5. Generating an Example:**

To illustrate the lock ranking system, I need a simple scenario where acquiring locks in the wrong order could lead to a deadlock. The example should demonstrate how the lock ranking would prevent this. A common deadlock scenario involves two goroutines trying to acquire two locks in opposite orders.

* **Choosing Locks:** I need to select two locks with a defined ordering in `lockPartialOrder`. `lockRankA` with a lower rank than `lockRankB` is ideal. Let's pick two simple ones: `lockRankSched` and `lockRankAllg`. `lockPartialOrder` shows `lockRankAllg` can hold `lockRankSched`.
* **Simulating Correct Acquisition:** Show acquiring `lockRankSched` first, then `lockRankAllg`.
* **Simulating Incorrect Acquisition:** Show acquiring `lockRankAllg` first, then trying to acquire `lockRankSched`.
* **Explaining the Role of Lock Ranking:** Explain that the runtime would enforce the order, preventing the second scenario.

**6. Identifying Potential Mistakes:**

The most obvious mistake users could make is ignoring the lock ranking and acquiring locks in the wrong order *if they were manually managing low-level runtime locks* (which is usually discouraged). Since this code is internal, direct user interaction is limited. However, understanding the principle is valuable.

**7. Considering Command-Line Arguments:**

Since this code is generated and part of the core runtime, it's unlikely to have direct command-line arguments. The generation process (`mklockrank.go`) *might* have arguments, but the generated file itself wouldn't.

**8. Structuring the Answer:**

Organize the findings into the categories requested by the prompt:

* **功能 (Functionality):** Clearly state the primary purpose: preventing deadlocks through a lock ranking system.
* **实现的 Go 语言功能 (Implemented Go Feature):**  Connect the code to the broader concept of deadlock prevention.
* **Go 代码举例说明 (Go Code Example):** Provide the example with correct and incorrect lock acquisition, highlighting the intended behavior.
* **命令行参数的具体处理 (Command-Line Argument Handling):** Explain that this code doesn't directly handle command-line arguments.
* **使用者易犯错的点 (Common Mistakes):**  Explain the potential for incorrect lock acquisition if users were directly manipulating these low-level locks (and emphasize this is usually not the case).

**Self-Correction/Refinement:**

* **Initial thought:** Maybe this is used for some kind of performance monitoring related to locks.
* **Correction:** The "rank" and "partial order" strongly indicate dependency management, specifically for deadlock prevention.
* **Initial thought (for the example):**  Use `sync.Mutex`.
* **Correction:** The example should ideally use the *conceptual* locks represented by the `lockRank` constants, even if those aren't directly exposed for user-level locking. The goal is to illustrate the ranking principle. Using `sync.Mutex` might confuse the core concept being demonstrated. (Although demonstrating the *principle* with `sync.Mutex` and illustrating *how a similar system might work at a higher level* could also be valid, focusing on the runtime-internal locks is more directly relevant to the provided code.)

By following this thought process, which involves careful code analysis, hypothesis formation, connecting to broader concepts, and structuring the answer effectively, I can arrive at a comprehensive and accurate explanation of the `lockrank.go` file.
这段代码是Go语言运行时（runtime）的一部分，它的主要功能是**定义和管理运行时锁的等级（rank）系统**，用于**防止死锁**。

让我们分解一下它的功能：

**1. 定义锁的等级 (Lock Ranks):**

*   `type lockRank int`: 定义了一个名为 `lockRank` 的整型类型，用来表示锁的等级。
*   `const (...)`: 定义了一系列常量，每个常量都代表一个特定的运行时锁的等级。这些常量按照等级顺序排列，等级较低的锁必须在等级较高的锁之前获取。
    *   例如，`lockRankSysmon` 代表 `sysmon` 锁的等级，`lockRankSched` 代表 `sched` 锁的等级。
*   `lockRankLeafRank`:  定义了一个特殊的等级，表示叶子锁。叶子锁是指没有声明等级的锁，通常是锁层级结构的末端。

**2. 提供锁的名称 (Lock Names):**

*   `var lockNames = []string{...}`:  定义了一个字符串切片 `lockNames`，用于存储每个锁等级对应的名称。这使得我们可以通过锁的等级来获取其易于理解的名称。
*   `func (rank lockRank) String() string`:  为 `lockRank` 类型实现了 `String()` 方法，使得可以直接将锁的等级转换为其对应的名称字符串。

**3. 定义锁的偏序关系 (Lock Partial Order):**

*   `var lockPartialOrder [][]lockRank = [][]lockRank{...}`:  定义了一个二维的 `lockRank` 切片 `lockPartialOrder`，用于存储锁的偏序关系。
    *   对于每个锁等级 `X`，`lockPartialOrder[X]` 包含了当尝试获取锁 `X` 时，可能已经持有的锁的等级列表。
    *   这个偏序关系表示了锁的获取顺序约束。如果锁 `A` 的等级低于锁 `B`，那么在持有锁 `B` 的情况下获取锁 `A` 是不允许的，这有助于避免死锁。
    *   部分锁允许自循环，即在获取该锁时可以已经持有该锁，这些锁会在其对应的 `lockPartialOrder` 项中包含自身。

**它是什么Go语言功能的实现：**

这段代码是 Go 语言运行时中**死锁预防机制**的核心部分。Go 运行时使用锁等级排序来确保锁的获取顺序，从而避免多个 goroutine 因为循环等待对方持有的锁而造成的死锁。

**Go 代码举例说明：**

虽然这段代码本身主要是数据定义，但我们可以通过一个简化的例子来说明锁等级的概念。假设我们有两个需要加锁的资源，分别对应 `lockRankA` 和 `lockRankB`，且 `lockRankA` 的等级低于 `lockRankB`。

```go
package main

import "fmt"
import "sync"

// 假设 lockRankA 和 lockRankB 是运行时定义的锁等级
const lockRankA = 1
const lockRankB = 2

var (
	muA sync.Mutex
	muB sync.Mutex
)

// 安全的获取锁的方式 (遵循锁等级顺序)
func safeAcquireLocks() {
	fmt.Println("Goroutine 1: 尝试获取锁 A")
	muA.Lock()
	fmt.Println("Goroutine 1: 获取锁 A 成功")

	fmt.Println("Goroutine 1: 尝试获取锁 B")
	muB.Lock()
	fmt.Println("Goroutine 1: 获取锁 B 成功")

	// ... 操作共享资源 ...

	muB.Unlock()
	muA.Unlock()
}

// 不安全的获取锁的方式 (违反锁等级顺序)
func unsafeAcquireLocks() {
	fmt.Println("Goroutine 2: 尝试获取锁 B")
	muB.Lock()
	fmt.Println("Goroutine 2: 获取锁 B 成功")

	fmt.Println("Goroutine 2: 尝试获取锁 A")
	muA.Lock() // 如果另一个 goroutine 持有锁 A 并尝试获取锁 B，则会发生死锁
	fmt.Println("Goroutine 2: 获取锁 A 成功")

	// ... 操作共享资源 ...

	muA.Unlock()
	muB.Unlock()
}

func main() {
	go safeAcquireLocks()
	go unsafeAcquireLocks()

	// 为了演示，这里让主 goroutine 等待一段时间
	select {}
}
```

**假设的输入与输出：**

在上面的例子中，如果两个 goroutine 同时运行，`safeAcquireLocks` 总是先尝试获取等级较低的 `muA`，然后再获取等级较高的 `muB`。这种方式不会导致死锁。

但是，如果 `unsafeAcquireLocks` 先尝试获取等级较高的 `muB`，然后尝试获取等级较低的 `muA`，而此时另一个 goroutine (`safeAcquireLocks`) 已经持有 `muA` 并尝试获取 `muB`，那么就会发生死锁。

**输出 (可能发生死锁的情况):**

```
Goroutine 1: 尝试获取锁 A
Goroutine 1: 获取锁 A 成功
Goroutine 1: 尝试获取锁 B
Goroutine 2: 尝试获取锁 B
Goroutine 2: 获取锁 B 成功
Goroutine 2: 尝试获取锁 A
```

此时，`Goroutine 1` 持有 `muA` 并等待 `muB`，而 `Goroutine 2` 持有 `muB` 并等待 `muA`，形成死锁。

**命令行参数的具体处理：**

这段代码是 Go 运行时的内部实现，不由用户直接调用，因此它本身不涉及命令行参数的处理。生成此代码的工具 `mklockrank.go` 可能会有自己的命令行参数，但这不在当前代码的讨论范围内。

**使用者易犯错的点：**

对于一般的 Go 开发者来说，这段代码是运行时内部的细节，通常不需要直接关心或操作。Go 的 `sync` 包提供的锁机制（如 `sync.Mutex`）已经考虑了死锁的预防。

然而，对于需要深入理解 Go 运行时或者进行底层开发的开发者来说，**容易犯错的点在于理解和遵守锁的等级顺序**。如果在运行时内部错误地获取锁，违反了这里定义的等级约束，就可能导致难以调试的死锁问题。

例如，假设一个开发者在修改 Go 运行时代码时，不小心在一个持有 `lockRankSched` 锁的上下文中尝试获取 `lockRankAllocmR` 锁，而 `lockPartialOrder` 中明确指出 `lockRankSched` 的等级高于 `lockRankAllocmR`，这就违反了锁的等级顺序，可能导致死锁。

总而言之，`go/src/runtime/lockrank.go` 定义了一个精心设计的锁等级系统，它是 Go 运行时用来保证并发安全和避免死锁的关键机制。理解其背后的原理对于深入理解 Go 的并发模型非常有帮助。

### 提示词
```
这是路径为go/src/runtime/lockrank.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
请用中文回答。
```

### 源代码
```go
// Code generated by mklockrank.go; DO NOT EDIT.

package runtime

type lockRank int

// Constants representing the ranks of all non-leaf runtime locks, in rank order.
// Locks with lower rank must be taken before locks with higher rank,
// in addition to satisfying the partial order in lockPartialOrder.
// A few ranks allow self-cycles, which are specified in lockPartialOrder.
const (
	lockRankUnknown lockRank = iota

	lockRankSysmon
	lockRankScavenge
	lockRankForcegc
	lockRankDefer
	lockRankSweepWaiters
	lockRankAssistQueue
	lockRankStrongFromWeakQueue
	lockRankSweep
	lockRankTestR
	lockRankTestW
	lockRankTimerSend
	lockRankAllocmW
	lockRankExecW
	lockRankCpuprof
	lockRankPollCache
	lockRankPollDesc
	lockRankWakeableSleep
	lockRankHchan
	// SCHED
	lockRankAllocmR
	lockRankExecR
	lockRankSched
	lockRankAllg
	lockRankAllp
	lockRankNotifyList
	lockRankSudog
	lockRankTimers
	lockRankTimer
	lockRankNetpollInit
	lockRankRoot
	lockRankItab
	lockRankReflectOffs
	lockRankSynctest
	lockRankUserArenaState
	// TRACEGLOBAL
	lockRankTraceBuf
	lockRankTraceStrings
	// MALLOC
	lockRankFin
	lockRankSpanSetSpine
	lockRankMspanSpecial
	lockRankTraceTypeTab
	// MPROF
	lockRankGcBitsArenas
	lockRankProfInsert
	lockRankProfBlock
	lockRankProfMemActive
	lockRankProfMemFuture
	// STACKGROW
	lockRankGscan
	lockRankStackpool
	lockRankStackLarge
	lockRankHchanLeaf
	// WB
	lockRankWbufSpans
	lockRankMheap
	lockRankMheapSpecial
	lockRankGlobalAlloc
	// TRACE
	lockRankTrace
	lockRankTraceStackTab
	lockRankPanic
	lockRankDeadlock
	lockRankRaceFini
	lockRankAllocmRInternal
	lockRankExecRInternal
	lockRankTestRInternal
)

// lockRankLeafRank is the rank of lock that does not have a declared rank,
// and hence is a leaf lock.
const lockRankLeafRank lockRank = 1000

// lockNames gives the names associated with each of the above ranks.
var lockNames = []string{
	lockRankSysmon:              "sysmon",
	lockRankScavenge:            "scavenge",
	lockRankForcegc:             "forcegc",
	lockRankDefer:               "defer",
	lockRankSweepWaiters:        "sweepWaiters",
	lockRankAssistQueue:         "assistQueue",
	lockRankStrongFromWeakQueue: "strongFromWeakQueue",
	lockRankSweep:               "sweep",
	lockRankTestR:               "testR",
	lockRankTestW:               "testW",
	lockRankTimerSend:           "timerSend",
	lockRankAllocmW:             "allocmW",
	lockRankExecW:               "execW",
	lockRankCpuprof:             "cpuprof",
	lockRankPollCache:           "pollCache",
	lockRankPollDesc:            "pollDesc",
	lockRankWakeableSleep:       "wakeableSleep",
	lockRankHchan:               "hchan",
	lockRankAllocmR:             "allocmR",
	lockRankExecR:               "execR",
	lockRankSched:               "sched",
	lockRankAllg:                "allg",
	lockRankAllp:                "allp",
	lockRankNotifyList:          "notifyList",
	lockRankSudog:               "sudog",
	lockRankTimers:              "timers",
	lockRankTimer:               "timer",
	lockRankNetpollInit:         "netpollInit",
	lockRankRoot:                "root",
	lockRankItab:                "itab",
	lockRankReflectOffs:         "reflectOffs",
	lockRankSynctest:            "synctest",
	lockRankUserArenaState:      "userArenaState",
	lockRankTraceBuf:            "traceBuf",
	lockRankTraceStrings:        "traceStrings",
	lockRankFin:                 "fin",
	lockRankSpanSetSpine:        "spanSetSpine",
	lockRankMspanSpecial:        "mspanSpecial",
	lockRankTraceTypeTab:        "traceTypeTab",
	lockRankGcBitsArenas:        "gcBitsArenas",
	lockRankProfInsert:          "profInsert",
	lockRankProfBlock:           "profBlock",
	lockRankProfMemActive:       "profMemActive",
	lockRankProfMemFuture:       "profMemFuture",
	lockRankGscan:               "gscan",
	lockRankStackpool:           "stackpool",
	lockRankStackLarge:          "stackLarge",
	lockRankHchanLeaf:           "hchanLeaf",
	lockRankWbufSpans:           "wbufSpans",
	lockRankMheap:               "mheap",
	lockRankMheapSpecial:        "mheapSpecial",
	lockRankGlobalAlloc:         "globalAlloc",
	lockRankTrace:               "trace",
	lockRankTraceStackTab:       "traceStackTab",
	lockRankPanic:               "panic",
	lockRankDeadlock:            "deadlock",
	lockRankRaceFini:            "raceFini",
	lockRankAllocmRInternal:     "allocmRInternal",
	lockRankExecRInternal:       "execRInternal",
	lockRankTestRInternal:       "testRInternal",
}

func (rank lockRank) String() string {
	if rank == 0 {
		return "UNKNOWN"
	}
	if rank == lockRankLeafRank {
		return "LEAF"
	}
	if rank < 0 || int(rank) >= len(lockNames) {
		return "BAD RANK"
	}
	return lockNames[rank]
}

// lockPartialOrder is the transitive closure of the lock rank graph.
// An entry for rank X lists all of the ranks that can already be held
// when rank X is acquired.
//
// Lock ranks that allow self-cycles list themselves.
var lockPartialOrder [][]lockRank = [][]lockRank{
	lockRankSysmon:              {},
	lockRankScavenge:            {lockRankSysmon},
	lockRankForcegc:             {lockRankSysmon},
	lockRankDefer:               {},
	lockRankSweepWaiters:        {},
	lockRankAssistQueue:         {},
	lockRankStrongFromWeakQueue: {},
	lockRankSweep:               {},
	lockRankTestR:               {},
	lockRankTestW:               {},
	lockRankTimerSend:           {},
	lockRankAllocmW:             {},
	lockRankExecW:               {},
	lockRankCpuprof:             {},
	lockRankPollCache:           {},
	lockRankPollDesc:            {},
	lockRankWakeableSleep:       {},
	lockRankHchan:               {lockRankSysmon, lockRankScavenge, lockRankSweep, lockRankTestR, lockRankTimerSend, lockRankWakeableSleep, lockRankHchan},
	lockRankAllocmR:             {lockRankSysmon, lockRankScavenge, lockRankForcegc, lockRankSweepWaiters, lockRankAssistQueue, lockRankStrongFromWeakQueue, lockRankSweep, lockRankTestR, lockRankTimerSend, lockRankCpuprof, lockRankPollDesc, lockRankWakeableSleep, lockRankHchan},
	lockRankExecR:               {lockRankSysmon, lockRankScavenge, lockRankForcegc, lockRankSweepWaiters, lockRankAssistQueue, lockRankStrongFromWeakQueue, lockRankSweep, lockRankTestR, lockRankTimerSend, lockRankCpuprof, lockRankPollDesc, lockRankWakeableSleep, lockRankHchan},
	lockRankSched:               {lockRankSysmon, lockRankScavenge, lockRankForcegc, lockRankSweepWaiters, lockRankAssistQueue, lockRankStrongFromWeakQueue, lockRankSweep, lockRankTestR, lockRankTimerSend, lockRankCpuprof, lockRankPollDesc, lockRankWakeableSleep, lockRankHchan, lockRankAllocmR, lockRankExecR},
	lockRankAllg:                {lockRankSysmon, lockRankScavenge, lockRankForcegc, lockRankSweepWaiters, lockRankAssistQueue, lockRankStrongFromWeakQueue, lockRankSweep, lockRankTestR, lockRankTimerSend, lockRankCpuprof, lockRankPollDesc, lockRankWakeableSleep, lockRankHchan, lockRankAllocmR, lockRankExecR, lockRankSched},
	lockRankAllp:                {lockRankSysmon, lockRankScavenge, lockRankForcegc, lockRankSweepWaiters, lockRankAssistQueue, lockRankStrongFromWeakQueue, lockRankSweep, lockRankTestR, lockRankTimerSend, lockRankCpuprof, lockRankPollDesc, lockRankWakeableSleep, lockRankHchan, lockRankAllocmR, lockRankExecR, lockRankSched},
	lockRankNotifyList:          {},
	lockRankSudog:               {lockRankSysmon, lockRankScavenge, lockRankSweep, lockRankTestR, lockRankTimerSend, lockRankWakeableSleep, lockRankHchan, lockRankNotifyList},
	lockRankTimers:              {lockRankSysmon, lockRankScavenge, lockRankSweep, lockRankTestR, lockRankTimerSend, lockRankPollDesc, lockRankWakeableSleep, lockRankHchan, lockRankTimers},
	lockRankTimer:               {lockRankSysmon, lockRankScavenge, lockRankSweep, lockRankTestR, lockRankTimerSend, lockRankPollDesc, lockRankWakeableSleep, lockRankHchan, lockRankTimers},
	lockRankNetpollInit:         {lockRankSysmon, lockRankScavenge, lockRankSweep, lockRankTestR, lockRankTimerSend, lockRankPollDesc, lockRankWakeableSleep, lockRankHchan, lockRankTimers, lockRankTimer},
	lockRankRoot:                {},
	lockRankItab:                {},
	lockRankReflectOffs:         {lockRankItab},
	lockRankSynctest:            {lockRankSysmon, lockRankScavenge, lockRankSweep, lockRankTestR, lockRankTimerSend, lockRankPollDesc, lockRankWakeableSleep, lockRankHchan, lockRankNotifyList, lockRankTimers, lockRankTimer, lockRankRoot, lockRankItab, lockRankReflectOffs},
	lockRankUserArenaState:      {},
	lockRankTraceBuf:            {lockRankSysmon, lockRankScavenge},
	lockRankTraceStrings:        {lockRankSysmon, lockRankScavenge, lockRankTraceBuf},
	lockRankFin:                 {lockRankSysmon, lockRankScavenge, lockRankForcegc, lockRankSweepWaiters, lockRankAssistQueue, lockRankStrongFromWeakQueue, lockRankSweep, lockRankTestR, lockRankTimerSend, lockRankExecW, lockRankCpuprof, lockRankPollDesc, lockRankWakeableSleep, lockRankHchan, lockRankAllocmR, lockRankExecR, lockRankSched, lockRankAllg, lockRankAllp, lockRankNotifyList, lockRankTimers, lockRankTimer, lockRankItab, lockRankReflectOffs, lockRankUserArenaState, lockRankTraceBuf, lockRankTraceStrings},
	lockRankSpanSetSpine:        {lockRankSysmon, lockRankScavenge, lockRankForcegc, lockRankSweepWaiters, lockRankAssistQueue, lockRankStrongFromWeakQueue, lockRankSweep, lockRankTestR, lockRankTimerSend, lockRankExecW, lockRankCpuprof, lockRankPollDesc, lockRankWakeableSleep, lockRankHchan, lockRankAllocmR, lockRankExecR, lockRankSched, lockRankAllg, lockRankAllp, lockRankNotifyList, lockRankTimers, lockRankTimer, lockRankItab, lockRankReflectOffs, lockRankUserArenaState, lockRankTraceBuf, lockRankTraceStrings},
	lockRankMspanSpecial:        {lockRankSysmon, lockRankScavenge, lockRankForcegc, lockRankSweepWaiters, lockRankAssistQueue, lockRankStrongFromWeakQueue, lockRankSweep, lockRankTestR, lockRankTimerSend, lockRankExecW, lockRankCpuprof, lockRankPollDesc, lockRankWakeableSleep, lockRankHchan, lockRankAllocmR, lockRankExecR, lockRankSched, lockRankAllg, lockRankAllp, lockRankNotifyList, lockRankTimers, lockRankTimer, lockRankItab, lockRankReflectOffs, lockRankUserArenaState, lockRankTraceBuf, lockRankTraceStrings},
	lockRankTraceTypeTab:        {lockRankSysmon, lockRankScavenge, lockRankForcegc, lockRankSweepWaiters, lockRankAssistQueue, lockRankStrongFromWeakQueue, lockRankSweep, lockRankTestR, lockRankTimerSend, lockRankExecW, lockRankCpuprof, lockRankPollDesc, lockRankWakeableSleep, lockRankHchan, lockRankAllocmR, lockRankExecR, lockRankSched, lockRankAllg, lockRankAllp, lockRankNotifyList, lockRankTimers, lockRankTimer, lockRankItab, lockRankReflectOffs, lockRankUserArenaState, lockRankTraceBuf, lockRankTraceStrings},
	lockRankGcBitsArenas:        {lockRankSysmon, lockRankScavenge, lockRankForcegc, lockRankSweepWaiters, lockRankAssistQueue, lockRankStrongFromWeakQueue, lockRankSweep, lockRankTestR, lockRankTimerSend, lockRankExecW, lockRankCpuprof, lockRankPollDesc, lockRankWakeableSleep, lockRankHchan, lockRankAllocmR, lockRankExecR, lockRankSched, lockRankAllg, lockRankAllp, lockRankNotifyList, lockRankTimers, lockRankTimer, lockRankItab, lockRankReflectOffs, lockRankUserArenaState, lockRankTraceBuf, lockRankTraceStrings, lockRankMspanSpecial},
	lockRankProfInsert:          {lockRankSysmon, lockRankScavenge, lockRankForcegc, lockRankSweepWaiters, lockRankAssistQueue, lockRankStrongFromWeakQueue, lockRankSweep, lockRankTestR, lockRankTimerSend, lockRankExecW, lockRankCpuprof, lockRankPollDesc, lockRankWakeableSleep, lockRankHchan, lockRankAllocmR, lockRankExecR, lockRankSched, lockRankAllg, lockRankAllp, lockRankNotifyList, lockRankTimers, lockRankTimer, lockRankItab, lockRankReflectOffs, lockRankUserArenaState, lockRankTraceBuf, lockRankTraceStrings},
	lockRankProfBlock:           {lockRankSysmon, lockRankScavenge, lockRankForcegc, lockRankSweepWaiters, lockRankAssistQueue, lockRankStrongFromWeakQueue, lockRankSweep, lockRankTestR, lockRankTimerSend, lockRankExecW, lockRankCpuprof, lockRankPollDesc, lockRankWakeableSleep, lockRankHchan, lockRankAllocmR, lockRankExecR, lockRankSched, lockRankAllg, lockRankAllp, lockRankNotifyList, lockRankTimers, lockRankTimer, lockRankItab, lockRankReflectOffs, lockRankUserArenaState, lockRankTraceBuf, lockRankTraceStrings},
	lockRankProfMemActive:       {lockRankSysmon, lockRankScavenge, lockRankForcegc, lockRankSweepWaiters, lockRankAssistQueue, lockRankStrongFromWeakQueue, lockRankSweep, lockRankTestR, lockRankTimerSend, lockRankExecW, lockRankCpuprof, lockRankPollDesc, lockRankWakeableSleep, lockRankHchan, lockRankAllocmR, lockRankExecR, lockRankSched, lockRankAllg, lockRankAllp, lockRankNotifyList, lockRankTimers, lockRankTimer, lockRankItab, lockRankReflectOffs, lockRankUserArenaState, lockRankTraceBuf, lockRankTraceStrings},
	lockRankProfMemFuture:       {lockRankSysmon, lockRankScavenge, lockRankForcegc, lockRankSweepWaiters, lockRankAssistQueue, lockRankStrongFromWeakQueue, lockRankSweep, lockRankTestR, lockRankTimerSend, lockRankExecW, lockRankCpuprof, lockRankPollDesc, lockRankWakeableSleep, lockRankHchan, lockRankAllocmR, lockRankExecR, lockRankSched, lockRankAllg, lockRankAllp, lockRankNotifyList, lockRankTimers, lockRankTimer, lockRankItab, lockRankReflectOffs, lockRankUserArenaState, lockRankTraceBuf, lockRankTraceStrings, lockRankProfMemActive},
	lockRankGscan:               {lockRankSysmon, lockRankScavenge, lockRankForcegc, lockRankSweepWaiters, lockRankAssistQueue, lockRankStrongFromWeakQueue, lockRankSweep, lockRankTestR, lockRankTimerSend, lockRankExecW, lockRankCpuprof, lockRankPollDesc, lockRankWakeableSleep, lockRankHchan, lockRankAllocmR, lockRankExecR, lockRankSched, lockRankAllg, lockRankAllp, lockRankNotifyList, lockRankTimers, lockRankTimer, lockRankNetpollInit, lockRankRoot, lockRankItab, lockRankReflectOffs, lockRankSynctest, lockRankUserArenaState, lockRankTraceBuf, lockRankTraceStrings, lockRankFin, lockRankSpanSetSpine, lockRankMspanSpecial, lockRankGcBitsArenas, lockRankProfInsert, lockRankProfBlock, lockRankProfMemActive, lockRankProfMemFuture},
	lockRankStackpool:           {lockRankSysmon, lockRankScavenge, lockRankForcegc, lockRankSweepWaiters, lockRankAssistQueue, lockRankStrongFromWeakQueue, lockRankSweep, lockRankTestR, lockRankTimerSend, lockRankExecW, lockRankCpuprof, lockRankPollDesc, lockRankWakeableSleep, lockRankHchan, lockRankAllocmR, lockRankExecR, lockRankSched, lockRankAllg, lockRankAllp, lockRankNotifyList, lockRankTimers, lockRankTimer, lockRankNetpollInit, lockRankRoot, lockRankItab, lockRankReflectOffs, lockRankSynctest, lockRankUserArenaState, lockRankTraceBuf, lockRankTraceStrings, lockRankFin, lockRankSpanSetSpine, lockRankMspanSpecial, lockRankGcBitsArenas, lockRankProfInsert, lockRankProfBlock, lockRankProfMemActive, lockRankProfMemFuture, lockRankGscan},
	lockRankStackLarge:          {lockRankSysmon, lockRankScavenge, lockRankForcegc, lockRankSweepWaiters, lockRankAssistQueue, lockRankStrongFromWeakQueue, lockRankSweep, lockRankTestR, lockRankTimerSend, lockRankExecW, lockRankCpuprof, lockRankPollDesc, lockRankWakeableSleep, lockRankHchan, lockRankAllocmR, lockRankExecR, lockRankSched, lockRankAllg, lockRankAllp, lockRankNotifyList, lockRankTimers, lockRankTimer, lockRankNetpollInit, lockRankRoot, lockRankItab, lockRankReflectOffs, lockRankSynctest, lockRankUserArenaState, lockRankTraceBuf, lockRankTraceStrings, lockRankFin, lockRankSpanSetSpine, lockRankMspanSpecial, lockRankGcBitsArenas, lockRankProfInsert, lockRankProfBlock, lockRankProfMemActive, lockRankProfMemFuture, lockRankGscan},
	lockRankHchanLeaf:           {lockRankSysmon, lockRankScavenge, lockRankForcegc, lockRankSweepWaiters, lockRankAssistQueue, lockRankStrongFromWeakQueue, lockRankSweep, lockRankTestR, lockRankTimerSend, lockRankExecW, lockRankCpuprof, lockRankPollDesc, lockRankWakeableSleep, lockRankHchan, lockRankAllocmR, lockRankExecR, lockRankSched, lockRankAllg, lockRankAllp, lockRankNotifyList, lockRankTimers, lockRankTimer, lockRankNetpollInit, lockRankRoot, lockRankItab, lockRankReflectOffs, lockRankSynctest, lockRankUserArenaState, lockRankTraceBuf, lockRankTraceStrings, lockRankFin, lockRankSpanSetSpine, lockRankMspanSpecial, lockRankGcBitsArenas, lockRankProfInsert, lockRankProfBlock, lockRankProfMemActive, lockRankProfMemFuture, lockRankGscan, lockRankHchanLeaf},
	lockRankWbufSpans:           {lockRankSysmon, lockRankScavenge, lockRankForcegc, lockRankDefer, lockRankSweepWaiters, lockRankAssistQueue, lockRankStrongFromWeakQueue, lockRankSweep, lockRankTestR, lockRankTimerSend, lockRankExecW, lockRankCpuprof, lockRankPollCache, lockRankPollDesc, lockRankWakeableSleep, lockRankHchan, lockRankAllocmR, lockRankExecR, lockRankSched, lockRankAllg, lockRankAllp, lockRankNotifyList, lockRankSudog, lockRankTimers, lockRankTimer, lockRankNetpollInit, lockRankRoot, lockRankItab, lockRankReflectOffs, lockRankSynctest, lockRankUserArenaState, lockRankTraceBuf, lockRankTraceStrings, lockRankFin, lockRankSpanSetSpine, lockRankMspanSpecial, lockRankGcBitsArenas, lockRankProfInsert, lockRankProfBlock, lockRankProfMemActive, lockRankProfMemFuture, lockRankGscan},
	lockRankMheap:               {lockRankSysmon, lockRankScavenge, lockRankForcegc, lockRankDefer, lockRankSweepWaiters, lockRankAssistQueue, lockRankStrongFromWeakQueue, lockRankSweep, lockRankTestR, lockRankTimerSend, lockRankExecW, lockRankCpuprof, lockRankPollCache, lockRankPollDesc, lockRankWakeableSleep, lockRankHchan, lockRankAllocmR, lockRankExecR, lockRankSched, lockRankAllg, lockRankAllp, lockRankNotifyList, lockRankSudog, lockRankTimers, lockRankTimer, lockRankNetpollInit, lockRankRoot, lockRankItab, lockRankReflectOffs, lockRankSynctest, lockRankUserArenaState, lockRankTraceBuf, lockRankTraceStrings, lockRankFin, lockRankSpanSetSpine, lockRankMspanSpecial, lockRankGcBitsArenas, lockRankProfInsert, lockRankProfBlock, lockRankProfMemActive, lockRankProfMemFuture, lockRankGscan, lockRankStackpool, lockRankStackLarge, lockRankWbufSpans},
	lockRankMheapSpecial:        {lockRankSysmon, lockRankScavenge, lockRankForcegc, lockRankDefer, lockRankSweepWaiters, lockRankAssistQueue, lockRankStrongFromWeakQueue, lockRankSweep, lockRankTestR, lockRankTimerSend, lockRankExecW, lockRankCpuprof, lockRankPollCache, lockRankPollDesc, lockRankWakeableSleep, lockRankHchan, lockRankAllocmR, lockRankExecR, lockRankSched, lockRankAllg, lockRankAllp, lockRankNotifyList, lockRankSudog, lockRankTimers, lockRankTimer, lockRankNetpollInit, lockRankRoot, lockRankItab, lockRankReflectOffs, lockRankSynctest, lockRankUserArenaState, lockRankTraceBuf, lockRankTraceStrings, lockRankFin, lockRankSpanSetSpine, lockRankMspanSpecial, lockRankGcBitsArenas, lockRankProfInsert, lockRankProfBlock, lockRankProfMemActive, lockRankProfMemFuture, lockRankGscan, lockRankStackpool, lockRankStackLarge, lockRankWbufSpans, lockRankMheap},
	lockRankGlobalAlloc:         {lockRankSysmon, lockRankScavenge, lockRankForcegc, lockRankDefer, lockRankSweepWaiters, lockRankAssistQueue, lockRankStrongFromWeakQueue, lockRankSweep, lockRankTestR, lockRankTimerSend, lockRankExecW, lockRankCpuprof, lockRankPollCache, lockRankPollDesc, lockRankWakeableSleep, lockRankHchan, lockRankAllocmR, lockRankExecR, lockRankSched, lockRankAllg, lockRankAllp, lockRankNotifyList, lockRankSudog, lockRankTimers, lockRankTimer, lockRankNetpollInit, lockRankRoot, lockRankItab, lockRankReflectOffs, lockRankSynctest, lockRankUserArenaState, lockRankTraceBuf, lockRankTraceStrings, lockRankFin, lockRankSpanSetSpine, lockRankMspanSpecial, lockRankGcBitsArenas, lockRankProfInsert, lockRankProfBlock, lockRankProfMemActive, lockRankProfMemFuture, lockRankGscan, lockRankStackpool, lockRankStackLarge, lockRankWbufSpans, lockRankMheap, lockRankMheapSpecial},
	lockRankTrace:               {lockRankSysmon, lockRankScavenge, lockRankForcegc, lockRankDefer, lockRankSweepWaiters, lockRankAssistQueue, lockRankStrongFromWeakQueue, lockRankSweep, lockRankTestR, lockRankTimerSend, lockRankExecW, lockRankCpuprof, lockRankPollCache, lockRankPollDesc, lockRankWakeableSleep, lockRankHchan, lockRankAllocmR, lockRankExecR, lockRankSched, lockRankAllg, lockRankAllp, lockRankNotifyList, lockRankSudog, lockRankTimers, lockRankTimer, lockRankNetpollInit, lockRankRoot, lockRankItab, lockRankReflectOffs, lockRankSynctest, lockRankUserArenaState, lockRankTraceBuf, lockRankTraceStrings, lockRankFin, lockRankSpanSetSpine, lockRankMspanSpecial, lockRankGcBitsArenas, lockRankProfInsert, lockRankProfBlock, lockRankProfMemActive, lockRankProfMemFuture, lockRankGscan, lockRankStackpool, lockRankStackLarge, lockRankWbufSpans, lockRankMheap},
	lockRankTraceStackTab:       {lockRankSysmon, lockRankScavenge, lockRankForcegc, lockRankDefer, lockRankSweepWaiters, lockRankAssistQueue, lockRankStrongFromWeakQueue, lockRankSweep, lockRankTestR, lockRankTimerSend, lockRankExecW, lockRankCpuprof, lockRankPollCache, lockRankPollDesc, lockRankWakeableSleep, lockRankHchan, lockRankAllocmR, lockRankExecR, lockRankSched, lockRankAllg, lockRankAllp, lockRankNotifyList, lockRankSudog, lockRankTimers, lockRankTimer, lockRankNetpollInit, lockRankRoot, lockRankItab, lockRankReflectOffs, lockRankSynctest, lockRankUserArenaState, lockRankTraceBuf, lockRankTraceStrings, lockRankFin, lockRankSpanSetSpine, lockRankMspanSpecial, lockRankGcBitsArenas, lockRankProfInsert, lockRankProfBlock, lockRankProfMemActive, lockRankProfMemFuture, lockRankGscan, lockRankStackpool, lockRankStackLarge, lockRankWbufSpans, lockRankMheap, lockRankTrace},
	lockRankPanic:               {},
	lockRankDeadlock:            {lockRankPanic, lockRankDeadlock},
	lockRankRaceFini:            {lockRankPanic},
	lockRankAllocmRInternal:     {lockRankSysmon, lockRankScavenge, lockRankForcegc, lockRankSweepWaiters, lockRankAssistQueue, lockRankStrongFromWeakQueue, lockRankSweep, lockRankTestR, lockRankTimerSend, lockRankAllocmW, lockRankCpuprof, lockRankPollDesc, lockRankWakeableSleep, lockRankHchan, lockRankAllocmR},
	lockRankExecRInternal:       {lockRankSysmon, lockRankScavenge, lockRankForcegc, lockRankSweepWaiters, lockRankAssistQueue, lockRankStrongFromWeakQueue, lockRankSweep, lockRankTestR, lockRankTimerSend, lockRankExecW, lockRankCpuprof, lockRankPollDesc, lockRankWakeableSleep, lockRankHchan, lockRankExecR},
	lockRankTestRInternal:       {lockRankTestR, lockRankTestW},
}
```
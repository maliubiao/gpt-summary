Response:
Let's break down the thought process for analyzing this Go code snippet.

1. **Understand the Goal:** The request asks for the functionality of the provided Go code, its purpose in the broader Go language, examples, handling of command-line arguments, and potential pitfalls for users. The file path `go/src/runtime/traceback_test.go` is a huge clue: it's a *test file* within the `runtime` package. This immediately suggests its purpose is to test the traceback functionality in the Go runtime.

2. **High-Level Overview:**  Skim the code to identify the main components. I see test functions (`TestTracebackInlined`, `TestTracebackElision`, `TestTracebackArgs`, `TestTracebackParentChildGoroutines`, `TestTracebackGeneric`), helper functions (`check`, `parseTraceback`, `parseTraceback1`), data structures (`ttiResult`, `traceback`, `tbFrame`), and functions specifically designed for testing (`ttiLeaf`, `ttiSimple1`, etc.). The presence of `//go:noinline` and `//go:linkname` directives is also notable.

3. **Focus on Core Functionality:** The name `traceback_test.go` points to the central theme: testing how Go generates and formats stack traces (tracebacks). The functions with names like `tti...` and `tte...` seem to be specifically designed to create different stack scenarios.

4. **Analyze Individual Test Functions:**
    * **`TestTracebackInlined`:** The name itself suggests testing tracebacks with inlined functions. The `check` function compares the printed traceback against expected function names. The different `t.Run` blocks (`simple`, `sigpanic`, `wrapper`, `excluded`) highlight various inlining scenarios being tested.
    * **`TestTracebackElision`:**  This test focuses on how Go handles very long stack traces and "elides" (omits) some frames. The loop with `elided` values confirms this. The `tteStack` and `tteX` functions create deep call stacks for testing elision.
    * **`TestTracebackArgs`:** The name indicates testing the display of function arguments in tracebacks. The `tests` slice contains various function calls with different argument types and counts, and the `expect` string specifies the expected output. The `abiSel` function hints at testing different calling conventions (ABIs).
    * **`TestTracebackParentChildGoroutines`:**  This test checks if the traceback information includes the parent goroutine's ID when a new goroutine is created.
    * **`TestTracebackGeneric`:** This test focuses on tracebacks involving generic functions and methods.

5. **Examine Helper Functions:**
    * **`check`:** This is a crucial helper for `TestTracebackInlined`. It parses the traceback and verifies the sequence of function calls, specifically looking for inlined frames.
    * **`parseTraceback` and `parseTraceback1`:** These functions are responsible for parsing the raw text output of `debug.Stack()` into a more structured format (`traceback` and `tbFrame`). The regular expression and string manipulation within these functions are key to understanding how the traceback format is analyzed.

6. **Identify Key Go Language Features:**
    * **`runtime/debug.Stack()`:** This is the core function being tested. It's how Go programs obtain stack traces programmatically.
    * **Inlining:**  The tests extensively use `//go:noinline` to control which functions are inlined, allowing for specific testing of inlined frame representation in tracebacks. The `testenv.SkipIfOptimizationOff(t)` call reinforces the focus on inlining.
    * **Goroutines:** The `TestTracebackParentChildGoroutines` test directly deals with goroutine creation and the traceback's ability to link parent and child goroutines.
    * **Panic/Recover:** The `ttiSigpanic1` test demonstrates how tracebacks handle panics and the `recover()` mechanism.
    * **`//go:linkname`:** The `ttiExcluded2` function uses `//go:linkname` to associate a local function with a `runtime.` prefixed name, which is used to simulate scenarios where certain runtime functions are excluded from tracebacks.
    * **Generics:** The `TestTracebackGeneric` function clearly tests tracebacks in the context of Go's generics feature.
    * **Calling Conventions (ABIs):** The `TestTracebackArgs` test uses `abiSel` indicating that it's testing how arguments are displayed based on the architecture's calling conventions.

7. **Infer Overall Functionality:**  Based on the above analysis, it's clear that this code is part of the Go runtime's testing suite. Its specific purpose is to ensure the correctness and quality of stack traces generated by the Go runtime. This includes verifying the representation of inlined functions, handling of elided frames in long stacks, the correct display of function arguments (considering different ABIs), and the inclusion of parent goroutine information.

8. **Construct Examples and Explanations:**  Now, translate the understanding into the requested format. Provide code examples demonstrating how to obtain a stack trace using `debug.Stack()`. Explain how the tests simulate different scenarios. Highlight the purpose of directives like `//go:noinline`.

9. **Address Specific Requirements:**
    * **Command-line arguments:** Scan the code for any direct use of `os.Args` or the `flag` package. None are found, so note that.
    * **Common Mistakes:**  Think about common misunderstandings users might have about tracebacks. One is the impact of inlining and how it might affect the perceived call stack. Another is the elision of frames in very long stacks. The `//go:noinline` aspect might also be confusing.
    * **Code Inference with Input/Output:** For `TestTracebackArgs`, the input is the function call with specific arguments, and the output is the expected string representation in the traceback.

10. **Refine and Organize:**  Review the generated answer for clarity, accuracy, and completeness. Ensure it's well-structured and easy to understand. Use clear headings and bullet points.

This detailed process, moving from high-level understanding to specific code analysis and then synthesizing the information into a comprehensive explanation, allows for a thorough and accurate response to the request.
这段代码是Go语言运行时（runtime）包的一部分，专门用于**测试Go程序生成堆栈跟踪（traceback）的功能**。更具体地说，它侧重于测试与内联函数相关的堆栈跟踪信息的正确性。

以下是其主要功能点的详细说明：

**1. 测试内联函数的堆栈跟踪 (`TestTracebackInlined`)**

   这个测试函数是核心，它验证了当函数被内联（编译器将一个函数的代码直接插入到调用它的地方）时，堆栈跟踪信息是否仍然能够正确地反映出逻辑上的调用关系。

   * **`check` 函数:** 这是一个辅助函数，用于解析 `debug.Stack()` 产生的堆栈跟踪字符串，并将其分解为帧（frame）列表。然后，它会检查帧的函数名序列是否与预期一致。这个函数是测试的核心验证逻辑。
   * **`t.Run` 子测试:**  `TestTracebackInlined` 包含多个子测试，分别针对不同的内联场景：
      * **`simple`:** 测试一个简单的函数调用链，其中一些函数被内联。
      * **`sigpanic`:** 测试当内联函数中发生 `panic` 时，堆栈跟踪是否正确显示。
      * **`wrapper`:** 测试一个方法被内联到一个包装函数中时的情况。
      * **`excluded`:** 测试当一个被内联的函数的调用者被排除在堆栈跟踪之外时，被内联的函数是否仍然会显示。这涉及到使用 `//go:linkname` 将一个本地函数与 runtime 包中的名字关联，模拟 runtime 内部函数的场景。

**2. 测试堆栈跟踪的省略 (`TestTracebackElision`)**

   这个测试函数验证了当堆栈非常深时，Go运行时如何省略（elide）中间的帧，以避免生成过长的堆栈跟踪。

   * **循环测试不同的省略数量:**  它通过循环测试省略 0 个、1 个和 10 个帧的情况，来验证省略机制的正确性。
   * **`tteStack` 和 `tteX` 函数:** 这些函数用于创建深度嵌套的函数调用栈，以便触发堆栈省略。它们通过递归调用自身来模拟深层调用栈。

**3. 测试堆栈跟踪中的函数参数显示 (`TestTracebackArgs`)**

   这个测试函数验证了 `runtime.Stack()` 能否正确地显示函数调用时的参数值。

   * **多种参数类型和数量:** 它定义了一个 `tests` 切片，包含了各种不同的函数调用，这些函数接收不同类型（基本类型、结构体、数组、切片等）和不同数量的参数。
   * **`expect` 字段:** 每个测试用例都包含一个 `expect` 字符串，表示预期的参数显示格式。
   * **ABI 考虑:**  `abiSel` 函数用于根据不同的架构和编译选项（特别是是否开启优化）选择预期的输出，这表明参数的显示可能受到调用约定（ABI）的影响。
   * **寄存器参数和栈参数:**  测试用例还考虑了参数是存储在寄存器中还是栈上的情况，以及参数的生命周期（live/dead）。
   * **切片参数的显示:**  特别测试了切片参数的显示，以确保数据指针能够正确显示。
   * **`poisonStack` 函数:**  这个辅助函数用于填充栈空间，以确保在测试参数显示时获得确定的输出，特别是在测试寄存器参数的生命周期时。

**4. 测试父子 Goroutine 的堆栈跟踪 (`TestTracebackParentChildGoroutines`)**

   这个测试函数验证了在子 Goroutine 的堆栈跟踪中是否能够看到创建它的父 Goroutine 的信息。堆栈跟踪应该包含类似 "created by ... in goroutine N" 的信息。

**5. 测试泛型函数的堆栈跟踪 (`TestTracebackGeneric`)**

   这个测试函数验证了 `runtime.Stack()` 在处理泛型函数和方法时，能否正确地生成堆栈跟踪信息，包括类型参数的显示，但不包含内部的 "shape" 信息。

**推理 Go 语言功能：堆栈跟踪 (Stack Trace)**

这段代码主要测试的是 Go 语言的**堆栈跟踪**功能。堆栈跟踪是在程序执行过程中，记录函数调用关系的一种机制。当程序发生错误（例如 panic）或者开发者主动调用 `runtime/debug.Stack()` 时，Go 运行时会生成堆栈跟踪信息，用于帮助定位问题。

**Go 代码举例说明:**

```go
package main

import (
	"fmt"
	"runtime/debug"
)

func a() {
	b()
}

func b() {
	c()
}

func c() {
	fmt.Println(string(debug.Stack()))
}

func main() {
	a()
}
```

**假设的输入与输出:**

当你运行上面的代码时，`c()` 函数会调用 `debug.Stack()` 获取当前的堆栈信息并打印出来。

**可能的输出 (取决于具体的 Go 版本和操作系统):**

```
goroutine 1 [running]:
main.c()
        /path/to/your/file.go:16 +0x45
main.b()
        /path/to/your/file.go:12 +0x29
main.a()
        /path/to/your/file.go:8 +0x29
main.main()
        /path/to/your/file.go:20 +0x27
```

**代码推理:**

* `debug.Stack()` 函数返回一个 `[]byte`，其中包含了当前 Goroutine 的堆栈跟踪信息。
* 堆栈跟踪信息通常会显示每个调用帧的函数名、文件名和行号。
* `TestTracebackInlined` 的测试用例模拟了内联的情况，例如 `ttiSimple1` 调用 `ttiSimple2`，`ttiSimple2` 调用 `ttiSimple3`，而这些函数可能被编译器内联到 `ttiLeaf` 中。测试的目标是确保即使发生了内联，堆栈跟踪仍然能展示 `ttiSimple1` -> `ttiSimple2` -> `ttiSimple3` 这样的逻辑调用链。

**命令行参数的具体处理:**

这段代码本身是一个测试文件，它依赖于 Go 的测试框架 (`testing` 包)。它不直接处理任何用户提供的命令行参数。测试是通过 `go test` 命令运行的。

**使用者易犯错的点:**

虽然这段代码是测试代码，但理解其背后的概念有助于避免在使用堆栈跟踪时犯错：

1. **误解内联的影响:** 用户可能会认为内联会完全消除函数调用的痕迹。但实际上，Go 的堆栈跟踪会尽力保留逻辑上的调用关系，即使函数被内联。`TestTracebackInlined` 正是为了验证这一点。

   **例子:**  如果一个用户看到一个堆栈跟踪中缺少了他们认为应该存在的中间函数，他们可能会感到困惑。这可能是因为该函数被内联了。理解内联的概念有助于理解堆栈跟踪的显示。

2. **忽略省略的帧:** 当堆栈非常深时，Go 会省略中间的帧。用户可能会误以为某些调用没有发生。`TestTracebackElision` 表明 Go 会用类似 "...N frames elided..." 的信息来指示省略的帧。

   **例子:**  一个深度递归的程序可能会产生很长的堆栈。用户需要注意到 "elided" 的信息，理解堆栈跟踪可能不包含所有实际的调用帧。

3. **不理解参数显示的限制:** `TestTracebackArgs` 揭示了堆栈跟踪中显示的参数值可能受到多种因素的影响，包括参数类型、大小、是否存储在寄存器中以及编译优化等。显示的格式也可能因为 ABI 的不同而有所差异。

   **例子:**  用户不应该期望在所有情况下都能看到完整的、原始的参数值。对于某些复杂类型或在优化情况下，可能只会显示部分信息或内存地址。

总而言之，`go/src/runtime/traceback_test.go` 是一组重要的测试，用于确保 Go 语言的堆栈跟踪功能能够准确、可靠地提供程序执行过程中的调用信息，这对于调试和问题定位至关重要。理解这些测试所涵盖的场景，可以帮助 Go 开发者更好地理解和利用堆栈跟踪信息。

Prompt: 
```
这是路径为go/src/runtime/traceback_test.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
请用中文回答。

"""
// Copyright 2021 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package runtime_test

import (
	"bytes"
	"fmt"
	"internal/abi"
	"internal/testenv"
	"regexp"
	"runtime"
	"runtime/debug"
	"strconv"
	"strings"
	"sync"
	"testing"
	_ "unsafe"
)

// Test traceback printing of inlined frames.
func TestTracebackInlined(t *testing.T) {
	testenv.SkipIfOptimizationOff(t) // This test requires inlining
	check := func(t *testing.T, r *ttiResult, funcs ...string) {
		t.Helper()

		// Check the printed traceback.
		frames := parseTraceback1(t, r.printed).frames
		t.Log(r.printed)
		// Find ttiLeaf
		for len(frames) > 0 && frames[0].funcName != "runtime_test.ttiLeaf" {
			frames = frames[1:]
		}
		if len(frames) == 0 {
			t.Errorf("missing runtime_test.ttiLeaf")
			return
		}
		frames = frames[1:]
		// Check the function sequence.
		for i, want := range funcs {
			got := "<end>"
			if i < len(frames) {
				got = frames[i].funcName
				if strings.HasSuffix(want, ")") {
					got += "(" + frames[i].args + ")"
				}
			}
			if got != want {
				t.Errorf("got %s, want %s", got, want)
				return
			}
		}
	}

	t.Run("simple", func(t *testing.T) {
		// Check a simple case of inlining
		r := ttiSimple1()
		check(t, r, "runtime_test.ttiSimple3(...)", "runtime_test.ttiSimple2(...)", "runtime_test.ttiSimple1()")
	})

	t.Run("sigpanic", func(t *testing.T) {
		// Check that sigpanic from an inlined function prints correctly
		r := ttiSigpanic1()
		check(t, r, "runtime_test.ttiSigpanic1.func1()", "panic", "runtime_test.ttiSigpanic3(...)", "runtime_test.ttiSigpanic2(...)", "runtime_test.ttiSigpanic1()")
	})

	t.Run("wrapper", func(t *testing.T) {
		// Check that a method inlined into a wrapper prints correctly
		r := ttiWrapper1()
		check(t, r, "runtime_test.ttiWrapper.m1(...)", "runtime_test.ttiWrapper1()")
	})

	t.Run("excluded", func(t *testing.T) {
		// Check that when F -> G is inlined and F is excluded from stack
		// traces, G still appears.
		r := ttiExcluded1()
		check(t, r, "runtime_test.ttiExcluded3(...)", "runtime_test.ttiExcluded1()")
	})
}

type ttiResult struct {
	printed string
}

//go:noinline
func ttiLeaf() *ttiResult {
	// Get a printed stack trace.
	printed := string(debug.Stack())
	return &ttiResult{printed}
}

//go:noinline
func ttiSimple1() *ttiResult {
	return ttiSimple2()
}
func ttiSimple2() *ttiResult {
	return ttiSimple3()
}
func ttiSimple3() *ttiResult {
	return ttiLeaf()
}

//go:noinline
func ttiSigpanic1() (res *ttiResult) {
	defer func() {
		res = ttiLeaf()
		recover()
	}()
	ttiSigpanic2()
	// without condition below the inliner might decide to de-prioritize
	// the callsite above (since it would be on an "always leads to panic"
	// path).
	if alwaysTrue {
		panic("did not panic")
	}
	return nil
}
func ttiSigpanic2() {
	ttiSigpanic3()
}
func ttiSigpanic3() {
	var p *int
	*p = 3
}

var alwaysTrue = true

//go:noinline
func ttiWrapper1() *ttiResult {
	var w ttiWrapper
	m := (*ttiWrapper).m1
	return m(&w)
}

type ttiWrapper struct{}

func (w ttiWrapper) m1() *ttiResult {
	return ttiLeaf()
}

//go:noinline
func ttiExcluded1() *ttiResult {
	return ttiExcluded2()
}

// ttiExcluded2 should be excluded from tracebacks. There are
// various ways this could come up. Linking it to a "runtime." name is
// rather synthetic, but it's easy and reliable. See issue #42754 for
// one way this happened in real code.
//
//go:linkname ttiExcluded2 runtime.ttiExcluded2
//go:noinline
func ttiExcluded2() *ttiResult {
	return ttiExcluded3()
}
func ttiExcluded3() *ttiResult {
	return ttiLeaf()
}

var testTracebackArgsBuf [1000]byte

func TestTracebackElision(t *testing.T) {
	// Test printing exactly the maximum number of frames to make sure we don't
	// print any "elided" message, eliding exactly 1 so we have to pick back up
	// in the paused physical frame, and eliding 10 so we have to advance the
	// physical frame forward.
	for _, elided := range []int{0, 1, 10} {
		t.Run(fmt.Sprintf("elided=%d", elided), func(t *testing.T) {
			n := elided + runtime.TracebackInnerFrames + runtime.TracebackOuterFrames

			// Start a new goroutine so we have control over the whole stack.
			stackChan := make(chan string)
			go tteStack(n, stackChan)
			stack := <-stackChan
			tb := parseTraceback1(t, stack)

			// Check the traceback.
			i := 0
			for i < n {
				if len(tb.frames) == 0 {
					t.Errorf("traceback ended early")
					break
				}
				fr := tb.frames[0]
				if i == runtime.TracebackInnerFrames && elided > 0 {
					// This should be an "elided" frame.
					if fr.elided != elided {
						t.Errorf("want %d frames elided", elided)
						break
					}
					i += fr.elided
				} else {
					want := fmt.Sprintf("runtime_test.tte%d", (i+1)%5)
					if i == 0 {
						want = "runtime/debug.Stack"
					} else if i == n-1 {
						want = "runtime_test.tteStack"
					}
					if fr.funcName != want {
						t.Errorf("want %s, got %s", want, fr.funcName)
						break
					}
					i++
				}
				tb.frames = tb.frames[1:]
			}
			if !t.Failed() && len(tb.frames) > 0 {
				t.Errorf("got %d more frames than expected", len(tb.frames))
			}
			if t.Failed() {
				t.Logf("traceback diverged at frame %d", i)
				off := len(stack)
				if len(tb.frames) > 0 {
					off = tb.frames[0].off
				}
				t.Logf("traceback before error:\n%s", stack[:off])
				t.Logf("traceback after error:\n%s", stack[off:])
			}
		})
	}
}

// tteStack creates a stack of n logical frames and sends the traceback to
// stack. It cycles through 5 logical frames per physical frame to make it
// unlikely that any part of the traceback will end on a physical boundary.
func tteStack(n int, stack chan<- string) {
	n-- // Account for this frame
	// This is basically a Duff's device for starting the inline stack in the
	// right place so we wind up at tteN when n%5=N.
	switch n % 5 {
	case 0:
		stack <- tte0(n)
	case 1:
		stack <- tte1(n)
	case 2:
		stack <- tte2(n)
	case 3:
		stack <- tte3(n)
	case 4:
		stack <- tte4(n)
	default:
		panic("unreachable")
	}
}
func tte0(n int) string {
	return tte4(n - 1)
}
func tte1(n int) string {
	return tte0(n - 1)
}
func tte2(n int) string {
	// tte2 opens n%5 == 2 frames. It's also the base case of the recursion,
	// since we can open no fewer than two frames to call debug.Stack().
	if n < 2 {
		panic("bad n")
	}
	if n == 2 {
		return string(debug.Stack())
	}
	return tte1(n - 1)
}
func tte3(n int) string {
	return tte2(n - 1)
}
func tte4(n int) string {
	return tte3(n - 1)
}

func TestTracebackArgs(t *testing.T) {
	if *flagQuick {
		t.Skip("-quick")
	}
	optimized := !testenv.OptimizationOff()
	abiSel := func(x, y string) string {
		// select expected output based on ABI
		// In noopt build we always spill arguments so the output is the same as stack ABI.
		if optimized && abi.IntArgRegs > 0 {
			return x
		}
		return y
	}

	tests := []struct {
		fn     func() int
		expect string
	}{
		// simple ints
		{
			func() int { return testTracebackArgs1(1, 2, 3, 4, 5) },
			"testTracebackArgs1(0x1, 0x2, 0x3, 0x4, 0x5)",
		},
		// some aggregates
		{
			func() int {
				return testTracebackArgs2(false, struct {
					a, b, c int
					x       [2]int
				}{1, 2, 3, [2]int{4, 5}}, [0]int{}, [3]byte{6, 7, 8})
			},
			"testTracebackArgs2(0x0, {0x1, 0x2, 0x3, {0x4, 0x5}}, {}, {0x6, 0x7, 0x8})",
		},
		{
			func() int { return testTracebackArgs3([3]byte{1, 2, 3}, 4, 5, 6, [3]byte{7, 8, 9}) },
			"testTracebackArgs3({0x1, 0x2, 0x3}, 0x4, 0x5, 0x6, {0x7, 0x8, 0x9})",
		},
		// too deeply nested type
		{
			func() int { return testTracebackArgs4(false, [1][1][1][1][1][1][1][1][1][1]int{}) },
			"testTracebackArgs4(0x0, {{{{{...}}}}})",
		},
		// a lot of zero-sized type
		{
			func() int {
				z := [0]int{}
				return testTracebackArgs5(false, struct {
					x int
					y [0]int
					z [2][0]int
				}{1, z, [2][0]int{}}, z, z, z, z, z, z, z, z, z, z, z, z)
			},
			"testTracebackArgs5(0x0, {0x1, {}, {{}, {}}}, {}, {}, {}, {}, {}, ...)",
		},

		// edge cases for ...
		// no ... for 10 args
		{
			func() int { return testTracebackArgs6a(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) },
			"testTracebackArgs6a(0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa)",
		},
		// has ... for 11 args
		{
			func() int { return testTracebackArgs6b(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11) },
			"testTracebackArgs6b(0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, ...)",
		},
		// no ... for aggregates with 10 words
		{
			func() int { return testTracebackArgs7a([10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}) },
			"testTracebackArgs7a({0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa})",
		},
		// has ... for aggregates with 11 words
		{
			func() int { return testTracebackArgs7b([11]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}) },
			"testTracebackArgs7b({0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, ...})",
		},
		// no ... for aggregates, but with more args
		{
			func() int { return testTracebackArgs7c([10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 11) },
			"testTracebackArgs7c({0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa}, ...)",
		},
		// has ... for aggregates and also for more args
		{
			func() int { return testTracebackArgs7d([11]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}, 12) },
			"testTracebackArgs7d({0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, ...}, ...)",
		},
		// nested aggregates, no ...
		{
			func() int { return testTracebackArgs8a(testArgsType8a{1, 2, 3, 4, 5, 6, 7, 8, [2]int{9, 10}}) },
			"testTracebackArgs8a({0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, {0x9, 0xa}})",
		},
		// nested aggregates, ... in inner but not outer
		{
			func() int { return testTracebackArgs8b(testArgsType8b{1, 2, 3, 4, 5, 6, 7, 8, [3]int{9, 10, 11}}) },
			"testTracebackArgs8b({0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, {0x9, 0xa, ...}})",
		},
		// nested aggregates, ... in outer but not inner
		{
			func() int { return testTracebackArgs8c(testArgsType8c{1, 2, 3, 4, 5, 6, 7, 8, [2]int{9, 10}, 11}) },
			"testTracebackArgs8c({0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, {0x9, 0xa}, ...})",
		},
		// nested aggregates, ... in both inner and outer
		{
			func() int { return testTracebackArgs8d(testArgsType8d{1, 2, 3, 4, 5, 6, 7, 8, [3]int{9, 10, 11}, 12}) },
			"testTracebackArgs8d({0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, {0x9, 0xa, ...}, ...})",
		},

		// Register argument liveness.
		// 1, 3 are used and live, 2, 4 are dead (in register ABI).
		// Address-taken (7) and stack ({5, 6}) args are always live.
		{
			func() int {
				poisonStack() // poison arg area to make output deterministic
				return testTracebackArgs9(1, 2, 3, 4, [2]int{5, 6}, 7)
			},
			abiSel(
				"testTracebackArgs9(0x1, 0xffffffff?, 0x3, 0xff?, {0x5, 0x6}, 0x7)",
				"testTracebackArgs9(0x1, 0x2, 0x3, 0x4, {0x5, 0x6}, 0x7)"),
		},
		// No live.
		// (Note: this assume at least 5 int registers if register ABI is used.)
		{
			func() int {
				poisonStack() // poison arg area to make output deterministic
				return testTracebackArgs10(1, 2, 3, 4, 5)
			},
			abiSel(
				"testTracebackArgs10(0xffffffff?, 0xffffffff?, 0xffffffff?, 0xffffffff?, 0xffffffff?)",
				"testTracebackArgs10(0x1, 0x2, 0x3, 0x4, 0x5)"),
		},
		// Conditional spills.
		// Spill in conditional, not executed.
		{
			func() int {
				poisonStack() // poison arg area to make output deterministic
				return testTracebackArgs11a(1, 2, 3)
			},
			abiSel(
				"testTracebackArgs11a(0xffffffff?, 0xffffffff?, 0xffffffff?)",
				"testTracebackArgs11a(0x1, 0x2, 0x3)"),
		},
		// 2 spills in conditional, not executed; 3 spills in conditional, executed, but not statically known.
		// So print 0x3?.
		{
			func() int {
				poisonStack() // poison arg area to make output deterministic
				return testTracebackArgs11b(1, 2, 3, 4)
			},
			abiSel(
				"testTracebackArgs11b(0xffffffff?, 0xffffffff?, 0x3?, 0x4)",
				"testTracebackArgs11b(0x1, 0x2, 0x3, 0x4)"),
		},
		// Make sure spilled slice data pointers are spilled to the right location
		// to ensure we see it listed without a ?.
		// See issue 64414.
		{
			func() int {
				poisonStack()
				return testTracebackArgsSlice(testTracebackArgsSliceBackingStore[:])
			},
			// Note: capacity of the slice might be junk, as it is not used.
			fmt.Sprintf("testTracebackArgsSlice({%p, 0x2, ", &testTracebackArgsSliceBackingStore[0]),
		},
	}
	for _, test := range tests {
		n := test.fn()
		got := testTracebackArgsBuf[:n]
		if !bytes.Contains(got, []byte(test.expect)) {
			t.Errorf("traceback does not contain expected string: want %q, got\n%s", test.expect, got)
		}
	}
}

//go:noinline
func testTracebackArgs1(a, b, c, d, e int) int {
	n := runtime.Stack(testTracebackArgsBuf[:], false)
	if a < 0 {
		// use in-reg args to keep them alive
		return a + b + c + d + e
	}
	return n
}

//go:noinline
func testTracebackArgs2(a bool, b struct {
	a, b, c int
	x       [2]int
}, _ [0]int, d [3]byte) int {
	n := runtime.Stack(testTracebackArgsBuf[:], false)
	if a {
		// use in-reg args to keep them alive
		return b.a + b.b + b.c + b.x[0] + b.x[1] + int(d[0]) + int(d[1]) + int(d[2])
	}
	return n
}

//go:noinline
//go:registerparams
func testTracebackArgs3(x [3]byte, a, b, c int, y [3]byte) int {
	n := runtime.Stack(testTracebackArgsBuf[:], false)
	if a < 0 {
		// use in-reg args to keep them alive
		return int(x[0]) + int(x[1]) + int(x[2]) + a + b + c + int(y[0]) + int(y[1]) + int(y[2])
	}
	return n
}

//go:noinline
func testTracebackArgs4(a bool, x [1][1][1][1][1][1][1][1][1][1]int) int {
	n := runtime.Stack(testTracebackArgsBuf[:], false)
	if a {
		panic(x) // use args to keep them alive
	}
	return n
}

//go:noinline
func testTracebackArgs5(a bool, x struct {
	x int
	y [0]int
	z [2][0]int
}, _, _, _, _, _, _, _, _, _, _, _, _ [0]int) int {
	n := runtime.Stack(testTracebackArgsBuf[:], false)
	if a {
		panic(x) // use args to keep them alive
	}
	return n
}

//go:noinline
func testTracebackArgs6a(a, b, c, d, e, f, g, h, i, j int) int {
	n := runtime.Stack(testTracebackArgsBuf[:], false)
	if a < 0 {
		// use in-reg args to keep them alive
		return a + b + c + d + e + f + g + h + i + j
	}
	return n
}

//go:noinline
func testTracebackArgs6b(a, b, c, d, e, f, g, h, i, j, k int) int {
	n := runtime.Stack(testTracebackArgsBuf[:], false)
	if a < 0 {
		// use in-reg args to keep them alive
		return a + b + c + d + e + f + g + h + i + j + k
	}
	return n
}

//go:noinline
func testTracebackArgs7a(a [10]int) int {
	n := runtime.Stack(testTracebackArgsBuf[:], false)
	if a[0] < 0 {
		// use in-reg args to keep them alive
		return a[1] + a[2] + a[3] + a[4] + a[5] + a[6] + a[7] + a[8] + a[9]
	}
	return n
}

//go:noinline
func testTracebackArgs7b(a [11]int) int {
	n := runtime.Stack(testTracebackArgsBuf[:], false)
	if a[0] < 0 {
		// use in-reg args to keep them alive
		return a[1] + a[2] + a[3] + a[4] + a[5] + a[6] + a[7] + a[8] + a[9] + a[10]
	}
	return n
}

//go:noinline
func testTracebackArgs7c(a [10]int, b int) int {
	n := runtime.Stack(testTracebackArgsBuf[:], false)
	if a[0] < 0 {
		// use in-reg args to keep them alive
		return a[1] + a[2] + a[3] + a[4] + a[5] + a[6] + a[7] + a[8] + a[9] + b
	}
	return n
}

//go:noinline
func testTracebackArgs7d(a [11]int, b int) int {
	n := runtime.Stack(testTracebackArgsBuf[:], false)
	if a[0] < 0 {
		// use in-reg args to keep them alive
		return a[1] + a[2] + a[3] + a[4] + a[5] + a[6] + a[7] + a[8] + a[9] + a[10] + b
	}
	return n
}

type testArgsType8a struct {
	a, b, c, d, e, f, g, h int
	i                      [2]int
}
type testArgsType8b struct {
	a, b, c, d, e, f, g, h int
	i                      [3]int
}
type testArgsType8c struct {
	a, b, c, d, e, f, g, h int
	i                      [2]int
	j                      int
}
type testArgsType8d struct {
	a, b, c, d, e, f, g, h int
	i                      [3]int
	j                      int
}

//go:noinline
func testTracebackArgs8a(a testArgsType8a) int {
	n := runtime.Stack(testTracebackArgsBuf[:], false)
	if a.a < 0 {
		// use in-reg args to keep them alive
		return a.b + a.c + a.d + a.e + a.f + a.g + a.h + a.i[0] + a.i[1]
	}
	return n
}

//go:noinline
func testTracebackArgs8b(a testArgsType8b) int {
	n := runtime.Stack(testTracebackArgsBuf[:], false)
	if a.a < 0 {
		// use in-reg args to keep them alive
		return a.b + a.c + a.d + a.e + a.f + a.g + a.h + a.i[0] + a.i[1] + a.i[2]
	}
	return n
}

//go:noinline
func testTracebackArgs8c(a testArgsType8c) int {
	n := runtime.Stack(testTracebackArgsBuf[:], false)
	if a.a < 0 {
		// use in-reg args to keep them alive
		return a.b + a.c + a.d + a.e + a.f + a.g + a.h + a.i[0] + a.i[1] + a.j
	}
	return n
}

//go:noinline
func testTracebackArgs8d(a testArgsType8d) int {
	n := runtime.Stack(testTracebackArgsBuf[:], false)
	if a.a < 0 {
		// use in-reg args to keep them alive
		return a.b + a.c + a.d + a.e + a.f + a.g + a.h + a.i[0] + a.i[1] + a.i[2] + a.j
	}
	return n
}

// nosplit to avoid preemption or morestack spilling registers.
//
//go:nosplit
//go:noinline
func testTracebackArgs9(a int64, b int32, c int16, d int8, x [2]int, y int) int {
	if a < 0 {
		println(&y) // take address, make y live, even if no longer used at traceback
	}
	n := runtime.Stack(testTracebackArgsBuf[:], false)
	if a < 0 {
		// use half of in-reg args to keep them alive, the other half are dead
		return int(a) + int(c)
	}
	return n
}

// nosplit to avoid preemption or morestack spilling registers.
//
//go:nosplit
//go:noinline
func testTracebackArgs10(a, b, c, d, e int32) int {
	// no use of any args
	return runtime.Stack(testTracebackArgsBuf[:], false)
}

// norace to avoid race instrumentation changing spill locations.
// nosplit to avoid preemption or morestack spilling registers.
//
//go:norace
//go:nosplit
//go:noinline
func testTracebackArgs11a(a, b, c int32) int {
	if a < 0 {
		println(a, b, c) // spill in a conditional, may not execute
	}
	if b < 0 {
		return int(a + b + c)
	}
	return runtime.Stack(testTracebackArgsBuf[:], false)
}

// norace to avoid race instrumentation changing spill locations.
// nosplit to avoid preemption or morestack spilling registers.
//
//go:norace
//go:nosplit
//go:noinline
func testTracebackArgs11b(a, b, c, d int32) int {
	var x int32
	if a < 0 {
		print() // spill b in a conditional
		x = b
	} else {
		print() // spill c in a conditional
		x = c
	}
	if d < 0 { // d is always needed
		return int(x + d)
	}
	return runtime.Stack(testTracebackArgsBuf[:], false)
}

// norace to avoid race instrumentation changing spill locations.
// nosplit to avoid preemption or morestack spilling registers.
//
//go:norace
//go:nosplit
//go:noinline
func testTracebackArgsSlice(a []int) int {
	n := runtime.Stack(testTracebackArgsBuf[:], false)
	return a[1] + n
}

var testTracebackArgsSliceBackingStore [2]int

// Poison the arg area with deterministic values.
//
//go:noinline
func poisonStack() [20]int {
	return [20]int{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}
}

func TestTracebackParentChildGoroutines(t *testing.T) {
	parent := fmt.Sprintf("goroutine %d", runtime.Goid())
	var wg sync.WaitGroup
	wg.Add(1)
	go func() {
		defer wg.Done()
		buf := make([]byte, 1<<10)
		// We collect the stack only for this goroutine (by passing
		// false to runtime.Stack). We expect to see the current
		// goroutine ID, and the parent goroutine ID in a message like
		// "created by ... in goroutine N".
		stack := string(buf[:runtime.Stack(buf, false)])
		child := fmt.Sprintf("goroutine %d", runtime.Goid())
		if !strings.Contains(stack, parent) || !strings.Contains(stack, child) {
			t.Errorf("did not see parent (%s) and child (%s) IDs in stack, got %s", parent, child, stack)
		}
	}()
	wg.Wait()
}

type traceback struct {
	frames    []*tbFrame
	createdBy *tbFrame // no args
}

type tbFrame struct {
	funcName string
	args     string
	inlined  bool

	// elided is set to the number of frames elided, and the other fields are
	// set to the zero value.
	elided int

	off int // byte offset in the traceback text of this frame
}

// parseTraceback parses a printed traceback to make it easier for tests to
// check the result.
func parseTraceback(t *testing.T, tb string) []*traceback {
	//lines := strings.Split(tb, "\n")
	//nLines := len(lines)
	off := 0
	lineNo := 0
	fatal := func(f string, args ...any) {
		msg := fmt.Sprintf(f, args...)
		t.Fatalf("%s (line %d):\n%s", msg, lineNo, tb)
	}
	parseFrame := func(funcName, args string) *tbFrame {
		// Consume file/line/etc
		if !strings.HasPrefix(tb, "\t") {
			fatal("missing source line")
		}
		_, tb, _ = strings.Cut(tb, "\n")
		lineNo++
		inlined := args == "..."
		return &tbFrame{funcName: funcName, args: args, inlined: inlined, off: off}
	}
	var elidedRe = regexp.MustCompile(`^\.\.\.([0-9]+) frames elided\.\.\.$`)
	var tbs []*traceback
	var cur *traceback
	tbLen := len(tb)
	for len(tb) > 0 {
		var line string
		off = tbLen - len(tb)
		line, tb, _ = strings.Cut(tb, "\n")
		lineNo++
		switch {
		case strings.HasPrefix(line, "goroutine "):
			cur = &traceback{}
			tbs = append(tbs, cur)
		case line == "":
			// Separator between goroutines
			cur = nil
		case line[0] == '\t':
			fatal("unexpected indent")
		case strings.HasPrefix(line, "created by "):
			funcName := line[len("created by "):]
			cur.createdBy = parseFrame(funcName, "")
		case strings.HasSuffix(line, ")"):
			line = line[:len(line)-1] // Trim trailing ")"
			funcName, args, found := strings.Cut(line, "(")
			if !found {
				fatal("missing (")
			}
			frame := parseFrame(funcName, args)
			cur.frames = append(cur.frames, frame)
		case elidedRe.MatchString(line):
			// "...N frames elided..."
			nStr := elidedRe.FindStringSubmatch(line)
			n, _ := strconv.Atoi(nStr[1])
			frame := &tbFrame{elided: n}
			cur.frames = append(cur.frames, frame)
		}
	}
	return tbs
}

// parseTraceback1 is like parseTraceback, but expects tb to contain exactly one
// goroutine.
func parseTraceback1(t *testing.T, tb string) *traceback {
	tbs := parseTraceback(t, tb)
	if len(tbs) != 1 {
		t.Fatalf("want 1 goroutine, got %d:\n%s", len(tbs), tb)
	}
	return tbs[0]
}

//go:noinline
func testTracebackGenericFn[T any](buf []byte) int {
	return runtime.Stack(buf[:], false)
}

func testTracebackGenericFnInlined[T any](buf []byte) int {
	return runtime.Stack(buf[:], false)
}

type testTracebackGenericTyp[P any] struct{ x P }

//go:noinline
func (t testTracebackGenericTyp[P]) M(buf []byte) int {
	return runtime.Stack(buf[:], false)
}

func (t testTracebackGenericTyp[P]) Inlined(buf []byte) int {
	return runtime.Stack(buf[:], false)
}

func TestTracebackGeneric(t *testing.T) {
	if *flagQuick {
		t.Skip("-quick")
	}
	var x testTracebackGenericTyp[int]
	tests := []struct {
		fn     func([]byte) int
		expect string
	}{
		// function, not inlined
		{
			testTracebackGenericFn[int],
			"testTracebackGenericFn[...](",
		},
		// function, inlined
		{
			func(buf []byte) int { return testTracebackGenericFnInlined[int](buf) },
			"testTracebackGenericFnInlined[...](",
		},
		// method, not inlined
		{
			x.M,
			"testTracebackGenericTyp[...].M(",
		},
		// method, inlined
		{
			func(buf []byte) int { return x.Inlined(buf) },
			"testTracebackGenericTyp[...].Inlined(",
		},
	}
	var buf [1000]byte
	for _, test := range tests {
		n := test.fn(buf[:])
		got := buf[:n]
		if !bytes.Contains(got, []byte(test.expect)) {
			t.Errorf("traceback does not contain expected string: want %q, got\n%s", test.expect, got)
		}
		if bytes.Contains(got, []byte("shape")) { // should not contain shape name
			t.Errorf("traceback contains shape name: got\n%s", got)
		}
	}
}

"""



```
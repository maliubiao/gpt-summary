Response:
Let's break down the thought process for analyzing this Go code snippet and generating the detailed explanation.

1. **Understand the Goal:** The core task is to analyze a Go test file (`dump_test.go`) within the `net/http/httputil` package. The focus is on understanding its functionality, particularly related to request and response dumping.

2. **Identify Key Functions/Types:**  The file name itself suggests the primary functionality: dumping HTTP requests and responses. Quickly scanning the code reveals the key functions being tested: `DumpRequest`, `DumpRequestOut`, and `DumpResponse`. The `dumpTest` struct is central to organizing test cases.

3. **Analyze `dumpTest` Struct:** This struct is the blueprint for each test case. Understanding its fields is crucial:
    * `Req`: An `http.Request` pointer, representing the request to be dumped.
    * `GetReq`: A function that returns an `http.Request`. This provides flexibility in creating requests.
    * `Body`: The request body (can be `[]byte` or a function returning `io.ReadCloser`).
    * `WantDump`: The expected output of `DumpRequest`.
    * `WantDumpOut`: The expected output of `DumpRequestOut`.
    * `MustError`: A boolean indicating if the test is expected to produce an error.
    * `NoBody`:  A boolean to control whether the body should be included in the dump.

4. **Analyze Test Cases (`dumpTests`):**  Go through each test case within the `dumpTests` slice. For each case, try to understand:
    * **The Scenario:** What specific aspect of request/response dumping is being tested? (e.g., chunked encoding, HTTP version, presence/absence of `Host` header, handling of `Content-Length`, etc.)
    * **Input:** What is the `Req` (or the request generated by `GetReq`) and the `Body` (if any)?
    * **Expected Output:** What is the `WantDump` or `WantDumpOut`? How does it relate to the input request?
    * **Special Conditions:** Is `NoBody` set? Is `MustError` set?

5. **Focus on `DumpRequest` and `DumpRequestOut`:** Based on the test cases, deduce the purpose and behavior of these functions:
    * `DumpRequest`: Seems to dump the request as it was *received* or as it's *prepared* (without adding client-specific headers like `User-Agent`). It's likely used for logging or debugging the structure of a request.
    * `DumpRequestOut`: Seems to dump the request as it's being *sent* by an HTTP client. This includes client-specific headers like `User-Agent` and automatically adds the `Host` header if missing.

6. **Analyze `DumpResponse`:**  Similarly, analyze the `dumpResTests`. Understand how the `body` parameter affects the output.

7. **Identify Edge Cases and Error Handling:** Notice the `MustError` field in some `dumpTest` cases. This indicates the tests are intentionally trying to trigger errors, likely when dealing with invalid or incomplete requests (like an empty URL).

8. **Infer Functionality (High-Level):** Based on the tests, conclude that the primary goal of the `httputil` package's dumping functions is to provide a textual representation of HTTP requests and responses, useful for debugging and logging. Distinguish between the "raw" request (`DumpRequest`) and the outgoing request as seen by the server (`DumpRequestOut`).

9. **Consider Potential Pitfalls:** Think about common mistakes developers might make when using these functions. The main point here is the difference between `DumpRequest` and `DumpRequestOut` and when to use each. Also, the `NoBody` flag is a potential point of confusion.

10. **Address Specific Questions from the Prompt:** Now, systematically answer each part of the original prompt:
    * **功能列表:**  Summarize the observed functionalities.
    * **Go语言功能实现推理:** Connect the observed behavior to specific Go language features (like `http.Request`, `http.Response`, `io.Reader`, `bufio.Reader`, etc.).
    * **代码举例:** Provide concrete examples using `DumpRequest` and `DumpRequestOut`, illustrating the difference with example input and output.
    * **代码推理 (with assumptions):**  Explain the logic behind the outputs, explicitly stating any assumptions (like the default HTTP version).
    * **命令行参数:** Since this is a test file, there are no direct command-line arguments involved in the *tested* functions. However, mention how tests are generally run in Go.
    * **易犯错的点:** Explain the common misunderstandings about `DumpRequest` vs. `DumpRequestOut` and the `NoBody` flag.

11. **Structure the Answer:** Organize the information logically with clear headings and bullet points for readability. Use code blocks for examples and expected outputs.

12. **Review and Refine:**  Read through the generated answer to ensure accuracy, clarity, and completeness. Check for any inconsistencies or missing information. Ensure the language is clear and concise. For example, initially, I might have just said "dumps requests," but refining it to distinguish between the "raw" and "outgoing" forms makes the explanation much better. Similarly, explicitly mentioning the purpose of the `NoBody` flag adds clarity.

By following this step-by-step approach, combining code analysis, logical deduction, and a focus on the prompt's requirements, we can arrive at a comprehensive and accurate explanation of the given Go code snippet.
这段代码是 Go 语言标准库 `net/http/httputil` 包中 `dump_test.go` 文件的一部分，它主要用于测试 `httputil` 包中的 `DumpRequest` 和 `DumpResponse` 函数的功能。这两个函数可以将 HTTP 请求和响应的内容以文本形式转储出来，方便开发者进行调试和日志记录。

**主要功能:**

1. **测试 `DumpRequest` 函数:**
   - 验证 `DumpRequest` 函数能否正确地将 `http.Request` 对象的内容（包括请求行、头部和可选的请求体）转储为字符串。
   - 测试不同 HTTP 版本、请求方法、URL、头部信息以及请求体的场景。
   - 验证在指定不包含请求体时 (`NoBody: true`)，`DumpRequest` 能否正确处理。
   - 测试 `DumpRequest` 是否能正确处理 `Content-Length` 头部。
   - 针对一些特定的 issue (如 #7215, #18506, #34504, #54616) 进行了回归测试，确保 `DumpRequest` 能按预期工作。
   - 测试当 URL 为空时，`DumpRequest` 是否会抛出错误，并检查是否存在 Goroutine 泄漏。

2. **测试 `DumpRequestOut` 函数:**
   - 验证 `DumpRequestOut` 函数的功能，它与 `DumpRequest` 类似，但通常用于转储客户端发出的请求，会包含一些客户端自动添加的头部（例如 `User-Agent`， `Accept-Encoding`）。
   - 测试了包含请求体和不包含请求体的场景。
   - 针对 Issue #38352 进行了并发测试，检查在高并发取消请求的情况下是否会发生死锁。

3. **测试 `DumpResponse` 函数:**
   - 验证 `DumpResponse` 函数能否正确地将 `http.Response` 对象的内容（包括状态行、头部和可选的响应体）转储为字符串。
   - 测试了包含和不包含响应体的场景。
   - 测试了 `Content-Length` 和 `Transfer-Encoding: chunked` 头部的情况。

**它是什么 Go 语言功能的实现？**

这段代码主要测试了 `net/http/httputil` 包中用于 **HTTP 消息转储** 功能的实现。  `httputil.DumpRequest` 和 `httputil.DumpResponse` 函数是实现这个功能的核心。

**Go 代码举例说明:**

```go
package main

import (
	"bytes"
	"fmt"
	"net/http"
	"net/http/httputil"
	"net/url"
)

func main() {
	// 创建一个 HTTP 请求
	req := &http.Request{
		Method: "POST",
		URL: &url.URL{
			Scheme: "http",
			Host:   "example.com",
			Path:   "/submit",
		},
		Header: http.Header{
			"Content-Type": []string{"application/json"},
		},
		Body:    bytes.NewBufferString(`{"key": "value"}`),
		ContentLength: int64(len(`{"key": "value"}`)),
	}

	// 使用 DumpRequest 转储请求 (包含请求体)
	dumpedRequest, err := httputil.DumpRequest(req, true)
	if err != nil {
		fmt.Println("Error dumping request:", err)
		return
	}
	fmt.Println("Dumped Request (with body):\n", string(dumpedRequest))

	// 使用 DumpRequest 转储请求 (不包含请求体)
	dumpedRequestWithoutBody, err := httputil.DumpRequest(req, false)
	if err != nil {
		fmt.Println("Error dumping request:", err)
		return
	}
	fmt.Println("Dumped Request (without body):\n", string(dumpedRequestWithoutBody))

	// 模拟一个 HTTP 响应
	resp := &http.Response{
		Status:     "200 OK",
		StatusCode: http.StatusOK,
		Proto:      "HTTP/1.1",
		ProtoMajor: 1,
		ProtoMinor: 1,
		Header: http.Header{
			"Content-Type": []string{"application/json"},
		},
		Body:    http.NoBody, // 示例中没有响应体
		ContentLength: 0,
	}

	// 使用 DumpResponse 转储响应 (不包含响应体，因为 Body 是 http.NoBody)
	dumpedResponse, err := httputil.DumpResponse(resp, true)
	if err != nil {
		fmt.Println("Error dumping response:", err)
		return
	}
	fmt.Println("Dumped Response:\n", string(dumpedResponse))
}
```

**假设的输入与输出 (基于上面的代码示例):**

**输入 (req):**  一个 `http.Request` 对象，如上面代码所示。

**使用 `DumpRequest(req, true)` 的输出:**

```
Dumped Request (with body):
 POST /submit HTTP/1.1
Host: example.com
Content-Type: application/json
Content-Length: 16

{"key": "value"}
```

**使用 `DumpRequest(req, false)` 的输出:**

```
Dumped Request (without body):
 POST /submit HTTP/1.1
Host: example.com
Content-Type: application/json
Content-Length: 16
```

**输入 (resp):** 一个 `http.Response` 对象，如上面代码所示。

**使用 `DumpResponse(resp, true)` 的输出:**

```
Dumped Response:
 HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 0
```

**命令行参数的具体处理:**

这段代码本身是测试代码，不涉及命令行参数的处理。`httputil.DumpRequest` 和 `httputil.DumpResponse` 函数也不接受命令行参数。它们直接操作 `http.Request` 和 `http.Response` 对象。

如果你想运行这些测试，可以使用 Go 的测试命令：

```bash
go test net/http/httputil
```

或者，如果你在 `net/http/httputil` 目录下，可以直接运行：

```bash
go test
```

Go 的测试框架会查找以 `_test.go` 结尾的文件并执行其中的测试函数。

**使用者易犯错的点:**

1. **混淆 `DumpRequest` 和 `DumpRequestOut` 的使用场景:**
   - `DumpRequest` 更侧重于转储接收到的或者构造的原始请求，它不会像浏览器或 `http.Client` 那样自动添加一些头部（例如 `Host`, `User-Agent`， `Accept-Encoding`）。
   - `DumpRequestOut` 更侧重于转储客户端即将发送的请求，它会包含 `http.Client` 在发送请求前添加的头部。

   **举例:**

   ```go
   req := &http.Request{
       Method: "GET",
       URL: &url.URL{Scheme: "http", Host: "example.com", Path: "/"},
       ProtoMajor: 1,
       ProtoMinor: 1,
   }

   dump1, _ := httputil.DumpRequest(req, false)
   fmt.Println("DumpRequest:\n", string(dump1))

   client := &http.Client{}
   dump2, _ := httputil.DumpRequestOut(req, false)
   fmt.Println("DumpRequestOut:\n", string(dump2))
   ```

   **输出 (可能):**

   ```
   DumpRequest:
    GET / HTTP/1.1

   DumpRequestOut:
    GET / HTTP/1.1
   Host: example.com
   User-Agent: Go-http-client/1.1
   Accept-Encoding: gzip
   ```

   可以看到 `DumpRequestOut` 包含了 `Host` 和 `User-Agent` 头部。

2. **忘记 `DumpRequest` 和 `DumpResponse` 的第二个参数 ( `body bool` ):**
   - 这个参数决定了是否要包含请求或响应的主体内容。
   - 如果设置为 `false`，则转储的字符串中不会包含主体部分。
   - 如果没有注意这个参数，可能会导致在调试时看不到请求或响应体，从而难以定位问题。

3. **认为 `DumpRequest` 或 `DumpResponse` 会修改原始的 `http.Request` 或 `http.Response` 对象:**
   - 这两个函数只是将请求或响应的内容转储为字符串，并不会修改原始对象的状态。

总而言之，这段测试代码全面地验证了 `httputil.DumpRequest` 和 `httputil.DumpResponse` 函数在各种场景下的行为，确保这些工具函数能够正确地为开发者提供 HTTP 消息的文本表示，辅助调试和日志记录。

### 提示词
```
这是路径为go/src/net/http/httputil/dump_test.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
请用中文回答。
```

### 源代码
```go
// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package httputil

import (
	"bufio"
	"bytes"
	"context"
	"fmt"
	"io"
	"math/rand"
	"net/http"
	"net/url"
	"runtime"
	"runtime/pprof"
	"strings"
	"testing"
	"time"
)

type eofReader struct{}

func (n eofReader) Close() error { return nil }

func (n eofReader) Read([]byte) (int, error) { return 0, io.EOF }

type dumpTest struct {
	// Either Req or GetReq can be set/nil but not both.
	Req    *http.Request
	GetReq func() *http.Request

	Body any // optional []byte or func() io.ReadCloser to populate Req.Body

	WantDump    string
	WantDumpOut string
	MustError   bool // if true, the test is expected to throw an error
	NoBody      bool // if true, set DumpRequest{,Out} body to false
}

var dumpTests = []dumpTest{
	// HTTP/1.1 => chunked coding; body; empty trailer
	{
		Req: &http.Request{
			Method: "GET",
			URL: &url.URL{
				Scheme: "http",
				Host:   "www.google.com",
				Path:   "/search",
			},
			ProtoMajor:       1,
			ProtoMinor:       1,
			TransferEncoding: []string{"chunked"},
		},

		Body: []byte("abcdef"),

		WantDump: "GET /search HTTP/1.1\r\n" +
			"Host: www.google.com\r\n" +
			"Transfer-Encoding: chunked\r\n\r\n" +
			chunk("abcdef") + chunk(""),
	},

	// Verify that DumpRequest preserves the HTTP version number, doesn't add a Host,
	// and doesn't add a User-Agent.
	{
		Req: &http.Request{
			Method:     "GET",
			URL:        mustParseURL("/foo"),
			ProtoMajor: 1,
			ProtoMinor: 0,
			Header: http.Header{
				"X-Foo": []string{"X-Bar"},
			},
		},

		WantDump: "GET /foo HTTP/1.0\r\n" +
			"X-Foo: X-Bar\r\n\r\n",
	},

	{
		Req: mustNewRequest("GET", "http://example.com/foo", nil),

		WantDumpOut: "GET /foo HTTP/1.1\r\n" +
			"Host: example.com\r\n" +
			"User-Agent: Go-http-client/1.1\r\n" +
			"Accept-Encoding: gzip\r\n\r\n",
	},

	// Test that an https URL doesn't try to do an SSL negotiation
	// with a bytes.Buffer and hang with all goroutines not
	// runnable.
	{
		Req: mustNewRequest("GET", "https://example.com/foo", nil),
		WantDumpOut: "GET /foo HTTP/1.1\r\n" +
			"Host: example.com\r\n" +
			"User-Agent: Go-http-client/1.1\r\n" +
			"Accept-Encoding: gzip\r\n\r\n",
	},

	// Request with Body, but Dump requested without it.
	{
		Req: &http.Request{
			Method: "POST",
			URL: &url.URL{
				Scheme: "http",
				Host:   "post.tld",
				Path:   "/",
			},
			ContentLength: 6,
			ProtoMajor:    1,
			ProtoMinor:    1,
		},

		Body: []byte("abcdef"),

		WantDumpOut: "POST / HTTP/1.1\r\n" +
			"Host: post.tld\r\n" +
			"User-Agent: Go-http-client/1.1\r\n" +
			"Content-Length: 6\r\n" +
			"Accept-Encoding: gzip\r\n\r\n",

		NoBody: true,
	},

	// Request with Body > 8196 (default buffer size)
	{
		Req: &http.Request{
			Method: "POST",
			URL: &url.URL{
				Scheme: "http",
				Host:   "post.tld",
				Path:   "/",
			},
			Header: http.Header{
				"Content-Length": []string{"8193"},
			},

			ContentLength: 8193,
			ProtoMajor:    1,
			ProtoMinor:    1,
		},

		Body: bytes.Repeat([]byte("a"), 8193),

		WantDumpOut: "POST / HTTP/1.1\r\n" +
			"Host: post.tld\r\n" +
			"User-Agent: Go-http-client/1.1\r\n" +
			"Content-Length: 8193\r\n" +
			"Accept-Encoding: gzip\r\n\r\n" +
			strings.Repeat("a", 8193),
		WantDump: "POST / HTTP/1.1\r\n" +
			"Host: post.tld\r\n" +
			"Content-Length: 8193\r\n\r\n" +
			strings.Repeat("a", 8193),
	},

	{
		GetReq: func() *http.Request {
			return mustReadRequest("GET http://foo.com/ HTTP/1.1\r\n" +
				"User-Agent: blah\r\n\r\n")
		},
		NoBody: true,
		WantDump: "GET http://foo.com/ HTTP/1.1\r\n" +
			"User-Agent: blah\r\n\r\n",
	},

	// Issue #7215. DumpRequest should return the "Content-Length" when set
	{
		GetReq: func() *http.Request {
			return mustReadRequest("POST /v2/api/?login HTTP/1.1\r\n" +
				"Host: passport.myhost.com\r\n" +
				"Content-Length: 3\r\n" +
				"\r\nkey1=name1&key2=name2")
		},
		WantDump: "POST /v2/api/?login HTTP/1.1\r\n" +
			"Host: passport.myhost.com\r\n" +
			"Content-Length: 3\r\n" +
			"\r\nkey",
	},
	// Issue #7215. DumpRequest should return the "Content-Length" in ReadRequest
	{
		GetReq: func() *http.Request {
			return mustReadRequest("POST /v2/api/?login HTTP/1.1\r\n" +
				"Host: passport.myhost.com\r\n" +
				"Content-Length: 0\r\n" +
				"\r\nkey1=name1&key2=name2")
		},
		WantDump: "POST /v2/api/?login HTTP/1.1\r\n" +
			"Host: passport.myhost.com\r\n" +
			"Content-Length: 0\r\n\r\n",
	},

	// Issue #7215. DumpRequest should not return the "Content-Length" if unset
	{
		GetReq: func() *http.Request {
			return mustReadRequest("POST /v2/api/?login HTTP/1.1\r\n" +
				"Host: passport.myhost.com\r\n" +
				"\r\nkey1=name1&key2=name2")
		},
		WantDump: "POST /v2/api/?login HTTP/1.1\r\n" +
			"Host: passport.myhost.com\r\n\r\n",
	},

	// Issue 18506: make drainBody recognize NoBody. Otherwise
	// this was turning into a chunked request.
	{
		Req: mustNewRequest("POST", "http://example.com/foo", http.NoBody),
		WantDumpOut: "POST /foo HTTP/1.1\r\n" +
			"Host: example.com\r\n" +
			"User-Agent: Go-http-client/1.1\r\n" +
			"Content-Length: 0\r\n" +
			"Accept-Encoding: gzip\r\n\r\n",
	},

	// Issue 34504: a non-nil Body without ContentLength set should be chunked
	{
		Req: &http.Request{
			Method: "PUT",
			URL: &url.URL{
				Scheme: "http",
				Host:   "post.tld",
				Path:   "/test",
			},
			ContentLength: 0,
			Proto:         "HTTP/1.1",
			ProtoMajor:    1,
			ProtoMinor:    1,
			Body:          &eofReader{},
		},
		NoBody: true,
		WantDumpOut: "PUT /test HTTP/1.1\r\n" +
			"Host: post.tld\r\n" +
			"User-Agent: Go-http-client/1.1\r\n" +
			"Transfer-Encoding: chunked\r\n" +
			"Accept-Encoding: gzip\r\n\r\n",
	},

	// Issue 54616: request with Connection header doesn't result in duplicate header.
	{
		GetReq: func() *http.Request {
			return mustReadRequest("GET / HTTP/1.1\r\n" +
				"Host: example.com\r\n" +
				"Connection: close\r\n\r\n")
		},
		NoBody: true,
		WantDump: "GET / HTTP/1.1\r\n" +
			"Host: example.com\r\n" +
			"Connection: close\r\n\r\n",
	},
}

func TestDumpRequest(t *testing.T) {
	// Make a copy of dumpTests and add 10 new cases with an empty URL
	// to test that no goroutines are leaked. See golang.org/issue/32571.
	// 10 seems to be a decent number which always triggers the failure.
	dumpTests := dumpTests[:]
	for i := 0; i < 10; i++ {
		dumpTests = append(dumpTests, dumpTest{
			Req:       mustNewRequest("GET", "", nil),
			MustError: true,
		})
	}
	numg0 := runtime.NumGoroutine()
	for i, tt := range dumpTests {
		if tt.Req != nil && tt.GetReq != nil || tt.Req == nil && tt.GetReq == nil {
			t.Errorf("#%d: either .Req(%p) or .GetReq(%p) can be set/nil but not both", i, tt.Req, tt.GetReq)
			continue
		}

		freshReq := func(ti dumpTest) *http.Request {
			req := ti.Req
			if req == nil {
				req = ti.GetReq()
			}

			if req.Header == nil {
				req.Header = make(http.Header)
			}

			if ti.Body == nil {
				return req
			}
			switch b := ti.Body.(type) {
			case []byte:
				req.Body = io.NopCloser(bytes.NewReader(b))
			case func() io.ReadCloser:
				req.Body = b()
			default:
				t.Fatalf("Test %d: unsupported Body of %T", i, ti.Body)
			}
			return req
		}

		if tt.WantDump != "" {
			req := freshReq(tt)
			dump, err := DumpRequest(req, !tt.NoBody)
			if err != nil {
				t.Errorf("DumpRequest #%d: %s\nWantDump:\n%s", i, err, tt.WantDump)
				continue
			}
			if string(dump) != tt.WantDump {
				t.Errorf("DumpRequest %d, expecting:\n%s\nGot:\n%s\n", i, tt.WantDump, string(dump))
				continue
			}
		}

		if tt.MustError {
			req := freshReq(tt)
			_, err := DumpRequestOut(req, !tt.NoBody)
			if err == nil {
				t.Errorf("DumpRequestOut #%d: expected an error, got nil", i)
			}
			continue
		}

		if tt.WantDumpOut != "" {
			req := freshReq(tt)
			dump, err := DumpRequestOut(req, !tt.NoBody)
			if err != nil {
				t.Errorf("DumpRequestOut #%d: %s", i, err)
				continue
			}
			if string(dump) != tt.WantDumpOut {
				t.Errorf("DumpRequestOut %d, expecting:\n%s\nGot:\n%s\n", i, tt.WantDumpOut, string(dump))
				continue
			}
		}
	}

	// Validate we haven't leaked any goroutines.
	var dg int
	dl := deadline(t, 5*time.Second, time.Second)
	for time.Now().Before(dl) {
		if dg = runtime.NumGoroutine() - numg0; dg <= 4 {
			// No unexpected goroutines.
			return
		}

		// Allow goroutines to schedule and die off.
		runtime.Gosched()
	}

	buf := make([]byte, 4096)
	buf = buf[:runtime.Stack(buf, true)]
	t.Errorf("Unexpectedly large number of new goroutines: %d new: %s", dg, buf)
}

// deadline returns the time which is needed before t.Deadline()
// if one is configured and it is s greater than needed in the future,
// otherwise defaultDelay from the current time.
func deadline(t *testing.T, defaultDelay, needed time.Duration) time.Time {
	if dl, ok := t.Deadline(); ok {
		if dl = dl.Add(-needed); dl.After(time.Now()) {
			// Allow an arbitrarily long delay.
			return dl
		}
	}

	// No deadline configured or its closer than needed from now
	// so just use the default.
	return time.Now().Add(defaultDelay)
}

func chunk(s string) string {
	return fmt.Sprintf("%x\r\n%s\r\n", len(s), s)
}

func mustParseURL(s string) *url.URL {
	u, err := url.Parse(s)
	if err != nil {
		panic(fmt.Sprintf("Error parsing URL %q: %v", s, err))
	}
	return u
}

func mustNewRequest(method, url string, body io.Reader) *http.Request {
	req, err := http.NewRequest(method, url, body)
	if err != nil {
		panic(fmt.Sprintf("NewRequest(%q, %q, %p) err = %v", method, url, body, err))
	}
	return req
}

func mustReadRequest(s string) *http.Request {
	req, err := http.ReadRequest(bufio.NewReader(strings.NewReader(s)))
	if err != nil {
		panic(err)
	}
	return req
}

var dumpResTests = []struct {
	res  *http.Response
	body bool
	want string
}{
	{
		res: &http.Response{
			Status:        "200 OK",
			StatusCode:    200,
			Proto:         "HTTP/1.1",
			ProtoMajor:    1,
			ProtoMinor:    1,
			ContentLength: 50,
			Header: http.Header{
				"Foo": []string{"Bar"},
			},
			Body: io.NopCloser(strings.NewReader("foo")), // shouldn't be used
		},
		body: false, // to verify we see 50, not empty or 3.
		want: `HTTP/1.1 200 OK
Content-Length: 50
Foo: Bar`,
	},

	{
		res: &http.Response{
			Status:        "200 OK",
			StatusCode:    200,
			Proto:         "HTTP/1.1",
			ProtoMajor:    1,
			ProtoMinor:    1,
			ContentLength: 3,
			Body:          io.NopCloser(strings.NewReader("foo")),
		},
		body: true,
		want: `HTTP/1.1 200 OK
Content-Length: 3

foo`,
	},

	{
		res: &http.Response{
			Status:           "200 OK",
			StatusCode:       200,
			Proto:            "HTTP/1.1",
			ProtoMajor:       1,
			ProtoMinor:       1,
			ContentLength:    -1,
			Body:             io.NopCloser(strings.NewReader("foo")),
			TransferEncoding: []string{"chunked"},
		},
		body: true,
		want: `HTTP/1.1 200 OK
Transfer-Encoding: chunked

3
foo
0`,
	},
	{
		res: &http.Response{
			Status:        "200 OK",
			StatusCode:    200,
			Proto:         "HTTP/1.1",
			ProtoMajor:    1,
			ProtoMinor:    1,
			ContentLength: 0,
			Header: http.Header{
				// To verify if headers are not filtered out.
				"Foo1": []string{"Bar1"},
				"Foo2": []string{"Bar2"},
			},
			Body: nil,
		},
		body: false, // to verify we see 0, not empty.
		want: `HTTP/1.1 200 OK
Foo1: Bar1
Foo2: Bar2
Content-Length: 0`,
	},
}

func TestDumpResponse(t *testing.T) {
	for i, tt := range dumpResTests {
		gotb, err := DumpResponse(tt.res, tt.body)
		if err != nil {
			t.Errorf("%d. DumpResponse = %v", i, err)
			continue
		}
		got := string(gotb)
		got = strings.TrimSpace(got)
		got = strings.ReplaceAll(got, "\r", "")

		if got != tt.want {
			t.Errorf("%d.\nDumpResponse got:\n%s\n\nWant:\n%s\n", i, got, tt.want)
		}
	}
}

// Issue 38352: Check for deadlock on canceled requests.
func TestDumpRequestOutIssue38352(t *testing.T) {
	if testing.Short() {
		return
	}
	t.Parallel()

	timeout := 10 * time.Second
	if deadline, ok := t.Deadline(); ok {
		timeout = time.Until(deadline)
		timeout -= time.Second * 2 // Leave 2 seconds to report failures.
	}
	for i := 0; i < 1000; i++ {
		delay := time.Duration(rand.Intn(5)) * time.Millisecond
		ctx, cancel := context.WithTimeout(context.Background(), delay)
		defer cancel()

		r := bytes.NewBuffer(make([]byte, 10000))
		req, err := http.NewRequestWithContext(ctx, http.MethodPost, "http://example.com", r)
		if err != nil {
			t.Fatal(err)
		}

		out := make(chan error)
		go func() {
			_, err = DumpRequestOut(req, true)
			out <- err
		}()

		select {
		case <-out:
		case <-time.After(timeout):
			b := &strings.Builder{}
			fmt.Fprintf(b, "deadlock detected on iteration %d after %s with delay: %v\n", i, timeout, delay)
			pprof.Lookup("goroutine").WriteTo(b, 1)
			t.Fatal(b.String())
		}
	}
}
```
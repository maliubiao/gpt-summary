Response:
Let's break down the thought process for analyzing this Go code snippet.

**1. Initial Reading and High-Level Understanding:**

* **Code Generation Comment:** The first line `// Code generated by gen_sort_variants.go; DO NOT EDIT.` immediately tells me this file is likely automatically generated. This implies a template-based approach where a general sorting algorithm is adapted for different types or comparison methods. The "DO NOT EDIT" reinforces this.
* **Copyright and License:** Standard Go boilerplate. Indicates the origin and licensing terms.
* **Package `slices`:**  This tells me the code is related to slice manipulation, likely part of the standard library or an extended library.
* **Import `cmp`:** The import of `cmp` is crucial. It suggests the sorting is based on the `cmp.Ordered` interface, which enables sorting of various comparable types. This is a key piece of information for understanding the code's purpose.

**2. Function-by-Function Analysis (Top-Down):**

I'll go through each function and try to understand its role and algorithm:

* **`insertionSortOrdered`:**  The name is self-explanatory. It's a basic insertion sort algorithm. The inner loop comparing `data[j]` and `data[j-1]` confirms this.
* **`siftDownOrdered`:** This function's name and the logic involving `2*root + 1` strongly suggest it's part of a heap-based sorting algorithm. It's the "downward heapify" operation.
* **`heapSortOrdered`:**  This function clearly implements the heap sort algorithm, using `siftDownOrdered` to build the heap and then extract elements.
* **`pdqsortOrdered`:** The name and the comment referencing a paper and implementations in other languages immediately identify this as an implementation of the "Pattern-Defeating QuickSort" algorithm. The `limit` parameter suggests a fallback mechanism (to heapsort). The variables `wasBalanced` and `wasPartitioned` hint at the adaptive nature of the algorithm.
* **`partitionOrdered`:** This is the standard quicksort partitioning step. It chooses a pivot and arranges the elements such that elements smaller than the pivot are on one side, and larger elements are on the other.
* **`partitionEqualOrdered`:**  This seems like a specialized partition step for when there are many equal elements, partitioning them together.
* **`partialInsertionSortOrdered`:** This function name suggests an optimization. It tries to partially sort the slice and checks if it becomes fully sorted within a limited number of steps. The constants `maxSteps` and `shortestShifting` confirm this.
* **`breakPatternsOrdered`:** This function's name strongly indicates an attempt to disrupt patterns in the data that could lead to poor quicksort performance (e.g., already sorted or reverse sorted data). The use of a random number generator supports this.
* **`choosePivotOrdered`:**  This function is responsible for selecting a good pivot for quicksort. The comments about "median-of-three" and "Tukey ninther" explain the different strategies used depending on the slice size. The return of `sortedHint` provides additional information about the likely sortedness of the data.
* **Helper Functions (`order2Ordered`, `medianOrdered`, `medianAdjacentOrdered`):** These are clearly utilities used by `choosePivotOrdered` to find medians.
* **`reverseRangeOrdered`:**  A simple utility to reverse a portion of the slice.
* **`swapRangeOrdered`:** A utility to swap ranges of elements.
* **`stableOrdered`:** The name and the logic involving `insertionSortOrdered` and `symMergeOrdered` point to a stable sorting algorithm, likely a merge sort variant. The block-wise processing suggests an attempt to optimize the merge process.
* **`symMergeOrdered`:** The comment and the function's logic (especially the reference to the paper) clearly identify this as an implementation of the "SymMerge" algorithm, a stable merge algorithm.
* **`rotateOrdered`:**  A utility function for rotating elements within a slice, often used in merge sort implementations.

**3. Inferring the Go Language Feature:**

Based on the function names, the `cmp.Ordered` constraint, and the overall structure, it's highly likely that this code implements **generic sorting functions for slices of ordered types.** The use of type parameters like `[E cmp.Ordered]` is the key indicator of Go generics.

**4. Code Example and Reasoning:**

I'll create a simple example demonstrating sorting with these functions. The focus will be on showing the usage of the generic functions with different ordered types.

**5. Command-Line Arguments (Not Applicable):**

Since this is a library-level implementation within the `slices` package, it doesn't directly handle command-line arguments. Its functions are meant to be called by other Go code.

**6. Common Mistakes:**

I'll consider potential pitfalls for users. A key one is assuming a specific sorting algorithm is always used when calling a higher-level sorting function. The adaptive nature of `pdqsortOrdered` (and the fallback to heapsort) is important to understand.

**7. Structuring the Answer:**

Finally, I'll organize my findings into a clear and structured answer using the requested format (listing functions, inferring the feature, providing code examples, etc.). I'll ensure the language is clear and concise, and the examples are easy to understand. I will specifically address the "generated code" aspect as it's a crucial piece of context.
这个Go语言实现文件 `zsortordered.go` 是 `slices` 包的一部分，它包含了一系列用于**对切片进行排序**的泛型函数。由于文件名包含 `ordered`，可以推断这些排序函数是针对实现了 `cmp.Ordered` 接口的类型。

**功能列举:**

1. **`insertionSortOrdered[E cmp.Ordered](data []E, a, b int)`:**  对切片 `data` 中索引从 `a` 到 `b-1` 的子切片使用**插入排序**算法进行排序。
2. **`siftDownOrdered[E cmp.Ordered](data []E, lo, hi, first int)`:**  用于实现堆排序的**下沉**操作，维护 `data[lo:hi]` 的堆性质。 `first` 是堆根元素的偏移量。
3. **`heapSortOrdered[E cmp.Ordered](data []E, a, b int)`:** 对切片 `data` 中索引从 `a` 到 `b-1` 的子切片使用**堆排序**算法进行排序。
4. **`pdqsortOrdered[E cmp.Ordered](data []E, a, b, limit int)`:** 对切片 `data` 中索引从 `a` 到 `b-1` 的子切片使用 **pdqsort (Pattern-Defeating QuickSort)** 算法进行排序。`limit` 参数限制了在回退到堆排序之前的坏（非常不平衡的）主元的数量。
5. **`partitionOrdered[E cmp.Ordered](data []E, a, b, pivot int) (newpivot int, alreadyPartitioned bool)`:** 执行一次快速排序的**分区**操作。它会将 `data[a:b]` 中的元素移动，使得小于 `data[pivot]` 的元素在 `newpivot` 之前，大于等于 `data[pivot]` 的元素在 `newpivot` 之后。返回新的主元索引 `newpivot` 以及是否已经完成分区的布尔值。
6. **`partitionEqualOrdered[E cmp.Ordered](data []E, a, b, pivot int) (newpivot int)`:** 将 `data[a:b]` 分区为等于 `data[pivot]` 的元素，然后是大于 `data[pivot]` 的元素。它假设 `data[a:b]` 不包含小于 `data[pivot]` 的元素。
7. **`partialInsertionSortOrdered[E cmp.Ordered](data []E, a, b int) bool`:** 对切片进行**部分插入排序**，如果最终切片已排序，则返回 `true`。
8. **`breakPatternsOrdered[E cmp.Ordered](data []E, a, b int)`:** 通过随机交换一些元素来**打破数据中的模式**，以避免快速排序中出现不平衡的分区。
9. **`choosePivotOrdered[E cmp.Ordered](data []E, a, b int) (pivot int, hint sortedHint)`:** 在 `data[a:b]` 中**选择一个主元**。它会根据切片长度使用不同的策略（静态主元、三数取中、Tukey ninther）。同时返回一个排序提示 `sortedHint`。
10. **`order2Ordered[E cmp.Ordered](data []E, a, b int, swaps *int) (int, int)`:** 返回索引 `x, y`，其中 `data[x] <= data[y]`，其中 `x,y` 是 `a,b` 或 `b,a`。
11. **`medianOrdered[E cmp.Ordered](data []E, a, b, c int, swaps *int) int`:** 返回索引 `x`，其中 `data[x]` 是 `data[a]`, `data[b]`, `data[c]` 的中位数。
12. **`medianAdjacentOrdered[E cmp.Ordered](data []E, a int, swaps *int) int`:** 找到 `data[a - 1]`, `data[a]`, `data[a + 1]` 的中位数，并将索引存储到 `a` 中。
13. **`reverseRangeOrdered[E cmp.Ordered](data []E, a, b int)`:** 反转切片 `data` 中索引从 `a` 到 `b-1` 的元素。
14. **`swapRangeOrdered[E cmp.Ordered](data []E, a, b, n int)`:** 交换切片 `data` 中两个长度为 `n` 的子切片，起始位置分别为 `a` 和 `b`。
15. **`stableOrdered[E cmp.Ordered](data []E, n int)`:** 对切片 `data` 的前 `n` 个元素进行**稳定排序**。
16. **`symMergeOrdered[E cmp.Ordered](data []E, a, m, b int)`:** 使用 SymMerge 算法**合并**两个已排序的子序列 `data[a:m]` 和 `data[m:b]`。
17. **`rotateOrdered[E cmp.Ordered](data []E, a, m, b int)`:** **旋转**切片中的两个连续块 `data[a:m]` 和 `data[m:b]`。

**推断的 Go 语言功能实现：**

这个文件实现的是 Go 语言的**泛型排序功能**，具体来说，是针对实现了 `cmp.Ordered` 接口的类型的切片进行排序。`cmp.Ordered` 是 Go 1.18 引入的泛型约束，表示类型的值可以进行全序比较。

**Go 代码举例说明：**

```go
package main

import (
	"fmt"
	"slices"
)

func main() {
	intSlice := []int{5, 2, 8, 1, 9, 4}
	slices.Sort(intSlice) // 使用 slices.Sort，底层可能会调用 zsortordered.go 中的函数
	fmt.Println("排序后的 int 切片:", intSlice) // 输出: 排序后的 int 切片: [1 2 4 5 8 9]

	stringSlice := []string{"banana", "apple", "cherry"}
	slices.Sort(stringSlice)
	fmt.Println("排序后的 string 切片:", stringSlice) // 输出: 排序后的 string 切片: [apple banana cherry]

	// 自定义结构体并实现排序 (需要实现 Less 方法或使用 cmp 包)
	type Person struct {
		Name string
		Age  int
	}

	people := []Person{
		{"Alice", 30},
		{"Bob", 25},
		{"Charlie", 35},
	}

	// 使用 slices.SortFunc 进行排序
	slices.SortFunc(people, func(a, b Person) int {
		return cmp.Compare(a.Age, b.Age)
	})
	fmt.Println("按年龄排序后的 Person 切片:", people)
	// 输出: 按年龄排序后的 Person 切片: [{Bob 25} {Alice 30} {Charlie 35}]
}
```

**假设的输入与输出：**

以 `pdqsortOrdered` 函数为例：

**假设输入:**

```go
data := []int{5, 2, 8, 1, 9, 4}
a := 0
b := len(data) // 6
limit := 10
```

**推理输出:** (由于 pdqsort 的具体实现细节，这里只能给出排序后的结果)

```go
// 调用 pdqsortOrdered(data, a, b, limit) 后
data == []int{1, 2, 4, 5, 8, 9}
```

**命令行参数的具体处理：**

这个代码片段本身是库代码，不直接处理命令行参数。它提供的排序功能会被其他 Go 程序调用。处理命令行参数通常发生在 `main` 函数中，使用 `os` 包和 `flag` 包等。

**使用者易犯错的点：**

1. **对未实现 `cmp.Ordered` 接口的类型使用排序函数：**

   ```go
   type MyStruct struct {
       Value int
   }

   mySlice := []MyStruct{{1}, {3}, {2}}
   // slices.Sort(mySlice) // 编译错误：MyStruct does not implement cmp.Ordered
   ```
   **解决方法：**  要么让 `MyStruct` 实现 `cmp.Ordered` 接口，要么使用 `slices.SortFunc` 提供自定义的比较函数。

2. **在自定义比较函数中出现不一致的比较逻辑 (使用 `slices.SortFunc`)：** 如果传递给 `slices.SortFunc` 的比较函数没有满足全序关系（例如，对于某些 `a` 和 `b`，`compare(a, b)` 和 `compare(b, a)` 都返回负数），会导致排序结果不可预测甚至程序崩溃。

3. **期望稳定排序但使用了非稳定排序算法 (例如 `slices.Sort` 底层使用的 pdqsort)：**  `slices.Sort` 在大多数情况下提供高性能的排序，但不保证稳定性。如果需要稳定排序，应该使用 `slices.Stable` 函数。

总而言之，`go/src/slices/zsortordered.go` 是 Go 语言标准库中 `slices` 包用于高效排序切片的核心实现，它利用了泛型和多种排序算法（包括 pdqsort、堆排序和插入排序）来优化不同场景下的性能。使用者需要理解类型约束和选择合适的排序函数来避免错误。

### 提示词
```
这是路径为go/src/slices/zsortordered.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
请用中文回答。
```

### 源代码
```go
// Code generated by gen_sort_variants.go; DO NOT EDIT.

// Copyright 2022 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package slices

import "cmp"

// insertionSortOrdered sorts data[a:b] using insertion sort.
func insertionSortOrdered[E cmp.Ordered](data []E, a, b int) {
	for i := a + 1; i < b; i++ {
		for j := i; j > a && cmp.Less(data[j], data[j-1]); j-- {
			data[j], data[j-1] = data[j-1], data[j]
		}
	}
}

// siftDownOrdered implements the heap property on data[lo:hi].
// first is an offset into the array where the root of the heap lies.
func siftDownOrdered[E cmp.Ordered](data []E, lo, hi, first int) {
	root := lo
	for {
		child := 2*root + 1
		if child >= hi {
			break
		}
		if child+1 < hi && cmp.Less(data[first+child], data[first+child+1]) {
			child++
		}
		if !cmp.Less(data[first+root], data[first+child]) {
			return
		}
		data[first+root], data[first+child] = data[first+child], data[first+root]
		root = child
	}
}

func heapSortOrdered[E cmp.Ordered](data []E, a, b int) {
	first := a
	lo := 0
	hi := b - a

	// Build heap with greatest element at top.
	for i := (hi - 1) / 2; i >= 0; i-- {
		siftDownOrdered(data, i, hi, first)
	}

	// Pop elements, largest first, into end of data.
	for i := hi - 1; i >= 0; i-- {
		data[first], data[first+i] = data[first+i], data[first]
		siftDownOrdered(data, lo, i, first)
	}
}

// pdqsortOrdered sorts data[a:b].
// The algorithm based on pattern-defeating quicksort(pdqsort), but without the optimizations from BlockQuicksort.
// pdqsort paper: https://arxiv.org/pdf/2106.05123.pdf
// C++ implementation: https://github.com/orlp/pdqsort
// Rust implementation: https://docs.rs/pdqsort/latest/pdqsort/
// limit is the number of allowed bad (very unbalanced) pivots before falling back to heapsort.
func pdqsortOrdered[E cmp.Ordered](data []E, a, b, limit int) {
	const maxInsertion = 12

	var (
		wasBalanced    = true // whether the last partitioning was reasonably balanced
		wasPartitioned = true // whether the slice was already partitioned
	)

	for {
		length := b - a

		if length <= maxInsertion {
			insertionSortOrdered(data, a, b)
			return
		}

		// Fall back to heapsort if too many bad choices were made.
		if limit == 0 {
			heapSortOrdered(data, a, b)
			return
		}

		// If the last partitioning was imbalanced, we need to breaking patterns.
		if !wasBalanced {
			breakPatternsOrdered(data, a, b)
			limit--
		}

		pivot, hint := choosePivotOrdered(data, a, b)
		if hint == decreasingHint {
			reverseRangeOrdered(data, a, b)
			// The chosen pivot was pivot-a elements after the start of the array.
			// After reversing it is pivot-a elements before the end of the array.
			// The idea came from Rust's implementation.
			pivot = (b - 1) - (pivot - a)
			hint = increasingHint
		}

		// The slice is likely already sorted.
		if wasBalanced && wasPartitioned && hint == increasingHint {
			if partialInsertionSortOrdered(data, a, b) {
				return
			}
		}

		// Probably the slice contains many duplicate elements, partition the slice into
		// elements equal to and elements greater than the pivot.
		if a > 0 && !cmp.Less(data[a-1], data[pivot]) {
			mid := partitionEqualOrdered(data, a, b, pivot)
			a = mid
			continue
		}

		mid, alreadyPartitioned := partitionOrdered(data, a, b, pivot)
		wasPartitioned = alreadyPartitioned

		leftLen, rightLen := mid-a, b-mid
		balanceThreshold := length / 8
		if leftLen < rightLen {
			wasBalanced = leftLen >= balanceThreshold
			pdqsortOrdered(data, a, mid, limit)
			a = mid + 1
		} else {
			wasBalanced = rightLen >= balanceThreshold
			pdqsortOrdered(data, mid+1, b, limit)
			b = mid
		}
	}
}

// partitionOrdered does one quicksort partition.
// Let p = data[pivot]
// Moves elements in data[a:b] around, so that data[i]<p and data[j]>=p for i<newpivot and j>newpivot.
// On return, data[newpivot] = p
func partitionOrdered[E cmp.Ordered](data []E, a, b, pivot int) (newpivot int, alreadyPartitioned bool) {
	data[a], data[pivot] = data[pivot], data[a]
	i, j := a+1, b-1 // i and j are inclusive of the elements remaining to be partitioned

	for i <= j && cmp.Less(data[i], data[a]) {
		i++
	}
	for i <= j && !cmp.Less(data[j], data[a]) {
		j--
	}
	if i > j {
		data[j], data[a] = data[a], data[j]
		return j, true
	}
	data[i], data[j] = data[j], data[i]
	i++
	j--

	for {
		for i <= j && cmp.Less(data[i], data[a]) {
			i++
		}
		for i <= j && !cmp.Less(data[j], data[a]) {
			j--
		}
		if i > j {
			break
		}
		data[i], data[j] = data[j], data[i]
		i++
		j--
	}
	data[j], data[a] = data[a], data[j]
	return j, false
}

// partitionEqualOrdered partitions data[a:b] into elements equal to data[pivot] followed by elements greater than data[pivot].
// It assumed that data[a:b] does not contain elements smaller than the data[pivot].
func partitionEqualOrdered[E cmp.Ordered](data []E, a, b, pivot int) (newpivot int) {
	data[a], data[pivot] = data[pivot], data[a]
	i, j := a+1, b-1 // i and j are inclusive of the elements remaining to be partitioned

	for {
		for i <= j && !cmp.Less(data[a], data[i]) {
			i++
		}
		for i <= j && cmp.Less(data[a], data[j]) {
			j--
		}
		if i > j {
			break
		}
		data[i], data[j] = data[j], data[i]
		i++
		j--
	}
	return i
}

// partialInsertionSortOrdered partially sorts a slice, returns true if the slice is sorted at the end.
func partialInsertionSortOrdered[E cmp.Ordered](data []E, a, b int) bool {
	const (
		maxSteps         = 5  // maximum number of adjacent out-of-order pairs that will get shifted
		shortestShifting = 50 // don't shift any elements on short arrays
	)
	i := a + 1
	for j := 0; j < maxSteps; j++ {
		for i < b && !cmp.Less(data[i], data[i-1]) {
			i++
		}

		if i == b {
			return true
		}

		if b-a < shortestShifting {
			return false
		}

		data[i], data[i-1] = data[i-1], data[i]

		// Shift the smaller one to the left.
		if i-a >= 2 {
			for j := i - 1; j >= 1; j-- {
				if !cmp.Less(data[j], data[j-1]) {
					break
				}
				data[j], data[j-1] = data[j-1], data[j]
			}
		}
		// Shift the greater one to the right.
		if b-i >= 2 {
			for j := i + 1; j < b; j++ {
				if !cmp.Less(data[j], data[j-1]) {
					break
				}
				data[j], data[j-1] = data[j-1], data[j]
			}
		}
	}
	return false
}

// breakPatternsOrdered scatters some elements around in an attempt to break some patterns
// that might cause imbalanced partitions in quicksort.
func breakPatternsOrdered[E cmp.Ordered](data []E, a, b int) {
	length := b - a
	if length >= 8 {
		random := xorshift(length)
		modulus := nextPowerOfTwo(length)

		for idx := a + (length/4)*2 - 1; idx <= a+(length/4)*2+1; idx++ {
			other := int(uint(random.Next()) & (modulus - 1))
			if other >= length {
				other -= length
			}
			data[idx], data[a+other] = data[a+other], data[idx]
		}
	}
}

// choosePivotOrdered chooses a pivot in data[a:b].
//
// [0,8): chooses a static pivot.
// [8,shortestNinther): uses the simple median-of-three method.
// [shortestNinther,∞): uses the Tukey ninther method.
func choosePivotOrdered[E cmp.Ordered](data []E, a, b int) (pivot int, hint sortedHint) {
	const (
		shortestNinther = 50
		maxSwaps        = 4 * 3
	)

	l := b - a

	var (
		swaps int
		i     = a + l/4*1
		j     = a + l/4*2
		k     = a + l/4*3
	)

	if l >= 8 {
		if l >= shortestNinther {
			// Tukey ninther method, the idea came from Rust's implementation.
			i = medianAdjacentOrdered(data, i, &swaps)
			j = medianAdjacentOrdered(data, j, &swaps)
			k = medianAdjacentOrdered(data, k, &swaps)
		}
		// Find the median among i, j, k and stores it into j.
		j = medianOrdered(data, i, j, k, &swaps)
	}

	switch swaps {
	case 0:
		return j, increasingHint
	case maxSwaps:
		return j, decreasingHint
	default:
		return j, unknownHint
	}
}

// order2Ordered returns x,y where data[x] <= data[y], where x,y=a,b or x,y=b,a.
func order2Ordered[E cmp.Ordered](data []E, a, b int, swaps *int) (int, int) {
	if cmp.Less(data[b], data[a]) {
		*swaps++
		return b, a
	}
	return a, b
}

// medianOrdered returns x where data[x] is the median of data[a],data[b],data[c], where x is a, b, or c.
func medianOrdered[E cmp.Ordered](data []E, a, b, c int, swaps *int) int {
	a, b = order2Ordered(data, a, b, swaps)
	b, c = order2Ordered(data, b, c, swaps)
	a, b = order2Ordered(data, a, b, swaps)
	return b
}

// medianAdjacentOrdered finds the median of data[a - 1], data[a], data[a + 1] and stores the index into a.
func medianAdjacentOrdered[E cmp.Ordered](data []E, a int, swaps *int) int {
	return medianOrdered(data, a-1, a, a+1, swaps)
}

func reverseRangeOrdered[E cmp.Ordered](data []E, a, b int) {
	i := a
	j := b - 1
	for i < j {
		data[i], data[j] = data[j], data[i]
		i++
		j--
	}
}

func swapRangeOrdered[E cmp.Ordered](data []E, a, b, n int) {
	for i := 0; i < n; i++ {
		data[a+i], data[b+i] = data[b+i], data[a+i]
	}
}

func stableOrdered[E cmp.Ordered](data []E, n int) {
	blockSize := 20 // must be > 0
	a, b := 0, blockSize
	for b <= n {
		insertionSortOrdered(data, a, b)
		a = b
		b += blockSize
	}
	insertionSortOrdered(data, a, n)

	for blockSize < n {
		a, b = 0, 2*blockSize
		for b <= n {
			symMergeOrdered(data, a, a+blockSize, b)
			a = b
			b += 2 * blockSize
		}
		if m := a + blockSize; m < n {
			symMergeOrdered(data, a, m, n)
		}
		blockSize *= 2
	}
}

// symMergeOrdered merges the two sorted subsequences data[a:m] and data[m:b] using
// the SymMerge algorithm from Pok-Son Kim and Arne Kutzner, "Stable Minimum
// Storage Merging by Symmetric Comparisons", in Susanne Albers and Tomasz
// Radzik, editors, Algorithms - ESA 2004, volume 3221 of Lecture Notes in
// Computer Science, pages 714-723. Springer, 2004.
//
// Let M = m-a and N = b-n. Wolog M < N.
// The recursion depth is bound by ceil(log(N+M)).
// The algorithm needs O(M*log(N/M + 1)) calls to data.Less.
// The algorithm needs O((M+N)*log(M)) calls to data.Swap.
//
// The paper gives O((M+N)*log(M)) as the number of assignments assuming a
// rotation algorithm which uses O(M+N+gcd(M+N)) assignments. The argumentation
// in the paper carries through for Swap operations, especially as the block
// swapping rotate uses only O(M+N) Swaps.
//
// symMerge assumes non-degenerate arguments: a < m && m < b.
// Having the caller check this condition eliminates many leaf recursion calls,
// which improves performance.
func symMergeOrdered[E cmp.Ordered](data []E, a, m, b int) {
	// Avoid unnecessary recursions of symMerge
	// by direct insertion of data[a] into data[m:b]
	// if data[a:m] only contains one element.
	if m-a == 1 {
		// Use binary search to find the lowest index i
		// such that data[i] >= data[a] for m <= i < b.
		// Exit the search loop with i == b in case no such index exists.
		i := m
		j := b
		for i < j {
			h := int(uint(i+j) >> 1)
			if cmp.Less(data[h], data[a]) {
				i = h + 1
			} else {
				j = h
			}
		}
		// Swap values until data[a] reaches the position before i.
		for k := a; k < i-1; k++ {
			data[k], data[k+1] = data[k+1], data[k]
		}
		return
	}

	// Avoid unnecessary recursions of symMerge
	// by direct insertion of data[m] into data[a:m]
	// if data[m:b] only contains one element.
	if b-m == 1 {
		// Use binary search to find the lowest index i
		// such that data[i] > data[m] for a <= i < m.
		// Exit the search loop with i == m in case no such index exists.
		i := a
		j := m
		for i < j {
			h := int(uint(i+j) >> 1)
			if !cmp.Less(data[m], data[h]) {
				i = h + 1
			} else {
				j = h
			}
		}
		// Swap values until data[m] reaches the position i.
		for k := m; k > i; k-- {
			data[k], data[k-1] = data[k-1], data[k]
		}
		return
	}

	mid := int(uint(a+b) >> 1)
	n := mid + m
	var start, r int
	if m > mid {
		start = n - b
		r = mid
	} else {
		start = a
		r = m
	}
	p := n - 1

	for start < r {
		c := int(uint(start+r) >> 1)
		if !cmp.Less(data[p-c], data[c]) {
			start = c + 1
		} else {
			r = c
		}
	}

	end := n - start
	if start < m && m < end {
		rotateOrdered(data, start, m, end)
	}
	if a < start && start < mid {
		symMergeOrdered(data, a, start, mid)
	}
	if mid < end && end < b {
		symMergeOrdered(data, mid, end, b)
	}
}

// rotateOrdered rotates two consecutive blocks u = data[a:m] and v = data[m:b] in data:
// Data of the form 'x u v y' is changed to 'x v u y'.
// rotate performs at most b-a many calls to data.Swap,
// and it assumes non-degenerate arguments: a < m && m < b.
func rotateOrdered[E cmp.Ordered](data []E, a, m, b int) {
	i := m - a
	j := b - m

	for i != j {
		if i > j {
			swapRangeOrdered(data, m-i, m, j)
			i -= j
		} else {
			swapRangeOrdered(data, m-i, m+j-i, i)
			j -= i
		}
	}
	// i == j
	swapRangeOrdered(data, m-i, m, i)
}
```
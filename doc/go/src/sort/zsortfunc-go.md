Response:
Let's break down the thought process for analyzing the provided Go code snippet.

1. **Initial Observation and Context:** The first line "// Code generated by gen_sort_variants.go; DO NOT EDIT." immediately tells us this is automatically generated code. This suggests it's likely part of a larger sorting implementation where different sorting algorithms or variations are generated programmatically. The `package sort` declaration confirms it's within the standard `sort` package in Go.

2. **Core Functionality Identification:**  The names of the functions are highly indicative of their purpose:
    * `insertionSort_func`:  Clearly an insertion sort implementation.
    * `siftDown_func`: A helper function for heap-based sorting, used to maintain the heap property.
    * `heapSort_func`:  Implements heap sort.
    * `pdqsort_func`:  Indicates an implementation of "Pattern-Defeating QuickSort" (pdqsort), a more advanced quicksort variant. The comments provide links to research papers and other implementations, which is very helpful.
    * `partition_func`:  The core partitioning step in quicksort.
    * `partitionEqual_func`:  A specialized partitioning for elements equal to the pivot, useful for handling duplicates.
    * `partialInsertionSort_func`:  A hybrid approach that attempts to sort partially and checks if the array becomes fully sorted.
    * `breakPatterns_func`:  A strategy to randomize elements to avoid worst-case scenarios in quicksort.
    * `choosePivot_func`:  Selects a pivot element for quicksort, employing different strategies based on the slice size.
    * `order2_func`, `median_func`, `medianAdjacent_func`: Helper functions for pivot selection, specifically finding medians.
    * `reverseRange_func`, `swapRange_func`: Utility functions for manipulating slices.
    * `stable_func`:  Implements a stable sorting algorithm (likely merge sort based).
    * `symMerge_func`: The merge step in merge sort.
    * `rotate_func`:  A function to rotate elements within a slice.

3. **Grouping and High-Level Understanding:**  We can group these functions into logical units related to sorting algorithms:
    * **Simple Sorts:** `insertionSort_func`
    * **Heap Sort:** `siftDown_func`, `heapSort_func`
    * **Quick Sort (and Variations):** `pdqsort_func`, `partition_func`, `partitionEqual_func`, `partialInsertionSort_func`, `breakPatterns_func`, `choosePivot_func`, `order2_func`, `median_func`, `medianAdjacent_func`
    * **Merge Sort (Stable Sort):** `stable_func`, `symMerge_func`, `rotate_func`, `swapRange_func`
    * **Utilities:** `reverseRange_func`, `swapRange_func`

4. **Deeper Dive into `pdqsort_func`:**  This function is clearly the most complex and likely the primary sorting algorithm used. The comments mention "pattern-defeating quicksort" and provide links, which is crucial for understanding its design goals. The logic involves:
    * Checking for small sizes and using insertion sort.
    * Falling back to heap sort if pivot selection is consistently poor.
    * Employing strategies to avoid bad pivot choices (`breakPatterns_func`).
    * Using different pivot selection methods (`choosePivot_func`).
    * Handling potential already-sorted or partially-sorted data (`partialInsertionSort_func`).
    * Optimizing for slices with many duplicate elements (`partitionEqual_func`).
    * Recursively sorting sub-partitions.

5. **Inferring the Overall Purpose:** Given the presence of multiple sorting algorithms (insertion sort, heap sort, quicksort variant, merge sort), the file likely contributes to a generic `Sort` function within the `sort` package. This generic function probably selects the most appropriate sorting algorithm based on the input data characteristics. The `zsortfunc.go` naming suggests it might be one of several files containing implementations of different sorting strategies, potentially generated for different data types or comparison methods.

6. **Code Example Construction (for `pdqsort_func`):** To demonstrate `pdqsort_func`, we need to create a type that implements the `lessSwap` interface. This involves a slice of some comparable type and the `Less` and `Swap` methods. Then, we can call `pdqsort_func` on an instance of this type. The example should show a basic case and demonstrate the expected sorting behavior.

7. **Input/Output and Assumptions:** For the code example, the input is the unsorted slice, and the output is the sorted slice. The key assumption is that the provided `lessSwap` implementation correctly defines the ordering of elements.

8. **Command-Line Arguments:** Since this is a core library file within the `sort` package, it doesn't directly handle command-line arguments. The `sort` package's command-line utility (`sort`) is a separate program that uses this library.

9. **Common Mistakes:**  A potential mistake for users of the `sort` package (not necessarily *this specific file*) is not understanding the stability of different sorting algorithms. `pdqsort` is generally not stable, while `stable_func` implements a stable sort. Another mistake is assuming the default `sort.Slice` function uses a specific algorithm when the implementation might change.

10. **Refinement and Structuring the Answer:**  Finally, organize the findings into a clear and logical structure, addressing each point of the prompt: functionality, inferred purpose, code examples, assumptions, command-line arguments, and common mistakes. Use clear and concise language, and provide illustrative examples.

By following these steps, we can systematically analyze the code snippet and arrive at a comprehensive understanding of its purpose and functionality within the broader context of the Go `sort` package.
这段代码是 Go 语言标准库 `sort` 包中与排序功能实现相关的一部分，具体来说，它定义和实现了多个用于排序的辅助函数和一个主要的排序算法 `pdqsort_func`。由于文件名包含 `zsortfunc`, 这暗示它是自动生成的代码，可能用于处理特定的数据类型或排序需求。

以下是代码中各个函数的功能：

1. **`insertionSort_func(data lessSwap, a, b int)`**:  对 `data` 中索引从 `a` 到 `b-1` 的元素使用插入排序算法进行排序。插入排序适用于小规模或者基本有序的数据。

2. **`siftDown_func(data lessSwap, lo, hi, first int)`**:  用于实现堆的性质。它将 `data` 中 `lo` 到 `hi-1` 的元素看作一个堆，并将索引为 `first + lo` 的元素向下调整，以满足堆的性质（父节点的值大于或等于子节点的值，对于最大堆）。这个函数是堆排序的辅助函数。

3. **`heapSort_func(data lessSwap, a, b int)`**: 对 `data` 中索引从 `a` 到 `b-1` 的元素使用堆排序算法进行排序。堆排序是一种原地排序算法，效率相对稳定。

4. **`pdqsort_func(data lessSwap, a, b, limit int)`**: 这是这段代码的核心，实现了 **Pattern-Defeating Quicksort (pdqsort)** 算法。pdqsort 是一种优化的快速排序算法，旨在避免传统快速排序在特定输入下的性能退化。
    *   它首先会检查待排序的切片长度，如果很小，则使用插入排序。
    *   如果连续遇到不好的 pivot 选择次数超过 `limit`，则会退化到堆排序，保证最坏情况下的时间复杂度。
    *   它会尝试检测数据中的模式，并采取措施打断这些模式，以避免产生不平衡的 partition。
    *   它使用 `choosePivot_func` 来选择 pivot 元素，并且根据情况可能反转部分切片。
    *   它还会检测切片是否已经部分排序，如果是，则可能使用 `partialInsertionSort_func` 进行优化。
    *   如果检测到大量重复元素，则使用 `partitionEqual_func` 进行优化。
    *   最后，它使用 `partition_func` 进行 partition，并递归地对子切片进行排序。

5. **`partition_func(data lessSwap, a, b, pivot int)`**:  执行快速排序的一次 partition 操作。它选择 `data[pivot]` 作为 pivot 元素，并将 `data` 中索引从 `a` 到 `b-1` 的元素重新排列，使得小于 pivot 的元素位于 pivot 的左边，大于或等于 pivot 的元素位于 pivot 的右边。返回新的 pivot 索引和是否已经完成 partition 的布尔值。

6. **`partitionEqual_func(data lessSwap, a, b, pivot int)`**:  专门用于处理包含大量重复元素的情况。它将 `data` 中索引从 `a` 到 `b-1` 的元素分割成两部分：等于 `data[pivot]` 的元素在前，大于 `data[pivot]` 的元素在后。它假设待分割的切片不包含小于 `data[pivot]` 的元素。

7. **`partialInsertionSort_func(data lessSwap, a, b int)`**:  尝试部分地进行插入排序。如果切片在少量步骤内变得有序，则返回 `true`，否则返回 `false`。这用于优化那些已经部分排序的切片。

8. **`breakPatterns_func(data lessSwap, a, b int)`**:  用于打断数据中的某些模式，这些模式可能导致快速排序 partition 不平衡。它通过随机交换一些元素的位置来实现。

9. **`choosePivot_func(data lessSwap, a, b int)`**:  负责选择快速排序的 pivot 元素。它会根据切片的长度选择不同的策略：
    *   对于小切片，选择静态的 pivot。
    *   对于中等大小的切片，使用 median-of-three 方法选择 pivot。
    *   对于较大的切片，使用 Tukey ninther 方法选择 pivot。
    它还会返回一个 `sortedHint`，指示数据可能是有序的还是逆序的。

10. **`order2_func(data lessSwap, a, b int, swaps *int)`**:  一个辅助函数，用于比较 `data[a]` 和 `data[b]`，并返回较小值的索引和较大值的索引。如果发生了交换，则递增 `swaps` 计数器。

11. **`median_func(data lessSwap, a, b, c int, swaps *int)`**:  返回 `data[a]`、`data[b]` 和 `data[c]` 的中位数对应的索引。

12. **`medianAdjacent_func(data lessSwap, a int, swaps *int)`**:  返回 `data[a-1]`、`data[a]` 和 `data[a+1]` 的中位数对应的索引。

13. **`reverseRange_func(data lessSwap, a, b int)`**:  反转 `data` 中索引从 `a` 到 `b-1` 的元素。

14. **`swapRange_func(data lessSwap, a, b, n int)`**:  交换 `data` 中两个相邻的长度为 `n` 的切片，起始位置分别为 `a` 和 `b`。

15. **`stable_func(data lessSwap, n int)`**:  实现稳定的排序算法，这里使用的是基于归并排序的变体。它首先使用插入排序对小块数据进行排序，然后逐步合并这些块。

16. **`symMerge_func(data lessSwap, a, m, b int)`**:  实现了 SymMerge 算法，用于合并两个已排序的子序列 `data[a:m]` 和 `data[m:b]`。SymMerge 是一种稳定的、最小额外空间的归并算法。

17. **`rotate_func(data lessSwap, a, m, b int)`**:  将 `data` 中两个连续的块 `data[a:m]` 和 `data[m:b]` 进行旋转，即将 `x u v y` 变为 `x v u y`。

**推断 Go 语言功能的实现：**

这段代码是 Go 语言 `sort` 包中用于实现通用排序功能的底层实现。Go 的 `sort` 包提供了一系列用于排序切片和用户自定义集合的函数。`zsortfunc.go` 文件中的这些函数，特别是 `pdqsort_func` 和 `stable_func`，是实现 `sort.Slice` 等通用排序函数的核心 building blocks。

`sort.Slice` 函数允许用户使用自定义的 less 函数对任意类型的切片进行排序。`zsortfunc.go` 中的这些函数需要能够处理不同的比较逻辑，这就是为什么它们都接受一个 `lessSwap` 接口类型的参数。

**`lessSwap` 接口的定义（虽然代码中没有直接给出，但可以推断）：**

```go
type lessSwap interface {
	Len() int
	Less(i, j int) bool // data[i] < data[j]
	Swap(i, j int)      // 交換 data[i] 和 data[j]
}
```

`sort.Slice` 函数会接收一个切片和一个比较函数，然后内部会创建一个实现了 `lessSwap` 接口的适配器，将比较函数转换为 `Less` 方法。

**Go 代码举例说明：**

```go
package main

import (
	"fmt"
	"sort"
)

type Person struct {
	Name string
	Age  int
}

// ByAge implements sort.Interface for []Person based on the Age field.
type ByAge []Person

func (a ByAge) Len() int           { return len(a) }
func (a ByAge) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a ByAge) Less(i, j int) bool { return a[i].Age < a[j].Age }

func main() {
	people := []Person{
		{"Alice", 30},
		{"Bob", 20},
		{"Charlie", 25},
	}

	// 使用 sort.Sort 和自定义的排序类型进行排序
	sort.Sort(ByAge(people))
	fmt.Println("Sorted by age (using sort.Sort):", people)

	// 使用 sort.Slice 和匿名函数进行排序（更常用）
	people2 := []Person{
		{"Alice", 30},
		{"Bob", 20},
		{"Charlie", 25},
	}
	sort.Slice(people2, func(i, j int) bool {
		return people2[i].Age < people2[j].Age
	})
	fmt.Println("Sorted by age (using sort.Slice):", people2)

	// 使用 sort.Slice 按照名字排序
	people3 := []Person{
		{"Alice", 30},
		{"Bob", 20},
		{"Charlie", 25},
	}
	sort.Slice(people3, func(i, j int) bool {
		return people3[i].Name < people3[j].Name
	})
	fmt.Println("Sorted by name (using sort.Slice):", people3)
}
```

**假设的输入与输出：**

在上面的 `main` 函数的例子中：

*   **输入 `people`**: `[]Person{{"Alice", 30}, {"Bob", 20}, {"Charlie", 25}}`
*   **输出 (使用 `sort.Sort(ByAge(people))`):** `[]Person{{"Bob", 20}, {"Charlie", 25}, {"Alice", 30}}`

*   **输入 `people2`**: `[]Person{{"Alice", 30}, {"Bob", 20}, {"Charlie", 25}}`
*   **输出 (使用 `sort.Slice` 按照年龄排序):** `[]Person{{"Bob", 20}, {"Charlie", 25}, {"Alice", 30}}`

*   **输入 `people3`**: `[]Person{{"Alice", 30}, {"Bob", 20}, {"Charlie", 25}}`
*   **输出 (使用 `sort.Slice` 按照名字排序):** `[]Person{{"Alice", 30}, {"Bob", 20}, {"Charlie", 25}}`

**命令行参数的具体处理：**

`zsortfunc.go` 文件本身并不直接处理命令行参数。它是 `sort` 标准库的一部分，供其他 Go 程序使用。如果你想对命令行输入的数据进行排序，你需要编写一个 Go 程序，该程序会读取命令行参数或标准输入，然后使用 `sort` 包中的函数进行排序。

例如，一个简单的命令行排序程序可能如下所示：

```go
package main

import (
	"fmt"
	"os"
	"sort"
	"strconv"
)

func main() {
	if len(os.Args) <= 1 {
		fmt.Println("Usage: sort_numbers <number1> <number2> ...")
		return
	}

	numbers := make([]int, 0, len(os.Args)-1)
	for i := 1; i < len(os.Args); i++ {
		num, err := strconv.Atoi(os.Args[i])
		if err != nil {
			fmt.Fprintf(os.Stderr, "Invalid number: %s\n", os.Args[i])
			return
		}
		numbers = append(numbers, num)
	}

	sort.Ints(numbers) // 使用 sort 包中的 Ints 函数
	fmt.Println("Sorted numbers:", numbers)
}
```

在这个程序中，命令行参数被解析为整数，然后使用 `sort.Ints` 函数进行排序。`sort.Ints` 内部会使用类似 `zsortfunc.go` 中实现的排序算法。

**使用者易犯错的点：**

1. **没有理解排序的稳定性：** 某些排序算法（如 `stable_func` 实现的）是稳定的，这意味着相等元素的相对顺序在排序后保持不变。而 `pdqsort_func` 实现的快速排序通常不是稳定的。如果元素的相等性是基于部分属性，而需要保持原有顺序，则需要选择稳定的排序算法。

    ```go
    package main

    import (
        "fmt"
        "sort"
    )

    type Item struct {
        ID    int
        Value string
    }

    func main() {
        items := []Item{
            {1, "b"},
            {2, "a"},
            {3, "b"},
        }

        // 按照 Value 排序，但 ID 的顺序可能会改变（不稳定排序）
        sort.Slice(items, func(i, j int) bool {
            return items[i].Value < items[j].Value
        })
        fmt.Println("Unstable sort:", items) // 可能输出: [{2 a} {1 b} {3 b}] 或 [{2 a} {3 b} {1 b}]

        items2 := []Item{
            {1, "b"},
            {2, "a"},
            {3, "b"},
        }

        // 这里没有直接提供稳定的 Slice 方法，但可以使用其他方法实现稳定的排序
        // 一种方法是使用 sort.SliceStable (Go 1.9+)
        sort.SliceStable(items2, func(i, j int) bool {
            return items2[i].Value < items2[j].Value
        })
        fmt.Println("Stable sort:", items2) // 输出: [{2 a} {1 b} {3 b}]，保证 ID 为 1 的 "b" 在 ID 为 3 的 "b" 前面
    }
    ```

2. **自定义排序逻辑错误：** 在使用 `sort.Slice` 提供自定义的 less 函数时，如果 less 函数的逻辑不正确（例如，不满足全序关系），会导致排序结果不正确或程序 panic。

    ```go
    package main

    import (
        "fmt"
        "sort"
    )

    func main() {
        numbers := []int{3, 1, 4, 1, 5, 9, 2, 6}

        // 错误的 less 函数，不满足传递性
        sort.Slice(numbers, func(i, j int) bool {
            return numbers[i] < numbers[j] || numbers[i] == numbers[j] // 错误：相等时返回 true
        })
        fmt.Println("Incorrectly sorted numbers:", numbers) // 结果可能不符合预期
    }
    ```

总而言之，`go/src/sort/zsortfunc.go` 文件是 Go 语言 `sort` 包中实现各种排序算法的核心代码，它通过提供高效的排序功能，为 Go 程序的性能优化提供了基础。使用者可以通过 `sort` 包提供的上层 API（如 `sort.Slice`、`sort.Ints` 等）方便地使用这些底层的排序实现。

Prompt: 
```
这是路径为go/src/sort/zsortfunc.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
请用中文回答。

"""
// Code generated by gen_sort_variants.go; DO NOT EDIT.

// Copyright 2022 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package sort

// insertionSort_func sorts data[a:b] using insertion sort.
func insertionSort_func(data lessSwap, a, b int) {
	for i := a + 1; i < b; i++ {
		for j := i; j > a && data.Less(j, j-1); j-- {
			data.Swap(j, j-1)
		}
	}
}

// siftDown_func implements the heap property on data[lo:hi].
// first is an offset into the array where the root of the heap lies.
func siftDown_func(data lessSwap, lo, hi, first int) {
	root := lo
	for {
		child := 2*root + 1
		if child >= hi {
			break
		}
		if child+1 < hi && data.Less(first+child, first+child+1) {
			child++
		}
		if !data.Less(first+root, first+child) {
			return
		}
		data.Swap(first+root, first+child)
		root = child
	}
}

func heapSort_func(data lessSwap, a, b int) {
	first := a
	lo := 0
	hi := b - a

	// Build heap with greatest element at top.
	for i := (hi - 1) / 2; i >= 0; i-- {
		siftDown_func(data, i, hi, first)
	}

	// Pop elements, largest first, into end of data.
	for i := hi - 1; i >= 0; i-- {
		data.Swap(first, first+i)
		siftDown_func(data, lo, i, first)
	}
}

// pdqsort_func sorts data[a:b].
// The algorithm based on pattern-defeating quicksort(pdqsort), but without the optimizations from BlockQuicksort.
// pdqsort paper: https://arxiv.org/pdf/2106.05123.pdf
// C++ implementation: https://github.com/orlp/pdqsort
// Rust implementation: https://docs.rs/pdqsort/latest/pdqsort/
// limit is the number of allowed bad (very unbalanced) pivots before falling back to heapsort.
func pdqsort_func(data lessSwap, a, b, limit int) {
	const maxInsertion = 12

	var (
		wasBalanced    = true // whether the last partitioning was reasonably balanced
		wasPartitioned = true // whether the slice was already partitioned
	)

	for {
		length := b - a

		if length <= maxInsertion {
			insertionSort_func(data, a, b)
			return
		}

		// Fall back to heapsort if too many bad choices were made.
		if limit == 0 {
			heapSort_func(data, a, b)
			return
		}

		// If the last partitioning was imbalanced, we need to breaking patterns.
		if !wasBalanced {
			breakPatterns_func(data, a, b)
			limit--
		}

		pivot, hint := choosePivot_func(data, a, b)
		if hint == decreasingHint {
			reverseRange_func(data, a, b)
			// The chosen pivot was pivot-a elements after the start of the array.
			// After reversing it is pivot-a elements before the end of the array.
			// The idea came from Rust's implementation.
			pivot = (b - 1) - (pivot - a)
			hint = increasingHint
		}

		// The slice is likely already sorted.
		if wasBalanced && wasPartitioned && hint == increasingHint {
			if partialInsertionSort_func(data, a, b) {
				return
			}
		}

		// Probably the slice contains many duplicate elements, partition the slice into
		// elements equal to and elements greater than the pivot.
		if a > 0 && !data.Less(a-1, pivot) {
			mid := partitionEqual_func(data, a, b, pivot)
			a = mid
			continue
		}

		mid, alreadyPartitioned := partition_func(data, a, b, pivot)
		wasPartitioned = alreadyPartitioned

		leftLen, rightLen := mid-a, b-mid
		balanceThreshold := length / 8
		if leftLen < rightLen {
			wasBalanced = leftLen >= balanceThreshold
			pdqsort_func(data, a, mid, limit)
			a = mid + 1
		} else {
			wasBalanced = rightLen >= balanceThreshold
			pdqsort_func(data, mid+1, b, limit)
			b = mid
		}
	}
}

// partition_func does one quicksort partition.
// Let p = data[pivot]
// Moves elements in data[a:b] around, so that data[i]<p and data[j]>=p for i<newpivot and j>newpivot.
// On return, data[newpivot] = p
func partition_func(data lessSwap, a, b, pivot int) (newpivot int, alreadyPartitioned bool) {
	data.Swap(a, pivot)
	i, j := a+1, b-1 // i and j are inclusive of the elements remaining to be partitioned

	for i <= j && data.Less(i, a) {
		i++
	}
	for i <= j && !data.Less(j, a) {
		j--
	}
	if i > j {
		data.Swap(j, a)
		return j, true
	}
	data.Swap(i, j)
	i++
	j--

	for {
		for i <= j && data.Less(i, a) {
			i++
		}
		for i <= j && !data.Less(j, a) {
			j--
		}
		if i > j {
			break
		}
		data.Swap(i, j)
		i++
		j--
	}
	data.Swap(j, a)
	return j, false
}

// partitionEqual_func partitions data[a:b] into elements equal to data[pivot] followed by elements greater than data[pivot].
// It assumed that data[a:b] does not contain elements smaller than the data[pivot].
func partitionEqual_func(data lessSwap, a, b, pivot int) (newpivot int) {
	data.Swap(a, pivot)
	i, j := a+1, b-1 // i and j are inclusive of the elements remaining to be partitioned

	for {
		for i <= j && !data.Less(a, i) {
			i++
		}
		for i <= j && data.Less(a, j) {
			j--
		}
		if i > j {
			break
		}
		data.Swap(i, j)
		i++
		j--
	}
	return i
}

// partialInsertionSort_func partially sorts a slice, returns true if the slice is sorted at the end.
func partialInsertionSort_func(data lessSwap, a, b int) bool {
	const (
		maxSteps         = 5  // maximum number of adjacent out-of-order pairs that will get shifted
		shortestShifting = 50 // don't shift any elements on short arrays
	)
	i := a + 1
	for j := 0; j < maxSteps; j++ {
		for i < b && !data.Less(i, i-1) {
			i++
		}

		if i == b {
			return true
		}

		if b-a < shortestShifting {
			return false
		}

		data.Swap(i, i-1)

		// Shift the smaller one to the left.
		if i-a >= 2 {
			for j := i - 1; j >= 1; j-- {
				if !data.Less(j, j-1) {
					break
				}
				data.Swap(j, j-1)
			}
		}
		// Shift the greater one to the right.
		if b-i >= 2 {
			for j := i + 1; j < b; j++ {
				if !data.Less(j, j-1) {
					break
				}
				data.Swap(j, j-1)
			}
		}
	}
	return false
}

// breakPatterns_func scatters some elements around in an attempt to break some patterns
// that might cause imbalanced partitions in quicksort.
func breakPatterns_func(data lessSwap, a, b int) {
	length := b - a
	if length >= 8 {
		random := xorshift(length)
		modulus := nextPowerOfTwo(length)

		for idx := a + (length/4)*2 - 1; idx <= a+(length/4)*2+1; idx++ {
			other := int(uint(random.Next()) & (modulus - 1))
			if other >= length {
				other -= length
			}
			data.Swap(idx, a+other)
		}
	}
}

// choosePivot_func chooses a pivot in data[a:b].
//
// [0,8): chooses a static pivot.
// [8,shortestNinther): uses the simple median-of-three method.
// [shortestNinther,∞): uses the Tukey ninther method.
func choosePivot_func(data lessSwap, a, b int) (pivot int, hint sortedHint) {
	const (
		shortestNinther = 50
		maxSwaps        = 4 * 3
	)

	l := b - a

	var (
		swaps int
		i     = a + l/4*1
		j     = a + l/4*2
		k     = a + l/4*3
	)

	if l >= 8 {
		if l >= shortestNinther {
			// Tukey ninther method, the idea came from Rust's implementation.
			i = medianAdjacent_func(data, i, &swaps)
			j = medianAdjacent_func(data, j, &swaps)
			k = medianAdjacent_func(data, k, &swaps)
		}
		// Find the median among i, j, k and stores it into j.
		j = median_func(data, i, j, k, &swaps)
	}

	switch swaps {
	case 0:
		return j, increasingHint
	case maxSwaps:
		return j, decreasingHint
	default:
		return j, unknownHint
	}
}

// order2_func returns x,y where data[x] <= data[y], where x,y=a,b or x,y=b,a.
func order2_func(data lessSwap, a, b int, swaps *int) (int, int) {
	if data.Less(b, a) {
		*swaps++
		return b, a
	}
	return a, b
}

// median_func returns x where data[x] is the median of data[a],data[b],data[c], where x is a, b, or c.
func median_func(data lessSwap, a, b, c int, swaps *int) int {
	a, b = order2_func(data, a, b, swaps)
	b, c = order2_func(data, b, c, swaps)
	a, b = order2_func(data, a, b, swaps)
	return b
}

// medianAdjacent_func finds the median of data[a - 1], data[a], data[a + 1] and stores the index into a.
func medianAdjacent_func(data lessSwap, a int, swaps *int) int {
	return median_func(data, a-1, a, a+1, swaps)
}

func reverseRange_func(data lessSwap, a, b int) {
	i := a
	j := b - 1
	for i < j {
		data.Swap(i, j)
		i++
		j--
	}
}

func swapRange_func(data lessSwap, a, b, n int) {
	for i := 0; i < n; i++ {
		data.Swap(a+i, b+i)
	}
}

func stable_func(data lessSwap, n int) {
	blockSize := 20 // must be > 0
	a, b := 0, blockSize
	for b <= n {
		insertionSort_func(data, a, b)
		a = b
		b += blockSize
	}
	insertionSort_func(data, a, n)

	for blockSize < n {
		a, b = 0, 2*blockSize
		for b <= n {
			symMerge_func(data, a, a+blockSize, b)
			a = b
			b += 2 * blockSize
		}
		if m := a + blockSize; m < n {
			symMerge_func(data, a, m, n)
		}
		blockSize *= 2
	}
}

// symMerge_func merges the two sorted subsequences data[a:m] and data[m:b] using
// the SymMerge algorithm from Pok-Son Kim and Arne Kutzner, "Stable Minimum
// Storage Merging by Symmetric Comparisons", in Susanne Albers and Tomasz
// Radzik, editors, Algorithms - ESA 2004, volume 3221 of Lecture Notes in
// Computer Science, pages 714-723. Springer, 2004.
//
// Let M = m-a and N = b-n. Wolog M < N.
// The recursion depth is bound by ceil(log(N+M)).
// The algorithm needs O(M*log(N/M + 1)) calls to data.Less.
// The algorithm needs O((M+N)*log(M)) calls to data.Swap.
//
// The paper gives O((M+N)*log(M)) as the number of assignments assuming a
// rotation algorithm which uses O(M+N+gcd(M+N)) assignments. The argumentation
// in the paper carries through for Swap operations, especially as the block
// swapping rotate uses only O(M+N) Swaps.
//
// symMerge assumes non-degenerate arguments: a < m && m < b.
// Having the caller check this condition eliminates many leaf recursion calls,
// which improves performance.
func symMerge_func(data lessSwap, a, m, b int) {
	// Avoid unnecessary recursions of symMerge
	// by direct insertion of data[a] into data[m:b]
	// if data[a:m] only contains one element.
	if m-a == 1 {
		// Use binary search to find the lowest index i
		// such that data[i] >= data[a] for m <= i < b.
		// Exit the search loop with i == b in case no such index exists.
		i := m
		j := b
		for i < j {
			h := int(uint(i+j) >> 1)
			if data.Less(h, a) {
				i = h + 1
			} else {
				j = h
			}
		}
		// Swap values until data[a] reaches the position before i.
		for k := a; k < i-1; k++ {
			data.Swap(k, k+1)
		}
		return
	}

	// Avoid unnecessary recursions of symMerge
	// by direct insertion of data[m] into data[a:m]
	// if data[m:b] only contains one element.
	if b-m == 1 {
		// Use binary search to find the lowest index i
		// such that data[i] > data[m] for a <= i < m.
		// Exit the search loop with i == m in case no such index exists.
		i := a
		j := m
		for i < j {
			h := int(uint(i+j) >> 1)
			if !data.Less(m, h) {
				i = h + 1
			} else {
				j = h
			}
		}
		// Swap values until data[m] reaches the position i.
		for k := m; k > i; k-- {
			data.Swap(k, k-1)
		}
		return
	}

	mid := int(uint(a+b) >> 1)
	n := mid + m
	var start, r int
	if m > mid {
		start = n - b
		r = mid
	} else {
		start = a
		r = m
	}
	p := n - 1

	for start < r {
		c := int(uint(start+r) >> 1)
		if !data.Less(p-c, c) {
			start = c + 1
		} else {
			r = c
		}
	}

	end := n - start
	if start < m && m < end {
		rotate_func(data, start, m, end)
	}
	if a < start && start < mid {
		symMerge_func(data, a, start, mid)
	}
	if mid < end && end < b {
		symMerge_func(data, mid, end, b)
	}
}

// rotate_func rotates two consecutive blocks u = data[a:m] and v = data[m:b] in data:
// Data of the form 'x u v y' is changed to 'x v u y'.
// rotate performs at most b-a many calls to data.Swap,
// and it assumes non-degenerate arguments: a < m && m < b.
func rotate_func(data lessSwap, a, m, b int) {
	i := m - a
	j := b - m

	for i != j {
		if i > j {
			swapRange_func(data, m-i, m, j)
			i -= j
		} else {
			swapRange_func(data, m-i, m+j-i, i)
			j -= i
		}
	}
	// i == j
	swapRange_func(data, m-i, m, i)
}

"""



```
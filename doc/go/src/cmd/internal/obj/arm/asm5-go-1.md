Response: Let's break down the thought process for analyzing this Go code snippet.

1. **Understand the Goal:** The request asks for a breakdown of the functionality of a specific Go file (`asm5.go`) related to ARM assembly. The key is to identify what assembly instructions are being generated and for what higher-level Go operations.

2. **Initial Scan for Keywords:** Look for recognizable assembly mnemonics (like `MOV`, `ADD`, `LDR`, `STR`, `BL`, `CMP`), Go types (like `obj.Prog`, `obj.Addr`), and diagnostic messages (`c.ctxt.Diag`). These act as anchors for understanding the code's purpose.

3. **Identify Core Functions:**  Notice the key functions: `asmout`, `movxt`, `mov`, `oprrr`, `opbra`, `olr`, `olhr`, `osr`, `oshr`, etc. These functions seem responsible for generating the actual machine code (`uint32` values).

4. **Focus on Key Assembly Patterns:**  As you examine the `case` statements within `asmout`, you'll start to recognize common ARM instruction encodings and their corresponding Go operations. For example:
    * `case 88`:  `MOV` instructions with shifts. The bit manipulations (`<<`, `|`) are typical for encoding instruction fields.
    * `case 89`: `MOV` with immediate values. The handling of large immediates (using the pool) is a common compiler optimization.
    * `case 90`: Load instructions (`LDR`, `LDRB`, `LDRH`). The different variants for signed/unsigned and byte/halfword are evident.
    * `case 91`: Store instructions (`STR`, `STRB`, `STRH`).
    * `case 93` and `94`:  More complex `MOV` involving memory access and temporary registers, pointing towards memory loads and stores.
    * `case 96`:  The `UNDEF` instruction for signaling errors.
    * The presence of `MUL`, `DIV`, `CLZ`, etc., indicates support for arithmetic and bit manipulation operations.
    * The cases around 110 (`dmb`) suggest support for memory barriers.

5. **Connect Assembly to Go Concepts:**  Think about what Go language features might translate into these assembly instructions.
    * Simple assignments (`a = b`) can become `MOV` instructions.
    * Arithmetic operations (`a + b`, `a * b`) map to `ADD`, `MUL`, etc.
    * Memory access (`x := array[i]`, `array[i] = y`) involve `LDR` and `STR`.
    * Function calls use `BL` (Branch with Link).
    * Conditional statements (`if`, `switch`) rely on conditional branches (`BEQ`, `BNE`, etc.) generated by `opbra`.
    * Bitwise operations (`&`, `|`, `^`, `<<`, `>>`) correspond to instructions like `AND`, `ORR`, `EOR`, `SLL`, `SRL`.

6. **Infer Function Roles:**
    * `asmout`: The main dispatcher, taking a `Prog` (representing a Go instruction) and emitting the corresponding machine code. The `case` statement acts as a giant switch based on the `op` code.
    * `movxt`, `mov`: Implement different forms of the `MOV` instruction.
    * `oprrr`: Handles register-to-register operations (arithmetic, logical).
    * `opbra`: Generates branch instructions.
    * `olr`, `olhr`, `osr`, `oshr`: Handle load and store instructions with immediate offsets. The `h` variants likely handle halfwords.
    * `omvs`, `omvr`, `omvl`: Handle `MOV` with immediate values, potentially with optimizations for large or negative constants.

7. **Address Specific Questions:**
    * **Go Feature Implementation:**  Look for patterns that correspond to specific Go features, like the handling of string operations (likely involving memory copies), and the `UNDEF` instruction suggesting runtime errors.
    * **Code Reasoning (with examples):**  Choose a few representative `case` statements from `asmout` and create simple Go code snippets that might lead to those assembly patterns. Focus on variable assignments, basic arithmetic, and memory access.
    * **Command-line Parameters:**  A quick scan doesn't reveal any direct handling of command-line parameters *within this specific code snippet*. This code is more focused on the assembly generation process itself. Command-line flags influencing this would be handled at a higher level in the Go compiler.
    * **Common Mistakes:** Analyze the error messages from `c.ctxt.Diag`. These reveal potential pitfalls, like incorrect register usage with `STREX`, non-zero offsets in specific instructions, and out-of-range immediate values.

8. **Synthesize and Summarize:** Combine the individual observations into a coherent description of the code's functionality. Focus on the core task of translating Go intermediate representation into ARM assembly.

9. **Refine and Organize:**  Review the generated explanation for clarity, accuracy, and completeness. Structure the information logically (e.g., by function, by instruction type).

Self-Correction/Refinement during the process:

* **Initial Misinterpretations:**  You might initially misinterpret a specific bit manipulation or the purpose of a particular instruction. Double-checking ARM architecture documentation or related Go compiler code can help correct these.
* **Overgeneralization:** Avoid making overly broad statements without sufficient evidence. Focus on what the code *directly* implements.
* **Missing Connections:** If you can't connect a block of assembly to a Go feature, consider looking at related parts of the Go compiler or ARM assembly documentation for clues. For example, understanding the role of the "pool" in `omvl` requires knowledge of how compilers handle large constants.

By following this structured approach, you can effectively analyze and understand the functionality of complex code snippets like this one. The key is to combine pattern recognition with an understanding of the underlying architecture and the higher-level language being compiled.
Let's break down the functionality of this Go code snippet from `go/src/cmd/internal/obj/arm/asm5.go`. This is the second part of the analysis, building upon the understanding from the first part.

**归纳一下它的功能 (Summary of its Functionality)**

This code snippet is a crucial part of the ARM assembler within the Go compiler toolchain. Its primary function is to **translate Go's intermediate representation of ARM assembly instructions into actual machine code (32-bit unsigned integers).** It does this by:

* **Matching Instruction Opcodes:**  The `asmout` function acts as a central dispatcher. It takes a `obj.Prog` (which represents a single assembly instruction in Go's internal format) and uses a `case` statement based on the instruction's opcode (`p.As`) to determine how to encode it.
* **Encoding Instruction Fields:**  For each instruction type, the code meticulously constructs the 32-bit instruction word by setting specific bits according to the operands (registers, immediate values, memory addresses), condition codes, and other instruction-specific flags. This involves bitwise operations (`<<`, `|`, `&`, `^`).
* **Handling Different Operand Types and Addressing Modes:**  The code distinguishes between register operands, immediate operands, and various memory addressing modes (e.g., register with offset, PC-relative addressing). Helper functions like `olr`, `olhr`, `osr`, `oshr`, `omvs`, `omvr`, and `omvl` are used to generate the correct bit patterns for these different operand types.
* **Supporting a Wide Range of ARM Instructions:** The `case` statements in `asmout` and the various helper functions cover a significant portion of the ARM instruction set, including data processing instructions (arithmetic, logical, move), load/store instructions, branch instructions, and some floating-point instructions.
* **Performing Error Checking and Diagnostics:** The code includes checks for invalid operand combinations, out-of-range immediate values, and other potential errors. The `c.ctxt.Diag` function is used to report these errors to the compiler.
* **Optimizing for Specific Cases:** Functions like `chipzero5` and `chipfloat5` suggest optimizations for loading specific floating-point constants (zero and potentially other common values) using more efficient instructions.

**Let's break down the individual functions and their roles:**

* **`asmout(ctxt *ctxt5, s *obj.LSym, cursym *obj.Prog)`:** This is the main function responsible for emitting the machine code for a given instruction `p`. It acts as a large switch statement based on the instruction's opcode (`p.As`). The `case` numbers correspond to different ARM instruction encodings defined elsewhere in the Go compiler.
* **`movxt(p *obj.Prog) uint32`:** This function handles encoding of `MOV` instructions with specific extended register operands (like byte or halfword extraction with optional shift).
* **`mov(p *obj.Prog) uint32`:** Encodes general `MOV` instructions, including those with immediate values and register operands.
* **`oprrr(p *obj.Prog, a obj.As, sc int) uint32`:**  This is a key function for encoding data processing instructions that operate on registers (register-register operations). It takes the instruction opcode (`a`) and condition code (`sc`) as input and constructs the base instruction word.
* **`opbra(p *obj.Prog, a obj.As, sc int) uint32`:** Encodes branch instructions (`B`, `BL`, and conditional branches).
* **`olr(v int32, b int, r int, sc int) uint32`:** Encodes load instructions with immediate offsets.
* **`olhr(v int32, b int, r int, sc int) uint32`:** Encodes load halfword instructions with immediate offsets.
* **`osr(a obj.As, r int, v int32, b int, sc int) uint32`:** Encodes store instructions with immediate offsets.
* **`oshr(r int, v int32, b int, sc int) uint32`:** Encodes store halfword instructions with immediate offsets.
* **`osrr`, `oshrr`, `olrr`, `olhrr`:** These functions seem to handle load/store instructions with register shifts as offsets.
* **`ofsr(a obj.As, r int, v int32, b int, sc int, p *obj.Prog) uint32`:** Encodes floating-point store instructions.
* **`omvs(p *obj.Prog, a *obj.Addr, dr int) uint32`:** Encodes `MOV` instructions with small immediate values (lower 16 bits).
* **`omvr(p *obj.Prog, a *obj.Addr, dr int) uint32`:** Encodes `MOV` instructions with potentially larger immediate values by using a rotate-immediate encoding.
* **`omvl(p *obj.Prog, a *obj.Addr, dr int) uint32`:** Encodes `MOV` instructions with large immediate values that cannot be directly encoded. It often involves loading the value from a "pool" of constants in memory.
* **`chipzero5(e float64) int`:**  Checks if a floating-point number is zero and potentially returns a special encoding if so (for optimization).
* **`chipfloat5(e float64) int`:**  Checks if a floating-point number matches a specific pattern that can be loaded efficiently using an immediate instruction.
* **`nocache(p *obj.Prog)`:**  Seems to clear some internal caching information related to the instruction.

**Go Code Examples Illustrating Functionality (with Hypothesized Inputs and Outputs)**

Let's take a few examples based on the `case` statements in `asmout`:

**Case 88: `MOV` with Shift**

```go
// Hypothetical input obj.Prog representing "MOV R1, R2, LSL #2"
prog := &obj.Prog{
	As:   obj.AMOVW, // MOV instruction
	From: obj.Addr{Type: obj.TYPE_REG, Reg: 2, Offset: SHIFT_LL | 2<<7}, // Source: R2, LSL #2
	To:   obj.Addr{Type: obj.TYPE_REG, Reg: 1},                      // Destination: R1
	Scond: 0, // No conditional execution
}

// Assuming c is an instance of *ctxt5

// Expected output (example - actual encoding may vary based on exact ARM architecture):
// o1 should represent the 32-bit encoding of "MOV R1, R2, LSL #2"
// Let's say it's something like 0xE1A01002 (this is just an example)

c.asmout(ctxt, nil, prog) // Inside asmout, case 88 would be hit

// After execution (within asmout):
// o1 would be calculated based on the fields of prog.From and prog.To
// o1 = ((0 & C_SCOND) ^ C_SCOND_XOR) << 28  // Condition codes
// o1 |= 0x0<<21                              // Opcode for MOV
// o1 |= (uint32(2) & 15) << 0                 // Source register (Rm)
// o1 |= (uint32(1) & 15) << 12                // Destination register (Rd)
// o1 |= (uint32(prog.From.Offset) & 0xfff) << 4 // Shift amount and type
// ...and so on

// The actual generated machine code would be stored in ctxt.cursym.P
```

**Case 89: `MOV` with Immediate**

```go
// Hypothetical input obj.Prog representing "MOV R0, #100"
prog := &obj.Prog{
	As:   obj.AMOVW,
	From: obj.Addr{Type: obj.TYPE_CONST, Offset: 100}, // Immediate value 100
	To:   obj.Addr{Type: obj.TYPE_REG, Reg: 0},
	Scond: 0,
}

// Expected output: o1 representing the encoding of "MOV R0, #100"
// Example: 0xE3A00064 (again, just an example)

c.asmout(ctxt, nil, prog) // Inside asmout, case 89 would be hit

// Calculation within case 89, involving immrot to handle immediate encoding
```

**Case 90: `LDR` (Load Register)**

```go
// Hypothetical input obj.Prog representing "LDR R3, [R4, #8]"
prog := &obj.Prog{
	As:   obj.AMOVW, // Represents LDR internally
	From: obj.Addr{Type: obj.TYPE_MEM, Reg: 4, Offset: 8}, // Memory address [R4, #8]
	To:   obj.Addr{Type: obj.TYPE_REG, Reg: 3},
	Scond: 0,
}

// Expected output: o1 representing the encoding of "LDR R3, [R4, #8]"
// Example: 0xE5943008

c.asmout(ctxt, nil, prog) // Inside asmout, case 90 would be hit
// The code would call c.olr to generate the load instruction
```

**Command-Line Parameter Handling**

This specific code snippet doesn't directly handle command-line parameters. The processing of command-line flags (like `-march`, `-mfloat-abi`, etc.) that influence code generation happens at a higher level in the Go compiler, likely within the `cmd/compile/internal/gc` package or earlier stages of the compilation process. These flags would configure the `ctxt5` structure or other relevant settings that this code then uses to make encoding decisions.

**Common Mistakes Users Might Make (Relating to Assembly Programming)**

While this code is part of the *compiler*, understanding potential errors helps illustrate its purpose. Users writing assembly (even indirectly through compiler intrinsics or very low-level code) might make mistakes that this assembler needs to catch:

* **Incorrect Register Usage with `STREX/LDREX`:** The code explicitly checks for cases where the same register is used as both source and destination in `STREX/LDREX` instructions. These instructions are used for atomic operations and have specific register constraints.

   ```go
   // Example of an error the assembler would catch
   // (Hypothetical assembly instruction that would lead to this)
   prog := &obj.Prog{
       As:   ASTREXD,
       From: obj.Addr{Type: obj.TYPE_REG, Reg: 1},
       To:   obj.Addr{Type: obj.TYPE_REG, Reg: 1}, // Same register as source
       Reg:  3,
   }
   // The `c.ctxt.Diag` would be called within case 92.
   ```

* **Non-Zero Offset in `STREX/LDREX`:**  These instructions typically require an offset of zero.

   ```go
   prog := &obj.Prog{
       As:   ALDREXD,
       From: obj.Addr{Type: obj.TYPE_MEM, Reg: 1, Offset: 4}, // Non-zero offset
       To:   obj.Addr{Type: obj.TYPE_REG, Reg: 2},
   }
   // Error caught in case 91.
   ```

* **Misaligned Registers in `STREXD/LDREXD`:**  Double-word atomic operations require even-numbered registers.

   ```go
   prog := &obj.Prog{
       As:   ASTREXD,
       From: obj.Addr{Type: obj.TYPE_REG, Reg: 1}, // Odd register
       To:   obj.Addr{Type: obj.TYPE_REG, Reg: 2},
       Reg:  3,
   }
   // Error caught in case 92.
   ```

* **Out-of-Range Immediate Values:**  The assembler checks if immediate values fit within the allowed bit ranges for specific instructions. The `immrot` function and checks within `olr`, `olhr` are related to this.

* **Incorrect Condition Code Usage:**  Using conditional suffixes on instructions where they are not allowed.

This code snippet is a low-level but essential part of the Go compiler for ARM architectures. It's responsible for the final stage of translating abstract assembly instructions into the concrete binary representation that the processor can execute.

### 提示词
```
这是路径为go/src/cmd/internal/obj/arm/asm5.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
这是第2部分，共2部分，请归纳一下它的功能
```

### 源代码
```go
= 0x1b << 20
		case ALDREXB:
			o1 = 0x1d << 20
		}
		o1 |= 0xf9f
		o1 |= (uint32(p.From.Reg) & 15) << 16
		o1 |= (uint32(p.To.Reg) & 15) << 12
		o1 |= ((uint32(p.Scond) & C_SCOND) ^ C_SCOND_XOR) << 28

	case 92: /* strexd/strexb reg,oreg,reg */
		c.aclass(&p.From)

		if c.instoffset != 0 {
			c.ctxt.Diag("offset must be zero in STREX")
		}
		if p.To.Reg == p.From.Reg || p.To.Reg == p.Reg || (p.As == ASTREXD && p.To.Reg == p.Reg+1) {
			c.ctxt.Diag("cannot use same register as both source and destination: %v", p)
		}

		switch p.As {
		case ASTREXD:
			if p.Reg&1 != 0 {
				c.ctxt.Diag("source register must be even in STREXD: %v", p)
			}
			o1 = 0x1a << 20
		case ASTREXB:
			o1 = 0x1c << 20
		}
		o1 |= 0xf90
		o1 |= (uint32(p.From.Reg) & 15) << 16
		o1 |= (uint32(p.Reg) & 15) << 0
		o1 |= (uint32(p.To.Reg) & 15) << 12
		o1 |= ((uint32(p.Scond) & C_SCOND) ^ C_SCOND_XOR) << 28

	case 93: /* movb/movh/movhu addr,R -> ldrsb/ldrsh/ldrh */
		o1 = c.omvl(p, &p.From, REGTMP)

		if o1 == 0 {
			break
		}
		o2 = c.olhr(0, REGTMP, int(p.To.Reg), int(p.Scond))
		if p.As == AMOVB || p.As == AMOVBS {
			o2 ^= 1<<5 | 1<<6
		} else if p.As == AMOVH || p.As == AMOVHS {
			o2 ^= (1 << 6)
		}
		if o.flag&LPCREL != 0 {
			o3 = o2
			o2 = c.oprrr(p, AADD, int(p.Scond)) | REGTMP&15 | (REGPC&15)<<16 | (REGTMP&15)<<12
		}

	case 94: /* movh/movhu R,addr -> strh */
		o1 = c.omvl(p, &p.To, REGTMP)

		if o1 == 0 {
			break
		}
		o2 = c.oshr(int(p.From.Reg), 0, REGTMP, int(p.Scond))
		if o.flag&LPCREL != 0 {
			o3 = o2
			o2 = c.oprrr(p, AADD, int(p.Scond)) | REGTMP&15 | (REGPC&15)<<16 | (REGTMP&15)<<12
		}

	case 95: /* PLD off(reg) */
		o1 = 0xf5d0f000

		o1 |= (uint32(p.From.Reg) & 15) << 16
		if p.From.Offset < 0 {
			o1 &^= (1 << 23)
			o1 |= uint32((-p.From.Offset) & 0xfff)
		} else {
			o1 |= uint32(p.From.Offset & 0xfff)
		}

	// This is supposed to be something that stops execution.
	// It's not supposed to be reached, ever, but if it is, we'd
	// like to be able to tell how we got there. Assemble as
	// 0xf7fabcfd which is guaranteed to raise undefined instruction
	// exception.
	case 96: /* UNDEF */
		o1 = 0xf7fabcfd

	case 97: /* CLZ Rm, Rd */
		o1 = c.oprrr(p, p.As, int(p.Scond))

		o1 |= (uint32(p.To.Reg) & 15) << 12
		o1 |= (uint32(p.From.Reg) & 15) << 0

	case 98: /* MULW{T,B} Rs, Rm, Rd */
		o1 = c.oprrr(p, p.As, int(p.Scond))

		o1 |= (uint32(p.To.Reg) & 15) << 16
		o1 |= (uint32(p.From.Reg) & 15) << 8
		o1 |= (uint32(p.Reg) & 15) << 0

	case 99: /* MULAW{T,B} Rs, Rm, Rn, Rd */
		o1 = c.oprrr(p, p.As, int(p.Scond))

		o1 |= (uint32(p.To.Reg) & 15) << 16
		o1 |= (uint32(p.From.Reg) & 15) << 8
		o1 |= (uint32(p.Reg) & 15) << 0
		o1 |= uint32((p.To.Offset & 15) << 12)

	case 105: /* divhw r,[r,]r */
		o1 = c.oprrr(p, p.As, int(p.Scond))
		rf := int(p.From.Reg)
		rt := int(p.To.Reg)
		r := int(p.Reg)
		if r == 0 {
			r = rt
		}
		o1 |= (uint32(rf)&15)<<8 | (uint32(r)&15)<<0 | (uint32(rt)&15)<<16

	case 110: /* dmb [mbop | $con] */
		o1 = 0xf57ff050
		mbop := uint32(0)

		switch c.aclass(&p.From) {
		case C_SPR:
			for _, f := range mbOp {
				if f.reg == p.From.Reg {
					mbop = f.enc
					break
				}
			}
		case C_RCON:
			for _, f := range mbOp {
				enc := uint32(c.instoffset)
				if f.enc == enc {
					mbop = enc
					break
				}
			}
		case C_NONE:
			mbop = 0xf
		}

		if mbop == 0 {
			c.ctxt.Diag("illegal mb option:\n%v", p)
		}
		o1 |= mbop
	}

	out[0] = o1
	out[1] = o2
	out[2] = o3
	out[3] = o4
	out[4] = o5
	out[5] = o6
}

func (c *ctxt5) movxt(p *obj.Prog) uint32 {
	o1 := ((uint32(p.Scond) & C_SCOND) ^ C_SCOND_XOR) << 28
	switch p.As {
	case AMOVB, AMOVBS:
		o1 |= 0x6af<<16 | 0x7<<4
	case AMOVH, AMOVHS:
		o1 |= 0x6bf<<16 | 0x7<<4
	case AMOVBU:
		o1 |= 0x6ef<<16 | 0x7<<4
	case AMOVHU:
		o1 |= 0x6ff<<16 | 0x7<<4
	default:
		c.ctxt.Diag("illegal combination: %v", p)
	}
	switch p.From.Offset &^ 0xf {
	// only 0/8/16/24 bits rotation is accepted
	case SHIFT_RR, SHIFT_RR | 8<<7, SHIFT_RR | 16<<7, SHIFT_RR | 24<<7:
		o1 |= uint32(p.From.Offset) & 0xc0f
	default:
		c.ctxt.Diag("illegal shift: %v", p)
	}
	o1 |= (uint32(p.To.Reg) & 15) << 12
	return o1
}

func (c *ctxt5) mov(p *obj.Prog) uint32 {
	c.aclass(&p.From)
	o1 := c.oprrr(p, p.As, int(p.Scond))
	o1 |= uint32(p.From.Offset)
	rt := int(p.To.Reg)
	if p.To.Type == obj.TYPE_NONE {
		rt = 0
	}
	r := int(p.Reg)
	if p.As == AMOVW || p.As == AMVN {
		r = 0
	} else if r == 0 {
		r = rt
	}
	o1 |= (uint32(r)&15)<<16 | (uint32(rt)&15)<<12
	return o1
}

func (c *ctxt5) oprrr(p *obj.Prog, a obj.As, sc int) uint32 {
	o := ((uint32(sc) & C_SCOND) ^ C_SCOND_XOR) << 28
	if sc&C_SBIT != 0 {
		o |= 1 << 20
	}
	switch a {
	case ADIVHW:
		return o | 0x71<<20 | 0xf<<12 | 0x1<<4
	case ADIVUHW:
		return o | 0x73<<20 | 0xf<<12 | 0x1<<4
	case AMMUL:
		return o | 0x75<<20 | 0xf<<12 | 0x1<<4
	case AMULS:
		return o | 0x6<<20 | 0x9<<4
	case AMMULA:
		return o | 0x75<<20 | 0x1<<4
	case AMMULS:
		return o | 0x75<<20 | 0xd<<4
	case AMULU, AMUL:
		return o | 0x0<<21 | 0x9<<4
	case AMULA:
		return o | 0x1<<21 | 0x9<<4
	case AMULLU:
		return o | 0x4<<21 | 0x9<<4
	case AMULL:
		return o | 0x6<<21 | 0x9<<4
	case AMULALU:
		return o | 0x5<<21 | 0x9<<4
	case AMULAL:
		return o | 0x7<<21 | 0x9<<4
	case AAND:
		return o | 0x0<<21
	case AEOR:
		return o | 0x1<<21
	case ASUB:
		return o | 0x2<<21
	case ARSB:
		return o | 0x3<<21
	case AADD:
		return o | 0x4<<21
	case AADC:
		return o | 0x5<<21
	case ASBC:
		return o | 0x6<<21
	case ARSC:
		return o | 0x7<<21
	case ATST:
		return o | 0x8<<21 | 1<<20
	case ATEQ:
		return o | 0x9<<21 | 1<<20
	case ACMP:
		return o | 0xa<<21 | 1<<20
	case ACMN:
		return o | 0xb<<21 | 1<<20
	case AORR:
		return o | 0xc<<21

	case AMOVB, AMOVH, AMOVW:
		if sc&(C_PBIT|C_WBIT) != 0 {
			c.ctxt.Diag("invalid .P/.W suffix: %v", p)
		}
		return o | 0xd<<21
	case ABIC:
		return o | 0xe<<21
	case AMVN:
		return o | 0xf<<21
	case ASLL:
		return o | 0xd<<21 | 0<<5
	case ASRL:
		return o | 0xd<<21 | 1<<5
	case ASRA:
		return o | 0xd<<21 | 2<<5
	case ASWI:
		return o | 0xf<<24

	case AADDD:
		return o | 0xe<<24 | 0x3<<20 | 0xb<<8 | 0<<4
	case AADDF:
		return o | 0xe<<24 | 0x3<<20 | 0xa<<8 | 0<<4
	case ASUBD:
		return o | 0xe<<24 | 0x3<<20 | 0xb<<8 | 4<<4
	case ASUBF:
		return o | 0xe<<24 | 0x3<<20 | 0xa<<8 | 4<<4
	case AMULD:
		return o | 0xe<<24 | 0x2<<20 | 0xb<<8 | 0<<4
	case AMULF:
		return o | 0xe<<24 | 0x2<<20 | 0xa<<8 | 0<<4
	case ANMULD:
		return o | 0xe<<24 | 0x2<<20 | 0xb<<8 | 0x4<<4
	case ANMULF:
		return o | 0xe<<24 | 0x2<<20 | 0xa<<8 | 0x4<<4
	case AMULAD:
		return o | 0xe<<24 | 0xb<<8
	case AMULAF:
		return o | 0xe<<24 | 0xa<<8
	case AMULSD:
		return o | 0xe<<24 | 0xb<<8 | 0x4<<4
	case AMULSF:
		return o | 0xe<<24 | 0xa<<8 | 0x4<<4
	case ANMULAD:
		return o | 0xe<<24 | 0x1<<20 | 0xb<<8 | 0x4<<4
	case ANMULAF:
		return o | 0xe<<24 | 0x1<<20 | 0xa<<8 | 0x4<<4
	case ANMULSD:
		return o | 0xe<<24 | 0x1<<20 | 0xb<<8
	case ANMULSF:
		return o | 0xe<<24 | 0x1<<20 | 0xa<<8
	case AFMULAD:
		return o | 0xe<<24 | 0xa<<20 | 0xb<<8
	case AFMULAF:
		return o | 0xe<<24 | 0xa<<20 | 0xa<<8
	case AFMULSD:
		return o | 0xe<<24 | 0xa<<20 | 0xb<<8 | 0x4<<4
	case AFMULSF:
		return o | 0xe<<24 | 0xa<<20 | 0xa<<8 | 0x4<<4
	case AFNMULAD:
		return o | 0xe<<24 | 0x9<<20 | 0xb<<8 | 0x4<<4
	case AFNMULAF:
		return o | 0xe<<24 | 0x9<<20 | 0xa<<8 | 0x4<<4
	case AFNMULSD:
		return o | 0xe<<24 | 0x9<<20 | 0xb<<8
	case AFNMULSF:
		return o | 0xe<<24 | 0x9<<20 | 0xa<<8
	case ADIVD:
		return o | 0xe<<24 | 0x8<<20 | 0xb<<8 | 0<<4
	case ADIVF:
		return o | 0xe<<24 | 0x8<<20 | 0xa<<8 | 0<<4
	case ASQRTD:
		return o | 0xe<<24 | 0xb<<20 | 1<<16 | 0xb<<8 | 0xc<<4
	case ASQRTF:
		return o | 0xe<<24 | 0xb<<20 | 1<<16 | 0xa<<8 | 0xc<<4
	case AABSD:
		return o | 0xe<<24 | 0xb<<20 | 0<<16 | 0xb<<8 | 0xc<<4
	case AABSF:
		return o | 0xe<<24 | 0xb<<20 | 0<<16 | 0xa<<8 | 0xc<<4
	case ANEGD:
		return o | 0xe<<24 | 0xb<<20 | 1<<16 | 0xb<<8 | 0x4<<4
	case ANEGF:
		return o | 0xe<<24 | 0xb<<20 | 1<<16 | 0xa<<8 | 0x4<<4
	case ACMPD:
		return o | 0xe<<24 | 0xb<<20 | 4<<16 | 0xb<<8 | 0xc<<4
	case ACMPF:
		return o | 0xe<<24 | 0xb<<20 | 4<<16 | 0xa<<8 | 0xc<<4

	case AMOVF:
		return o | 0xe<<24 | 0xb<<20 | 0<<16 | 0xa<<8 | 4<<4
	case AMOVD:
		return o | 0xe<<24 | 0xb<<20 | 0<<16 | 0xb<<8 | 4<<4

	case AMOVDF:
		return o | 0xe<<24 | 0xb<<20 | 7<<16 | 0xa<<8 | 0xc<<4 | 1<<8 // dtof
	case AMOVFD:
		return o | 0xe<<24 | 0xb<<20 | 7<<16 | 0xa<<8 | 0xc<<4 | 0<<8 // dtof

	case AMOVWF:
		if sc&C_UBIT == 0 {
			o |= 1 << 7 /* signed */
		}
		return o | 0xe<<24 | 0xb<<20 | 8<<16 | 0xa<<8 | 4<<4 | 0<<18 | 0<<8 // toint, double

	case AMOVWD:
		if sc&C_UBIT == 0 {
			o |= 1 << 7 /* signed */
		}
		return o | 0xe<<24 | 0xb<<20 | 8<<16 | 0xa<<8 | 4<<4 | 0<<18 | 1<<8 // toint, double

	case AMOVFW:
		if sc&C_UBIT == 0 {
			o |= 1 << 16 /* signed */
		}
		return o | 0xe<<24 | 0xb<<20 | 8<<16 | 0xa<<8 | 4<<4 | 1<<18 | 0<<8 | 1<<7 // toint, double, trunc

	case AMOVDW:
		if sc&C_UBIT == 0 {
			o |= 1 << 16 /* signed */
		}
		return o | 0xe<<24 | 0xb<<20 | 8<<16 | 0xa<<8 | 4<<4 | 1<<18 | 1<<8 | 1<<7 // toint, double, trunc

	case -AMOVWF: // copy WtoF
		return o | 0xe<<24 | 0x0<<20 | 0xb<<8 | 1<<4

	case -AMOVFW: // copy FtoW
		return o | 0xe<<24 | 0x1<<20 | 0xb<<8 | 1<<4

	case -ACMP: // cmp imm
		return o | 0x3<<24 | 0x5<<20

	case ABFX:
		return o | 0x3d<<21 | 0x5<<4

	case ABFXU:
		return o | 0x3f<<21 | 0x5<<4

	case ABFC:
		return o | 0x3e<<21 | 0x1f

	case ABFI:
		return o | 0x3e<<21 | 0x1<<4

	case AXTAB:
		return o | 0x6a<<20 | 0x7<<4

	case AXTAH:
		return o | 0x6b<<20 | 0x7<<4

	case AXTABU:
		return o | 0x6e<<20 | 0x7<<4

	case AXTAHU:
		return o | 0x6f<<20 | 0x7<<4

		// CLZ doesn't support .nil
	case ACLZ:
		return o&(0xf<<28) | 0x16f<<16 | 0xf1<<4

	case AREV:
		return o&(0xf<<28) | 0x6bf<<16 | 0xf3<<4

	case AREV16:
		return o&(0xf<<28) | 0x6bf<<16 | 0xfb<<4

	case AREVSH:
		return o&(0xf<<28) | 0x6ff<<16 | 0xfb<<4

	case ARBIT:
		return o&(0xf<<28) | 0x6ff<<16 | 0xf3<<4

	case AMULWT:
		return o&(0xf<<28) | 0x12<<20 | 0xe<<4

	case AMULWB:
		return o&(0xf<<28) | 0x12<<20 | 0xa<<4

	case AMULBB:
		return o&(0xf<<28) | 0x16<<20 | 0x8<<4

	case AMULAWT:
		return o&(0xf<<28) | 0x12<<20 | 0xc<<4

	case AMULAWB:
		return o&(0xf<<28) | 0x12<<20 | 0x8<<4

	case AMULABB:
		return o&(0xf<<28) | 0x10<<20 | 0x8<<4

	case ABL: // BLX REG
		return o&(0xf<<28) | 0x12fff3<<4
	}

	c.ctxt.Diag("%v: bad rrr %d", p, a)
	return 0
}

func (c *ctxt5) opbra(p *obj.Prog, a obj.As, sc int) uint32 {
	sc &= C_SCOND
	sc ^= C_SCOND_XOR
	if a == ABL || a == obj.ADUFFZERO || a == obj.ADUFFCOPY {
		return uint32(sc)<<28 | 0x5<<25 | 0x1<<24
	}
	if sc != 0xe {
		c.ctxt.Diag("%v: .COND on bcond instruction", p)
	}
	switch a {
	case ABEQ:
		return 0x0<<28 | 0x5<<25
	case ABNE:
		return 0x1<<28 | 0x5<<25
	case ABCS:
		return 0x2<<28 | 0x5<<25
	case ABHS:
		return 0x2<<28 | 0x5<<25
	case ABCC:
		return 0x3<<28 | 0x5<<25
	case ABLO:
		return 0x3<<28 | 0x5<<25
	case ABMI:
		return 0x4<<28 | 0x5<<25
	case ABPL:
		return 0x5<<28 | 0x5<<25
	case ABVS:
		return 0x6<<28 | 0x5<<25
	case ABVC:
		return 0x7<<28 | 0x5<<25
	case ABHI:
		return 0x8<<28 | 0x5<<25
	case ABLS:
		return 0x9<<28 | 0x5<<25
	case ABGE:
		return 0xa<<28 | 0x5<<25
	case ABLT:
		return 0xb<<28 | 0x5<<25
	case ABGT:
		return 0xc<<28 | 0x5<<25
	case ABLE:
		return 0xd<<28 | 0x5<<25
	case AB:
		return 0xe<<28 | 0x5<<25
	}

	c.ctxt.Diag("%v: bad bra %v", p, a)
	return 0
}

func (c *ctxt5) olr(v int32, b int, r int, sc int) uint32 {
	o := ((uint32(sc) & C_SCOND) ^ C_SCOND_XOR) << 28
	if sc&C_PBIT == 0 {
		o |= 1 << 24
	}
	if sc&C_UBIT == 0 {
		o |= 1 << 23
	}
	if sc&C_WBIT != 0 {
		o |= 1 << 21
	}
	o |= 1<<26 | 1<<20
	if v < 0 {
		if sc&C_UBIT != 0 {
			c.ctxt.Diag(".U on neg offset")
		}
		v = -v
		o ^= 1 << 23
	}

	if v >= 1<<12 || v < 0 {
		c.ctxt.Diag("literal span too large: %d (R%d)\n%v", v, b, c.printp)
	}
	o |= uint32(v)
	o |= (uint32(b) & 15) << 16
	o |= (uint32(r) & 15) << 12
	return o
}

func (c *ctxt5) olhr(v int32, b int, r int, sc int) uint32 {
	o := ((uint32(sc) & C_SCOND) ^ C_SCOND_XOR) << 28
	if sc&C_PBIT == 0 {
		o |= 1 << 24
	}
	if sc&C_WBIT != 0 {
		o |= 1 << 21
	}
	o |= 1<<23 | 1<<20 | 0xb<<4
	if v < 0 {
		v = -v
		o ^= 1 << 23
	}

	if v >= 1<<8 || v < 0 {
		c.ctxt.Diag("literal span too large: %d (R%d)\n%v", v, b, c.printp)
	}
	o |= uint32(v)&0xf | (uint32(v)>>4)<<8 | 1<<22
	o |= (uint32(b) & 15) << 16
	o |= (uint32(r) & 15) << 12
	return o
}

func (c *ctxt5) osr(a obj.As, r int, v int32, b int, sc int) uint32 {
	o := c.olr(v, b, r, sc) ^ (1 << 20)
	if a != AMOVW {
		o |= 1 << 22
	}
	return o
}

func (c *ctxt5) oshr(r int, v int32, b int, sc int) uint32 {
	o := c.olhr(v, b, r, sc) ^ (1 << 20)
	return o
}

func (c *ctxt5) osrr(r int, i int, b int, sc int) uint32 {
	return c.olr(int32(i), b, r, sc) ^ (1<<25 | 1<<20)
}

func (c *ctxt5) oshrr(r int, i int, b int, sc int) uint32 {
	return c.olhr(int32(i), b, r, sc) ^ (1<<22 | 1<<20)
}

func (c *ctxt5) olrr(i int, b int, r int, sc int) uint32 {
	return c.olr(int32(i), b, r, sc) ^ (1 << 25)
}

func (c *ctxt5) olhrr(i int, b int, r int, sc int) uint32 {
	return c.olhr(int32(i), b, r, sc) ^ (1 << 22)
}

func (c *ctxt5) ofsr(a obj.As, r int, v int32, b int, sc int, p *obj.Prog) uint32 {
	o := ((uint32(sc) & C_SCOND) ^ C_SCOND_XOR) << 28
	if sc&C_PBIT == 0 {
		o |= 1 << 24
	}
	if sc&C_WBIT != 0 {
		o |= 1 << 21
	}
	o |= 6<<25 | 1<<24 | 1<<23 | 10<<8
	if v < 0 {
		v = -v
		o ^= 1 << 23
	}

	if v&3 != 0 {
		c.ctxt.Diag("odd offset for floating point op: %d\n%v", v, p)
	} else if v >= 1<<10 || v < 0 {
		c.ctxt.Diag("literal span too large: %d\n%v", v, p)
	}
	o |= (uint32(v) >> 2) & 0xFF
	o |= (uint32(b) & 15) << 16
	o |= (uint32(r) & 15) << 12

	switch a {
	default:
		c.ctxt.Diag("bad fst %v", a)
		fallthrough

	case AMOVD:
		o |= 1 << 8
		fallthrough

	case AMOVF:
		break
	}

	return o
}

// MOVW $"lower 16-bit", Reg
func (c *ctxt5) omvs(p *obj.Prog, a *obj.Addr, dr int) uint32 {
	o1 := ((uint32(p.Scond) & C_SCOND) ^ C_SCOND_XOR) << 28
	o1 |= 0x30 << 20
	o1 |= (uint32(dr) & 15) << 12
	o1 |= uint32(a.Offset) & 0x0fff
	o1 |= (uint32(a.Offset) & 0xf000) << 4
	return o1
}

// MVN $C_NCON, Reg -> MOVW $C_RCON, Reg
func (c *ctxt5) omvr(p *obj.Prog, a *obj.Addr, dr int) uint32 {
	o1 := c.oprrr(p, AMOVW, int(p.Scond))
	o1 |= (uint32(dr) & 15) << 12
	v := immrot(^uint32(a.Offset))
	if v == 0 {
		c.ctxt.Diag("%v: missing literal", p)
		return 0
	}
	o1 |= uint32(v)
	return o1
}

func (c *ctxt5) omvl(p *obj.Prog, a *obj.Addr, dr int) uint32 {
	var o1 uint32
	if p.Pool == nil {
		c.aclass(a)
		v := immrot(^uint32(c.instoffset))
		if v == 0 {
			c.ctxt.Diag("%v: missing literal", p)
			return 0
		}

		o1 = c.oprrr(p, AMVN, int(p.Scond)&C_SCOND)
		o1 |= uint32(v)
		o1 |= (uint32(dr) & 15) << 12
	} else {
		v := int32(p.Pool.Pc - p.Pc - 8)
		o1 = c.olr(v, REGPC, dr, int(p.Scond)&C_SCOND)
	}

	return o1
}

func (c *ctxt5) chipzero5(e float64) int {
	// We use GOARM.Version=7 and !GOARM.SoftFloat to gate the use of VFPv3 vmov (imm) instructions.
	if buildcfg.GOARM.Version < 7 || buildcfg.GOARM.SoftFloat || math.Float64bits(e) != 0 {
		return -1
	}
	return 0
}

func (c *ctxt5) chipfloat5(e float64) int {
	// We use GOARM.Version=7 and !GOARM.SoftFloat to gate the use of VFPv3 vmov (imm) instructions.
	if buildcfg.GOARM.Version < 7 || buildcfg.GOARM.SoftFloat {
		return -1
	}

	ei := math.Float64bits(e)
	l := uint32(ei)
	h := uint32(ei >> 32)

	if l != 0 || h&0xffff != 0 {
		return -1
	}
	h1 := h & 0x7fc00000
	if h1 != 0x40000000 && h1 != 0x3fc00000 {
		return -1
	}
	n := 0

	// sign bit (a)
	if h&0x80000000 != 0 {
		n |= 1 << 7
	}

	// exp sign bit (b)
	if h1 == 0x3fc00000 {
		n |= 1 << 6
	}

	// rest of exp and mantissa (cd-efgh)
	n |= int((h >> 16) & 0x3f)

	//print("match %.8lux %.8lux %d\n", l, h, n);
	return n
}

func nocache(p *obj.Prog) {
	p.Optab = 0
	p.From.Class = 0
	if p.GetFrom3() != nil {
		p.GetFrom3().Class = 0
	}
	p.To.Class = 0
}
```
Response:
The user wants a summary of the functionalities present in the provided Go code snippet. This is the second part of a two-part code listing. I need to focus on summarizing the functions defined in this part and how they contribute to the overall testing framework.

Based on the code, the primary functionalities seem to be:

1. **Output comparison:** Comparing the actual output of a test execution with an expected output file.
2. **Error checking:** Analyzing the output for expected error messages based on comments in the source code.
3. **Assembly code verification:** Checking the generated assembly code against expected opcodes defined in comments.
4. **Test filtering:** Determining whether a test should be executed based on build tags.
5. **File system manipulation:** Creating an overlay directory for testing.

I will summarize these functionalities in detail.
这是 `go/src/cmd/internal/testdir/testdir_test.go` 代码的第二部分，它主要负责以下功能：

1. **检查预期输出 (checkExpectedOutput):**
   - 该函数接收测试执行的输出 `gotBytes`。
   - 它会查找与当前测试 Go 文件对应的 `.out` 文件（通过将 `.go` 替换为 `.out`）。
   - 它会读取 `.out` 文件的内容作为预期输出。
   - 如果 `.out` 文件不存在，则认为预期输出为空。
   - 它会将实际输出和预期输出进行比较，如果两者不匹配，则会返回一个包含详细信息的错误。
   - **功能归纳:** 用于验证测试程序的输出是否与预期的输出文件内容一致。

2. **分割输出 (splitOutput):**
   - 该函数接收一个字符串形式的输出 `out` 和一个布尔值 `wantAuto`。
   - 它会将输出按行分割。
   - 对于以制表符开头的行，它会将其追加到前一行的结果中 (用于处理 `gc` 错误消息可能跨多行的情况)。
   - 它会过滤掉以 "go tool" 或 "#" 开头的行。
   - 如果 `wantAuto` 为 `false`，还会过滤掉以 "<autogenerated>" 开头的行。
   - 它会忽略空行。
   - **功能归纳:** 将测试输出分割成有意义的独立行，并可以根据需要过滤掉特定的行。

3. **错误检查 (errorCheck):**
   - 该函数接收测试执行的输出 `outStr`，一个布尔值 `wantAuto`，以及一个包含源文件路径和名称的字符串切片 `fullshort`。
   - 它的目标是将输出中的错误信息与源文件中以 `// ERROR "regexp"` 形式存在的注释进行匹配。
   - 它首先使用 `splitOutput` 函数分割输出。
   - 然后，它会遍历源文件，查找 `// ERROR "regexp"` 注释，提取预期的错误信息和正则表达式。
   - 接着，它会在分割后的输出中查找匹配这些正则表达式的错误信息。
   - 如果输出中存在没有对应注释的错误，或者注释存在但输出中没有对应的错误，或者错误信息与正则表达式不匹配，则会报告错误。
   - **功能归纳:** 验证测试程序产生的错误信息是否与源文件中标记的预期错误信息一致。

4. **更新错误 (updateErrors):**
   - 该函数接收测试输出 `out` 和源文件名 `file`。
   - 它的目的是根据测试输出中实际产生的错误信息，自动更新源文件中的 `// ERROR` 注释。
   - 它会读取源文件内容，移除旧的 `// ERROR` 注释。
   - 然后，它会解析测试输出，提取新的错误信息和对应的行号。
   - 它会将新的错误信息以 `// ERROR "regexp"` 的形式添加到源文件的对应行。
   - 最后，它会使用 `go fmt` 格式化更新后的源文件。
   - **功能归纳:**  根据实际的测试输出自动更新源文件中的错误预期注释。这是一个辅助功能，用于维护测试的正确性。

5. **匹配前缀 (matchPrefix):**
   - 该函数接收一个字符串 `s` 和一个前缀 `prefix`。
   - 它会检查字符串 `s` 是否以 `prefix` 开头，并且 `prefix` 后面紧跟着 `:` 或 `[`，或者 `prefix` 前面可以有目录路径。
   - **功能归纳:** 检查字符串是否具有指定的文件名或路径前缀。

6. **分割字符串 (partitionStrings):**
   - 该函数接收一个前缀字符串 `prefix` 和一个字符串切片 `strs`。
   - 它会将 `strs` 分割成两个切片：`matched` 包含所有以 `prefix` 开头的字符串，`unmatched` 包含所有不以 `prefix` 开头的字符串。
   - **功能归纳:** 根据字符串是否具有指定的前缀将其分类。

7. **获取期望的错误 (wantedErrors):**
   - 该函数接收源文件名 `file` 和短文件名 `short`。
   - 它会读取源文件内容，查找以 `// ERROR "regexp"` 或 `// ERRORAUTO "regexp"` 形式存在的注释。
   - 它会将这些注释中的正则表达式编译成 `regexp.Regexp` 对象。
   - 它会返回一个包含期望错误信息的 `wantedError` 结构体切片，其中包括正则表达式、行号、是否为自动生成错误等信息。
   - **功能归纳:** 解析源文件，提取所有标记为预期错误的注释信息。

8. **获取期望的汇编指令 (wantedAsmOpcodes):**
   - 该函数接收源文件名 `fn`。
   - 它会读取源文件，查找包含汇编指令检查的注释，其格式为 `// architecture : opcode1, opcode2`。
   - 它会解析这些注释，提取目标架构、操作系统以及期望的汇编指令（可以是正向匹配或负向匹配）。
   - 它会返回一个 `asmChecks` 类型的 map，其中包含了在不同构建环境下对不同代码行的汇编指令检查。
   - **功能归纳:** 解析源文件，提取所有标记为需要进行汇编指令检查的注释信息，并组织成按构建环境和代码行索引的结构。

9. **汇编检查 (asmCheck):**
   - 该函数接收汇编输出 `outStr`，源文件名 `fn`，构建环境 `env`，以及从 `wantedAsmOpcodes` 获取的期望汇编指令信息 `fullops`。
   - 它会将汇编输出按函数分割，并记录每行汇编代码对应的源文件行号。
   - 它会遍历 `fullops` 中定义的汇编指令检查，在汇编输出中查找匹配的指令。
   - 如果期望匹配的指令没有找到，或者期望不匹配的指令找到了，则会返回一个错误。
   - **功能归纳:**  验证生成的汇编代码是否符合源文件中标记的预期指令。

10. **默认运行输出限制 (defaultRunOutputLimit):**
    - 该函数返回可以并行执行的 `runoutput` 测试的最大数量。
    - 它会考虑 CPU 核心数，并针对 `arm` 架构设置一个上限。
    - **功能归纳:**  决定并行执行 `runoutput` 测试的数量，以优化测试效率。

11. **测试 ShouldTest 函数 (TestShouldTest):**
    - 该函数是一个测试函数，用于测试 `shouldTest` 函数的逻辑。
    - 它使用断言来验证 `shouldTest` 函数在不同构建标签下的行为是否符合预期。
    - **功能归纳:**  测试 `shouldTest` 函数的正确性。

12. **覆盖目录 (overlayDir):**
    - 该函数接收目标目录 `dstRoot` 和源目录 `srcRoot`。
    - 它会在目标目录创建一个源目录的轻量级副本，可以使用符号链接来提高效率。
    - 这允许在不修改原始源目录的情况下添加新的测试文件。
    - **功能归纳:**  创建一个源目录的副本，用于测试环境，避免修改原始文件。

13. **辅助函数和变量:**
    - `setOf`: 创建一个字符串集合的辅助函数。
    - `splitQuoted`:  用于分割带引号的字符串，类似于 shell 命令的参数解析。
    - `replacePrefix`:  替换字符串中指定的前缀，类似于 `cmd/go` 中处理文件名的逻辑。
    - `types2Failures`, `types2Failures32Bit`: 存储在新的类型检查器 (`types2`) 下已知会失败或产生非最优错误的测试文件列表。
    - `archVariants`: 存储了不同架构及其支持的变体。
    - 正则表达式相关的变量 (`errRx`, `errAutoRx`, `errQuotesRx`, `lineRx`, `rxAsmComment`, `rxAsmPlatform`, `rxAsmCheck`)：用于解析源文件中的注释和汇编输出。

**总功能归纳:**

这部分代码是 `testdir` 测试框架的核心组成部分，专注于自动化测试的验证环节。它提供了一系列函数，用于比较测试程序的输出、检查预期的错误信息、验证生成的汇编代码、根据构建标签过滤测试，以及提供一些辅助功能来管理测试环境和解析测试数据。 它的主要目的是确保编译器在各种场景下的行为符合预期，包括输出结果、错误报告和生成的机器码。

### 提示词
```
这是路径为go/src/cmd/internal/testdir/testdir_test.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
请用中文回答。
这是第2部分，共2部分，请归纳一下它的功能
```

### 源代码
```go
ile, if any (replace ".go" with ".out").
// If they don't match, fail with an informative message.
func (t test) checkExpectedOutput(gotBytes []byte) error {
	got := string(gotBytes)
	filename := filepath.Join(t.dir, t.goFile)
	filename = filename[:len(filename)-len(".go")]
	filename += ".out"
	b, err := os.ReadFile(filepath.Join(t.gorootTestDir, filename))
	if errors.Is(err, fs.ErrNotExist) {
		// File is allowed to be missing, in which case output should be empty.
		b = nil
	} else if err != nil {
		return err
	}
	got = strings.Replace(got, "\r\n", "\n", -1)
	if got != string(b) {
		if err == nil {
			return fmt.Errorf("output does not match expected in %s. Instead saw\n%s", filename, got)
		} else {
			return fmt.Errorf("output should be empty when (optional) expected-output file %s is not present. Instead saw\n%s", filename, got)
		}
	}
	return nil
}

func splitOutput(out string, wantAuto bool) []string {
	// gc error messages continue onto additional lines with leading tabs.
	// Split the output at the beginning of each line that doesn't begin with a tab.
	// <autogenerated> lines are impossible to match so those are filtered out.
	var res []string
	for _, line := range strings.Split(out, "\n") {
		if strings.HasSuffix(line, "\r") { // remove '\r', output by compiler on windows
			line = line[:len(line)-1]
		}
		if strings.HasPrefix(line, "\t") {
			res[len(res)-1] += "\n" + line
		} else if strings.HasPrefix(line, "go tool") || strings.HasPrefix(line, "#") || !wantAuto && strings.HasPrefix(line, "<autogenerated>") {
			continue
		} else if strings.TrimSpace(line) != "" {
			res = append(res, line)
		}
	}
	return res
}

// errorCheck matches errors in outStr against comments in source files.
// For each line of the source files which should generate an error,
// there should be a comment of the form // ERROR "regexp".
// If outStr has an error for a line which has no such comment,
// this function will report an error.
// Likewise if outStr does not have an error for a line which has a comment,
// or if the error message does not match the <regexp>.
// The <regexp> syntax is Perl but it's best to stick to egrep.
//
// Sources files are supplied as fullshort slice.
// It consists of pairs: full path to source file and its base name.
func (t test) errorCheck(outStr string, wantAuto bool, fullshort ...string) (err error) {
	defer func() {
		if testing.Verbose() && err != nil {
			t.Logf("gc output:\n%s", outStr)
		}
	}()
	var errs []error
	out := splitOutput(outStr, wantAuto)

	// Cut directory name.
	for i := range out {
		for j := 0; j < len(fullshort); j += 2 {
			full, short := fullshort[j], fullshort[j+1]
			out[i] = replacePrefix(out[i], full, short)
		}
	}

	var want []wantedError
	for j := 0; j < len(fullshort); j += 2 {
		full, short := fullshort[j], fullshort[j+1]
		want = append(want, t.wantedErrors(full, short)...)
	}

	for _, we := range want {
		var errmsgs []string
		if we.auto {
			errmsgs, out = partitionStrings("<autogenerated>", out)
		} else {
			errmsgs, out = partitionStrings(we.prefix, out)
		}
		if len(errmsgs) == 0 {
			errs = append(errs, fmt.Errorf("%s:%d: missing error %q", we.file, we.lineNum, we.reStr))
			continue
		}
		matched := false
		n := len(out)
		for _, errmsg := range errmsgs {
			// Assume errmsg says "file:line: foo".
			// Cut leading "file:line: " to avoid accidental matching of file name instead of message.
			text := errmsg
			if _, suffix, ok := strings.Cut(text, " "); ok {
				text = suffix
			}
			if we.re.MatchString(text) {
				matched = true
			} else {
				out = append(out, errmsg)
			}
		}
		if !matched {
			errs = append(errs, fmt.Errorf("%s:%d: no match for %#q in:\n\t%s", we.file, we.lineNum, we.reStr, strings.Join(out[n:], "\n\t")))
			continue
		}
	}

	if len(out) > 0 {
		errs = append(errs, fmt.Errorf("Unmatched Errors:"))
		for _, errLine := range out {
			errs = append(errs, fmt.Errorf("%s", errLine))
		}
	}

	if len(errs) == 0 {
		return nil
	}
	if len(errs) == 1 {
		return errs[0]
	}
	var buf bytes.Buffer
	fmt.Fprintf(&buf, "\n")
	for _, err := range errs {
		fmt.Fprintf(&buf, "%s\n", err.Error())
	}
	return errors.New(buf.String())
}

func (test) updateErrors(out, file string) {
	base := path.Base(file)
	// Read in source file.
	src, err := os.ReadFile(file)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		return
	}
	lines := strings.Split(string(src), "\n")
	// Remove old errors.
	for i := range lines {
		lines[i], _, _ = strings.Cut(lines[i], " // ERROR ")
	}
	// Parse new errors.
	errors := make(map[int]map[string]bool)
	tmpRe := regexp.MustCompile(`autotmp_\d+`)
	fileRe := regexp.MustCompile(`(\.go):\d+:`)
	for _, errStr := range splitOutput(out, false) {
		m := fileRe.FindStringSubmatchIndex(errStr)
		if len(m) != 4 {
			continue
		}
		// The end of the file is the end of the first and only submatch.
		errFile := errStr[:m[3]]
		rest := errStr[m[3]+1:]
		if errFile != file {
			continue
		}
		lineStr, msg, ok := strings.Cut(rest, ":")
		if !ok {
			continue
		}
		line, err := strconv.Atoi(lineStr)
		line--
		if err != nil || line < 0 || line >= len(lines) {
			continue
		}
		msg = strings.Replace(msg, file, base, -1) // normalize file mentions in error itself
		msg = strings.TrimLeft(msg, " \t")
		for _, r := range []string{`\`, `*`, `+`, `?`, `[`, `]`, `(`, `)`} {
			msg = strings.Replace(msg, r, `\`+r, -1)
		}
		msg = strings.Replace(msg, `"`, `.`, -1)
		msg = tmpRe.ReplaceAllLiteralString(msg, `autotmp_[0-9]+`)
		if errors[line] == nil {
			errors[line] = make(map[string]bool)
		}
		errors[line][msg] = true
	}
	// Add new errors.
	for line, errs := range errors {
		var sorted []string
		for e := range errs {
			sorted = append(sorted, e)
		}
		sort.Strings(sorted)
		lines[line] += " // ERROR"
		for _, e := range sorted {
			lines[line] += fmt.Sprintf(` "%s$"`, e)
		}
	}
	// Write new file.
	err = os.WriteFile(file, []byte(strings.Join(lines, "\n")), 0640)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		return
	}
	// Polish.
	exec.Command(goTool, "fmt", file).CombinedOutput()
}

// matchPrefix reports whether s is of the form ^(.*/)?prefix(:|[),
// That is, it needs the file name prefix followed by a : or a [,
// and possibly preceded by a directory name.
func matchPrefix(s, prefix string) bool {
	i := strings.Index(s, ":")
	if i < 0 {
		return false
	}
	j := strings.LastIndex(s[:i], "/")
	s = s[j+1:]
	if len(s) <= len(prefix) || s[:len(prefix)] != prefix {
		return false
	}
	switch s[len(prefix)] {
	case '[', ':':
		return true
	}
	return false
}

func partitionStrings(prefix string, strs []string) (matched, unmatched []string) {
	for _, s := range strs {
		if matchPrefix(s, prefix) {
			matched = append(matched, s)
		} else {
			unmatched = append(unmatched, s)
		}
	}
	return
}

type wantedError struct {
	reStr   string
	re      *regexp.Regexp
	lineNum int
	auto    bool // match <autogenerated> line
	file    string
	prefix  string
}

var (
	errRx       = regexp.MustCompile(`// (?:GC_)?ERROR (.*)`)
	errAutoRx   = regexp.MustCompile(`// (?:GC_)?ERRORAUTO (.*)`)
	errQuotesRx = regexp.MustCompile(`"([^"]*)"`)
	lineRx      = regexp.MustCompile(`LINE(([+-])(\d+))?`)
)

func (t test) wantedErrors(file, short string) (errs []wantedError) {
	cache := make(map[string]*regexp.Regexp)

	src, _ := os.ReadFile(file)
	for i, line := range strings.Split(string(src), "\n") {
		lineNum := i + 1
		if strings.Contains(line, "////") {
			// double comment disables ERROR
			continue
		}
		var auto bool
		m := errAutoRx.FindStringSubmatch(line)
		if m != nil {
			auto = true
		} else {
			m = errRx.FindStringSubmatch(line)
		}
		if m == nil {
			continue
		}
		all := m[1]
		mm := errQuotesRx.FindAllStringSubmatch(all, -1)
		if mm == nil {
			t.Fatalf("%s:%d: invalid errchk line: %s", t.goFileName(), lineNum, line)
		}
		for _, m := range mm {
			rx := lineRx.ReplaceAllStringFunc(m[1], func(m string) string {
				n := lineNum
				if strings.HasPrefix(m, "LINE+") {
					delta, _ := strconv.Atoi(m[5:])
					n += delta
				} else if strings.HasPrefix(m, "LINE-") {
					delta, _ := strconv.Atoi(m[5:])
					n -= delta
				}
				return fmt.Sprintf("%s:%d", short, n)
			})
			re := cache[rx]
			if re == nil {
				var err error
				re, err = regexp.Compile(rx)
				if err != nil {
					t.Fatalf("%s:%d: invalid regexp \"%s\" in ERROR line: %v", t.goFileName(), lineNum, rx, err)
				}
				cache[rx] = re
			}
			prefix := fmt.Sprintf("%s:%d", short, lineNum)
			errs = append(errs, wantedError{
				reStr:   rx,
				re:      re,
				prefix:  prefix,
				auto:    auto,
				lineNum: lineNum,
				file:    short,
			})
		}
	}

	return
}

const (
	// Regexp to match a single opcode check: optionally begin with "-" (to indicate
	// a negative check), followed by a string literal enclosed in "" or ``. For "",
	// backslashes must be handled.
	reMatchCheck = `-?(?:\x60[^\x60]*\x60|"(?:[^"\\]|\\.)*")`
)

var (
	// Regexp to split a line in code and comment, trimming spaces
	rxAsmComment = regexp.MustCompile(`^\s*(.*?)\s*(?://\s*(.+)\s*)?$`)

	// Regexp to extract an architecture check: architecture name (or triplet),
	// followed by semi-colon, followed by a comma-separated list of opcode checks.
	// Extraneous spaces are ignored.
	//
	// An example: arm64/v8.1 : -`ADD` , `SUB`
	//	"(\w+)" matches "arm64" (architecture name)
	//	"(/[\w.]+)?" matches "v8.1" (architecture version)
	//	"(/\w*)?" doesn't match anything here (it's an optional part of the triplet)
	//	"\s*:\s*" matches " : " (semi-colon)
	//	"(" starts a capturing group
	//      first reMatchCheck matches "-`ADD`"
	//	`(?:" starts a non-capturing group
	//	"\s*,\s*` matches " , "
	//	second reMatchCheck matches "`SUB`"
	//	")*)" closes started groups; "*" means that there might be other elements in the comma-separated list
	rxAsmPlatform = regexp.MustCompile(`(\w+)(/[\w.]+)?(/\w*)?\s*:\s*(` + reMatchCheck + `(?:\s*,\s*` + reMatchCheck + `)*)`)

	// Regexp to extract a single opcoded check
	rxAsmCheck = regexp.MustCompile(reMatchCheck)

	// List of all architecture variants. Key is the GOARCH architecture,
	// value[0] is the variant-changing environment variable, and values[1:]
	// are the supported variants.
	archVariants = map[string][]string{
		"386":     {"GO386", "sse2", "softfloat"},
		"amd64":   {"GOAMD64", "v1", "v2", "v3", "v4"},
		"arm":     {"GOARM", "5", "6", "7", "7,softfloat"},
		"arm64":   {"GOARM64", "v8.0", "v8.1"},
		"loong64": {},
		"mips":    {"GOMIPS", "hardfloat", "softfloat"},
		"mips64":  {"GOMIPS64", "hardfloat", "softfloat"},
		"ppc64":   {"GOPPC64", "power8", "power9", "power10"},
		"ppc64le": {"GOPPC64", "power8", "power9", "power10"},
		"ppc64x":  {}, // A pseudo-arch representing both ppc64 and ppc64le
		"s390x":   {},
		"wasm":    {},
		"riscv64": {"GORISCV64", "rva20u64", "rva22u64"},
	}
)

// wantedAsmOpcode is a single asmcheck check
type wantedAsmOpcode struct {
	fileline string         // original source file/line (eg: "/path/foo.go:45")
	line     int            // original source line
	opcode   *regexp.Regexp // opcode check to be performed on assembly output
	negative bool           // true if the check is supposed to fail rather than pass
	found    bool           // true if the opcode check matched at least one in the output
}

// A build environment triplet separated by slashes (eg: linux/386/sse2).
// The third field can be empty if the arch does not support variants (eg: "plan9/amd64/")
type buildEnv string

// Environ returns the environment it represents in cmd.Environ() "key=val" format
// For instance, "linux/386/sse2".Environ() returns {"GOOS=linux", "GOARCH=386", "GO386=sse2"}
func (b buildEnv) Environ() []string {
	fields := strings.Split(string(b), "/")
	if len(fields) != 3 {
		panic("invalid buildEnv string: " + string(b))
	}
	env := []string{"GOOS=" + fields[0], "GOARCH=" + fields[1]}
	if fields[2] != "" {
		env = append(env, archVariants[fields[1]][0]+"="+fields[2])
	}
	return env
}

// asmChecks represents all the asmcheck checks present in a test file
// The outer map key is the build triplet in which the checks must be performed.
// The inner map key represent the source file line ("filename.go:1234") at which the
// checks must be performed.
type asmChecks map[buildEnv]map[string][]wantedAsmOpcode

// Envs returns all the buildEnv in which at least one check is present
func (a asmChecks) Envs() []buildEnv {
	var envs []buildEnv
	for e := range a {
		envs = append(envs, e)
	}
	sort.Slice(envs, func(i, j int) bool {
		return string(envs[i]) < string(envs[j])
	})
	return envs
}

func (t test) wantedAsmOpcodes(fn string) asmChecks {
	ops := make(asmChecks)

	comment := ""
	src, err := os.ReadFile(fn)
	if err != nil {
		t.Fatal(err)
	}
	for i, line := range strings.Split(string(src), "\n") {
		matches := rxAsmComment.FindStringSubmatch(line)
		code, cmt := matches[1], matches[2]

		// Keep comments pending in the comment variable until
		// we find a line that contains some code.
		comment += " " + cmt
		if code == "" {
			continue
		}

		// Parse and extract any architecture check from comments,
		// made by one architecture name and multiple checks.
		lnum := fn + ":" + strconv.Itoa(i+1)
		for _, ac := range rxAsmPlatform.FindAllStringSubmatch(comment, -1) {
			archspec, allchecks := ac[1:4], ac[4]

			var arch, subarch, os string
			switch {
			case archspec[2] != "": // 3 components: "linux/386/sse2"
				os, arch, subarch = archspec[0], archspec[1][1:], archspec[2][1:]
			case archspec[1] != "": // 2 components: "386/sse2"
				os, arch, subarch = "linux", archspec[0], archspec[1][1:]
			default: // 1 component: "386"
				os, arch, subarch = "linux", archspec[0], ""
				if arch == "wasm" {
					os = "js"
				}
			}

			if _, ok := archVariants[arch]; !ok {
				t.Fatalf("%s:%d: unsupported architecture: %v", t.goFileName(), i+1, arch)
			}

			// Create the build environments corresponding the above specifiers
			envs := make([]buildEnv, 0, 4)
			arches := []string{arch}
			// ppc64x is a pseudo-arch, generate tests for both endian variants.
			if arch == "ppc64x" {
				arches = []string{"ppc64", "ppc64le"}
			}
			for _, arch := range arches {
				if subarch != "" {
					envs = append(envs, buildEnv(os+"/"+arch+"/"+subarch))
				} else {
					subarchs := archVariants[arch]
					if len(subarchs) == 0 {
						envs = append(envs, buildEnv(os+"/"+arch+"/"))
					} else {
						for _, sa := range archVariants[arch][1:] {
							envs = append(envs, buildEnv(os+"/"+arch+"/"+sa))
						}
					}
				}
			}

			for _, m := range rxAsmCheck.FindAllString(allchecks, -1) {
				negative := false
				if m[0] == '-' {
					negative = true
					m = m[1:]
				}

				rxsrc, err := strconv.Unquote(m)
				if err != nil {
					t.Fatalf("%s:%d: error unquoting string: %v", t.goFileName(), i+1, err)
				}

				// Compile the checks as regular expressions. Notice that we
				// consider checks as matching from the beginning of the actual
				// assembler source (that is, what is left on each line of the
				// compile -S output after we strip file/line info) to avoid
				// trivial bugs such as "ADD" matching "FADD". This
				// doesn't remove genericity: it's still possible to write
				// something like "F?ADD", but we make common cases simpler
				// to get right.
				oprx, err := regexp.Compile("^" + rxsrc)
				if err != nil {
					t.Fatalf("%s:%d: %v", t.goFileName(), i+1, err)
				}

				for _, env := range envs {
					if ops[env] == nil {
						ops[env] = make(map[string][]wantedAsmOpcode)
					}
					ops[env][lnum] = append(ops[env][lnum], wantedAsmOpcode{
						negative: negative,
						fileline: lnum,
						line:     i + 1,
						opcode:   oprx,
					})
				}
			}
		}
		comment = ""
	}

	return ops
}

func (t test) asmCheck(outStr string, fn string, env buildEnv, fullops map[string][]wantedAsmOpcode) error {
	// The assembly output contains the concatenated dump of multiple functions.
	// the first line of each function begins at column 0, while the rest is
	// indented by a tabulation. These data structures help us index the
	// output by function.
	functionMarkers := make([]int, 1)
	lineFuncMap := make(map[string]int)

	lines := strings.Split(outStr, "\n")
	rxLine := regexp.MustCompile(fmt.Sprintf(`\((%s:\d+)\)\s+(.*)`, regexp.QuoteMeta(fn)))

	for nl, line := range lines {
		// Check if this line begins a function
		if len(line) > 0 && line[0] != '\t' {
			functionMarkers = append(functionMarkers, nl)
		}

		// Search if this line contains a assembly opcode (which is prefixed by the
		// original source file/line in parenthesis)
		matches := rxLine.FindStringSubmatch(line)
		if len(matches) == 0 {
			continue
		}
		srcFileLine, asm := matches[1], matches[2]

		// Associate the original file/line information to the current
		// function in the output; it will be useful to dump it in case
		// of error.
		lineFuncMap[srcFileLine] = len(functionMarkers) - 1

		// If there are opcode checks associated to this source file/line,
		// run the checks.
		if ops, found := fullops[srcFileLine]; found {
			for i := range ops {
				if !ops[i].found && ops[i].opcode.FindString(asm) != "" {
					ops[i].found = true
				}
			}
		}
	}
	functionMarkers = append(functionMarkers, len(lines))

	var failed []wantedAsmOpcode
	for _, ops := range fullops {
		for _, o := range ops {
			// There's a failure if a negative match was found,
			// or a positive match was not found.
			if o.negative == o.found {
				failed = append(failed, o)
			}
		}
	}
	if len(failed) == 0 {
		return nil
	}

	// At least one asmcheck failed; report them.
	lastFunction := -1
	var errbuf bytes.Buffer
	fmt.Fprintln(&errbuf)
	sort.Slice(failed, func(i, j int) bool { return failed[i].line < failed[j].line })
	for _, o := range failed {
		// Dump the function in which this opcode check was supposed to
		// pass but failed.
		funcIdx := lineFuncMap[o.fileline]
		if funcIdx != 0 && funcIdx != lastFunction {
			funcLines := lines[functionMarkers[funcIdx]:functionMarkers[funcIdx+1]]
			t.Log(strings.Join(funcLines, "\n"))
			lastFunction = funcIdx // avoid printing same function twice
		}

		if o.negative {
			fmt.Fprintf(&errbuf, "%s:%d: %s: wrong opcode found: %q\n", t.goFileName(), o.line, env, o.opcode.String())
		} else {
			fmt.Fprintf(&errbuf, "%s:%d: %s: opcode not found: %q\n", t.goFileName(), o.line, env, o.opcode.String())
		}
	}
	return errors.New(errbuf.String())
}

// defaultRunOutputLimit returns the number of runoutput tests that
// can be executed in parallel.
func defaultRunOutputLimit() int {
	const maxArmCPU = 2

	cpu := runtime.NumCPU()
	if runtime.GOARCH == "arm" && cpu > maxArmCPU {
		cpu = maxArmCPU
	}
	return cpu
}

func TestShouldTest(t *testing.T) {
	if *shard != 0 {
		t.Skipf("nothing to test on shard index %d", *shard)
	}

	assert := func(ok bool, _ string) {
		t.Helper()
		if !ok {
			t.Error("test case failed")
		}
	}
	assertNot := func(ok bool, _ string) { t.Helper(); assert(!ok, "") }

	// Simple tests.
	assert(shouldTest("// +build linux", "linux", "arm"))
	assert(shouldTest("// +build !windows", "linux", "arm"))
	assertNot(shouldTest("// +build !windows", "windows", "amd64"))

	// A file with no build tags will always be tested.
	assert(shouldTest("// This is a test.", "os", "arch"))

	// Build tags separated by a space are OR-ed together.
	assertNot(shouldTest("// +build arm 386", "linux", "amd64"))

	// Build tags separated by a comma are AND-ed together.
	assertNot(shouldTest("// +build !windows,!plan9", "windows", "amd64"))
	assertNot(shouldTest("// +build !windows,!plan9", "plan9", "386"))

	// Build tags on multiple lines are AND-ed together.
	assert(shouldTest("// +build !windows\n// +build amd64", "linux", "amd64"))
	assertNot(shouldTest("// +build !windows\n// +build amd64", "windows", "amd64"))

	// Test that (!a OR !b) matches anything.
	assert(shouldTest("// +build !windows !plan9", "windows", "amd64"))

	// Test that //go:build tag match.
	assert(shouldTest("//go:build go1.4", "linux", "amd64"))
}

// overlayDir makes a minimal-overhead copy of srcRoot in which new files may be added.
func overlayDir(dstRoot, srcRoot string) error {
	dstRoot = filepath.Clean(dstRoot)
	if err := os.MkdirAll(dstRoot, 0777); err != nil {
		return err
	}

	srcRoot, err := filepath.Abs(srcRoot)
	if err != nil {
		return err
	}

	return filepath.WalkDir(srcRoot, func(srcPath string, d fs.DirEntry, err error) error {
		if err != nil || srcPath == srcRoot {
			return err
		}

		suffix := strings.TrimPrefix(srcPath, srcRoot)
		for len(suffix) > 0 && suffix[0] == filepath.Separator {
			suffix = suffix[1:]
		}
		dstPath := filepath.Join(dstRoot, suffix)

		var info fs.FileInfo
		if d.Type()&os.ModeSymlink != 0 {
			info, err = os.Stat(srcPath)
		} else {
			info, err = d.Info()
		}
		if err != nil {
			return err
		}
		perm := info.Mode() & os.ModePerm

		// Always copy directories (don't symlink them).
		// If we add a file in the overlay, we don't want to add it in the original.
		if info.IsDir() {
			return os.MkdirAll(dstPath, perm|0200)
		}

		// If the OS supports symlinks, use them instead of copying bytes.
		if err := os.Symlink(srcPath, dstPath); err == nil {
			return nil
		}

		// Otherwise, copy the bytes.
		src, err := os.Open(srcPath)
		if err != nil {
			return err
		}
		defer src.Close()

		dst, err := os.OpenFile(dstPath, os.O_WRONLY|os.O_CREATE|os.O_EXCL, perm)
		if err != nil {
			return err
		}

		_, err = io.Copy(dst, src)
		if closeErr := dst.Close(); err == nil {
			err = closeErr
		}
		return err
	})
}

// The following sets of files are excluded from testing depending on configuration.
// The types2Failures(32Bit) files pass with the 1.17 compiler but don't pass with
// the 1.18 compiler using the new types2 type checker, or pass with sub-optimal
// error(s).

// List of files that the compiler cannot errorcheck with the new typechecker (types2).
var types2Failures = setOf(
	"shift1.go",               // types2 reports two new errors which are probably not right
	"fixedbugs/issue10700.go", // types2 should give hint about ptr to interface
	"fixedbugs/issue18331.go", // missing error about misuse of //go:noescape (irgen needs code from noder)
	"fixedbugs/issue18419.go", // types2 reports no field or method member, but should say unexported
	"fixedbugs/issue20233.go", // types2 reports two instead of one error (preference: 1.17 compiler)
	"fixedbugs/issue20245.go", // types2 reports two instead of one error (preference: 1.17 compiler)
	"fixedbugs/issue31053.go", // types2 reports "unknown field" instead of "cannot refer to unexported field"
)

var types2Failures32Bit = setOf(
	"printbig.go",             // large untyped int passed to print (32-bit)
	"fixedbugs/bug114.go",     // large untyped int passed to println (32-bit)
	"fixedbugs/issue23305.go", // large untyped int passed to println (32-bit)
)

// In all of these cases, the 1.17 compiler reports reasonable errors, but either the
// 1.17 or 1.18 compiler report extra errors, so we can't match correctly on both. We
// now set the patterns to match correctly on all the 1.18 errors.
// This list remains here just as a reference and for comparison - these files all pass.
var _ = setOf(
	"import1.go",      // types2 reports extra errors
	"initializerr.go", // types2 reports extra error
	"typecheck.go",    // types2 reports extra error at function call

	"fixedbugs/bug176.go", // types2 reports all errors (pref: types2)
	"fixedbugs/bug195.go", // types2 reports slight different errors, and an extra error
	"fixedbugs/bug412.go", // types2 produces a follow-on error

	"fixedbugs/issue11614.go", // types2 reports an extra error
	"fixedbugs/issue17038.go", // types2 doesn't report a follow-on error (pref: types2)
	"fixedbugs/issue23732.go", // types2 reports different (but ok) line numbers
	"fixedbugs/issue4510.go",  // types2 reports different (but ok) line numbers
	"fixedbugs/issue7525b.go", // types2 reports init cycle error on different line - ok otherwise
	"fixedbugs/issue7525c.go", // types2 reports init cycle error on different line - ok otherwise
	"fixedbugs/issue7525d.go", // types2 reports init cycle error on different line - ok otherwise
	"fixedbugs/issue7525e.go", // types2 reports init cycle error on different line - ok otherwise
	"fixedbugs/issue7525.go",  // types2 reports init cycle error on different line - ok otherwise
)

func setOf(keys ...string) map[string]bool {
	m := make(map[string]bool, len(keys))
	for _, key := range keys {
		m[key] = true
	}
	return m
}

// splitQuoted splits the string s around each instance of one or more consecutive
// white space characters while taking into account quotes and escaping, and
// returns an array of substrings of s or an empty list if s contains only white space.
// Single quotes and double quotes are recognized to prevent splitting within the
// quoted region, and are removed from the resulting substrings. If a quote in s
// isn't closed err will be set and r will have the unclosed argument as the
// last element. The backslash is used for escaping.
//
// For example, the following string:
//
//	a b:"c d" 'e''f'  "g\""
//
// Would be parsed as:
//
//	[]string{"a", "b:c d", "ef", `g"`}
//
// [copied from src/go/build/build.go]
func splitQuoted(s string) (r []string, err error) {
	var args []string
	arg := make([]rune, len(s))
	escaped := false
	quoted := false
	quote := '\x00'
	i := 0
	for _, rune := range s {
		switch {
		case escaped:
			escaped = false
		case rune == '\\':
			escaped = true
			continue
		case quote != '\x00':
			if rune == quote {
				quote = '\x00'
				continue
			}
		case rune == '"' || rune == '\'':
			quoted = true
			quote = rune
			continue
		case unicode.IsSpace(rune):
			if quoted || i > 0 {
				quoted = false
				args = append(args, string(arg[:i]))
				i = 0
			}
			continue
		}
		arg[i] = rune
		i++
	}
	if quoted || i > 0 {
		args = append(args, string(arg[:i]))
	}
	if quote != 0 {
		err = errors.New("unclosed quote")
	} else if escaped {
		err = errors.New("unfinished escaping")
	}
	return args, err
}

// replacePrefix is like strings.ReplaceAll, but only replaces instances of old
// that are preceded by ' ', '\t', or appear at the beginning of a line.
//
// This does the same kind of filename string replacement as cmd/go.
// Pilfered from src/cmd/go/internal/work/shell.go .
func replacePrefix(s, old, new string) string {
	n := strings.Count(s, old)
	if n == 0 {
		return s
	}

	s = strings.ReplaceAll(s, " "+old, " "+new)
	s = strings.ReplaceAll(s, "\n"+old, "\n"+new)
	s = strings.ReplaceAll(s, "\n\t"+old, "\n\t"+new)
	if strings.HasPrefix(s, old) {
		s = new + s[len(old):]
	}
	return s
}
```
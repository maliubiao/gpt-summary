Response: My thinking process to analyze the Go code and fulfill the request goes like this:

1. **Understand the Goal:** The core purpose is to test the inlining heuristics of the Go compiler. This means verifying the properties the compiler infers about functions that influence inlining decisions.

2. **Identify Key Functions and Data Structures:** I scan the code for prominent functions and data structures that seem central to the testing process.

    * `TestFuncProperties`: This is the main test function. It iterates through test cases.
    * `gatherPropsDumpForFile`:  This function seems responsible for running the compiler and capturing the output related to inlining properties. The `-d=dumpinlfuncprops` flag is a strong clue.
    * `readDump`: This function parses the output generated by `gatherPropsDumpForFile`.
    * `compareEntries`: This function compares the actual output with the expected output.
    * `genExpected`:  This generates the "expected" output.
    * `updateExpected`: This function updates the expected output if the `-update-expected` flag is used.
    * `fnInlHeur`, `FuncProps`, `encodedCallSiteTab`, `propsAndScore`: These are data structures likely used to represent the function properties extracted from the compiler output.

3. **Trace the Test Flow:** I follow the execution flow of `TestFuncProperties` to understand the overall process:

    * **Setup:** Create a temporary directory.
    * **Iteration:** Loop through test cases (e.g., "funcflags", "returns").
    * **Dump Generation:** Call `gatherPropsDumpForFile` to run the compiler with the dump flag, generating a dump file.
    * **Dump Reading:** Call `readDump` to parse the generated dump file into data structures.
    * **Expected Handling:**
        * **Update Mode:** If `-update-expected` is set, call `updateExpected` to regenerate the expected output.
        * **Comparison Mode:** Otherwise, call `genExpected` to read the existing expected output, and then call `compareEntries` to compare the generated and expected data.

4. **Analyze Individual Functions:** I delve deeper into the purpose and workings of the key functions:

    * **`gatherPropsDumpForFile`:**  The critical part is the `-gcflags=-d=dumpinlfuncprops=...` which tells the compiler to output information about function inlining properties to a specified file. The code also handles potential caching issues by creating a unique filename for the dump.
    * **`readDump`:**  This function parses the structured output from the compiler. The delimiters (`preambleDelimiter`, `comDelimiter`, `csDelimiter`, `fnDelimiter`) are important for understanding how the dump file is organized. It deserializes JSON for function properties and parses the call site information.
    * **`compareEntries`:** This function performs detailed comparisons of function flags, return properties, parameter properties, and call site information.
    * **`genExpected`:**  This function extracts the expected output directly from the test Go files by looking for lines starting with `// `. This implies the expected output is embedded as comments in the test files.
    * **`updateExpected`:** This is for updating the expected output. It reads the existing Go file, processes the generated dump data, and rewrites the Go file with updated comments reflecting the new dump information. It handles cases with multiple functions on the same line and closures.

5. **Infer the Go Language Feature:**  Based on the `-d=dumpinlfuncprops` flag and the data being extracted (function flags, return properties, parameter properties, call site information), it's clear that this code tests the **Go compiler's inlining heuristics**. Inlining is a compiler optimization where the code of a function call is inserted directly into the calling function, potentially improving performance. The heuristics determine which functions are suitable for inlining.

6. **Construct Go Code Examples:**  To illustrate the functionality, I create simple Go code examples that correspond to the different test cases ("funcflags", "returns", "params", "acrosscall", "calls", "returns2"). These examples should be designed to demonstrate different aspects of function properties that affect inlining.

7. **Explain Command-Line Arguments:** I focus on the `-update-expected` flag and explain its purpose (regenerating expected output).

8. **Identify Potential Pitfalls:**  I consider common mistakes users might make:

    * **Forgetting to run with `-update-expected`:** When inlining heuristics change, the tests will fail. The user needs to regenerate the expected output.
    * **Manually editing expected files:**  This is discouraged, as the `-update-expected` mechanism should be used.
    * **Not understanding the test data format:** The expected output is embedded in comments, which might be surprising to some users.

9. **Structure the Response:** I organize the information logically, covering the requested points: functionality, inferred Go feature with examples, command-line arguments, and potential pitfalls. I use clear headings and formatting for readability.

By following these steps, I can effectively analyze the provided Go code and generate a comprehensive and accurate response that addresses all aspects of the request.
这段代码是 Go 编译器的一部分，位于 `go/src/cmd/compile/internal/inline/inlheur/funcprops_test.go`，它的主要功能是 **测试 Go 编译器的内联启发式算法 (inlining heuristics) 中用于提取函数属性的功能**。

更具体地说，它测试了编译器在编译 Go 代码时，能否正确地提取出影响函数是否可以被内联的各种属性。

**功能列表:**

1. **收集函数属性信息:** 通过运行 Go 编译器并使用 `-d=dumpinlfuncprops=...` 编译选项，针对一组测试用例中的 Go 代码，收集编译器提取出的函数属性信息。这些信息包括函数的各种标志 (flags)、返回值属性、参数属性以及调用点信息。
2. **读取和解析编译器输出:**  `readDump` 函数负责读取并解析编译器生成的包含函数属性信息的转储文件。它将这些信息反序列化为 Go 的数据结构，例如 `fnInlHeur` 和 `encodedCallSiteTab`。
3. **生成期望的输出:** `genExpected` 函数从测试用例的 Go 代码文件中提取以 `// ` 开头的注释行，作为期望的函数属性信息。这部分信息是预先定义好的，用于和编译器实际提取出的信息进行比较。
4. **比较实际输出和期望输出:** `compareEntries` 函数对比编译器实际生成的函数属性信息和预期的信息，包括函数标志、返回值属性、参数属性以及调用点信息，并报告任何不一致之处。
5. **更新期望输出 (可选):**  如果运行测试时带有 `-update-expected` 标志，`updateExpected` 函数会将编译器新生成的函数属性信息写回到测试用例的 Go 代码文件中，更新期望的输出。这通常在修改了内联启发式算法后使用。

**推理的 Go 语言功能实现：内联启发式算法 (Inlining Heuristics)**

内联是 Go 编译器的一种优化技术，它将一个函数的代码直接插入到调用该函数的地方，以减少函数调用的开销。编译器需要使用一套启发式规则来判断哪些函数适合内联。这段测试代码就是用来验证这些启发式规则是否正确地工作，并提取出正确的函数属性，从而影响内联决策。

**Go 代码举例说明:**

假设 `testdata/props/funcflags.go` 文件包含以下 Go 代码：

```go
// Copyright 2023 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package funcflags

// T_SimpleFunc noinline:false
func T_SimpleFunc() {
}

// T_ExportedFunc noinline:false
func T_ExportedFunc() {
}

// T_ReceiverFunc noinline:false
type ReceiverType struct{}
func (r ReceiverType) T_ReceiverFunc() {
}
```

运行 `go test -v -run=TestFuncProperties` (不带 `-update-expected`) 时，`gatherPropsDumpForFile` 会调用 Go 编译器，并使用 `-d=dumpinlfuncprops=` 生成一个包含函数属性信息的转储文件，例如 `funcflags.dump.txt`。

`readDump` 会读取这个文件，解析出类似下面的信息（简化版本）：

```
// go/src/cmd/compile/internal/inline/inlheur/testdata/props/funcflags.go T_SimpleFunc 7
// com
// {"Flags":1}
// cs
// fn
// go/src/cmd/compile/internal/inline/inlheur/testdata/props/funcflags.go T_ExportedFunc 11
// com
// {"Flags":1}
// cs
// fn
// go/src/cmd/compile/internal/inline/inlheur/testdata/props/funcflags.go ReceiverType.T_ReceiverFunc 15
// com
// {"Flags":1}
// cs
// fn
```

`genExpected` 会读取 `testdata/props/funcflags.go` 文件，提取出以 `// ` 开头的注释行作为期望的输出。

`compareEntries` 会比较实际解析出的 `Flags` 值 (例如，对于 `T_SimpleFunc`，`Flags` 可能是 1，代表某些特定的函数标志) 和 `genExpected` 生成的预期信息。

**带假设的输入与输出:**

**假设输入 (testdata/props/funcflags.go):**  如上所示。

**假设编译器生成的 dump 文件内容 (funcflags.dump.txt):**  如上所示的简化版本。

**假设 `genExpected` 生成的期望信息 (基于 funcflags.go 的注释):**

```
// T_SimpleFunc noinline:false
// T_ExportedFunc noinline:false
// T_ReceiverFunc noinline:false
```

**`compareEntries` 的比较过程:**

`compareEntries` 会将解析出的 `fnInlHeur` 结构体中的 `props.Flags` 与期望的信息进行对比。 例如，对于 `T_SimpleFunc`，如果解析出的 `props.Flags` 对应的字符串表示与期望的 "noinline:false" 不符，则会报告错误。

**命令行参数的具体处理:**

* **`-update-expected`:** 这是一个布尔类型的 flag。
    * **不使用时 (默认):** 测试会比较实际生成的函数属性信息和预先定义在测试用例 Go 文件中的期望信息。如果两者不一致，测试会失败。
    * **使用时 (`go test -v -run=TestFuncProperties -args -update-expected`):**  测试会运行，生成新的函数属性信息，并将这些信息更新到对应的测试用例 Go 文件中，替换原有的期望信息。这用于当编译器内联启发式算法发生变化时，更新测试用例的期望结果。

**使用者易犯错的点:**

1. **修改了内联启发式算法后忘记运行 `-update-expected`:**  如果开发者修改了 Go 编译器的内联启发式算法，导致编译器提取出的函数属性信息发生变化，但不运行带有 `-update-expected` 标志的测试，那么测试会因为实际输出与旧的期望输出不一致而失败。开发者需要记得在修改内联逻辑后更新期望结果。

   **错误示例:**

   假设修改了编译器，使得 `T_SimpleFunc` 的 `Flags` 值发生了变化。如果不运行 `go test -v -run=TestFuncProperties -args -update-expected`，测试会报告类似以下的错误：

   ```
   --- FAIL: TestFuncProperties (0.01s)
       funcprops_test.go:75: testcase "funcflags": Flags mismatch for "T_SimpleFunc": got 新的 Flags 字符串, wanted noinline:false
   ```

   正确的做法是运行带有 `-update-expected` 的命令来更新 `testdata/props/funcflags.go` 文件中的期望信息。

2. **手动修改 `.expected` 文件或测试用例中的注释:** 虽然可以手动修改期望结果，但这通常不是推荐的做法。使用 `-update-expected` 可以确保期望结果是基于当前编译器实际输出的，避免人为错误。

总之，这段代码是 Go 编译器内联启发式算法测试的关键部分，它通过对比编译器实际提取的函数属性和预期的属性，来验证内联逻辑的正确性。`remasterflag` (通过 `-update-expected` 设置) 提供了一种方便的方式来更新测试用例的期望结果，以适应编译器算法的变化。

### 提示词
```
这是路径为go/src/cmd/compile/internal/inline/inlheur/funcprops_test.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
```

### 源代码
```go
// Copyright 2023 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package inlheur

import (
	"bufio"
	"encoding/json"
	"flag"
	"fmt"
	"internal/testenv"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"testing"
	"time"
)

var remasterflag = flag.Bool("update-expected", false, "if true, generate updated golden results in testcases for all props tests")

func TestFuncProperties(t *testing.T) {
	td := t.TempDir()
	// td = "/tmp/qqq"
	// os.RemoveAll(td)
	// os.Mkdir(td, 0777)
	testenv.MustHaveGoBuild(t)

	// NOTE: this testpoint has the unfortunate characteristic that it
	// relies on the installed compiler, meaning that if you make
	// changes to the inline heuristics code in your working copy and
	// then run the test, it will test the installed compiler and not
	// your local modifications. TODO: decide whether to convert this
	// to building a fresh compiler on the fly, or using some other
	// scheme.

	testcases := []string{"funcflags", "returns", "params",
		"acrosscall", "calls", "returns2"}
	for _, tc := range testcases {
		dumpfile, err := gatherPropsDumpForFile(t, tc, td)
		if err != nil {
			t.Fatalf("dumping func props for %q: error %v", tc, err)
		}
		// Read in the newly generated dump.
		dentries, dcsites, derr := readDump(t, dumpfile)
		if derr != nil {
			t.Fatalf("reading func prop dump: %v", derr)
		}
		if *remasterflag {
			updateExpected(t, tc, dentries, dcsites)
			continue
		}
		// Generate expected dump.
		epath, egerr := genExpected(td, tc)
		if egerr != nil {
			t.Fatalf("generating expected func prop dump: %v", egerr)
		}
		// Read in the expected result entries.
		eentries, ecsites, eerr := readDump(t, epath)
		if eerr != nil {
			t.Fatalf("reading expected func prop dump: %v", eerr)
		}
		// Compare new vs expected.
		n := len(dentries)
		eidx := 0
		for i := 0; i < n; i++ {
			dentry := dentries[i]
			dcst := dcsites[i]
			if !interestingToCompare(dentry.fname) {
				continue
			}
			if eidx >= len(eentries) {
				t.Errorf("testcase %s missing expected entry for %s, skipping", tc, dentry.fname)
				continue
			}
			eentry := eentries[eidx]
			ecst := ecsites[eidx]
			eidx++
			if dentry.fname != eentry.fname {
				t.Errorf("got fn %q wanted %q, skipping checks",
					dentry.fname, eentry.fname)
				continue
			}
			compareEntries(t, tc, &dentry, dcst, &eentry, ecst)
		}
	}
}

func propBitsToString[T interface{ String() string }](sl []T) string {
	var sb strings.Builder
	for i, f := range sl {
		fmt.Fprintf(&sb, "%d: %s\n", i, f.String())
	}
	return sb.String()
}

func compareEntries(t *testing.T, tc string, dentry *fnInlHeur, dcsites encodedCallSiteTab, eentry *fnInlHeur, ecsites encodedCallSiteTab) {
	dfp := dentry.props
	efp := eentry.props
	dfn := dentry.fname

	// Compare function flags.
	if dfp.Flags != efp.Flags {
		t.Errorf("testcase %q: Flags mismatch for %q: got %s, wanted %s",
			tc, dfn, dfp.Flags.String(), efp.Flags.String())
	}
	// Compare returns
	rgot := propBitsToString[ResultPropBits](dfp.ResultFlags)
	rwant := propBitsToString[ResultPropBits](efp.ResultFlags)
	if rgot != rwant {
		t.Errorf("testcase %q: Results mismatch for %q: got:\n%swant:\n%s",
			tc, dfn, rgot, rwant)
	}
	// Compare receiver + params.
	pgot := propBitsToString[ParamPropBits](dfp.ParamFlags)
	pwant := propBitsToString[ParamPropBits](efp.ParamFlags)
	if pgot != pwant {
		t.Errorf("testcase %q: Params mismatch for %q: got:\n%swant:\n%s",
			tc, dfn, pgot, pwant)
	}
	// Compare call sites.
	for k, ve := range ecsites {
		if vd, ok := dcsites[k]; !ok {
			t.Errorf("testcase %q missing expected callsite %q in func %q", tc, k, dfn)
			continue
		} else {
			if vd != ve {
				t.Errorf("testcase %q callsite %q in func %q: got %+v want %+v",
					tc, k, dfn, vd.String(), ve.String())
			}
		}
	}
	for k := range dcsites {
		if _, ok := ecsites[k]; !ok {
			t.Errorf("testcase %q unexpected extra callsite %q in func %q", tc, k, dfn)
		}
	}
}

type dumpReader struct {
	s  *bufio.Scanner
	t  *testing.T
	p  string
	ln int
}

// readDump reads in the contents of a dump file produced
// by the "-d=dumpinlfuncprops=..." command line flag by the Go
// compiler. It breaks the dump down into separate sections
// by function, then deserializes each func section into a
// fnInlHeur object and returns a slice of those objects.
func readDump(t *testing.T, path string) ([]fnInlHeur, []encodedCallSiteTab, error) {
	content, err := os.ReadFile(path)
	if err != nil {
		return nil, nil, err
	}
	dr := &dumpReader{
		s:  bufio.NewScanner(strings.NewReader(string(content))),
		t:  t,
		p:  path,
		ln: 1,
	}
	// consume header comment until preamble delimiter.
	found := false
	for dr.scan() {
		if dr.curLine() == preambleDelimiter {
			found = true
			break
		}
	}
	if !found {
		return nil, nil, fmt.Errorf("malformed testcase file %s, missing preamble delimiter", path)
	}
	res := []fnInlHeur{}
	csres := []encodedCallSiteTab{}
	for {
		dentry, dcst, err := dr.readEntry()
		if err != nil {
			t.Fatalf("reading func prop dump: %v", err)
		}
		if dentry.fname == "" {
			break
		}
		res = append(res, dentry)
		csres = append(csres, dcst)
	}
	return res, csres, nil
}

func (dr *dumpReader) scan() bool {
	v := dr.s.Scan()
	if v {
		dr.ln++
	}
	return v
}

func (dr *dumpReader) curLine() string {
	res := strings.TrimSpace(dr.s.Text())
	if !strings.HasPrefix(res, "// ") {
		dr.t.Fatalf("malformed line %s:%d, no comment: %s", dr.p, dr.ln, res)
	}
	return res[3:]
}

// readObjBlob reads in a series of commented lines until
// it hits a delimiter, then returns the contents of the comments.
func (dr *dumpReader) readObjBlob(delim string) (string, error) {
	var sb strings.Builder
	foundDelim := false
	for dr.scan() {
		line := dr.curLine()
		if delim == line {
			foundDelim = true
			break
		}
		sb.WriteString(line + "\n")
	}
	if err := dr.s.Err(); err != nil {
		return "", err
	}
	if !foundDelim {
		return "", fmt.Errorf("malformed input %s, missing delimiter %q",
			dr.p, delim)
	}
	return sb.String(), nil
}

// readEntry reads a single function's worth of material from
// a file produced by the "-d=dumpinlfuncprops=..." command line
// flag. It deserializes the json for the func properties and
// returns the resulting properties and function name. EOF is
// signaled by a nil FuncProps return (with no error
func (dr *dumpReader) readEntry() (fnInlHeur, encodedCallSiteTab, error) {
	var funcInlHeur fnInlHeur
	var callsites encodedCallSiteTab
	if !dr.scan() {
		return funcInlHeur, callsites, nil
	}
	// first line contains info about function: file/name/line
	info := dr.curLine()
	chunks := strings.Fields(info)
	funcInlHeur.file = chunks[0]
	funcInlHeur.fname = chunks[1]
	if _, err := fmt.Sscanf(chunks[2], "%d", &funcInlHeur.line); err != nil {
		return funcInlHeur, callsites, fmt.Errorf("scanning line %q: %v", info, err)
	}
	// consume comments until and including delimiter
	for {
		if !dr.scan() {
			break
		}
		if dr.curLine() == comDelimiter {
			break
		}
	}

	// Consume JSON for encoded props.
	dr.scan()
	line := dr.curLine()
	fp := &FuncProps{}
	if err := json.Unmarshal([]byte(line), fp); err != nil {
		return funcInlHeur, callsites, err
	}
	funcInlHeur.props = fp

	// Consume callsites.
	callsites = make(encodedCallSiteTab)
	for dr.scan() {
		line := dr.curLine()
		if line == csDelimiter {
			break
		}
		// expected format: "// callsite: <expanded pos> flagstr <desc> flagval <flags> score <score> mask <scoremask> maskstr <scoremaskstring>"
		fields := strings.Fields(line)
		if len(fields) != 12 {
			return funcInlHeur, nil, fmt.Errorf("malformed callsite (nf=%d) %s line %d: %s", len(fields), dr.p, dr.ln, line)
		}
		if fields[2] != "flagstr" || fields[4] != "flagval" || fields[6] != "score" || fields[8] != "mask" || fields[10] != "maskstr" {
			return funcInlHeur, nil, fmt.Errorf("malformed callsite %s line %d: %s",
				dr.p, dr.ln, line)
		}
		tag := fields[1]
		flagstr := fields[5]
		flags, err := strconv.Atoi(flagstr)
		if err != nil {
			return funcInlHeur, nil, fmt.Errorf("bad flags val %s line %d: %q err=%v",
				dr.p, dr.ln, line, err)
		}
		scorestr := fields[7]
		score, err2 := strconv.Atoi(scorestr)
		if err2 != nil {
			return funcInlHeur, nil, fmt.Errorf("bad score val %s line %d: %q err=%v",
				dr.p, dr.ln, line, err2)
		}
		maskstr := fields[9]
		mask, err3 := strconv.Atoi(maskstr)
		if err3 != nil {
			return funcInlHeur, nil, fmt.Errorf("bad mask val %s line %d: %q err=%v",
				dr.p, dr.ln, line, err3)
		}
		callsites[tag] = propsAndScore{
			props: CSPropBits(flags),
			score: score,
			mask:  scoreAdjustTyp(mask),
		}
	}

	// Consume function delimiter.
	dr.scan()
	line = dr.curLine()
	if line != fnDelimiter {
		return funcInlHeur, nil, fmt.Errorf("malformed testcase file %q, missing delimiter %q", dr.p, fnDelimiter)
	}

	return funcInlHeur, callsites, nil
}

// gatherPropsDumpForFile builds the specified testcase 'testcase' from
// testdata/props passing the "-d=dumpinlfuncprops=..." compiler option,
// to produce a properties dump, then returns the path of the newly
// created file. NB: we can't use "go tool compile" here, since
// some of the test cases import stdlib packages (such as "os").
// This means using "go build", which is problematic since the
// Go command can potentially cache the results of the compile step,
// causing the test to fail when being run interactively. E.g.
//
//	$ rm -f dump.txt
//	$ go build -o foo.a -gcflags=-d=dumpinlfuncprops=dump.txt foo.go
//	$ rm -f dump.txt foo.a
//	$ go build -o foo.a -gcflags=-d=dumpinlfuncprops=dump.txt foo.go
//	$ ls foo.a dump.txt > /dev/null
//	ls : cannot access 'dump.txt': No such file or directory
//	$
//
// For this reason, pick a unique filename for the dump, so as to
// defeat the caching.
func gatherPropsDumpForFile(t *testing.T, testcase string, td string) (string, error) {
	t.Helper()
	gopath := "testdata/props/" + testcase + ".go"
	outpath := filepath.Join(td, testcase+".a")
	salt := fmt.Sprintf(".p%dt%d", os.Getpid(), time.Now().UnixNano())
	dumpfile := filepath.Join(td, testcase+salt+".dump.txt")
	run := []string{testenv.GoToolPath(t), "build",
		"-gcflags=-d=dumpinlfuncprops=" + dumpfile, "-o", outpath, gopath}
	out, err := testenv.Command(t, run[0], run[1:]...).CombinedOutput()
	if err != nil {
		t.Logf("compile command: %+v", run)
	}
	if strings.TrimSpace(string(out)) != "" {
		t.Logf("%s", out)
	}
	return dumpfile, err
}

// genExpected reads in a given Go testcase file, strips out all the
// unindented (column 0) commands, writes them out to a new file, and
// returns the path of that new file. By picking out just the comments
// from the Go file we wind up with something that resembles the
// output from a "-d=dumpinlfuncprops=..." compilation.
func genExpected(td string, testcase string) (string, error) {
	epath := filepath.Join(td, testcase+".expected")
	outf, err := os.OpenFile(epath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		return "", err
	}
	gopath := "testdata/props/" + testcase + ".go"
	content, err := os.ReadFile(gopath)
	if err != nil {
		return "", err
	}
	lines := strings.Split(string(content), "\n")
	for _, line := range lines[3:] {
		if !strings.HasPrefix(line, "// ") {
			continue
		}
		fmt.Fprintf(outf, "%s\n", line)
	}
	if err := outf.Close(); err != nil {
		return "", err
	}
	return epath, nil
}

type upexState struct {
	dentries   []fnInlHeur
	newgolines []string
	atline     map[uint]uint
}

func mkUpexState(dentries []fnInlHeur) *upexState {
	atline := make(map[uint]uint)
	for _, e := range dentries {
		atline[e.line] = atline[e.line] + 1
	}
	return &upexState{
		dentries: dentries,
		atline:   atline,
	}
}

// updateExpected takes a given Go testcase file X.go and writes out a
// new/updated version of the file to X.go.new, where the column-0
// "expected" comments have been updated using fresh data from
// "dentries".
//
// Writing of expected results is complicated by closures and by
// generics, where you can have multiple functions that all share the
// same starting line. Currently we combine up all the dups and
// closures into the single pre-func comment.
func updateExpected(t *testing.T, testcase string, dentries []fnInlHeur, dcsites []encodedCallSiteTab) {
	nd := len(dentries)

	ues := mkUpexState(dentries)

	gopath := "testdata/props/" + testcase + ".go"
	newgopath := "testdata/props/" + testcase + ".go.new"

	// Read the existing Go file.
	content, err := os.ReadFile(gopath)
	if err != nil {
		t.Fatalf("opening %s: %v", gopath, err)
	}
	golines := strings.Split(string(content), "\n")

	// Preserve copyright.
	ues.newgolines = append(ues.newgolines, golines[:4]...)
	if !strings.HasPrefix(golines[0], "// Copyright") {
		t.Fatalf("missing copyright from existing testcase")
	}
	golines = golines[4:]

	clore := regexp.MustCompile(`.+\.func\d+[\.\d]*$`)

	emitFunc := func(e *fnInlHeur, dcsites encodedCallSiteTab,
		instance, atl uint) {
		var sb strings.Builder
		dumpFnPreamble(&sb, e, dcsites, instance, atl)
		ues.newgolines = append(ues.newgolines,
			strings.Split(strings.TrimSpace(sb.String()), "\n")...)
	}

	// Write file preamble with "DO NOT EDIT" message and such.
	var sb strings.Builder
	dumpFilePreamble(&sb)
	ues.newgolines = append(ues.newgolines,
		strings.Split(strings.TrimSpace(sb.String()), "\n")...)

	// Helper to add a clump of functions to the output file.
	processClump := func(idx int, emit bool) int {
		// Process func itself, plus anything else defined
		// on the same line
		atl := ues.atline[dentries[idx].line]
		for k := uint(0); k < atl; k++ {
			if emit {
				emitFunc(&dentries[idx], dcsites[idx], k, atl)
			}
			idx++
		}
		// now process any closures it contains
		ncl := 0
		for idx < nd {
			nfn := dentries[idx].fname
			if !clore.MatchString(nfn) {
				break
			}
			ncl++
			if emit {
				emitFunc(&dentries[idx], dcsites[idx], 0, 1)
			}
			idx++
		}
		return idx
	}

	didx := 0
	for _, line := range golines {
		if strings.HasPrefix(line, "func ") {

			// We have a function definition.
			// Pick out the corresponding entry or entries in the dump
			// and emit if interesting (or skip if not).
			dentry := dentries[didx]
			emit := interestingToCompare(dentry.fname)
			didx = processClump(didx, emit)
		}

		// Consume all existing comments.
		if strings.HasPrefix(line, "//") {
			continue
		}
		ues.newgolines = append(ues.newgolines, line)
	}

	if didx != nd {
		t.Logf("didx=%d wanted %d", didx, nd)
	}

	// Open new Go file and write contents.
	of, err := os.OpenFile(newgopath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		t.Fatalf("opening %s: %v", newgopath, err)
	}
	fmt.Fprintf(of, "%s", strings.Join(ues.newgolines, "\n"))
	if err := of.Close(); err != nil {
		t.Fatalf("closing %s: %v", newgopath, err)
	}

	t.Logf("update-expected: emitted updated file %s", newgopath)
	t.Logf("please compare the two files, then overwrite %s with %s\n",
		gopath, newgopath)
}

// interestingToCompare returns TRUE if we want to compare results
// for function 'fname'.
func interestingToCompare(fname string) bool {
	if strings.HasPrefix(fname, "init.") {
		return true
	}
	if strings.HasPrefix(fname, "T_") {
		return true
	}
	f := strings.Split(fname, ".")
	if len(f) == 2 && strings.HasPrefix(f[1], "T_") {
		return true
	}
	return false
}
```
Response: Let's break down the thought process for analyzing the provided Go code snippet.

1. **Understand the Context:** The first thing to recognize is the file path: `go/src/cmd/compile/internal/walk/compare.go`. This immediately tells us we're dealing with the Go compiler's internal workings, specifically in the "walk" phase, and this file is related to comparison operations. The `internal` package also signifies this isn't part of the public Go API.

2. **Identify Key Functions:** Scan the code for top-level function declarations. The most prominent ones are:
    * `fakePC`:  Intriguing name. It seems to be generating some kind of identifier based on the IR node's position and content. The comments confirm its purpose: deterministic IDs.
    * `walkCompare`:  The core function. The comment `// The result of walkCompare MUST be assigned back to n` strongly suggests this function modifies and returns the input node. The presence of `init *ir.Nodes` hints at building a sequence of operations.
    * `walkCompareInterface`: Deals specifically with interface comparisons.
    * `walkCompareString`: Handles string comparisons.
    * `finishCompare`: Seems to be a helper function for post-processing the comparison result.
    * `brcom`, `brrev`, `tracecmpArg`:  Smaller utility functions likely related to comparison operators.

3. **Analyze `walkCompare` - The Central Logic:**  This function is the heart of the snippet. Go through its conditional logic step by step:
    * **Interface Comparison:** The first `if` checks for interface comparisons (excluding nil comparisons) and calls `walkCompareInterface`. This suggests special handling for interfaces.
    * **String Comparison:** The next `if` handles string comparisons, calling `walkCompareString`. This points to specialized string comparison logic.
    * **Mixed Interface/Concrete:** The `if n.X.Type().IsInterface() != n.Y.Type().IsInterface()` block is crucial. It explains how the compiler handles comparing an interface with a concrete type by rewriting it into a type and data comparison. This is a key optimization.
    * **Array/Struct Comparison:** The `switch t.Kind()` block handles arrays and structs. It decides whether to perform the comparison inline or call a runtime function. The `maxcmpsize` and `unalignedLoad` variables hint at performance considerations.
    * **Libfuzzer Integration:** The `if base.Debug.Libfuzzer != 0` block is for fuzzing. It inserts calls to `libfuzzerTraceCmp` functions to track comparison outcomes for testing.
    * **Inline Comparison Logic:** If the decision is to inline, the code iterates through elements (for arrays) or fields (for structs) and builds a boolean expression using `OANDAND` or `OOROR`.
    * **Calling Runtime Equality Function:** If inlining isn't chosen, it calls `reflectdata.EqFor` to get a runtime equality function for the type. This is for larger or more complex structures.

4. **Analyze Specialized Comparison Functions:**
    * **`walkCompareInterface`:**  Directly calls `compare.EqInterface` to get the type and data equality checks for interfaces.
    * **`walkCompareString`:** Has logic for short constant string comparisons (inlining) and otherwise calls `compare.EqString` for general string comparisons. It also has `libfuzzer` hooks.

5. **Analyze Helper Functions:**
    * **`finishCompare`:**  Performs type checking and conversion on the comparison result.
    * **`fakePC`:**  Generates a pseudo-program counter value for deterministic identification, particularly useful for autogenerated code or scenarios where source positions might be the same.
    * **`brcom` and `brrev`:**  Simple utilities for inverting and reversing comparison operators, respectively.
    * **`tracecmpArg`:**  A helper for passing arguments to the libfuzzer tracing functions, handling potential negative constant issues.

6. **Infer Go Language Feature:** Based on the functionality, the primary feature being implemented is the **comparison operators** (`==`, `!=`, `<`, `>`, `<=`, `>=`) for various Go data types. The code shows specialized handling for interfaces, strings, arrays, and structs.

7. **Construct Go Code Examples:** Based on the analysis, create examples demonstrating the different scenarios handled by `walkCompare`:
    * Basic integer comparison (shows the default case).
    * Interface comparison.
    * String comparison (with both constant and variable strings).
    * Array comparison (showing the inlining for small arrays).
    * Struct comparison (showing inlining).
    * Mixed interface/concrete comparison.

8. **Infer Inputs and Outputs (for Code Reasoning):** For `walkCompare`, the input is a `*ir.BinaryExpr` representing a comparison operation and an `*ir.Nodes` for initialization statements. The output is a modified `ir.Node` representing the transformed comparison logic. Provide specific examples of input `ir.BinaryExpr` structures and the likely output based on the internal transformations.

9. **Command-Line Arguments:**  The code references `base.Flag.Race` and `base.Debug.Libfuzzer`. This suggests the behavior can be influenced by the `-race` flag (for enabling race detection) and potentially a `-libfuzzer` flag (though it's accessed through `base.Debug`). Explain how these flags affect the comparison process.

10. **Common Mistakes:** Think about scenarios where a Go developer might make incorrect assumptions about comparisons, particularly with interfaces and structs. The key mistake is expecting pointer comparison to be the same as value comparison for composite types.

11. **Review and Refine:** Go back through the analysis, code examples, and explanations to ensure accuracy and clarity. Ensure that the explanations connect the code snippets to the overall Go language feature.

This systematic approach, moving from the general context to specific function details and then back to the broader language feature, helps in comprehensively understanding the given code snippet. The emphasis on understanding the *why* behind the code (e.g., why are interfaces handled specially, why is there inlining for small arrays) is crucial for a deeper understanding.
这段代码是 Go 编译器 `cmd/compile/internal/walk` 包中 `compare.go` 文件的一部分，主要负责**将 Go 语言中的比较表达式（例如 `==`, `!=`, `<`, `>`, `<=`, `>=`）转换为更底层的、可执行的中间表示形式 (IR)。** 这个过程是编译器“walk”阶段的一部分，它遍历抽象语法树 (AST) 并进行语义分析和转换。

以下是它的主要功能分解：

**1. `fakePC(n ir.Node) ir.Node`:**

* **功能:** 为给定的 IR 节点 `n` 生成一个伪程序计数器 (PC) 值。
* **目的:**  这个伪 PC 值用于在编译过程中需要唯一标识符的场景，例如当启用 `libfuzzer` 进行模糊测试时，需要区分不同的比较操作。
* **实现细节:** 它通过哈希 IR 节点所在的文件路径、行号、列号以及节点的字符串表示来生成哈希值，并将其转换为一个 `ir.NewInt` 节点。
* **关联功能:** 主要用于 `libfuzzer` 功能，以在进行模糊测试时跟踪比较操作。

**2. `walkCompare(n *ir.BinaryExpr, init *ir.Nodes) ir.Node`:**

* **功能:** 这是核心函数，负责处理各种类型的比较表达式。
* **参数:**
    * `n`:  要处理的二元表达式节点，其操作符是比较操作符（`OEQ`, `ONE`, `OLT`, `OGT`, `OLE`, `OGE`）。
    * `init`: 一个节点列表，用于存储在转换过程中需要添加的初始化语句。
* **主要处理逻辑:**
    * **接口比较:** 如果比较的双方都是接口类型且都不是 `nil`，则调用 `walkCompareInterface` 进行处理。
    * **字符串比较:** 如果比较的双方都是字符串类型，则调用 `walkCompareString` 进行处理。
    * **混合接口和具体类型比较:**  如果比较的一方是接口类型，另一方是具体类型，则会将比较操作重写为先比较类型是否相等，再比较数据是否相等。这样可以避免运行时的类型断言和方法查找，提高效率。
    * **数组和结构体比较:**
        * 如果数组或结构体较小，则会生成内联的比较代码，逐个元素或字段进行比较。
        * 如果数组或结构体较大，或者包含不能直接比较的元素（例如包含函数类型的字段），则会调用运行时库提供的比较函数（例如 `memequal`）。
    * **`libfuzzer` 集成:** 如果启用了 `libfuzzer`，会在整型和字符串的比较操作前后插入调用 `libfuzzerTraceCmp` 或 `libfuzzerHookStrCmp` 的代码，用于记录比较操作和参数。
    * **其他类型比较:** 对于其他基本类型（例如整数、浮点数），会先对操作数进行求值（调用 `walkExpr`），然后将比较操作交给后端的代码生成阶段处理。

**3. `walkCompareInterface(n *ir.BinaryExpr, init *ir.Nodes) ir.Node`:**

* **功能:**  专门处理接口类型的比较。
* **实现逻辑:** 它调用 `compare.EqInterface` 函数来获取比较两个接口值的类型信息和数据信息的代码，然后根据原始的比较操作符（`==` 或 `!=`）生成相应的逻辑表达式。

**4. `walkCompareString(n *ir.BinaryExpr, init *ir.Nodes) ir.Node`:**

* **功能:** 专门处理字符串类型的比较。
* **实现逻辑:**
    * **`libfuzzer` 集成:** 如果启用了 `libfuzzer` 且比较的双方不是常量字符串，则插入调用 `libfuzzerHookStrCmp` 的代码。
    * **短常量字符串优化:**  如果比较的是一个变量字符串和一个短的常量字符串，则会将比较操作展开为先比较长度，然后逐字节比较。这可以避免调用运行时的字符串比较函数。
    * **一般字符串比较:** 对于一般的字符串比较（包括变量与变量，或者变量与较长的常量），会调用 `compare.EqString` 获取比较长度和内容的表达式。对于 `==` 和 `!=`，会先比较长度，再比较内容；对于 `<`, `>`, `<=`, `>=`，则调用运行时的 `cmpstring` 函数。

**5. `finishCompare(n *ir.BinaryExpr, r ir.Node, init *ir.Nodes) ir.Node`:**

* **功能:**  比较操作处理完成后的收尾工作。
* **实现逻辑:** 它对比较的结果表达式 `r` 进行类型检查和类型转换，确保类型与原始比较表达式的类型一致，并再次调用 `walkExpr` 进行进一步的处理。

**6. `brcom(op ir.Op) ir.Op` 和 `brrev(op ir.Op) ir.Op`:**

* **功能:**  用于获取比较操作符的“补”操作符（例如 `==` 的补是 `!=`）和“反”操作符（例如 `<` 的反是 `>`）。
* **用途:** 在处理某些比较操作时，可能需要将其转换为相反的操作。

**7. `tracecmpArg(n ir.Node, t *types.Type, init *ir.Nodes) ir.Node`:**

* **功能:**  为 `libfuzzer` 的跟踪比较函数准备参数。
* **目的:**  确保传递给跟踪函数的参数类型正确。对于负的常量整数，会进行拷贝以避免潜在的溢出问题。

**推理 Go 语言功能：比较运算符**

这段代码的核心功能是实现 Go 语言的比较运算符：`==`, `!=`, `<`, `>`, `<=`, `>=`。

**Go 代码示例:**

```go
package main

import "fmt"

func main() {
	a := 10
	b := 20
	c := "hello"
	d := "world"
	e := [2]int{1, 2}
	f := [2]int{1, 2}
	g := struct{ x int }{x: 1}
	h := struct{ x int }{x: 1}
	var i interface{} = a
	var j interface{} = a

	fmt.Println(a == b)   // 输出: false
	fmt.Println(a < b)    // 输出: true
	fmt.Println(c != d)   // 输出: true
	fmt.Println(e == f)   // 输出: true (数组的元素逐个比较)
	fmt.Println(g == h)   // 输出: true (结构体的字段逐个比较)
	fmt.Println(i == j)   // 输出: true (接口值的动态类型和值都相等)
	fmt.Println(i == a)   // 输出: true (接口与具体类型比较)
}
```

**代码推理 (假设输入与输出):**

假设 `walkCompare` 接收到以下 `ir.BinaryExpr` 节点 `n`:

* **输入 (整数比较):**
  ```
  Op: OEQ  // 表示 ==
  X: *ir.Name{ ... Name: "a", Type: int ... }  // 代表变量 a
  Y: *ir.ConstExpr{ ... Value: 10, Type: int ... } // 代表常量 10
  ```
* **输出:** `walkCompare` 可能会直接返回原始节点 `n`，因为整数比较通常由后端的代码生成器直接处理。

* **输入 (字符串比较):**
  ```
  Op: OEQ  // 表示 ==
  X: *ir.Name{ ... Name: "c", Type: string ... } // 代表变量 c
  Y: *ir.String{ ... Value: "hello", Type: string ... } // 代表常量字符串 "hello"
  ```
* **输出:** `walkCompare` 可能会调用 `walkCompareString`，并根据字符串长度和编译器优化选项，生成比较长度和/或逐字节比较的 IR 节点。例如，如果 "hello" 足够短，可能会生成类似以下的 IR 结构：
  ```
  Op: OANDAND
  Left: *ir.BinaryExpr{ Op: OEQ, Left: *ir.UnaryExpr{ Op: OLEN, ... }, Right: *ir.ConstExpr{ ... } } // 比较长度
  Right: *ir.LogicalExpr{ Op: OANDAND, ... } // 逐字节比较的 AND 链
  ```

* **输入 (接口比较):**
  ```
  Op: OEQ  // 表示 ==
  X: *ir.Name{ ... Name: "i", Type: interface{} ... } // 代表接口变量 i
  Y: *ir.Name{ ... Name: "j", Type: interface{} ... } // 代表接口变量 j
  ```
* **输出:** `walkCompare` 会调用 `walkCompareInterface`，返回类似以下的 IR 结构，表示先比较接口的类型信息 (itab 或 type)，再比较数据指针：
  ```
  Op: OANDAND
  Left: ... // 比较类型信息
  Right: ... // 比较数据指针
  ```

**命令行参数处理:**

这段代码中涉及到以下命令行参数的影响：

* **`-race` 标志 (通过 `base.Flag.Race` 访问):**
    * 在 `walkCompare` 中，当比较数组或结构体时，如果 `-race` 标志被设置，会在调用运行时比较函数 `reflectdata.EqFor` 之前，插入对 `racereadrange` 函数的调用。
    * **作用:** 用于启用 Go 的竞态检测器，在比较内存区域之前，通知竞态检测器正在读取这些内存，以帮助发现潜在的并发问题。

* **`-libfuzzer` 相关的标志 (通过 `base.Debug.Libfuzzer` 访问):**
    * 如果 `base.Debug.Libfuzzer` 不为 0，表示启用了 `libfuzzer` 的集成。
    * **作用:**
        * 在 `walkCompare` 中，对于整型比较，会插入调用 `libfuzzerTraceCmp` 或 `libfuzzerTraceConstCmp` 函数的代码。这些函数会将比较操作的操作数和结果记录下来，用于模糊测试分析。
        * 在 `walkCompareString` 中，对于字符串比较，会插入调用 `libfuzzerHookStrCmp` 函数的代码，用于模糊测试。
    * **使用方式:** 通常通过 `go build -toolexec "libfuzzer-go -<libfuzzer flags>" ...` 或类似的命令来启用 `libfuzzer`。

**使用者易犯错的点:**

虽然这段代码是编译器内部实现，普通 Go 开发者不会直接接触，但理解其背后的原理可以避免一些常见的误解：

* **结构体和数组的比较是值比较:**  新手可能会认为结构体或数组的比较是比较它们的内存地址。实际上，Go 会逐个比较它们的字段或元素的值。这段代码就体现了这种逐个比较的实现方式。
* **接口的比较不仅仅是比较指针:** 比较两个接口类型的值时，Go 会同时比较它们的动态类型和动态值。这段代码中的 `walkCompareInterface` 就反映了这一点，它会比较类型信息（itab 或 type）和数据指针。
* **混合类型比较的隐式转换:**  当比较接口类型和具体类型时，Go 会进行隐式的类型转换。这段代码展示了编译器如何将这种比较转换为更底层的类型和数据比较。

**示例说明易犯错的点:**

```go
package main

import "fmt"

type MyStruct struct {
	Value int
}

func main() {
	s1 := MyStruct{Value: 1}
	s2 := MyStruct{Value: 1}
	s3 := &MyStruct{Value: 1}
	s4 := &MyStruct{Value: 1}

	fmt.Println(s1 == s2) // 输出: true (值比较)
	fmt.Println(s3 == s4) // 输出: false (指针比较，地址不同)

	var i1 interface{} = s1
	var i2 interface{} = s2
	fmt.Println(i1 == i2) // 输出: true (动态类型和值都相等)

	var i3 interface{} = s3
	var i4 interface{} = s4
	fmt.Println(i3 == i4) // 输出: false (动态类型相同，但动态值的指针地址不同)
}
```

在这个例子中，直接比较结构体 `s1` 和 `s2` 会得到 `true`，因为它们的值相等。但是比较结构体指针 `s3` 和 `s4` 会得到 `false`，因为它们指向不同的内存地址。接口的比较也是类似的，需要同时考虑动态类型和动态值。理解编译器如何处理这些比较可以避免在使用过程中产生误解。

### 提示词
```
这是路径为go/src/cmd/compile/internal/walk/compare.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
```

### 源代码
```go
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package walk

import (
	"encoding/binary"
	"fmt"
	"go/constant"
	"hash/fnv"
	"io"

	"cmd/compile/internal/base"
	"cmd/compile/internal/compare"
	"cmd/compile/internal/ir"
	"cmd/compile/internal/reflectdata"
	"cmd/compile/internal/ssagen"
	"cmd/compile/internal/typecheck"
	"cmd/compile/internal/types"
)

func fakePC(n ir.Node) ir.Node {
	// In order to get deterministic IDs, we include the package path, absolute filename, line number, column number
	// in the calculation of the fakePC for the IR node.
	hash := fnv.New32()
	// We ignore the errors here because the `io.Writer` in the `hash.Hash` interface never returns an error.
	io.WriteString(hash, base.Ctxt.Pkgpath)
	io.WriteString(hash, base.Ctxt.PosTable.Pos(n.Pos()).AbsFilename())
	binary.Write(hash, binary.LittleEndian, int64(n.Pos().Line()))
	binary.Write(hash, binary.LittleEndian, int64(n.Pos().Col()))
	// We also include the string representation of the node to distinguish autogenerated expression since
	// those get the same `src.XPos`
	io.WriteString(hash, fmt.Sprintf("%v", n))

	return ir.NewInt(base.Pos, int64(hash.Sum32()))
}

// The result of walkCompare MUST be assigned back to n, e.g.
//
//	n.Left = walkCompare(n.Left, init)
func walkCompare(n *ir.BinaryExpr, init *ir.Nodes) ir.Node {
	if n.X.Type().IsInterface() && n.Y.Type().IsInterface() && n.X.Op() != ir.ONIL && n.Y.Op() != ir.ONIL {
		return walkCompareInterface(n, init)
	}

	if n.X.Type().IsString() && n.Y.Type().IsString() {
		return walkCompareString(n, init)
	}

	n.X = walkExpr(n.X, init)
	n.Y = walkExpr(n.Y, init)

	// Given mixed interface/concrete comparison,
	// rewrite into types-equal && data-equal.
	// This is efficient, avoids allocations, and avoids runtime calls.
	//
	// TODO(mdempsky): It would be more general and probably overall
	// simpler to just extend walkCompareInterface to optimize when one
	// operand is an OCONVIFACE.
	if n.X.Type().IsInterface() != n.Y.Type().IsInterface() {
		// Preserve side-effects in case of short-circuiting; see #32187.
		l := cheapExpr(n.X, init)
		r := cheapExpr(n.Y, init)
		// Swap so that l is the interface value and r is the concrete value.
		if n.Y.Type().IsInterface() {
			l, r = r, l
		}

		// Handle both == and !=.
		eq := n.Op()
		andor := ir.OOROR
		if eq == ir.OEQ {
			andor = ir.OANDAND
		}
		// Check for types equal.
		// For empty interface, this is:
		//   l.tab == type(r)
		// For non-empty interface, this is:
		//   l.tab != nil && l.tab._type == type(r)
		//
		// TODO(mdempsky): For non-empty interface comparisons, just
		// compare against the itab address directly?
		var eqtype ir.Node
		tab := ir.NewUnaryExpr(base.Pos, ir.OITAB, l)
		rtyp := reflectdata.CompareRType(base.Pos, n)
		if l.Type().IsEmptyInterface() {
			tab.SetType(types.NewPtr(types.Types[types.TUINT8]))
			tab.SetTypecheck(1)
			eqtype = ir.NewBinaryExpr(base.Pos, eq, tab, rtyp)
		} else {
			nonnil := ir.NewBinaryExpr(base.Pos, brcom(eq), typecheck.NodNil(), tab)
			match := ir.NewBinaryExpr(base.Pos, eq, itabType(tab), rtyp)
			eqtype = ir.NewLogicalExpr(base.Pos, andor, nonnil, match)
		}
		// Check for data equal.
		eqdata := ir.NewBinaryExpr(base.Pos, eq, ifaceData(n.Pos(), l, r.Type()), r)
		// Put it all together.
		expr := ir.NewLogicalExpr(base.Pos, andor, eqtype, eqdata)
		return finishCompare(n, expr, init)
	}

	// Must be comparison of array or struct.
	// Otherwise back end handles it.
	// While we're here, decide whether to
	// inline or call an eq alg.
	t := n.X.Type()
	var inline bool

	maxcmpsize := int64(4)
	unalignedLoad := ssagen.Arch.LinkArch.CanMergeLoads
	if unalignedLoad {
		// Keep this low enough to generate less code than a function call.
		maxcmpsize = 2 * int64(ssagen.Arch.LinkArch.RegSize)
	}

	switch t.Kind() {
	default:
		if base.Debug.Libfuzzer != 0 && t.IsInteger() && (n.X.Name() == nil || !n.X.Name().Libfuzzer8BitCounter()) {
			n.X = cheapExpr(n.X, init)
			n.Y = cheapExpr(n.Y, init)

			// If exactly one comparison operand is
			// constant, invoke the constcmp functions
			// instead, and arrange for the constant
			// operand to be the first argument.
			l, r := n.X, n.Y
			if r.Op() == ir.OLITERAL {
				l, r = r, l
			}
			constcmp := l.Op() == ir.OLITERAL && r.Op() != ir.OLITERAL

			var fn string
			var paramType *types.Type
			switch t.Size() {
			case 1:
				fn = "libfuzzerTraceCmp1"
				if constcmp {
					fn = "libfuzzerTraceConstCmp1"
				}
				paramType = types.Types[types.TUINT8]
			case 2:
				fn = "libfuzzerTraceCmp2"
				if constcmp {
					fn = "libfuzzerTraceConstCmp2"
				}
				paramType = types.Types[types.TUINT16]
			case 4:
				fn = "libfuzzerTraceCmp4"
				if constcmp {
					fn = "libfuzzerTraceConstCmp4"
				}
				paramType = types.Types[types.TUINT32]
			case 8:
				fn = "libfuzzerTraceCmp8"
				if constcmp {
					fn = "libfuzzerTraceConstCmp8"
				}
				paramType = types.Types[types.TUINT64]
			default:
				base.Fatalf("unexpected integer size %d for %v", t.Size(), t)
			}
			init.Append(mkcall(fn, nil, init, tracecmpArg(l, paramType, init), tracecmpArg(r, paramType, init), fakePC(n)))
		}
		return n
	case types.TARRAY:
		// We can compare several elements at once with 2/4/8 byte integer compares
		inline = t.NumElem() <= 1 || (types.IsSimple[t.Elem().Kind()] && (t.NumElem() <= 4 || t.Elem().Size()*t.NumElem() <= maxcmpsize))
	case types.TSTRUCT:
		inline = compare.EqStructCost(t) <= 4
	}

	cmpl := n.X
	for cmpl != nil && cmpl.Op() == ir.OCONVNOP {
		cmpl = cmpl.(*ir.ConvExpr).X
	}
	cmpr := n.Y
	for cmpr != nil && cmpr.Op() == ir.OCONVNOP {
		cmpr = cmpr.(*ir.ConvExpr).X
	}

	// Chose not to inline. Call equality function directly.
	if !inline {
		// eq algs take pointers; cmpl and cmpr must be addressable
		if !ir.IsAddressable(cmpl) || !ir.IsAddressable(cmpr) {
			base.Fatalf("arguments of comparison must be lvalues - %v %v", cmpl, cmpr)
		}

		// Should only arrive here with large memory or
		// a struct/array containing a non-memory field/element.
		// Small memory is handled inline, and single non-memory
		// is handled by walkCompare.
		fn, needsLength := reflectdata.EqFor(t)
		call := ir.NewCallExpr(base.Pos, ir.OCALL, fn, nil)
		addrCmpl := typecheck.NodAddr(cmpl)
		addrCmpR := typecheck.NodAddr(cmpr)
		if !types.IsNoRacePkg(types.LocalPkg) && base.Flag.Race {
			ptrL := typecheck.Conv(typecheck.Conv(addrCmpl, types.Types[types.TUNSAFEPTR]), types.Types[types.TUINTPTR])
			ptrR := typecheck.Conv(typecheck.Conv(addrCmpR, types.Types[types.TUNSAFEPTR]), types.Types[types.TUINTPTR])
			raceFn := typecheck.LookupRuntime("racereadrange")
			size := ir.NewInt(base.Pos, t.Size())
			call.PtrInit().Append(mkcall1(raceFn, nil, init, ptrL, size))
			call.PtrInit().Append(mkcall1(raceFn, nil, init, ptrR, size))
		}
		call.Args.Append(addrCmpl)
		call.Args.Append(addrCmpR)
		if needsLength {
			call.Args.Append(ir.NewInt(base.Pos, t.Size()))
		}
		res := ir.Node(call)
		if n.Op() != ir.OEQ {
			res = ir.NewUnaryExpr(base.Pos, ir.ONOT, res)
		}
		return finishCompare(n, res, init)
	}

	// inline: build boolean expression comparing element by element
	andor := ir.OANDAND
	if n.Op() == ir.ONE {
		andor = ir.OOROR
	}
	var expr ir.Node
	comp := func(el, er ir.Node) {
		a := ir.NewBinaryExpr(base.Pos, n.Op(), el, er)
		if expr == nil {
			expr = a
		} else {
			expr = ir.NewLogicalExpr(base.Pos, andor, expr, a)
		}
	}
	and := func(cond ir.Node) {
		if expr == nil {
			expr = cond
		} else {
			expr = ir.NewLogicalExpr(base.Pos, andor, expr, cond)
		}
	}
	cmpl = safeExpr(cmpl, init)
	cmpr = safeExpr(cmpr, init)
	if t.IsStruct() {
		conds, _ := compare.EqStruct(t, cmpl, cmpr)
		if n.Op() == ir.OEQ {
			for _, cond := range conds {
				and(cond)
			}
		} else {
			for _, cond := range conds {
				notCond := ir.NewUnaryExpr(base.Pos, ir.ONOT, cond)
				and(notCond)
			}
		}
	} else {
		step := int64(1)
		remains := t.NumElem() * t.Elem().Size()
		combine64bit := unalignedLoad && types.RegSize == 8 && t.Elem().Size() <= 4 && t.Elem().IsInteger()
		combine32bit := unalignedLoad && t.Elem().Size() <= 2 && t.Elem().IsInteger()
		combine16bit := unalignedLoad && t.Elem().Size() == 1 && t.Elem().IsInteger()
		for i := int64(0); remains > 0; {
			var convType *types.Type
			switch {
			case remains >= 8 && combine64bit:
				convType = types.Types[types.TINT64]
				step = 8 / t.Elem().Size()
			case remains >= 4 && combine32bit:
				convType = types.Types[types.TUINT32]
				step = 4 / t.Elem().Size()
			case remains >= 2 && combine16bit:
				convType = types.Types[types.TUINT16]
				step = 2 / t.Elem().Size()
			default:
				step = 1
			}
			if step == 1 {
				comp(
					ir.NewIndexExpr(base.Pos, cmpl, ir.NewInt(base.Pos, i)),
					ir.NewIndexExpr(base.Pos, cmpr, ir.NewInt(base.Pos, i)),
				)
				i++
				remains -= t.Elem().Size()
			} else {
				elemType := t.Elem().ToUnsigned()
				cmplw := ir.Node(ir.NewIndexExpr(base.Pos, cmpl, ir.NewInt(base.Pos, i)))
				cmplw = typecheck.Conv(cmplw, elemType) // convert to unsigned
				cmplw = typecheck.Conv(cmplw, convType) // widen
				cmprw := ir.Node(ir.NewIndexExpr(base.Pos, cmpr, ir.NewInt(base.Pos, i)))
				cmprw = typecheck.Conv(cmprw, elemType)
				cmprw = typecheck.Conv(cmprw, convType)
				// For code like this:  uint32(s[0]) | uint32(s[1])<<8 | uint32(s[2])<<16 ...
				// ssa will generate a single large load.
				for offset := int64(1); offset < step; offset++ {
					lb := ir.Node(ir.NewIndexExpr(base.Pos, cmpl, ir.NewInt(base.Pos, i+offset)))
					lb = typecheck.Conv(lb, elemType)
					lb = typecheck.Conv(lb, convType)
					lb = ir.NewBinaryExpr(base.Pos, ir.OLSH, lb, ir.NewInt(base.Pos, 8*t.Elem().Size()*offset))
					cmplw = ir.NewBinaryExpr(base.Pos, ir.OOR, cmplw, lb)
					rb := ir.Node(ir.NewIndexExpr(base.Pos, cmpr, ir.NewInt(base.Pos, i+offset)))
					rb = typecheck.Conv(rb, elemType)
					rb = typecheck.Conv(rb, convType)
					rb = ir.NewBinaryExpr(base.Pos, ir.OLSH, rb, ir.NewInt(base.Pos, 8*t.Elem().Size()*offset))
					cmprw = ir.NewBinaryExpr(base.Pos, ir.OOR, cmprw, rb)
				}
				comp(cmplw, cmprw)
				i += step
				remains -= step * t.Elem().Size()
			}
		}
	}
	if expr == nil {
		expr = ir.NewBool(base.Pos, n.Op() == ir.OEQ)
		// We still need to use cmpl and cmpr, in case they contain
		// an expression which might panic. See issue 23837.
		a1 := typecheck.Stmt(ir.NewAssignStmt(base.Pos, ir.BlankNode, cmpl))
		a2 := typecheck.Stmt(ir.NewAssignStmt(base.Pos, ir.BlankNode, cmpr))
		init.Append(a1, a2)
	}
	return finishCompare(n, expr, init)
}

func walkCompareInterface(n *ir.BinaryExpr, init *ir.Nodes) ir.Node {
	n.Y = cheapExpr(n.Y, init)
	n.X = cheapExpr(n.X, init)
	eqtab, eqdata := compare.EqInterface(n.X, n.Y)
	var cmp ir.Node
	if n.Op() == ir.OEQ {
		cmp = ir.NewLogicalExpr(base.Pos, ir.OANDAND, eqtab, eqdata)
	} else {
		eqtab.SetOp(ir.ONE)
		cmp = ir.NewLogicalExpr(base.Pos, ir.OOROR, eqtab, ir.NewUnaryExpr(base.Pos, ir.ONOT, eqdata))
	}
	return finishCompare(n, cmp, init)
}

func walkCompareString(n *ir.BinaryExpr, init *ir.Nodes) ir.Node {
	if base.Debug.Libfuzzer != 0 {
		if !ir.IsConst(n.X, constant.String) || !ir.IsConst(n.Y, constant.String) {
			fn := "libfuzzerHookStrCmp"
			n.X = cheapExpr(n.X, init)
			n.Y = cheapExpr(n.Y, init)
			paramType := types.Types[types.TSTRING]
			init.Append(mkcall(fn, nil, init, tracecmpArg(n.X, paramType, init), tracecmpArg(n.Y, paramType, init), fakePC(n)))
		}
	}
	// Rewrite comparisons to short constant strings as length+byte-wise comparisons.
	var cs, ncs ir.Node // const string, non-const string
	switch {
	case ir.IsConst(n.X, constant.String) && ir.IsConst(n.Y, constant.String):
		// ignore; will be constant evaluated
	case ir.IsConst(n.X, constant.String):
		cs = n.X
		ncs = n.Y
	case ir.IsConst(n.Y, constant.String):
		cs = n.Y
		ncs = n.X
	}
	if cs != nil {
		cmp := n.Op()
		// Our comparison below assumes that the non-constant string
		// is on the left hand side, so rewrite "" cmp x to x cmp "".
		// See issue 24817.
		if ir.IsConst(n.X, constant.String) {
			cmp = brrev(cmp)
		}

		// maxRewriteLen was chosen empirically.
		// It is the value that minimizes cmd/go file size
		// across most architectures.
		// See the commit description for CL 26758 for details.
		maxRewriteLen := 6
		// Some architectures can load unaligned byte sequence as 1 word.
		// So we can cover longer strings with the same amount of code.
		canCombineLoads := ssagen.Arch.LinkArch.CanMergeLoads
		combine64bit := false
		if canCombineLoads {
			// Keep this low enough to generate less code than a function call.
			maxRewriteLen = 2 * ssagen.Arch.LinkArch.RegSize
			combine64bit = ssagen.Arch.LinkArch.RegSize >= 8
		}

		var and ir.Op
		switch cmp {
		case ir.OEQ:
			and = ir.OANDAND
		case ir.ONE:
			and = ir.OOROR
		default:
			// Don't do byte-wise comparisons for <, <=, etc.
			// They're fairly complicated.
			// Length-only checks are ok, though.
			maxRewriteLen = 0
		}
		if s := ir.StringVal(cs); len(s) <= maxRewriteLen {
			if len(s) > 0 {
				ncs = safeExpr(ncs, init)
			}
			r := ir.Node(ir.NewBinaryExpr(base.Pos, cmp, ir.NewUnaryExpr(base.Pos, ir.OLEN, ncs), ir.NewInt(base.Pos, int64(len(s)))))
			remains := len(s)
			for i := 0; remains > 0; {
				if remains == 1 || !canCombineLoads {
					cb := ir.NewInt(base.Pos, int64(s[i]))
					ncb := ir.NewIndexExpr(base.Pos, ncs, ir.NewInt(base.Pos, int64(i)))
					r = ir.NewLogicalExpr(base.Pos, and, r, ir.NewBinaryExpr(base.Pos, cmp, ncb, cb))
					remains--
					i++
					continue
				}
				var step int
				var convType *types.Type
				switch {
				case remains >= 8 && combine64bit:
					convType = types.Types[types.TINT64]
					step = 8
				case remains >= 4:
					convType = types.Types[types.TUINT32]
					step = 4
				case remains >= 2:
					convType = types.Types[types.TUINT16]
					step = 2
				}
				ncsubstr := typecheck.Conv(ir.NewIndexExpr(base.Pos, ncs, ir.NewInt(base.Pos, int64(i))), convType)
				csubstr := int64(s[i])
				// Calculate large constant from bytes as sequence of shifts and ors.
				// Like this:  uint32(s[0]) | uint32(s[1])<<8 | uint32(s[2])<<16 ...
				// ssa will combine this into a single large load.
				for offset := 1; offset < step; offset++ {
					b := typecheck.Conv(ir.NewIndexExpr(base.Pos, ncs, ir.NewInt(base.Pos, int64(i+offset))), convType)
					b = ir.NewBinaryExpr(base.Pos, ir.OLSH, b, ir.NewInt(base.Pos, int64(8*offset)))
					ncsubstr = ir.NewBinaryExpr(base.Pos, ir.OOR, ncsubstr, b)
					csubstr |= int64(s[i+offset]) << uint8(8*offset)
				}
				csubstrPart := ir.NewInt(base.Pos, csubstr)
				// Compare "step" bytes as once
				r = ir.NewLogicalExpr(base.Pos, and, r, ir.NewBinaryExpr(base.Pos, cmp, csubstrPart, ncsubstr))
				remains -= step
				i += step
			}
			return finishCompare(n, r, init)
		}
	}

	var r ir.Node
	if n.Op() == ir.OEQ || n.Op() == ir.ONE {
		// prepare for rewrite below
		n.X = cheapExpr(n.X, init)
		n.Y = cheapExpr(n.Y, init)
		eqlen, eqmem := compare.EqString(n.X, n.Y)
		// quick check of len before full compare for == or !=.
		// memequal then tests equality up to length len.
		if n.Op() == ir.OEQ {
			// len(left) == len(right) && memequal(left, right, len)
			r = ir.NewLogicalExpr(base.Pos, ir.OANDAND, eqlen, eqmem)
		} else {
			// len(left) != len(right) || !memequal(left, right, len)
			eqlen.SetOp(ir.ONE)
			r = ir.NewLogicalExpr(base.Pos, ir.OOROR, eqlen, ir.NewUnaryExpr(base.Pos, ir.ONOT, eqmem))
		}
	} else {
		// sys_cmpstring(s1, s2) :: 0
		r = mkcall("cmpstring", types.Types[types.TINT], init, typecheck.Conv(n.X, types.Types[types.TSTRING]), typecheck.Conv(n.Y, types.Types[types.TSTRING]))
		r = ir.NewBinaryExpr(base.Pos, n.Op(), r, ir.NewInt(base.Pos, 0))
	}

	return finishCompare(n, r, init)
}

// The result of finishCompare MUST be assigned back to n, e.g.
//
//	n.Left = finishCompare(n.Left, x, r, init)
func finishCompare(n *ir.BinaryExpr, r ir.Node, init *ir.Nodes) ir.Node {
	r = typecheck.Expr(r)
	r = typecheck.Conv(r, n.Type())
	r = walkExpr(r, init)
	return r
}

// brcom returns !(op).
// For example, brcom(==) is !=.
func brcom(op ir.Op) ir.Op {
	switch op {
	case ir.OEQ:
		return ir.ONE
	case ir.ONE:
		return ir.OEQ
	case ir.OLT:
		return ir.OGE
	case ir.OGT:
		return ir.OLE
	case ir.OLE:
		return ir.OGT
	case ir.OGE:
		return ir.OLT
	}
	base.Fatalf("brcom: no com for %v\n", op)
	return op
}

// brrev returns reverse(op).
// For example, Brrev(<) is >.
func brrev(op ir.Op) ir.Op {
	switch op {
	case ir.OEQ:
		return ir.OEQ
	case ir.ONE:
		return ir.ONE
	case ir.OLT:
		return ir.OGT
	case ir.OGT:
		return ir.OLT
	case ir.OLE:
		return ir.OGE
	case ir.OGE:
		return ir.OLE
	}
	base.Fatalf("brrev: no rev for %v\n", op)
	return op
}

func tracecmpArg(n ir.Node, t *types.Type, init *ir.Nodes) ir.Node {
	// Ugly hack to avoid "constant -1 overflows uintptr" errors, etc.
	if n.Op() == ir.OLITERAL && n.Type().IsSigned() && ir.Int64Val(n) < 0 {
		n = copyExpr(n, n.Type(), init)
	}

	return typecheck.Conv(n, t)
}
```
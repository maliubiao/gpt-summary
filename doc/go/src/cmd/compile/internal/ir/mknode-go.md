Response: Let's break down the thought process for analyzing this Go code and answering the prompt.

1. **Understanding the Goal:** The core purpose of the `mknode.go` script is to generate Go code. The `// Code generated by mknode.go. DO NOT EDIT.` line is a major clue. The script manipulates the abstract syntax tree (AST) of Go code to achieve this.

2. **Initial Code Examination - Key Imports and Data Structures:**

   - `go/ast`, `go/parser`, `go/token`, `go/format`: These packages immediately tell us this script works with Go source code structure. It parses, manipulates, and formats Go code.
   - `bytes.Buffer`:  This suggests the script builds the generated code in memory.
   - `concreteNodes`, `interfaceNodes`, `mini`: These variables store information extracted from the parsed Go files. The names are suggestive of different categories of types within the `ir` package.

3. **Identifying Core Functionality - Reading and Processing Go Files:**

   - `parser.ParseDir`: This function is central. It reads Go source files in the current directory (`.`). The `filter` function suggests it's selectively processing files (excluding itself).
   - The nested loops iterating through `pkg.Files` and `d.Decls` (declarations) are standard ways to traverse the AST of a Go package.
   - The code specifically looks for `ast.GenDecl` (general declarations) and `ast.TypeSpec` (type specifications). This confirms it's focused on type definitions.

4. **Deciphering the "Mini" Types:**

   - The code explicitly looks for type names starting with "mini". The comment `// Find all the mini types. These let us determine which concrete types implement Node...` is crucial.
   - The check `if t.Name.Name != "miniNode" { ... if !isNamedType(s.Fields.List[0].Type, "miniNode") ... }` confirms that "miniNode" is a base type and other "mini" types embed it. This is likely a form of lightweight inheritance or composition. *Self-correction:*  It's not inheritance in the traditional OOP sense, but embedding.
   - The `isMini` function checks if a type is one of these "mini" types.

5. **Understanding `implementsNode`:**

   - This function checks if a given `ast.Expr` (expression) represents a type that is either a concrete node or an interface node. It iterates through `concreteNodes` and `interfaceNodes` to determine this.

6. **Figuring out `isConcreteNode` and `isInterfaceNode`:**

   - `isConcreteNode`: Checks if a `TypeSpec` represents a `struct` that embeds a "mini" type. This confirms the "mini" types are used to identify concrete node implementations.
   - `isInterfaceNode`: Checks if a `TypeSpec` represents an `interface`. It handles the base `Node` interface specially and also looks for embedding of the `Node` interface in other interfaces. The exclusion of "OrigNode" and "InitNode" suggests these are special interfaces not meant to be directly processed.

7. **The `processType` Function - Generating Code:**

   - The `fmt.Fprintf` calls writing to the `buf` indicate code generation.
   - `fmtNode`: The call to `fmtNode` (presumably defined elsewhere) suggests generating `Format` methods for each concrete node type.
   - The handling of embedded fields, particularly the "mini" types, is significant. The code effectively "flattens" the embedded struct's fields into the embedding struct.
   - The loops iterating through the fields and the conditional `Fprintf` calls for `doChildren`, `editChildren`, etc., strongly suggest the generation of methods for traversing and manipulating the node hierarchy. The `hidden` tag suggests selective processing of fields.

8. **The `generateHelpers` Function:**

   - This function generates helper functions like `copy<Type>s`, `do<Type>s`, and `edit<Type>s` for slices of nodes. These are likely used by the generated `copy`, `doChildren`, and `editChildren` methods.

9. **Putting It All Together - The Big Picture:**

   - The script reads Go source code defining types related to an Abstract Syntax Tree (AST).
   - It identifies concrete and interface types that implement a `Node` interface (likely representing nodes in the AST).
   - It generates Go code (likely into `node_gen.go`) that provides functionality for:
     - Formatting these node types for debugging/printing.
     - Copying nodes.
     - Traversing the tree structure (`doChildren`, `doChildrenWithHidden`).
     - Modifying the tree structure (`editChildren`, `editChildrenWithHidden`).

10. **Answering the Prompt's Specific Questions:**  Now that the overall purpose is understood, it's easier to address the individual points:

    - **Functionality:**  Summarize the code generation tasks.
    - **Go Feature (AST Manipulation):** Explain that it leverages the `go/ast` package to generate boilerplate code for working with the AST.
    - **Code Example:** Provide a simplified hypothetical example of input and the expected generated output. Focus on the core transformations.
    - **Command-line Arguments:** The script doesn't use any explicit command-line arguments. This should be stated.
    - **User Mistakes:** Think about common pitfalls when working with generated code or ASTs (e.g., manual edits, misunderstanding the generation logic).

11. **Refinement and Clarity:**  Review the generated answer for clarity, accuracy, and completeness. Ensure the explanations are easy to understand and the code examples are illustrative. For instance, initially, I might have overemphasized inheritance, but realizing "mini" types are embedded corrects that. Similarly, explicitly stating the lack of command-line arguments is important.
这段代码 `mknode.go` 是 Go 编译器源码的一部分，其主要功能是**自动生成 `go/src/cmd/compile/internal/ir` 包中 `Node` 接口相关类型的辅助方法**。 这些方法通常用于遍历、复制和操作抽象语法树 (AST) 节点。

更具体地说，它执行以下操作：

1. **解析 `ir` 包中的 Go 代码:** 它使用 `go/parser` 包来读取和解析当前目录下的 Go 源文件（除了以 "mknode" 开头的文件）。
2. **识别 `Node` 接口的实现:** 它会查找实现了 `Node` 接口的具体类型和接口类型。这通过查找嵌入了特定的 "mini" 类型（例如 `miniNode`，`miniExpr`，`miniStmt`）的结构体或嵌入了 `Node` 接口的接口来实现。
3. **生成 `Format` 方法:**  为每个具体的 `Node` 类型生成 `Format` 方法，使其可以使用 `fmt` 包进行格式化输出。
4. **生成 `copy` 方法:** 为每个具体的 `Node` 类型生成 `copy` 方法，用于创建节点的深拷贝。
5. **生成 `doChildren` 和 `doChildrenWithHidden` 方法:** 为每个具体的 `Node` 类型生成这两个方法，用于遍历节点的子节点。`doChildrenWithHidden` 方法会遍历所有子节点，而 `doChildren` 方法可能会排除一些被标记为 "hidden" 的子节点。
6. **生成 `editChildren` 和 `editChildrenWithHidden` 方法:** 为每个具体的 `Node` 类型生成这两个方法，用于修改节点的子节点。`editChildrenWithHidden` 方法会处理所有子节点，而 `editChildren` 方法可能会排除一些被标记为 "hidden" 的子节点。
7. **生成辅助函数:**  生成一些辅助函数，例如 `copyNodes`, `doNodes`, `editNodes`，用于处理 `Node` 类型的切片。

**它是什么 Go 语言功能的实现？**

这段代码是 Go 编译器内部 AST (Abstract Syntax Tree) 操作支持代码的生成器。Go 编译器在编译 Go 代码时，首先会将其解析成 AST。`ir` 包中的类型定义了 AST 的节点。 `mknode.go` 的作用是为这些 AST 节点类型生成一些常用的、重复性的方法，例如遍历和复制，从而简化编译器后续阶段的代码编写。

**Go 代码举例说明:**

假设 `go/src/cmd/compile/internal/ir` 包中定义了以下结构体：

```go
// go/src/cmd/compile/internal/ir/node.go
package ir

type Node interface {
	Format(s fmt.State, verb rune)
	// ... 其他方法
}

type miniNode struct{}

type Expr struct {
	miniNode
	X Node
}

type BinaryExpr struct {
	miniNode
	Op   int
	Left  Node
	Right Node
}
```

运行 `mknode.go` 后，可能会生成类似以下的 `node_gen.go` 文件的一部分：

```go
// Code generated by mknode.go. DO NOT EDIT.

package ir

import "fmt"

func (n *Expr) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }

func (n *Expr) copy() Node {
	c := *n
	if n.X != nil {
		c.X = n.X.copy()
	}
	return &c
}

func (n *Expr) doChildren(do func(Node) bool) bool {
	if n.X != nil && do(n.X) {
		return true
	}
	return false
}

func (n *Expr) doChildrenWithHidden(do func(Node) bool) bool {
	if n.X != nil && do(n.X) {
		return true
	}
	return false
}

func (n *Expr) editChildren(edit func(Node) Node) {
	if n.X != nil {
		n.X = edit(n.X).(Node)
	}
}

func (n *Expr) editChildrenWithHidden(edit func(Node) Node) {
	if n.X != nil {
		n.X = edit(n.X).(Node)
	}
}

func (n *BinaryExpr) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }

func (n *BinaryExpr) copy() Node {
	c := *n
	if n.Left != nil {
		c.Left = n.Left.copy()
	}
	if n.Right != nil {
		c.Right = n.Right.copy()
	}
	return &c
}

func (n *BinaryExpr) doChildren(do func(Node) bool) bool {
	if n.Left != nil && do(n.Left) {
		return true
	}
	if n.Right != nil && do(n.Right) {
		return true
	}
	return false
}

func (n *BinaryExpr) doChildrenWithHidden(do func(Node) bool) bool {
	if n.Left != nil && do(n.Left) {
		return true
	}
	if n.Right != nil && do(n.Right) {
		return true
	}
	return false
}

func (n *BinaryExpr) editChildren(edit func(Node) Node) {
	if n.Left != nil {
		n.Left = edit(n.Left).(Node)
	}
	if n.Right != nil {
		n.Right = edit(n.Right).(Node)
	}
}

func (n *BinaryExpr) editChildrenWithHidden(edit func(Node) Node) {
	if n.Left != nil {
		n.Left = edit(n.Left).(Node)
	}
	if n.Right != nil {
		n.Right = edit(n.Right).(Node)
	}
}
```

**假设的输入与输出:**

**输入 (go/src/cmd/compile/internal/ir/node.go):**

```go
package ir

import "fmt"

type Node interface {
	Format(s fmt.State, verb rune)
}

type miniNode struct{}

type Expr struct {
	miniNode
	X Node
}
```

**输出 (生成的 go/src/cmd/compile/internal/ir/node_gen.go 的一部分):**

```go
// Code generated by mknode.go. DO NOT EDIT.

package ir

import "fmt"

func (n *Expr) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }

func (n *Expr) copy() Node {
	c := *n
	if n.X != nil {
		c.X = n.X.copy()
	}
	return &c
}

func (n *Expr) doChildren(do func(Node) bool) bool {
	if n.X != nil && do(n.X) {
		return true
	}
	return false
}

func (n *Expr) doChildrenWithHidden(do func(Node) bool) bool {
	if n.X != nil && do(n.X) {
		return true
	}
	return false
}

func (n *Expr) editChildren(edit func(Node) Node) {
	if n.X != nil {
		n.X = edit(n.X).(Node)
	}
}

func (n *Expr) editChildrenWithHidden(edit func(Node) Node) {
	if n.X != nil {
		n.X = edit(n.X).(Node)
	}
}
```

**命令行参数的具体处理:**

这段代码本身是一个 Go 程序，需要使用 `go run mknode.go` 命令来执行。它不接受任何命令行参数。它会解析当前目录下的 `ir` 包的源代码。

**使用者易犯错的点:**

1. **手动修改 `node_gen.go`:**  `node_gen.go` 文件开头有 `// Code generated by mknode.go. DO NOT EDIT.` 的注释，这意味着这个文件是自动生成的。  **用户不应该手动修改这个文件。** 任何手动修改都会在下次运行 `mknode.go` 时被覆盖。
2. **未理解 `mini` 类型的作用:**  `mknode.go` 使用以 "mini" 开头的类型（如 `miniNode`) 来判断哪些结构体是 `Node` 接口的具体实现。 如果用户在定义新的 AST 节点类型时，没有正确地嵌入这些 "mini" 类型，`mknode.go` 就不会为这些类型生成相应的辅助方法。
3. **标签使用不当:**  代码中使用了 `mknode:"-"` 标签来标记某些 `Node` 类型的字段在 `doChildren` 和 `editChildren` 方法中被排除。如果用户使用了其他格式的 `mknode` 标签，程序会 panic。例如，如果写成 `mknode:ignore`，就会导致错误。
4. **依赖 `mknode.go` 的执行环境:**  `mknode.go` 依赖于能在其执行目录下找到 `ir` 包的源代码。如果执行 `go run mknode.go` 的目录不正确，或者 `ir` 包的结构发生变化，可能会导致解析错误或生成不正确的代码。

总而言之，`mknode.go` 是一个重要的代码生成工具，它简化了 Go 编译器中 AST 节点操作相关代码的编写和维护。理解它的工作原理以及注意事项，有助于避免在开发 Go 编译器时犯错。

Prompt: 
```
这是路径为go/src/cmd/compile/internal/ir/mknode.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，

"""
// Copyright 2022 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build ignore

// Note: this program must be run in this directory.
//   go run mknode.go

package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/fs"
	"log"
	"os"
	"slices"
	"strings"
)

var fset = token.NewFileSet()

var buf bytes.Buffer

// concreteNodes contains all concrete types in the package that implement Node
// (except for the mini* types).
var concreteNodes []*ast.TypeSpec

// interfaceNodes contains all interface types in the package that implement Node.
var interfaceNodes []*ast.TypeSpec

// mini contains the embeddable mini types (miniNode, miniExpr, and miniStmt).
var mini = map[string]*ast.TypeSpec{}

// implementsNode reports whether the type t is one which represents a Node
// in the AST.
func implementsNode(t ast.Expr) bool {
	id, ok := t.(*ast.Ident)
	if !ok {
		return false // only named types
	}
	for _, ts := range interfaceNodes {
		if ts.Name.Name == id.Name {
			return true
		}
	}
	for _, ts := range concreteNodes {
		if ts.Name.Name == id.Name {
			return true
		}
	}
	return false
}

func isMini(t ast.Expr) bool {
	id, ok := t.(*ast.Ident)
	return ok && mini[id.Name] != nil
}

func isNamedType(t ast.Expr, name string) bool {
	if id, ok := t.(*ast.Ident); ok {
		if id.Name == name {
			return true
		}
	}
	return false
}

func main() {
	fmt.Fprintln(&buf, "// Code generated by mknode.go. DO NOT EDIT.")
	fmt.Fprintln(&buf)
	fmt.Fprintln(&buf, "package ir")
	fmt.Fprintln(&buf)
	fmt.Fprintln(&buf, `import "fmt"`)

	filter := func(file fs.FileInfo) bool {
		return !strings.HasPrefix(file.Name(), "mknode")
	}
	pkgs, err := parser.ParseDir(fset, ".", filter, 0)
	if err != nil {
		panic(err)
	}
	pkg := pkgs["ir"]

	// Find all the mini types. These let us determine which
	// concrete types implement Node, so we need to find them first.
	for _, f := range pkg.Files {
		for _, d := range f.Decls {
			g, ok := d.(*ast.GenDecl)
			if !ok {
				continue
			}
			for _, s := range g.Specs {
				t, ok := s.(*ast.TypeSpec)
				if !ok {
					continue
				}
				if strings.HasPrefix(t.Name.Name, "mini") {
					mini[t.Name.Name] = t
					// Double-check that it is or embeds miniNode.
					if t.Name.Name != "miniNode" {
						s := t.Type.(*ast.StructType)
						if !isNamedType(s.Fields.List[0].Type, "miniNode") {
							panic(fmt.Sprintf("can't find miniNode in %s", t.Name.Name))
						}
					}
				}
			}
		}
	}

	// Find all the declarations of concrete types that implement Node.
	for _, f := range pkg.Files {
		for _, d := range f.Decls {
			g, ok := d.(*ast.GenDecl)
			if !ok {
				continue
			}
			for _, s := range g.Specs {
				t, ok := s.(*ast.TypeSpec)
				if !ok {
					continue
				}
				if strings.HasPrefix(t.Name.Name, "mini") {
					// We don't treat the mini types as
					// concrete implementations of Node
					// (even though they are) because
					// we only use them by embedding them.
					continue
				}
				if isConcreteNode(t) {
					concreteNodes = append(concreteNodes, t)
				}
				if isInterfaceNode(t) {
					interfaceNodes = append(interfaceNodes, t)
				}
			}
		}
	}
	// Sort for deterministic output.
	slices.SortFunc(concreteNodes, func(a, b *ast.TypeSpec) int {
		return strings.Compare(a.Name.Name, b.Name.Name)
	})
	// Generate code for each concrete type.
	for _, t := range concreteNodes {
		processType(t)
	}
	// Add some helpers.
	generateHelpers()

	// Format and write output.
	out, err := format.Source(buf.Bytes())
	if err != nil {
		// write out mangled source so we can see the bug.
		out = buf.Bytes()
	}
	err = os.WriteFile("node_gen.go", out, 0666)
	if err != nil {
		log.Fatal(err)
	}
}

// isConcreteNode reports whether the type t is a concrete type
// implementing Node.
func isConcreteNode(t *ast.TypeSpec) bool {
	s, ok := t.Type.(*ast.StructType)
	if !ok {
		return false
	}
	for _, f := range s.Fields.List {
		if isMini(f.Type) {
			return true
		}
	}
	return false
}

// isInterfaceNode reports whether the type t is an interface type
// implementing Node (including Node itself).
func isInterfaceNode(t *ast.TypeSpec) bool {
	s, ok := t.Type.(*ast.InterfaceType)
	if !ok {
		return false
	}
	if t.Name.Name == "Node" {
		return true
	}
	if t.Name.Name == "OrigNode" || t.Name.Name == "InitNode" {
		// These we exempt from consideration (fields of
		// this type don't need to be walked or copied).
		return false
	}

	// Look for embedded Node type.
	// Note that this doesn't handle multi-level embedding, but
	// we have none of that at the moment.
	for _, f := range s.Methods.List {
		if len(f.Names) != 0 {
			continue
		}
		if isNamedType(f.Type, "Node") {
			return true
		}
	}
	return false
}

func processType(t *ast.TypeSpec) {
	name := t.Name.Name
	fmt.Fprintf(&buf, "\n")
	fmt.Fprintf(&buf, "func (n *%s) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }\n", name)

	switch name {
	case "Name", "Func":
		// Too specialized to automate.
		return
	}

	s := t.Type.(*ast.StructType)
	fields := s.Fields.List

	// Expand any embedded fields.
	for i := 0; i < len(fields); i++ {
		f := fields[i]
		if len(f.Names) != 0 {
			continue // not embedded
		}
		if isMini(f.Type) {
			// Insert the fields of the embedded type into the main type.
			// (It would be easier just to append, but inserting in place
			// matches the old mknode behavior.)
			ss := mini[f.Type.(*ast.Ident).Name].Type.(*ast.StructType)
			var f2 []*ast.Field
			f2 = append(f2, fields[:i]...)
			f2 = append(f2, ss.Fields.List...)
			f2 = append(f2, fields[i+1:]...)
			fields = f2
			i--
			continue
		} else if isNamedType(f.Type, "origNode") {
			// Ignore this field
			copy(fields[i:], fields[i+1:])
			fields = fields[:len(fields)-1]
			i--
			continue
		} else {
			panic("unknown embedded field " + fmt.Sprintf("%v", f.Type))
		}
	}
	// Process fields.
	var copyBody strings.Builder
	var doChildrenBody strings.Builder
	var doChildrenWithHiddenBody strings.Builder
	var editChildrenBody strings.Builder
	var editChildrenWithHiddenBody strings.Builder
	for _, f := range fields {
		names := f.Names
		ft := f.Type
		hidden := false
		if f.Tag != nil {
			tag := f.Tag.Value[1 : len(f.Tag.Value)-1]
			if strings.HasPrefix(tag, "mknode:") {
				if tag[7:] == "\"-\"" {
					if !isNamedType(ft, "Node") {
						continue
					}
					hidden = true
				} else {
					panic(fmt.Sprintf("unexpected tag value: %s", tag))
				}
			}
		}
		if isNamedType(ft, "Nodes") {
			// Nodes == []Node
			ft = &ast.ArrayType{Elt: &ast.Ident{Name: "Node"}}
		}
		isSlice := false
		if a, ok := ft.(*ast.ArrayType); ok && a.Len == nil {
			isSlice = true
			ft = a.Elt
		}
		isPtr := false
		if p, ok := ft.(*ast.StarExpr); ok {
			isPtr = true
			ft = p.X
		}
		if !implementsNode(ft) {
			continue
		}
		for _, name := range names {
			ptr := ""
			if isPtr {
				ptr = "*"
			}
			if isSlice {
				fmt.Fprintf(&doChildrenWithHiddenBody,
					"if do%ss(n.%s, do) {\nreturn true\n}\n", ft, name)
				fmt.Fprintf(&editChildrenWithHiddenBody,
					"edit%ss(n.%s, edit)\n", ft, name)
			} else {
				fmt.Fprintf(&doChildrenWithHiddenBody,
					"if n.%s != nil && do(n.%s) {\nreturn true\n}\n", name, name)
				fmt.Fprintf(&editChildrenWithHiddenBody,
					"if n.%s != nil {\nn.%s = edit(n.%s).(%s%s)\n}\n", name, name, name, ptr, ft)
			}
			if hidden {
				continue
			}
			if isSlice {
				fmt.Fprintf(&copyBody, "c.%s = copy%ss(c.%s)\n", name, ft, name)
				fmt.Fprintf(&doChildrenBody,
					"if do%ss(n.%s, do) {\nreturn true\n}\n", ft, name)
				fmt.Fprintf(&editChildrenBody,
					"edit%ss(n.%s, edit)\n", ft, name)
			} else {
				fmt.Fprintf(&doChildrenBody,
					"if n.%s != nil && do(n.%s) {\nreturn true\n}\n", name, name)
				fmt.Fprintf(&editChildrenBody,
					"if n.%s != nil {\nn.%s = edit(n.%s).(%s%s)\n}\n", name, name, name, ptr, ft)
			}
		}
	}
	fmt.Fprintf(&buf, "func (n *%s) copy() Node {\nc := *n\n", name)
	buf.WriteString(copyBody.String())
	fmt.Fprintf(&buf, "return &c\n}\n")
	fmt.Fprintf(&buf, "func (n *%s) doChildren(do func(Node) bool) bool {\n", name)
	buf.WriteString(doChildrenBody.String())
	fmt.Fprintf(&buf, "return false\n}\n")
	fmt.Fprintf(&buf, "func (n *%s) doChildrenWithHidden(do func(Node) bool) bool {\n", name)
	buf.WriteString(doChildrenWithHiddenBody.String())
	fmt.Fprintf(&buf, "return false\n}\n")
	fmt.Fprintf(&buf, "func (n *%s) editChildren(edit func(Node) Node) {\n", name)
	buf.WriteString(editChildrenBody.String())
	fmt.Fprintf(&buf, "}\n")
	fmt.Fprintf(&buf, "func (n *%s) editChildrenWithHidden(edit func(Node) Node) {\n", name)
	buf.WriteString(editChildrenWithHiddenBody.String())
	fmt.Fprintf(&buf, "}\n")
}

func generateHelpers() {
	for _, typ := range []string{"CaseClause", "CommClause", "Name", "Node"} {
		ptr := "*"
		if typ == "Node" {
			ptr = "" // interfaces don't need *
		}
		fmt.Fprintf(&buf, "\n")
		fmt.Fprintf(&buf, "func copy%ss(list []%s%s) []%s%s {\n", typ, ptr, typ, ptr, typ)
		fmt.Fprintf(&buf, "if list == nil { return nil }\n")
		fmt.Fprintf(&buf, "c := make([]%s%s, len(list))\n", ptr, typ)
		fmt.Fprintf(&buf, "copy(c, list)\n")
		fmt.Fprintf(&buf, "return c\n")
		fmt.Fprintf(&buf, "}\n")
		fmt.Fprintf(&buf, "func do%ss(list []%s%s, do func(Node) bool) bool {\n", typ, ptr, typ)
		fmt.Fprintf(&buf, "for _, x := range list {\n")
		fmt.Fprintf(&buf, "if x != nil && do(x) {\n")
		fmt.Fprintf(&buf, "return true\n")
		fmt.Fprintf(&buf, "}\n")
		fmt.Fprintf(&buf, "}\n")
		fmt.Fprintf(&buf, "return false\n")
		fmt.Fprintf(&buf, "}\n")
		fmt.Fprintf(&buf, "func edit%ss(list []%s%s, edit func(Node) Node) {\n", typ, ptr, typ)
		fmt.Fprintf(&buf, "for i, x := range list {\n")
		fmt.Fprintf(&buf, "if x != nil {\n")
		fmt.Fprintf(&buf, "list[i] = edit(x).(%s%s)\n", ptr, typ)
		fmt.Fprintf(&buf, "}\n")
		fmt.Fprintf(&buf, "}\n")
		fmt.Fprintf(&buf, "}\n")
	}
}

"""



```
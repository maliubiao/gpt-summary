Response: Let's break down the thought process for analyzing this Go code snippet.

**1. Initial Scan and Obvious Patterns:**

The first thing that jumps out is the repetitive structure. Each block of code follows a similar pattern:

* Starts with `func (n *TypeName) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }`
* Followed by `func (n *TypeName) copy() Node { ... }`
* Then `func (n *TypeName) doChildren(do func(Node) bool) bool { ... }`
* And `func (n *TypeName) editChildren(edit func(Node) Node) { ... }`
* Often with `doChildrenWithHidden` and `editChildrenWithHidden` variants.

The `TypeName` changes for each block (e.g., `AddStringExpr`, `AddrExpr`, `AssignStmt`). This strongly suggests that each block is defining methods for a specific type.

**2. Deduction of Core Functionality:**

* **`Format`:**  The `fmt.State` and `verb rune` parameters are standard for implementing the `fmt.Formatter` interface. The call to `fmtNode` reinforces this. Therefore, this method likely handles how these `ir.Node` types are formatted for printing (e.g., using `%v`, `%#v`, etc.).

* **`copy`:** This method creates a new instance of the `TypeName` and copies the fields. The `copyNodes` and `copyNames` functions suggest that fields holding slices of `Node` or `Name` types need special handling for deep copying. This is standard practice to avoid aliasing issues when working with complex data structures.

* **`doChildren` and `editChildren`:** The `do func(Node) bool` and `edit func(Node) Node` patterns point to tree traversal or manipulation. The "children" terminology is a strong clue. These methods appear to iterate over the "child" nodes of the current node and apply a given function (`do` or `edit`). The `WithHidden` variants likely deal with nodes that might be considered internal or less visible in a typical traversal.

**3. Connecting to Compiler Concepts:**

Given the file path `go/src/cmd/compile/internal/ir/node_gen.go`, and the presence of "nodes" and operations like "copying" and "editing," the immediate thought is that this code is part of the Go compiler's internal representation (IR - Intermediate Representation).

The methods likely operate on an Abstract Syntax Tree (AST) or a similar data structure used during compilation. Each `TypeName` likely represents a specific kind of node in this tree (e.g., an addition expression, an address-of expression, an assignment statement).

**4. Inferring the Role of `mknode.go`:**

The comment `// Code generated by mknode.go. DO NOT EDIT.` is crucial. It means this code isn't written manually but is automatically generated. `mknode.go` is likely a tool that takes a specification of the IR node types and generates the boilerplate code for methods like `Format`, `copy`, `doChildren`, and `editChildren`. This makes the compiler code more maintainable by reducing repetitive manual coding.

**5. Constructing Examples:**

Now, armed with the understanding that these are IR nodes, we can construct plausible Go code examples that would result in these node types being created during compilation.

* **`AddStringExpr`:** String concatenation using the `+` operator.
* **`AddrExpr`:** Taking the address of a variable using the `&` operator.
* **`AssignStmt`:** Basic variable assignment.
* **`BinaryExpr`:** Arithmetic or logical operations like `a + b` or `x > y`.
* **`BlockStmt`:** Code enclosed in curly braces `{}`.
* **`CallExpr`:** Function calls.
* **`CompLitExpr`:** Composite literals (e.g., array or struct initialization).
* **`ForStmt`:** `for` loops.
* **`IfStmt`:** `if` statements.
* **`IndexExpr`:** Array or slice indexing.
* **`RangeStmt`:** `for...range` loops.
* **`ReturnStmt`:** `return` statements.
* **`SelectorExpr`:** Accessing fields of a struct or methods of a receiver.

**6. Considering Command-Line Arguments (and Absence Thereof):**

Since the code is about the *internal representation* of Go code, it doesn't directly handle command-line arguments passed to the `go` compiler. The command-line argument parsing happens in earlier stages of the compilation process.

**7. Identifying Potential Pitfalls:**

The primary pitfall relates to the generated nature of the code. Users of the `ir` package (other parts of the compiler) need to be aware that:

* **Don't edit this file directly:**  Changes will be overwritten.
* **Understand the underlying node structure:**  To effectively use the `doChildren` and `editChildren` methods, you need to know what the "children" of a given node type are. This information is likely defined elsewhere (perhaps in the input to `mknode.go`).

**Self-Correction/Refinement:**

Initially, I might have focused too much on the specific details of each method. However, recognizing the overarching pattern and the "generated code" comment quickly shifts the focus to the higher-level purpose and how this code fits into the compiler's architecture. The examples are then generated based on the *types* of nodes, not by reverse-engineering the exact logic within `doChildren` or `editChildren`. The `WithHidden` methods initially seemed confusing, but realizing they likely handle less common or internal aspects of the IR clarifies their purpose.
The Go code snippet you provided is a part of the Abstract Syntax Tree (AST) representation used by the Go compiler. Specifically, the file `go/src/cmd/compile/internal/ir/node_gen.go` is auto-generated code that defines methods for various node types within this AST.

Here's a breakdown of its functionality:

**1. Defining Methods for AST Node Types:**

The core function of this file is to define common methods for different types of nodes in the Go compiler's intermediate representation (IR). Each block of code, starting with a type like `AddStringExpr`, `AddrExpr`, etc., defines methods specific to that node type.

**2. Common Methods Implemented:**

For each node type, the code implements several methods, including:

* **`Format(s fmt.State, verb rune)`:** This method implements the `fmt.Formatter` interface, allowing these AST nodes to be printed in a human-readable format using the `fmt` package. It likely delegates to a common formatting function `fmtNode`.
* **`copy() Node`:** This method creates a deep copy of the AST node. It ensures that any child nodes (and their children, recursively) are also copied, preventing unintended modification of the original tree. It uses helper functions like `copyNodes` and `copyNames` to handle slices of child nodes.
* **`doChildren(do func(Node) bool) bool`:** This method facilitates traversing the AST. It takes a function `do` as an argument and calls it for each direct child node of the current node. The `do` function is expected to return `true` if the traversal should stop, otherwise `false`.
* **`doChildrenWithHidden(do func(Node) bool) bool`:** Similar to `doChildren`, but this method might include "hidden" or less commonly traversed child nodes in the iteration.
* **`editChildren(edit func(Node) Node)`:** This method allows modifying the AST. It takes a function `edit` as an argument, calls it for each direct child node, and replaces the child node with the result of the `edit` function. The `edit` function should return the modified child node.
* **`editChildrenWithHidden(edit func(Node) Node)`:** Similar to `editChildren`, but it might include "hidden" child nodes in the editing process.

**3. Purpose within the Go Compiler:**

This file plays a crucial role in the Go compiler's internal workings:

* **AST Manipulation:** The `copy`, `doChildren`, and `editChildren` methods provide the foundation for algorithms that analyze, transform, and optimize the Go code represented by the AST. Compiler passes like type checking, optimization, and code generation rely on these methods to navigate and modify the syntax tree.
* **Debugging and Visualization:** The `Format` method is useful for debugging the compiler itself. It allows developers to inspect the structure of the AST during different stages of compilation.

**4. What Go Language Feature Does This Implement?**

This code *doesn't* implement a specific Go language feature directly. Instead, it provides the *infrastructure* for representing and manipulating Go code internally within the compiler. The various node types (like `AddStringExpr`, `AssignStmt`, `ForStmt`) represent different syntactic constructs of the Go language.

**5. Go Code Example (Illustrative):**

To illustrate how these node types might be used, consider the Go code:

```go
package main

func main() {
	a := "hello"
	b := "world"
	c := a + b
	println(c)
}
```

When this code is parsed by the Go compiler, the expression `a + b` would likely be represented by an `AddStringExpr` node in the AST. The assignments `a := "hello"` and `b := "world"` would be represented by `AssignStmt` nodes. The `println(c)` call would be a `CallExpr`.

**Hypothetical Input and Output for `doChildren`:**

Let's imagine we have the `AddStringExpr` node for `c := a + b`.

**Input:** An `AddStringExpr` node representing `a + b`.

**`doChildren` call:**

```go
addStringNode.doChildren(func(n ir.Node) bool {
    fmt.Printf("Child node type: %T\n", n)
    return false // Continue traversal
})
```

**Hypothetical Output:**

```
Child node type: *ir.Name  // Represents 'a'
Child node type: *ir.Name  // Represents 'b'
```

**Explanation:** The `AddStringExpr` node has children representing the operands of the string concatenation, which in this case are likely `Name` nodes referring to the variables `a` and `b`.

**6. Command-Line Parameters:**

This specific code file (`node_gen.go`) doesn't directly handle command-line parameters. The Go compiler (`go build`, `go run`, etc.) handles command-line arguments in earlier stages. This file deals with the internal representation of the code *after* parsing and initial processing of command-line options.

**7. User Mistakes:**

Since this file is auto-generated and part of the compiler's internal implementation, it's not typically used directly by Go programmers writing application code. However, developers working on the Go compiler itself might make mistakes, such as:

* **Manually editing `node_gen.go`:** This is explicitly discouraged by the `DO NOT EDIT` comment. Any manual changes will be overwritten when `mknode.go` is run again.
* **Incorrectly implementing the `do` or `edit` functions:** When using `doChildren` or `editChildren`, providing functions that don't handle all possible child node types or perform incorrect modifications can lead to compiler errors or unexpected behavior.
* **Assuming a specific order of children:** While the code iterates over children, the exact order might not always be guaranteed or documented. Relying on a specific order could lead to bugs if the internal representation changes.

**In summary, `go/src/cmd/compile/internal/ir/node_gen.go` is a crucial, auto-generated file in the Go compiler that defines the structure and common operations for the Abstract Syntax Tree nodes, which are the compiler's internal representation of Go code.** It provides the building blocks for various compiler passes to analyze, transform, and generate code from Go source.

Prompt: 
```
这是路径为go/src/cmd/compile/internal/ir/node_gen.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，

"""
// Code generated by mknode.go. DO NOT EDIT.

package ir

import "fmt"

func (n *AddStringExpr) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *AddStringExpr) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	c.List = copyNodes(c.List)
	return &c
}
func (n *AddStringExpr) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if doNodes(n.List, do) {
		return true
	}
	if n.Prealloc != nil && do(n.Prealloc) {
		return true
	}
	return false
}
func (n *AddStringExpr) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if doNodes(n.List, do) {
		return true
	}
	if n.Prealloc != nil && do(n.Prealloc) {
		return true
	}
	return false
}
func (n *AddStringExpr) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	editNodes(n.List, edit)
	if n.Prealloc != nil {
		n.Prealloc = edit(n.Prealloc).(*Name)
	}
}
func (n *AddStringExpr) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	editNodes(n.List, edit)
	if n.Prealloc != nil {
		n.Prealloc = edit(n.Prealloc).(*Name)
	}
}

func (n *AddrExpr) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *AddrExpr) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	return &c
}
func (n *AddrExpr) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.X != nil && do(n.X) {
		return true
	}
	if n.Prealloc != nil && do(n.Prealloc) {
		return true
	}
	return false
}
func (n *AddrExpr) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.X != nil && do(n.X) {
		return true
	}
	if n.Prealloc != nil && do(n.Prealloc) {
		return true
	}
	return false
}
func (n *AddrExpr) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.X != nil {
		n.X = edit(n.X).(Node)
	}
	if n.Prealloc != nil {
		n.Prealloc = edit(n.Prealloc).(*Name)
	}
}
func (n *AddrExpr) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.X != nil {
		n.X = edit(n.X).(Node)
	}
	if n.Prealloc != nil {
		n.Prealloc = edit(n.Prealloc).(*Name)
	}
}

func (n *AssignListStmt) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *AssignListStmt) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	c.Lhs = copyNodes(c.Lhs)
	c.Rhs = copyNodes(c.Rhs)
	return &c
}
func (n *AssignListStmt) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if doNodes(n.Lhs, do) {
		return true
	}
	if doNodes(n.Rhs, do) {
		return true
	}
	return false
}
func (n *AssignListStmt) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if doNodes(n.Lhs, do) {
		return true
	}
	if doNodes(n.Rhs, do) {
		return true
	}
	return false
}
func (n *AssignListStmt) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	editNodes(n.Lhs, edit)
	editNodes(n.Rhs, edit)
}
func (n *AssignListStmt) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	editNodes(n.Lhs, edit)
	editNodes(n.Rhs, edit)
}

func (n *AssignOpStmt) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *AssignOpStmt) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	return &c
}
func (n *AssignOpStmt) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.X != nil && do(n.X) {
		return true
	}
	if n.Y != nil && do(n.Y) {
		return true
	}
	return false
}
func (n *AssignOpStmt) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.X != nil && do(n.X) {
		return true
	}
	if n.Y != nil && do(n.Y) {
		return true
	}
	return false
}
func (n *AssignOpStmt) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.X != nil {
		n.X = edit(n.X).(Node)
	}
	if n.Y != nil {
		n.Y = edit(n.Y).(Node)
	}
}
func (n *AssignOpStmt) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.X != nil {
		n.X = edit(n.X).(Node)
	}
	if n.Y != nil {
		n.Y = edit(n.Y).(Node)
	}
}

func (n *AssignStmt) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *AssignStmt) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	return &c
}
func (n *AssignStmt) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.X != nil && do(n.X) {
		return true
	}
	if n.Y != nil && do(n.Y) {
		return true
	}
	return false
}
func (n *AssignStmt) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.X != nil && do(n.X) {
		return true
	}
	if n.Y != nil && do(n.Y) {
		return true
	}
	return false
}
func (n *AssignStmt) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.X != nil {
		n.X = edit(n.X).(Node)
	}
	if n.Y != nil {
		n.Y = edit(n.Y).(Node)
	}
}
func (n *AssignStmt) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.X != nil {
		n.X = edit(n.X).(Node)
	}
	if n.Y != nil {
		n.Y = edit(n.Y).(Node)
	}
}

func (n *BasicLit) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *BasicLit) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	return &c
}
func (n *BasicLit) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	return false
}
func (n *BasicLit) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	return false
}
func (n *BasicLit) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
}
func (n *BasicLit) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
}

func (n *BinaryExpr) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *BinaryExpr) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	return &c
}
func (n *BinaryExpr) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.X != nil && do(n.X) {
		return true
	}
	if n.Y != nil && do(n.Y) {
		return true
	}
	return false
}
func (n *BinaryExpr) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.X != nil && do(n.X) {
		return true
	}
	if n.Y != nil && do(n.Y) {
		return true
	}
	if n.RType != nil && do(n.RType) {
		return true
	}
	return false
}
func (n *BinaryExpr) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.X != nil {
		n.X = edit(n.X).(Node)
	}
	if n.Y != nil {
		n.Y = edit(n.Y).(Node)
	}
}
func (n *BinaryExpr) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.X != nil {
		n.X = edit(n.X).(Node)
	}
	if n.Y != nil {
		n.Y = edit(n.Y).(Node)
	}
	if n.RType != nil {
		n.RType = edit(n.RType).(Node)
	}
}

func (n *BlockStmt) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *BlockStmt) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	c.List = copyNodes(c.List)
	return &c
}
func (n *BlockStmt) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if doNodes(n.List, do) {
		return true
	}
	return false
}
func (n *BlockStmt) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if doNodes(n.List, do) {
		return true
	}
	return false
}
func (n *BlockStmt) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	editNodes(n.List, edit)
}
func (n *BlockStmt) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	editNodes(n.List, edit)
}

func (n *BranchStmt) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *BranchStmt) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	return &c
}
func (n *BranchStmt) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	return false
}
func (n *BranchStmt) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	return false
}
func (n *BranchStmt) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
}
func (n *BranchStmt) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
}

func (n *CallExpr) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *CallExpr) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	c.Args = copyNodes(c.Args)
	c.KeepAlive = copyNames(c.KeepAlive)
	return &c
}
func (n *CallExpr) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.Fun != nil && do(n.Fun) {
		return true
	}
	if doNodes(n.Args, do) {
		return true
	}
	if n.DeferAt != nil && do(n.DeferAt) {
		return true
	}
	if doNames(n.KeepAlive, do) {
		return true
	}
	return false
}
func (n *CallExpr) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.Fun != nil && do(n.Fun) {
		return true
	}
	if doNodes(n.Args, do) {
		return true
	}
	if n.DeferAt != nil && do(n.DeferAt) {
		return true
	}
	if n.RType != nil && do(n.RType) {
		return true
	}
	if doNames(n.KeepAlive, do) {
		return true
	}
	return false
}
func (n *CallExpr) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.Fun != nil {
		n.Fun = edit(n.Fun).(Node)
	}
	editNodes(n.Args, edit)
	if n.DeferAt != nil {
		n.DeferAt = edit(n.DeferAt).(Node)
	}
	editNames(n.KeepAlive, edit)
}
func (n *CallExpr) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.Fun != nil {
		n.Fun = edit(n.Fun).(Node)
	}
	editNodes(n.Args, edit)
	if n.DeferAt != nil {
		n.DeferAt = edit(n.DeferAt).(Node)
	}
	if n.RType != nil {
		n.RType = edit(n.RType).(Node)
	}
	editNames(n.KeepAlive, edit)
}

func (n *CaseClause) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *CaseClause) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	c.List = copyNodes(c.List)
	c.RTypes = copyNodes(c.RTypes)
	c.Body = copyNodes(c.Body)
	return &c
}
func (n *CaseClause) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.Var != nil && do(n.Var) {
		return true
	}
	if doNodes(n.List, do) {
		return true
	}
	if doNodes(n.RTypes, do) {
		return true
	}
	if doNodes(n.Body, do) {
		return true
	}
	return false
}
func (n *CaseClause) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.Var != nil && do(n.Var) {
		return true
	}
	if doNodes(n.List, do) {
		return true
	}
	if doNodes(n.RTypes, do) {
		return true
	}
	if doNodes(n.Body, do) {
		return true
	}
	return false
}
func (n *CaseClause) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.Var != nil {
		n.Var = edit(n.Var).(*Name)
	}
	editNodes(n.List, edit)
	editNodes(n.RTypes, edit)
	editNodes(n.Body, edit)
}
func (n *CaseClause) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.Var != nil {
		n.Var = edit(n.Var).(*Name)
	}
	editNodes(n.List, edit)
	editNodes(n.RTypes, edit)
	editNodes(n.Body, edit)
}

func (n *ClosureExpr) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *ClosureExpr) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	return &c
}
func (n *ClosureExpr) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.Prealloc != nil && do(n.Prealloc) {
		return true
	}
	return false
}
func (n *ClosureExpr) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.Prealloc != nil && do(n.Prealloc) {
		return true
	}
	return false
}
func (n *ClosureExpr) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.Prealloc != nil {
		n.Prealloc = edit(n.Prealloc).(*Name)
	}
}
func (n *ClosureExpr) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.Prealloc != nil {
		n.Prealloc = edit(n.Prealloc).(*Name)
	}
}

func (n *CommClause) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *CommClause) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	c.Body = copyNodes(c.Body)
	return &c
}
func (n *CommClause) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.Comm != nil && do(n.Comm) {
		return true
	}
	if doNodes(n.Body, do) {
		return true
	}
	return false
}
func (n *CommClause) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.Comm != nil && do(n.Comm) {
		return true
	}
	if doNodes(n.Body, do) {
		return true
	}
	return false
}
func (n *CommClause) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.Comm != nil {
		n.Comm = edit(n.Comm).(Node)
	}
	editNodes(n.Body, edit)
}
func (n *CommClause) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.Comm != nil {
		n.Comm = edit(n.Comm).(Node)
	}
	editNodes(n.Body, edit)
}

func (n *CompLitExpr) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *CompLitExpr) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	c.List = copyNodes(c.List)
	return &c
}
func (n *CompLitExpr) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if doNodes(n.List, do) {
		return true
	}
	if n.Prealloc != nil && do(n.Prealloc) {
		return true
	}
	return false
}
func (n *CompLitExpr) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if doNodes(n.List, do) {
		return true
	}
	if n.RType != nil && do(n.RType) {
		return true
	}
	if n.Prealloc != nil && do(n.Prealloc) {
		return true
	}
	return false
}
func (n *CompLitExpr) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	editNodes(n.List, edit)
	if n.Prealloc != nil {
		n.Prealloc = edit(n.Prealloc).(*Name)
	}
}
func (n *CompLitExpr) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	editNodes(n.List, edit)
	if n.RType != nil {
		n.RType = edit(n.RType).(Node)
	}
	if n.Prealloc != nil {
		n.Prealloc = edit(n.Prealloc).(*Name)
	}
}

func (n *ConvExpr) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *ConvExpr) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	return &c
}
func (n *ConvExpr) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.X != nil && do(n.X) {
		return true
	}
	return false
}
func (n *ConvExpr) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.X != nil && do(n.X) {
		return true
	}
	if n.TypeWord != nil && do(n.TypeWord) {
		return true
	}
	if n.SrcRType != nil && do(n.SrcRType) {
		return true
	}
	if n.ElemRType != nil && do(n.ElemRType) {
		return true
	}
	if n.ElemElemRType != nil && do(n.ElemElemRType) {
		return true
	}
	return false
}
func (n *ConvExpr) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.X != nil {
		n.X = edit(n.X).(Node)
	}
}
func (n *ConvExpr) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.X != nil {
		n.X = edit(n.X).(Node)
	}
	if n.TypeWord != nil {
		n.TypeWord = edit(n.TypeWord).(Node)
	}
	if n.SrcRType != nil {
		n.SrcRType = edit(n.SrcRType).(Node)
	}
	if n.ElemRType != nil {
		n.ElemRType = edit(n.ElemRType).(Node)
	}
	if n.ElemElemRType != nil {
		n.ElemElemRType = edit(n.ElemElemRType).(Node)
	}
}

func (n *Decl) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *Decl) copy() Node {
	c := *n
	return &c
}
func (n *Decl) doChildren(do func(Node) bool) bool {
	if n.X != nil && do(n.X) {
		return true
	}
	return false
}
func (n *Decl) doChildrenWithHidden(do func(Node) bool) bool {
	if n.X != nil && do(n.X) {
		return true
	}
	return false
}
func (n *Decl) editChildren(edit func(Node) Node) {
	if n.X != nil {
		n.X = edit(n.X).(*Name)
	}
}
func (n *Decl) editChildrenWithHidden(edit func(Node) Node) {
	if n.X != nil {
		n.X = edit(n.X).(*Name)
	}
}

func (n *DynamicType) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *DynamicType) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	return &c
}
func (n *DynamicType) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.RType != nil && do(n.RType) {
		return true
	}
	if n.ITab != nil && do(n.ITab) {
		return true
	}
	return false
}
func (n *DynamicType) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.RType != nil && do(n.RType) {
		return true
	}
	if n.ITab != nil && do(n.ITab) {
		return true
	}
	return false
}
func (n *DynamicType) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.RType != nil {
		n.RType = edit(n.RType).(Node)
	}
	if n.ITab != nil {
		n.ITab = edit(n.ITab).(Node)
	}
}
func (n *DynamicType) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.RType != nil {
		n.RType = edit(n.RType).(Node)
	}
	if n.ITab != nil {
		n.ITab = edit(n.ITab).(Node)
	}
}

func (n *DynamicTypeAssertExpr) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *DynamicTypeAssertExpr) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	return &c
}
func (n *DynamicTypeAssertExpr) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.X != nil && do(n.X) {
		return true
	}
	if n.SrcRType != nil && do(n.SrcRType) {
		return true
	}
	if n.RType != nil && do(n.RType) {
		return true
	}
	if n.ITab != nil && do(n.ITab) {
		return true
	}
	return false
}
func (n *DynamicTypeAssertExpr) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.X != nil && do(n.X) {
		return true
	}
	if n.SrcRType != nil && do(n.SrcRType) {
		return true
	}
	if n.RType != nil && do(n.RType) {
		return true
	}
	if n.ITab != nil && do(n.ITab) {
		return true
	}
	return false
}
func (n *DynamicTypeAssertExpr) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.X != nil {
		n.X = edit(n.X).(Node)
	}
	if n.SrcRType != nil {
		n.SrcRType = edit(n.SrcRType).(Node)
	}
	if n.RType != nil {
		n.RType = edit(n.RType).(Node)
	}
	if n.ITab != nil {
		n.ITab = edit(n.ITab).(Node)
	}
}
func (n *DynamicTypeAssertExpr) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.X != nil {
		n.X = edit(n.X).(Node)
	}
	if n.SrcRType != nil {
		n.SrcRType = edit(n.SrcRType).(Node)
	}
	if n.RType != nil {
		n.RType = edit(n.RType).(Node)
	}
	if n.ITab != nil {
		n.ITab = edit(n.ITab).(Node)
	}
}

func (n *ForStmt) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *ForStmt) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	c.Body = copyNodes(c.Body)
	return &c
}
func (n *ForStmt) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.Cond != nil && do(n.Cond) {
		return true
	}
	if n.Post != nil && do(n.Post) {
		return true
	}
	if doNodes(n.Body, do) {
		return true
	}
	return false
}
func (n *ForStmt) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.Cond != nil && do(n.Cond) {
		return true
	}
	if n.Post != nil && do(n.Post) {
		return true
	}
	if doNodes(n.Body, do) {
		return true
	}
	return false
}
func (n *ForStmt) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.Cond != nil {
		n.Cond = edit(n.Cond).(Node)
	}
	if n.Post != nil {
		n.Post = edit(n.Post).(Node)
	}
	editNodes(n.Body, edit)
}
func (n *ForStmt) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.Cond != nil {
		n.Cond = edit(n.Cond).(Node)
	}
	if n.Post != nil {
		n.Post = edit(n.Post).(Node)
	}
	editNodes(n.Body, edit)
}

func (n *Func) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }

func (n *GoDeferStmt) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *GoDeferStmt) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	return &c
}
func (n *GoDeferStmt) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.Call != nil && do(n.Call) {
		return true
	}
	if n.DeferAt != nil && do(n.DeferAt) {
		return true
	}
	return false
}
func (n *GoDeferStmt) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.Call != nil && do(n.Call) {
		return true
	}
	if n.DeferAt != nil && do(n.DeferAt) {
		return true
	}
	return false
}
func (n *GoDeferStmt) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.Call != nil {
		n.Call = edit(n.Call).(Node)
	}
	if n.DeferAt != nil {
		n.DeferAt = edit(n.DeferAt).(Expr)
	}
}
func (n *GoDeferStmt) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.Call != nil {
		n.Call = edit(n.Call).(Node)
	}
	if n.DeferAt != nil {
		n.DeferAt = edit(n.DeferAt).(Expr)
	}
}

func (n *Ident) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *Ident) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	return &c
}
func (n *Ident) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	return false
}
func (n *Ident) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	return false
}
func (n *Ident) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
}
func (n *Ident) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
}

func (n *IfStmt) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *IfStmt) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	c.Body = copyNodes(c.Body)
	c.Else = copyNodes(c.Else)
	return &c
}
func (n *IfStmt) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.Cond != nil && do(n.Cond) {
		return true
	}
	if doNodes(n.Body, do) {
		return true
	}
	if doNodes(n.Else, do) {
		return true
	}
	return false
}
func (n *IfStmt) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.Cond != nil && do(n.Cond) {
		return true
	}
	if doNodes(n.Body, do) {
		return true
	}
	if doNodes(n.Else, do) {
		return true
	}
	return false
}
func (n *IfStmt) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.Cond != nil {
		n.Cond = edit(n.Cond).(Node)
	}
	editNodes(n.Body, edit)
	editNodes(n.Else, edit)
}
func (n *IfStmt) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.Cond != nil {
		n.Cond = edit(n.Cond).(Node)
	}
	editNodes(n.Body, edit)
	editNodes(n.Else, edit)
}

func (n *IndexExpr) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *IndexExpr) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	return &c
}
func (n *IndexExpr) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.X != nil && do(n.X) {
		return true
	}
	if n.Index != nil && do(n.Index) {
		return true
	}
	return false
}
func (n *IndexExpr) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.X != nil && do(n.X) {
		return true
	}
	if n.Index != nil && do(n.Index) {
		return true
	}
	if n.RType != nil && do(n.RType) {
		return true
	}
	return false
}
func (n *IndexExpr) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.X != nil {
		n.X = edit(n.X).(Node)
	}
	if n.Index != nil {
		n.Index = edit(n.Index).(Node)
	}
}
func (n *IndexExpr) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.X != nil {
		n.X = edit(n.X).(Node)
	}
	if n.Index != nil {
		n.Index = edit(n.Index).(Node)
	}
	if n.RType != nil {
		n.RType = edit(n.RType).(Node)
	}
}

func (n *InlineMarkStmt) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *InlineMarkStmt) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	return &c
}
func (n *InlineMarkStmt) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	return false
}
func (n *InlineMarkStmt) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	return false
}
func (n *InlineMarkStmt) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
}
func (n *InlineMarkStmt) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
}

func (n *InlinedCallExpr) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *InlinedCallExpr) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	c.Body = copyNodes(c.Body)
	c.ReturnVars = copyNodes(c.ReturnVars)
	return &c
}
func (n *InlinedCallExpr) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if doNodes(n.Body, do) {
		return true
	}
	if doNodes(n.ReturnVars, do) {
		return true
	}
	return false
}
func (n *InlinedCallExpr) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if doNodes(n.Body, do) {
		return true
	}
	if doNodes(n.ReturnVars, do) {
		return true
	}
	return false
}
func (n *InlinedCallExpr) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	editNodes(n.Body, edit)
	editNodes(n.ReturnVars, edit)
}
func (n *InlinedCallExpr) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	editNodes(n.Body, edit)
	editNodes(n.ReturnVars, edit)
}

func (n *InterfaceSwitchStmt) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *InterfaceSwitchStmt) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	return &c
}
func (n *InterfaceSwitchStmt) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.Case != nil && do(n.Case) {
		return true
	}
	if n.Itab != nil && do(n.Itab) {
		return true
	}
	if n.RuntimeType != nil && do(n.RuntimeType) {
		return true
	}
	if n.Hash != nil && do(n.Hash) {
		return true
	}
	return false
}
func (n *InterfaceSwitchStmt) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.Case != nil && do(n.Case) {
		return true
	}
	if n.Itab != nil && do(n.Itab) {
		return true
	}
	if n.RuntimeType != nil && do(n.RuntimeType) {
		return true
	}
	if n.Hash != nil && do(n.Hash) {
		return true
	}
	return false
}
func (n *InterfaceSwitchStmt) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.Case != nil {
		n.Case = edit(n.Case).(Node)
	}
	if n.Itab != nil {
		n.Itab = edit(n.Itab).(Node)
	}
	if n.RuntimeType != nil {
		n.RuntimeType = edit(n.RuntimeType).(Node)
	}
	if n.Hash != nil {
		n.Hash = edit(n.Hash).(Node)
	}
}
func (n *InterfaceSwitchStmt) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.Case != nil {
		n.Case = edit(n.Case).(Node)
	}
	if n.Itab != nil {
		n.Itab = edit(n.Itab).(Node)
	}
	if n.RuntimeType != nil {
		n.RuntimeType = edit(n.RuntimeType).(Node)
	}
	if n.Hash != nil {
		n.Hash = edit(n.Hash).(Node)
	}
}

func (n *JumpTableStmt) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *JumpTableStmt) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	return &c
}
func (n *JumpTableStmt) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.Idx != nil && do(n.Idx) {
		return true
	}
	return false
}
func (n *JumpTableStmt) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.Idx != nil && do(n.Idx) {
		return true
	}
	return false
}
func (n *JumpTableStmt) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.Idx != nil {
		n.Idx = edit(n.Idx).(Node)
	}
}
func (n *JumpTableStmt) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.Idx != nil {
		n.Idx = edit(n.Idx).(Node)
	}
}

func (n *KeyExpr) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *KeyExpr) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	return &c
}
func (n *KeyExpr) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.Key != nil && do(n.Key) {
		return true
	}
	if n.Value != nil && do(n.Value) {
		return true
	}
	return false
}
func (n *KeyExpr) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.Key != nil && do(n.Key) {
		return true
	}
	if n.Value != nil && do(n.Value) {
		return true
	}
	return false
}
func (n *KeyExpr) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.Key != nil {
		n.Key = edit(n.Key).(Node)
	}
	if n.Value != nil {
		n.Value = edit(n.Value).(Node)
	}
}
func (n *KeyExpr) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.Key != nil {
		n.Key = edit(n.Key).(Node)
	}
	if n.Value != nil {
		n.Value = edit(n.Value).(Node)
	}
}

func (n *LabelStmt) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *LabelStmt) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	return &c
}
func (n *LabelStmt) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	return false
}
func (n *LabelStmt) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	return false
}
func (n *LabelStmt) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
}
func (n *LabelStmt) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
}

func (n *LinksymOffsetExpr) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *LinksymOffsetExpr) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	return &c
}
func (n *LinksymOffsetExpr) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	return false
}
func (n *LinksymOffsetExpr) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	return false
}
func (n *LinksymOffsetExpr) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
}
func (n *LinksymOffsetExpr) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
}

func (n *LogicalExpr) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *LogicalExpr) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	return &c
}
func (n *LogicalExpr) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.X != nil && do(n.X) {
		return true
	}
	if n.Y != nil && do(n.Y) {
		return true
	}
	return false
}
func (n *LogicalExpr) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.X != nil && do(n.X) {
		return true
	}
	if n.Y != nil && do(n.Y) {
		return true
	}
	return false
}
func (n *LogicalExpr) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.X != nil {
		n.X = edit(n.X).(Node)
	}
	if n.Y != nil {
		n.Y = edit(n.Y).(Node)
	}
}
func (n *LogicalExpr) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.X != nil {
		n.X = edit(n.X).(Node)
	}
	if n.Y != nil {
		n.Y = edit(n.Y).(Node)
	}
}

func (n *MakeExpr) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *MakeExpr) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	return &c
}
func (n *MakeExpr) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.Len != nil && do(n.Len) {
		return true
	}
	if n.Cap != nil && do(n.Cap) {
		return true
	}
	return false
}
func (n *MakeExpr) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.RType != nil && do(n.RType) {
		return true
	}
	if n.Len != nil && do(n.Len) {
		return true
	}
	if n.Cap != nil && do(n.Cap) {
		return true
	}
	return false
}
func (n *MakeExpr) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.Len != nil {
		n.Len = edit(n.Len).(Node)
	}
	if n.Cap != nil {
		n.Cap = edit(n.Cap).(Node)
	}
}
func (n *MakeExpr) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.RType != nil {
		n.RType = edit(n.RType).(Node)
	}
	if n.Len != nil {
		n.Len = edit(n.Len).(Node)
	}
	if n.Cap != nil {
		n.Cap = edit(n.Cap).(Node)
	}
}

func (n *Name) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }

func (n *NilExpr) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *NilExpr) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	return &c
}
func (n *NilExpr) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	return false
}
func (n *NilExpr) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	return false
}
func (n *NilExpr) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
}
func (n *NilExpr) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
}

func (n *ParenExpr) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *ParenExpr) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	return &c
}
func (n *ParenExpr) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.X != nil && do(n.X) {
		return true
	}
	return false
}
func (n *ParenExpr) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.X != nil && do(n.X) {
		return true
	}
	return false
}
func (n *ParenExpr) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.X != nil {
		n.X = edit(n.X).(Node)
	}
}
func (n *ParenExpr) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.X != nil {
		n.X = edit(n.X).(Node)
	}
}

func (n *RangeStmt) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *RangeStmt) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	c.Body = copyNodes(c.Body)
	return &c
}
func (n *RangeStmt) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.X != nil && do(n.X) {
		return true
	}
	if n.Key != nil && do(n.Key) {
		return true
	}
	if n.Value != nil && do(n.Value) {
		return true
	}
	if doNodes(n.Body, do) {
		return true
	}
	if n.Prealloc != nil && do(n.Prealloc) {
		return true
	}
	return false
}
func (n *RangeStmt) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.X != nil && do(n.X) {
		return true
	}
	if n.RType != nil && do(n.RType) {
		return true
	}
	if n.Key != nil && do(n.Key) {
		return true
	}
	if n.Value != nil && do(n.Value) {
		return true
	}
	if doNodes(n.Body, do) {
		return true
	}
	if n.Prealloc != nil && do(n.Prealloc) {
		return true
	}
	if n.KeyTypeWord != nil && do(n.KeyTypeWord) {
		return true
	}
	if n.KeySrcRType != nil && do(n.KeySrcRType) {
		return true
	}
	if n.ValueTypeWord != nil && do(n.ValueTypeWord) {
		return true
	}
	if n.ValueSrcRType != nil && do(n.ValueSrcRType) {
		return true
	}
	return false
}
func (n *RangeStmt) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.X != nil {
		n.X = edit(n.X).(Node)
	}
	if n.Key != nil {
		n.Key = edit(n.Key).(Node)
	}
	if n.Value != nil {
		n.Value = edit(n.Value).(Node)
	}
	editNodes(n.Body, edit)
	if n.Prealloc != nil {
		n.Prealloc = edit(n.Prealloc).(*Name)
	}
}
func (n *RangeStmt) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.X != nil {
		n.X = edit(n.X).(Node)
	}
	if n.RType != nil {
		n.RType = edit(n.RType).(Node)
	}
	if n.Key != nil {
		n.Key = edit(n.Key).(Node)
	}
	if n.Value != nil {
		n.Value = edit(n.Value).(Node)
	}
	editNodes(n.Body, edit)
	if n.Prealloc != nil {
		n.Prealloc = edit(n.Prealloc).(*Name)
	}
	if n.KeyTypeWord != nil {
		n.KeyTypeWord = edit(n.KeyTypeWord).(Node)
	}
	if n.KeySrcRType != nil {
		n.KeySrcRType = edit(n.KeySrcRType).(Node)
	}
	if n.ValueTypeWord != nil {
		n.ValueTypeWord = edit(n.ValueTypeWord).(Node)
	}
	if n.ValueSrcRType != nil {
		n.ValueSrcRType = edit(n.ValueSrcRType).(Node)
	}
}

func (n *ResultExpr) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *ResultExpr) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	return &c
}
func (n *ResultExpr) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	return false
}
func (n *ResultExpr) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	return false
}
func (n *ResultExpr) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
}
func (n *ResultExpr) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
}

func (n *ReturnStmt) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *ReturnStmt) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	c.Results = copyNodes(c.Results)
	return &c
}
func (n *ReturnStmt) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if doNodes(n.Results, do) {
		return true
	}
	return false
}
func (n *ReturnStmt) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if doNodes(n.Results, do) {
		return true
	}
	return false
}
func (n *ReturnStmt) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	editNodes(n.Results, edit)
}
func (n *ReturnStmt) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	editNodes(n.Results, edit)
}

func (n *SelectStmt) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *SelectStmt) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	c.Cases = copyCommClauses(c.Cases)
	c.Compiled = copyNodes(c.Compiled)
	return &c
}
func (n *SelectStmt) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if doCommClauses(n.Cases, do) {
		return true
	}
	if doNodes(n.Compiled, do) {
		return true
	}
	return false
}
func (n *SelectStmt) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if doCommClauses(n.Cases, do) {
		return true
	}
	if doNodes(n.Compiled, do) {
		return true
	}
	return false
}
func (n *SelectStmt) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	editCommClauses(n.Cases, edit)
	editNodes(n.Compiled, edit)
}
func (n *SelectStmt) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	editCommClauses(n.Cases, edit)
	editNodes(n.Compiled, edit)
}

func (n *SelectorExpr) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *SelectorExpr) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	return &c
}
func (n *SelectorExpr) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.X != nil && do(n.X) {
		return true
	}
	if n.Prealloc != nil && do(n.Prealloc) {
		return true
	}
	return false
}
func (n *SelectorExpr) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.X != nil && do(n.X) {
		return true
	}
	if n.Prealloc != nil && do(n.Prealloc) {
		return true
	}
	return false
}
func (n *SelectorExpr) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.X != nil {
		n.X = edit(n.X).(Node)
	}
	if n.Prealloc != nil {
		n.Prealloc = edit(n.Prealloc).(*Name)
	}
}
func (n *SelectorExpr) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.X != nil {
		n.X = edit(n.X).(Node)
	}
	if n.Prealloc != nil {
		n.Prealloc = edit(n.Prealloc).(*Name)
	}
}

func (n *SendStmt) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *SendStmt) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	return &c
}
func (n *SendStmt) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.Chan != nil && do(n.Chan) {
		return true
	}
	if n.Value != nil && do(n.Value) {
		return true
	}
	return false
}
func (n *SendStmt) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.Chan != nil && do(n.Chan) {
		return true
	}
	if n.Value != nil && do(n.Value) {
		return true
	}
	return false
}
func (n *SendStmt) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.Chan != nil {
		n.Chan = edit(n.Chan).(Node)
	}
	if n.Value != nil {
		n.Value = edit(n.Value).(Node)
	}
}
func (n *SendStmt) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.Chan != nil {
		n.Chan = edit(n.Chan).(Node)
	}
	if n.Value != nil {
		n.Value = edit(n.Value).(Node)
	}
}

func (n *SliceExpr) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *SliceExpr) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	return &c
}
func (n *SliceExpr) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.X != nil && do(n.X) {
		return true
	}
	if n.Low != nil && do(n.Low) {
		return true
	}
	if n.High != nil && do(n.High) {
		return true
	}
	if n.Max != nil && do(n.Max) {
		return true
	}
	return false
}
func (n *SliceExpr) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.X != nil && do(n.X) {
		return true
	}
	if n.Low != nil && do(n.Low) {
		return true
	}
	if n.High != nil && do(n.High) {
		return true
	}
	if n.Max != nil && do(n.Max) {
		return true
	}
	return false
}
func (n *SliceExpr) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.X != nil {
		n.X = edit(n.X).(Node)
	}
	if n.Low != nil {
		n.Low = edit(n.Low).(Node)
	}
	if n.High != nil {
		n.High = edit(n.High).(Node)
	}
	if n.Max != nil {
		n.Max = edit(n.Max).(Node)
	}
}
func (n *SliceExpr) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.X != nil {
		n.X = edit(n.X).(Node)
	}
	if n.Low != nil {
		n.Low = edit(n.Low).(Node)
	}
	if n.High != nil {
		n.High = edit(n.High).(Node)
	}
	if n.Max != nil {
		n.Max = edit(n.Max).(Node)
	}
}

func (n *SliceHeaderExpr) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *SliceHeaderExpr) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	return &c
}
func (n *SliceHeaderExpr) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.Ptr != nil && do(n.Ptr) {
		return true
	}
	if n.Len != nil && do(n.Len) {
		return true
	}
	if n.Cap != nil && do(n.Cap) {
		return true
	}
	return false
}
func (n *SliceHeaderExpr) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.Ptr != nil && do(n.Ptr) {
		return true
	}
	if n.Len != nil && do(n.Len) {
		return true
	}
	if n.Cap != nil && do(n.Cap) {
		return true
	}
	return false
}
func (n *SliceHeaderExpr) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.Ptr != nil {
		n.Ptr = edit(n.Ptr).(Node)
	}
	if n.Len != nil {
		n.Len = edit(n.Len).(Node)
	}
	if n.Cap != nil {
		n.Cap = edit(n.Cap).(Node)
	}
}
func (n *SliceHeaderExpr) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.Ptr != nil {
		n.Ptr = edit(n.Ptr).(Node)
	}
	if n.Len != nil {
		n.Len = edit(n.Len).(Node)
	}
	if n.Cap != nil {
		n.Cap = edit(n.Cap).(Node)
	}
}

func (n *StarExpr) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *StarExpr) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	return &c
}
func (n *StarExpr) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.X != nil && do(n.X) {
		return true
	}
	return false
}
func (n *StarExpr) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.X != nil && do(n.X) {
		return true
	}
	return false
}
func (n *StarExpr) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.X != nil {
		n.X = edit(n.X).(Node)
	}
}
func (n *StarExpr) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.X != nil {
		n.X = edit(n.X).(Node)
	}
}

func (n *StringHeaderExpr) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *StringHeaderExpr) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	return &c
}
func (n *StringHeaderExpr) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.Ptr != nil && do(n.Ptr) {
		return true
	}
	if n.Len != nil && do(n.Len) {
		return true
	}
	return false
}
func (n *StringHeaderExpr) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.Ptr != nil && do(n.Ptr) {
		return true
	}
	if n.Len != nil && do(n.Len) {
		return true
	}
	return false
}
func (n *StringHeaderExpr) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.Ptr != nil {
		n.Ptr = edit(n.Ptr).(Node)
	}
	if n.Len != nil {
		n.Len = edit(n.Len).(Node)
	}
}
func (n *StringHeaderExpr) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.Ptr != nil {
		n.Ptr = edit(n.Ptr).(Node)
	}
	if n.Len != nil {
		n.Len = edit(n.Len).(Node)
	}
}

func (n *StructKeyExpr) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *StructKeyExpr) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	return &c
}
func (n *StructKeyExpr) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.Value != nil && do(n.Value) {
		return true
	}
	return false
}
func (n *StructKeyExpr) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.Value != nil && do(n.Value) {
		return true
	}
	return false
}
func (n *StructKeyExpr) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.Value != nil {
		n.Value = edit(n.Value).(Node)
	}
}
func (n *StructKeyExpr) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.Value != nil {
		n.Value = edit(n.Value).(Node)
	}
}

func (n *SwitchStmt) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *SwitchStmt) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	c.Cases = copyCaseClauses(c.Cases)
	c.Compiled = copyNodes(c.Compiled)
	return &c
}
func (n *SwitchStmt) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.Tag != nil && do(n.Tag) {
		return true
	}
	if doCaseClauses(n.Cases, do) {
		return true
	}
	if doNodes(n.Compiled, do) {
		return true
	}
	return false
}
func (n *SwitchStmt) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.Tag != nil && do(n.Tag) {
		return true
	}
	if doCaseClauses(n.Cases, do) {
		return true
	}
	if doNodes(n.Compiled, do) {
		return true
	}
	return false
}
func (n *SwitchStmt) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.Tag != nil {
		n.Tag = edit(n.Tag).(Node)
	}
	editCaseClauses(n.Cases, edit)
	editNodes(n.Compiled, edit)
}
func (n *SwitchStmt) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.Tag != nil {
		n.Tag = edit(n.Tag).(Node)
	}
	editCaseClauses(n.Cases, edit)
	editNodes(n.Compiled, edit)
}

func (n *TailCallStmt) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *TailCallStmt) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	return &c
}
func (n *TailCallStmt) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.Call != nil && do(n.Call) {
		return true
	}
	return false
}
func (n *TailCallStmt) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.Call != nil && do(n.Call) {
		return true
	}
	return false
}
func (n *TailCallStmt) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.Call != nil {
		n.Call = edit(n.Call).(*CallExpr)
	}
}
func (n *TailCallStmt) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.Call != nil {
		n.Call = edit(n.Call).(*CallExpr)
	}
}

func (n *TypeAssertExpr) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *TypeAssertExpr) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	return &c
}
func (n *TypeAssertExpr) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.X != nil && do(n.X) {
		return true
	}
	return false
}
func (n *TypeAssertExpr) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.X != nil && do(n.X) {
		return true
	}
	if n.ITab != nil && do(n.ITab) {
		return true
	}
	return false
}
func (n *TypeAssertExpr) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.X != nil {
		n.X = edit(n.X).(Node)
	}
}
func (n *TypeAssertExpr) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.X != nil {
		n.X = edit(n.X).(Node)
	}
	if n.ITab != nil {
		n.ITab = edit(n.ITab).(Node)
	}
}

func (n *TypeSwitchGuard) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *TypeSwitchGuard) copy() Node {
	c := *n
	return &c
}
func (n *TypeSwitchGuard) doChildren(do func(Node) bool) bool {
	if n.Tag != nil && do(n.Tag) {
		return true
	}
	if n.X != nil && do(n.X) {
		return true
	}
	return false
}
func (n *TypeSwitchGuard) doChildrenWithHidden(do func(Node) bool) bool {
	if n.Tag != nil && do(n.Tag) {
		return true
	}
	if n.X != nil && do(n.X) {
		return true
	}
	return false
}
func (n *TypeSwitchGuard) editChildren(edit func(Node) Node) {
	if n.Tag != nil {
		n.Tag = edit(n.Tag).(*Ident)
	}
	if n.X != nil {
		n.X = edit(n.X).(Node)
	}
}
func (n *TypeSwitchGuard) editChildrenWithHidden(edit func(Node) Node) {
	if n.Tag != nil {
		n.Tag = edit(n.Tag).(*Ident)
	}
	if n.X != nil {
		n.X = edit(n.X).(Node)
	}
}

func (n *UnaryExpr) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *UnaryExpr) copy() Node {
	c := *n
	c.init = copyNodes(c.init)
	return &c
}
func (n *UnaryExpr) doChildren(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.X != nil && do(n.X) {
		return true
	}
	return false
}
func (n *UnaryExpr) doChildrenWithHidden(do func(Node) bool) bool {
	if doNodes(n.init, do) {
		return true
	}
	if n.X != nil && do(n.X) {
		return true
	}
	return false
}
func (n *UnaryExpr) editChildren(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.X != nil {
		n.X = edit(n.X).(Node)
	}
}
func (n *UnaryExpr) editChildrenWithHidden(edit func(Node) Node) {
	editNodes(n.init, edit)
	if n.X != nil {
		n.X = edit(n.X).(Node)
	}
}

func (n *typeNode) Format(s fmt.State, verb rune) { fmtNode(n, s, verb) }
func (n *typeNode) copy() Node {
	c := *n
	return &c
}
func (n *typeNode) doChildren(do func(Node) bool) bool {
	return false
}
func (n *typeNode) doChildrenWithHidden(do func(Node) bool) bool {
	return false
}
func (n *typeNode) editChildren(edit func(Node) Node) {
}
func (n *typeNode) editChildrenWithHidden(edit func(Node) Node) {
}

func copyCaseClauses(list []*CaseClause) []*CaseClause {
	if list == nil {
		return nil
	}
	c := make([]*CaseClause, len(list))
	copy(c, list)
	return c
}
func doCaseClauses(list []*CaseClause, do func(Node) bool) bool {
	for _, x := range list {
		if x != nil && do(x) {
			return true
		}
	}
	return false
}
func editCaseClauses(list []*CaseClause, edit func(Node) Node) {
	for i, x := range list {
		if x != nil {
			list[i] = edit(x).(*CaseClause)
		}
	}
}

func copyCommClauses(list []*CommClause) []*CommClause {
	if list == nil {
		return nil
	}
	c := make([]*CommClause, len(list))
	copy(c, list)
	return c
}
func doCommClauses(list []*CommClause, do func(Node) bool) bool {
	for _, x := range list {
		if x != nil && do(x) {
			return true
		}
	}
	return false
}
func editCommClauses(list []*CommClause, edit func(Node) Node) {
	for i, x := range list {
		if x != nil {
			list[i] = edit(x).(*CommClause)
		}
	}
}

func copyNames(list []*Name) []*Name {
	if list == nil {
		return nil
	}
	c := make([]*Name, len(list))
	copy(c, list)
	return c
}
func doNames(list []*Name, do func(Node) bool) bool {
	for _, x := range list {
		if x != nil && do(x) {
			return true
		}
	}
	return false
}
func editNames(list []*Name, edit func(Node) Node) {
	for i, x := range list {
		if x != nil {
			list[i] = edit(x).(*Name)
		}
	}
}

func copyNodes(list []Node) []Node {
	if list == nil {
		return nil
	}
	c := make([]Node, len(list))
	copy(c, list)
	return c
}
func doNodes(list []Node, do func(Node) bool) bool {
	for _, x := range list {
		if x != nil && do(x) {
			return true
		}
	}
	return false
}
func editNodes(list []Node, edit func(Node) Node) {
	for i, x := range list {
		if x != nil {
			list[i] = edit(x).(Node)
		}
	}
}

"""



```
Response:
Let's break down the thought process for analyzing the provided Go code snippet.

**1. Initial Understanding - The Context:**

The first clue is the file path: `go/src/cmd/compile/internal/ssa/_gen/MIPSOps.go`. This immediately tells us we're dealing with the Go compiler (`cmd/compile`), specifically its Static Single Assignment (SSA) intermediate representation (`internal/ssa`), and that this file likely *generates* code related to MIPS architecture (`MIPSOps.go`). The `_gen` directory strongly suggests code generation.

**2. High-Level Purpose - What does it *do*?**

The comment at the beginning is crucial:  "// This file is generated by ...". This confirms our suspicion about code generation. The comment also implicitly tells us this file defines the *operations* (ops) and *blocks* that the SSA representation uses for the MIPS architecture. Think of it as a blueprint for how Go code will be translated into MIPS assembly instructions within the compiler.

**3. Key Data Structures - Identifying the building blocks:**

Scanning the code, the following stand out:

* **`regNamesMIPS`:** A slice of strings representing the names of MIPS registers. This is fundamental for mapping abstract register concepts to actual hardware registers.
* **`regMask`:**  The code doesn't explicitly define this as a separate type within this snippet, but the usage (e.g., `regMask(0)`) and bitwise operations (`|=`, `&^`) strongly suggest it's an integer type used as a bitmask to represent sets of registers.
* **`regInfo`:** A struct that likely describes the input and output register requirements, and potential register clobbering for an operation.
* **`opData`:**  A struct containing detailed information about a specific MIPS operation: its name, number of arguments, register requirements (`regInfo`), assembly instruction (`asm`), any associated auxiliary data (`aux`), and other properties (commutative, type, etc.). This is the core definition of a MIPS operation within the SSA framework.
* **`blockData`:** A struct describing different types of control flow blocks (e.g., conditional branches) in the MIPS SSA representation.
* **`arch`:**  A struct that groups all the architecture-specific information together (name, package, generated file location, operations, blocks, register information, etc.).
* **`ops`:** A slice of `opData` structs – the complete list of supported MIPS operations in the SSA.
* **`blocks`:** A slice of `blockData` structs – the complete list of supported MIPS control flow block types.
* **`archs`:** A slice containing a single `arch` struct for MIPS.

**4. Functional Breakdown -  What do the pieces achieve?**

* **Register Mapping:** `regNamesMIPS` and the `init()` function create a mapping between symbolic register names (R0, SP, F0, etc.) and numerical identifiers. This is essential for the compiler's internal representation.
* **Register Masks:** The `buildReg` function takes a string of register names and creates a `regMask`. This is used in `regInfo` to specify which registers an operation uses or modifies.
* **Operation Definition:**  The `opData` struct is the central definition of each MIPS instruction the compiler knows about. It specifies the instruction's name, how many operands it takes, which registers it uses (inputs/outputs/clobbers), the corresponding assembly mnemonic, and other semantic properties.
* **Block Definition:** The `blockData` struct defines different control flow constructs, like conditional branches, by specifying the number of control inputs they have.
* **Architecture Definition:** The `arch` struct bundles all the MIPS-specific information, allowing the compiler to handle different target architectures.

**5. Inferring Go Functionality - Connecting to Go language features:**

The operations defined in `ops` directly relate to how Go code is translated to MIPS assembly. For example:

* **Arithmetic:** `ADD`, `SUB`, `MUL`, `DIV` correspond to Go's arithmetic operators (+, -, *, /).
* **Bitwise:** `AND`, `OR`, `XOR`, `SLL`, `SRL`, `SRA` correspond to Go's bitwise operators (&, |, ^, <<, >>).
* **Comparisons:** `SGT`, `CMPEQ`, `CMPGE`, `CMPGT` are used to implement Go's comparison operators (>, ==, >=).
* **Memory Access:** `MOVBload`, `MOVWstore` relate to how Go loads and stores values from memory (e.g., accessing array elements, struct fields).
* **Function Calls:** `CALLstatic`, `CALLclosure`, `CALLinter` are the underlying mechanisms for Go function calls.
* **Atomic Operations:** `LoweredAtomicLoad`, `LoweredAtomicStore`, `LoweredAtomicCas` support Go's `sync/atomic` package.
* **Panic and Bounds Checking:** `LoweredPanicBounds`, `LoweredPanicExtend` implement runtime checks for array and slice access.

**6. Code Examples (Illustrative):**

Based on the operation definitions, we can construct simple Go examples and infer how they might be represented using these SSA operations. The key is to map the Go source code constructs to the corresponding `opData`.

**7. Command-Line Parameters:**

While this specific file doesn't handle command-line parameters directly, it's part of the `go build` process. The choice of target architecture (MIPS in this case) is often specified through command-line flags like `GOARCH=mips`. The compiler uses this information to load the appropriate architecture definition (from `MIPSOps.go` in this scenario).

**8. Potential Pitfalls:**

The comments within the code provide hints about common issues, particularly with register usage and the handling of constant values. The notes about integer and boolean types living in the lower parts of registers and the handling of large constants are important for anyone working directly with the generated assembly or the SSA representation.

**Self-Correction/Refinement:**

During the analysis, I might initially focus too much on the individual instructions. It's important to step back and see the bigger picture – how these instructions are organized into `opData` and `blockData` and how the `arch` struct ties everything together for the MIPS architecture. The connection to Go language features might not be immediately obvious for every operation, but thinking about the compiler's task of translating high-level Go code into low-level machine instructions is key. Also, realizing the code generation nature of the file is a crucial piece of the puzzle.
这个文件 `go/src/cmd/compile/internal/ssa/_gen/MIPSOps.go` 是 Go 编译器的一部分，它定义了 **MIPS 架构** 在 **静态单赋值 (SSA)** 中间表示中使用的 **操作 (ops)** 和 **控制流块 (blocks)**。  由于路径中包含 `_gen`，可以推断出这个文件很可能是通过代码生成工具生成的。

让我们分解一下它的功能：

**1. 定义 MIPS 架构的寄存器:**

   - `regNamesMIPS` 变量定义了一个字符串切片，包含了 MIPS 架构中可用于寄存器分配的寄存器名称，例如 "R0", "R1", "SP", "F0" 等。
   - `init()` 函数中，它创建了一个从寄存器名称到索引的映射 (`num`)，并定义了一些常用的寄存器掩码 (`regMask`)，例如 `gp` (通用寄存器), `fp` (浮点寄存器) 等。 这些掩码用于描述指令可以使用的寄存器集合。

**2. 定义 MIPS 架构的指令操作 (ops):**

   - `opData` 结构体定义了 SSA 中表示 MIPS 指令所需的信息。 关键字段包括：
     - `name`: 操作的名称，例如 "ADD", "MOVWconst"。
     - `argLength`: 操作的操作数数量。
     - `reg`: 一个 `regInfo` 结构体，描述了操作的输入和输出寄存器需求，以及可能被修改的寄存器。
     - `asm`:  对应的 MIPS 汇编指令字符串，例如 "ADDU", "MOVW"。
     - `aux`:  辅助信息类型，例如 "Int32", "SymOff"，用于表示立即数或符号偏移。
     - `commutative`:  布尔值，指示操作是否满足交换律。
     - `typ`: 操作的类型信息。
     - 其他属性，如 `rematerializeable` (是否可以重新计算), `faultOnNilArg0` (如果第一个参数为 nil 是否会触发错误), `symEffect` (符号影响，如 "Read", "Write"), `call` (是否是函数调用), `clobberFlags` (是否会修改标志位) 等。
   - `ops` 变量是一个 `opData` 结构体的切片，它包含了所有 Go 编译器在 SSA 阶段为 MIPS 架构定义的操作。 每个 `opData` 元素都描述了一个特定的 MIPS 指令或操作。

**3. 定义 MIPS 架构的控制流块 (blocks):**

   - `blockData` 结构体定义了 SSA 中表示 MIPS 控制流块的信息。
     - `name`:  块的名称，例如 "EQ" (等于), "NE" (不等于)。
     - `controls`:  控制流块的控制输入数量。 例如，一个条件分支块会有一个控制输入。
   - `blocks` 变量是一个 `blockData` 结构体的切片，包含了所有 Go 编译器在 SSA 阶段为 MIPS 架构定义的控制流块类型。

**4. 定义 MIPS 架构的整体信息:**

   - `arch` 结构体汇总了特定架构的所有相关信息。
     - `name`: 架构名称 "MIPS"。
     - `pkg`: 架构相关的包路径 "cmd/internal/obj/mips"。
     - `genfile`: 生成文件的路径 "../../mips/ssa.go"。
     - `ops`: 上面定义的 `ops` 切片。
     - `blocks`: 上面定义的 `blocks` 切片。
     - `regnames`: 上面定义的 `regNamesMIPS` 切片。
     - `gpregmask`: 通用寄存器掩码。
     - `fpregmask`: 浮点寄存器掩码。
     - `specialregmask`: 特殊寄存器掩码 (HI, LO)。
     - `framepointerreg`: 帧指针寄存器，MIPS 中未使用，所以是 -1。
     - `linkreg`: 链接寄存器 "R31"。
   - `archs` 变量是一个包含单个 `arch` 结构体的切片，用于注册 MIPS 架构的信息。

**该文件实现的功能是为 Go 编译器提供 MIPS 架构的特定信息，以便在编译过程中将 Go 代码转换为适合 MIPS 处理器的机器码。**  SSA 是一种中间表示形式，编译器会将 Go 的抽象语法树转换为 SSA，然后在 SSA 上进行各种优化，最后将 SSA 转换为目标架构的机器码。  这个文件定义了 SSA 转换到 MIPS 机器码的“词汇表”和“语法规则”。

**Go 代码举例说明 (推理):**

虽然这个文件本身不是直接的 Go 功能实现，但它描述了 Go 代码在 MIPS 架构上的底层表示。 例如，考虑一个简单的 Go 加法操作：

```go
package main

func main() {
	a := 10
	b := 20
	c := a + b
	println(c)
}
```

在 SSA 中，这个加法操作 `a + b` 可能会被表示为一个 `ADD` 操作，对应于 `MIPSOps.go` 中的：

```go
{name: "ADD", argLength: 2, reg: gp21, asm: "ADDU", commutative: true},
```

**假设的 SSA 输入和输出:**

**输入 (SSA 表示的一部分):**

```
v1 = ConstI32 <int32> 10  // 将常量 10 加载到虚拟寄存器 v1
v2 = ConstI32 <int32> 20  // 将常量 20 加载到虚拟寄存器 v2
v3 = ADD <int32> v1 v2    // 执行加法操作，结果存储到虚拟寄存器 v3
```

**输出 (可能的 MIPS 汇编指令):**

假设 `v1` 分配到 `R1`，`v2` 分配到 `R2`，`v3` 分配到 `R3`，则 `ADD` 操作会被翻译成：

```assembly
ADDU R3, R1, R2  // R3 = R1 + R2
```

这里的 `ADDU` 就对应了 `MIPSOps.go` 中 `ADD` 操作的 `asm` 字段。 `gp21` `regInfo` 指示了该操作需要两个通用寄存器作为输入，并产生一个通用寄存器作为输出。

**命令行参数的具体处理:**

这个文件本身不处理命令行参数。 命令行参数的处理发生在 Go 编译器的其他阶段，例如在解析命令行标志并确定目标架构时。  当使用 `go build` 命令并指定目标架构为 MIPS 时 (例如 `GOARCH=mips go build main.go`)，编译器会加载 `MIPSOps.go` 中定义的 MIPS 架构信息，以便生成相应的机器码。

**使用者易犯错的点 (针对编译器开发者):**

这个文件主要供 Go 编译器开发者使用。  如果开发者在修改或扩展此文件时犯错，可能会导致以下问题：

* **寄存器约束错误:**  如果 `regInfo` 配置不正确，例如输入或输出寄存器掩码错误，会导致寄存器分配失败或生成错误的指令。 例如，如果一个需要修改寄存器的操作的 `outputs` 字段没有包含该寄存器，优化器可能会错误地认为该寄存器的值没有被修改。
* **指令名称或汇编指令错误:** `name` 和 `asm` 字段必须正确匹配 MIPS 架构的指令。 拼写错误或指令操作码错误会导致汇编器报错或生成错误的机器码。
* **辅助信息类型错误:**  如果 `aux` 字段的类型与实际使用的辅助信息不符，会导致编译器在处理这些操作时出错。
* **操作属性错误:**  `commutative` 等属性的设置必须正确。 例如，将一个不满足交换律的操作标记为 `commutative` 会导致错误的优化。
* **遗漏或错误的原子操作定义:**  原子操作的定义需要特别小心，确保生成的指令能够正确实现原子性。 `LoweredAtomic*` 开头的操作定义了 MIPS 架构的原子操作实现，如果定义错误，会导致并发程序的竞争条件。

**例子 (假设的错误):**

假设错误地将 `SUB` (减法) 操作标记为 `commutative: true`:

```go
{name: "SUB", argLength: 2, reg: gp21, asm: "SUBU", commutative: true}, // 错误：减法不满足交换律
```

这会导致编译器在优化时，可能会错误地将 `a - b` 替换为 `b - a`，从而产生错误的计算结果。

总而言之，`MIPSOps.go` 是 Go 编译器中一个关键的文件，它为 MIPS 架构定义了 SSA 中间表示的操作和控制流块，是 Go 编译器将 Go 代码转换为 MIPS 机器码的基础。  它的正确性对于生成高效且正确的 MIPS 代码至关重要。

### 提示词
```
这是路径为go/src/cmd/compile/internal/ssa/_gen/MIPSOps.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
```

### 源代码
```go
// Copyright 2016 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import "strings"

// Notes:
//  - Integer types live in the low portion of registers. Upper portions are junk.
//  - Boolean types use the low-order byte of a register. 0=false, 1=true.
//    Upper bytes are junk.
//  - Unused portions of AuxInt are filled by sign-extending the used portion.
//  - *const instructions may use a constant larger than the instruction can encode.
//    In this case the assembler expands to multiple instructions and uses tmp
//    register (R23).

// Suffixes encode the bit width of various instructions.
// W (word)      = 32 bit
// H (half word) = 16 bit
// HU            = 16 bit unsigned
// B (byte)      = 8 bit
// BU            = 8 bit unsigned
// F (float)     = 32 bit float
// D (double)    = 64 bit float

// Note: registers not used in regalloc are not included in this list,
// so that regmask stays within int64
// Be careful when hand coding regmasks.
var regNamesMIPS = []string{
	"R0", // constant 0
	"R1",
	"R2",
	"R3",
	"R4",
	"R5",
	"R6",
	"R7",
	"R8",
	"R9",
	"R10",
	"R11",
	"R12",
	"R13",
	"R14",
	"R15",
	"R16",
	"R17",
	"R18",
	"R19",
	"R20",
	"R21",
	"R22",
	//REGTMP
	"R24",
	"R25",
	// R26 reserved by kernel
	// R27 reserved by kernel
	"R28",
	"SP",  // aka R29
	"g",   // aka R30
	"R31", // REGLINK

	// odd FP registers contain high parts of 64-bit FP values
	"F0",
	"F2",
	"F4",
	"F6",
	"F8",
	"F10",
	"F12",
	"F14",
	"F16",
	"F18",
	"F20",
	"F22",
	"F24",
	"F26",
	"F28",
	"F30",

	"HI", // high bits of multiplication
	"LO", // low bits of multiplication

	// If you add registers, update asyncPreempt in runtime.

	// pseudo-registers
	"SB",
}

func init() {
	// Make map from reg names to reg integers.
	if len(regNamesMIPS) > 64 {
		panic("too many registers")
	}
	num := map[string]int{}
	for i, name := range regNamesMIPS {
		num[name] = i
	}
	buildReg := func(s string) regMask {
		m := regMask(0)
		for _, r := range strings.Split(s, " ") {
			if n, ok := num[r]; ok {
				m |= regMask(1) << uint(n)
				continue
			}
			panic("register " + r + " not found")
		}
		return m
	}

	// Common individual register masks
	var (
		gp         = buildReg("R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 R16 R17 R18 R19 R20 R21 R22 R24 R25 R28 R31")
		gpg        = gp | buildReg("g")
		gpsp       = gp | buildReg("SP")
		gpspg      = gpg | buildReg("SP")
		gpspsbg    = gpspg | buildReg("SB")
		fp         = buildReg("F0 F2 F4 F6 F8 F10 F12 F14 F16 F18 F20 F22 F24 F26 F28 F30")
		lo         = buildReg("LO")
		hi         = buildReg("HI")
		callerSave = gp | fp | lo | hi | buildReg("g") // runtime.setg (and anything calling it) may clobber g
		r1         = buildReg("R1")
		r2         = buildReg("R2")
		r3         = buildReg("R3")
		r4         = buildReg("R4")
		r5         = buildReg("R5")
	)
	// Common regInfo
	var (
		gp01      = regInfo{inputs: nil, outputs: []regMask{gp}}
		gp11      = regInfo{inputs: []regMask{gpg}, outputs: []regMask{gp}}
		gp11sp    = regInfo{inputs: []regMask{gpspg}, outputs: []regMask{gp}}
		gp21      = regInfo{inputs: []regMask{gpg, gpg}, outputs: []regMask{gp}}
		gp31      = regInfo{inputs: []regMask{gp, gp, gp}, outputs: []regMask{gp}}
		gp2hilo   = regInfo{inputs: []regMask{gpg, gpg}, outputs: []regMask{hi, lo}}
		gpload    = regInfo{inputs: []regMask{gpspsbg}, outputs: []regMask{gp}}
		gpstore   = regInfo{inputs: []regMask{gpspsbg, gpg}}
		gpxchg    = regInfo{inputs: []regMask{gpspsbg, gpg}, outputs: []regMask{gp}}
		gpcas     = regInfo{inputs: []regMask{gpspsbg, gpg, gpg}, outputs: []regMask{gp}}
		gpstore0  = regInfo{inputs: []regMask{gpspsbg}}
		fpgp      = regInfo{inputs: []regMask{fp}, outputs: []regMask{gp}}
		gpfp      = regInfo{inputs: []regMask{gp}, outputs: []regMask{fp}}
		fp01      = regInfo{inputs: nil, outputs: []regMask{fp}}
		fp11      = regInfo{inputs: []regMask{fp}, outputs: []regMask{fp}}
		fp21      = regInfo{inputs: []regMask{fp, fp}, outputs: []regMask{fp}}
		fp2flags  = regInfo{inputs: []regMask{fp, fp}}
		fpload    = regInfo{inputs: []regMask{gpspsbg}, outputs: []regMask{fp}}
		fpstore   = regInfo{inputs: []regMask{gpspsbg, fp}}
		readflags = regInfo{inputs: nil, outputs: []regMask{gp}}
	)
	ops := []opData{
		{name: "ADD", argLength: 2, reg: gp21, asm: "ADDU", commutative: true},                                                                           // arg0 + arg1
		{name: "ADDconst", argLength: 1, reg: gp11sp, asm: "ADDU", aux: "Int32"},                                                                         // arg0 + auxInt
		{name: "SUB", argLength: 2, reg: gp21, asm: "SUBU"},                                                                                              // arg0 - arg1
		{name: "SUBconst", argLength: 1, reg: gp11, asm: "SUBU", aux: "Int32"},                                                                           // arg0 - auxInt
		{name: "MUL", argLength: 2, reg: regInfo{inputs: []regMask{gpg, gpg}, outputs: []regMask{gp}, clobbers: hi | lo}, asm: "MUL", commutative: true}, // arg0 * arg1
		{name: "MULT", argLength: 2, reg: gp2hilo, asm: "MUL", commutative: true, typ: "(Int32,Int32)"},                                                  // arg0 * arg1, signed, results hi,lo
		{name: "MULTU", argLength: 2, reg: gp2hilo, asm: "MULU", commutative: true, typ: "(UInt32,UInt32)"},                                              // arg0 * arg1, unsigned, results hi,lo
		{name: "DIV", argLength: 2, reg: gp2hilo, asm: "DIV", typ: "(Int32,Int32)"},                                                                      // arg0 / arg1, signed, results hi=arg0%arg1,lo=arg0/arg1
		{name: "DIVU", argLength: 2, reg: gp2hilo, asm: "DIVU", typ: "(UInt32,UInt32)"},                                                                  // arg0 / arg1, signed, results hi=arg0%arg1,lo=arg0/arg1

		{name: "ADDF", argLength: 2, reg: fp21, asm: "ADDF", commutative: true}, // arg0 + arg1
		{name: "ADDD", argLength: 2, reg: fp21, asm: "ADDD", commutative: true}, // arg0 + arg1
		{name: "SUBF", argLength: 2, reg: fp21, asm: "SUBF"},                    // arg0 - arg1
		{name: "SUBD", argLength: 2, reg: fp21, asm: "SUBD"},                    // arg0 - arg1
		{name: "MULF", argLength: 2, reg: fp21, asm: "MULF", commutative: true}, // arg0 * arg1
		{name: "MULD", argLength: 2, reg: fp21, asm: "MULD", commutative: true}, // arg0 * arg1
		{name: "DIVF", argLength: 2, reg: fp21, asm: "DIVF"},                    // arg0 / arg1
		{name: "DIVD", argLength: 2, reg: fp21, asm: "DIVD"},                    // arg0 / arg1

		{name: "AND", argLength: 2, reg: gp21, asm: "AND", commutative: true},                // arg0 & arg1
		{name: "ANDconst", argLength: 1, reg: gp11, asm: "AND", aux: "Int32"},                // arg0 & auxInt
		{name: "OR", argLength: 2, reg: gp21, asm: "OR", commutative: true},                  // arg0 | arg1
		{name: "ORconst", argLength: 1, reg: gp11, asm: "OR", aux: "Int32"},                  // arg0 | auxInt
		{name: "XOR", argLength: 2, reg: gp21, asm: "XOR", commutative: true, typ: "UInt32"}, // arg0 ^ arg1
		{name: "XORconst", argLength: 1, reg: gp11, asm: "XOR", aux: "Int32", typ: "UInt32"}, // arg0 ^ auxInt
		{name: "NOR", argLength: 2, reg: gp21, asm: "NOR", commutative: true},                // ^(arg0 | arg1)
		{name: "NORconst", argLength: 1, reg: gp11, asm: "NOR", aux: "Int32"},                // ^(arg0 | auxInt)

		{name: "NEG", argLength: 1, reg: gp11},                 // -arg0
		{name: "NEGF", argLength: 1, reg: fp11, asm: "NEGF"},   // -arg0, float32
		{name: "NEGD", argLength: 1, reg: fp11, asm: "NEGD"},   // -arg0, float64
		{name: "ABSD", argLength: 1, reg: fp11, asm: "ABSD"},   // abs(arg0), float64
		{name: "SQRTD", argLength: 1, reg: fp11, asm: "SQRTD"}, // sqrt(arg0), float64
		{name: "SQRTF", argLength: 1, reg: fp11, asm: "SQRTF"}, // sqrt(arg0), float32

		// shifts
		{name: "SLL", argLength: 2, reg: gp21, asm: "SLL"},                    // arg0 << arg1, shift amount is mod 32
		{name: "SLLconst", argLength: 1, reg: gp11, asm: "SLL", aux: "Int32"}, // arg0 << auxInt, shift amount must be 0 through 31 inclusive
		{name: "SRL", argLength: 2, reg: gp21, asm: "SRL"},                    // arg0 >> arg1, unsigned, shift amount is mod 32
		{name: "SRLconst", argLength: 1, reg: gp11, asm: "SRL", aux: "Int32"}, // arg0 >> auxInt, shift amount must be 0 through 31 inclusive
		{name: "SRA", argLength: 2, reg: gp21, asm: "SRA"},                    // arg0 >> arg1, signed, shift amount is mod 32
		{name: "SRAconst", argLength: 1, reg: gp11, asm: "SRA", aux: "Int32"}, // arg0 >> auxInt, signed, shift amount must be 0 through 31 inclusive

		{name: "CLZ", argLength: 1, reg: gp11, asm: "CLZ"},

		// comparisons
		{name: "SGT", argLength: 2, reg: gp21, asm: "SGT", typ: "Bool"},                      // 1 if arg0 > arg1 (signed), 0 otherwise
		{name: "SGTconst", argLength: 1, reg: gp11, asm: "SGT", aux: "Int32", typ: "Bool"},   // 1 if auxInt > arg0 (signed), 0 otherwise
		{name: "SGTzero", argLength: 1, reg: gp11, asm: "SGT", typ: "Bool"},                  // 1 if arg0 > 0 (signed), 0 otherwise
		{name: "SGTU", argLength: 2, reg: gp21, asm: "SGTU", typ: "Bool"},                    // 1 if arg0 > arg1 (unsigned), 0 otherwise
		{name: "SGTUconst", argLength: 1, reg: gp11, asm: "SGTU", aux: "Int32", typ: "Bool"}, // 1 if auxInt > arg0 (unsigned), 0 otherwise
		{name: "SGTUzero", argLength: 1, reg: gp11, asm: "SGTU", typ: "Bool"},                // 1 if arg0 > 0 (unsigned), 0 otherwise

		{name: "CMPEQF", argLength: 2, reg: fp2flags, asm: "CMPEQF", typ: "Flags"}, // flags=true if arg0 = arg1, float32
		{name: "CMPEQD", argLength: 2, reg: fp2flags, asm: "CMPEQD", typ: "Flags"}, // flags=true if arg0 = arg1, float64
		{name: "CMPGEF", argLength: 2, reg: fp2flags, asm: "CMPGEF", typ: "Flags"}, // flags=true if arg0 >= arg1, float32
		{name: "CMPGED", argLength: 2, reg: fp2flags, asm: "CMPGED", typ: "Flags"}, // flags=true if arg0 >= arg1, float64
		{name: "CMPGTF", argLength: 2, reg: fp2flags, asm: "CMPGTF", typ: "Flags"}, // flags=true if arg0 > arg1, float32
		{name: "CMPGTD", argLength: 2, reg: fp2flags, asm: "CMPGTD", typ: "Flags"}, // flags=true if arg0 > arg1, float64

		// moves
		{name: "MOVWconst", argLength: 0, reg: gp01, aux: "Int32", asm: "MOVW", typ: "UInt32", rematerializeable: true},    // auxint
		{name: "MOVFconst", argLength: 0, reg: fp01, aux: "Float32", asm: "MOVF", typ: "Float32", rematerializeable: true}, // auxint as 64-bit float, convert to 32-bit float
		{name: "MOVDconst", argLength: 0, reg: fp01, aux: "Float64", asm: "MOVD", typ: "Float64", rematerializeable: true}, // auxint as 64-bit float

		{name: "MOVWaddr", argLength: 1, reg: regInfo{inputs: []regMask{buildReg("SP") | buildReg("SB")}, outputs: []regMask{gp}}, aux: "SymOff", asm: "MOVW", rematerializeable: true, symEffect: "Addr"}, // arg0 + auxInt + aux.(*gc.Sym), arg0=SP/SB

		{name: "MOVBload", argLength: 2, reg: gpload, aux: "SymOff", asm: "MOVB", typ: "Int8", faultOnNilArg0: true, symEffect: "Read"},     // load from arg0 + auxInt + aux.  arg1=mem.
		{name: "MOVBUload", argLength: 2, reg: gpload, aux: "SymOff", asm: "MOVBU", typ: "UInt8", faultOnNilArg0: true, symEffect: "Read"},  // load from arg0 + auxInt + aux.  arg1=mem.
		{name: "MOVHload", argLength: 2, reg: gpload, aux: "SymOff", asm: "MOVH", typ: "Int16", faultOnNilArg0: true, symEffect: "Read"},    // load from arg0 + auxInt + aux.  arg1=mem.
		{name: "MOVHUload", argLength: 2, reg: gpload, aux: "SymOff", asm: "MOVHU", typ: "UInt16", faultOnNilArg0: true, symEffect: "Read"}, // load from arg0 + auxInt + aux.  arg1=mem.
		{name: "MOVWload", argLength: 2, reg: gpload, aux: "SymOff", asm: "MOVW", typ: "UInt32", faultOnNilArg0: true, symEffect: "Read"},   // load from arg0 + auxInt + aux.  arg1=mem.
		{name: "MOVFload", argLength: 2, reg: fpload, aux: "SymOff", asm: "MOVF", typ: "Float32", faultOnNilArg0: true, symEffect: "Read"},  // load from arg0 + auxInt + aux.  arg1=mem.
		{name: "MOVDload", argLength: 2, reg: fpload, aux: "SymOff", asm: "MOVD", typ: "Float64", faultOnNilArg0: true, symEffect: "Read"},  // load from arg0 + auxInt + aux.  arg1=mem.

		{name: "MOVBstore", argLength: 3, reg: gpstore, aux: "SymOff", asm: "MOVB", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"}, // store 1 byte of arg1 to arg0 + auxInt + aux.  arg2=mem.
		{name: "MOVHstore", argLength: 3, reg: gpstore, aux: "SymOff", asm: "MOVH", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"}, // store 2 bytes of arg1 to arg0 + auxInt + aux.  arg2=mem.
		{name: "MOVWstore", argLength: 3, reg: gpstore, aux: "SymOff", asm: "MOVW", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"}, // store 4 bytes of arg1 to arg0 + auxInt + aux.  arg2=mem.
		{name: "MOVFstore", argLength: 3, reg: fpstore, aux: "SymOff", asm: "MOVF", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"}, // store 4 bytes of arg1 to arg0 + auxInt + aux.  arg2=mem.
		{name: "MOVDstore", argLength: 3, reg: fpstore, aux: "SymOff", asm: "MOVD", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"}, // store 8 bytes of arg1 to arg0 + auxInt + aux.  arg2=mem.

		{name: "MOVBstorezero", argLength: 2, reg: gpstore0, aux: "SymOff", asm: "MOVB", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"}, // store 1 byte of zero to arg0 + auxInt + aux.  arg1=mem.
		{name: "MOVHstorezero", argLength: 2, reg: gpstore0, aux: "SymOff", asm: "MOVH", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"}, // store 2 bytes of zero to arg0 + auxInt + aux.  arg1=mem.
		{name: "MOVWstorezero", argLength: 2, reg: gpstore0, aux: "SymOff", asm: "MOVW", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"}, // store 4 bytes of zero to arg0 + auxInt + aux.  arg1=mem.

		// moves (no conversion)
		{name: "MOVWfpgp", argLength: 1, reg: fpgp, asm: "MOVW"}, // move float32 to int32 (no conversion)
		{name: "MOVWgpfp", argLength: 1, reg: gpfp, asm: "MOVW"}, // move int32 to float32 (no conversion)

		// conversions
		{name: "MOVBreg", argLength: 1, reg: gp11, asm: "MOVB"},   // move from arg0, sign-extended from byte
		{name: "MOVBUreg", argLength: 1, reg: gp11, asm: "MOVBU"}, // move from arg0, unsign-extended from byte
		{name: "MOVHreg", argLength: 1, reg: gp11, asm: "MOVH"},   // move from arg0, sign-extended from half
		{name: "MOVHUreg", argLength: 1, reg: gp11, asm: "MOVHU"}, // move from arg0, unsign-extended from half
		{name: "MOVWreg", argLength: 1, reg: gp11, asm: "MOVW"},   // move from arg0

		{name: "MOVWnop", argLength: 1, reg: regInfo{inputs: []regMask{gp}, outputs: []regMask{gp}}, resultInArg0: true}, // nop, return arg0 in same register

		// conditional move on zero (returns arg1 if arg2 is 0, otherwise arg0)
		// order of parameters is reversed so we can use resultInArg0 (OpCMOVZ result arg1 arg2-> CMOVZ arg2reg, arg1reg, resultReg)
		{name: "CMOVZ", argLength: 3, reg: gp31, asm: "CMOVZ", resultInArg0: true},
		{name: "CMOVZzero", argLength: 2, reg: regInfo{inputs: []regMask{gp, gpg}, outputs: []regMask{gp}}, asm: "CMOVZ", resultInArg0: true},

		{name: "MOVWF", argLength: 1, reg: fp11, asm: "MOVWF"},     // int32 -> float32
		{name: "MOVWD", argLength: 1, reg: fp11, asm: "MOVWD"},     // int32 -> float64
		{name: "TRUNCFW", argLength: 1, reg: fp11, asm: "TRUNCFW"}, // float32 -> int32
		{name: "TRUNCDW", argLength: 1, reg: fp11, asm: "TRUNCDW"}, // float64 -> int32
		{name: "MOVFD", argLength: 1, reg: fp11, asm: "MOVFD"},     // float32 -> float64
		{name: "MOVDF", argLength: 1, reg: fp11, asm: "MOVDF"},     // float64 -> float32

		// function calls
		{name: "CALLstatic", argLength: 1, reg: regInfo{clobbers: callerSave}, aux: "CallOff", clobberFlags: true, call: true},                                               // call static function aux.(*obj.LSym).  arg0=mem, auxint=argsize, returns mem
		{name: "CALLtail", argLength: 1, reg: regInfo{clobbers: callerSave}, aux: "CallOff", clobberFlags: true, call: true, tailCall: true},                                 //  tail call static function aux.(*obj.LSym).  arg0=mem, auxint=argsize, returns mem
		{name: "CALLclosure", argLength: 3, reg: regInfo{inputs: []regMask{gpsp, buildReg("R22"), 0}, clobbers: callerSave}, aux: "CallOff", clobberFlags: true, call: true}, // call function via closure.  arg0=codeptr, arg1=closure, arg2=mem, auxint=argsize, returns mem
		{name: "CALLinter", argLength: 2, reg: regInfo{inputs: []regMask{gp}, clobbers: callerSave}, aux: "CallOff", clobberFlags: true, call: true},                         // call fn by pointer.  arg0=codeptr, arg1=mem, auxint=argsize, returns mem

		// atomic ops

		// load from arg0. arg1=mem.
		// returns <value,memory> so they can be properly ordered with other loads.
		// SYNC
		// MOV(B|W)	(Rarg0), Rout
		// SYNC
		{name: "LoweredAtomicLoad8", argLength: 2, reg: gpload, faultOnNilArg0: true},
		{name: "LoweredAtomicLoad32", argLength: 2, reg: gpload, faultOnNilArg0: true},

		// store arg1 to arg0. arg2=mem. returns memory.
		// SYNC
		// MOV(B|W)	Rarg1, (Rarg0)
		// SYNC
		{name: "LoweredAtomicStore8", argLength: 3, reg: gpstore, faultOnNilArg0: true, hasSideEffects: true},
		{name: "LoweredAtomicStore32", argLength: 3, reg: gpstore, faultOnNilArg0: true, hasSideEffects: true},
		{name: "LoweredAtomicStorezero", argLength: 2, reg: gpstore0, faultOnNilArg0: true, hasSideEffects: true},

		// atomic exchange.
		// store arg1 to arg0. arg2=mem. returns <old content of *arg0, memory>.
		// SYNC
		// LL	(Rarg0), Rout
		// MOVW Rarg1, Rtmp
		// SC	Rtmp, (Rarg0)
		// BEQ	Rtmp, -3(PC)
		// SYNC
		{name: "LoweredAtomicExchange", argLength: 3, reg: gpxchg, resultNotInArgs: true, faultOnNilArg0: true, hasSideEffects: true, unsafePoint: true},

		// atomic add.
		// *arg0 += arg1. arg2=mem. returns <new content of *arg0, memory>.
		// SYNC
		// LL	(Rarg0), Rout
		// ADDU Rarg1, Rout, Rtmp
		// SC	Rtmp, (Rarg0)
		// BEQ	Rtmp, -3(PC)
		// SYNC
		// ADDU Rarg1, Rout
		{name: "LoweredAtomicAdd", argLength: 3, reg: gpxchg, resultNotInArgs: true, faultOnNilArg0: true, hasSideEffects: true, unsafePoint: true},
		{name: "LoweredAtomicAddconst", argLength: 2, reg: regInfo{inputs: []regMask{gpspsbg}, outputs: []regMask{gp}}, aux: "Int32", resultNotInArgs: true, faultOnNilArg0: true, hasSideEffects: true, unsafePoint: true},

		// atomic compare and swap.
		// arg0 = pointer, arg1 = old value, arg2 = new value, arg3 = memory.
		// if *arg0 == arg1 {
		//   *arg0 = arg2
		//   return (true, memory)
		// } else {
		//   return (false, memory)
		// }
		// SYNC
		// MOVW $0, Rout
		// LL	(Rarg0), Rtmp
		// BNE	Rtmp, Rarg1, 4(PC)
		// MOVW Rarg2, Rout
		// SC	Rout, (Rarg0)
		// BEQ	Rout, -4(PC)
		// SYNC
		{name: "LoweredAtomicCas", argLength: 4, reg: gpcas, resultNotInArgs: true, faultOnNilArg0: true, hasSideEffects: true, unsafePoint: true},

		// atomic and/or.
		// *arg0 &= (|=) arg1. arg2=mem. returns memory.
		// SYNC
		// LL	(Rarg0), Rtmp
		// AND	Rarg1, Rtmp
		// SC	Rtmp, (Rarg0)
		// BEQ	Rtmp, -3(PC)
		// SYNC
		{name: "LoweredAtomicAnd", argLength: 3, reg: gpstore, asm: "AND", faultOnNilArg0: true, hasSideEffects: true, unsafePoint: true},
		{name: "LoweredAtomicOr", argLength: 3, reg: gpstore, asm: "OR", faultOnNilArg0: true, hasSideEffects: true, unsafePoint: true},

		// large or unaligned zeroing
		// arg0 = address of memory to zero (in R1, changed as side effect)
		// arg1 = address of the last element to zero
		// arg2 = mem
		// auxint = alignment
		// returns mem
		//	SUBU	$4, R1
		//	MOVW	R0, 4(R1)
		//	ADDU	$4, R1
		//	BNE	Rarg1, R1, -2(PC)
		{
			name:      "LoweredZero",
			aux:       "Int32",
			argLength: 3,
			reg: regInfo{
				inputs:   []regMask{buildReg("R1"), gp},
				clobbers: buildReg("R1"),
			},
			faultOnNilArg0: true,
		},

		// large or unaligned move
		// arg0 = address of dst memory (in R2, changed as side effect)
		// arg1 = address of src memory (in R1, changed as side effect)
		// arg2 = address of the last element of src
		// arg3 = mem
		// auxint = alignment
		// returns mem
		//	SUBU	$4, R1
		//	MOVW	4(R1), Rtmp
		//	MOVW	Rtmp, (R2)
		//	ADDU	$4, R1
		//	ADDU	$4, R2
		//	BNE	Rarg2, R1, -4(PC)
		{
			name:      "LoweredMove",
			aux:       "Int32",
			argLength: 4,
			reg: regInfo{
				inputs:   []regMask{buildReg("R2"), buildReg("R1"), gp},
				clobbers: buildReg("R1 R2"),
			},
			faultOnNilArg0: true,
			faultOnNilArg1: true,
		},

		// pseudo-ops
		{name: "LoweredNilCheck", argLength: 2, reg: regInfo{inputs: []regMask{gpg}}, nilCheck: true, faultOnNilArg0: true}, // panic if arg0 is nil.  arg1=mem.

		{name: "FPFlagTrue", argLength: 1, reg: readflags},  // bool, true if FP flag is true
		{name: "FPFlagFalse", argLength: 1, reg: readflags}, // bool, true if FP flag is false

		// Scheduler ensures LoweredGetClosurePtr occurs only in entry block,
		// and sorts it to the very beginning of the block to prevent other
		// use of R22 (mips.REGCTXT, the closure pointer)
		{name: "LoweredGetClosurePtr", reg: regInfo{outputs: []regMask{buildReg("R22")}}, zeroWidth: true},

		// LoweredGetCallerSP returns the SP of the caller of the current function. arg0=mem.
		{name: "LoweredGetCallerSP", argLength: 1, reg: gp01, rematerializeable: true},

		// LoweredGetCallerPC evaluates to the PC to which its "caller" will return.
		// I.e., if f calls g "calls" sys.GetCallerPC,
		// the result should be the PC within f that g will return to.
		// See runtime/stubs.go for a more detailed discussion.
		{name: "LoweredGetCallerPC", reg: gp01, rematerializeable: true},

		// LoweredWB invokes runtime.gcWriteBarrier. arg0=mem, auxint=# of buffer entries needed
		// It saves all GP registers if necessary,
		// but clobbers R31 (LR) because it's a call
		// and R23 (REGTMP).
		// Returns a pointer to a write barrier buffer in R25.
		{name: "LoweredWB", argLength: 1, reg: regInfo{clobbers: (callerSave &^ gpg) | buildReg("R31"), outputs: []regMask{buildReg("R25")}}, clobberFlags: true, aux: "Int64"},

		// There are three of these functions so that they can have three different register inputs.
		// When we check 0 <= c <= cap (A), then 0 <= b <= c (B), then 0 <= a <= b (C), we want the
		// default registers to match so we don't need to copy registers around unnecessarily.
		{name: "LoweredPanicBoundsA", argLength: 3, aux: "Int64", reg: regInfo{inputs: []regMask{r3, r4}}, typ: "Mem", call: true}, // arg0=idx, arg1=len, arg2=mem, returns memory. AuxInt contains report code (see PanicBounds in genericOps.go).
		{name: "LoweredPanicBoundsB", argLength: 3, aux: "Int64", reg: regInfo{inputs: []regMask{r2, r3}}, typ: "Mem", call: true}, // arg0=idx, arg1=len, arg2=mem, returns memory. AuxInt contains report code (see PanicBounds in genericOps.go).
		{name: "LoweredPanicBoundsC", argLength: 3, aux: "Int64", reg: regInfo{inputs: []regMask{r1, r2}}, typ: "Mem", call: true}, // arg0=idx, arg1=len, arg2=mem, returns memory. AuxInt contains report code (see PanicBounds in genericOps.go).
		// Extend ops are the same as Bounds ops except the indexes are 64-bit.
		{name: "LoweredPanicExtendA", argLength: 4, aux: "Int64", reg: regInfo{inputs: []regMask{r5, r3, r4}}, typ: "Mem", call: true}, // arg0=idxHi, arg1=idxLo, arg2=len, arg3=mem, returns memory. AuxInt contains report code (see PanicExtend in genericOps.go).
		{name: "LoweredPanicExtendB", argLength: 4, aux: "Int64", reg: regInfo{inputs: []regMask{r5, r2, r3}}, typ: "Mem", call: true}, // arg0=idxHi, arg1=idxLo, arg2=len, arg3=mem, returns memory. AuxInt contains report code (see PanicExtend in genericOps.go).
		{name: "LoweredPanicExtendC", argLength: 4, aux: "Int64", reg: regInfo{inputs: []regMask{r5, r1, r2}}, typ: "Mem", call: true}, // arg0=idxHi, arg1=idxLo, arg2=len, arg3=mem, returns memory. AuxInt contains report code (see PanicExtend in genericOps.go).
	}

	blocks := []blockData{
		{name: "EQ", controls: 1},
		{name: "NE", controls: 1},
		{name: "LTZ", controls: 1}, // < 0
		{name: "LEZ", controls: 1}, // <= 0
		{name: "GTZ", controls: 1}, // > 0
		{name: "GEZ", controls: 1}, // >= 0
		{name: "FPT", controls: 1}, // FP flag is true
		{name: "FPF", controls: 1}, // FP flag is false
	}

	archs = append(archs, arch{
		name:            "MIPS",
		pkg:             "cmd/internal/obj/mips",
		genfile:         "../../mips/ssa.go",
		ops:             ops,
		blocks:          blocks,
		regnames:        regNamesMIPS,
		gpregmask:       gp,
		fpregmask:       fp,
		specialregmask:  hi | lo,
		framepointerreg: -1, // not used
		linkreg:         int8(num["R31"]),
	})
}
```
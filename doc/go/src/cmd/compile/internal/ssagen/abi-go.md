Response: Let's break down the thought process for analyzing this Go code snippet.

1. **Understand the Context:** The first thing I noticed is the package path: `go/src/cmd/compile/internal/ssagen`. This immediately tells me this code is part of the Go compiler, specifically dealing with the "ssa generation" phase. The `abi.go` filename hints that it's about Application Binary Interfaces.

2. **High-Level Goal:** I scan the code for prominent data structures and function names. The `SymABIs` struct and its methods like `ReadSymABIs` and `GenABIWrappers` stand out. This suggests the code's main purpose is to handle ABI information for symbols (functions, variables, etc.).

3. **Dissect `SymABIs`:**
    * The `defs` map seems to store the *defined* ABI for a symbol (the ABI it's implemented with).
    * The `refs` map appears to store the ABIs that a symbol is *referenced* with.
    * `canonicalize` is a helper function to normalize symbol names. This is important in the compiler context where symbols can have different representations.

4. **Analyze `ReadSymABIs`:** This function reads a file. The file format is described in comments. It parses lines with "def" and "ref" verbs, extracting the symbol name and ABI. This confirms the purpose of `SymABIs`: managing ABI definitions and references. The file likely comes from the assembler, providing information that the compiler needs.

5. **Investigate `GenABIWrappers`:** This is the core function. It iterates through the functions being compiled (`typecheck.Target.Funcs`). For each function, it:
    * Checks for defined ABIs from the `s.defs` map.
    * Handles `cgo_export` pragmas, which are directives for C interoperation. The code seems to be adding ABI information to these pragmas.
    * Checks for referenced ABIs from `s.refs`.
    * Makes decisions about whether to generate ABI wrappers based on linknames and whether the function is being exported to C via cgo.
    * Calls `forEachWrapperABI` and `makeABIWrapper`.

6. **Examine `forEachWrapperABI` and `makeABIWrapper`:** These functions are responsible for actually creating the ABI wrappers.
    * `forEachWrapperABI` determines which ABIs need wrappers.
    * `makeABIWrapper` creates a new function. The key is understanding *why* wrappers are needed: to bridge the gap when a function is called with a different ABI than its definition. The generated wrapper adapts the calling convention. The code includes details like setting the ABI, marking it as an ABI wrapper, and handling tail calls.

7. **Look for WASM Specifics:**  The functions `CreateWasmImportWrapper`, `GenWasmExportWrapper`, `setupWasmImport`, `setupWasmExport`, `paramsToWasmFields`, `resultsToWasmFields`, and `wasmElemTypeAllowed` clearly deal with WebAssembly. They manage how Go functions interact with WASM modules, both for imports and exports. They seem to involve converting Go types to WASM types and handling the differences in calling conventions.

8. **Identify Key Concepts:** Based on the above analysis, the key concepts involved are:
    * **ABIs (Application Binary Interfaces):**  How functions are called (parameter passing, return values, etc.).
    * **Symbol Definitions and References:** Where a symbol is implemented and where it's used.
    * **ABI Wrappers:**  Functions generated by the compiler to adapt between different ABIs.
    * **Cgo:**  Go's mechanism for interoperating with C code.
    * **WASM (WebAssembly):**  A binary instruction format for a stack-based virtual machine.
    * **Linknames:**  A mechanism to give a Go symbol a different name at the linker level.
    * **Pragmas:** Compiler directives that provide extra information.

9. **Formulate the Summary:** Now I can organize my findings into a coherent summary, covering the functionalities: reading ABI information, applying it to functions, generating ABI wrappers, and handling WASM imports/exports.

10. **Create Examples:** The next step is to illustrate the functionality with Go code examples. For ABI wrappers, I'd show a function defined with one ABI and called with another. For WASM, I'd demonstrate the use of `//go:wasmimport` and `//go:wasmexport`.

11. **Identify Command-Line Arguments and Error Points:** I'd scan the code for uses of `base.Flag` or similar constructs to identify relevant command-line flags. For potential errors, I'd look for `log.Fatalf` or `base.Errorf` calls and think about the conditions that might trigger them. For instance, inconsistent ABI definitions, unsupported WASM types, or incorrect usage of cgo pragmas.

12. **Refine and Structure:**  Finally, I'd organize the information clearly, using headings, bullet points, and code blocks to make it easy to understand. I'd double-check the accuracy and completeness of my analysis.

This systematic approach, starting with understanding the context and gradually dissecting the code, helps in comprehending complex compiler code like this. The key is to look for patterns, identify the core data structures and functions, and understand the problem the code is trying to solve.
这段 `abi.go` 文件是 Go 编译器 (`cmd/compile`) 中 `ssagen` (SSA generation) 包的一部分，它的主要功能是处理与函数调用约定（Application Binary Interface, ABI）相关的事务，并负责生成必要的 ABI 适配器（wrapper）函数。

以下是它的功能列表：

1. **读取和解析符号的 ABI 信息:**
   - `ReadSymABIs` 函数负责读取一个指定的文件（通常由汇编器生成），该文件包含了关于符号（函数等）的 ABI 定义和引用信息。
   - 文件格式是每行一个记录，指定了符号名及其使用的 ABI。
   - 这些信息存储在 `SymABIs` 结构体的 `defs` (定义 ABI) 和 `refs` (引用 ABI) 两个 map 中。

2. **应用 ABI 信息到函数:**
   - `GenABIWrappers` 函数遍历当前编译单元中的所有函数 (`typecheck.Target.Funcs`)。
   - 它根据 `SymABIs` 中读取的信息，为每个函数设置其定义的 ABI (`fn.ABI`) 和引用的 ABI 集合 (`fn.ABIRefs`)。

3. **生成 ABI 适配器函数:**
   - 当一个函数被以不同于其定义 ABI 的方式调用时，就需要一个适配器函数来进行转换。
   - `GenABIWrappers` 会检查函数的 `ABIRefs`，如果存在与 `fn.ABI` 不同的引用 ABI，并且启用了 `regabiwrappers` 实验性特性，则会生成适配器函数。
   - `makeABIWrapper` 函数负责创建这个适配器函数。它会创建一个新的函数，该函数使用调用者的 ABI (`wrapperABI`)，并在其内部调用原始函数 `f`，确保参数和返回值的传递符合 `f` 的定义 ABI。

4. **处理 Cgo 导出:**
   - `GenABIWrappers` 还会处理通过 Cgo 导出的 Go 函数。
   - 对于标记为 `//go:cgo_export_static` 或 `//go:cgo_export_dynamic` 的函数，编译器会确保链接器导出正确的 ABI 定义，并且通常不会生成额外的 ABI 适配器。

5. **处理 WebAssembly (Wasm) 导入和导出:**
   - `CreateWasmImportWrapper` 函数为导入的 WebAssembly 函数生成适配器，以适应 Go 的调用约定。这些适配器的具体实现是在 `cmd/internal/obj/wasm/wasmobj.go` 中生成的。
   - `GenWasmExportWrapper` 函数为导出的 Go 函数生成适配器，使其能够被 WebAssembly 调用。这涉及到参数和返回值的转换，以匹配 WebAssembly 的类型系统。
   - `setupWasmImport` 和 `setupWasmExport` 函数负责设置 Wasm 导入和导出所需的元数据，包括参数和返回值的类型信息。
   - `paramsToWasmFields` 和 `resultsToWasmFields` 函数将 Go 函数的参数和返回值转换为 WebAssembly 的字段表示。
   - `wasmElemTypeAllowed` 函数判断某些 Go 类型是否允许在 Go Wasm 模块和宿主环境之间传递。

**推断的 Go 语言功能实现：函数调用和跨 ABI 调用**

这段代码的核心是为了支持在 Go 程序中，函数能够以多种不同的调用约定被调用。这在以下场景中尤为重要：

- **与汇编代码交互:** 汇编代码可能使用特定的 ABI，而 Go 代码可能使用不同的 ABI。
- **Cgo:** 与 C 代码进行互操作时，需要遵循 C 的调用约定。
- **WebAssembly:** 与 WebAssembly 模块进行交互时，需要进行 ABI 的转换。
- **未来 Go 版本的 ABI 演进:**  允许在不同的编译单元中使用不同的 ABI，并通过适配器进行桥接。

**Go 代码示例：ABI 适配器**

假设我们有一个使用 `ABI0` 定义的函数，但需要在某个地方以 `ABIInternal` 的方式调用它（`ABIInternal` 是 Go 内部优化的调用约定，通常涉及寄存器传递参数）。

```go
package main

//go:noinline // 避免内联，更容易观察 ABI 适配器
//go:linkname definedWithABI0 definedWithABI0
func definedWithABI0(a int) int {
	return a + 1
}

//go:noinline
func callWithABIInternal(f func(int) int, x int) int {
	return f(x)
}

func main() {
	result := callWithABIInternal(definedWithABI0, 10)
	println(result) // 输出: 11
}
```

**假设的输入与输出：**

在这个例子中，`definedWithABI0` 函数被假定定义时使用了 `ABI0`。当我们调用 `callWithABIInternal(definedWithABI0, 10)` 时，`callWithABIInternal` 内部是以 `ABIInternal` 的方式调用传递进来的函数 `f`。

编译器在编译时，会检测到 `definedWithABI0` 的定义 ABI (`ABI0`) 与 `callWithABIInternal` 调用它的 ABI (`ABIInternal`) 不匹配。因此，编译器会生成一个 ABI 适配器函数。

- **输入（编译时信息）：**
    - `definedWithABI0` 的定义 ABI: `ABI0`
    - `callWithABIInternal` 中对 `f` 的调用上下文的 ABI: `ABIInternal`
    - `definedWithABI0` 作为参数传递给 `callWithABIInternal`。

- **输出（生成的代码）：**
    - 一个名为类似 `ABIInternal_definedWithABI0` 的适配器函数会被生成。
    - 这个适配器函数会按照 `ABIInternal` 的约定接收参数，然后按照 `ABI0` 的约定调用 `definedWithABI0`。

**Go 代码示例：Wasm 导入和导出**

```go
//go:build wasm
// +build wasm

package main

import "syscall/js"

//go:wasmimport env logStr
func logStr(sp int32)

//go:wasmexport add
func add(a, b int) int {
	return a + b
}

func main() {
	// 调用导入的 Wasm 函数 (假设宿主环境提供了 logStr)
	s := "Hello from Go/Wasm!"
	// 模拟将字符串传递给 Wasm (实际需要更复杂的内存操作)
	ptr := js.ValueOf(s) // 这里只是示意，实际操作会更复杂
	logStr(int32(ptr.Int()))

	// 导出的 add 函数可以被 Wasm 宿主环境调用
	println("Go Wasm module started")
}
```

在这个 Wasm 的例子中：

- `//go:wasmimport env logStr` 声明了从名为 "env" 的 Wasm 模块导入的名为 "logStr" 的函数。`abi.go` 中的 `CreateWasmImportWrapper` 会为此生成适配器。
- `//go:wasmexport add` 声明了要导出到 Wasm 宿主环境的名为 "add" 的函数。`abi.go` 中的 `GenWasmExportWrapper` 会为此生成适配器。

**命令行参数的具体处理:**

这段代码本身没有直接处理命令行参数。它依赖于编译器在更早阶段解析的命令行参数。然而，与 ABI 相关的编译选项可能影响此代码的行为，例如：

- **`-symabis <file>`:**  这个标志指定了包含符号 ABI 信息的文件，`ReadSymABIs` 函数会读取这个文件。
- **实验性标志:** 可能存在与 ABI 相关的实验性标志，例如控制是否生成 ABI 适配器。  在代码中可以看到对 `buildcfg.Experiment.RegabiWrappers` 的检查，这表明 `regabiwrappers` 可能是一个这样的实验性标志。

**使用者易犯错的点 (主要针对高级用户或编译器开发者):**

1. **`symabis` 文件格式错误:** 如果传递给 `-symabis` 的文件格式不正确，`ReadSymABIs` 会报错并终止编译。例如，行中缺少必要的字段，或者 ABI 名称拼写错误。

   ```
   # 错误的 symabis 文件内容
   def myFunc  // 缺少 ABI
   ref otherFunc ABIInternal invalid field // 字段过多
   def anotherFunc INVALID_ABI // 无效的 ABI 名称
   ```

   **错误示例输出：**
   ```
   -symabis: symabis_file:1: invalid symabi: syntax is "def sym abi"
   -symabis: symabis_file:2: invalid symabi: syntax is "ref sym abi"
   -symabis: symabis_file:3: invalid symabi: unknown abi "INVALID_ABI"
   ```

2. **ABI 定义与实际使用不一致:** 如果 `symabis` 文件中定义的 ABI 与函数实际的实现或调用方式不匹配，可能导致运行时错误或未定义的行为。这通常发生在手动编写汇编代码并提供 ABI 信息时。

3. **Wasm 导入/导出类型不兼容:** 在使用 `//go:wasmimport` 和 `//go:wasmexport` 时，如果 Go 函数的参数和返回值类型无法直接映射到 WebAssembly 的类型，编译器会报错。`wasmElemTypeAllowed` 函数定义了允许的类型。

   ```go
   //go:build wasm
   // +build wasm

   package main

   // 错误示例：Go 的 slice 无法直接映射到 Wasm
   //go:wasmimport env processData
   func processData(data []byte) // 编译错误
   ```

   **错误示例输出 (编译时)：**
   ```
   abi_test.go:7: wasmimport: unsupported parameter type []uint8
   ```

总而言之，`abi.go` 是 Go 编译器中一个至关重要的组件，它处理了函数调用的底层细节，确保了不同代码模块（Go、汇编、C、Wasm）之间的正确互操作。理解它的功能有助于深入了解 Go 语言的编译过程和运行时机制。

### 提示词
```
这是路径为go/src/cmd/compile/internal/ssagen/abi.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
```

### 源代码
```go
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package ssagen

import (
	"fmt"
	"internal/buildcfg"
	"log"
	"os"
	"strings"

	"cmd/compile/internal/abi"
	"cmd/compile/internal/base"
	"cmd/compile/internal/ir"
	"cmd/compile/internal/objw"
	"cmd/compile/internal/typecheck"
	"cmd/compile/internal/types"
	"cmd/internal/obj"
	"cmd/internal/obj/wasm"

	rtabi "internal/abi"
)

// SymABIs records information provided by the assembler about symbol
// definition ABIs and reference ABIs.
type SymABIs struct {
	defs map[string]obj.ABI
	refs map[string]obj.ABISet
}

func NewSymABIs() *SymABIs {
	return &SymABIs{
		defs: make(map[string]obj.ABI),
		refs: make(map[string]obj.ABISet),
	}
}

// canonicalize returns the canonical name used for a linker symbol in
// s's maps. Symbols in this package may be written either as "".X or
// with the package's import path already in the symbol. This rewrites
// both to use the full path, which matches compiler-generated linker
// symbol names.
func (s *SymABIs) canonicalize(linksym string) string {
	if strings.HasPrefix(linksym, `"".`) {
		panic("non-canonical symbol name: " + linksym)
	}
	return linksym
}

// ReadSymABIs reads a symabis file that specifies definitions and
// references of text symbols by ABI.
//
// The symabis format is a set of lines, where each line is a sequence
// of whitespace-separated fields. The first field is a verb and is
// either "def" for defining a symbol ABI or "ref" for referencing a
// symbol using an ABI. For both "def" and "ref", the second field is
// the symbol name and the third field is the ABI name, as one of the
// named cmd/internal/obj.ABI constants.
func (s *SymABIs) ReadSymABIs(file string) {
	data, err := os.ReadFile(file)
	if err != nil {
		log.Fatalf("-symabis: %v", err)
	}

	for lineNum, line := range strings.Split(string(data), "\n") {
		lineNum++ // 1-based
		line = strings.TrimSpace(line)
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}

		parts := strings.Fields(line)
		switch parts[0] {
		case "def", "ref":
			// Parse line.
			if len(parts) != 3 {
				log.Fatalf(`%s:%d: invalid symabi: syntax is "%s sym abi"`, file, lineNum, parts[0])
			}
			sym, abistr := parts[1], parts[2]
			abi, valid := obj.ParseABI(abistr)
			if !valid {
				log.Fatalf(`%s:%d: invalid symabi: unknown abi "%s"`, file, lineNum, abistr)
			}

			sym = s.canonicalize(sym)

			// Record for later.
			if parts[0] == "def" {
				s.defs[sym] = abi
			} else {
				s.refs[sym] |= obj.ABISetOf(abi)
			}
		default:
			log.Fatalf(`%s:%d: invalid symabi type "%s"`, file, lineNum, parts[0])
		}
	}
}

// GenABIWrappers applies ABI information to Funcs and generates ABI
// wrapper functions where necessary.
func (s *SymABIs) GenABIWrappers() {
	// For cgo exported symbols, we tell the linker to export the
	// definition ABI to C. That also means that we don't want to
	// create ABI wrappers even if there's a linkname.
	//
	// TODO(austin): Maybe we want to create the ABI wrappers, but
	// ensure the linker exports the right ABI definition under
	// the unmangled name?
	cgoExports := make(map[string][]*[]string)
	for i, prag := range typecheck.Target.CgoPragmas {
		switch prag[0] {
		case "cgo_export_static", "cgo_export_dynamic":
			symName := s.canonicalize(prag[1])
			pprag := &typecheck.Target.CgoPragmas[i]
			cgoExports[symName] = append(cgoExports[symName], pprag)
		}
	}

	// Apply ABI defs and refs to Funcs and generate wrappers.
	//
	// This may generate new decls for the wrappers, but we
	// specifically *don't* want to visit those, lest we create
	// wrappers for wrappers.
	for _, fn := range typecheck.Target.Funcs {
		nam := fn.Nname
		if ir.IsBlank(nam) {
			continue
		}
		sym := nam.Sym()

		symName := sym.Linkname
		if symName == "" {
			symName = sym.Pkg.Prefix + "." + sym.Name
		}
		symName = s.canonicalize(symName)

		// Apply definitions.
		defABI, hasDefABI := s.defs[symName]
		if hasDefABI {
			if len(fn.Body) != 0 {
				base.ErrorfAt(fn.Pos(), 0, "%v defined in both Go and assembly", fn)
			}
			fn.ABI = defABI
		}

		if fn.Pragma&ir.CgoUnsafeArgs != 0 {
			// CgoUnsafeArgs indicates the function (or its callee) uses
			// offsets to dispatch arguments, which currently using ABI0
			// frame layout. Pin it to ABI0.
			fn.ABI = obj.ABI0
			// Propagate linkname attribute, which was set on the ABIInternal
			// symbol.
			if sym.Linksym().IsLinkname() {
				sym.LinksymABI(fn.ABI).Set(obj.AttrLinkname, true)
			}
		}

		// If cgo-exported, add the definition ABI to the cgo
		// pragmas.
		cgoExport := cgoExports[symName]
		for _, pprag := range cgoExport {
			// The export pragmas have the form:
			//
			//   cgo_export_* <local> [<remote>]
			//
			// If <remote> is omitted, it's the same as
			// <local>.
			//
			// Expand to
			//
			//   cgo_export_* <local> <remote> <ABI>
			if len(*pprag) == 2 {
				*pprag = append(*pprag, (*pprag)[1])
			}
			// Add the ABI argument.
			*pprag = append(*pprag, fn.ABI.String())
		}

		// Apply references.
		if abis, ok := s.refs[symName]; ok {
			fn.ABIRefs |= abis
		}
		// Assume all functions are referenced at least as
		// ABIInternal, since they may be referenced from
		// other packages.
		fn.ABIRefs.Set(obj.ABIInternal, true)

		// If a symbol is defined in this package (either in
		// Go or assembly) and given a linkname, it may be
		// referenced from another package, so make it
		// callable via any ABI. It's important that we know
		// it's defined in this package since other packages
		// may "pull" symbols using linkname and we don't want
		// to create duplicate ABI wrappers.
		//
		// However, if it's given a linkname for exporting to
		// C, then we don't make ABI wrappers because the cgo
		// tool wants the original definition.
		hasBody := len(fn.Body) != 0
		if sym.Linkname != "" && (hasBody || hasDefABI) && len(cgoExport) == 0 {
			fn.ABIRefs |= obj.ABISetCallable
		}

		// Double check that cgo-exported symbols don't get
		// any wrappers.
		if len(cgoExport) > 0 && fn.ABIRefs&^obj.ABISetOf(fn.ABI) != 0 {
			base.Fatalf("cgo exported function %v cannot have ABI wrappers", fn)
		}

		if !buildcfg.Experiment.RegabiWrappers {
			continue
		}

		forEachWrapperABI(fn, makeABIWrapper)
	}
}

func forEachWrapperABI(fn *ir.Func, cb func(fn *ir.Func, wrapperABI obj.ABI)) {
	need := fn.ABIRefs &^ obj.ABISetOf(fn.ABI)
	if need == 0 {
		return
	}

	for wrapperABI := obj.ABI(0); wrapperABI < obj.ABICount; wrapperABI++ {
		if !need.Get(wrapperABI) {
			continue
		}
		cb(fn, wrapperABI)
	}
}

// makeABIWrapper creates a new function that will be called with
// wrapperABI and calls "f" using f.ABI.
func makeABIWrapper(f *ir.Func, wrapperABI obj.ABI) {
	if base.Debug.ABIWrap != 0 {
		fmt.Fprintf(os.Stderr, "=-= %v to %v wrapper for %v\n", wrapperABI, f.ABI, f)
	}

	// Q: is this needed?
	savepos := base.Pos
	savedcurfn := ir.CurFunc

	pos := base.AutogeneratedPos
	base.Pos = pos

	// At the moment we don't support wrapping a method, we'd need machinery
	// below to handle the receiver. Panic if we see this scenario.
	ft := f.Nname.Type()
	if ft.NumRecvs() != 0 {
		base.ErrorfAt(f.Pos(), 0, "makeABIWrapper support for wrapping methods not implemented")
		return
	}

	// Reuse f's types.Sym to create a new ODCLFUNC/function.
	// TODO(mdempsky): Means we can't set sym.Def in Declfunc, ugh.
	fn := ir.NewFunc(pos, pos, f.Sym(), types.NewSignature(nil,
		typecheck.NewFuncParams(ft.Params()),
		typecheck.NewFuncParams(ft.Results())))
	fn.ABI = wrapperABI
	typecheck.DeclFunc(fn)

	fn.SetABIWrapper(true)
	fn.SetDupok(true)

	// ABI0-to-ABIInternal wrappers will be mainly loading params from
	// stack into registers (and/or storing stack locations back to
	// registers after the wrapped call); in most cases they won't
	// need to allocate stack space, so it should be OK to mark them
	// as NOSPLIT in these cases. In addition, my assumption is that
	// functions written in assembly are NOSPLIT in most (but not all)
	// cases. In the case of an ABIInternal target that has too many
	// parameters to fit into registers, the wrapper would need to
	// allocate stack space, but this seems like an unlikely scenario.
	// Hence: mark these wrappers NOSPLIT.
	//
	// ABIInternal-to-ABI0 wrappers on the other hand will be taking
	// things in registers and pushing them onto the stack prior to
	// the ABI0 call, meaning that they will always need to allocate
	// stack space. If the compiler marks them as NOSPLIT this seems
	// as though it could lead to situations where the linker's
	// nosplit-overflow analysis would trigger a link failure. On the
	// other hand if they not tagged NOSPLIT then this could cause
	// problems when building the runtime (since there may be calls to
	// asm routine in cases where it's not safe to grow the stack). In
	// most cases the wrapper would be (in effect) inlined, but are
	// there (perhaps) indirect calls from the runtime that could run
	// into trouble here.
	// FIXME: at the moment all.bash does not pass when I leave out
	// NOSPLIT for these wrappers, so all are currently tagged with NOSPLIT.
	fn.Pragma |= ir.Nosplit

	// Generate call. Use tail call if no params and no returns,
	// but a regular call otherwise.
	//
	// Note: ideally we would be using a tail call in cases where
	// there are params but no returns for ABI0->ABIInternal wrappers,
	// provided that all params fit into registers (e.g. we don't have
	// to allocate any stack space). Doing this will require some
	// extra work in typecheck/walk/ssa, might want to add a new node
	// OTAILCALL or something to this effect.
	tailcall := fn.Type().NumResults() == 0 && fn.Type().NumParams() == 0 && fn.Type().NumRecvs() == 0
	if base.Ctxt.Arch.Name == "ppc64le" && base.Ctxt.Flag_dynlink {
		// cannot tailcall on PPC64 with dynamic linking, as we need
		// to restore R2 after call.
		tailcall = false
	}
	if base.Ctxt.Arch.Name == "amd64" && wrapperABI == obj.ABIInternal {
		// cannot tailcall from ABIInternal to ABI0 on AMD64, as we need
		// to special registers (X15) when returning to ABIInternal.
		tailcall = false
	}

	var tail ir.Node
	call := ir.NewCallExpr(base.Pos, ir.OCALL, f.Nname, nil)
	call.Args = ir.ParamNames(fn.Type())
	call.IsDDD = fn.Type().IsVariadic()
	tail = call
	if tailcall {
		tail = ir.NewTailCallStmt(base.Pos, call)
	} else if fn.Type().NumResults() > 0 {
		n := ir.NewReturnStmt(base.Pos, nil)
		n.Results = []ir.Node{call}
		tail = n
	}
	fn.Body.Append(tail)

	typecheck.FinishFuncBody()

	ir.CurFunc = fn
	typecheck.Stmts(fn.Body)

	// Restore previous context.
	base.Pos = savepos
	ir.CurFunc = savedcurfn
}

// CreateWasmImportWrapper creates a wrapper for imported WASM functions to
// adapt them to the Go calling convention. The body for this function is
// generated in cmd/internal/obj/wasm/wasmobj.go
func CreateWasmImportWrapper(fn *ir.Func) bool {
	if fn.WasmImport == nil {
		return false
	}
	if buildcfg.GOARCH != "wasm" {
		base.FatalfAt(fn.Pos(), "CreateWasmImportWrapper call not supported on %s: func was %v", buildcfg.GOARCH, fn)
	}

	ir.InitLSym(fn, true)

	setupWasmImport(fn)

	pp := objw.NewProgs(fn, 0)
	defer pp.Free()
	pp.Text.To.Type = obj.TYPE_TEXTSIZE
	pp.Text.To.Val = int32(types.RoundUp(fn.Type().ArgWidth(), int64(types.RegSize)))
	// Wrapper functions never need their own stack frame
	pp.Text.To.Offset = 0
	pp.Flush()

	return true
}

func GenWasmExportWrapper(wrapped *ir.Func) {
	if wrapped.WasmExport == nil {
		return
	}
	if buildcfg.GOARCH != "wasm" {
		base.FatalfAt(wrapped.Pos(), "GenWasmExportWrapper call not supported on %s: func was %v", buildcfg.GOARCH, wrapped)
	}

	pos := base.AutogeneratedPos
	sym := &types.Sym{
		Name:     wrapped.WasmExport.Name,
		Linkname: wrapped.WasmExport.Name,
	}
	ft := wrapped.Nname.Type()
	fn := ir.NewFunc(pos, pos, sym, types.NewSignature(nil,
		typecheck.NewFuncParams(ft.Params()),
		typecheck.NewFuncParams(ft.Results())))
	fn.ABI = obj.ABI0 // actually wasm ABI
	// The wrapper function has a special calling convention that
	// morestack currently doesn't handle. For now we require that
	// the argument size fits in StackSmall, which we know we have
	// on stack, so we don't need to split stack.
	// cmd/internal/obj/wasm supports only 16 argument "registers"
	// anyway.
	if ft.ArgWidth() > rtabi.StackSmall {
		base.ErrorfAt(wrapped.Pos(), 0, "wasmexport function argument too large")
	}
	fn.Pragma |= ir.Nosplit

	ir.InitLSym(fn, true)

	setupWasmExport(fn, wrapped)

	pp := objw.NewProgs(fn, 0)
	defer pp.Free()
	// TEXT. Has a frame to pass args on stack to the Go function.
	pp.Text.To.Type = obj.TYPE_TEXTSIZE
	pp.Text.To.Val = int32(0)
	pp.Text.To.Offset = types.RoundUp(ft.ArgWidth(), int64(types.RegSize))
	// No locals. (Callee's args are covered in the callee's stackmap.)
	p := pp.Prog(obj.AFUNCDATA)
	p.From.SetConst(rtabi.FUNCDATA_LocalsPointerMaps)
	p.To.Type = obj.TYPE_MEM
	p.To.Name = obj.NAME_EXTERN
	p.To.Sym = base.Ctxt.Lookup("no_pointers_stackmap")
	pp.Flush()
	// Actual code geneneration is in cmd/internal/obj/wasm.
}

func paramsToWasmFields(f *ir.Func, pragma string, result *abi.ABIParamResultInfo, abiParams []abi.ABIParamAssignment) []obj.WasmField {
	wfs := make([]obj.WasmField, 0, len(abiParams))
	for _, p := range abiParams {
		t := p.Type
		var wt obj.WasmFieldType
		switch t.Kind() {
		case types.TINT32, types.TUINT32:
			wt = obj.WasmI32
		case types.TINT64, types.TUINT64:
			wt = obj.WasmI64
		case types.TFLOAT32:
			wt = obj.WasmF32
		case types.TFLOAT64:
			wt = obj.WasmF64
		case types.TUNSAFEPTR, types.TUINTPTR:
			wt = obj.WasmPtr
		case types.TBOOL:
			wt = obj.WasmBool
		case types.TSTRING:
			// Two parts, (ptr, len)
			wt = obj.WasmPtr
			wfs = append(wfs, obj.WasmField{Type: wt, Offset: p.FrameOffset(result)})
			wfs = append(wfs, obj.WasmField{Type: wt, Offset: p.FrameOffset(result) + int64(types.PtrSize)})
			continue
		case types.TPTR:
			if wasmElemTypeAllowed(t.Elem()) {
				wt = obj.WasmPtr
				break
			}
			fallthrough
		default:
			base.ErrorfAt(f.Pos(), 0, "%s: unsupported parameter type %s", pragma, t.String())
		}
		wfs = append(wfs, obj.WasmField{Type: wt, Offset: p.FrameOffset(result)})
	}
	return wfs
}

func resultsToWasmFields(f *ir.Func, pragma string, result *abi.ABIParamResultInfo, abiParams []abi.ABIParamAssignment) []obj.WasmField {
	if len(abiParams) > 1 {
		base.ErrorfAt(f.Pos(), 0, "%s: too many return values", pragma)
		return nil
	}
	wfs := make([]obj.WasmField, len(abiParams))
	for i, p := range abiParams {
		t := p.Type
		switch t.Kind() {
		case types.TINT32, types.TUINT32:
			wfs[i].Type = obj.WasmI32
		case types.TINT64, types.TUINT64:
			wfs[i].Type = obj.WasmI64
		case types.TFLOAT32:
			wfs[i].Type = obj.WasmF32
		case types.TFLOAT64:
			wfs[i].Type = obj.WasmF64
		case types.TUNSAFEPTR, types.TUINTPTR:
			wfs[i].Type = obj.WasmPtr
		case types.TBOOL:
			wfs[i].Type = obj.WasmBool
		case types.TPTR:
			if wasmElemTypeAllowed(t.Elem()) {
				wfs[i].Type = obj.WasmPtr
				break
			}
			fallthrough
		default:
			base.ErrorfAt(f.Pos(), 0, "%s: unsupported result type %s", pragma, t.String())
		}
		wfs[i].Offset = p.FrameOffset(result)
	}
	return wfs
}

// wasmElemTypeAllowed reports whether t is allowed to be passed in memory
// (as a pointer's element type, a field of it, etc.) between the Go wasm
// module and the host.
func wasmElemTypeAllowed(t *types.Type) bool {
	switch t.Kind() {
	case types.TINT8, types.TUINT8, types.TINT16, types.TUINT16,
		types.TINT32, types.TUINT32, types.TINT64, types.TUINT64,
		types.TFLOAT32, types.TFLOAT64, types.TBOOL:
		return true
	case types.TARRAY:
		return wasmElemTypeAllowed(t.Elem())
	case types.TSTRUCT:
		if len(t.Fields()) == 0 {
			return true
		}
		seenHostLayout := false
		for _, f := range t.Fields() {
			sym := f.Type.Sym()
			if sym != nil && sym.Name == "HostLayout" && sym.Pkg.Path == "structs" {
				seenHostLayout = true
				continue
			}
			if !wasmElemTypeAllowed(f.Type) {
				return false
			}
		}
		return seenHostLayout
	}
	// Pointer, and all pointerful types are not allowed, as pointers have
	// different width on the Go side and the host side. (It will be allowed
	// on GOARCH=wasm32.)
	return false
}

// setupWasmImport calculates the params and results in terms of WebAssembly values for the given function,
// and sets up the wasmimport metadata.
func setupWasmImport(f *ir.Func) {
	wi := obj.WasmImport{
		Module: f.WasmImport.Module,
		Name:   f.WasmImport.Name,
	}
	if wi.Module == wasm.GojsModule {
		// Functions that are imported from the "gojs" module use a special
		// ABI that just accepts the stack pointer.
		// Example:
		//
		// 	//go:wasmimport gojs add
		// 	func importedAdd(a, b uint) uint
		//
		// will roughly become
		//
		// 	(import "gojs" "add" (func (param i32)))
		wi.Params = []obj.WasmField{{Type: obj.WasmI32}}
	} else {
		// All other imported functions use the normal WASM ABI.
		// Example:
		//
		// 	//go:wasmimport a_module add
		// 	func importedAdd(a, b uint) uint
		//
		// will roughly become
		//
		// 	(import "a_module" "add" (func (param i32 i32) (result i32)))
		abiConfig := AbiForBodylessFuncStackMap(f)
		abiInfo := abiConfig.ABIAnalyzeFuncType(f.Type())
		wi.Params = paramsToWasmFields(f, "go:wasmimport", abiInfo, abiInfo.InParams())
		wi.Results = resultsToWasmFields(f, "go:wasmimport", abiInfo, abiInfo.OutParams())
	}
	f.LSym.Func().WasmImport = &wi
}

// setupWasmExport calculates the params and results in terms of WebAssembly values for the given function,
// and sets up the wasmexport metadata.
func setupWasmExport(f, wrapped *ir.Func) {
	we := obj.WasmExport{
		WrappedSym: wrapped.LSym,
	}
	abiConfig := AbiForBodylessFuncStackMap(wrapped)
	abiInfo := abiConfig.ABIAnalyzeFuncType(wrapped.Type())
	we.Params = paramsToWasmFields(wrapped, "go:wasmexport", abiInfo, abiInfo.InParams())
	we.Results = resultsToWasmFields(wrapped, "go:wasmexport", abiInfo, abiInfo.OutParams())
	f.LSym.Func().WasmExport = &we
}
```
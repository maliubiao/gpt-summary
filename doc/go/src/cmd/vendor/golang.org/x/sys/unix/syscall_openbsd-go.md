Response:
Let's break down the thought process for analyzing the provided Go code snippet.

**1. Initial Scan and Identification of Key Elements:**

My first step is always to quickly scan the code for recognizable patterns and keywords. I see:

* **Package declaration:** `package unix` - This immediately tells me it's related to low-level operating system interactions.
* **Import statements:** `import ("sort", "syscall", "unsafe")` - These imports give strong hints about the functionality: sorting, direct system calls, and memory manipulation.
* **Struct definitions:** `SockaddrDatalink` -  This suggests networking, specifically data link layer addresses.
* **Function definitions:** A large number of functions, some starting with `Syscall`, `Get`, `Pipe`, `Fcntl`, etc. The `//sys` and `//sysnb` comments are particularly important.
* **Comments:**  The initial comments point to OpenBSD system calls and the use of `mksyscall`.

**2. Understanding the `mksyscall` Mechanism:**

The comments about `mksyscall` are crucial. This tool is used in Go's standard library to generate the low-level Go wrappers for system calls. The `//sys` comments tell `mksyscall` which system call to bind to. This explains the prevalence of functions with names like `Access`, `Open`, `Read`, etc., which are standard POSIX system calls. The `//sysnb` likely indicates non-blocking or a slightly different variation.

**3. Grouping Functionality by Purpose:**

To make sense of the code, I start mentally grouping functions based on their apparent purpose:

* **Socket/Networking:** `SockaddrDatalink`, `anyToSockaddrGOOS`.
* **System Information:** Functions dealing with `sysctl` (like `nametomib`, `SysctlUvmexp`, and the `Uname` function which uses `sysctl`).
* **Directory and File Operations:** Functions like `Getdents`, `Getdirentries`, `Getcwd`, and the many directly exposed system calls (`Access`, `Open`, `Read`, `Write`, `Mkdir`, etc.).
* **Pipes:** `Pipe`, `Pipe2`.
* **File Locking:** `FcntlFlock`.
* **Process Information:** `Getresuid`, `Getresgid`, `Getpgid`, `Getppid`, `Getsid`.
* **Resource Limits:** `Getrlimit`.
* **Time:** `Adjtime`, `ClockGettime`, `Gettimeofday`, `Nanosleep`, `Settimeofday`.
* **Memory Management:** `mmap`, `munmap`.
* **Security/Permissions:** `Chflags`, `Chmod`, `Chown`, `Fchflags`, `Fchmod`, `Fchown`, `Lchown`, `Umask`, `pledge`, `unveil`.
* **System Control:** `ioctl`.

**4. Analyzing Specific Functions in Detail:**

Now I pick out some representative functions for deeper analysis:

* **`SockaddrDatalink` and `anyToSockaddrGOOS`:**  These are clearly related to networking. `SockaddrDatalink` defines a structure for data link layer addresses. `anyToSockaddrGOOS` aims to convert a generic socket address to a Go-specific `Sockaddr` interface, but in this case, it returns `EAFNOSUPPORT`, indicating it's not implemented for this address family.
* **`nametomib` and `SysctlUvmexp`:** These demonstrate how to access system information using `sysctl`. `nametomib` translates a human-readable name to a Management Information Base (MIB) array. `SysctlUvmexp` retrieves memory usage statistics.
* **`Pipe` and `Pipe2`:**  These are for creating unidirectional data channels. `Pipe2` offers more control through flags.
* **`Getdents` and `Getdirentries`:** These functions read directory entries. `Getdirentries` seems to be a higher-level wrapper around `Getdents` that also tries to retrieve the current seek position.
* **The `//sys` annotated functions:** These are the direct system call wrappers generated by `mksyscall`.

**5. Inferring Go Language Feature Implementations:**

Based on the identified functionality, I can infer the Go language features being implemented:

* **File I/O:** The numerous file-related system calls implement core file operations.
* **Networking:**  The socket address structure and related functions are part of Go's networking support.
* **Process Management:** Functions for getting process IDs, group IDs, and sending signals are part of Go's process control capabilities.
* **System Information Retrieval:** The `sysctl` wrappers allow Go programs to query system parameters.
* **Pipes:** The `Pipe` functions implement inter-process communication.

**6. Constructing Go Code Examples:**

For the examples, I focus on demonstrating how a few key functions might be used. I select functions that are relatively straightforward to illustrate, like `Pipe`, `Getcwd`, and using `sysctl` to get the hostname. I also consider potential error conditions and how to handle them in Go.

**7. Identifying Potential Pitfalls:**

I consider common errors developers might make when using these low-level functions:

* **Incorrect error handling:**  Not checking the `err` return value is a major source of bugs.
* **Buffer overflows:** When dealing with byte slices and system calls, it's important to manage buffer sizes correctly.
* **Incorrect use of pointers:**  The `unsafe` package requires careful handling to avoid memory corruption.
* **Platform differences:**  System calls and their behavior can vary between operating systems.

**8. Review and Refinement:**

Finally, I review my analysis and examples to ensure accuracy, clarity, and completeness. I check that the code examples are runnable and that the explanations are easy to understand. I make sure I haven't made any incorrect assumptions about the code's behavior. For instance, initially, I might have overlooked the detail that `anyToSockaddrGOOS` is not fully implemented, but careful reading catches this.

This systematic approach allows me to dissect the provided code snippet, understand its purpose, and explain its functionality in a clear and organized manner. The focus on the `mksyscall` mechanism and the grouping of related functions are key to efficiently analyzing this type of low-level code.
这段代码是 Go 语言标准库中 `syscall` 包的一部分，专门用于 OpenBSD 操作系统。它提供了对 OpenBSD 系统调用的底层访问。

**主要功能列举:**

1. **定义 `SockaddrDatalink` 结构体:**  这个结构体用于表示 AF_LINK 类型的 socket 地址，通常用于链路层协议，比如以太网。它包含了链路层地址的各种信息，如长度、地址族、接口索引等。

2. **提供 `anyToSockaddrGOOS` 函数:**  这个函数尝试将一个通用的 socket 地址 (`RawSockaddrAny`) 转换为特定于 OpenBSD 的 `Sockaddr` 接口。然而，在这个特定的 OpenBSD 实现中，它总是返回 `EAFNOSUPPORT` 错误，意味着不支持该地址族。这可能是因为在 OpenBSD 上，这种通用的转换方式并不适用或者有更特定的处理方式。

3. **声明 `Syscall9` 函数:**  这是一个底层的系统调用函数，可以发起最多带有 9 个参数的系统调用。通常，Go 开发者不会直接使用它，而是使用 `mksyscall` 生成的更具体的系统调用包装器。

4. **实现 `nametomib` 函数:**  这个函数将一个系统控制变量的名称（字符串）转换为其对应的 Management Information Base (MIB)  的整数数组。MIB 用于 `sysctl` 系统调用，允许获取和设置内核参数。它使用了一个名为 `sysctlMib` 的排序切片进行查找。

5. **提供 `direntIno`, `direntReclen`, `direntNamlen` 函数:**  这些辅助函数用于从 `Dirent` 结构体的字节数组表示中提取目录项的 inode 编号、记录长度和名称长度。它们使用了 `unsafe` 包进行指针操作。

6. **实现 `SysctlUvmexp` 函数:**  这个函数专门用于获取 OpenBSD 的虚拟内存统计信息。它通过 `nametomib` 获取 "vm.uvmexp" 的 MIB，然后使用 `sysctl` 系统调用获取 `Uvmexp` 结构体的数据。

7. **提供 `Pipe` 和 `Pipe2` 函数:**  这两个函数用于创建管道，用于进程间通信。`Pipe` 是 `Pipe2` 的一个简化版本，默认 flags 为 0。`Pipe2` 允许指定额外的 flags，例如 `O_CLOEXEC`。

8. **声明并包装 `Getdents` 函数:**  `Getdents` 是一个系统调用，用于读取目录项。`Getdirentries` 函数是对 `Getdents` 的一个封装，它除了调用 `Getdents` 外，还会尝试获取当前的文件偏移量，并将其作为 `basep` 返回。

9. **声明并包装 `Getcwd` 函数:**  `Getcwd` 系统调用用于获取当前工作目录。

10. **声明并包装 `Sendfile` 函数:** `Sendfile` 用于在两个文件描述符之间直接传输数据，避免了用户空间的缓冲区拷贝。然而，在这个 OpenBSD 的实现中，`sendfile` 函数本身被标记为 `TODO` 并且总是返回 `ENOSYS` (Function not implemented) 错误。这意味着 OpenBSD 上的 `Sendfile` 功能可能未实现或有其他替代方案。

11. **实现 `Getfsstat` 函数:**  这个函数用于获取文件系统状态信息。它可以获取一个或多个文件系统的统计数据。

12. **声明并实现 `Getresuid` 和 `Getresgid` 函数:**  这些函数用于获取进程的 real UID、effective UID 和 saved set UID/GID。

13. **声明并包装 `ioctl`, `ioctlPtr`, `sysctl`, `fcntl`, `fcntlPtr` 函数:**  这些是与系统交互的重要系统调用。
    * `ioctl`:  用于设备特定的输入/输出控制。
    * `sysctl`: 用于获取和设置内核参数。
    * `fcntl`: 用于文件控制操作，如修改文件描述符的属性。

14. **提供 `FcntlInt` 和 `FcntlFlock` 函数:**  这些是对 `fcntl` 的更易于使用的包装器。`FcntlInt` 用于执行带有整数参数的 `fcntl` 操作，而 `FcntlFlock` 专门用于文件锁操作。

15. **声明并包装 `ppoll` 函数:**  `ppoll` 是 `poll` 的一个变体，允许指定信号掩码。

16. **实现 `Ppoll` 函数:**  这是对 `ppoll` 的 Go 语言包装。

17. **实现 `Uname` 函数:**  这个函数获取系统的相关信息，如操作系统名称、主机名、内核版本等，并将信息填充到 `Utsname` 结构体中。它使用了 `sysctl` 系统调用来获取这些信息。

18. **大量直接暴露的系统调用:** 代码中列出了很多以 `//sys` 开头的行，这些行是 `mksyscall` 工具的指令。`mksyscall` 会解析这些行，并生成相应的 Go 函数，这些函数直接调用底层的 OpenBSD 系统调用。这些系统调用涵盖了文件操作、进程管理、内存管理、权限控制等各个方面。

**它是什么 Go 语言功能的实现？**

这个文件是 Go 语言标准库中 **`syscall` 包**的一部分。`syscall` 包提供了对底层操作系统 API 的访问能力。 具体来说，这个 `syscall_openbsd.go` 文件实现了 `syscall` 包在 **OpenBSD 操作系统**上的特定功能。

**Go 代码举例说明:**

假设我们要获取当前的工作目录：

```go
package main

import (
	"fmt"
	"syscall"
	"unsafe"
)

func main() {
	buf := make([]byte, syscall.MAXPATHLEN)
	n, err := syscall.Getcwd(buf)
	if err != nil {
		fmt.Println("Error getting current directory:", err)
		return
	}
	cwd := string(buf[:n])
	fmt.Println("Current working directory:", cwd)
}
```

**假设的输入与输出：**

如果当前工作目录是 `/home/user/projects`，那么输出将会是：

```
Current working directory: /home/user/projects
```

另一个例子，使用 `Pipe` 创建一个管道：

```go
package main

import (
	"fmt"
	"os"
	"syscall"
)

func main() {
	fds := make([]int, 2)
	err := syscall.Pipe(fds)
	if err != nil {
		fmt.Println("Error creating pipe:", err)
		return
	}
	fmt.Println("Pipe file descriptors:", fds[0], fds[1])

	// 关闭文件描述符 (通常会在使用完毕后关闭)
	syscall.Close(fds[0])
	syscall.Close(fds[1])
}
```

**假设的输入与输出：**

输出会显示新创建的管道的两个文件描述符，例如：

```
Pipe file descriptors: 3 4
```
(实际的描述符值可能不同)

**命令行参数的具体处理:**

在这个文件中，大部分函数是对系统调用的直接映射，本身并不直接处理命令行参数。命令行参数的处理通常发生在更上层的 Go 代码中，例如 `os` 包或者用户自己的应用程序中。

例如，`os.Open` 函数最终会调用 `syscall.Open` 或 `syscall.Openat`，但 `os.Open` 负责处理传递给它的文件名和打开模式等参数。

**使用者易犯错的点:**

1. **错误处理:** 调用系统调用时，务必检查返回的 `error`。系统调用失败的原因有很多，例如权限不足、文件不存在等。忽略错误可能导致程序行为异常甚至崩溃。

   ```go
   fd, err := syscall.Open("/nonexistent_file", syscall.O_RDONLY, 0)
   if err != nil {
       fmt.Println("Error opening file:", err) // 应该处理错误
       // ...
   }
   ```

2. **不正确地使用 `unsafe` 包:** 像 `direntIno` 这样的函数使用了 `unsafe` 包进行指针操作。如果使用不当，可能会导致内存安全问题。通常情况下，应该尽量避免直接使用 `unsafe` 包，而是使用 Go 标准库提供的更安全的抽象。

3. **缓冲区大小不足:** 在使用像 `Getcwd` 或 `Readlink` 这样的函数时，需要提供一个缓冲区来存储结果。如果缓冲区太小，可能会导致数据截断或错误。

   ```go
   buf := make([]byte, 10) // 缓冲区可能太小
   n, err := syscall.Readlink("/path/to/a/long/symlink", buf)
   if err != nil {
       // ...
   }
   ```
   应该使用 `syscall.MAXPATHLEN` 或根据实际需求分配足够大的缓冲区。

4. **文件描述符管理:**  系统调用返回的文件描述符（例如 `Open`, `Pipe`, `Kqueue` 的返回值）是有限的资源。使用完毕后，务必使用 `syscall.Close()` 关闭文件描述符，避免资源泄漏。

5. **平台差异:**  `syscall` 包中的代码是平台相关的。这段代码是针对 OpenBSD 的，在其他操作系统上可能行为不同或者根本不存在。编写跨平台程序时需要注意这些差异。

总而言之，这个文件是 Go 语言与 OpenBSD 操作系统底层交互的桥梁，提供了访问系统调用的能力。开发者在使用 `syscall` 包时需要理解底层操作系统的概念，并谨慎处理错误和资源。

### 提示词
```
这是路径为go/src/cmd/vendor/golang.org/x/sys/unix/syscall_openbsd.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
```

### 源代码
```go
// Copyright 2009,2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// OpenBSD system calls.
// This file is compiled as ordinary Go code,
// but it is also input to mksyscall,
// which parses the //sys lines and generates system call stubs.
// Note that sometimes we use a lowercase //sys name and wrap
// it in our own nicer implementation, either here or in
// syscall_bsd.go or syscall_unix.go.

package unix

import (
	"sort"
	"syscall"
	"unsafe"
)

// SockaddrDatalink implements the Sockaddr interface for AF_LINK type sockets.
type SockaddrDatalink struct {
	Len    uint8
	Family uint8
	Index  uint16
	Type   uint8
	Nlen   uint8
	Alen   uint8
	Slen   uint8
	Data   [24]int8
	raw    RawSockaddrDatalink
}

func anyToSockaddrGOOS(fd int, rsa *RawSockaddrAny) (Sockaddr, error) {
	return nil, EAFNOSUPPORT
}

func Syscall9(trap, a1, a2, a3, a4, a5, a6, a7, a8, a9 uintptr) (r1, r2 uintptr, err syscall.Errno)

func nametomib(name string) (mib []_C_int, err error) {
	i := sort.Search(len(sysctlMib), func(i int) bool {
		return sysctlMib[i].ctlname >= name
	})
	if i < len(sysctlMib) && sysctlMib[i].ctlname == name {
		return sysctlMib[i].ctloid, nil
	}
	return nil, EINVAL
}

func direntIno(buf []byte) (uint64, bool) {
	return readInt(buf, unsafe.Offsetof(Dirent{}.Fileno), unsafe.Sizeof(Dirent{}.Fileno))
}

func direntReclen(buf []byte) (uint64, bool) {
	return readInt(buf, unsafe.Offsetof(Dirent{}.Reclen), unsafe.Sizeof(Dirent{}.Reclen))
}

func direntNamlen(buf []byte) (uint64, bool) {
	return readInt(buf, unsafe.Offsetof(Dirent{}.Namlen), unsafe.Sizeof(Dirent{}.Namlen))
}

func SysctlUvmexp(name string) (*Uvmexp, error) {
	mib, err := sysctlmib(name)
	if err != nil {
		return nil, err
	}

	n := uintptr(SizeofUvmexp)
	var u Uvmexp
	if err := sysctl(mib, (*byte)(unsafe.Pointer(&u)), &n, nil, 0); err != nil {
		return nil, err
	}
	if n != SizeofUvmexp {
		return nil, EIO
	}
	return &u, nil
}

func Pipe(p []int) (err error) {
	return Pipe2(p, 0)
}

//sysnb	pipe2(p *[2]_C_int, flags int) (err error)

func Pipe2(p []int, flags int) error {
	if len(p) != 2 {
		return EINVAL
	}
	var pp [2]_C_int
	err := pipe2(&pp, flags)
	if err == nil {
		p[0] = int(pp[0])
		p[1] = int(pp[1])
	}
	return err
}

//sys	Getdents(fd int, buf []byte) (n int, err error)

func Getdirentries(fd int, buf []byte, basep *uintptr) (n int, err error) {
	n, err = Getdents(fd, buf)
	if err != nil || basep == nil {
		return
	}

	var off int64
	off, err = Seek(fd, 0, 1 /* SEEK_CUR */)
	if err != nil {
		*basep = ^uintptr(0)
		return
	}
	*basep = uintptr(off)
	if unsafe.Sizeof(*basep) == 8 {
		return
	}
	if off>>32 != 0 {
		// We can't stuff the offset back into a uintptr, so any
		// future calls would be suspect. Generate an error.
		// EIO was allowed by getdirentries.
		err = EIO
	}
	return
}

//sys	Getcwd(buf []byte) (n int, err error) = SYS___GETCWD

func Sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) {
	if raceenabled {
		raceReleaseMerge(unsafe.Pointer(&ioSync))
	}
	return sendfile(outfd, infd, offset, count)
}

// TODO
func sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) {
	return -1, ENOSYS
}

func Getfsstat(buf []Statfs_t, flags int) (n int, err error) {
	var bufptr *Statfs_t
	var bufsize uintptr
	if len(buf) > 0 {
		bufptr = &buf[0]
		bufsize = unsafe.Sizeof(Statfs_t{}) * uintptr(len(buf))
	}
	return getfsstat(bufptr, bufsize, flags)
}

//sysnb	getresuid(ruid *_C_int, euid *_C_int, suid *_C_int)
//sysnb	getresgid(rgid *_C_int, egid *_C_int, sgid *_C_int)

func Getresuid() (ruid, euid, suid int) {
	var r, e, s _C_int
	getresuid(&r, &e, &s)
	return int(r), int(e), int(s)
}

func Getresgid() (rgid, egid, sgid int) {
	var r, e, s _C_int
	getresgid(&r, &e, &s)
	return int(r), int(e), int(s)
}

//sys	ioctl(fd int, req uint, arg uintptr) (err error)
//sys	ioctlPtr(fd int, req uint, arg unsafe.Pointer) (err error) = SYS_IOCTL

//sys	sysctl(mib []_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) = SYS___SYSCTL

//sys	fcntl(fd int, cmd int, arg int) (n int, err error)
//sys	fcntlPtr(fd int, cmd int, arg unsafe.Pointer) (n int, err error) = SYS_FCNTL

// FcntlInt performs a fcntl syscall on fd with the provided command and argument.
func FcntlInt(fd uintptr, cmd, arg int) (int, error) {
	return fcntl(int(fd), cmd, arg)
}

// FcntlFlock performs a fcntl syscall for the F_GETLK, F_SETLK or F_SETLKW command.
func FcntlFlock(fd uintptr, cmd int, lk *Flock_t) error {
	_, err := fcntlPtr(int(fd), cmd, unsafe.Pointer(lk))
	return err
}

//sys	ppoll(fds *PollFd, nfds int, timeout *Timespec, sigmask *Sigset_t) (n int, err error)

func Ppoll(fds []PollFd, timeout *Timespec, sigmask *Sigset_t) (n int, err error) {
	if len(fds) == 0 {
		return ppoll(nil, 0, timeout, sigmask)
	}
	return ppoll(&fds[0], len(fds), timeout, sigmask)
}

func Uname(uname *Utsname) error {
	mib := []_C_int{CTL_KERN, KERN_OSTYPE}
	n := unsafe.Sizeof(uname.Sysname)
	if err := sysctl(mib, &uname.Sysname[0], &n, nil, 0); err != nil {
		return err
	}

	mib = []_C_int{CTL_KERN, KERN_HOSTNAME}
	n = unsafe.Sizeof(uname.Nodename)
	if err := sysctl(mib, &uname.Nodename[0], &n, nil, 0); err != nil {
		return err
	}

	mib = []_C_int{CTL_KERN, KERN_OSRELEASE}
	n = unsafe.Sizeof(uname.Release)
	if err := sysctl(mib, &uname.Release[0], &n, nil, 0); err != nil {
		return err
	}

	mib = []_C_int{CTL_KERN, KERN_VERSION}
	n = unsafe.Sizeof(uname.Version)
	if err := sysctl(mib, &uname.Version[0], &n, nil, 0); err != nil {
		return err
	}

	// The version might have newlines or tabs in it, convert them to
	// spaces.
	for i, b := range uname.Version {
		if b == '\n' || b == '\t' {
			if i == len(uname.Version)-1 {
				uname.Version[i] = 0
			} else {
				uname.Version[i] = ' '
			}
		}
	}

	mib = []_C_int{CTL_HW, HW_MACHINE}
	n = unsafe.Sizeof(uname.Machine)
	if err := sysctl(mib, &uname.Machine[0], &n, nil, 0); err != nil {
		return err
	}

	return nil
}

/*
 * Exposed directly
 */
//sys	Access(path string, mode uint32) (err error)
//sys	Adjtime(delta *Timeval, olddelta *Timeval) (err error)
//sys	Chdir(path string) (err error)
//sys	Chflags(path string, flags int) (err error)
//sys	Chmod(path string, mode uint32) (err error)
//sys	Chown(path string, uid int, gid int) (err error)
//sys	Chroot(path string) (err error)
//sys	ClockGettime(clockid int32, time *Timespec) (err error)
//sys	Close(fd int) (err error)
//sys	Dup(fd int) (nfd int, err error)
//sys	Dup2(from int, to int) (err error)
//sys	Dup3(from int, to int, flags int) (err error)
//sys	Exit(code int)
//sys	Faccessat(dirfd int, path string, mode uint32, flags int) (err error)
//sys	Fchdir(fd int) (err error)
//sys	Fchflags(fd int, flags int) (err error)
//sys	Fchmod(fd int, mode uint32) (err error)
//sys	Fchmodat(dirfd int, path string, mode uint32, flags int) (err error)
//sys	Fchown(fd int, uid int, gid int) (err error)
//sys	Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error)
//sys	Flock(fd int, how int) (err error)
//sys	Fpathconf(fd int, name int) (val int, err error)
//sys	Fstat(fd int, stat *Stat_t) (err error)
//sys	Fstatat(fd int, path string, stat *Stat_t, flags int) (err error)
//sys	Fstatfs(fd int, stat *Statfs_t) (err error)
//sys	Fsync(fd int) (err error)
//sys	Ftruncate(fd int, length int64) (err error)
//sysnb	Getegid() (egid int)
//sysnb	Geteuid() (uid int)
//sysnb	Getgid() (gid int)
//sysnb	Getpgid(pid int) (pgid int, err error)
//sysnb	Getpgrp() (pgrp int)
//sysnb	Getpid() (pid int)
//sysnb	Getppid() (ppid int)
//sys	Getpriority(which int, who int) (prio int, err error)
//sysnb	Getrlimit(which int, lim *Rlimit) (err error)
//sysnb	Getrtable() (rtable int, err error)
//sysnb	Getrusage(who int, rusage *Rusage) (err error)
//sysnb	Getsid(pid int) (sid int, err error)
//sysnb	Gettimeofday(tv *Timeval) (err error)
//sysnb	Getuid() (uid int)
//sys	Issetugid() (tainted bool)
//sys	Kill(pid int, signum syscall.Signal) (err error)
//sys	Kqueue() (fd int, err error)
//sys	Lchown(path string, uid int, gid int) (err error)
//sys	Link(path string, link string) (err error)
//sys	Linkat(pathfd int, path string, linkfd int, link string, flags int) (err error)
//sys	Listen(s int, backlog int) (err error)
//sys	Lstat(path string, stat *Stat_t) (err error)
//sys	Mkdir(path string, mode uint32) (err error)
//sys	Mkdirat(dirfd int, path string, mode uint32) (err error)
//sys	Mkfifo(path string, mode uint32) (err error)
//sys	Mkfifoat(dirfd int, path string, mode uint32) (err error)
//sys	Mknod(path string, mode uint32, dev int) (err error)
//sys	Mknodat(dirfd int, path string, mode uint32, dev int) (err error)
//sys	Mount(fsType string, dir string, flags int, data unsafe.Pointer) (err error)
//sys	Nanosleep(time *Timespec, leftover *Timespec) (err error)
//sys	Open(path string, mode int, perm uint32) (fd int, err error)
//sys	Openat(dirfd int, path string, mode int, perm uint32) (fd int, err error)
//sys	Pathconf(path string, name int) (val int, err error)
//sys	pread(fd int, p []byte, offset int64) (n int, err error)
//sys	pwrite(fd int, p []byte, offset int64) (n int, err error)
//sys	read(fd int, p []byte) (n int, err error)
//sys	Readlink(path string, buf []byte) (n int, err error)
//sys	Readlinkat(dirfd int, path string, buf []byte) (n int, err error)
//sys	Rename(from string, to string) (err error)
//sys	Renameat(fromfd int, from string, tofd int, to string) (err error)
//sys	Revoke(path string) (err error)
//sys	Rmdir(path string) (err error)
//sys	Seek(fd int, offset int64, whence int) (newoffset int64, err error) = SYS_LSEEK
//sys	Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error)
//sysnb	Setegid(egid int) (err error)
//sysnb	Seteuid(euid int) (err error)
//sysnb	Setgid(gid int) (err error)
//sys	Setlogin(name string) (err error)
//sysnb	Setpgid(pid int, pgid int) (err error)
//sys	Setpriority(which int, who int, prio int) (err error)
//sysnb	Setregid(rgid int, egid int) (err error)
//sysnb	Setreuid(ruid int, euid int) (err error)
//sysnb	Setresgid(rgid int, egid int, sgid int) (err error)
//sysnb	Setresuid(ruid int, euid int, suid int) (err error)
//sysnb	Setrtable(rtable int) (err error)
//sysnb	Setsid() (pid int, err error)
//sysnb	Settimeofday(tp *Timeval) (err error)
//sysnb	Setuid(uid int) (err error)
//sys	Stat(path string, stat *Stat_t) (err error)
//sys	Statfs(path string, stat *Statfs_t) (err error)
//sys	Symlink(path string, link string) (err error)
//sys	Symlinkat(oldpath string, newdirfd int, newpath string) (err error)
//sys	Sync() (err error)
//sys	Truncate(path string, length int64) (err error)
//sys	Umask(newmask int) (oldmask int)
//sys	Unlink(path string) (err error)
//sys	Unlinkat(dirfd int, path string, flags int) (err error)
//sys	Unmount(path string, flags int) (err error)
//sys	write(fd int, p []byte) (n int, err error)
//sys	mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error)
//sys	munmap(addr uintptr, length uintptr) (err error)
//sys	getfsstat(stat *Statfs_t, bufsize uintptr, flags int) (n int, err error)
//sys	utimensat(dirfd int, path string, times *[2]Timespec, flags int) (err error)
//sys	pledge(promises *byte, execpromises *byte) (err error)
//sys	unveil(path *byte, flags *byte) (err error)
```
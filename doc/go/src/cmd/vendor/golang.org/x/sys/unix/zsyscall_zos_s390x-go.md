Response:
Let's break down the thought process for analyzing this Go code snippet.

**1. Initial Scan and Understanding the Context:**

* **File Path:** `go/src/cmd/vendor/golang.org/x/sys/unix/zsyscall_zos_s390x.go`  This immediately tells us a few key things:
    * It's part of the Go standard library's `syscall` package, specifically for Unix-like systems.
    * The `zos` and `s390x` in the name and `//go:build` tag indicate it's for the z/OS operating system running on the s390x architecture.
    * The `zsyscall_` prefix suggests it deals with low-level system calls.
    * It's within the `vendor` directory, meaning it's a vendored dependency, likely from the `golang.org/x/sys` repository.
* **Generated Code Comment:**  The `// go run mksyscall_zos_s390x.go ...` comment and "Code generated by the command above; see README.md. DO NOT EDIT." are crucial. This tells us the code is automatically generated and shouldn't be manually modified. It also hints at the existence of a tool (`mksyscall_zos_s390x.go`) responsible for this generation.
* **`//go:build zos && s390x`:** This build tag confirms the target platform.
* **Imports:** `runtime`, `syscall`, and `unsafe` are the core imports. This reinforces the idea of low-level system call interaction, as `unsafe` is often needed for direct memory manipulation, and `syscall` provides the basic syscall infrastructure. `runtime` is used for managing Go's runtime environment, including entering and exiting syscalls.

**2. Identifying Key Patterns:**

* **Function Structure:**  A very consistent pattern emerges for most functions:
    * `func <syscall_name>(...) (...)` - The externally visible function.
    * `func impl_<syscall_name>(...) (...)` - The actual implementation that makes the system call.
    * `func get_<syscall_name>Addr() *(...)` -  A function to get a pointer to the implementation function.
    * `var <syscall_name> = enter_<syscall_name>` - Assigning the "enter" function to the publicly used variable.
    * `func enter_<syscall_name>(...) (...)` - A function that checks if the implementation exists and calls either the implementation or an error handler.
    * `func error_<syscall_name>(...) (...)` -  An error handler that returns `ENOSYS`.
* **`CallLeFuncWithErr`:** This function is called within the `impl_` functions. The `GetZosLibVec()` part strongly suggests it's calling into a dynamically linked library (likely the z/OS system library). The `SYS_<SYSCALL_NAME> << 4` pattern implies that system call numbers are being used as offsets.
* **`runtime.EnterSyscall()` and `runtime.ExitSyscall()`:** These calls bracket the actual system call, indicating proper management of Go's scheduler during syscalls.
* **Error Handling:** The `errnoErr2(e1, e2)` pattern suggests a specific way of converting raw error codes from the system call into Go's `error` type.
* **`unsafe.Pointer`:**  Used extensively for passing data to and from system calls, which often require raw memory addresses.
* **`BytePtrFromString`:**  Used to convert Go strings into C-style null-terminated byte pointers, as required by many system calls.

**3. Hypothesizing the Purpose of the Pattern:**

The consistent function pattern suggests a strategy for handling system call availability. The `enter_` functions act as a gatekeeper. The `funcptrtest` function likely checks if the system call is supported by the underlying kernel at runtime. If it is, the `impl_` function is used; otherwise, the `error_` function, which returns `ENOSYS` (Operation not supported), is used. This is a common technique for providing forward compatibility or handling optional system calls.

**4. Inferring the Overall Functionality:**

Based on the identified patterns, the primary function of this code is to provide Go interfaces to various z/OS system calls. It handles the details of:

* Calling the correct system call using `CallLeFuncWithErr`.
* Marshalling data between Go types and the raw memory formats expected by the system calls.
* Managing Go's runtime during system call execution.
* Handling potential errors returned by system calls.
* Gracefully handling cases where a system call might not be implemented.

**5. Generating Examples (Mental Exercise and Refinement):**

To solidify understanding, one could think of specific examples:

* **`read` and `write`:** These are fundamental for file I/O. A simple example would involve opening a file and reading/writing to it.
* **Extended Attributes (`Flistxattr`, `Fgetxattr`, `Fsetxattr`, `Fremovexattr`):** These relate to managing metadata associated with files. An example would involve setting a custom attribute on a file and then retrieving it.
* **Networking Functions (`accept`, `bind`, `connect`, `socket`):**  These are building blocks for network communication. An example would be creating a simple server socket.
* **Process Management (`Exit`, `Kill`):**  Basic process control. An example would be sending a signal to another process.

**6. Addressing Specific Questions from the Prompt:**

* **Function Listing:** This becomes a matter of enumerating all the exported functions.
* **Go Language Feature:** The code primarily implements the `syscall` package functionality, providing a bridge between Go and the operating system kernel. The dynamic dispatch mechanism (using function pointers and `enter_` functions) is also a noteworthy aspect.
* **Code Examples:**  Based on the identified function categories, one can create illustrative code snippets.
* **Command Line Arguments:**  The initial comment provides the command used to generate the code, which includes input and output file names.
* **Common Mistakes:**  Given the generated nature and low-level focus, common mistakes would likely involve incorrect usage of file descriptors, buffer sizes, or pointer arithmetic if one were to try and interact with these functions directly (though the `syscall` package usually provides higher-level abstractions).
* **Summary:**  The summary should capture the essence of the code's purpose: providing a low-level interface to z/OS system calls for Go programs.

By following these steps, combining code analysis with an understanding of operating system and Go programming concepts, one can effectively deduce the functionality of this seemingly complex generated code.
这是一个 Go 语言 `syscall` 包的一部分，专门针对 `zos` 操作系统和 `s390x` 架构。它定义了一系列与操作系统底层交互的函数，这些函数是对 z/OS 系统调用的封装。

**功能归纳:**

这个 Go 文件 (`zsyscall_zos_s390x.go`) 的主要功能是：

1. **提供 Go 语言访问 z/OS 系统调用的接口:**  它定义了一系列 Go 函数，每个函数都对应一个底层的 z/OS 系统调用。
2. **处理系统调用的参数和返回值:**  这些 Go 函数负责将 Go 语言的数据类型转换为系统调用所需的格式，并在系统调用返回后，将结果转换回 Go 语言的数据类型。
3. **处理系统调用错误:**  当系统调用发生错误时，这些 Go 函数会捕获错误码，并将其转换为 Go 语言的 `error` 类型。
4. **使用间接调用处理系统调用可用性:**  对于一些可选的或者在特定版本中才存在的系统调用，它使用了函数指针和动态加载的方式，以避免在不支持的系统上直接调用导致程序崩溃。如果系统调用不可用，会使用一个返回 `ENOSYS` 错误的占位函数。

**更具体的功能列表 (基于代码中的函数名):**

* **文件操作:**
    * `fcntl`: 文件控制操作 (如获取/设置文件描述符标志)。
    * `read`: 从文件描述符读取数据。
    * `write`: 向文件描述符写入数据。
    * `creat`: 创建文件。
    * `dup`, `dup2`, `dup3`: 复制文件描述符。
    * `fstat`, `lstat`, `fstatat`: 获取文件状态信息。
    * `chmod`, `fchmod`, `fchmodat`: 修改文件权限。
    * `chown`, `fchown`, `lchown`, `fchownat`: 修改文件所有者和组。
    * `link`, `linkat`: 创建硬链接。
    * `mkdir`, `mkdirat`: 创建目录。
    * `mkfifo`: 创建命名管道。
    * `mknod`, `mknodat`: 创建特殊文件（设备文件等）。
    * `truncate`, `ftruncate`: 截断文件。
    * `access`, `faccessat`: 检查文件访问权限。
    * `unlink`, `unlinkat`: 删除文件。
    * `rename`, `renameat`: 重命名文件或目录。
    * `chdir`, `fchdir`: 改变当前工作目录。
    * `chroot`: 改变根目录。
    * `open`, `openat`: 打开文件。
    * `close`: 关闭文件描述符。
    * `sync`, `fsync`, `fdatasync`, `syncfs`: 将文件数据同步到磁盘。
    * `utimes`, `lutimes`, `futimes`, `futimesat`: 修改文件访问和修改时间。
    * `statfs`, `fstatfs`: 获取文件系统统计信息。
    * `statvfs`, `fstatvfs`: 获取文件系统信息。
    * `readdir_r`: 读取目录条目 (线程安全版本)。
    * `dirfd`: 获取目录流的文件描述符。

* **扩展属性 (Extended Attributes):**
    * `impl_Flistxattr`, `Flistxattr`: 列出文件描述符对应的扩展属性。
    * `impl_Fgetxattr`, `Fgetxattr`: 获取文件描述符对应的指定扩展属性的值。
    * `impl_Fsetxattr`, `Fsetxattr`: 设置文件描述符对应的扩展属性的值。
    * `impl_Fremovexattr`, `Fremovexattr`: 删除文件描述符对应的扩展属性。
    * `impl_Listxattr`, `Listxattr`: 列出路径对应的扩展属性。
    * `impl_Llistxattr`, `Llistxattr`: 列出符号链接指向的文件对应的扩展属性。
    * `impl_Lgetxattr`, `Lgetxattr`: 获取符号链接指向的文件对应的指定扩展属性的值。
    * `impl_Lsetxattr`, `Lsetxattr`: 设置符号链接指向的文件对应的扩展属性的值。
    * `impl_Removexattr`, `Removexattr`: 删除路径对应的扩展属性。
    * `impl_Lremovexattr`, `Lremovexattr`: 删除符号链接指向的文件对应的扩展属性。

* **进程管理:**
    * `exit`: 终止当前进程。
    * `kill`: 向进程发送信号。
    * `getpid`, `getppid`, `getgid`, `getegid`, `getuid`, `geteuid`: 获取进程/用户/组 ID。
    * `getpgid`, `getsid`: 获取进程组 ID 和会话 ID。
    * `setgroups`, `getgroups`: 设置和获取当前进程的附加组 ID。
    * `getpriority`: 获取进程优先级。
    * `getrlimit`: 获取进程资源限制。
    * `getrusage`: 获取进程资源使用情况。

* **内存管理:**
    * `mmap`: 将文件或设备映射到内存。
    * `munmap`: 取消内存映射。
    * `mprotect`: 修改内存区域的保护属性。
    * `msync`: 将内存中的修改刷新到磁盘。
    * `shmat`, `shmctl`, `shmdt`, `shmget`: System V 共享内存操作。

* **Socket 和网络:**
    * `socket`: 创建 socket。
    * `bind`: 将 socket 绑定到本地地址和端口。
    * `listen`: 监听 socket 连接。
    * `accept`, `accept4`: 接受 socket 连接。
    * `connect`: 连接到远程 socket。
    * `sendto`, `recvfrom`: 在无连接 socket 上发送和接收数据。
    * `sendmsg`, `recvmsg`: 通过 socket 发送和接收消息。
    * `getsockopt`, `setsockopt`: 获取和设置 socket 选项。
    * `getpeername`, `getsockname`: 获取连接的对端地址和本地地址。
    * `socketpair`: 创建一对已连接的 socket。
    * `gethostname`: 获取主机名.

* **事件通知 (epoll 和 inotify):**
    * `impl_EpollCreate`, `EpollCreate`, `impl_EpollCreate1`, `EpollCreate1`: 创建 epoll 实例。
    * `impl_EpollCtl`, `EpollCtl`: 控制 epoll 实例中的事件。
    * `impl_EpollWait`, `EpollWait`, `impl_EpollPwait`, `EpollPwait`: 等待 epoll 实例上的事件。
    * `impl_InotifyInit`, `InotifyInit`, `impl_InotifyInit1`, `InotifyInit1`: 初始化 inotify 实例。
    * `impl_InotifyAddWatch`, `InotifyAddWatch`: 向 inotify 实例添加监控。
    * `impl_InotifyRmWatch`, `InotifyRmWatch`: 从 inotify 实例移除监控。
    * `impl_Eventfd`, `Eventfd`: 创建事件文件描述符。

* **其他系统调用:**
    * `ioctl`, `ioctlPtr`:  设备相关的 I/O 控制操作。
    * `poll`: 等待一组文件描述符上的事件。
    * `select`: 同步 I/O 多路复用。
    * `console2`:  与系统控制台交互。
    * `mount_LE`, `unmount_LE`: 挂载和卸载文件系统。
    * `uname`: 获取系统信息。
    * `impl_Unshare`, `Unshare`:  取消进程共享的执行上下文部分。
    * `Errno2`: 获取辅助错误码。
    * `impl_Getrandom`, `Getrandom`: 获取随机数。
    * `Times`: 获取进程的 CPU 时间。
    * `W_Getmntent`, `W_Getmntent_A`: 获取挂载点信息。

**Go 代码示例 (基于 `read` 系统调用):**

假设我们想从一个打开的文件中读取数据。

```go
package main

import (
	"fmt"
	"os"
	"syscall"
	"unsafe"
)

func main() {
	filename := "test.txt"
	file, err := os.Open(filename)
	if err != nil {
		fmt.Println("Error opening file:", err)
		return
	}
	defer file.Close()

	fd := file.Fd() // 获取文件描述符

	buffer := make([]byte, 100) // 创建一个缓冲区

	// 调用封装的 read 系统调用
	n, err := syscall.Read(int(fd), buffer)
	if err != nil {
		fmt.Println("Error reading file:", err)
		return
	}

	fmt.Printf("Read %d bytes: %s\n", n, string(buffer[:n]))
}
```

**假设的输入与输出:**

如果 `test.txt` 文件包含 "Hello, z/OS!"，那么：

* **输入:** 文件描述符 (由 `os.Open` 返回)，缓冲区 `buffer`。
* **输出:**  `n` 的值可能为 13 (读取的字节数)，`buffer` 的前 13 个字节将包含 "Hello, z/OS!"。

**命令行参数的具体处理:**

该代码本身并不直接处理命令行参数。命令行参数的处理通常发生在 `main` 函数或者使用 `flag` 包等。

然而，代码开头的注释提供了一个用于生成此文件的命令：

```
// go run mksyscall_zos_s390x.go -o_sysnum zsysnum_zos_s390x.go -o_syscall zsyscall_zos_s390x.go -i_syscall syscall_zos_s390x.go -o_asm zsymaddr_zos_s390x.s
```

这个命令是 `mksyscall_zos_s390x.go` 脚本的调用，它用于根据 `-i_syscall` 指定的输入文件 (`syscall_zos_s390x.go`) 生成系统调用的封装代码。

* `-o_sysnum zsysnum_zos_s390x.go`: 指定生成的系统调用号常量的输出文件。
* `-o_syscall zsyscall_zos_s390x.go`: 指定生成的系统调用封装函数的输出文件 (当前分析的文件)。
* `-i_syscall syscall_zos_s390x.go`: 指定包含系统调用定义信息的输入文件。
* `-o_asm zsymaddr_zos_s390x.s`: 指定生成的汇编符号地址文件的输出文件。

**使用者易犯错的点:**

1. **不正确的类型转换:**  系统调用通常需要特定的数据类型和大小，错误的类型转换 (特别是在使用 `unsafe.Pointer` 时) 可能导致程序崩溃或未定义的行为。例如，传递了错误的结构体大小或者是指向错误内存区域的指针。
2. **缓冲区大小不匹配:** 在 `read` 和 `write` 等操作中，提供的缓冲区大小与实际要读取或写入的数据量不匹配可能导致数据丢失或溢出。
3. **文件描述符无效:**  如果使用了已经关闭或者无效的文件描述符，系统调用将会失败。
4. **忽略错误返回值:**  所有的系统调用都可能返回错误，忽略这些错误返回值会导致程序在遇到问题时无法正确处理。
5. **不理解系统调用的语义:** 错误地使用系统调用，例如在不应该使用阻塞式 I/O 的场景下使用了阻塞式调用，或者对某些权限有限制的系统调用没有做相应的权限检查。
6. **在不安全的上下文中使用 `unsafe` 包:**  过度或不当使用 `unsafe` 包会破坏 Go 语言的内存安全保证，导致难以调试的错误。

**总结:**

总而言之，`zsyscall_zos_s390x.go` 是 Go 语言在 z/OS s390x 平台上提供底层操作系统接口的关键部分。它封装了大量的系统调用，使得 Go 程序能够执行诸如文件操作、进程管理、网络通信等底层任务。 由于它涉及到与操作系统内核的直接交互，因此使用时需要格外小心，并充分理解各个系统调用的功能和限制。

Prompt: 
```
这是路径为go/src/cmd/vendor/golang.org/x/sys/unix/zsyscall_zos_s390x.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
这是第1部分，共2部分，请归纳一下它的功能

"""
// go run mksyscall_zos_s390x.go -o_sysnum zsysnum_zos_s390x.go -o_syscall zsyscall_zos_s390x.go -i_syscall syscall_zos_s390x.go -o_asm zsymaddr_zos_s390x.s
// Code generated by the command above; see README.md. DO NOT EDIT.

//go:build zos && s390x

package unix

import (
	"runtime"
	"syscall"
	"unsafe"
)

var _ syscall.Errno

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fcntl(fd int, cmd int, arg int) (val int, err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_FCNTL<<4, uintptr(fd), uintptr(cmd), uintptr(arg))
	runtime.ExitSyscall()
	val = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_Flistxattr(fd int, dest []byte) (sz int, err error) {
	var _p0 unsafe.Pointer
	if len(dest) > 0 {
		_p0 = unsafe.Pointer(&dest[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___FLISTXATTR_A<<4, uintptr(fd), uintptr(_p0), uintptr(len(dest)))
	runtime.ExitSyscall()
	sz = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_FlistxattrAddr() *(func(fd int, dest []byte) (sz int, err error))

var Flistxattr = enter_Flistxattr

func enter_Flistxattr(fd int, dest []byte) (sz int, err error) {
	funcref := get_FlistxattrAddr()
	if funcptrtest(GetZosLibVec()+SYS___FLISTXATTR_A<<4, "") == 0 {
		*funcref = impl_Flistxattr
	} else {
		*funcref = error_Flistxattr
	}
	return (*funcref)(fd, dest)
}

func error_Flistxattr(fd int, dest []byte) (sz int, err error) {
	sz = -1
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_Fremovexattr(fd int, attr string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(attr)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___FREMOVEXATTR_A<<4, uintptr(fd), uintptr(unsafe.Pointer(_p0)))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_FremovexattrAddr() *(func(fd int, attr string) (err error))

var Fremovexattr = enter_Fremovexattr

func enter_Fremovexattr(fd int, attr string) (err error) {
	funcref := get_FremovexattrAddr()
	if funcptrtest(GetZosLibVec()+SYS___FREMOVEXATTR_A<<4, "") == 0 {
		*funcref = impl_Fremovexattr
	} else {
		*funcref = error_Fremovexattr
	}
	return (*funcref)(fd, attr)
}

func error_Fremovexattr(fd int, attr string) (err error) {
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func read(fd int, p []byte) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_READ<<4, uintptr(fd), uintptr(_p0), uintptr(len(p)))
	runtime.ExitSyscall()
	n = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func write(fd int, p []byte) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_WRITE<<4, uintptr(fd), uintptr(_p0), uintptr(len(p)))
	runtime.ExitSyscall()
	n = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_Fgetxattr(fd int, attr string, dest []byte) (sz int, err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(attr)
	if err != nil {
		return
	}
	var _p1 unsafe.Pointer
	if len(dest) > 0 {
		_p1 = unsafe.Pointer(&dest[0])
	} else {
		_p1 = unsafe.Pointer(&_zero)
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___FGETXATTR_A<<4, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))
	runtime.ExitSyscall()
	sz = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_FgetxattrAddr() *(func(fd int, attr string, dest []byte) (sz int, err error))

var Fgetxattr = enter_Fgetxattr

func enter_Fgetxattr(fd int, attr string, dest []byte) (sz int, err error) {
	funcref := get_FgetxattrAddr()
	if funcptrtest(GetZosLibVec()+SYS___FGETXATTR_A<<4, "") == 0 {
		*funcref = impl_Fgetxattr
	} else {
		*funcref = error_Fgetxattr
	}
	return (*funcref)(fd, attr, dest)
}

func error_Fgetxattr(fd int, attr string, dest []byte) (sz int, err error) {
	sz = -1
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_Fsetxattr(fd int, attr string, data []byte, flag int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(attr)
	if err != nil {
		return
	}
	var _p1 unsafe.Pointer
	if len(data) > 0 {
		_p1 = unsafe.Pointer(&data[0])
	} else {
		_p1 = unsafe.Pointer(&_zero)
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___FSETXATTR_A<<4, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(data)), uintptr(flag))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_FsetxattrAddr() *(func(fd int, attr string, data []byte, flag int) (err error))

var Fsetxattr = enter_Fsetxattr

func enter_Fsetxattr(fd int, attr string, data []byte, flag int) (err error) {
	funcref := get_FsetxattrAddr()
	if funcptrtest(GetZosLibVec()+SYS___FSETXATTR_A<<4, "") == 0 {
		*funcref = impl_Fsetxattr
	} else {
		*funcref = error_Fsetxattr
	}
	return (*funcref)(fd, attr, data, flag)
}

func error_Fsetxattr(fd int, attr string, data []byte, flag int) (err error) {
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___ACCEPT_A<<4, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
	runtime.ExitSyscall()
	fd = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___ACCEPT4_A<<4, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags))
	runtime.ExitSyscall()
	fd = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_accept4Addr() *(func(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error))

var accept4 = enter_accept4

func enter_accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) {
	funcref := get_accept4Addr()
	if funcptrtest(GetZosLibVec()+SYS___ACCEPT4_A<<4, "") == 0 {
		*funcref = impl_accept4
	} else {
		*funcref = error_accept4
	}
	return (*funcref)(s, rsa, addrlen, flags)
}

func error_accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) {
	fd = -1
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___BIND_A<<4, uintptr(s), uintptr(addr), uintptr(addrlen))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___CONNECT_A<<4, uintptr(s), uintptr(addr), uintptr(addrlen))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getgroups(n int, list *_Gid_t) (nn int, err error) {
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_GETGROUPS<<4, uintptr(n), uintptr(unsafe.Pointer(list)))
	nn = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func setgroups(n int, list *_Gid_t) (err error) {
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_SETGROUPS<<4, uintptr(n), uintptr(unsafe.Pointer(list)))
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_GETSOCKOPT<<4, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_SETSOCKOPT<<4, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func socket(domain int, typ int, proto int) (fd int, err error) {
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_SOCKET<<4, uintptr(domain), uintptr(typ), uintptr(proto))
	fd = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func socketpair(domain int, typ int, proto int, fd *[2]int32) (err error) {
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_SOCKETPAIR<<4, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)))
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) {
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___GETPEERNAME_A<<4, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) {
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___GETSOCKNAME_A<<4, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_Removexattr(path string, attr string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	var _p1 *byte
	_p1, err = BytePtrFromString(attr)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___REMOVEXATTR_A<<4, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_RemovexattrAddr() *(func(path string, attr string) (err error))

var Removexattr = enter_Removexattr

func enter_Removexattr(path string, attr string) (err error) {
	funcref := get_RemovexattrAddr()
	if funcptrtest(GetZosLibVec()+SYS___REMOVEXATTR_A<<4, "") == 0 {
		*funcref = impl_Removexattr
	} else {
		*funcref = error_Removexattr
	}
	return (*funcref)(path, attr)
}

func error_Removexattr(path string, attr string) (err error) {
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___RECVFROM_A<<4, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))
	runtime.ExitSyscall()
	n = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func sendto(s int, buf []byte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) {
	var _p0 unsafe.Pointer
	if len(buf) > 0 {
		_p0 = unsafe.Pointer(&buf[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___SENDTO_A<<4, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func recvmsg(s int, msg *Msghdr, flags int) (n int, err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___RECVMSG_A<<4, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))
	runtime.ExitSyscall()
	n = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func sendmsg(s int, msg *Msghdr, flags int) (n int, err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___SENDMSG_A<<4, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))
	runtime.ExitSyscall()
	n = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_MMAP<<4, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flag), uintptr(fd), uintptr(pos))
	runtime.ExitSyscall()
	ret = uintptr(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func munmap(addr uintptr, length uintptr) (err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_MUNMAP<<4, uintptr(addr), uintptr(length))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func ioctl(fd int, req int, arg uintptr) (err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_IOCTL<<4, uintptr(fd), uintptr(req), uintptr(arg))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func ioctlPtr(fd int, req int, arg unsafe.Pointer) (err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_IOCTL<<4, uintptr(fd), uintptr(req), uintptr(arg))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func shmat(id int, addr uintptr, flag int) (ret uintptr, err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_SHMAT<<4, uintptr(id), uintptr(addr), uintptr(flag))
	runtime.ExitSyscall()
	ret = uintptr(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func shmctl(id int, cmd int, buf *SysvShmDesc) (result int, err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_SHMCTL64<<4, uintptr(id), uintptr(cmd), uintptr(unsafe.Pointer(buf)))
	runtime.ExitSyscall()
	result = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func shmdt(addr uintptr) (err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_SHMDT<<4, uintptr(addr))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func shmget(key int, size int, flag int) (id int, err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_SHMGET<<4, uintptr(key), uintptr(size), uintptr(flag))
	runtime.ExitSyscall()
	id = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Access(path string, mode uint32) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___ACCESS_A<<4, uintptr(unsafe.Pointer(_p0)), uintptr(mode))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Chdir(path string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___CHDIR_A<<4, uintptr(unsafe.Pointer(_p0)))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Chown(path string, uid int, gid int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___CHOWN_A<<4, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Chmod(path string, mode uint32) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___CHMOD_A<<4, uintptr(unsafe.Pointer(_p0)), uintptr(mode))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Creat(path string, mode uint32) (fd int, err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___CREAT_A<<4, uintptr(unsafe.Pointer(_p0)), uintptr(mode))
	runtime.ExitSyscall()
	fd = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Dup(oldfd int) (fd int, err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_DUP<<4, uintptr(oldfd))
	runtime.ExitSyscall()
	fd = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Dup2(oldfd int, newfd int) (err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_DUP2<<4, uintptr(oldfd), uintptr(newfd))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_Dup3(oldfd int, newfd int, flags int) (err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_DUP3<<4, uintptr(oldfd), uintptr(newfd), uintptr(flags))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_Dup3Addr() *(func(oldfd int, newfd int, flags int) (err error))

var Dup3 = enter_Dup3

func enter_Dup3(oldfd int, newfd int, flags int) (err error) {
	funcref := get_Dup3Addr()
	if funcptrtest(GetZosLibVec()+SYS_DUP3<<4, "") == 0 {
		*funcref = impl_Dup3
	} else {
		*funcref = error_Dup3
	}
	return (*funcref)(oldfd, newfd, flags)
}

func error_Dup3(oldfd int, newfd int, flags int) (err error) {
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_Dirfd(dirp uintptr) (fd int, err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_DIRFD<<4, uintptr(dirp))
	runtime.ExitSyscall()
	fd = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_DirfdAddr() *(func(dirp uintptr) (fd int, err error))

var Dirfd = enter_Dirfd

func enter_Dirfd(dirp uintptr) (fd int, err error) {
	funcref := get_DirfdAddr()
	if funcptrtest(GetZosLibVec()+SYS_DIRFD<<4, "") == 0 {
		*funcref = impl_Dirfd
	} else {
		*funcref = error_Dirfd
	}
	return (*funcref)(dirp)
}

func error_Dirfd(dirp uintptr) (fd int, err error) {
	fd = -1
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_EpollCreate(size int) (fd int, err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_EPOLL_CREATE<<4, uintptr(size))
	runtime.ExitSyscall()
	fd = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_EpollCreateAddr() *(func(size int) (fd int, err error))

var EpollCreate = enter_EpollCreate

func enter_EpollCreate(size int) (fd int, err error) {
	funcref := get_EpollCreateAddr()
	if funcptrtest(GetZosLibVec()+SYS_EPOLL_CREATE<<4, "") == 0 {
		*funcref = impl_EpollCreate
	} else {
		*funcref = error_EpollCreate
	}
	return (*funcref)(size)
}

func error_EpollCreate(size int) (fd int, err error) {
	fd = -1
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_EpollCreate1(flags int) (fd int, err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_EPOLL_CREATE1<<4, uintptr(flags))
	runtime.ExitSyscall()
	fd = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_EpollCreate1Addr() *(func(flags int) (fd int, err error))

var EpollCreate1 = enter_EpollCreate1

func enter_EpollCreate1(flags int) (fd int, err error) {
	funcref := get_EpollCreate1Addr()
	if funcptrtest(GetZosLibVec()+SYS_EPOLL_CREATE1<<4, "") == 0 {
		*funcref = impl_EpollCreate1
	} else {
		*funcref = error_EpollCreate1
	}
	return (*funcref)(flags)
}

func error_EpollCreate1(flags int) (fd int, err error) {
	fd = -1
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_EPOLL_CTL<<4, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_EpollCtlAddr() *(func(epfd int, op int, fd int, event *EpollEvent) (err error))

var EpollCtl = enter_EpollCtl

func enter_EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error) {
	funcref := get_EpollCtlAddr()
	if funcptrtest(GetZosLibVec()+SYS_EPOLL_CTL<<4, "") == 0 {
		*funcref = impl_EpollCtl
	} else {
		*funcref = error_EpollCtl
	}
	return (*funcref)(epfd, op, fd, event)
}

func error_EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error) {
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_EpollPwait(epfd int, events []EpollEvent, msec int, sigmask *int) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(events) > 0 {
		_p0 = unsafe.Pointer(&events[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_EPOLL_PWAIT<<4, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec), uintptr(unsafe.Pointer(sigmask)))
	runtime.ExitSyscall()
	n = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_EpollPwaitAddr() *(func(epfd int, events []EpollEvent, msec int, sigmask *int) (n int, err error))

var EpollPwait = enter_EpollPwait

func enter_EpollPwait(epfd int, events []EpollEvent, msec int, sigmask *int) (n int, err error) {
	funcref := get_EpollPwaitAddr()
	if funcptrtest(GetZosLibVec()+SYS_EPOLL_PWAIT<<4, "") == 0 {
		*funcref = impl_EpollPwait
	} else {
		*funcref = error_EpollPwait
	}
	return (*funcref)(epfd, events, msec, sigmask)
}

func error_EpollPwait(epfd int, events []EpollEvent, msec int, sigmask *int) (n int, err error) {
	n = -1
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_EpollWait(epfd int, events []EpollEvent, msec int) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(events) > 0 {
		_p0 = unsafe.Pointer(&events[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_EPOLL_WAIT<<4, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec))
	runtime.ExitSyscall()
	n = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_EpollWaitAddr() *(func(epfd int, events []EpollEvent, msec int) (n int, err error))

var EpollWait = enter_EpollWait

func enter_EpollWait(epfd int, events []EpollEvent, msec int) (n int, err error) {
	funcref := get_EpollWaitAddr()
	if funcptrtest(GetZosLibVec()+SYS_EPOLL_WAIT<<4, "") == 0 {
		*funcref = impl_EpollWait
	} else {
		*funcref = error_EpollWait
	}
	return (*funcref)(epfd, events, msec)
}

func error_EpollWait(epfd int, events []EpollEvent, msec int) (n int, err error) {
	n = -1
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Errno2() (er2 int) {
	runtime.EnterSyscall()
	r0, _, _ := CallLeFuncWithErr(GetZosLibVec() + SYS___ERRNO2<<4)
	runtime.ExitSyscall()
	er2 = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_Eventfd(initval uint, flags int) (fd int, err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_EVENTFD<<4, uintptr(initval), uintptr(flags))
	runtime.ExitSyscall()
	fd = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_EventfdAddr() *(func(initval uint, flags int) (fd int, err error))

var Eventfd = enter_Eventfd

func enter_Eventfd(initval uint, flags int) (fd int, err error) {
	funcref := get_EventfdAddr()
	if funcptrtest(GetZosLibVec()+SYS_EVENTFD<<4, "") == 0 {
		*funcref = impl_Eventfd
	} else {
		*funcref = error_Eventfd
	}
	return (*funcref)(initval, flags)
}

func error_Eventfd(initval uint, flags int) (fd int, err error) {
	fd = -1
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Exit(code int) {
	runtime.EnterSyscall()
	CallLeFuncWithErr(GetZosLibVec()+SYS_EXIT<<4, uintptr(code))
	runtime.ExitSyscall()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_Faccessat(dirfd int, path string, mode uint32, flags int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___FACCESSAT_A<<4, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_FaccessatAddr() *(func(dirfd int, path string, mode uint32, flags int) (err error))

var Faccessat = enter_Faccessat

func enter_Faccessat(dirfd int, path string, mode uint32, flags int) (err error) {
	funcref := get_FaccessatAddr()
	if funcptrtest(GetZosLibVec()+SYS___FACCESSAT_A<<4, "") == 0 {
		*funcref = impl_Faccessat
	} else {
		*funcref = error_Faccessat
	}
	return (*funcref)(dirfd, path, mode, flags)
}

func error_Faccessat(dirfd int, path string, mode uint32, flags int) (err error) {
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fchdir(fd int) (err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_FCHDIR<<4, uintptr(fd))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fchmod(fd int, mode uint32) (err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_FCHMOD<<4, uintptr(fd), uintptr(mode))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___FCHMODAT_A<<4, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_FchmodatAddr() *(func(dirfd int, path string, mode uint32, flags int) (err error))

var Fchmodat = enter_Fchmodat

func enter_Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) {
	funcref := get_FchmodatAddr()
	if funcptrtest(GetZosLibVec()+SYS___FCHMODAT_A<<4, "") == 0 {
		*funcref = impl_Fchmodat
	} else {
		*funcref = error_Fchmodat
	}
	return (*funcref)(dirfd, path, mode, flags)
}

func error_Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) {
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fchown(fd int, uid int, gid int) (err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_FCHOWN<<4, uintptr(fd), uintptr(uid), uintptr(gid))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_Fchownat(fd int, path string, uid int, gid int, flags int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___FCHOWNAT_A<<4, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_FchownatAddr() *(func(fd int, path string, uid int, gid int, flags int) (err error))

var Fchownat = enter_Fchownat

func enter_Fchownat(fd int, path string, uid int, gid int, flags int) (err error) {
	funcref := get_FchownatAddr()
	if funcptrtest(GetZosLibVec()+SYS___FCHOWNAT_A<<4, "") == 0 {
		*funcref = impl_Fchownat
	} else {
		*funcref = error_Fchownat
	}
	return (*funcref)(fd, path, uid, gid, flags)
}

func error_Fchownat(fd int, path string, uid int, gid int, flags int) (err error) {
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func FcntlInt(fd uintptr, cmd int, arg int) (retval int, err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_FCNTL<<4, uintptr(fd), uintptr(cmd), uintptr(arg))
	runtime.ExitSyscall()
	retval = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_Fdatasync(fd int) (err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_FDATASYNC<<4, uintptr(fd))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_FdatasyncAddr() *(func(fd int) (err error))

var Fdatasync = enter_Fdatasync

func enter_Fdatasync(fd int) (err error) {
	funcref := get_FdatasyncAddr()
	if funcptrtest(GetZosLibVec()+SYS_FDATASYNC<<4, "") == 0 {
		*funcref = impl_Fdatasync
	} else {
		*funcref = error_Fdatasync
	}
	return (*funcref)(fd)
}

func error_Fdatasync(fd int) (err error) {
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fstat(fd int, stat *Stat_LE_t) (err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_FSTAT<<4, uintptr(fd), uintptr(unsafe.Pointer(stat)))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_fstatat(dirfd int, path string, stat *Stat_LE_t, flags int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___FSTATAT_A<<4, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_fstatatAddr() *(func(dirfd int, path string, stat *Stat_LE_t, flags int) (err error))

var fstatat = enter_fstatat

func enter_fstatat(dirfd int, path string, stat *Stat_LE_t, flags int) (err error) {
	funcref := get_fstatatAddr()
	if funcptrtest(GetZosLibVec()+SYS___FSTATAT_A<<4, "") == 0 {
		*funcref = impl_fstatat
	} else {
		*funcref = error_fstatat
	}
	return (*funcref)(dirfd, path, stat, flags)
}

func error_fstatat(dirfd int, path string, stat *Stat_LE_t, flags int) (err error) {
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_Lgetxattr(link string, attr string, dest []byte) (sz int, err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(link)
	if err != nil {
		return
	}
	var _p1 *byte
	_p1, err = BytePtrFromString(attr)
	if err != nil {
		return
	}
	var _p2 unsafe.Pointer
	if len(dest) > 0 {
		_p2 = unsafe.Pointer(&dest[0])
	} else {
		_p2 = unsafe.Pointer(&_zero)
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___LGETXATTR_A<<4, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)))
	runtime.ExitSyscall()
	sz = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_LgetxattrAddr() *(func(link string, attr string, dest []byte) (sz int, err error))

var Lgetxattr = enter_Lgetxattr

func enter_Lgetxattr(link string, attr string, dest []byte) (sz int, err error) {
	funcref := get_LgetxattrAddr()
	if funcptrtest(GetZosLibVec()+SYS___LGETXATTR_A<<4, "") == 0 {
		*funcref = impl_Lgetxattr
	} else {
		*funcref = error_Lgetxattr
	}
	return (*funcref)(link, attr, dest)
}

func error_Lgetxattr(link string, attr string, dest []byte) (sz int, err error) {
	sz = -1
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_Lsetxattr(path string, attr string, data []byte, flags int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	var _p1 *byte
	_p1, err = BytePtrFromString(attr)
	if err != nil {
		return
	}
	var _p2 unsafe.Pointer
	if len(data) > 0 {
		_p2 = unsafe.Pointer(&data[0])
	} else {
		_p2 = unsafe.Pointer(&_zero)
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___LSETXATTR_A<<4, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_LsetxattrAddr() *(func(path string, attr string, data []byte, flags int) (err error))

var Lsetxattr = enter_Lsetxattr

func enter_Lsetxattr(path string, attr string, data []byte, flags int) (err error) {
	funcref := get_LsetxattrAddr()
	if funcptrtest(GetZosLibVec()+SYS___LSETXATTR_A<<4, "") == 0 {
		*funcref = impl_Lsetxattr
	} else {
		*funcref = error_Lsetxattr
	}
	return (*funcref)(path, attr, data, flags)
}

func error_Lsetxattr(path string, attr string, data []byte, flags int) (err error) {
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_Fstatfs(fd int, buf *Statfs_t) (err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_FSTATFS<<4, uintptr(fd), uintptr(unsafe.Pointer(buf)))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_FstatfsAddr() *(func(fd int, buf *Statfs_t) (err error))

var Fstatfs = enter_Fstatfs

func enter_Fstatfs(fd int, buf *Statfs_t) (err error) {
	funcref := get_FstatfsAddr()
	if funcptrtest(GetZosLibVec()+SYS_FSTATFS<<4, "") == 0 {
		*funcref = impl_Fstatfs
	} else {
		*funcref = error_Fstatfs
	}
	return (*funcref)(fd, buf)
}

func error_Fstatfs(fd int, buf *Statfs_t) (err error) {
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fstatvfs(fd int, stat *Statvfs_t) (err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_FSTATVFS<<4, uintptr(fd), uintptr(unsafe.Pointer(stat)))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fsync(fd int) (err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_FSYNC<<4, uintptr(fd))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_Futimes(fd int, tv []Timeval) (err error) {
	var _p0 unsafe.Pointer
	if len(tv) > 0 {
		_p0 = unsafe.Pointer(&tv[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_FUTIMES<<4, uintptr(fd), uintptr(_p0), uintptr(len(tv)))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_FutimesAddr() *(func(fd int, tv []Timeval) (err error))

var Futimes = enter_Futimes

func enter_Futimes(fd int, tv []Timeval) (err error) {
	funcref := get_FutimesAddr()
	if funcptrtest(GetZosLibVec()+SYS_FUTIMES<<4, "") == 0 {
		*funcref = impl_Futimes
	} else {
		*funcref = error_Futimes
	}
	return (*funcref)(fd, tv)
}

func error_Futimes(fd int, tv []Timeval) (err error) {
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_Futimesat(dirfd int, path string, tv []Timeval) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	var _p1 unsafe.Pointer
	if len(tv) > 0 {
		_p1 = unsafe.Pointer(&tv[0])
	} else {
		_p1 = unsafe.Pointer(&_zero)
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___FUTIMESAT_A<<4, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(tv)))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_FutimesatAddr() *(func(dirfd int, path string, tv []Timeval) (err error))

var Futimesat = enter_Futimesat

func enter_Futimesat(dirfd int, path string, tv []Timeval) (err error) {
	funcref := get_FutimesatAddr()
	if funcptrtest(GetZosLibVec()+SYS___FUTIMESAT_A<<4, "") == 0 {
		*funcref = impl_Futimesat
	} else {
		*funcref = error_Futimesat
	}
	return (*funcref)(dirfd, path, tv)
}

func error_Futimesat(dirfd int, path string, tv []Timeval) (err error) {
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Ftruncate(fd int, length int64) (err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_FTRUNCATE<<4, uintptr(fd), uintptr(length))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_Getrandom(buf []byte, flags int) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(buf) > 0 {
		_p0 = unsafe.Pointer(&buf[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_GETRANDOM<<4, uintptr(_p0), uintptr(len(buf)), uintptr(flags))
	runtime.ExitSyscall()
	n = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_GetrandomAddr() *(func(buf []byte, flags int) (n int, err error))

var Getrandom = enter_Getrandom

func enter_Getrandom(buf []byte, flags int) (n int, err error) {
	funcref := get_GetrandomAddr()
	if funcptrtest(GetZosLibVec()+SYS_GETRANDOM<<4, "") == 0 {
		*funcref = impl_Getrandom
	} else {
		*funcref = error_Getrandom
	}
	return (*funcref)(buf, flags)
}

func error_Getrandom(buf []byte, flags int) (n int, err error) {
	n = -1
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_InotifyInit() (fd int, err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec() + SYS_INOTIFY_INIT<<4)
	runtime.ExitSyscall()
	fd = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_InotifyInitAddr() *(func() (fd int, err error))

var InotifyInit = enter_InotifyInit

func enter_InotifyInit() (fd int, err error) {
	funcref := get_InotifyInitAddr()
	if funcptrtest(GetZosLibVec()+SYS_INOTIFY_INIT<<4, "") == 0 {
		*funcref = impl_InotifyInit
	} else {
		*funcref = error_InotifyInit
	}
	return (*funcref)()
}

func error_InotifyInit() (fd int, err error) {
	fd = -1
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_InotifyInit1(flags int) (fd int, err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_INOTIFY_INIT1<<4, uintptr(flags))
	runtime.ExitSyscall()
	fd = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_InotifyInit1Addr() *(func(flags int) (fd int, err error))

var InotifyInit1 = enter_InotifyInit1

func enter_InotifyInit1(flags int) (fd int, err error) {
	funcref := get_InotifyInit1Addr()
	if funcptrtest(GetZosLibVec()+SYS_INOTIFY_INIT1<<4, "") == 0 {
		*funcref = impl_InotifyInit1
	} else {
		*funcref = error_InotifyInit1
	}
	return (*funcref)(flags)
}

func error_InotifyInit1(flags int) (fd int, err error) {
	fd = -1
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(pathname)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___INOTIFY_ADD_WATCH_A<<4, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(mask))
	runtime.ExitSyscall()
	watchdesc = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_InotifyAddWatchAddr() *(func(fd int, pathname string, mask uint32) (watchdesc int, err error))

var InotifyAddWatch = enter_InotifyAddWatch

func enter_InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) {
	funcref := get_InotifyAddWatchAddr()
	if funcptrtest(GetZosLibVec()+SYS___INOTIFY_ADD_WATCH_A<<4, "") == 0 {
		*funcref = impl_InotifyAddWatch
	} else {
		*funcref = error_InotifyAddWatch
	}
	return (*funcref)(fd, pathname, mask)
}

func error_InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) {
	watchdesc = -1
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_InotifyRmWatch(fd int, watchdesc uint32) (success int, err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_INOTIFY_RM_WATCH<<4, uintptr(fd), uintptr(watchdesc))
	runtime.ExitSyscall()
	success = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_InotifyRmWatchAddr() *(func(fd int, watchdesc uint32) (success int, err error))

var InotifyRmWatch = enter_InotifyRmWatch

func enter_InotifyRmWatch(fd int, watchdesc uint32) (success int, err error) {
	funcref := get_InotifyRmWatchAddr()
	if funcptrtest(GetZosLibVec()+SYS_INOTIFY_RM_WATCH<<4, "") == 0 {
		*funcref = impl_InotifyRmWatch
	} else {
		*funcref = error_InotifyRmWatch
	}
	return (*funcref)(fd, watchdesc)
}

func error_InotifyRmWatch(fd int, watchdesc uint32) (success int, err error) {
	success = -1
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_Listxattr(path string, dest []byte) (sz int, err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	var _p1 unsafe.Pointer
	if len(dest) > 0 {
		_p1 = unsafe.Pointer(&dest[0])
	} else {
		_p1 = unsafe.Pointer(&_zero)
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___LISTXATTR_A<<4, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))
	runtime.ExitSyscall()
	sz = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_ListxattrAddr() *(func(path string, dest []byte) (sz int, err error))

var Listxattr = enter_Listxattr

func enter_Listxattr(path string, dest []byte) (sz int, err error) {
	funcref := get_ListxattrAddr()
	if funcptrtest(GetZosLibVec()+SYS___LISTXATTR_A<<4, "") == 0 {
		*funcref = impl_Listxattr
	} else {
		*funcref = error_Listxattr
	}
	return (*funcref)(path, dest)
}

func error_Listxattr(path string, dest []byte) (sz int, err error) {
	sz = -1
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_Llistxattr(path string, dest []byte) (sz int, err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	var _p1 unsafe.Pointer
	if len(dest) > 0 {
		_p1 = unsafe.Pointer(&dest[0])
	} else {
		_p1 = unsafe.Pointer(&_zero)
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___LLISTXATTR_A<<4, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))
	runtime.ExitSyscall()
	sz = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_LlistxattrAddr() *(func(path string, dest []byte) (sz int, err error))

var Llistxattr = enter_Llistxattr

func enter_Llistxattr(path string, dest []byte) (sz int, err error) {
	funcref := get_LlistxattrAddr()
	if funcptrtest(GetZosLibVec()+SYS___LLISTXATTR_A<<4, "") == 0 {
		*funcref = impl_Llistxattr
	} else {
		*funcref = error_Llistxattr
	}
	return (*funcref)(path, dest)
}

func error_Llistxattr(path string, dest []byte) (sz int, err error) {
	sz = -1
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_Lremovexattr(path string, attr string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	var _p1 *byte
	_p1, err = BytePtrFromString(attr)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___LREMOVEXATTR_A<<4, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_LremovexattrAddr() *(func(path string, attr string) (err error))

var Lremovexattr = enter_Lremovexattr

func enter_Lremovexattr(path string, attr string) (err error) {
	funcref := get_LremovexattrAddr()
	if funcptrtest(GetZosLibVec()+SYS___LREMOVEXATTR_A<<4, "") == 0 {
		*funcref = impl_Lremovexattr
	} else {
		*funcref = error_Lremovexattr
	}
	return (*funcref)(path, attr)
}

func error_Lremovexattr(path string, attr string) (err error) {
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_Lutimes(path string, tv []Timeval) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	var _p1 unsafe.Pointer
	if len(tv) > 0 {
		_p1 = unsafe.Pointer(&tv[0])
	} else {
		_p1 = unsafe.Pointer(&_zero)
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___LUTIMES_A<<4, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(tv)))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_LutimesAddr() *(func(path string, tv []Timeval) (err error))

var Lutimes = enter_Lutimes

func enter_Lutimes(path string, tv []Timeval) (err error) {
	funcref := get_LutimesAddr()
	if funcptrtest(GetZosLibVec()+SYS___LUTIMES_A<<4, "") == 0 {
		*funcref = impl_Lutimes
	} else {
		*funcref = error_Lutimes
	}
	return (*funcref)(path, tv)
}

func error_Lutimes(path string, tv []Timeval) (err error) {
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Mprotect(b []byte, prot int) (err error) {
	var _p0 unsafe.Pointer
	if len(b) > 0 {
		_p0 = unsafe.Pointer(&b[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_MPROTECT<<4, uintptr(_p0), uintptr(len(b)), uintptr(prot))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Msync(b []byte, flags int) (err error) {
	var _p0 unsafe.Pointer
	if len(b) > 0 {
		_p0 = unsafe.Pointer(&b[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_MSYNC<<4, uintptr(_p0), uintptr(len(b)), uintptr(flags))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Console2(cmsg *ConsMsg2, modstr *byte, concmd *uint32) (err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___CONSOLE2<<4, uintptr(unsafe.Pointer(cmsg)), uintptr(unsafe.Pointer(modstr)), uintptr(unsafe.Pointer(concmd)))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Poll(fds []PollFd, timeout int) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(fds) > 0 {
		_p0 = unsafe.Pointer(&fds[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_POLL<<4, uintptr(_p0), uintptr(len(fds)), uintptr(timeout))
	runtime.ExitSyscall()
	n = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Readdir_r(dirp uintptr, entry *direntLE, result **direntLE) (err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___READDIR_R_A<<4, uintptr(dirp), uintptr(unsafe.Pointer(entry)), uintptr(unsafe.Pointer(result)))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_Statfs(path string, buf *Statfs_t) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___STATFS_A<<4, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_StatfsAddr() *(func(path string, buf *Statfs_t) (err error))

var Statfs = enter_Statfs

func enter_Statfs(path string, buf *Statfs_t) (err error) {
	funcref := get_StatfsAddr()
	if funcptrtest(GetZosLibVec()+SYS___STATFS_A<<4, "") == 0 {
		*funcref = impl_Statfs
	} else {
		*funcref = error_Statfs
	}
	return (*funcref)(path, buf)
}

func error_Statfs(path string, buf *Statfs_t) (err error) {
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_Syncfs(fd int) (err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_SYNCFS<<4, uintptr(fd))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_SyncfsAddr() *(func(fd int) (err error))

var Syncfs = enter_Syncfs

func enter_Syncfs(fd int) (err error) {
	funcref := get_SyncfsAddr()
	if funcptrtest(GetZosLibVec()+SYS_SYNCFS<<4, "") == 0 {
		*funcref = impl_Syncfs
	} else {
		*funcref = error_Syncfs
	}
	return (*funcref)(fd)
}

func error_Syncfs(fd int) (err error) {
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Times(tms *Tms) (ticks uintptr, err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_TIMES<<4, uintptr(unsafe.Pointer(tms)))
	runtime.ExitSyscall()
	ticks = uintptr(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func W_Getmntent(buff *byte, size int) (lastsys int, err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_W_GETMNTENT<<4, uintptr(unsafe.Pointer(buff)), uintptr(size))
	runtime.ExitSyscall()
	lastsys = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func W_Getmntent_A(buff *byte, size int) (lastsys int, err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___W_GETMNTENT_A<<4, uintptr(unsafe.Pointer(buff)), uintptr(size))
	runtime.ExitSyscall()
	lastsys = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func mount_LE(path string, filesystem string, fstype string, mtm uint32, parmlen int32, parm string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	var _p1 *byte
	_p1, err = BytePtrFromString(filesystem)
	if err != nil {
		return
	}
	var _p2 *byte
	_p2, err = BytePtrFromString(fstype)
	if err != nil {
		return
	}
	var _p3 *byte
	_p3, err = BytePtrFromString(parm)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___MOUNT_A<<4, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(mtm), uintptr(parmlen), uintptr(unsafe.Pointer(_p3)))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func unmount_LE(filesystem string, mtm int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(filesystem)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___UMOUNT_A<<4, uintptr(unsafe.Pointer(_p0)), uintptr(mtm))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Chroot(path string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___CHROOT_A<<4, uintptr(unsafe.Pointer(_p0)))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Select(nmsgsfds int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (ret int, err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_SELECT<<4, uintptr(nmsgsfds), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)))
	runtime.ExitSyscall()
	ret = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Uname(buf *Utsname) (err error) {
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_____OSNAME_A<<4, uintptr(unsafe.Pointer(buf)))
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_Unshare(flags int) (err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_UNSHARE<<4, uintptr(flags))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_UnshareAddr() *(func(flags int) (err error))

var Unshare = enter_Unshare

func enter_Unshare(flags int) (err error) {
	funcref := get_UnshareAddr()
	if funcptrtest(GetZosLibVec()+SYS_UNSHARE<<4, "") == 0 {
		*funcref = impl_Unshare
	} else {
		*funcref = error_Unshare
	}
	return (*funcref)(flags)
}

func error_Unshare(flags int) (err error) {
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Gethostname(buf []byte) (err error) {
	var _p0 unsafe.Pointer
	if len(buf) > 0 {
		_p0 = unsafe.Pointer(&buf[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___GETHOSTNAME_A<<4, uintptr(_p0), uintptr(len(buf)))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getgid() (gid int) {
	r0, _, _ := CallLeFuncWithErr(GetZosLibVec() + SYS_GETGID<<4)
	gid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getpid() (pid int) {
	r0, _, _ := CallLeFuncWithErr(GetZosLibVec() + SYS_GETPID<<4)
	pid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getpgid(pid int) (pgid int, err error) {
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_GETPGID<<4, uintptr(pid))
	pgid = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getppid() (pid int) {
	r0, _, _ := CallLeFuncWithErr(GetZosLibVec() + SYS_GETPPID<<4)
	pid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getpriority(which int, who int) (prio int, err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_GETPRIORITY<<4, uintptr(which), uintptr(who))
	runtime.ExitSyscall()
	prio = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getrlimit(resource int, rlim *Rlimit) (err error) {
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_GETRLIMIT<<4, uintptr(resource), uintptr(unsafe.Pointer(rlim)))
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getrusage(who int, rusage *rusage_zos) (err error) {
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_GETRUSAGE<<4, uintptr(who), uintptr(unsafe.Pointer(rusage)))
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getegid() (egid int) {
	runtime.EnterSyscall()
	r0, _, _ := CallLeFuncWithErr(GetZosLibVec() + SYS_GETEGID<<4)
	runtime.ExitSyscall()
	egid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Geteuid() (euid int) {
	runtime.EnterSyscall()
	r0, _, _ := CallLeFuncWithErr(GetZosLibVec() + SYS_GETEUID<<4)
	runtime.ExitSyscall()
	euid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getsid(pid int) (sid int, err error) {
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_GETSID<<4, uintptr(pid))
	sid = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getuid() (uid int) {
	r0, _, _ := CallLeFuncWithErr(GetZosLibVec() + SYS_GETUID<<4)
	uid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Kill(pid int, sig Signal) (err error) {
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_KILL<<4, uintptr(pid), uintptr(sig))
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Lchown(path string, uid int, gid int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___LCHOWN_A<<4, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Link(path string, link string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	var _p1 *byte
	_p1, err = BytePtrFromString(link)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___LINK_A<<4, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_Linkat(oldDirFd int, oldPath string, newDirFd int, newPath string, flags int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(oldPath)
	if err != nil {
		return
	}
	var _p1 *byte
	_p1, err = BytePtrFromString(newPath)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___LINKAT_A<<4, uintptr(oldDirFd), uintptr(unsafe.Pointer(_p0)), uintptr(newDirFd), uintptr(unsafe.Pointer(_p1)), uintptr(flags))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_LinkatAddr() *(func(oldDirFd int, oldPath string, newDirFd int, newPath string, flags int) (err error))

var Linkat = enter_Linkat

func enter_Linkat(oldDirFd int, oldPath string, newDirFd int, newPath string, flags int) (err error) {
	funcref := get_LinkatAddr()
	if funcptrtest(GetZosLibVec()+SYS___LINKAT_A<<4, "") == 0 {
		*funcref = impl_Linkat
	} else {
		*funcref = error_Linkat
	}
	return (*funcref)(oldDirFd, oldPath, newDirFd, newPath, flags)
}

func error_Linkat(oldDirFd int, oldPath string, newDirFd int, newPath string, flags int) (err error) {
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Listen(s int, n int) (err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_LISTEN<<4, uintptr(s), uintptr(n))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func lstat(path string, stat *Stat_LE_t) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___LSTAT_A<<4, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Mkdir(path string, mode uint32) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___MKDIR_A<<4, uintptr(unsafe.Pointer(_p0)), uintptr(mode))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_Mkdirat(dirfd int, path string, mode uint32) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___MKDIRAT_A<<4, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_MkdiratAddr() *(func(dirfd int, path string, mode uint32) (err error))

var Mkdirat = enter_Mkdirat

func enter_Mkdirat(dirfd int, path string, mode uint32) (err error) {
	funcref := get_MkdiratAddr()
	if funcptrtest(GetZosLibVec()+SYS___MKDIRAT_A<<4, "") == 0 {
		*funcref = impl_Mkdirat
	} else {
		*funcref = error_Mkdirat
	}
	return (*funcref)(dirfd, path, mode)
}

func error_Mkdirat(dirfd int, path string, mode uint32) (err error) {
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Mkfifo(path string, mode uint32) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___MKFIFO_A<<4, uintptr(unsafe.Pointer(_p0)), uintptr(mode))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Mknod(path string, mode uint32, dev int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___MKNOD_A<<4, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_Mknodat(dirfd int, path string, mode uint32, dev int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___MKNODAT_A<<4, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_MknodatAddr() *(func(dirfd int, path string, mode uint32, dev int) (err error))

var Mknodat = enter_Mknodat

func enter_Mknodat(dirfd int, path string, mode uint32, dev int) (err error) {
	funcref := get_MknodatAddr()
	if funcptrtest(GetZosLibVec()+SYS___MKNODAT_A<<4, "") == 0 {
		*funcref = impl_Mknodat
	} else {
		*funcref = error_Mknodat
	}
"""




```
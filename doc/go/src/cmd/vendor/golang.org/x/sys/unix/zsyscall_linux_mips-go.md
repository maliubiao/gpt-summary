Response:
Let's break down the thought process for analyzing the given Go code snippet.

**1. Initial Scan and Metadata:**

* **Filename and Path:** The path `go/src/cmd/vendor/golang.org/x/sys/unix/zsyscall_linux_mips.go` immediately tells us this is part of the Go standard library's low-level system call interface, specifically for Linux on the MIPS architecture. The `zsyscall_` prefix suggests automatically generated code.
* **Build Constraints:**  The `//go:build linux && mips` line confirms the target OS and architecture. This code will *only* be compiled and used on Linux systems running on a MIPS processor.
* **Generated Code Comment:**  The comment `// go run mksyscall.go -b32 -arm -tags linux,mips syscall_linux.go syscall_linux_mipsx.go syscall_linux_alarm.go` is crucial. It reveals that the code is generated by the `mksyscall` tool. This means we're looking at Go wrappers around Linux system calls. The `-b32 -arm` part is a bit confusing given the filename, suggesting a possible error or leftover from a previous generation command, since the filename clearly indicates MIPS. However, the `-tags linux,mips` is correct. The listed `syscall_linux*.go` files are likely input to the `mksyscall` tool.
* **Package Declaration:** `package unix` confirms this is part of the `syscall` package's internal `unix` implementation.
* **Import Statement:** `import ("syscall", "unsafe")` indicates the code uses the `syscall` package for core system call handling and `unsafe` for pointer manipulation, which is typical for low-level system interfaces.
* **`var _ syscall.Errno`:** This is a common idiom to ensure the `syscall` package is imported even if `Errno` isn't explicitly used in the immediate code.

**2. Analyzing Individual Functions:**

The core of the analysis involves looking at each function. A pattern emerges quickly:

* **Function Signature:**  Each function has a descriptive name (e.g., `fanotifyMark`, `Fallocate`, `Tee`). The parameters often correspond to the arguments of the underlying Linux system call. They usually return an `error` value.
* **`// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT`:** This repeated comment reinforces the auto-generated nature.
* **`Syscall` Family:**  The functions use `Syscall`, `Syscall6`, `Syscall9`, `RawSyscall`, and `RawSyscallNoError`. These are functions from the `syscall` package that provide the mechanism to invoke Linux system calls. The number in `SyscallN` indicates the number of arguments passed to the system call. `RawSyscall` and `RawSyscallNoError` offer lower-level access, potentially skipping some error checking.
* **System Call Constant:** The first argument to the `Syscall` functions is a constant like `SYS_FANOTIFY_MARK`, `SYS_FALLOCATE`, etc. These are integer constants defined elsewhere (likely in `syscall_linux.go` or a related file) that represent the system call number in the Linux kernel.
* **Argument Conversion:**  Arguments are often converted to `uintptr`. This is necessary because the `Syscall` functions expect arguments in this platform-independent integer type. For 64-bit values (like offsets and lengths), the code often splits them into two `uintptr` arguments using bitwise operations (`>> 32` and masking).
* **Pointer Handling:** The `unsafe.Pointer` type is used to pass pointers to data structures or strings to the system calls. Functions like `BytePtrFromString` are used to convert Go strings to C-style null-terminated byte pointers.
* **Error Handling:** The return value `e1` from the `Syscall` functions represents the raw system call error code. The `errnoErr(e1)` function (defined elsewhere) converts this raw error code into a Go `error` value.
* **Special Cases:** Some functions have specific logic, like `Tee` which combines the 32-bit return values `r0` and `r1` into a 64-bit `n`, or `EpollWait` which handles the conversion of a Go slice to a pointer.

**3. Inferring Functionality:**

By combining the function names and the system call constants, it's possible to deduce the functionality of each Go function. For example:

* `fanotifyMark`: Likely related to the `fanotify` Linux feature for file system event notification.
* `Fallocate`:  Allocates space for a file.
* `Tee`:  Copies data between two file descriptors.
* `EpollWait`: Waits for events on an epoll file descriptor.
* `Fadvise`: Provides advice to the kernel about access patterns for a file.
* `Fchown`, `Lchown`: Changes the owner and group of a file.
* `Ftruncate`, `Truncate`:  Truncates a file to a specified length.
* `Getegid`, `Geteuid`, `Getgid`, `Getuid`: Gets user and group IDs.
* `Listen`:  Listens for connections on a socket.
* `pread`, `pwrite`: Reads and writes to a file at a specific offset.
* `Renameat`: Renames a file relative to a directory file descriptor.
* `Select`:  Multiplexes I/O operations.
* `sendfile`:  Efficiently copies data between file descriptors.
* `setfsgid`, `setfsuid`: Sets file system user and group IDs.
* `Shutdown`: Shuts down part of a full-duplex connection.
* `Splice`: Moves data between two file descriptors.
* `SyncFileRange`: Flushes a range of a file to disk.
* Socket-related functions (`accept4`, `bind`, `connect`, `getsockopt`, `setsockopt`, `socket`, `socketpair`, `getpeername`, `getsockname`, `recvfrom`, `sendto`, `recvmsg`, `sendmsg`): Operations on network sockets.
* Time-related functions (`futimesat`, `Gettimeofday`, `Time`, `Utime`, `utimes`):  Getting and setting file timestamps and the system time.
* Stat-related functions (`Lstat`, `Fstat`, `Fstatat`, `Stat`): Getting file metadata.
* `mmap2`: Maps files or devices into memory.
* `getrlimit`: Gets resource limits.
* `Alarm`: Sets an alarm timer.

**4. Code Example and Assumptions:**

To create a Go code example, the key is to choose a relatively simple and understandable function. `Fallocate` is a good choice. The process involves:

* **Understanding the System Call:** Knowing what `fallocate` does and its arguments is essential (file descriptor, mode, offset, length).
* **Mapping to Go Types:**  Figuring out how to represent these arguments in Go (e.g., `int` for file descriptor, `uint32` for mode).
* **Calling the `unix` Function:**  Using the function from the analyzed code.
* **Error Handling:** Checking the returned `error` value.

**5. Command-Line Argument Processing (and Realization of Irrelevance):**

The initial thought might be to look for command-line argument parsing within this code. However, because this is a low-level system call interface, it *doesn't* handle command-line arguments directly. The command in the comment at the top is about *generating* this code, not how this code is *used*. The users of these functions are other Go programs that *will* parse command-line arguments.

**6. Common Mistakes:**

Identifying common mistakes requires thinking about how developers might misuse these low-level functions. Key areas are:

* **Incorrect Error Handling:** Ignoring the returned `error`.
* **Incorrect Pointer Usage:**  Not understanding how `unsafe.Pointer` works, potential memory safety issues.
* **Integer Overflow/Truncation:**  Mishandling the splitting of 64-bit values.
* **File Descriptor Management:** Not closing file descriptors properly.
* **Understanding System Call Semantics:**  Misinterpreting the behavior of the underlying Linux system call.

By following these steps, we can systematically analyze the given Go code, understand its purpose, provide examples, and identify potential pitfalls. The crucial insight here is recognizing that this is *generated* code wrapping Linux system calls, which significantly simplifies the analysis.
这个Go语言文件 `zsyscall_linux_mips.go` 是在Linux操作系统上为MIPS架构处理器提供系统调用的底层接口。它由 `mksyscall` 工具自动生成，目的是为了让Go程序能够调用Linux内核提供的各种功能。

**功能列举:**

这个文件中的每个函数都对应一个Linux系统调用。 它们的功能包括但不限于：

* **文件操作:**
    * `Fallocate`:  预分配文件空间。
    * `Truncate`, `Ftruncate`:  截断文件到指定长度。
    * `Pread`, `Pwrite`:  在指定偏移量处读取或写入文件。
    * `Renameat`:  原子地重命名文件或目录。
    * `SyncFileRange`:  将文件指定范围的数据同步到磁盘。
    * `Sendfile`:  在两个文件描述符之间高效传输数据。
    * `Splice`:  在两个文件描述符之间移动数据。
    * `Fadvise`:  向内核提供文件访问模式的建议。
* **文件属性操作:**
    * `Fchown`, `Lchown`:  改变文件的所有者和组。
    * `Lstat`, `Fstat`, `Fstatat`, `Stat`:  获取文件状态信息。
    * `Futimesat`, `Utime`, `Utimes`:  设置文件的访问和修改时间。
* **进程和用户:**
    * `Getegid`, `Geteuid`, `Getgid`, `Getuid`:  获取有效的组ID、有效的用户ID、组ID和用户ID。
    * `Setfsgid`, `Setfsuid`:  设置文件系统GID和UID。
    * `Getgroups`, `Setgroups`: 获取和设置当前进程的附加组ID。
* **内存管理:**
    * `Mmap2`:  将文件或设备映射到内存。
* **设备操作:**
    * `Ustat`:  获取文件系统的状态。
    * `Ioperm`, `Iopl`:  设置进程的I/O权限级别（通常需要特权）。
* **时间相关:**
    * `Gettimeofday`:  获取当前时间。
    * `Time`:  获取当前时间戳。
    * `Alarm`:  设置一个定时器，当定时器到期时发送一个信号。
* **网络相关:**
    * `Socket`, `Socketpair`:  创建套接字。
    * `Bind`, `Connect`:  绑定地址到套接字，连接到远程主机。
    * `Listen`:  监听连接请求。
    * `Accept4`:  接受连接请求。
    * `Getpeername`, `Getsockname`:  获取连接的对端地址和本地地址。
    * `Getsockopt`, `Setsockopt`:  获取和设置套接字选项。
    * `Sendto`, `Recvfrom`:  在无连接的套接字上发送和接收数据。
    * `Sendmsg`, `Recvmsg`:  在套接字上发送和接收消息。
    * `Shutdown`:  关闭套接字的发送或接收方向。
* **文件系统事件通知:**
    * `FanotifyMark`:  向 fanotify 文件事件通知系统添加或删除标记。
* **其他:**
    * `Tee`:  在两个管道之间复制数据。
    * `EpollWait`:  等待epoll实例上的事件。
    * `Select`:  同步I/O多路复用。
    * `Pause`:  暂停进程执行，直到接收到信号。

**Go语言功能实现示例:**

这个文件本身是底层实现，通常不会被直接调用。而是被 `syscall` 包或者更高级的网络、文件操作等包所使用。

以下代码展示了如何使用 `syscall` 包调用 `unix.Fallocate` (尽管通常你会使用 `os.Truncate` 或 `os.NewFile` 等更高级的接口):

```go
package main

import (
	"fmt"
	"os"
	"syscall"
	"unsafe"
)

func main() {
	filename := "test_fallocate.txt"
	file, err := os.Create(filename)
	if err != nil {
		fmt.Println("Error creating file:", err)
		return
	}
	defer file.Close()

	fd := int(file.Fd())
	mode := uint32(0) //  No flags specified
	offset := int64(1024) // 预分配从 1KB 开始
	length := int64(2048) // 预分配 2KB

	err = syscall.Fallocate(fd, mode, offset, length)
	if err != nil {
		fmt.Println("Error calling fallocate:", err)
		return
	}

	fmt.Printf("Successfully pre-allocated %d bytes at offset %d for file %s\n", length, offset, filename)

	// 你可以写入文件，预分配的空间会直接可用
	_, err = file.WriteAt([]byte("hello"), offset)
	if err != nil {
		fmt.Println("Error writing to file:", err)
	}
}
```

**假设的输入与输出:**

* **输入:**  执行上述 Go 代码。
* **输出:** 如果 `Fallocate` 系统调用成功，将输出类似: `Successfully pre-allocated 2048 bytes at offset 1024 for file test_fallocate.txt`，并在文件中从 1KB 偏移量开始预留 2KB 的空间。 如果写入成功，文件从 1KB 偏移量开始会包含 "hello"。 如果出错，会输出相应的错误信息。

**代码推理:**

在 `zsyscall_linux_mips.go` 文件中，`Fallocate` 函数的实现如下：

```go
func Fallocate(fd int, mode uint32, off int64, len int64) (err error) {
	_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off>>32), uintptr(off), uintptr(len>>32), uintptr(len))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}
```

* 它接收文件描述符 `fd`，模式 `mode`，偏移量 `off` 和长度 `len` 作为参数。
* 它调用 `Syscall6` 函数，这是 `syscall` 包提供的用于执行带有六个参数的系统调用的底层函数。
* `SYS_FALLOCATE` 是 `syscall` 包中定义的常量，代表 Linux `fallocate` 系统调用的编号。
* `uintptr(fd)`, `uintptr(mode)` 等将参数转换为 `uintptr` 类型，这是进行系统调用时需要的类型。 对于 64 位整数 `off` 和 `len`，它们被拆分成高 32 位 (`off>>32`, `len>>32`) 和低 32 位 (`off`, `len`) 传递，因为 MIPS 是 32 位架构，需要分别传递高低位。
* `e1` 接收系统调用的返回值，如果非零，则表示发生了错误。
* `errnoErr(e1)` 将 Linux 的错误码转换为 Go 的 `error` 类型。

**命令行参数的具体处理:**

这个 `zsyscall_linux_mips.go` 文件本身不处理命令行参数。 它是由 `mksyscall` 工具生成的。  `mksyscall` 工具的命令行参数在文件的头部注释中给出：

```
// go run mksyscall.go -b32 -arm -tags linux,mips syscall_linux.go syscall_linux_mipsx.go syscall_linux_alarm.go
```

* `go run mksyscall.go`:  使用 Go 运行 `mksyscall.go` 脚本。
* `-b32`:  指定目标架构是 32 位。 **注意:** 虽然这里写的是 `-arm`，但文件名是 `zsyscall_linux_mips.go`，并且 `-tags` 中包含了 `mips`，这可能是一个笔误或者在生成过程中调整过。 实际生成的代码是针对 MIPS 架构的。
* `-tags linux,mips`:  指定构建标签，只有在 `linux` 和 `mips` 标签同时满足时，这个文件才会被编译。
* `syscall_linux.go syscall_linux_mipsx.go syscall_linux_alarm.go`: 这些是 `mksyscall` 工具的输入文件，包含了系统调用的定义和结构体等信息。

总的来说，`mksyscall` 工具读取这些输入文件，根据指定的架构和操作系统，生成对应的系统调用包装代码。

**使用者易犯错的点:**

由于这个文件是底层实现，开发者通常不会直接使用它，而是通过 `syscall` 包或者更高级的抽象层来操作。  但是，如果直接使用，容易犯以下错误：

1. **不正确的参数类型或值:**  系统调用对参数的类型和取值范围有严格的要求。 传递错误的类型或超出范围的值可能导致程序崩溃或不可预测的行为。 例如，传递负数给期望非负的文件描述符。

   ```go
   // 错误示例：传递无效的文件描述符
   err := syscall.Fallocate(-1, 0, 0, 1024)
   if err != nil {
       fmt.Println("Error:", err) // 可能会输出 "bad file descriptor" 相关的错误
   }
   ```

2. **忽略错误返回值:** 系统调用可能会失败，并返回错误码。  必须检查错误返回值并进行适当的处理。

   ```go
   fd, err := syscall.Open("nonexistent_file.txt", syscall.O_RDONLY, 0)
   if err != nil {
       fmt.Println("Error opening file:", err)
       // 正确的做法是处理错误，例如创建文件或返回错误
   }
   if fd != -1 {
       syscall.Close(fd)
   }
   ```

3. **不安全地使用 `unsafe.Pointer`:**  直接操作指针是危险的，需要非常小心地管理内存。 错误的指针操作可能导致内存泄漏、数据损坏甚至安全漏洞。 例如，将不兼容的结构体指针传递给系统调用。

4. **不理解系统调用的语义:**  每个系统调用都有其特定的功能和限制。  不理解其工作原理可能导致不正确的程序行为。 例如，错误地使用 `O_NONBLOCK` 标志进行非阻塞 I/O 操作。

5. **架构依赖性:**  这个文件是针对 MIPS 架构的。  直接使用其中的函数在其他架构上会编译失败或者产生未定义的行为。 应该使用 `syscall` 包提供的跨平台接口，或者根据 `GOOS` 和 `GOARCH` 进行条件编译。

总而言之，`zsyscall_linux_mips.go` 是 Go 语言为了在 Linux/MIPS 环境下执行系统调用而自动生成的底层代码。它封装了各种 Linux 系统调用，使得 Go 程序可以通过 `syscall` 包来访问这些内核功能。 使用者通常不需要直接操作这个文件，但了解其功能有助于理解 Go 语言与操作系统底层的交互方式。

### 提示词
```
这是路径为go/src/cmd/vendor/golang.org/x/sys/unix/zsyscall_linux_mips.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
```

### 源代码
```go
// go run mksyscall.go -b32 -arm -tags linux,mips syscall_linux.go syscall_linux_mipsx.go syscall_linux_alarm.go
// Code generated by the command above; see README.md. DO NOT EDIT.

//go:build linux && mips

package unix

import (
	"syscall"
	"unsafe"
)

var _ syscall.Errno

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fanotifyMark(fd int, flags uint, mask uint64, dirFd int, pathname *byte) (err error) {
	_, _, e1 := Syscall6(SYS_FANOTIFY_MARK, uintptr(fd), uintptr(flags), uintptr(mask>>32), uintptr(mask), uintptr(dirFd), uintptr(unsafe.Pointer(pathname)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fallocate(fd int, mode uint32, off int64, len int64) (err error) {
	_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off>>32), uintptr(off), uintptr(len>>32), uintptr(len))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Tee(rfd int, wfd int, len int, flags int) (n int64, err error) {
	r0, r1, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)
	n = int64(int64(r0)<<32 | int64(r1))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func EpollWait(epfd int, events []EpollEvent, msec int) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(events) > 0 {
		_p0 = unsafe.Pointer(&events[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec), 0, 0)
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fadvise(fd int, offset int64, length int64, advice int) (err error) {
	_, _, e1 := Syscall9(SYS_FADVISE64, uintptr(fd), 0, uintptr(offset>>32), uintptr(offset), uintptr(length>>32), uintptr(length), uintptr(advice), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fchown(fd int, uid int, gid int) (err error) {
	_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Ftruncate(fd int, length int64) (err error) {
	_, _, e1 := Syscall6(SYS_FTRUNCATE64, uintptr(fd), 0, uintptr(length>>32), uintptr(length), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getegid() (egid int) {
	r0, _ := RawSyscallNoError(SYS_GETEGID, 0, 0, 0)
	egid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Geteuid() (euid int) {
	r0, _ := RawSyscallNoError(SYS_GETEUID, 0, 0, 0)
	euid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getgid() (gid int) {
	r0, _ := RawSyscallNoError(SYS_GETGID, 0, 0, 0)
	gid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getuid() (uid int) {
	r0, _ := RawSyscallNoError(SYS_GETUID, 0, 0, 0)
	uid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Lchown(path string, uid int, gid int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Listen(s int, n int) (err error) {
	_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(n), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func pread(fd int, p []byte, offset int64) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset>>32), uintptr(offset))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func pwrite(fd int, p []byte, offset int64) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset>>32), uintptr(offset))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(oldpath)
	if err != nil {
		return
	}
	var _p1 *byte
	_p1, err = BytePtrFromString(newpath)
	if err != nil {
		return
	}
	_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) {
	r0, _, e1 := Syscall6(SYS__NEWSELECT, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) {
	r0, _, e1 := Syscall6(SYS_SENDFILE64, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)
	written = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func setfsgid(gid int) (prev int, err error) {
	r0, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)
	prev = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func setfsuid(uid int) (prev int, err error) {
	r0, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)
	prev = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Shutdown(fd int, how int) (err error) {
	_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(fd), uintptr(how), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error) {
	r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func SyncFileRange(fd int, off int64, n int64, flags int) (err error) {
	_, _, e1 := Syscall9(SYS_SYNC_FILE_RANGE, uintptr(fd), 0, uintptr(off>>32), uintptr(off), uintptr(n>>32), uintptr(n), uintptr(flags), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Truncate(path string, length int64) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall6(SYS_TRUNCATE64, uintptr(unsafe.Pointer(_p0)), 0, uintptr(length>>32), uintptr(length), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Ustat(dev int, ubuf *Ustat_t) (err error) {
	_, _, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) {
	r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)
	fd = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) {
	_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) {
	_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getgroups(n int, list *_Gid_t) (nn int, err error) {
	r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)
	nn = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func setgroups(n int, list *_Gid_t) (err error) {
	_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) {
	_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) {
	_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func socket(domain int, typ int, proto int) (fd int, err error) {
	r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))
	fd = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func socketpair(domain int, typ int, proto int, fd *[2]int32) (err error) {
	_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) {
	_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) {
	_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func sendto(s int, buf []byte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) {
	var _p0 unsafe.Pointer
	if len(buf) > 0 {
		_p0 = unsafe.Pointer(&buf[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func recvmsg(s int, msg *Msghdr, flags int) (n int, err error) {
	r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func sendmsg(s int, msg *Msghdr, flags int) (n int, err error) {
	r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Ioperm(from int, num int, on int) (err error) {
	_, _, e1 := Syscall(SYS_IOPERM, uintptr(from), uintptr(num), uintptr(on))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Iopl(level int) (err error) {
	_, _, e1 := Syscall(SYS_IOPL, uintptr(level), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func futimesat(dirfd int, path string, times *[2]Timeval) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Gettimeofday(tv *Timeval) (err error) {
	_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Time(t *Time_t) (tt Time_t, err error) {
	r0, _, e1 := RawSyscall(SYS_TIME, uintptr(unsafe.Pointer(t)), 0, 0)
	tt = Time_t(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Utime(path string, buf *Utimbuf) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_UTIME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func utimes(path string, times *[2]Timeval) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Lstat(path string, stat *Stat_t) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_LSTAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fstat(fd int, stat *Stat_t) (err error) {
	_, _, e1 := Syscall(SYS_FSTAT64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall6(SYS_FSTATAT64, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Stat(path string, stat *Stat_t) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_STAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pause() (err error) {
	_, _, e1 := Syscall(SYS_PAUSE, 0, 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func mmap2(addr uintptr, length uintptr, prot int, flags int, fd int, pageOffset uintptr) (xaddr uintptr, err error) {
	r0, _, e1 := Syscall6(SYS_MMAP2, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flags), uintptr(fd), uintptr(pageOffset))
	xaddr = uintptr(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getrlimit(resource int, rlim *rlimit32) (err error) {
	_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Alarm(seconds uint) (remaining uint, err error) {
	r0, _, e1 := Syscall(SYS_ALARM, uintptr(seconds), 0, 0)
	remaining = uint(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}
```
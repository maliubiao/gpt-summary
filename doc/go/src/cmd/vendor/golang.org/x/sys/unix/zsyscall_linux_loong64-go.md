Response:
Let's break down the thought process for analyzing the provided Go code snippet.

1. **Understanding the Context:** The first thing to recognize is the file path: `go/src/cmd/vendor/golang.org/x/sys/unix/zsyscall_linux_loong64.go`. This immediately tells us:
    * It's part of the Go standard library's extended system call interface (`golang.org/x/sys/unix`).
    * It's auto-generated (`zsyscall_`).
    * It's specific to Linux on the `loong64` architecture.
    * It resides within the `vendor` directory, suggesting it's a vendored dependency (though in this case, it's part of the standard library's internal structure).

2. **Dissecting the Header:** The header comments provide crucial information:
    * `// go run mksyscall.go -tags linux,loong64 syscall_linux.go syscall_linux_loong64.go`: This is the command used to generate this file. It indicates that `mksyscall.go` was used, targeting Linux on the `loong64` architecture, and processed the definitions in `syscall_linux.go` and `syscall_linux_loong64.go`. This implies `syscall_linux.go` contains general Linux syscall definitions, and `syscall_linux_loong64.go` likely has architecture-specific details.
    * `// Code generated by the command above; see README.md. DO NOT EDIT.`: Reinforces the auto-generated nature and warns against manual modification.
    * `//go:build linux && loong64`: This is a build tag, ensuring this file is only compiled when targeting Linux on the `loong64` architecture.
    * `package unix`:  Indicates this code belongs to the `unix` package within `golang.org/x/sys`.
    * `import (...)`: Imports necessary packages, primarily `syscall` and `unsafe`. `syscall` is essential for interacting with low-level system calls, and `unsafe` is used for operations involving raw memory pointers.

3. **Analyzing Individual Functions:** The core of the file is a series of function definitions. A pattern quickly emerges:
    * Each function has a comment: `// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT`. Redundant, but emphasizes the auto-generated nature.
    * Each function wraps a `Syscall` or `Syscall6` call (and sometimes `RawSyscall` or `RawSyscallNoError`).
    * The first argument to `Syscall`/`Syscall6` is a constant like `SYS_FANOTIFY_MARK`. This is the system call number.
    * The remaining arguments are typically converted to `uintptr`.
    * Error handling is consistent: `if e1 != 0 { err = errnoErr(e1) }`. This converts the raw error number returned by the syscall into a Go `error`.

4. **Inferring Functionality (and Connecting to Go Features):** Based on the syscall names and the function signatures, we can deduce the purpose of each function and connect it to higher-level Go functionalities:

    * **File System Operations:** `Fallocate`, `Fadvise`, `Fchown`, `Fstatfs`, `Ftruncate`, `pread`, `pwrite`, `Seek`, `sendfile`, `SyncFileRange`, `Truncate`. These are clearly related to file manipulation and I/O. We can infer they are used by Go's `os` package and related functionalities for file operations.
    * **Process/User/Group IDs:** `Getegid`, `Geteuid`, `Getgid`, `Getuid`, `setfsgid`, `setfsuid`, `getgroups`, `setgroups`. These are for retrieving and setting user and group identifiers, likely used by the `os/user` package and for managing process permissions.
    * **Networking:** `Listen`, `accept4`, `bind`, `connect`, `getsockopt`, `setsockopt`, `socket`, `socketpair`, `getpeername`, `getsockname`, `recvfrom`, `sendto`, `recvmsg`, `sendmsg`, `Shutdown`, `Splice`, `Tee`. These are fundamental networking syscalls, heavily used by Go's `net` package for socket programming.
    * **Memory Management:** `mmap`. This is for memory mapping, often used for efficient file I/O or shared memory. Go's standard library provides higher-level abstractions, but this syscall is the foundation.
    * **Time:** `Gettimeofday`. This is for getting the current time. Go's `time` package uses this under the hood.
    * **Specialized Syscalls:** `fanotifyMark`, `EpollWait`, `kexecFileLoad`. These are more advanced or specific syscalls. `fanotifyMark` relates to file system event notifications, likely used by libraries implementing file watchers. `EpollWait` is a crucial part of the efficient I/O multiplexing mechanism in Linux, likely used internally by Go's networking and other I/O operations. `kexecFileLoad` is for loading a new kernel, a very low-level operation.

5. **Illustrative Go Code Examples:** Once the functionality is understood, constructing illustrative Go code becomes straightforward. For example, for `Fallocate`, one would demonstrate pre-allocating space in a file. For `EpollWait`, one would show how to set up an epoll instance and wait for events on file descriptors.

6. **Command Line Arguments:** The `go run mksyscall.go ...` line is the key here. It demonstrates how this specific file was generated. Explaining the meaning of the tags and the input files is crucial.

7. **Common Pitfalls:** Thinking about how developers might misuse these *low-level* functions is important. Directly using these functions can be error-prone due to the need for manual memory management (with `unsafe.Pointer`) and dealing with raw error numbers. Emphasizing the preference for higher-level Go packages is key. The example of incorrect `EpollEvent` slice usage highlights a common mistake when dealing with slices and pointers in syscalls.

8. **Structure and Clarity:**  Organizing the answer by functionality, providing code examples, explaining the generation process, and highlighting potential pitfalls makes the information more accessible and understandable. Using clear headings and formatting helps.

By following these steps, we can systematically analyze the provided code snippet, understand its purpose, and explain it effectively. The key is to work from the specific details (function signatures, syscall names) to the broader context of Go's functionalities and potential use cases.
这个文件 `zsyscall_linux_loong64.go` 是 Go 语言在 Linux `loong64` 架构下实现系统调用的一个组成部分。它的主要功能是将 Go 语言的函数调用转换为操作系统内核能够理解和执行的系统调用。

**核心功能：**

1. **系统调用绑定:**  该文件中的每个 Go 函数（例如 `fanotifyMark`, `Fallocate`, `Tee` 等）都对应一个底层的 Linux 系统调用。 函数内部通过 `Syscall` 或 `Syscall6` 函数，并传入特定的系统调用号（例如 `SYS_FANOTIFY_MARK`, `SYS_FALLOCATE`, `SYS_TEE`）以及相关的参数，来触发实际的系统调用。

2. **参数转换:** Go 语言的数据类型需要转换为系统调用期望的格式。这通常涉及到将 Go 的 `int`, `int64`, `uint`, `uint64`, byte slice 等转换为 `uintptr`，并使用 `unsafe.Pointer` 来传递指针。

3. **错误处理:** 系统调用执行后会返回一个错误码。该文件中的函数会检查这个错误码 (`e1`)，如果非零，则使用 `errnoErr` 函数将其转换为 Go 的 `error` 类型，方便 Go 程序的错误处理。

**它是如何实现 Go 语言功能的：**

这个文件是 Go 语言标准库 `syscall` 包在特定平台下的底层实现。  更具体地说，它是 `golang.org/x/sys/unix` 包的一部分，提供了对 Unix 系统调用的更细粒度的访问。  很多 Go 语言的内置功能，特别是涉及到操作系统交互的部分，都依赖于这些底层的系统调用。

**Go 代码示例：**

让我们以 `Fallocate` 函数为例，它对应 Linux 的 `fallocate` 系统调用，用于预分配文件空间。

```go
package main

import (
	"fmt"
	"os"
	"golang.org/x/sys/unix"
)

func main() {
	file, err := os.Create("test.txt")
	if err != nil {
		fmt.Println("创建文件失败:", err)
		return
	}
	defer file.Close()

	fd := int(file.Fd()) // 获取文件描述符

	// 预分配 1MB 的空间
	err = unix.Fallocate(fd, 0, 0, 1024*1024)
	if err != nil {
		fmt.Println("预分配空间失败:", err)
		return
	}

	fmt.Println("成功预分配 1MB 空间")
}
```

**假设的输入与输出：**

* **输入:**  在上面的例子中，输入是创建了一个名为 `test.txt` 的文件，并获取了它的文件描述符 `fd`。  `unix.Fallocate` 的参数是 `fd`，`mode` 为 0 (表示默认操作)，`off` 为 0 (从文件开头开始)，`len` 为 1024 * 1024 (1MB)。
* **输出:** 如果系统调用成功，`unix.Fallocate` 将返回 `nil` 作为 `err`。  实际上，操作系统的输出是在文件系统中预留了 1MB 的空间给 `test.txt` 文件。如果失败，`err` 将包含描述错误的 `error` 对象。

**代码推理：**

当我们调用 `unix.Fallocate(fd, 0, 0, 1024*1024)` 时，实际上会执行 `zsyscall_linux_loong64.go` 中的 `Fallocate` 函数：

```go
func Fallocate(fd int, mode uint32, off int64, len int64) (err error) {
	_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(len), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}
```

* `SYS_FALLOCATE` 是 `syscall` 包中定义的一个常量，代表 `fallocate` 系统调用的编号。
* `uintptr(fd)`, `uintptr(mode)`, `uintptr(off)`, `uintptr(len)` 将 Go 的 `int` 和 `int64` 类型转换为 `uintptr`，这是 `Syscall6` 函数所要求的。
* `Syscall6` 函数会将这些参数传递给底层的 `fallocate` 系统调用。
* 系统调用执行的结果（错误码）会存储在 `e1` 中。
* 如果 `e1` 非零，`errnoErr(e1)` 会将其转换为 Go 的错误。

**命令行参数的具体处理：**

该文件自身并不直接处理命令行参数。  命令行参数的处理通常发生在程序的 `main` 函数或者使用像 `flag` 包这样的工具。

然而，文件开头的注释 `// go run mksyscall.go -tags linux,loong64 syscall_linux.go syscall_linux_loong64.go` 描述了如何**生成**这个文件。

* `go run mksyscall.go`:  运行 `mksyscall.go` 这个 Go 程序。
* `-tags linux,loong64`:  这是一个 Go build tag。它告诉 `mksyscall.go` 针对 `linux` 操作系统和 `loong64` 架构生成代码。
* `syscall_linux.go syscall_linux_loong64.go`:  这两个是 `mksyscall.go` 程序的输入文件，包含了系统调用的定义。  `syscall_linux.go` 可能包含通用的 Linux 系统调用定义，而 `syscall_linux_loong64.go` 可能包含特定于 `loong64` 架构的定义。

所以，这个命令行是用来生成 `zsyscall_linux_loong64.go` 文件的，而不是这个文件本身处理命令行参数。

**使用者易犯错的点：**

由于 `zsyscall_linux_loong64.go` 提供的函数是对底层系统调用的直接封装，因此直接使用这些函数容易出错，主要集中在以下几点：

1. **不正确的参数类型和值:** 系统调用对参数的类型、范围和含义都有严格的要求。 传递错误的参数类型或超出范围的值会导致系统调用失败，并且可能引发难以调试的问题。 例如，传递一个不合法的文件描述符。

2. **内存管理:** 某些系统调用需要传递指针，例如 `fanotifyMark` 中的 `pathname *byte`，以及网络相关的系统调用中传递 socket 地址的指针。  用户需要确保这些指针指向有效的内存区域，并且在系统调用执行期间有效。  Go 的垃圾回收机制并不总是能保证这种情况，因此需要谨慎处理 `unsafe.Pointer` 的使用。

   **示例 (假设错误使用 `EpollWait`):**

   ```go
   package main

   import (
       "fmt"
       "golang.org/x/sys/unix"
       "syscall"
   )

   func main() {
       epfd, err := unix.EpollCreate1(0)
       if err != nil {
           fmt.Println("EpollCreate1 error:", err)
           return
       }
       defer syscall.Close(epfd)

       events := make([]unix.EpollEvent, 10) // 分配一个切片

       // 假设这里添加了一些要监听的文件描述符到 epfd

       n, err := unix.EpollWait(epfd, events, -1) // 等待事件

       // 错误：假设 events 切片在 EpollWait 返回后被修改或回收，访问 events[i] 可能导致问题
       for i := 0; i < n; i++ {
           fmt.Printf("收到事件: %+v\n", events[i])
       }
   }
   ```

   在这个例子中，虽然看起来没问题，但在更复杂的场景下，如果 `events` 切片的底层数组在 `EpollWait` 返回后，但在访问 `events[i]` 之前被其他操作修改或垃圾回收，可能会导致问题。  通常，对于接收数据的系统调用，需要确保提供的缓冲区在调用期间是稳定的。

3. **错误处理不当:** 直接使用系统调用时，必须仔细检查返回值和错误码。  忽略错误可能导致程序行为不可预测。

4. **平台差异:**  `zsyscall_linux_loong64.go` 中的系统调用只在 Linux 的 `loong64` 架构下可用。  直接使用这些函数会导致代码在其他操作系统或架构上无法编译或运行。  应该使用 Go 标准库中提供的、跨平台的抽象，例如 `os` 包和 `net` 包。

**总结:**

`zsyscall_linux_loong64.go` 是 Go 语言在特定平台下实现系统调用的桥梁。它将 Go 函数调用转换为底层的 Linux 系统调用，并负责参数转换和错误处理。  虽然它提供了对操作系统底层功能的直接访问，但直接使用这些函数容易出错，应该尽量使用 Go 标准库提供的更高级、更安全的抽象。

### 提示词
```
这是路径为go/src/cmd/vendor/golang.org/x/sys/unix/zsyscall_linux_loong64.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
```

### 源代码
```go
// go run mksyscall.go -tags linux,loong64 syscall_linux.go syscall_linux_loong64.go
// Code generated by the command above; see README.md. DO NOT EDIT.

//go:build linux && loong64

package unix

import (
	"syscall"
	"unsafe"
)

var _ syscall.Errno

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fanotifyMark(fd int, flags uint, mask uint64, dirFd int, pathname *byte) (err error) {
	_, _, e1 := Syscall6(SYS_FANOTIFY_MARK, uintptr(fd), uintptr(flags), uintptr(mask), uintptr(dirFd), uintptr(unsafe.Pointer(pathname)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fallocate(fd int, mode uint32, off int64, len int64) (err error) {
	_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(len), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Tee(rfd int, wfd int, len int, flags int) (n int64, err error) {
	r0, _, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)
	n = int64(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func EpollWait(epfd int, events []EpollEvent, msec int) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(events) > 0 {
		_p0 = unsafe.Pointer(&events[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_EPOLL_PWAIT, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec), 0, 0)
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fadvise(fd int, offset int64, length int64, advice int) (err error) {
	_, _, e1 := Syscall6(SYS_FADVISE64, uintptr(fd), uintptr(offset), uintptr(length), uintptr(advice), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fchown(fd int, uid int, gid int) (err error) {
	_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fstatfs(fd int, buf *Statfs_t) (err error) {
	_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(buf)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Ftruncate(fd int, length int64) (err error) {
	_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getegid() (egid int) {
	r0, _ := RawSyscallNoError(SYS_GETEGID, 0, 0, 0)
	egid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Geteuid() (euid int) {
	r0, _ := RawSyscallNoError(SYS_GETEUID, 0, 0, 0)
	euid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getgid() (gid int) {
	r0, _ := RawSyscallNoError(SYS_GETGID, 0, 0, 0)
	gid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getuid() (uid int) {
	r0, _ := RawSyscallNoError(SYS_GETUID, 0, 0, 0)
	uid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Listen(s int, n int) (err error) {
	_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(n), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func pread(fd int, p []byte, offset int64) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func pwrite(fd int, p []byte, offset int64) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Seek(fd int, offset int64, whence int) (off int64, err error) {
	r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))
	off = int64(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) {
	r0, _, e1 := Syscall6(SYS_SENDFILE, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)
	written = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func setfsgid(gid int) (prev int, err error) {
	r0, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)
	prev = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func setfsuid(uid int) (prev int, err error) {
	r0, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)
	prev = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Shutdown(fd int, how int) (err error) {
	_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(fd), uintptr(how), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error) {
	r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))
	n = int64(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Statfs(path string, buf *Statfs_t) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func SyncFileRange(fd int, off int64, n int64, flags int) (err error) {
	_, _, e1 := Syscall6(SYS_SYNC_FILE_RANGE, uintptr(fd), uintptr(off), uintptr(n), uintptr(flags), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Truncate(path string, length int64) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) {
	r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)
	fd = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) {
	_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) {
	_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getgroups(n int, list *_Gid_t) (nn int, err error) {
	r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)
	nn = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func setgroups(n int, list *_Gid_t) (err error) {
	_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) {
	_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) {
	_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func socket(domain int, typ int, proto int) (fd int, err error) {
	r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))
	fd = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func socketpair(domain int, typ int, proto int, fd *[2]int32) (err error) {
	_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) {
	_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) {
	_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func sendto(s int, buf []byte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) {
	var _p0 unsafe.Pointer
	if len(buf) > 0 {
		_p0 = unsafe.Pointer(&buf[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func recvmsg(s int, msg *Msghdr, flags int) (n int, err error) {
	r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func sendmsg(s int, msg *Msghdr, flags int) (n int, err error) {
	r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error) {
	r0, _, e1 := Syscall6(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flags), uintptr(fd), uintptr(offset))
	xaddr = uintptr(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Gettimeofday(tv *Timeval) (err error) {
	_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func kexecFileLoad(kernelFd int, initrdFd int, cmdlineLen int, cmdline string, flags int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(cmdline)
	if err != nil {
		return
	}
	_, _, e1 := Syscall6(SYS_KEXEC_FILE_LOAD, uintptr(kernelFd), uintptr(initrdFd), uintptr(cmdlineLen), uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}
```
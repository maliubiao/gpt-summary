Response:
Let's break down the thought process for analyzing the provided Go code snippet.

**1. Initial Scan and Keyword Recognition:**

The first step is to quickly scan the code for recognizable patterns and keywords. Things that immediately jump out are:

* `"THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT"`:  This is a strong indicator that the file is automatically generated, likely from system call definitions. This tells us that the core functionality relates to interacting with the operating system kernel.
* `go/src/cmd/vendor/golang.org/x/sys/unix/zsyscall_zos_s390x.go`: The path itself is highly informative. "syscall" clearly points to system call interactions. "zos" indicates the target operating system (z/OS). "s390x" specifies the architecture. "vendor" suggests this is a vendored dependency, meaning it's a specific version included in the project.
* Function signatures with `(err error)` as a return value:  This is standard Go error handling for operations that can fail.
* Functions like `impl_Mknodat`, `impl_PivotRoot`, `impl_Prctl`, etc.: The `impl_` prefix suggests these are the actual implementations of system calls.
* Corresponding `get_...Addr()`, `enter_...`, `error_...`: This pattern suggests a mechanism for dynamically choosing the actual implementation, potentially based on the availability of the system call at runtime.
* `runtime.EnterSyscall()` and `runtime.ExitSyscall()`: These are Go runtime functions related to managing the transition between Go code and system calls.
* `CallLeFuncWithErr()`:  This function is likely the core mechanism for invoking the underlying z/OS system calls. The `Le` probably refers to the linkage convention used on z/OS (likely Language Environment).
* `BytePtrFromString()`:  This converts Go strings to C-style null-terminated byte pointers, which is necessary for interacting with the OS kernel.
* `unsafe.Pointer`:  This is used extensively for passing data structures and memory addresses to the system calls.
* Constants like `SYS___PIVOT_ROOT_A<<4`: These are likely system call numbers or identifiers. The left shift (`<<4`) suggests some encoding or offset.
* Error handling using `errnoErr2()` and `ENOSYS`: This is the standard way to handle system call errors and represent "not implemented."

**2. Function Grouping and Pattern Recognition:**

Next, look for repeating patterns. The structure around functions like `PivotRoot` is a key example:

* `impl_PivotRoot`: The actual system call implementation.
* `get_PivotRootAddr`: Gets a pointer to the function variable.
* `PivotRoot = enter_PivotRoot`: Assigns the entry point.
* `enter_PivotRoot`:  Checks if the system call is available and assigns either `impl_PivotRoot` or `error_PivotRoot`.
* `error_PivotRoot`: A fallback implementation that returns `ENOSYS`.

This pattern is consistently repeated for many functions. This strongly suggests a strategy for handling potentially missing system calls on older z/OS versions or configurations.

**3. Inferring Functionality from Names and Parameters:**

At this stage, we can start to infer what each function does based on its name and parameters, drawing on general operating system knowledge:

* `Mknodat`:  Likely "make node at", creating a file or directory relative to a directory file descriptor.
* `PivotRoot`:  Changes the root directory of the process.
* `Pread`/`Pwrite`:  Read/write to a file descriptor at a specific offset.
* `Prctl`: Process control operations.
* `Prlimit`:  Get/set resource limits for a process.
* `Rename`/`Renameat`/`Renameat2`:  Rename files or directories.
* `Rmdir`: Remove a directory.
* `Seek`: Change the file offset.
* `Setegid`/`Seteuid`/`Sethostname`/`Setns`/`Setpriority`/`Setpgid`/`Setrlimit`/`Setregid`/`Setreuid`/`Setsid`/`Setuid`/`Setgid`:  Functions for setting process IDs, user/group IDs, hostname, namespaces, priority, and resource limits.
* `Shutdown`: Close down part or all of a full-duplex connection.
* `Stat`/`Symlink`/`Symlinkat`: Get file status, create symbolic links.
* `Sync`:  Synchronize file system data to disk.
* `Truncate`:  Truncate a file to a specified length.
* `Tcgetattr`/`Tcsetattr`: Get/set terminal attributes.
* `Umask`: Set the file mode creation mask.
* `Unlink`/`Unlinkat`: Remove a file.
* `Utime`/`Utimes`/`Utimeat`: Modify file access and modification times.
* `Open`/`Openat`/`Openat2`: Open files.
* `Remove`: Remove a file or directory.
* `Waitid`/`Waitpid`: Wait for process termination.
* `Gettimeofday`: Get the current time.
* `Pipe`: Create a pipe.
* `Posix_openpt`/`Grantpt`/`Unlockpt`: Functions related to pseudo-terminals.

**4. Focusing on the "Enter/Impl/Error" Pattern:**

The `enter_...`, `impl_...`, `error_...` pattern is crucial. It signifies a fallback mechanism. The `enter_` function checks for the availability of the system call (`funcptrtest`) and then dynamically assigns the correct implementation (`impl_...` if available, `error_...` otherwise). The `error_...` functions simply return `ENOSYS`, indicating that the system call is not supported.

**5. Considering the "Generated" Aspect:**

The "GENERATED" comment reinforces the idea that the code is a low-level interface. Manual editing is discouraged because changes would likely be overwritten. This also suggests that the code likely maps directly to system call definitions from the z/OS kernel.

**6. Synthesizing the Functionality (for Part 2):**

For the second part of the prompt, the goal is to summarize the overall functionality. The key points are:

* **Low-level System Call Interface:** The code provides a Go interface to z/OS system calls.
* **Dynamic Dispatch/Fallback:**  It uses a mechanism to call the actual system call if available or return an "operation not supported" error if it's not.
* **Error Handling:** Standard Go error handling is used to report failures.
* **Data Conversion:**  It handles the necessary conversion between Go data types (strings, slices) and the C-style data expected by system calls.
* **Architecture-Specific:** It's specifically for the s390x architecture on z/OS.
* **Generated Code:**  It's automatically generated, implying a close correspondence to the underlying system call definitions.

**7. Addressing Specific Prompt Requirements (Example for `Mknodat`):**

* **Functionality:** Create a file or directory relative to a directory file descriptor.
* **Go Example (with assumptions):** Assume we have a directory file descriptor `dirFd` and want to create a file named "myfile.txt" with permissions `0644`. The output would be an error if the operation fails.
* **Code Reasoning:** The `impl_Mknodat` function directly calls the underlying z/OS system call. The `enter_Mknodat` function ensures that if the system call isn't available, the `error_Mknodat` function is called, returning `ENOSYS`.
* **No Command-Line Arguments:** This particular function doesn't involve command-line arguments directly.
* **Potential Pitfalls:**  For `Mknodat`, a common error would be providing an invalid `dirfd` or not having the necessary permissions to create the file.

By following these steps, we can systematically analyze the code snippet and address all aspects of the prompt. The key is to start with the high-level information (file path, generated status), look for patterns, infer functionality from names, and then zoom in on the implementation details, particularly the dynamic dispatch mechanism.
好的，我们来归纳一下这段Go语言代码的功能。

**功能归纳**

这段代码是Go语言标准库中 `syscall` 包的一部分，专门为 `zos/s390x` 架构提供了对底层操作系统系统调用的封装。  它定义了一系列Go函数，这些函数可以直接调用 IBM z/OS 操作系统上的系统调用。

更具体地说，这段代码实现了以下功能：

1. **系统调用接口定义:**  它定义了一系列Go函数，函数名通常与对应的POSIX或者z/OS系统调用名称相似（例如 `Mknodat`, `PivotRoot`, `Pread`, `Pwrite` 等）。这些函数作为Go程序访问底层操作系统服务的桥梁。

2. **系统调用实现:**  对于每个定义的系统调用接口，通常包含以下几个部分：
   - `impl_FunctionName`:  这是实际执行系统调用的函数。它使用 `runtime.EnterSyscall()`, `CallLeFuncWithErr()`, 和 `runtime.ExitSyscall()` 来进行系统调用。 `CallLeFuncWithErr`  负责调用底层的 z/OS 链接库函数，并将Go的参数转换为系统调用所需的格式（例如使用 `BytePtrFromString` 将Go字符串转换为 C 风格的字符串指针）。
   - `get_FunctionNameAddr`:  返回一个指向函数变量的指针。这个变量最终会指向实际的实现函数。
   - `FunctionName`: 这是Go程序中直接调用的函数入口。它会调用 `enter_FunctionName`。
   - `enter_FunctionName`:  这个函数负责动态地决定使用哪个实现。它会检查系统调用是否可用 (`funcptrtest`)。如果可用，就将 `impl_FunctionName` 的地址赋给函数变量；如果不可用，就将 `error_FunctionName` 的地址赋给函数变量。
   - `error_FunctionName`:  如果系统调用不可用，这个函数会被调用，它通常会返回 `ENOSYS` 错误（表示功能未实现）。

3. **错误处理:**  系统调用的结果通过 `errnoErr2` 函数转换为Go的 `error` 类型，以便Go程序能够方便地处理系统调用失败的情况。

4. **数据类型转换:**  代码中使用了 `unsafe.Pointer` 进行指针转换，并且使用了辅助函数如 `BytePtrFromString` 将Go的字符串类型转换为系统调用需要的 C 风格的字符串指针。对于结构体，也直接使用指向结构体的指针传递给系统调用。

5. **动态链接或检查:**  通过 `funcptrtest` 和动态赋值函数指针的方式，这段代码似乎实现了一种机制，可以在运行时检查系统调用是否可用，并根据情况选择实际的实现或返回错误。这可能是为了兼容不同版本的 z/OS，某些系统调用可能在旧版本上不存在。

**这段代码实现的是 Go 语言的系统调用接口层，它使得 Go 程序能够与底层的 z/OS 操作系统进行交互，执行诸如文件操作、进程管理、权限控制等各种操作。**

由于这是第2部分，结合你在问题中提供的代码，我们可以看到这个文件定义了大量的系统调用接口。这些接口覆盖了文件系统操作（如 `mknodat`, `renameat`, `unlinkat`, `openat`），进程控制（如 `pivot_root`, `prctl`, `sethostname`, `setns`），以及其他底层操作（如 `pread`, `pwrite`, `shutdown`, `sync`）。

总而言之，`zsyscall_zos_s390x.go` 的主要功能是 **为 Go 语言在 z/OS s390x 平台上提供低级别的操作系统接口，允许 Go 程序执行底层的系统调用。** 它的设计包含了对系统调用可用性的检查和回退机制，以提高兼容性。

### 提示词
```
这是路径为go/src/cmd/vendor/golang.org/x/sys/unix/zsyscall_zos_s390x.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
这是第2部分，共2部分，请归纳一下它的功能
```

### 源代码
```go
return (*funcref)(dirfd, path, mode, dev)
}

func error_Mknodat(dirfd int, path string, mode uint32, dev int) (err error) {
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_PivotRoot(newroot string, oldroot string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(newroot)
	if err != nil {
		return
	}
	var _p1 *byte
	_p1, err = BytePtrFromString(oldroot)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___PIVOT_ROOT_A<<4, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_PivotRootAddr() *(func(newroot string, oldroot string) (err error))

var PivotRoot = enter_PivotRoot

func enter_PivotRoot(newroot string, oldroot string) (err error) {
	funcref := get_PivotRootAddr()
	if funcptrtest(GetZosLibVec()+SYS___PIVOT_ROOT_A<<4, "") == 0 {
		*funcref = impl_PivotRoot
	} else {
		*funcref = error_PivotRoot
	}
	return (*funcref)(newroot, oldroot)
}

func error_PivotRoot(newroot string, oldroot string) (err error) {
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pread(fd int, p []byte, offset int64) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_PREAD<<4, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset))
	runtime.ExitSyscall()
	n = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pwrite(fd int, p []byte, offset int64) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_PWRITE<<4, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset))
	runtime.ExitSyscall()
	n = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_Prctl(option int, arg2 uintptr, arg3 uintptr, arg4 uintptr, arg5 uintptr) (err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___PRCTL_A<<4, uintptr(option), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_PrctlAddr() *(func(option int, arg2 uintptr, arg3 uintptr, arg4 uintptr, arg5 uintptr) (err error))

var Prctl = enter_Prctl

func enter_Prctl(option int, arg2 uintptr, arg3 uintptr, arg4 uintptr, arg5 uintptr) (err error) {
	funcref := get_PrctlAddr()
	if funcptrtest(GetZosLibVec()+SYS___PRCTL_A<<4, "") == 0 {
		*funcref = impl_Prctl
	} else {
		*funcref = error_Prctl
	}
	return (*funcref)(option, arg2, arg3, arg4, arg5)
}

func error_Prctl(option int, arg2 uintptr, arg3 uintptr, arg4 uintptr, arg5 uintptr) (err error) {
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_Prlimit(pid int, resource int, newlimit *Rlimit, old *Rlimit) (err error) {
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_PRLIMIT<<4, uintptr(pid), uintptr(resource), uintptr(unsafe.Pointer(newlimit)), uintptr(unsafe.Pointer(old)))
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_PrlimitAddr() *(func(pid int, resource int, newlimit *Rlimit, old *Rlimit) (err error))

var Prlimit = enter_Prlimit

func enter_Prlimit(pid int, resource int, newlimit *Rlimit, old *Rlimit) (err error) {
	funcref := get_PrlimitAddr()
	if funcptrtest(GetZosLibVec()+SYS_PRLIMIT<<4, "") == 0 {
		*funcref = impl_Prlimit
	} else {
		*funcref = error_Prlimit
	}
	return (*funcref)(pid, resource, newlimit, old)
}

func error_Prlimit(pid int, resource int, newlimit *Rlimit, old *Rlimit) (err error) {
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Rename(from string, to string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(from)
	if err != nil {
		return
	}
	var _p1 *byte
	_p1, err = BytePtrFromString(to)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___RENAME_A<<4, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(oldpath)
	if err != nil {
		return
	}
	var _p1 *byte
	_p1, err = BytePtrFromString(newpath)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___RENAMEAT_A<<4, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_RenameatAddr() *(func(olddirfd int, oldpath string, newdirfd int, newpath string) (err error))

var Renameat = enter_Renameat

func enter_Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {
	funcref := get_RenameatAddr()
	if funcptrtest(GetZosLibVec()+SYS___RENAMEAT_A<<4, "") == 0 {
		*funcref = impl_Renameat
	} else {
		*funcref = error_Renameat
	}
	return (*funcref)(olddirfd, oldpath, newdirfd, newpath)
}

func error_Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_Renameat2(olddirfd int, oldpath string, newdirfd int, newpath string, flags uint) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(oldpath)
	if err != nil {
		return
	}
	var _p1 *byte
	_p1, err = BytePtrFromString(newpath)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___RENAMEAT2_A<<4, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_Renameat2Addr() *(func(olddirfd int, oldpath string, newdirfd int, newpath string, flags uint) (err error))

var Renameat2 = enter_Renameat2

func enter_Renameat2(olddirfd int, oldpath string, newdirfd int, newpath string, flags uint) (err error) {
	funcref := get_Renameat2Addr()
	if funcptrtest(GetZosLibVec()+SYS___RENAMEAT2_A<<4, "") == 0 {
		*funcref = impl_Renameat2
	} else {
		*funcref = error_Renameat2
	}
	return (*funcref)(olddirfd, oldpath, newdirfd, newpath, flags)
}

func error_Renameat2(olddirfd int, oldpath string, newdirfd int, newpath string, flags uint) (err error) {
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Rmdir(path string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___RMDIR_A<<4, uintptr(unsafe.Pointer(_p0)))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Seek(fd int, offset int64, whence int) (off int64, err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_LSEEK<<4, uintptr(fd), uintptr(offset), uintptr(whence))
	runtime.ExitSyscall()
	off = int64(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Setegid(egid int) (err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_SETEGID<<4, uintptr(egid))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Seteuid(euid int) (err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_SETEUID<<4, uintptr(euid))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_Sethostname(p []byte) (err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___SETHOSTNAME_A<<4, uintptr(_p0), uintptr(len(p)))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_SethostnameAddr() *(func(p []byte) (err error))

var Sethostname = enter_Sethostname

func enter_Sethostname(p []byte) (err error) {
	funcref := get_SethostnameAddr()
	if funcptrtest(GetZosLibVec()+SYS___SETHOSTNAME_A<<4, "") == 0 {
		*funcref = impl_Sethostname
	} else {
		*funcref = error_Sethostname
	}
	return (*funcref)(p)
}

func error_Sethostname(p []byte) (err error) {
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_Setns(fd int, nstype int) (err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_SETNS<<4, uintptr(fd), uintptr(nstype))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_SetnsAddr() *(func(fd int, nstype int) (err error))

var Setns = enter_Setns

func enter_Setns(fd int, nstype int) (err error) {
	funcref := get_SetnsAddr()
	if funcptrtest(GetZosLibVec()+SYS_SETNS<<4, "") == 0 {
		*funcref = impl_Setns
	} else {
		*funcref = error_Setns
	}
	return (*funcref)(fd, nstype)
}

func error_Setns(fd int, nstype int) (err error) {
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Setpriority(which int, who int, prio int) (err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_SETPRIORITY<<4, uintptr(which), uintptr(who), uintptr(prio))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Setpgid(pid int, pgid int) (err error) {
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_SETPGID<<4, uintptr(pid), uintptr(pgid))
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Setrlimit(resource int, lim *Rlimit) (err error) {
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_SETRLIMIT<<4, uintptr(resource), uintptr(unsafe.Pointer(lim)))
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Setregid(rgid int, egid int) (err error) {
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_SETREGID<<4, uintptr(rgid), uintptr(egid))
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Setreuid(ruid int, euid int) (err error) {
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_SETREUID<<4, uintptr(ruid), uintptr(euid))
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Setsid() (pid int, err error) {
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec() + SYS_SETSID<<4)
	pid = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Setuid(uid int) (err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_SETUID<<4, uintptr(uid))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Setgid(uid int) (err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_SETGID<<4, uintptr(uid))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Shutdown(fd int, how int) (err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_SHUTDOWN<<4, uintptr(fd), uintptr(how))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func stat(path string, statLE *Stat_LE_t) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___STAT_A<<4, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(statLE)))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Symlink(path string, link string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	var _p1 *byte
	_p1, err = BytePtrFromString(link)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___SYMLINK_A<<4, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_Symlinkat(oldPath string, dirfd int, newPath string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(oldPath)
	if err != nil {
		return
	}
	var _p1 *byte
	_p1, err = BytePtrFromString(newPath)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___SYMLINKAT_A<<4, uintptr(unsafe.Pointer(_p0)), uintptr(dirfd), uintptr(unsafe.Pointer(_p1)))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_SymlinkatAddr() *(func(oldPath string, dirfd int, newPath string) (err error))

var Symlinkat = enter_Symlinkat

func enter_Symlinkat(oldPath string, dirfd int, newPath string) (err error) {
	funcref := get_SymlinkatAddr()
	if funcptrtest(GetZosLibVec()+SYS___SYMLINKAT_A<<4, "") == 0 {
		*funcref = impl_Symlinkat
	} else {
		*funcref = error_Symlinkat
	}
	return (*funcref)(oldPath, dirfd, newPath)
}

func error_Symlinkat(oldPath string, dirfd int, newPath string) (err error) {
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Sync() {
	runtime.EnterSyscall()
	CallLeFuncWithErr(GetZosLibVec() + SYS_SYNC<<4)
	runtime.ExitSyscall()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Truncate(path string, length int64) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___TRUNCATE_A<<4, uintptr(unsafe.Pointer(_p0)), uintptr(length))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Tcgetattr(fildes int, termptr *Termios) (err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_TCGETATTR<<4, uintptr(fildes), uintptr(unsafe.Pointer(termptr)))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Tcsetattr(fildes int, when int, termptr *Termios) (err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_TCSETATTR<<4, uintptr(fildes), uintptr(when), uintptr(unsafe.Pointer(termptr)))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Umask(mask int) (oldmask int) {
	runtime.EnterSyscall()
	r0, _, _ := CallLeFuncWithErr(GetZosLibVec()+SYS_UMASK<<4, uintptr(mask))
	runtime.ExitSyscall()
	oldmask = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Unlink(path string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___UNLINK_A<<4, uintptr(unsafe.Pointer(_p0)))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_Unlinkat(dirfd int, path string, flags int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___UNLINKAT_A<<4, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_UnlinkatAddr() *(func(dirfd int, path string, flags int) (err error))

var Unlinkat = enter_Unlinkat

func enter_Unlinkat(dirfd int, path string, flags int) (err error) {
	funcref := get_UnlinkatAddr()
	if funcptrtest(GetZosLibVec()+SYS___UNLINKAT_A<<4, "") == 0 {
		*funcref = impl_Unlinkat
	} else {
		*funcref = error_Unlinkat
	}
	return (*funcref)(dirfd, path, flags)
}

func error_Unlinkat(dirfd int, path string, flags int) (err error) {
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Utime(path string, utim *Utimbuf) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___UTIME_A<<4, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(utim)))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func open(path string, mode int, perm uint32) (fd int, err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___OPEN_A<<4, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm))
	runtime.ExitSyscall()
	fd = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___OPENAT_A<<4, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mode))
	runtime.ExitSyscall()
	fd = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_openatAddr() *(func(dirfd int, path string, flags int, mode uint32) (fd int, err error))

var openat = enter_openat

func enter_openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) {
	funcref := get_openatAddr()
	if funcptrtest(GetZosLibVec()+SYS___OPENAT_A<<4, "") == 0 {
		*funcref = impl_openat
	} else {
		*funcref = error_openat
	}
	return (*funcref)(dirfd, path, flags, mode)
}

func error_openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) {
	fd = -1
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_openat2(dirfd int, path string, open_how *OpenHow, size int) (fd int, err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___OPENAT2_A<<4, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(open_how)), uintptr(size))
	runtime.ExitSyscall()
	fd = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_openat2Addr() *(func(dirfd int, path string, open_how *OpenHow, size int) (fd int, err error))

var openat2 = enter_openat2

func enter_openat2(dirfd int, path string, open_how *OpenHow, size int) (fd int, err error) {
	funcref := get_openat2Addr()
	if funcptrtest(GetZosLibVec()+SYS___OPENAT2_A<<4, "") == 0 {
		*funcref = impl_openat2
	} else {
		*funcref = error_openat2
	}
	return (*funcref)(dirfd, path, open_how, size)
}

func error_openat2(dirfd int, path string, open_how *OpenHow, size int) (fd int, err error) {
	fd = -1
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func remove(path string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_REMOVE<<4, uintptr(unsafe.Pointer(_p0)))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func waitid(idType int, id int, info *Siginfo, options int) (err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_WAITID<<4, uintptr(idType), uintptr(id), uintptr(unsafe.Pointer(info)), uintptr(options))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func waitpid(pid int, wstatus *_C_int, options int) (wpid int, err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_WAITPID<<4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options))
	runtime.ExitSyscall()
	wpid = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func gettimeofday(tv *timeval_zos) (err error) {
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_GETTIMEOFDAY<<4, uintptr(unsafe.Pointer(tv)))
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func pipe(p *[2]_C_int) (err error) {
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_PIPE<<4, uintptr(unsafe.Pointer(p)))
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func utimes(path string, timeval *[2]Timeval) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___UTIMES_A<<4, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(timeval)))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func impl_utimensat(dirfd int, path string, ts *[2]Timespec, flags int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS___UTIMENSAT_A<<4, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(ts)), uintptr(flags))
	runtime.ExitSyscall()
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

//go:nosplit
func get_utimensatAddr() *(func(dirfd int, path string, ts *[2]Timespec, flags int) (err error))

var utimensat = enter_utimensat

func enter_utimensat(dirfd int, path string, ts *[2]Timespec, flags int) (err error) {
	funcref := get_utimensatAddr()
	if funcptrtest(GetZosLibVec()+SYS___UTIMENSAT_A<<4, "") == 0 {
		*funcref = impl_utimensat
	} else {
		*funcref = error_utimensat
	}
	return (*funcref)(dirfd, path, ts, flags)
}

func error_utimensat(dirfd int, path string, ts *[2]Timespec, flags int) (err error) {
	err = ENOSYS
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Posix_openpt(oflag int) (fd int, err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_POSIX_OPENPT<<4, uintptr(oflag))
	runtime.ExitSyscall()
	fd = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Grantpt(fildes int) (rc int, err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_GRANTPT<<4, uintptr(fildes))
	runtime.ExitSyscall()
	rc = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Unlockpt(fildes int) (rc int, err error) {
	runtime.EnterSyscall()
	r0, e2, e1 := CallLeFuncWithErr(GetZosLibVec()+SYS_UNLOCKPT<<4, uintptr(fildes))
	runtime.ExitSyscall()
	rc = int(r0)
	if int64(r0) == -1 {
		err = errnoErr2(e1, e2)
	}
	return
}
```
Response:
My thought process for analyzing the provided Go code snippet goes like this:

1. **Understand the Context:** The filename `ztypes_linux_mips.go` immediately tells me this file is auto-generated (`// Code generated by...`) and targets the Linux operating system running on the MIPS architecture. The `package unix` declaration indicates it's part of the `syscall` or `unix` package in Go, dealing with low-level OS interactions. The `//go:build mips && linux` build constraint confirms this.

2. **Identify Core Function:** The primary purpose of this file is to define Go data structures that mirror corresponding C structures used in the Linux kernel for system calls. This allows Go programs to interact with the kernel's ABI (Application Binary Interface). The comments at the top involving `cgo -godefs` solidify this. `cgo -godefs` is a tool that generates Go type definitions from C header files.

3. **Analyze Key Elements:**

    * **Constants:**  The `const` declarations like `SizeofPtr`, `SizeofLong`, `FADV_DONTNEED`, `POLLRDHUP`, `SIG_BLOCK`, etc., define integer constants. These often represent flags, sizes, or other numerical values used in system calls. The names are usually indicative of their purpose (e.g., `SizeofPtr` is the size of a pointer).

    * **Types:** The `type` declarations define Go structures (structs) and type aliases. These structures directly correspond to C structures defined in system headers (like `linux/types.h` mentioned in the `cgo` command). For instance, `Timespec`, `Timeval`, `Stat_t`, `Dirent`, etc., are standard POSIX or Linux kernel structures. The fields within these structs represent the members of the corresponding C structures, with Go's data types mapped appropriately. Type aliases like `_C_long` and `Time_t` are also important for maintaining compatibility with C types.

4. **Infer Go Functionality:** Based on the identified data structures, I can infer the Go functionalities that rely on them. The structures represent fundamental system concepts:

    * **Time:** `Timespec`, `Timeval`, `Timex` are related to time and clock management. This points to functionalities like getting and setting time, measuring time intervals, and potentially NTP or clock synchronization.
    * **File System:** `Stat_t`, `Dirent`, `Utimbuf`, `Flock_t`, `Statfs_t` relate to file and directory operations. This includes getting file metadata, reading directory entries, modifying file access/modification times, file locking, and getting file system statistics.
    * **Process Management:** `Tms`, `Rusage`, `Taskstats` are related to process information and resource usage. This implies functionalities like getting CPU time used by a process, memory usage, and other resource consumption metrics.
    * **Networking:** `RawSockaddrNFCLLCP`, `RawSockaddr`, `RawSockaddrAny`, `Iovec`, `Msghdr`, `Cmsghdr`, `ifreq` are clearly related to networking and socket programming. This includes functionalities like sending and receiving data over sockets, getting network interface information, and potentially low-level network protocols.
    * **Signals:** `Sigset_t`, `Siginfo`, `Termios` relate to signal handling and terminal control. This involves functionalities like blocking/unblocking signals and controlling terminal settings.
    * **Memory Management:**  Structures like `Sysinfo_t` relate to system-wide memory information.
    * **Device Management:** `HDGeometry`, `BlkpgPartition`, `LoopInfo` are related to interacting with block devices.
    * **Inter-Process Communication (IPC):** `SysvIpcPerm`, `SysvShmDesc` relate to System V IPC mechanisms like shared memory.
    * **Polling/Event Notification:** `EpollEvent`, `POLLRDHUP` are related to the `epoll` mechanism for efficient event monitoring.
    * **Tracing:** `PtraceRegs` is used with the `ptrace` system call for debugging and process inspection.

5. **Provide Go Code Examples:**  To illustrate how these structures are used, I create simple Go code snippets. The key is to show how to interact with system calls that utilize these structures. I focus on common and relatively easy-to-understand examples, like getting file information (`os.Stat`) and getting process resource usage (`syscall.Getrusage`). I include assumptions about input and output to make the examples concrete.

6. **Address Command-Line Arguments:** The `cgo` command at the top is the relevant command-line interaction. I explain the purpose of `cgo`, the `-godefs` flag, `-objdir`, `-I`, and the use of `go run mkpost.go`. I explain how these arguments are used to generate the Go code from C definitions.

7. **Identify Common Mistakes:** I think about potential pitfalls for developers using this low-level code. Common mistakes include:

    * **Incorrectly sizing data when interacting with C:**  Mismatched sizes or incorrect alignment can lead to crashes or data corruption.
    * **Endianness issues (though less likely on MIPS in this context):** If interacting with data structures shared across different architectures.
    * **Misunderstanding the meaning of fields:**  Not properly interpreting the values within the structures according to the kernel's documentation.
    * **Not handling errors returned by system calls:**  Low-level system calls can fail, and ignoring errors can lead to unexpected behavior.

By following these steps, I can systematically analyze the provided Go code snippet, understand its purpose, infer its functionality, provide illustrative examples, and highlight potential pitfalls for users. The focus is on connecting the low-level data structures to higher-level Go functionalities and common system programming concepts.
这段Go语言代码定义了一系列结构体（`struct`）和常量（`const`），这些结构体和常量直接映射到Linux操作系统在MIPS架构下的C语言数据类型和常量。它作为Go语言的 `syscall` 或者 `unix` 包的一部分，使得Go程序能够与底层的Linux系统调用接口进行交互。

**功能列举:**

1. **定义了与时间相关的结构体:**
   - `Timespec`: 精确到纳秒的时间表示。
   - `Timeval`: 精确到微秒的时间表示。
   - `Timex`: 用于NTP（网络时间协议）的精细时间调整信息。

2. **定义了进程和资源相关的结构体:**
   - `Tms`: 记录进程的 CPU 时间（用户态、内核态）。
   - `Utimbuf`: 用于修改文件的访问和修改时间。
   - `Rusage`: 记录进程的资源使用情况（CPU时间、内存、I/O等）。
   - `Taskstats`: 提供更详细的进程和线程统计信息。

3. **定义了文件系统相关的结构体:**
   - `Stat_t`:  描述文件的元数据（大小、权限、所有者、时间戳等）。
   - `Dirent`:  表示目录项。
   - `Flock_t`:  用于文件锁。
   - `Statfs_t`:  描述文件系统的统计信息（总空间、可用空间等）。

4. **定义了网络相关的结构体:**
   - `RawSockaddrNFCLLCP`, `RawSockaddr`, `RawSockaddrAny`: 用于表示原始套接字地址。
   - `Iovec`: 用于分散/聚集 I/O 操作。
   - `Msghdr`, `Cmsghdr`: 用于发送和接收消息，包含辅助数据。
   - `ifreq`: 用于网络接口配置信息。

5. **定义了与系统调用相关的结构体:**
   - `PtraceRegs`: 用于 `ptrace` 系统调用，访问进程的寄存器状态。
   - `FdSet`: 用于 `select` 系统调用，表示文件描述符集合。
   - `Sysinfo_t`:  包含系统总体信息（运行时间、负载、内存等）。
   - `Ustat_t`:  过时的文件系统状态信息。
   - `EpollEvent`: 用于 `epoll` 系统调用，表示事件。
   - `Sigset_t`: 用于表示信号掩码。
   - `Siginfo`:  包含有关信号的详细信息。
   - `Termios`: 用于终端 I/O 控制。

6. **定义了其他硬件或内核相关的结构体:**
   - `HDGeometry`: 硬盘几何信息。
   - `RTCPLLInfo`: 实时时钟 PLL 信息。
   - `BlkpgPartition`: 块设备分区信息。
   - `LoopInfo`: 回环设备信息。
   - `TIPCSubscr`, `TIPCSIOCLNReq`, `TIPCSIOCNodeIDReq`: 与 TIPC（透明进程间通信）相关的结构体。
   - `PPSKInfo`: 精确时间协议（PPS）相关信息。
   - `SysvIpcPerm`, `SysvShmDesc`: System V IPC 相关结构体。

7. **定义了常量:**
   - `SizeofPtr`, `SizeofLong`: 指针和 `long` 类型的大小，在MIPS Linux下都是4字节。
   - 文件操作相关的常量: `FADV_DONTNEED`, `FADV_NOREUSE`.
   - 网络操作相关的常量: `SizeofSockaddrNFCLLCP`, `SizeofIovec`, `SizeofMsghdr`, `SizeofCmsghdr`, `SizeofSockFprog`.
   - `epoll` 相关的常量: `OPEN_TREE_CLOEXEC`.
   - `poll` 相关的常量: `POLLRDHUP`.
   - 信号相关的常量: `_C__NSIG`, `SIG_BLOCK`, `SIG_UNBLOCK`, `SIG_SETMASK`.
   - `ioctl` 请求相关的常量: `BLKPG`, `PPS_GETPARAMS`, `PPS_SETPARAMS`, `PPS_GETCAP`, `PPS_FETCH`.
   - 其他常量: `PIDFD_NONBLOCK`, `_NCPUBITS`.

**Go语言功能的实现（推理及代码示例）:**

这个文件本身不是一个“功能”的实现，而是为其他Go语言功能提供底层的数据结构定义。这些结构体会被 `syscall` 包中的函数使用，这些函数直接调用Linux的系统调用。

例如，`Stat_t` 结构体会被 `os.Stat` 和 `syscall.Stat` 函数使用，用于获取文件的元数据。

```go
package main

import (
	"fmt"
	"os"
	"syscall"
)

func main() {
	fileInfo, err := os.Stat("example.txt")
	if err != nil {
		fmt.Println("Error:", err)
		return
	}

	// fileInfo 是一个 os.FileInfo 接口，它内部包含了 syscall.Stat_t 的信息
	statT := fileInfo.Sys().(*syscall.Stat_t)

	fmt.Println("File Name:", "example.txt")
	fmt.Println("Size:", statT.Size)
	fmt.Println("Mode:", os.FileMode(statT.Mode))
	fmt.Println("UID:", statT.Uid)
	fmt.Println("GID:", statT.Gid)
	fmt.Println("Last Access Time:", statT.Atim)
	fmt.Println("Last Modification Time:", statT.Mtim)
	fmt.Println("Last Change Time:", statT.Ctim)
}
```

**假设输入与输出:**

假设 `example.txt` 文件存在，大小为 1024 字节，权限为 `-rw-r--r--`，用户ID为 1000，组ID为 1000，访问时间为 Unix 时间戳 1678886400，修改时间为 1678886450，状态改变时间为 1678886500。

**可能的输出:**

```
File Name: example.txt
Size: 1024
Mode: -rw-r--r--
UID: 1000
GID: 1000
Last Access Time: {1678886400 0}
Last Modification Time: {1678886450 0}
Last Change Time: {1678886500 0}
```

另一个例子是 `Rusage` 结构体，它被 `syscall.Getrusage` 函数使用来获取进程的资源使用情况。

```go
package main

import (
	"fmt"
	"syscall"
	"time"
)

func main() {
	var rusage syscall.Rusage
	err := syscall.Getrusage(syscall.RUSAGE_SELF, &rusage)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}

	fmt.Println("User CPU Time:", time.Duration(rusage.Utime.Sec)*time.Second+time.Duration(rusage.Utime.Usec)*time.Microsecond)
	fmt.Println("System CPU Time:", time.Duration(rusage.Stime.Sec)*time.Second+time.Duration(rusage.Stime.Usec)*time.Microsecond)
	fmt.Println("Max Resident Set Size:", rusage.Maxrss)
	fmt.Println("Voluntary Context Switches:", rusage.Nvcsw)
	fmt.Println("Involuntary Context Switches:", rusage.Nivcsw)
}
```

**假设输入与输出:**

假设程序运行了一段时间，消耗了一些CPU时间和内存，发生了若干次上下文切换。

**可能的输出:**

```
User CPU Time: 100ms
System CPU Time: 50ms
Max Resident Set Size: 12345
Voluntary Context Switches: 10
Involuntary Context Switches: 5
```

**命令行参数的具体处理:**

这个文件是由 `cgo -godefs` 命令生成的。

- `cgo`: 是 Go 语言提供的与 C 代码互操作的工具。
- `-godefs`: 是 `cgo` 的一个标志，用于生成 Go 语言的类型定义。
- `-objdir=/tmp/mips/cgo`: 指定生成的临时目标文件的目录。
- `--`:  告诉 `cgo` 后面的参数是传递给 C 编译器的。
- `-Wall -Werror -static -I/tmp/mips/include`:  这些是传递给 C 编译器的参数：
    - `-Wall`: 开启所有警告。
    - `-Werror`: 将警告视为错误。
    - `-static`:  进行静态链接。
    - `-I/tmp/mips/include`:  指定头文件的搜索路径。
- `linux/types.go`:  指定要处理的输入文件，虽然名字是 `.go`，但 `cgo -godefs` 会识别并提取其中嵌入的 C 代码或指令。
- `| go run mkpost.go`:  将 `cgo` 的输出通过管道传递给 `go run mkpost.go` 命令，这是一个后处理脚本，用于进一步处理生成的 Go 代码。

**mkpost.go 的作用（推测）:**

`mkpost.go` 脚本很可能执行以下操作：

1. **格式化代码:** 确保生成的 Go 代码符合 Go 的代码风格。
2. **添加或修改注释:**  根据需要添加或修改代码中的注释。
3. **进行平台相关的调整:**  根据目标平台（这里是 `mips` 和 `linux`）进行一些特定的代码调整。
4. **添加构建约束:**  添加 `//go:build mips && linux` 这样的构建约束，确保这段代码只在特定的平台上编译。

**使用者易犯错的点:**

1. **直接修改此文件:**  由于此文件是自动生成的，直接修改可能会在下次重新生成时被覆盖。如果需要修改，应该修改生成它的源头（可能是 `.go` 文件中嵌入的 C 代码或者 `mkpost.go` 脚本）。

2. **不理解结构体字段的含义和单位:** 这些结构体中的字段直接对应 Linux 内核的定义，理解它们的含义和单位（例如，时间单位是秒还是纳秒）至关重要，否则可能会导致错误的计算或解释。 例如，`Timespec` 中的 `Sec` 是秒，`Nsec` 是纳秒。

3. **在非 MIPS Linux 平台上使用:**  此文件带有 `//go:build mips && linux` 的构建约束，如果在其他平台上编译，这段代码不会被包含，可能会导致编译错误或运行时错误，因为对应的系统调用参数和结构体定义可能不同。

4. **错误地假设结构体的大小和布局:**  虽然 `SizeofPtr` 和 `SizeofLong` 在这里被定义，但其他结构体的大小和字段偏移是由 `cgo` 基于 C 头文件自动生成的。手动计算或假设可能不准确，尤其是在不同的内核版本或编译选项下。应该依赖 Go 语言提供的 `unsafe.Sizeof` 来获取实际大小。

这段代码是 Go 语言与底层操作系统交互的基石，理解它的作用对于进行系统编程至关重要。

### 提示词
```
这是路径为go/src/cmd/vendor/golang.org/x/sys/unix/ztypes_linux_mips.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
```

### 源代码
```go
// cgo -godefs -objdir=/tmp/mips/cgo -- -Wall -Werror -static -I/tmp/mips/include linux/types.go | go run mkpost.go
// Code generated by the command above; see README.md. DO NOT EDIT.

//go:build mips && linux

package unix

const (
	SizeofPtr  = 0x4
	SizeofLong = 0x4
)

type (
	_C_long int32
)

type Timespec struct {
	Sec  int32
	Nsec int32
}

type Timeval struct {
	Sec  int32
	Usec int32
}

type Timex struct {
	Modes     uint32
	Offset    int32
	Freq      int32
	Maxerror  int32
	Esterror  int32
	Status    int32
	Constant  int32
	Precision int32
	Tolerance int32
	Time      Timeval
	Tick      int32
	Ppsfreq   int32
	Jitter    int32
	Shift     int32
	Stabil    int32
	Jitcnt    int32
	Calcnt    int32
	Errcnt    int32
	Stbcnt    int32
	Tai       int32
	_         [44]byte
}

type Time_t int32

type Tms struct {
	Utime  int32
	Stime  int32
	Cutime int32
	Cstime int32
}

type Utimbuf struct {
	Actime  int32
	Modtime int32
}

type Rusage struct {
	Utime    Timeval
	Stime    Timeval
	Maxrss   int32
	Ixrss    int32
	Idrss    int32
	Isrss    int32
	Minflt   int32
	Majflt   int32
	Nswap    int32
	Inblock  int32
	Oublock  int32
	Msgsnd   int32
	Msgrcv   int32
	Nsignals int32
	Nvcsw    int32
	Nivcsw   int32
}

type Stat_t struct {
	Dev     uint32
	Pad1    [3]int32
	Ino     uint64
	Mode    uint32
	Nlink   uint32
	Uid     uint32
	Gid     uint32
	Rdev    uint32
	Pad2    [3]int32
	Size    int64
	Atim    Timespec
	Mtim    Timespec
	Ctim    Timespec
	Blksize int32
	Pad4    int32
	Blocks  int64
	Pad5    [14]int32
}

type Dirent struct {
	Ino    uint64
	Off    int64
	Reclen uint16
	Type   uint8
	Name   [256]int8
	_      [5]byte
}

type Flock_t struct {
	Type   int16
	Whence int16
	_      [4]byte
	Start  int64
	Len    int64
	Pid    int32
	_      [4]byte
}

type DmNameList struct {
	Dev  uint64
	Next uint32
	Name [0]byte
	_    [4]byte
}

const (
	FADV_DONTNEED = 0x4
	FADV_NOREUSE  = 0x5
)

type RawSockaddrNFCLLCP struct {
	Sa_family        uint16
	Dev_idx          uint32
	Target_idx       uint32
	Nfc_protocol     uint32
	Dsap             uint8
	Ssap             uint8
	Service_name     [63]uint8
	Service_name_len uint32
}

type RawSockaddr struct {
	Family uint16
	Data   [14]int8
}

type RawSockaddrAny struct {
	Addr RawSockaddr
	Pad  [96]int8
}

type Iovec struct {
	Base *byte
	Len  uint32
}

type Msghdr struct {
	Name       *byte
	Namelen    uint32
	Iov        *Iovec
	Iovlen     uint32
	Control    *byte
	Controllen uint32
	Flags      int32
}

type Cmsghdr struct {
	Len   uint32
	Level int32
	Type  int32
}

type ifreq struct {
	Ifrn [16]byte
	Ifru [16]byte
}

const (
	SizeofSockaddrNFCLLCP = 0x58
	SizeofIovec           = 0x8
	SizeofMsghdr          = 0x1c
	SizeofCmsghdr         = 0xc
)

const (
	SizeofSockFprog = 0x8
)

type PtraceRegs struct {
	Regs     [32]uint64
	Lo       uint64
	Hi       uint64
	Epc      uint64
	Badvaddr uint64
	Status   uint64
	Cause    uint64
}

type FdSet struct {
	Bits [32]int32
}

type Sysinfo_t struct {
	Uptime    int32
	Loads     [3]uint32
	Totalram  uint32
	Freeram   uint32
	Sharedram uint32
	Bufferram uint32
	Totalswap uint32
	Freeswap  uint32
	Procs     uint16
	Pad       uint16
	Totalhigh uint32
	Freehigh  uint32
	Unit      uint32
	_         [8]int8
}

type Ustat_t struct {
	Tfree  int32
	Tinode uint32
	Fname  [6]int8
	Fpack  [6]int8
}

type EpollEvent struct {
	Events uint32
	PadFd  int32
	Fd     int32
	Pad    int32
}

const (
	OPEN_TREE_CLOEXEC = 0x80000
)

const (
	POLLRDHUP = 0x2000
)

type Sigset_t struct {
	Val [32]uint32
}

const _C__NSIG = 0x80

const (
	SIG_BLOCK   = 0x1
	SIG_UNBLOCK = 0x2
	SIG_SETMASK = 0x3
)

type Siginfo struct {
	Signo int32
	Code  int32
	Errno int32
	_     [116]byte
}

type Termios struct {
	Iflag  uint32
	Oflag  uint32
	Cflag  uint32
	Lflag  uint32
	Line   uint8
	Cc     [23]uint8
	Ispeed uint32
	Ospeed uint32
}

type Taskstats struct {
	Version                   uint16
	Ac_exitcode               uint32
	Ac_flag                   uint8
	Ac_nice                   uint8
	_                         [4]byte
	Cpu_count                 uint64
	Cpu_delay_total           uint64
	Blkio_count               uint64
	Blkio_delay_total         uint64
	Swapin_count              uint64
	Swapin_delay_total        uint64
	Cpu_run_real_total        uint64
	Cpu_run_virtual_total     uint64
	Ac_comm                   [32]int8
	Ac_sched                  uint8
	Ac_pad                    [3]uint8
	_                         [4]byte
	Ac_uid                    uint32
	Ac_gid                    uint32
	Ac_pid                    uint32
	Ac_ppid                   uint32
	Ac_btime                  uint32
	_                         [4]byte
	Ac_etime                  uint64
	Ac_utime                  uint64
	Ac_stime                  uint64
	Ac_minflt                 uint64
	Ac_majflt                 uint64
	Coremem                   uint64
	Virtmem                   uint64
	Hiwater_rss               uint64
	Hiwater_vm                uint64
	Read_char                 uint64
	Write_char                uint64
	Read_syscalls             uint64
	Write_syscalls            uint64
	Read_bytes                uint64
	Write_bytes               uint64
	Cancelled_write_bytes     uint64
	Nvcsw                     uint64
	Nivcsw                    uint64
	Ac_utimescaled            uint64
	Ac_stimescaled            uint64
	Cpu_scaled_run_real_total uint64
	Freepages_count           uint64
	Freepages_delay_total     uint64
	Thrashing_count           uint64
	Thrashing_delay_total     uint64
	Ac_btime64                uint64
	Compact_count             uint64
	Compact_delay_total       uint64
	Ac_tgid                   uint32
	_                         [4]byte
	Ac_tgetime                uint64
	Ac_exe_dev                uint64
	Ac_exe_inode              uint64
	Wpcopy_count              uint64
	Wpcopy_delay_total        uint64
	Irq_count                 uint64
	Irq_delay_total           uint64
}

type cpuMask uint32

const (
	_NCPUBITS = 0x20
)

const (
	CBitFieldMaskBit0  = 0x8000000000000000
	CBitFieldMaskBit1  = 0x4000000000000000
	CBitFieldMaskBit2  = 0x2000000000000000
	CBitFieldMaskBit3  = 0x1000000000000000
	CBitFieldMaskBit4  = 0x800000000000000
	CBitFieldMaskBit5  = 0x400000000000000
	CBitFieldMaskBit6  = 0x200000000000000
	CBitFieldMaskBit7  = 0x100000000000000
	CBitFieldMaskBit8  = 0x80000000000000
	CBitFieldMaskBit9  = 0x40000000000000
	CBitFieldMaskBit10 = 0x20000000000000
	CBitFieldMaskBit11 = 0x10000000000000
	CBitFieldMaskBit12 = 0x8000000000000
	CBitFieldMaskBit13 = 0x4000000000000
	CBitFieldMaskBit14 = 0x2000000000000
	CBitFieldMaskBit15 = 0x1000000000000
	CBitFieldMaskBit16 = 0x800000000000
	CBitFieldMaskBit17 = 0x400000000000
	CBitFieldMaskBit18 = 0x200000000000
	CBitFieldMaskBit19 = 0x100000000000
	CBitFieldMaskBit20 = 0x80000000000
	CBitFieldMaskBit21 = 0x40000000000
	CBitFieldMaskBit22 = 0x20000000000
	CBitFieldMaskBit23 = 0x10000000000
	CBitFieldMaskBit24 = 0x8000000000
	CBitFieldMaskBit25 = 0x4000000000
	CBitFieldMaskBit26 = 0x2000000000
	CBitFieldMaskBit27 = 0x1000000000
	CBitFieldMaskBit28 = 0x800000000
	CBitFieldMaskBit29 = 0x400000000
	CBitFieldMaskBit30 = 0x200000000
	CBitFieldMaskBit31 = 0x100000000
	CBitFieldMaskBit32 = 0x80000000
	CBitFieldMaskBit33 = 0x40000000
	CBitFieldMaskBit34 = 0x20000000
	CBitFieldMaskBit35 = 0x10000000
	CBitFieldMaskBit36 = 0x8000000
	CBitFieldMaskBit37 = 0x4000000
	CBitFieldMaskBit38 = 0x2000000
	CBitFieldMaskBit39 = 0x1000000
	CBitFieldMaskBit40 = 0x800000
	CBitFieldMaskBit41 = 0x400000
	CBitFieldMaskBit42 = 0x200000
	CBitFieldMaskBit43 = 0x100000
	CBitFieldMaskBit44 = 0x80000
	CBitFieldMaskBit45 = 0x40000
	CBitFieldMaskBit46 = 0x20000
	CBitFieldMaskBit47 = 0x10000
	CBitFieldMaskBit48 = 0x8000
	CBitFieldMaskBit49 = 0x4000
	CBitFieldMaskBit50 = 0x2000
	CBitFieldMaskBit51 = 0x1000
	CBitFieldMaskBit52 = 0x800
	CBitFieldMaskBit53 = 0x400
	CBitFieldMaskBit54 = 0x200
	CBitFieldMaskBit55 = 0x100
	CBitFieldMaskBit56 = 0x80
	CBitFieldMaskBit57 = 0x40
	CBitFieldMaskBit58 = 0x20
	CBitFieldMaskBit59 = 0x10
	CBitFieldMaskBit60 = 0x8
	CBitFieldMaskBit61 = 0x4
	CBitFieldMaskBit62 = 0x2
	CBitFieldMaskBit63 = 0x1
)

type SockaddrStorage struct {
	Family uint16
	Data   [122]byte
	_      uint32
}

type HDGeometry struct {
	Heads     uint8
	Sectors   uint8
	Cylinders uint16
	Start     uint32
}

type Statfs_t struct {
	Type    int32
	Bsize   int32
	Frsize  int32
	_       [4]byte
	Blocks  uint64
	Bfree   uint64
	Files   uint64
	Ffree   uint64
	Bavail  uint64
	Fsid    Fsid
	Namelen int32
	Flags   int32
	Spare   [5]int32
	_       [4]byte
}

type TpacketHdr struct {
	Status  uint32
	Len     uint32
	Snaplen uint32
	Mac     uint16
	Net     uint16
	Sec     uint32
	Usec    uint32
}

const (
	SizeofTpacketHdr = 0x18
)

type RTCPLLInfo struct {
	Ctrl    int32
	Value   int32
	Max     int32
	Min     int32
	Posmult int32
	Negmult int32
	Clock   int32
}

type BlkpgPartition struct {
	Start   int64
	Length  int64
	Pno     int32
	Devname [64]uint8
	Volname [64]uint8
	_       [4]byte
}

const (
	BLKPG = 0x20001269
)

type CryptoUserAlg struct {
	Name        [64]int8
	Driver_name [64]int8
	Module_name [64]int8
	Type        uint32
	Mask        uint32
	Refcnt      uint32
	Flags       uint32
}

type CryptoStatAEAD struct {
	Type         [64]int8
	Encrypt_cnt  uint64
	Encrypt_tlen uint64
	Decrypt_cnt  uint64
	Decrypt_tlen uint64
	Err_cnt      uint64
}

type CryptoStatAKCipher struct {
	Type         [64]int8
	Encrypt_cnt  uint64
	Encrypt_tlen uint64
	Decrypt_cnt  uint64
	Decrypt_tlen uint64
	Verify_cnt   uint64
	Sign_cnt     uint64
	Err_cnt      uint64
}

type CryptoStatCipher struct {
	Type         [64]int8
	Encrypt_cnt  uint64
	Encrypt_tlen uint64
	Decrypt_cnt  uint64
	Decrypt_tlen uint64
	Err_cnt      uint64
}

type CryptoStatCompress struct {
	Type            [64]int8
	Compress_cnt    uint64
	Compress_tlen   uint64
	Decompress_cnt  uint64
	Decompress_tlen uint64
	Err_cnt         uint64
}

type CryptoStatHash struct {
	Type      [64]int8
	Hash_cnt  uint64
	Hash_tlen uint64
	Err_cnt   uint64
}

type CryptoStatKPP struct {
	Type                      [64]int8
	Setsecret_cnt             uint64
	Generate_public_key_cnt   uint64
	Compute_shared_secret_cnt uint64
	Err_cnt                   uint64
}

type CryptoStatRNG struct {
	Type          [64]int8
	Generate_cnt  uint64
	Generate_tlen uint64
	Seed_cnt      uint64
	Err_cnt       uint64
}

type CryptoStatLarval struct {
	Type [64]int8
}

type CryptoReportLarval struct {
	Type [64]int8
}

type CryptoReportHash struct {
	Type       [64]int8
	Blocksize  uint32
	Digestsize uint32
}

type CryptoReportCipher struct {
	Type        [64]int8
	Blocksize   uint32
	Min_keysize uint32
	Max_keysize uint32
}

type CryptoReportBlkCipher struct {
	Type        [64]int8
	Geniv       [64]int8
	Blocksize   uint32
	Min_keysize uint32
	Max_keysize uint32
	Ivsize      uint32
}

type CryptoReportAEAD struct {
	Type        [64]int8
	Geniv       [64]int8
	Blocksize   uint32
	Maxauthsize uint32
	Ivsize      uint32
}

type CryptoReportComp struct {
	Type [64]int8
}

type CryptoReportRNG struct {
	Type     [64]int8
	Seedsize uint32
}

type CryptoReportAKCipher struct {
	Type [64]int8
}

type CryptoReportKPP struct {
	Type [64]int8
}

type CryptoReportAcomp struct {
	Type [64]int8
}

type LoopInfo struct {
	Number           int32
	Device           uint32
	Inode            uint32
	Rdevice          uint32
	Offset           int32
	Encrypt_type     int32
	Encrypt_key_size int32
	Flags            int32
	Name             [64]int8
	Encrypt_key      [32]uint8
	Init             [2]uint32
	Reserved         [4]int8
}

type TIPCSubscr struct {
	Seq     TIPCServiceRange
	Timeout uint32
	Filter  uint32
	Handle  [8]int8
}

type TIPCSIOCLNReq struct {
	Peer     uint32
	Id       uint32
	Linkname [68]int8
}

type TIPCSIOCNodeIDReq struct {
	Peer uint32
	Id   [16]int8
}

type PPSKInfo struct {
	Assert_sequence uint32
	Clear_sequence  uint32
	Assert_tu       PPSKTime
	Clear_tu        PPSKTime
	Current_mode    int32
	_               [4]byte
}

const (
	PPS_GETPARAMS = 0x400470a1
	PPS_SETPARAMS = 0x800470a2
	PPS_GETCAP    = 0x400470a3
	PPS_FETCH     = 0xc00470a4
)

const (
	PIDFD_NONBLOCK = 0x80
)

type SysvIpcPerm struct {
	Key  int32
	Uid  uint32
	Gid  uint32
	Cuid uint32
	Cgid uint32
	Mode uint32
	_    [0]uint8
	Seq  uint16
	_    uint16
	_    uint32
	_    uint32
}
type SysvShmDesc struct {
	Perm       SysvIpcPerm
	Segsz      uint32
	Atime      uint32
	Dtime      uint32
	Ctime      uint32
	Cpid       int32
	Lpid       int32
	Nattch     uint32
	Atime_high uint16
	Dtime_high uint16
	Ctime_high uint16
	_          uint16
}
```
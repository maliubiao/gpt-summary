Response:
Let's break down the thought process for analyzing the provided Go code snippet.

1. **Initial Understanding:** The first thing that jumps out is the header: `// go run mksyscall_aix_ppc64.go -aix -tags aix,ppc64 syscall_aix.go syscall_aix_ppc64.go`. This tells us that this file is *generated* and is specific to the `aix` operating system and the `ppc64` architecture. The `// Code generated by... DO NOT EDIT.` reinforces this.

2. **Purpose of `zsyscall_*.go` files:**  Recognizing the naming convention `zsyscall_OS_ARCH.go` is crucial. These files are part of Go's internal mechanism for making system calls. They bridge the gap between Go code and the operating system's kernel. The "z" often indicates a generated or low-level system call interface.

3. **Identifying the Core Functionality:**  The code consists of a series of Go functions. Each function has a similar structure:
    * It takes Go-level arguments (strings, integers, slices, structs).
    * It often uses `unsafe.Pointer` to convert Go types to raw memory addresses.
    * It calls a function prefixed with `call` (e.g., `callutimes`, `callgetcwd`).
    * It handles potential errors by checking the return value of the `call` function and converting a non-zero error code to a Go `error`.

4. **Connecting `call...` functions to System Calls:** The `call...` functions are the key. The naming convention strongly suggests a direct mapping to POSIX system calls. For instance, `callutimes` likely corresponds to the `utimes` system call, `callgetcwd` to `getcwd`, and so on.

5. **Inferring Function Purposes:** Based on the function names and their arguments, we can infer their purpose:
    * Functions like `utimes`, `utimensat` deal with file timestamps.
    * `getcwd` gets the current working directory.
    * `accept` handles accepting network connections.
    * `getdirent` reads directory entries.
    * `wait4` waits for a child process to change state.
    * `ioctl` performs device-specific control operations.
    * `fcntl` manipulates file descriptors.
    * And so forth. The names are generally quite descriptive if you're familiar with basic system programming concepts.

6. **Go Feature Connection (System Calls):** The core Go feature being implemented here is the ability to make *system calls*. Go's standard library (`os` package, `syscall` package) provides higher-level abstractions, but these `zsyscall_*.go` files are closer to the metal.

7. **Illustrative Go Code Examples:**  To demonstrate how these functions are used, we need to show how the higher-level Go libraries might call these low-level functions. This involves:
    * Importing relevant packages (`syscall`, `os`).
    * Calling functions from these packages that internally rely on the `zsyscall_*.go` functions.
    * Providing simple examples with clear inputs and expected outputs (or potential errors).

8. **Command-Line Argument Processing (for the Generator):** The initial comment `// go run mksyscall_aix_ppc64.go -aix -tags aix,ppc64 syscall_aix.go syscall_aix_ppc64.go` reveals the command used to generate this file. We need to explain the purpose of the `mksyscall` tool and the meaning of the flags (`-aix`, `-tags`).

9. **Common Mistakes:**  Thinking about common pitfalls for users interacting with system calls directly (even indirectly through the standard library) is important. This leads to points like incorrect buffer sizes, misinterpreting return values, and platform-specific behavior.

10. **Structure and Clarity:** Finally, organizing the information logically with clear headings and examples is crucial for readability and understanding. Starting with a summary, then detailing each aspect (functionality, Go feature, examples, command-line, errors) makes the explanation comprehensive.

**Self-Correction/Refinement During the Thought Process:**

* **Initial thought:**  "These look like a lot of low-level functions."  **Refinement:** "Yes, they are likely the underlying implementation of system calls for this specific OS and architecture."
* **Initial thought:** "What are these `call...` functions?" **Refinement:** "They must be the actual assembly or C wrappers that execute the system calls."
* **Initial thought:** "How do I show how these are used?" **Refinement:** "Focus on the higher-level Go packages that abstract these low-level calls."
* **Initial thought:** "The command-line part is just for generation, not runtime." **Refinement:** "Correct, but it's important to understand how this file came to be."

By following these steps and iteratively refining the understanding, we can arrive at a comprehensive and accurate description of the provided Go code.
这段代码是 Go 语言运行时库中用于在 AIX (Advanced Interactive eXecutive) 操作系统且 CPU 架构为 ppc64 (PowerPC 64-bit) 的系统上执行底层系统调用的部分。它是由 `mksyscall` 工具自动生成的，目的是为了提供 Go 语言程序与 AIX 系统内核交互的桥梁。

**功能列举:**

这段代码定义了一系列 Go 函数，这些函数是对 AIX 系统调用的 Go 语言封装。每个函数都对应一个或多个 AIX 系统调用，负责执行特定的操作系统操作。以下是代码中包含的功能列表（按照代码出现的顺序）：

1. **utimes:**  修改文件的访问和修改时间。
2. **utimensat:**  以原子方式修改相对于目录文件描述符的文件的时间戳。
3. **getcwd:**  获取当前工作目录的路径。
4. **accept:**  接受一个套接字连接。
5. **getdirent:**  从目录流中读取目录条目。
6. **wait4:**  等待进程状态的改变。
7. **ioctl:**  对设备执行控制操作。
8. **ioctlPtr:**  `ioctl` 的一个变体，使用 `unsafe.Pointer` 作为参数。
9. **FcntlInt:**  执行文件控制操作，参数为整数。
10. **FcntlFlock:**  执行文件控制操作，用于文件锁。
11. **fcntl:**  执行文件控制操作。
12. **fsyncRange:**  将文件特定范围的数据同步到存储设备。
13. **Acct:**  启用或禁用进程记账。
14. **Chdir:**  改变当前工作目录。
15. **Chroot:**  改变进程的根目录。
16. **Close:**  关闭一个文件描述符。
17. **Dup:**  复制一个文件描述符。
18. **Exit:**  终止当前进程。
19. **Faccessat:**  检查用户是否具有访问文件的权限（相对于目录文件描述符）。
20. **Fchdir:**  将当前工作目录更改为与文件描述符关联的目录。
21. **Fchmod:**  更改文件的权限。
22. **Fchmodat:**  更改文件的权限（相对于目录文件描述符）。
23. **Fchownat:**  更改文件的所有者和组（相对于目录文件描述符）。
24. **Fdatasync:**  将文件的已修改数据同步到存储设备（不包括元数据）。
25. **Getpgid:**  获取进程组 ID。
26. **Getpgrp:**  获取当前进程组 ID。
27. **Getpid:**  获取当前进程 ID。
28. **Getppid:**  获取父进程 ID。
29. **Getpriority:**  获取进程的调度优先级。
30. **Getrusage:**  获取进程的资源使用情况。
31. **Getsid:**  获取会话 ID。
32. **Kill:**  向进程发送信号。
33. **Klogctl:**  控制内核日志守护进程（syslog）。
34. **Mkdir:**  创建目录。
35. **Mkdirat:**  创建目录（相对于目录文件描述符）。
36. **Mkfifo:**  创建一个 FIFO 特殊文件。
37. **Mknod:**  创建一个文件系统节点。
38. **Mknodat:**  创建一个文件系统节点（相对于目录文件描述符）。
39. **Nanosleep:**  使当前线程休眠指定的时间。
40. **Open:**  打开一个文件。
41. **Openat:**  打开一个文件（相对于目录文件描述符）。
42. **read:**  从文件描述符读取数据。
43. **Readlink:**  读取符号链接的目标。
44. **Renameat:**  重命名文件（相对于目录文件描述符）。
45. **Setdomainname:**  设置系统域名。
46. **Sethostname:**  设置系统主机名。
47. **Setpgid:**  设置进程组 ID。
48. **Setsid:**  创建一个新的会话。
49. **Settimeofday:**  设置系统时间。
50. **Setuid:**  设置进程的实际用户 ID。
51. **Setgid:**  设置进程的实际组 ID。
52. **Setpriority:**  设置进程的调度优先级。
53. **Statx:**  获取文件的扩展状态信息。
54. **Sync:**  将所有修改过的块缓冲区同步到磁盘。
55. **Times:**  获取进程的 CPU 时间信息。
56. **Umask:**  设置文件模式创建掩码。
57. **Uname:**  获取系统信息。
58. **Unlink:**  删除文件。
59. **Unlinkat:**  删除文件（相对于目录文件描述符）。
60. **Ustat:**  返回文件系统的状态信息。
61. **write:**  向文件描述符写入数据。
62. **Dup2:**  复制文件描述符到指定的文件描述符编号。
63. **Fadvise:**  向内核提供关于文件访问模式的建议。
64. **Fchown:**  更改文件的所有者和组。
65. **fstat:**  获取文件的状态信息（通过文件描述符）。
66. **fstatat:**  获取文件的状态信息（相对于目录文件描述符）。
67. **Fstatfs:**  获取文件系统的状态信息（通过文件描述符）。
68. **Ftruncate:**  将文件截断为指定长度。
69. **Getegid:**  获取有效组 ID。
70. **Geteuid:**  获取有效用户 ID。
71. **Getgid:**  获取实际组 ID。
72. **Getuid:**  获取实际用户 ID。
73. **Lchown:**  更改符号链接的所有者和组。
74. **Listen:**  监听套接字上的连接。
75. **lstat:**  获取文件的状态信息（对于符号链接，获取链接本身的状态）。
76. **Pause:**  暂停进程直到收到信号。
77. **pread:**  从指定偏移量处读取文件描述符中的数据。
78. **pwrite:**  从指定偏移量处向文件描述符写入数据。
79. **Select:**  同步 I/O 多路复用。
80. **Pselect:**  同步 I/O 多路复用，允许指定信号掩码。
81. **Setregid:**  设置实际和有效组 ID。
82. **Setreuid:**  设置实际和有效用户 ID。
83. **Shutdown:**  关闭套接字的部分或全部连接。
84. **Splice:**  在两个文件描述符之间移动数据。
85. **stat:**  获取文件的状态信息。
86. **Statfs:**  获取文件系统的状态信息。
87. **Truncate:**  将文件截断为指定长度。
88. **bind:**  将本地协议地址赋予一个套接字。
89. **connect:**  在套接字上发起连接。
90. **getgroups:**  获取当前进程所属的组 ID 列表。
91. **setgroups:**  设置当前进程的附属组 ID 列表。
92. **getsockopt:**  获取套接字的选项。
93. **setsockopt:**  设置套接字的选项。
94. **socket:**  创建一个套接字。
95. **socketpair:**  创建一对已连接的套接字。
96. **getpeername:**  获取连接到套接字的对端的地址。
97. **getsockname:**  获取套接字的本地地址。
98. **recvfrom:**  从套接字接收数据。
99. **sendto:**  向指定的目标地址发送数据。
100. **recvmsg:**  从套接字接收消息。
101. **sendmsg:**  向套接字发送消息。
102. **munmap:**  取消映射内存区域。
103. **Madvise:**  向内核提供关于内存区域使用模式的建议。
104. **Mprotect:**  设置内存区域的保护。
105. **Mlock:**  锁定内存页到 RAM 中。
106. **Mlockall:**  锁定调用进程所有映射的内存页到 RAM 中。
107. **Msync:**  将内存映射区域写回存储器。
108. **Munlock:**  解锁内存页。
109. **Munlockall:**  解锁调用进程所有映射的内存页。
110. **pipe:**  创建一个管道。
111. **poll:**  等待一组文件描述符上的事件。
112. **gettimeofday:**  获取当前时间和时区信息。
113. **Time:**  获取当前时间。
114. **Utime:**  设置文件的访问和修改时间。
115. **Getsystemcfg:**  获取系统配置信息。
116. **umount:**  卸载文件系统。
117. **Getrlimit:**  获取进程的资源限制。
118. **Seek:**  设置文件描述符的文件偏移量。
119. **mmap:**  将文件或设备映射到内存中。

**Go 语言功能的实现 (系统调用)**

这段代码的核心功能是 **实现 Go 语言的系统调用 (syscall)**。 Go 语言的 `syscall` 包和 `os` 包中的许多功能最终会调用这些底层的 `zsyscall_aix_ppc64.go` 文件中定义的函数，从而与操作系统进行交互。

**Go 代码示例:**

以下是一些使用 `os` 或 `syscall` 包中的函数，最终会通过 `zsyscall_aix_ppc64.go` 中的函数来执行系统调用的示例：

```go
package main

import (
	"fmt"
	"os"
	"syscall"
)

func main() {
	// 获取当前工作目录 (最终会调用 getcwd)
	dir, err := os.Getwd()
	if err != nil {
		fmt.Println("Error getting working directory:", err)
	} else {
		fmt.Println("Current working directory:", dir)
	}

	// 打开一个文件 (最终会调用 open 或 openat)
	file, err := os.Open("test.txt")
	if err != nil {
		fmt.Println("Error opening file:", err)
	} else {
		fmt.Println("File opened successfully:", file.Name())
		file.Close() // 最终会调用 close
	}

	// 创建一个目录 (最终会调用 mkdir 或 mkdirat)
	err = os.Mkdir("new_directory", 0755)
	if err != nil {
		fmt.Println("Error creating directory:", err)
	} else {
		fmt.Println("Directory created successfully")
		os.Remove("new_directory") // 最终会调用 unlink 或 rmdir
	}

	// 获取文件状态 (最终会调用 stat, fstat, 或 lstat)
	fileInfo, err := os.Stat("test.txt")
	if err != nil {
		fmt.Println("Error getting file info:", err)
	} else {
		fmt.Println("File size:", fileInfo.Size())
	}

	// 执行一个命令 (内部会涉及到 fork, execve, wait4 等系统调用)
	cmd := "ls"
	out, err := syscall.Exec("/bin/ls", []string{cmd, "-l"}, nil)
	if err != nil {
		// 注意: Exec 成功后不会返回，只有失败才会返回
		fmt.Println("Error executing command:", err)
		fmt.Println("Output:", out)
	}
}
```

**假设的输入与输出:**

假设当前目录下有一个名为 `test.txt` 的文件。

* **`os.Getwd()`:**
    * **输出:**  类似于 `/home/user/go/src/cmd/vendor/golang.org/x/sys/unix`  (取决于当前运行程序的路径)
* **`os.Open("test.txt")`:**
    * **假设 `test.txt` 存在:**  成功打开文件，返回 `*os.File` 对象。
    * **假设 `test.txt` 不存在:** 返回一个错误，例如 `open test.txt: no such file or directory`。
* **`os.Mkdir("new_directory", 0755)`:**
    * **假设成功:**  在当前目录下创建一个名为 `new_directory` 的目录。
    * **假设目录已存在:** 返回一个错误，例如 `mkdir new_directory: file exists`。
* **`os.Stat("test.txt")`:**
    * **假设 `test.txt` 存在:** 返回一个 `os.FileInfo` 接口，包含文件的大小、修改时间等信息。
    * **假设 `test.txt` 不存在:** 返回一个错误，例如 `stat test.txt: no such file or directory`。
* **`syscall.Exec("/bin/ls", []string{"ls", "-l"}, nil)`:**
    * **假设成功:**  会执行 `ls -l` 命令，并将结果输出到标准输出（示例代码中的 `Exec` 调用后通常不会到达 `fmt.Println`）。

**命令行参数的具体处理:**

该代码本身不直接处理命令行参数。它的作用是提供系统调用的底层接口。命令行参数的处理通常发生在更高级别的 Go 代码中，例如 `os` 包或用户编写的应用程序中。

然而，文件开头的注释提供了生成此文件的命令：

```
// go run mksyscall_aix_ppc64.go -aix -tags aix,ppc64 syscall_aix.go syscall_aix_ppc64.go
```

这个命令使用 `mksyscall_aix_ppc64.go` 这个 Go 程序来生成 `zsyscall_aix_ppc64.go` 文件。其命令行参数如下：

* **`-aix`**:  指定目标操作系统为 AIX。
* **`-tags aix,ppc64`**:  指定构建标签，用于条件编译。这段代码只会在构建目标为 AIX 且架构为 ppc64 时被编译。
* **`syscall_aix.go`**:  输入文件，包含了 AIX 特定的系统调用定义。
* **`syscall_aix_ppc64.go`**:  输出文件，即生成的系统调用封装代码。

`mksyscall` 工具会读取 `syscall_aix.go` 中的定义，并根据目标操作系统和架构生成相应的系统调用封装代码。

**使用者易犯错的点 (针对 `zsyscall_aix_ppc64.go` 间接用户):**

虽然开发者通常不会直接使用 `zsyscall_aix_ppc64.go` 中的函数，但理解其背后的机制有助于避免使用 `os` 和 `syscall` 包时的一些常见错误：

1. **不正确的错误处理:** 系统调用可能会返回错误。如果忽略这些错误，可能会导致程序行为异常。例如，打开文件失败但程序没有检查错误，后续的操作可能会崩溃。

   ```go
   file, _ := os.Open("nonexistent.txt") // 忽略了错误
   file.Close() // 可能导致 panic
   ```

   **正确的做法:**

   ```go
   file, err := os.Open("nonexistent.txt")
   if err != nil {
       fmt.Println("Error opening file:", err)
       return
   }
   defer file.Close()
   // ... 对文件进行操作 ...
   ```

2. **缓冲区大小不足:** 一些系统调用需要提供缓冲区来存储结果 (例如 `getcwd`, `read`)。如果提供的缓冲区太小，可能会导致数据截断或程序崩溃。

   ```go
   buf := make([]byte, 10)
   n, err := syscall.Readlink("/proc/self/exe", buf) // 假设 /proc/self/exe 路径很长
   if err != nil {
       fmt.Println("Error reading link:", err)
   } else {
       fmt.Println("Link:", string(buf[:n])) // 可能截断
   }
   ```

   **更安全的做法:** 预先分配足够大的缓冲区，或者多次调用直到读取所有数据。

3. **不理解文件描述符的生命周期:** 文件描述符是有限的资源。打开文件或套接字后，必须确保在使用完毕后正确关闭，否则可能导致资源泄漏。 使用 `defer` 语句可以确保资源被释放。

4. **平台差异:** 系统调用的行为和可用性可能因操作系统而异。依赖于特定于 AIX 的系统调用，而没有提供跨平台兼容性处理，会导致程序在其他操作系统上无法运行。

5. **不正确的权限设置:** 在创建文件或目录时，需要设置正确的权限。错误的权限设置可能导致安全问题或程序无法正常工作。

理解 `zsyscall_aix_ppc64.go` 的作用，有助于开发者更好地理解 Go 程序与底层操作系统交互的方式，从而编写更健壮和可靠的代码。

### 提示词
```
这是路径为go/src/cmd/vendor/golang.org/x/sys/unix/zsyscall_aix_ppc64.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
```

### 源代码
```go
// go run mksyscall_aix_ppc64.go -aix -tags aix,ppc64 syscall_aix.go syscall_aix_ppc64.go
// Code generated by the command above; see README.md. DO NOT EDIT.

//go:build aix && ppc64

package unix

import (
	"unsafe"
)

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func utimes(path string, times *[2]Timeval) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, e1 := callutimes(uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func utimensat(dirfd int, path string, times *[2]Timespec, flag int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, e1 := callutimensat(dirfd, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), flag)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getcwd(buf []byte) (err error) {
	var _p0 *byte
	if len(buf) > 0 {
		_p0 = &buf[0]
	}
	_, e1 := callgetcwd(uintptr(unsafe.Pointer(_p0)), len(buf))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) {
	r0, e1 := callaccept(s, uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
	fd = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getdirent(fd int, buf []byte) (n int, err error) {
	var _p0 *byte
	if len(buf) > 0 {
		_p0 = &buf[0]
	}
	r0, e1 := callgetdirent(fd, uintptr(unsafe.Pointer(_p0)), len(buf))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func wait4(pid Pid_t, status *_C_int, options int, rusage *Rusage) (wpid Pid_t, err error) {
	r0, e1 := callwait4(int(pid), uintptr(unsafe.Pointer(status)), options, uintptr(unsafe.Pointer(rusage)))
	wpid = Pid_t(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func ioctl(fd int, req int, arg uintptr) (err error) {
	_, e1 := callioctl(fd, req, arg)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func ioctlPtr(fd int, req int, arg unsafe.Pointer) (err error) {
	_, e1 := callioctl_ptr(fd, req, arg)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func FcntlInt(fd uintptr, cmd int, arg int) (r int, err error) {
	r0, e1 := callfcntl(fd, cmd, uintptr(arg))
	r = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func FcntlFlock(fd uintptr, cmd int, lk *Flock_t) (err error) {
	_, e1 := callfcntl(fd, cmd, uintptr(unsafe.Pointer(lk)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fcntl(fd int, cmd int, arg int) (val int, err error) {
	r0, e1 := callfcntl(uintptr(fd), cmd, uintptr(arg))
	val = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fsyncRange(fd int, how int, start int64, length int64) (err error) {
	_, e1 := callfsync_range(fd, how, start, length)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Acct(path string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, e1 := callacct(uintptr(unsafe.Pointer(_p0)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Chdir(path string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, e1 := callchdir(uintptr(unsafe.Pointer(_p0)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Chroot(path string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, e1 := callchroot(uintptr(unsafe.Pointer(_p0)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Close(fd int) (err error) {
	_, e1 := callclose(fd)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Dup(oldfd int) (fd int, err error) {
	r0, e1 := calldup(oldfd)
	fd = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Exit(code int) {
	callexit(code)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Faccessat(dirfd int, path string, mode uint32, flags int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, e1 := callfaccessat(dirfd, uintptr(unsafe.Pointer(_p0)), mode, flags)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fchdir(fd int) (err error) {
	_, e1 := callfchdir(fd)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fchmod(fd int, mode uint32) (err error) {
	_, e1 := callfchmod(fd, mode)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, e1 := callfchmodat(dirfd, uintptr(unsafe.Pointer(_p0)), mode, flags)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, e1 := callfchownat(dirfd, uintptr(unsafe.Pointer(_p0)), uid, gid, flags)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fdatasync(fd int) (err error) {
	_, e1 := callfdatasync(fd)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getpgid(pid int) (pgid int, err error) {
	r0, e1 := callgetpgid(pid)
	pgid = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getpgrp() (pid int) {
	r0, _ := callgetpgrp()
	pid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getpid() (pid int) {
	r0, _ := callgetpid()
	pid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getppid() (ppid int) {
	r0, _ := callgetppid()
	ppid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getpriority(which int, who int) (prio int, err error) {
	r0, e1 := callgetpriority(which, who)
	prio = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getrusage(who int, rusage *Rusage) (err error) {
	_, e1 := callgetrusage(who, uintptr(unsafe.Pointer(rusage)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getsid(pid int) (sid int, err error) {
	r0, e1 := callgetsid(pid)
	sid = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Kill(pid int, sig Signal) (err error) {
	_, e1 := callkill(pid, int(sig))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Klogctl(typ int, buf []byte) (n int, err error) {
	var _p0 *byte
	if len(buf) > 0 {
		_p0 = &buf[0]
	}
	r0, e1 := callsyslog(typ, uintptr(unsafe.Pointer(_p0)), len(buf))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Mkdir(dirfd int, path string, mode uint32) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, e1 := callmkdir(dirfd, uintptr(unsafe.Pointer(_p0)), mode)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Mkdirat(dirfd int, path string, mode uint32) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, e1 := callmkdirat(dirfd, uintptr(unsafe.Pointer(_p0)), mode)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Mkfifo(path string, mode uint32) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, e1 := callmkfifo(uintptr(unsafe.Pointer(_p0)), mode)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Mknod(path string, mode uint32, dev int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, e1 := callmknod(uintptr(unsafe.Pointer(_p0)), mode, dev)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Mknodat(dirfd int, path string, mode uint32, dev int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, e1 := callmknodat(dirfd, uintptr(unsafe.Pointer(_p0)), mode, dev)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Nanosleep(time *Timespec, leftover *Timespec) (err error) {
	_, e1 := callnanosleep(uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Open(path string, mode int, perm uint32) (fd int, err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	r0, e1 := callopen64(uintptr(unsafe.Pointer(_p0)), mode, perm)
	fd = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	r0, e1 := callopenat(dirfd, uintptr(unsafe.Pointer(_p0)), flags, mode)
	fd = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func read(fd int, p []byte) (n int, err error) {
	var _p0 *byte
	if len(p) > 0 {
		_p0 = &p[0]
	}
	r0, e1 := callread(fd, uintptr(unsafe.Pointer(_p0)), len(p))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Readlink(path string, buf []byte) (n int, err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	var _p1 *byte
	if len(buf) > 0 {
		_p1 = &buf[0]
	}
	r0, e1 := callreadlink(uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), len(buf))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(oldpath)
	if err != nil {
		return
	}
	var _p1 *byte
	_p1, err = BytePtrFromString(newpath)
	if err != nil {
		return
	}
	_, e1 := callrenameat(olddirfd, uintptr(unsafe.Pointer(_p0)), newdirfd, uintptr(unsafe.Pointer(_p1)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Setdomainname(p []byte) (err error) {
	var _p0 *byte
	if len(p) > 0 {
		_p0 = &p[0]
	}
	_, e1 := callsetdomainname(uintptr(unsafe.Pointer(_p0)), len(p))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Sethostname(p []byte) (err error) {
	var _p0 *byte
	if len(p) > 0 {
		_p0 = &p[0]
	}
	_, e1 := callsethostname(uintptr(unsafe.Pointer(_p0)), len(p))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Setpgid(pid int, pgid int) (err error) {
	_, e1 := callsetpgid(pid, pgid)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Setsid() (pid int, err error) {
	r0, e1 := callsetsid()
	pid = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Settimeofday(tv *Timeval) (err error) {
	_, e1 := callsettimeofday(uintptr(unsafe.Pointer(tv)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Setuid(uid int) (err error) {
	_, e1 := callsetuid(uid)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Setgid(uid int) (err error) {
	_, e1 := callsetgid(uid)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Setpriority(which int, who int, prio int) (err error) {
	_, e1 := callsetpriority(which, who, prio)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, e1 := callstatx(dirfd, uintptr(unsafe.Pointer(_p0)), flags, mask, uintptr(unsafe.Pointer(stat)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Sync() {
	callsync()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Times(tms *Tms) (ticks uintptr, err error) {
	r0, e1 := calltimes(uintptr(unsafe.Pointer(tms)))
	ticks = uintptr(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Umask(mask int) (oldmask int) {
	r0, _ := callumask(mask)
	oldmask = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Uname(buf *Utsname) (err error) {
	_, e1 := calluname(uintptr(unsafe.Pointer(buf)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Unlink(path string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, e1 := callunlink(uintptr(unsafe.Pointer(_p0)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Unlinkat(dirfd int, path string, flags int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, e1 := callunlinkat(dirfd, uintptr(unsafe.Pointer(_p0)), flags)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Ustat(dev int, ubuf *Ustat_t) (err error) {
	_, e1 := callustat(dev, uintptr(unsafe.Pointer(ubuf)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func write(fd int, p []byte) (n int, err error) {
	var _p0 *byte
	if len(p) > 0 {
		_p0 = &p[0]
	}
	r0, e1 := callwrite(fd, uintptr(unsafe.Pointer(_p0)), len(p))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Dup2(oldfd int, newfd int) (err error) {
	_, e1 := calldup2(oldfd, newfd)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fadvise(fd int, offset int64, length int64, advice int) (err error) {
	_, e1 := callposix_fadvise64(fd, offset, length, advice)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fchown(fd int, uid int, gid int) (err error) {
	_, e1 := callfchown(fd, uid, gid)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fstat(fd int, stat *Stat_t) (err error) {
	_, e1 := callfstat(fd, uintptr(unsafe.Pointer(stat)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, e1 := callfstatat(dirfd, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), flags)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fstatfs(fd int, buf *Statfs_t) (err error) {
	_, e1 := callfstatfs(fd, uintptr(unsafe.Pointer(buf)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Ftruncate(fd int, length int64) (err error) {
	_, e1 := callftruncate(fd, length)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getegid() (egid int) {
	r0, _ := callgetegid()
	egid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Geteuid() (euid int) {
	r0, _ := callgeteuid()
	euid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getgid() (gid int) {
	r0, _ := callgetgid()
	gid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getuid() (uid int) {
	r0, _ := callgetuid()
	uid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Lchown(path string, uid int, gid int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, e1 := calllchown(uintptr(unsafe.Pointer(_p0)), uid, gid)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Listen(s int, n int) (err error) {
	_, e1 := calllisten(s, n)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func lstat(path string, stat *Stat_t) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, e1 := calllstat(uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pause() (err error) {
	_, e1 := callpause()
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func pread(fd int, p []byte, offset int64) (n int, err error) {
	var _p0 *byte
	if len(p) > 0 {
		_p0 = &p[0]
	}
	r0, e1 := callpread64(fd, uintptr(unsafe.Pointer(_p0)), len(p), offset)
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func pwrite(fd int, p []byte, offset int64) (n int, err error) {
	var _p0 *byte
	if len(p) > 0 {
		_p0 = &p[0]
	}
	r0, e1 := callpwrite64(fd, uintptr(unsafe.Pointer(_p0)), len(p), offset)
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) {
	r0, e1 := callselect(nfd, uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pselect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *Sigset_t) (n int, err error) {
	r0, e1 := callpselect(nfd, uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Setregid(rgid int, egid int) (err error) {
	_, e1 := callsetregid(rgid, egid)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Setreuid(ruid int, euid int) (err error) {
	_, e1 := callsetreuid(ruid, euid)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Shutdown(fd int, how int) (err error) {
	_, e1 := callshutdown(fd, how)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error) {
	r0, e1 := callsplice(rfd, uintptr(unsafe.Pointer(roff)), wfd, uintptr(unsafe.Pointer(woff)), len, flags)
	n = int64(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func stat(path string, statptr *Stat_t) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, e1 := callstat(uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(statptr)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Statfs(path string, buf *Statfs_t) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, e1 := callstatfs(uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Truncate(path string, length int64) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, e1 := calltruncate(uintptr(unsafe.Pointer(_p0)), length)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) {
	_, e1 := callbind(s, uintptr(addr), uintptr(addrlen))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) {
	_, e1 := callconnect(s, uintptr(addr), uintptr(addrlen))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getgroups(n int, list *_Gid_t) (nn int, err error) {
	r0, e1 := callgetgroups(n, uintptr(unsafe.Pointer(list)))
	nn = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func setgroups(n int, list *_Gid_t) (err error) {
	_, e1 := callsetgroups(n, uintptr(unsafe.Pointer(list)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) {
	_, e1 := callgetsockopt(s, level, name, uintptr(val), uintptr(unsafe.Pointer(vallen)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) {
	_, e1 := callsetsockopt(s, level, name, uintptr(val), vallen)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func socket(domain int, typ int, proto int) (fd int, err error) {
	r0, e1 := callsocket(domain, typ, proto)
	fd = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func socketpair(domain int, typ int, proto int, fd *[2]int32) (err error) {
	_, e1 := callsocketpair(domain, typ, proto, uintptr(unsafe.Pointer(fd)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) {
	_, e1 := callgetpeername(fd, uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) {
	_, e1 := callgetsockname(fd, uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) {
	var _p0 *byte
	if len(p) > 0 {
		_p0 = &p[0]
	}
	r0, e1 := callrecvfrom(fd, uintptr(unsafe.Pointer(_p0)), len(p), flags, uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func sendto(s int, buf []byte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) {
	var _p0 *byte
	if len(buf) > 0 {
		_p0 = &buf[0]
	}
	_, e1 := callsendto(s, uintptr(unsafe.Pointer(_p0)), len(buf), flags, uintptr(to), uintptr(addrlen))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func recvmsg(s int, msg *Msghdr, flags int) (n int, err error) {
	r0, e1 := callnrecvmsg(s, uintptr(unsafe.Pointer(msg)), flags)
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func sendmsg(s int, msg *Msghdr, flags int) (n int, err error) {
	r0, e1 := callnsendmsg(s, uintptr(unsafe.Pointer(msg)), flags)
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func munmap(addr uintptr, length uintptr) (err error) {
	_, e1 := callmunmap(addr, length)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Madvise(b []byte, advice int) (err error) {
	var _p0 *byte
	if len(b) > 0 {
		_p0 = &b[0]
	}
	_, e1 := callmadvise(uintptr(unsafe.Pointer(_p0)), len(b), advice)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Mprotect(b []byte, prot int) (err error) {
	var _p0 *byte
	if len(b) > 0 {
		_p0 = &b[0]
	}
	_, e1 := callmprotect(uintptr(unsafe.Pointer(_p0)), len(b), prot)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Mlock(b []byte) (err error) {
	var _p0 *byte
	if len(b) > 0 {
		_p0 = &b[0]
	}
	_, e1 := callmlock(uintptr(unsafe.Pointer(_p0)), len(b))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Mlockall(flags int) (err error) {
	_, e1 := callmlockall(flags)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Msync(b []byte, flags int) (err error) {
	var _p0 *byte
	if len(b) > 0 {
		_p0 = &b[0]
	}
	_, e1 := callmsync(uintptr(unsafe.Pointer(_p0)), len(b), flags)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Munlock(b []byte) (err error) {
	var _p0 *byte
	if len(b) > 0 {
		_p0 = &b[0]
	}
	_, e1 := callmunlock(uintptr(unsafe.Pointer(_p0)), len(b))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Munlockall() (err error) {
	_, e1 := callmunlockall()
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func pipe(p *[2]_C_int) (err error) {
	_, e1 := callpipe(uintptr(unsafe.Pointer(p)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func poll(fds *PollFd, nfds int, timeout int) (n int, err error) {
	r0, e1 := callpoll(uintptr(unsafe.Pointer(fds)), nfds, timeout)
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func gettimeofday(tv *Timeval, tzp *Timezone) (err error) {
	_, e1 := callgettimeofday(uintptr(unsafe.Pointer(tv)), uintptr(unsafe.Pointer(tzp)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Time(t *Time_t) (tt Time_t, err error) {
	r0, e1 := calltime(uintptr(unsafe.Pointer(t)))
	tt = Time_t(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Utime(path string, buf *Utimbuf) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, e1 := callutime(uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getsystemcfg(label int) (n uint64) {
	r0, _ := callgetsystemcfg(label)
	n = uint64(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func umount(target string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(target)
	if err != nil {
		return
	}
	_, e1 := callumount(uintptr(unsafe.Pointer(_p0)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getrlimit(resource int, rlim *Rlimit) (err error) {
	_, e1 := callgetrlimit(resource, uintptr(unsafe.Pointer(rlim)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Seek(fd int, offset int64, whence int) (off int64, err error) {
	r0, e1 := calllseek(fd, offset, whence)
	off = int64(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error) {
	r0, e1 := callmmap64(addr, length, prot, flags, fd, offset)
	xaddr = uintptr(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}
```
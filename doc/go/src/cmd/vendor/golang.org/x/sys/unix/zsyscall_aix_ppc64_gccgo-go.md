Response:
Let's break down the thought process for analyzing the given Go code snippet.

**1. Initial Understanding and Context:**

* **File Path:** `go/src/cmd/vendor/golang.org/x/sys/unix/zsyscall_aix_ppc64_gccgo.go`  This immediately tells us several things:
    * It's part of the Go standard library's `syscall` package (via `golang.org/x/sys/unix`).
    * It's specifically for the `aix` operating system.
    * It's for the `ppc64` architecture (PowerPC 64-bit).
    * It's intended for use with the `gccgo` compiler (a less common Go compiler).
* **`// go run mksyscall_aix_ppc64.go ...`:** This comment is crucial. It reveals that the file is *generated* by another Go program (`mksyscall_aix_ppc64.go`). This means we shouldn't focus on the low-level logic of *how* things are implemented here, but rather *what system calls* are being interfaced with.
* **`// Code generated by the command above; see README.md. DO NOT EDIT.`:** Reinforces that this is generated code.
* **`//go:build aix && ppc64 && gccgo`:**  This is a Go build constraint, ensuring this file is only compiled for the specified target.
* **`package unix`:** Confirms it belongs to the `unix` subpackage.
* **`/* #include <stdint.h> ... */`:** This is a CGo block. It includes C header files and declares C functions. These C functions are the underlying system calls.

**2. Identifying the Core Functionality:**

The `#include` block lists various C functions. These are the core functionalities the Go code is providing access to. My first step is to recognize these as common POSIX/Unix system calls. I start listing them out and mentally categorize them:

* **File System Operations:** `utimes`, `utimensat`, `getcwd`, `getdirent`, `ioctl`, `fcntl`, `fsync_range`, `acct`, `chdir`, `chroot`, `close`, `faccessat`, `fchdir`, `fchmod`, `fchmodat`, `fchownat`, `fdatasync`, `mkdir`, `mkdirat`, `mkfifo`, `mknod`, `mknodat`, `open64`, `openat`, `read`, `readlink`, `renameat`, `unlink`, `unlinkat`, `ustat`, `write`, `fchown`, `fstat`, `fstatat`, `fstatfs`, `ftruncate`, `lchown`, `lstat`, `pread64`, `pwrite64`, `stat`, `statfs`, `truncate`
* **Process Management:** `wait4`, `exit`, `getpgid`, `getpgrp`, `getpid`, `getppid`, `getpriority`, `getrusage`, `getsid`, `kill`, `setpgid`, `setsid`, `setpriority`, `times`
* **Time and Date:** `nanosleep`, `settimeofday`, `gettimeofday`, `time`, `utime`
* **User and Group Management:** `setdomainname`, `sethostname`, `setuid`, `setgid`, `getegid`, `geteuid`, `getgid`, `getuid`, `setregid`, `setreuid`, `getgroups`, `setgroups`
* **Networking:** `accept`, `listen`, `select`, `pselect`, `shutdown`, `bind`, `connect`, `getsockopt`, `setsockopt`, `socket`, `socketpair`, `getpeername`, `getsockname`, `recvfrom`, `sendto`, `nrecvmsg`, `nsendmsg`
* **Memory Management:** `munmap`, `madvise`, `mprotect`, `mlock`, `mlockall`, `msync`, `munlock`, `munlockall`, `mmap64`
* **Pipes and Polling:** `pipe`, `poll`, `splice`
* **System Information:** `uname`, `getsystemcfg`, `getrlimit`
* **Other:** `dup`, `dup2`, `pause`, `sync`, `umask`, `umount`, `lseek`, `syslog`

**3. Analyzing the Go Function Wrappers:**

Next, I look at the generated Go functions. The pattern is very consistent:

* **Naming Convention:** `call` + C function name (e.g., `callutimes`, `callgetcwd`).
* **Parameters:**  They take Go types and often `uintptr` for memory addresses. The `_p0`, `_lenp0` naming suggests they represent pointers and lengths.
* **CGo Call:** Inside each Go function, there's a call to the corresponding C function using `C.<c_function_name>`. Type conversions are used (`C.uintptr_t`, `C.int`, `C.size_t`, etc.).
* **Error Handling:**  `syscall.GetErrno()` is called to retrieve the error code after the C call.
* **Return Values:** They return `uintptr` (likely representing return values or error codes) and `Errno` for error information.

**4. Inferring Go Functionality and Examples:**

Based on the C system calls, I can infer the corresponding Go functions they are likely used to implement. I choose a few representative examples:

* **`callgetcwd`:** Clearly related to getting the current working directory. I know the `os` package in Go has `os.Getwd()`.
* **`callopenat`:**  The "at" suffix often indicates relative path operations. I relate this to functions like `os.OpenFileAt` or similar in the `syscall` package.
* **`callwrite`:** A fundamental file operation, corresponding to `os.File.Write` or `syscall.Write`.
* **`callmkdirat`:**  Similar to `callopenat`, the "at" suggests a relative mkdir, so I think of `os.MkdirAll` or `syscall.Mkdirat`.
* **`callsocket`, `callbind`, `calllisten`, `callaccept`:**  These are the building blocks of network programming, clearly related to the `net` package in Go.

For each example, I construct a simple Go code snippet demonstrating its use. This involves:

* **Importing necessary packages:** `os`, `fmt`, `syscall`, `unsafe`, `net`.
* **Setting up inputs:** File paths, file descriptors, etc.
* **Calling the corresponding Go standard library function.**
* **Printing the output or error.**

**5. Command Line Arguments and Error Handling:**

* **Command Line:** The initial comment provides the command to generate the file. I analyze the flags: `-aix` specifies the OS, `-tags aix,ppc64` are build tags, and the last arguments are the input files for the generator.
* **Error Handling:** The consistent use of `syscall.GetErrno()` highlights how errors are handled at this low level. I point out that users need to check the returned `error` values in the standard Go functions.

**6. Common Mistakes:**

I consider what errors a user might make when interacting with these low-level syscalls (even indirectly through higher-level Go functions):

* **Incorrectly handling error returns:** Forgetting to check the `error` returned by functions.
* **Passing incorrect arguments:**  Especially with `uintptr`,  it's easy to pass the wrong memory address.
* **Not understanding permissions:** System calls like `mkdir` or `open` require correct permissions.

**7. Review and Refinement:**

Finally, I reread my analysis to ensure clarity, accuracy, and completeness. I check if the examples are understandable and if the explanations are concise. I ensure I've covered all the key aspects of the provided code snippet.
这个Go语言文件 `zsyscall_aix_ppc64_gccgo.go` 是 `golang.org/x/sys/unix` 包的一部分，它为在 **AIX 操作系统**上运行的 **PowerPC 64位架构** 的 Go 程序，并且使用 **gccgo编译器** 编译时，提供了与底层操作系统 **系统调用** 交互的能力。

**具体功能:**

这个文件包含了一系列 Go 函数，每个函数都对应一个 AIX 操作系统上的系统调用。这些 Go 函数充当了 C 语言系统调用接口的包装器 (wrapper)。它们负责：

1. **将 Go 的数据类型转换为 C 的数据类型:**  例如，将 Go 的 `string` 或 `[]byte` 转换为 C 的 `uintptr_t` 指针和 `size_t` 长度。
2. **调用底层的 C 语言系统调用:**  通过 `import "C"` 和 CGo 的机制调用 `#include` 中声明的 C 函数。
3. **将 C 语言系统调用的返回值和错误码转换为 Go 的返回值和 `syscall.Errno` 类型:** 使得 Go 程序可以方便地处理系统调用的结果和错误。

**实现的 Go 语言功能 (推理及代码示例):**

由于这个文件是系统调用的直接包装器，它本身并不实现高层次的 Go 语言功能。相反，Go 标准库中的其他包（如 `os`, `io`, `net` 等）会使用这些底层的系统调用包装器来实现更高级别的抽象功能。

我们可以根据文件中调用的 C 函数名来推断其对应的 Go 语言功能。以下是一些示例：

**1. 文件操作 (File Operations):**

* **`open64`, `openat`:** 用于打开文件。Go 中 `os.OpenFile`, `os.Create` 等函数最终会调用这些系统调用。
   ```go
   package main

   import (
       "fmt"
       "os"
   )

   func main() {
       file, err := os.OpenFile("test.txt", os.O_RDWR|os.O_CREATE, 0644)
       if err != nil {
           fmt.Println("Error opening file:", err)
           return
       }
       defer file.Close()
       fmt.Println("File opened successfully.")
   }
   ```
   **假设输入:**  当前目录下不存在 `test.txt` 文件。
   **预期输出:**  如果成功创建并打开文件，输出 "File opened successfully."。

* **`read`, `write`:** 用于读写文件。Go 中 `io.Reader`, `io.Writer` 接口以及 `os.File` 的 `Read`, `Write` 方法会用到这些系统调用。
   ```go
   package main

   import (
       "fmt"
       "os"
   )

   func main() {
       data := []byte("Hello, AIX!")
       file, err := os.Create("output.txt")
       if err != nil {
           fmt.Println("Error creating file:", err)
           return
       }
       defer file.Close()

       n, err := file.Write(data)
       if err != nil {
           fmt.Println("Error writing to file:", err)
           return
       }
       fmt.Printf("Wrote %d bytes to file.\n", n)
   }
   ```
   **假设输入:**  当前目录下。
   **预期输出:**  创建 `output.txt` 文件，并写入 "Hello, AIX!"，输出类似 "Wrote 11 bytes to file."。

* **`close`:** 用于关闭文件描述符。Go 中 `os.File.Close` 方法会调用此系统调用。
* **`mkdir`, `mkdirat`:** 用于创建目录。Go 中 `os.Mkdir`, `os.MkdirAll` 等函数会使用。
* **`unlink`, `unlinkat`:** 用于删除文件。Go 中 `os.Remove` 函数会使用。
* **`renameat`:** 用于重命名文件或目录。Go 中 `os.Rename` 函数会使用。
* **`stat`, `fstat`, `lstat`:** 用于获取文件或目录的元信息。Go 中 `os.Stat`, `os.Lstat` 等函数会使用。

**2. 进程管理 (Process Management):**

* **`getpid`, `getppid`:** 获取进程 ID 和父进程 ID。Go 中 `os.Getpid`, `os.Getppid` 函数会使用。
   ```go
   package main

   import (
       "fmt"
       "os"
   )

   func main() {
       fmt.Println("Process ID:", os.Getpid())
       fmt.Println("Parent Process ID:", os.Getppid())
   }
   ```
   **假设输入:**  无。
   **预期输出:**  当前进程和其父进程的 ID。

* **`exit`:** 终止进程。Go 中 `os.Exit` 函数会调用此系统调用。
* **`fork` (虽然没直接列出，但通常与 `wait4` 配合使用):** 创建子进程。Go 的 `os/exec` 包可能会间接使用。
* **`wait4`:** 等待子进程结束。Go 的 `os/exec` 包在运行外部命令时会使用。

**3. 网络编程 (Networking):**

* **`socket`:** 创建套接字。Go 中 `net.Dial`, `net.Listen` 等函数会使用。
* **`bind`:** 绑定地址到套接字。Go 中 `net.Listen` 函数会使用。
* **`listen`:** 监听连接。Go 中 `net.Listen` 函数会使用。
* **`accept`:** 接受连接。Go 中 `net.Listener.Accept` 方法会使用。
* **`connect`:** 连接到远程地址。Go 中 `net.Dial` 函数会使用。
* **`sendto`, `recvfrom`:** 在无连接的套接字上发送和接收数据。Go 中 `net.DialUDPConn.WriteTo`, `net.UDPConn.ReadFrom` 等会使用。
* **`getsockopt`, `setsockopt`:** 获取和设置套接字选项。Go 中 `net.Conn` 的相关方法会使用。

**4. 内存管理 (Memory Management):**

* **`mmap64`:** 映射文件或设备到内存。Go 中 `syscall.Mmap` 函数会使用。
* **`munmap`:** 取消内存映射。Go 中 `syscall.Munmap` 函数会使用。

**5. 其他:**

* **`ioctl`:**  设备特定的 I/O 控制操作。Go 中 `syscall.Syscall` 或更高级别的包可能会使用。
* **`fcntl`:** 文件控制操作，如获取/设置文件描述符标志。Go 中 `syscall.FcntlInt` 等函数会使用。
* **`gettimeofday`, `nanosleep`:** 获取当前时间和休眠。Go 中 `time` 包的相关函数会使用。

**命令行参数的具体处理:**

这个文件本身并不处理命令行参数。它是由 `mksyscall_aix_ppc64.go` 工具生成的。

根据注释 `// go run mksyscall_aix_ppc64.go -aix -tags aix,ppc64 syscall_aix.go syscall_aix_ppc64.go`，生成此文件的命令是：

* `go run mksyscall_aix_ppc64.go`:  运行 `mksyscall_aix_ppc64.go` 这个 Go 程序。
* `-aix`:  告诉生成器目标操作系统是 AIX。
* `-tags aix,ppc64`:  设置构建标签，这会影响哪些 Go 文件会被编译。
* `syscall_aix.go syscall_aix_ppc64.go`:  指定输入文件，`mksyscall_aix_ppc64.go` 会读取这些文件中的信息（可能包含系统调用的定义或其他元数据）来生成 `zsyscall_aix_ppc64_gccgo.go`。

**使用者易犯错的点:**

由于这是一个非常底层的库，普通 Go 开发者通常不会直接使用这个文件中的函数。他们会使用 `os`, `io`, `net`, `time` 等更高级别的包。

但是，如果开发者需要直接使用 `syscall` 包进行系统调用，以下是一些容易犯错的点：

1. **不正确的类型转换:**  系统调用通常需要特定类型的参数，例如 `uintptr` 表示内存地址。错误的类型转换会导致程序崩溃或产生不可预测的结果。例如，将一个普通的整数直接转换为 `uintptr` 而不获取变量的地址。
2. **忘记检查错误返回值:** 系统调用通常会返回一个错误码。必须检查 `syscall.GetErrno()` 的返回值来判断系统调用是否成功。忽略错误会导致程序在遇到问题时继续运行，最终可能导致更严重的问题。
   ```go
   package main

   import (
       "fmt"
       "syscall"
       "unsafe"
   )

   func main() {
       // 错误示例：忘记检查错误
       syscall.Chdir("/nonexistent_directory")
       fmt.Println("Successfully changed directory (this will likely not be printed)")

       // 正确示例：检查错误
       err := syscall.Chdir("/tmp")
       if err != nil {
           fmt.Println("Error changing directory:", err)
       } else {
           fmt.Println("Successfully changed directory to /tmp")
       }
   }
   ```
3. **不正确的内存管理:**  如果系统调用涉及到指针传递，需要确保传递的内存地址是有效的，并且在系统调用完成之前不会被释放。例如，传递一个局部变量的地址，但在系统调用完成前该函数返回，局部变量的内存被回收。
4. **不理解系统调用的语义:**  每个系统调用都有其特定的功能和限制。不理解系统调用的行为可能会导致不正确的使用。例如，`read` 系统调用返回读取的字节数，使用者需要正确处理这个返回值。
5. **平台差异:**  系统调用在不同的操作系统上可能有所不同。直接使用 `syscall` 可能会导致代码在其他平台上无法移植。这也是为什么 Go 标准库提供了跨平台的抽象。

总之，`zsyscall_aix_ppc64_gccgo.go` 是 Go 语言运行时环境与 AIX 操作系统底层交互的关键部分，它通过 CGo 机制为 Go 程序提供了访问系统调用的能力，但通常由更高级别的 Go 标准库包间接使用。直接使用需要对底层操作系统和系统调用有深入的理解。

### 提示词
```
这是路径为go/src/cmd/vendor/golang.org/x/sys/unix/zsyscall_aix_ppc64_gccgo.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
```

### 源代码
```go
// go run mksyscall_aix_ppc64.go -aix -tags aix,ppc64 syscall_aix.go syscall_aix_ppc64.go
// Code generated by the command above; see README.md. DO NOT EDIT.

//go:build aix && ppc64 && gccgo

package unix

/*
#include <stdint.h>
int utimes(uintptr_t, uintptr_t);
int utimensat(int, uintptr_t, uintptr_t, int);
int getcwd(uintptr_t, size_t);
int accept(int, uintptr_t, uintptr_t);
int getdirent(int, uintptr_t, size_t);
int wait4(int, uintptr_t, int, uintptr_t);
int ioctl(int, int, uintptr_t);
int fcntl(uintptr_t, int, uintptr_t);
int fsync_range(int, int, long long, long long);
int acct(uintptr_t);
int chdir(uintptr_t);
int chroot(uintptr_t);
int close(int);
int dup(int);
void exit(int);
int faccessat(int, uintptr_t, unsigned int, int);
int fchdir(int);
int fchmod(int, unsigned int);
int fchmodat(int, uintptr_t, unsigned int, int);
int fchownat(int, uintptr_t, int, int, int);
int fdatasync(int);
int getpgid(int);
int getpgrp();
int getpid();
int getppid();
int getpriority(int, int);
int getrusage(int, uintptr_t);
int getsid(int);
int kill(int, int);
int syslog(int, uintptr_t, size_t);
int mkdir(int, uintptr_t, unsigned int);
int mkdirat(int, uintptr_t, unsigned int);
int mkfifo(uintptr_t, unsigned int);
int mknod(uintptr_t, unsigned int, int);
int mknodat(int, uintptr_t, unsigned int, int);
int nanosleep(uintptr_t, uintptr_t);
int open64(uintptr_t, int, unsigned int);
int openat(int, uintptr_t, int, unsigned int);
int read(int, uintptr_t, size_t);
int readlink(uintptr_t, uintptr_t, size_t);
int renameat(int, uintptr_t, int, uintptr_t);
int setdomainname(uintptr_t, size_t);
int sethostname(uintptr_t, size_t);
int setpgid(int, int);
int setsid();
int settimeofday(uintptr_t);
int setuid(int);
int setgid(int);
int setpriority(int, int, int);
int statx(int, uintptr_t, int, int, uintptr_t);
int sync();
uintptr_t times(uintptr_t);
int umask(int);
int uname(uintptr_t);
int unlink(uintptr_t);
int unlinkat(int, uintptr_t, int);
int ustat(int, uintptr_t);
int write(int, uintptr_t, size_t);
int dup2(int, int);
int posix_fadvise64(int, long long, long long, int);
int fchown(int, int, int);
int fstat(int, uintptr_t);
int fstatat(int, uintptr_t, uintptr_t, int);
int fstatfs(int, uintptr_t);
int ftruncate(int, long long);
int getegid();
int geteuid();
int getgid();
int getuid();
int lchown(uintptr_t, int, int);
int listen(int, int);
int lstat(uintptr_t, uintptr_t);
int pause();
int pread64(int, uintptr_t, size_t, long long);
int pwrite64(int, uintptr_t, size_t, long long);
#define c_select select
int select(int, uintptr_t, uintptr_t, uintptr_t, uintptr_t);
int pselect(int, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t);
int setregid(int, int);
int setreuid(int, int);
int shutdown(int, int);
long long splice(int, uintptr_t, int, uintptr_t, int, int);
int stat(uintptr_t, uintptr_t);
int statfs(uintptr_t, uintptr_t);
int truncate(uintptr_t, long long);
int bind(int, uintptr_t, uintptr_t);
int connect(int, uintptr_t, uintptr_t);
int getgroups(int, uintptr_t);
int setgroups(int, uintptr_t);
int getsockopt(int, int, int, uintptr_t, uintptr_t);
int setsockopt(int, int, int, uintptr_t, uintptr_t);
int socket(int, int, int);
int socketpair(int, int, int, uintptr_t);
int getpeername(int, uintptr_t, uintptr_t);
int getsockname(int, uintptr_t, uintptr_t);
int recvfrom(int, uintptr_t, size_t, int, uintptr_t, uintptr_t);
int sendto(int, uintptr_t, size_t, int, uintptr_t, uintptr_t);
int nrecvmsg(int, uintptr_t, int);
int nsendmsg(int, uintptr_t, int);
int munmap(uintptr_t, uintptr_t);
int madvise(uintptr_t, size_t, int);
int mprotect(uintptr_t, size_t, int);
int mlock(uintptr_t, size_t);
int mlockall(int);
int msync(uintptr_t, size_t, int);
int munlock(uintptr_t, size_t);
int munlockall();
int pipe(uintptr_t);
int poll(uintptr_t, int, int);
int gettimeofday(uintptr_t, uintptr_t);
int time(uintptr_t);
int utime(uintptr_t, uintptr_t);
unsigned long long getsystemcfg(int);
int umount(uintptr_t);
int getrlimit(int, uintptr_t);
long long lseek(int, long long, int);
uintptr_t mmap64(uintptr_t, uintptr_t, int, int, int, long long);

*/
import "C"
import (
	"syscall"
	"unsafe"
)

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callutimes(_p0 uintptr, times uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.utimes(C.uintptr_t(_p0), C.uintptr_t(times)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callutimensat(dirfd int, _p0 uintptr, times uintptr, flag int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.utimensat(C.int(dirfd), C.uintptr_t(_p0), C.uintptr_t(times), C.int(flag)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callgetcwd(_p0 uintptr, _lenp0 int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.getcwd(C.uintptr_t(_p0), C.size_t(_lenp0)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callaccept(s int, rsa uintptr, addrlen uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.accept(C.int(s), C.uintptr_t(rsa), C.uintptr_t(addrlen)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callgetdirent(fd int, _p0 uintptr, _lenp0 int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.getdirent(C.int(fd), C.uintptr_t(_p0), C.size_t(_lenp0)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callwait4(pid int, status uintptr, options int, rusage uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.wait4(C.int(pid), C.uintptr_t(status), C.int(options), C.uintptr_t(rusage)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callioctl(fd int, req int, arg uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.ioctl(C.int(fd), C.int(req), C.uintptr_t(arg)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callioctl_ptr(fd int, req int, arg unsafe.Pointer) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.ioctl(C.int(fd), C.int(req), C.uintptr_t(uintptr(arg))))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callfcntl(fd uintptr, cmd int, arg uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.fcntl(C.uintptr_t(fd), C.int(cmd), C.uintptr_t(arg)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callfsync_range(fd int, how int, start int64, length int64) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.fsync_range(C.int(fd), C.int(how), C.longlong(start), C.longlong(length)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callacct(_p0 uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.acct(C.uintptr_t(_p0)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callchdir(_p0 uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.chdir(C.uintptr_t(_p0)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callchroot(_p0 uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.chroot(C.uintptr_t(_p0)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callclose(fd int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.close(C.int(fd)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func calldup(oldfd int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.dup(C.int(oldfd)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callexit(code int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.exit(C.int(code)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callfaccessat(dirfd int, _p0 uintptr, mode uint32, flags int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.faccessat(C.int(dirfd), C.uintptr_t(_p0), C.uint(mode), C.int(flags)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callfchdir(fd int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.fchdir(C.int(fd)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callfchmod(fd int, mode uint32) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.fchmod(C.int(fd), C.uint(mode)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callfchmodat(dirfd int, _p0 uintptr, mode uint32, flags int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.fchmodat(C.int(dirfd), C.uintptr_t(_p0), C.uint(mode), C.int(flags)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callfchownat(dirfd int, _p0 uintptr, uid int, gid int, flags int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.fchownat(C.int(dirfd), C.uintptr_t(_p0), C.int(uid), C.int(gid), C.int(flags)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callfdatasync(fd int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.fdatasync(C.int(fd)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callgetpgid(pid int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.getpgid(C.int(pid)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callgetpgrp() (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.getpgrp())
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callgetpid() (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.getpid())
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callgetppid() (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.getppid())
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callgetpriority(which int, who int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.getpriority(C.int(which), C.int(who)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callgetrusage(who int, rusage uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.getrusage(C.int(who), C.uintptr_t(rusage)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callgetsid(pid int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.getsid(C.int(pid)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callkill(pid int, sig int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.kill(C.int(pid), C.int(sig)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callsyslog(typ int, _p0 uintptr, _lenp0 int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.syslog(C.int(typ), C.uintptr_t(_p0), C.size_t(_lenp0)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callmkdir(dirfd int, _p0 uintptr, mode uint32) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.mkdir(C.int(dirfd), C.uintptr_t(_p0), C.uint(mode)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callmkdirat(dirfd int, _p0 uintptr, mode uint32) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.mkdirat(C.int(dirfd), C.uintptr_t(_p0), C.uint(mode)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callmkfifo(_p0 uintptr, mode uint32) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.mkfifo(C.uintptr_t(_p0), C.uint(mode)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callmknod(_p0 uintptr, mode uint32, dev int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.mknod(C.uintptr_t(_p0), C.uint(mode), C.int(dev)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callmknodat(dirfd int, _p0 uintptr, mode uint32, dev int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.mknodat(C.int(dirfd), C.uintptr_t(_p0), C.uint(mode), C.int(dev)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callnanosleep(time uintptr, leftover uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.nanosleep(C.uintptr_t(time), C.uintptr_t(leftover)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callopen64(_p0 uintptr, mode int, perm uint32) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.open64(C.uintptr_t(_p0), C.int(mode), C.uint(perm)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callopenat(dirfd int, _p0 uintptr, flags int, mode uint32) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.openat(C.int(dirfd), C.uintptr_t(_p0), C.int(flags), C.uint(mode)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callread(fd int, _p0 uintptr, _lenp0 int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.read(C.int(fd), C.uintptr_t(_p0), C.size_t(_lenp0)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callreadlink(_p0 uintptr, _p1 uintptr, _lenp1 int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.readlink(C.uintptr_t(_p0), C.uintptr_t(_p1), C.size_t(_lenp1)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callrenameat(olddirfd int, _p0 uintptr, newdirfd int, _p1 uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.renameat(C.int(olddirfd), C.uintptr_t(_p0), C.int(newdirfd), C.uintptr_t(_p1)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callsetdomainname(_p0 uintptr, _lenp0 int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.setdomainname(C.uintptr_t(_p0), C.size_t(_lenp0)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callsethostname(_p0 uintptr, _lenp0 int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.sethostname(C.uintptr_t(_p0), C.size_t(_lenp0)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callsetpgid(pid int, pgid int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.setpgid(C.int(pid), C.int(pgid)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callsetsid() (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.setsid())
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callsettimeofday(tv uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.settimeofday(C.uintptr_t(tv)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callsetuid(uid int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.setuid(C.int(uid)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callsetgid(uid int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.setgid(C.int(uid)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callsetpriority(which int, who int, prio int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.setpriority(C.int(which), C.int(who), C.int(prio)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callstatx(dirfd int, _p0 uintptr, flags int, mask int, stat uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.statx(C.int(dirfd), C.uintptr_t(_p0), C.int(flags), C.int(mask), C.uintptr_t(stat)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callsync() (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.sync())
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func calltimes(tms uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.times(C.uintptr_t(tms)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callumask(mask int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.umask(C.int(mask)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func calluname(buf uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.uname(C.uintptr_t(buf)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callunlink(_p0 uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.unlink(C.uintptr_t(_p0)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callunlinkat(dirfd int, _p0 uintptr, flags int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.unlinkat(C.int(dirfd), C.uintptr_t(_p0), C.int(flags)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callustat(dev int, ubuf uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.ustat(C.int(dev), C.uintptr_t(ubuf)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callwrite(fd int, _p0 uintptr, _lenp0 int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.write(C.int(fd), C.uintptr_t(_p0), C.size_t(_lenp0)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func calldup2(oldfd int, newfd int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.dup2(C.int(oldfd), C.int(newfd)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callposix_fadvise64(fd int, offset int64, length int64, advice int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.posix_fadvise64(C.int(fd), C.longlong(offset), C.longlong(length), C.int(advice)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callfchown(fd int, uid int, gid int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.fchown(C.int(fd), C.int(uid), C.int(gid)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callfstat(fd int, stat uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.fstat(C.int(fd), C.uintptr_t(stat)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callfstatat(dirfd int, _p0 uintptr, stat uintptr, flags int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.fstatat(C.int(dirfd), C.uintptr_t(_p0), C.uintptr_t(stat), C.int(flags)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callfstatfs(fd int, buf uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.fstatfs(C.int(fd), C.uintptr_t(buf)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callftruncate(fd int, length int64) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.ftruncate(C.int(fd), C.longlong(length)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callgetegid() (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.getegid())
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callgeteuid() (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.geteuid())
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callgetgid() (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.getgid())
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callgetuid() (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.getuid())
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func calllchown(_p0 uintptr, uid int, gid int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.lchown(C.uintptr_t(_p0), C.int(uid), C.int(gid)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func calllisten(s int, n int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.listen(C.int(s), C.int(n)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func calllstat(_p0 uintptr, stat uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.lstat(C.uintptr_t(_p0), C.uintptr_t(stat)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callpause() (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.pause())
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callpread64(fd int, _p0 uintptr, _lenp0 int, offset int64) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.pread64(C.int(fd), C.uintptr_t(_p0), C.size_t(_lenp0), C.longlong(offset)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callpwrite64(fd int, _p0 uintptr, _lenp0 int, offset int64) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.pwrite64(C.int(fd), C.uintptr_t(_p0), C.size_t(_lenp0), C.longlong(offset)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callselect(nfd int, r uintptr, w uintptr, e uintptr, timeout uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.c_select(C.int(nfd), C.uintptr_t(r), C.uintptr_t(w), C.uintptr_t(e), C.uintptr_t(timeout)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callpselect(nfd int, r uintptr, w uintptr, e uintptr, timeout uintptr, sigmask uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.pselect(C.int(nfd), C.uintptr_t(r), C.uintptr_t(w), C.uintptr_t(e), C.uintptr_t(timeout), C.uintptr_t(sigmask)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callsetregid(rgid int, egid int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.setregid(C.int(rgid), C.int(egid)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callsetreuid(ruid int, euid int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.setreuid(C.int(ruid), C.int(euid)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callshutdown(fd int, how int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.shutdown(C.int(fd), C.int(how)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callsplice(rfd int, roff uintptr, wfd int, woff uintptr, len int, flags int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.splice(C.int(rfd), C.uintptr_t(roff), C.int(wfd), C.uintptr_t(woff), C.int(len), C.int(flags)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callstat(_p0 uintptr, statptr uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.stat(C.uintptr_t(_p0), C.uintptr_t(statptr)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callstatfs(_p0 uintptr, buf uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.statfs(C.uintptr_t(_p0), C.uintptr_t(buf)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func calltruncate(_p0 uintptr, length int64) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.truncate(C.uintptr_t(_p0), C.longlong(length)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callbind(s int, addr uintptr, addrlen uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.bind(C.int(s), C.uintptr_t(addr), C.uintptr_t(addrlen)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callconnect(s int, addr uintptr, addrlen uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.connect(C.int(s), C.uintptr_t(addr), C.uintptr_t(addrlen)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callgetgroups(n int, list uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.getgroups(C.int(n), C.uintptr_t(list)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callsetgroups(n int, list uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.setgroups(C.int(n), C.uintptr_t(list)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callgetsockopt(s int, level int, name int, val uintptr, vallen uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.getsockopt(C.int(s), C.int(level), C.int(name), C.uintptr_t(val), C.uintptr_t(vallen)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callsetsockopt(s int, level int, name int, val uintptr, vallen uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.setsockopt(C.int(s), C.int(level), C.int(name), C.uintptr_t(val), C.uintptr_t(vallen)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callsocket(domain int, typ int, proto int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.socket(C.int(domain), C.int(typ), C.int(proto)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callsocketpair(domain int, typ int, proto int, fd uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.socketpair(C.int(domain), C.int(typ), C.int(proto), C.uintptr_t(fd)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callgetpeername(fd int, rsa uintptr, addrlen uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.getpeername(C.int(fd), C.uintptr_t(rsa), C.uintptr_t(addrlen)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callgetsockname(fd int, rsa uintptr, addrlen uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.getsockname(C.int(fd), C.uintptr_t(rsa), C.uintptr_t(addrlen)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callrecvfrom(fd int, _p0 uintptr, _lenp0 int, flags int, from uintptr, fromlen uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.recvfrom(C.int(fd), C.uintptr_t(_p0), C.size_t(_lenp0), C.int(flags), C.uintptr_t(from), C.uintptr_t(fromlen)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callsendto(s int, _p0 uintptr, _lenp0 int, flags int, to uintptr, addrlen uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.sendto(C.int(s), C.uintptr_t(_p0), C.size_t(_lenp0), C.int(flags), C.uintptr_t(to), C.uintptr_t(addrlen)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callnrecvmsg(s int, msg uintptr, flags int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.nrecvmsg(C.int(s), C.uintptr_t(msg), C.int(flags)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callnsendmsg(s int, msg uintptr, flags int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.nsendmsg(C.int(s), C.uintptr_t(msg), C.int(flags)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callmunmap(addr uintptr, length uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.munmap(C.uintptr_t(addr), C.uintptr_t(length)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callmadvise(_p0 uintptr, _lenp0 int, advice int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.madvise(C.uintptr_t(_p0), C.size_t(_lenp0), C.int(advice)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callmprotect(_p0 uintptr, _lenp0 int, prot int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.mprotect(C.uintptr_t(_p0), C.size_t(_lenp0), C.int(prot)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callmlock(_p0 uintptr, _lenp0 int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.mlock(C.uintptr_t(_p0), C.size_t(_lenp0)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callmlockall(flags int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.mlockall(C.int(flags)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callmsync(_p0 uintptr, _lenp0 int, flags int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.msync(C.uintptr_t(_p0), C.size_t(_lenp0), C.int(flags)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callmunlock(_p0 uintptr, _lenp0 int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.munlock(C.uintptr_t(_p0), C.size_t(_lenp0)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callmunlockall() (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.munlockall())
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callpipe(p uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.pipe(C.uintptr_t(p)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callpoll(fds uintptr, nfds int, timeout int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.poll(C.uintptr_t(fds), C.int(nfds), C.int(timeout)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callgettimeofday(tv uintptr, tzp uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.gettimeofday(C.uintptr_t(tv), C.uintptr_t(tzp)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func calltime(t uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.time(C.uintptr_t(t)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callutime(_p0 uintptr, buf uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.utime(C.uintptr_t(_p0), C.uintptr_t(buf)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callgetsystemcfg(label int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.getsystemcfg(C.int(label)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callumount(_p0 uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.umount(C.uintptr_t(_p0)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callgetrlimit(resource int, rlim uintptr) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.getrlimit(C.int(resource), C.uintptr_t(rlim)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func calllseek(fd int, offset int64, whence int) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.lseek(C.int(fd), C.longlong(offset), C.int(whence)))
	e1 = syscall.GetErrno()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func callmmap64(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (r1 uintptr, e1 Errno) {
	r1 = uintptr(C.mmap64(C.uintptr_t(addr), C.uintptr_t(length), C.int(prot), C.int(flags), C.int(fd), C.longlong(offset)))
	e1 = syscall.GetErrno()
	return
}
```
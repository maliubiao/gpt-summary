Response:
Let's break down the thought process for answering the request about the `zsysnum_openbsd_ppc64.go` file.

**1. Understanding the Core Purpose:**

The first and most crucial step is recognizing what kind of file this is. The filename itself gives a big hint: `zsysnum`. The "sysnum" part strongly suggests system call numbers. The `openbsd` and `ppc64` parts indicate this is specific to the OpenBSD operating system and the PowerPC 64-bit architecture. The initial comment also confirms this: "Code generated by the command above; see README.md. DO NOT EDIT."  This means it's auto-generated and likely contains constants related to the operating system.

**2. Identifying the Content:**

Scanning the file's content reveals a long list of `const` declarations. Each constant starts with `SYS_` followed by a name in uppercase (e.g., `SYS_EXIT`, `SYS_OPEN`). The comments next to each constant further clarify its purpose, often showing a C-style function signature. This confirms the suspicion that these are indeed system call numbers.

**3. Functionality Summary:**

Based on the identified content, the primary function is clear:  It defines Go constants representing system call numbers for the OpenBSD operating system on the ppc64 architecture. These constants act as symbolic names for the underlying numerical system call identifiers.

**4. Connecting to Go Functionality (The "Why"):**

The next question is *why* does Go need these?  Go's standard library provides platform-independent ways to interact with the operating system (e.g., `os.Open`, `os.Read`). However, under the hood, these higher-level functions ultimately need to invoke the operating system's system calls.

This `zsysnum` file bridges the gap. It provides the specific numerical identifiers that the Go runtime (specifically the `syscall` package or lower-level interactions) uses when making system calls on this particular platform.

**5. Illustrative Go Code Example:**

To demonstrate this, it's necessary to show how these constants are used. The `syscall` package is the most direct way to interact with system calls in Go. A simple example would involve using the `syscall.Syscall` function.

* **Choosing a System Call:**  `SYS_OPEN` is a good choice because it's fundamental and relatively easy to demonstrate.

* **Mapping Go Code to System Call:**  The Go `os.Open` function internally will likely use `SYS_OPEN`. The example should demonstrate the manual use of `syscall.Syscall` with `SYS_OPEN`.

* **Constructing the Example:** This involves:
    * Importing the `syscall` package.
    * Defining a path to open.
    * Specifying the flags (e.g., `syscall.O_RDONLY`). This often requires looking up the corresponding Go constants in the `syscall` package.
    * Calling `syscall.Syscall` with `SYS_OPEN` and the appropriate arguments.
    * Handling the return values (file descriptor, error).
    * Closing the file descriptor.

* **Adding Input/Output and Assumptions:**  To make the example concrete, specify the assumed input (the filename) and the expected output (success or an error).

**6. Command-Line Argument Handling:**

The provided file itself *doesn't* handle command-line arguments. The comment at the top refers to `mksysnum.go`. This indicates that *another* program generated this file. The `mksysnum.go` script likely takes a URL as an argument to fetch the system call definitions. It's important to distinguish between the generated file and the generator script. The answer should explain this distinction and describe what `mksysnum.go` likely does.

**7. Common Mistakes:**

Think about how developers might misuse or misunderstand this file.

* **Directly Using the Constants:**  A common mistake would be trying to use these `SYS_` constants directly in application code for file I/O or other OS operations. This would be platform-specific and brittle. Emphasize that the standard library provides portable abstractions.

* **Modifying the File:** The "DO NOT EDIT" comment is crucial. Modifying this file directly could lead to instability or incorrect behavior. Explain why it's auto-generated.

* **Misunderstanding the Scope:**  Developers might not realize that these constants are specific to OpenBSD and ppc64. Highlight the platform-specific nature.

**8. Review and Refine:**

After drafting the answer, reread it to ensure clarity, accuracy, and completeness. Make sure the explanations are easy to understand, especially for someone who might not be deeply familiar with system calls. Check the code example for correctness and that it illustrates the intended point.

This systematic approach, from understanding the basic purpose to providing concrete examples and highlighting potential pitfalls, allows for a comprehensive and helpful answer to the user's query.
`go/src/cmd/vendor/golang.org/x/sys/unix/zsysnum_openbsd_ppc64.go` 这个文件在 Go 语言中扮演着至关重要的角色，它定义了一系列常量，这些常量代表了 OpenBSD 操作系统在 ppc64 架构下的系统调用号。

**功能列表:**

1. **定义系统调用号常量:**  文件中定义了大量的以 `SYS_` 开头的常量，例如 `SYS_EXIT`, `SYS_OPEN`, `SYS_READ` 等。每个常量都对应着 OpenBSD 内核中一个特定的系统调用，并赋予其一个唯一的数字标识。

2. **平台特定:** 该文件通过 `//go:build ppc64 && openbsd` 构建约束，明确指定了这些常量仅在 `ppc64` 架构的 `openbsd` 操作系统下编译和使用。

3. **供 Go 运行时系统调用使用:** 这些常量主要被 Go 语言的运行时系统调用相关代码使用。当 Go 程序需要执行一个底层的操作系统操作时，它会通过这些常量来指明需要调用哪个系统调用。

**Go 语言功能的实现 (系统调用):**

这个文件是 Go 语言实现与操作系统底层交互的关键部分。Go 语言提供了一种与平台无关的方式来执行许多常见的操作系统操作（例如文件读写、进程管理等）。然而，在底层，这些操作最终需要调用操作系统提供的系统调用。

`zsysnum_openbsd_ppc64.go` 文件中的常量就充当了 Go 语言和 OpenBSD 内核之间的桥梁。当 Go 程序调用标准库中的某个函数（例如 `os.Open`）时，Go 运行时会根据当前操作系统和架构，找到对应的系统调用号（例如 `SYS_OPEN`），然后通过汇编指令发起实际的系统调用。

**Go 代码举例说明:**

虽然我们通常不会直接在应用代码中使用这些 `SYS_` 常量，但可以通过 `syscall` 包来观察它们的用法。`syscall` 包允许 Go 程序直接进行系统调用。

```go
package main

import (
	"fmt"
	"syscall"
	"unsafe"
)

func main() {
	// 假设我们要打开一个文件进行读取 (只读模式)
	path := "/etc/passwd"
	flags := syscall.O_RDONLY
	mode := 0 // 对于 open 系统调用，如果 flags 包含 O_CREAT，则需要指定 mode

	// 使用 syscall.Syscall 直接调用 open 系统调用
	fd, _, err := syscall.Syscall(syscall.SYS_OPEN, uintptr(unsafe.Pointer(syscall.StringBytePtr(path))), uintptr(flags), uintptr(mode))
	if err != 0 {
		fmt.Printf("Error opening file: %v\n", err)
		return
	}
	fmt.Printf("File opened successfully. File descriptor: %d\n", fd)

	// 记得关闭文件描述符
	syscall.Close(int(fd))
}
```

**假设的输入与输出:**

* **假设输入:**
    * 操作系统: OpenBSD (ppc64 架构)
    * 文件路径: `/etc/passwd` (假设该文件存在且可读)

* **预期输出:**
    ```
    File opened successfully. File descriptor: 3
    ```
    (文件描述符的具体数字可能会有所不同，但表示成功打开)

* **如果 `/etc/passwd` 不存在或不可读，则输出可能为:**
    ```
    Error opening file: no such file or directory
    ```

**代码推理:**

上面的代码示例直接使用了 `syscall.SYS_OPEN` 常量来调用 `open` 系统调用。`syscall.Syscall` 函数接收系统调用号以及其参数。

1. `unsafe.Pointer(syscall.StringBytePtr(path))` 将 Go 字符串转换为 C 风格的字符串指针。
2. `uintptr(flags)` 和 `uintptr(mode)` 将 `flags` 和 `mode` 转换为 `uintptr` 类型，这是 `syscall.Syscall` 所要求的。

`syscall.Syscall` 返回三个值：
* 第一个是系统调用的返回值，对于 `open` 来说是文件描述符。
* 第二个通常被忽略，用于一些特殊的系统调用。
* 第三个是错误码，如果系统调用失败，则会返回一个非零值。

**命令行参数的具体处理:**

这个文件本身不处理命令行参数。它的作用是定义常量，这些常量在 Go 程序的编译过程中被内联到代码中。

注释中提到的 `go run mksysnum.go https://cvsweb.openbsd.org/cgi-bin/cvsweb/~checkout~/src/sys/kern/syscalls.master`  揭示了这个文件是如何生成的。`mksysnum.go` 是一个用于生成这些系统调用号常量的工具。它会从 OpenBSD 的源代码仓库中抓取 `syscalls.master` 文件，解析其中的系统调用定义，并生成 `zsysnum_openbsd_ppc64.go` 这样的文件。

`mksysnum.go` 脚本会处理命令行参数，例如这里的 URL。这个 URL 指向 OpenBSD 内核源代码中包含系统调用定义的 `syscalls.master` 文件。`mksysnum.go` 会连接到这个 URL，下载文件，然后解析内容。

**使用者易犯错的点:**

1. **直接修改此文件:**  由于该文件是自动生成的，直接修改它会被后续的重新生成操作覆盖。开发者应该避免手动修改此类文件。如果需要添加或修改系统调用号，应该修改生成脚本 (`mksysnum.go`) 或者其数据来源 (`syscalls.master`)。

2. **跨平台使用:**  `zsysnum_openbsd_ppc64.go` 中定义的常量只适用于 OpenBSD 操作系统在 ppc64 架构下。在其他操作系统或架构下使用这些常量会导致错误或不可预测的行为。开发者应该使用 Go 标准库提供的跨平台抽象，而不是直接依赖这些特定平台的常量。例如，使用 `os` 包进行文件操作，而不是直接调用 `syscall.Syscall` 并硬编码系统调用号。

3. **误解系统调用号的含义:** 系统调用号是操作系统内核实现的细节，可能会在不同的操作系统版本之间发生变化。因此，直接使用系统调用号编写的代码依赖于特定的操作系统版本。Go 语言通过提供标准库来屏蔽这些底层差异，使得开发者可以使用更加稳定和可移植的接口。

总而言之，`go/src/cmd/vendor/golang.org/x/sys/unix/zsysnum_openbsd_ppc64.go` 是 Go 语言为了在 OpenBSD (ppc64) 上执行系统调用而定义的一组关键常量，它是 Go 运行时系统与操作系统内核交互的基础，但一般情况下，应用开发者不需要直接操作这个文件或其中的常量。

Prompt: 
```
这是路径为go/src/cmd/vendor/golang.org/x/sys/unix/zsysnum_openbsd_ppc64.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，

"""
// go run mksysnum.go https://cvsweb.openbsd.org/cgi-bin/cvsweb/~checkout~/src/sys/kern/syscalls.master
// Code generated by the command above; see README.md. DO NOT EDIT.

//go:build ppc64 && openbsd

package unix

const (
	SYS_EXIT           = 1   // { void sys_exit(int rval); }
	SYS_FORK           = 2   // { int sys_fork(void); }
	SYS_READ           = 3   // { ssize_t sys_read(int fd, void *buf, size_t nbyte); }
	SYS_WRITE          = 4   // { ssize_t sys_write(int fd, const void *buf, size_t nbyte); }
	SYS_OPEN           = 5   // { int sys_open(const char *path, int flags, ... mode_t mode); }
	SYS_CLOSE          = 6   // { int sys_close(int fd); }
	SYS_GETENTROPY     = 7   // { int sys_getentropy(void *buf, size_t nbyte); }
	SYS___TFORK        = 8   // { int sys___tfork(const struct __tfork *param, size_t psize); }
	SYS_LINK           = 9   // { int sys_link(const char *path, const char *link); }
	SYS_UNLINK         = 10  // { int sys_unlink(const char *path); }
	SYS_WAIT4          = 11  // { pid_t sys_wait4(pid_t pid, int *status, int options, struct rusage *rusage); }
	SYS_CHDIR          = 12  // { int sys_chdir(const char *path); }
	SYS_FCHDIR         = 13  // { int sys_fchdir(int fd); }
	SYS_MKNOD          = 14  // { int sys_mknod(const char *path, mode_t mode, dev_t dev); }
	SYS_CHMOD          = 15  // { int sys_chmod(const char *path, mode_t mode); }
	SYS_CHOWN          = 16  // { int sys_chown(const char *path, uid_t uid, gid_t gid); }
	SYS_OBREAK         = 17  // { int sys_obreak(char *nsize); } break
	SYS_GETDTABLECOUNT = 18  // { int sys_getdtablecount(void); }
	SYS_GETRUSAGE      = 19  // { int sys_getrusage(int who, struct rusage *rusage); }
	SYS_GETPID         = 20  // { pid_t sys_getpid(void); }
	SYS_MOUNT          = 21  // { int sys_mount(const char *type, const char *path, int flags, void *data); }
	SYS_UNMOUNT        = 22  // { int sys_unmount(const char *path, int flags); }
	SYS_SETUID         = 23  // { int sys_setuid(uid_t uid); }
	SYS_GETUID         = 24  // { uid_t sys_getuid(void); }
	SYS_GETEUID        = 25  // { uid_t sys_geteuid(void); }
	SYS_PTRACE         = 26  // { int sys_ptrace(int req, pid_t pid, caddr_t addr, int data); }
	SYS_RECVMSG        = 27  // { ssize_t sys_recvmsg(int s, struct msghdr *msg, int flags); }
	SYS_SENDMSG        = 28  // { ssize_t sys_sendmsg(int s, const struct msghdr *msg, int flags); }
	SYS_RECVFROM       = 29  // { ssize_t sys_recvfrom(int s, void *buf, size_t len, int flags, struct sockaddr *from, socklen_t *fromlenaddr); }
	SYS_ACCEPT         = 30  // { int sys_accept(int s, struct sockaddr *name, socklen_t *anamelen); }
	SYS_GETPEERNAME    = 31  // { int sys_getpeername(int fdes, struct sockaddr *asa, socklen_t *alen); }
	SYS_GETSOCKNAME    = 32  // { int sys_getsockname(int fdes, struct sockaddr *asa, socklen_t *alen); }
	SYS_ACCESS         = 33  // { int sys_access(const char *path, int amode); }
	SYS_CHFLAGS        = 34  // { int sys_chflags(const char *path, u_int flags); }
	SYS_FCHFLAGS       = 35  // { int sys_fchflags(int fd, u_int flags); }
	SYS_SYNC           = 36  // { void sys_sync(void); }
	SYS_STAT           = 38  // { int sys_stat(const char *path, struct stat *ub); }
	SYS_GETPPID        = 39  // { pid_t sys_getppid(void); }
	SYS_LSTAT          = 40  // { int sys_lstat(const char *path, struct stat *ub); }
	SYS_DUP            = 41  // { int sys_dup(int fd); }
	SYS_FSTATAT        = 42  // { int sys_fstatat(int fd, const char *path, struct stat *buf, int flag); }
	SYS_GETEGID        = 43  // { gid_t sys_getegid(void); }
	SYS_PROFIL         = 44  // { int sys_profil(caddr_t samples, size_t size, u_long offset, u_int scale); }
	SYS_KTRACE         = 45  // { int sys_ktrace(const char *fname, int ops, int facs, pid_t pid); }
	SYS_SIGACTION      = 46  // { int sys_sigaction(int signum, const struct sigaction *nsa, struct sigaction *osa); }
	SYS_GETGID         = 47  // { gid_t sys_getgid(void); }
	SYS_SIGPROCMASK    = 48  // { int sys_sigprocmask(int how, sigset_t mask); }
	SYS_SETLOGIN       = 50  // { int sys_setlogin(const char *namebuf); }
	SYS_ACCT           = 51  // { int sys_acct(const char *path); }
	SYS_SIGPENDING     = 52  // { int sys_sigpending(void); }
	SYS_FSTAT          = 53  // { int sys_fstat(int fd, struct stat *sb); }
	SYS_IOCTL          = 54  // { int sys_ioctl(int fd, u_long com, ... void *data); }
	SYS_REBOOT         = 55  // { int sys_reboot(int opt); }
	SYS_REVOKE         = 56  // { int sys_revoke(const char *path); }
	SYS_SYMLINK        = 57  // { int sys_symlink(const char *path, const char *link); }
	SYS_READLINK       = 58  // { ssize_t sys_readlink(const char *path, char *buf, size_t count); }
	SYS_EXECVE         = 59  // { int sys_execve(const char *path, char * const *argp, char * const *envp); }
	SYS_UMASK          = 60  // { mode_t sys_umask(mode_t newmask); }
	SYS_CHROOT         = 61  // { int sys_chroot(const char *path); }
	SYS_GETFSSTAT      = 62  // { int sys_getfsstat(struct statfs *buf, size_t bufsize, int flags); }
	SYS_STATFS         = 63  // { int sys_statfs(const char *path, struct statfs *buf); }
	SYS_FSTATFS        = 64  // { int sys_fstatfs(int fd, struct statfs *buf); }
	SYS_FHSTATFS       = 65  // { int sys_fhstatfs(const fhandle_t *fhp, struct statfs *buf); }
	SYS_VFORK          = 66  // { int sys_vfork(void); }
	SYS_GETTIMEOFDAY   = 67  // { int sys_gettimeofday(struct timeval *tp, struct timezone *tzp); }
	SYS_SETTIMEOFDAY   = 68  // { int sys_settimeofday(const struct timeval *tv, const struct timezone *tzp); }
	SYS_SETITIMER      = 69  // { int sys_setitimer(int which, const struct itimerval *itv, struct itimerval *oitv); }
	SYS_GETITIMER      = 70  // { int sys_getitimer(int which, struct itimerval *itv); }
	SYS_SELECT         = 71  // { int sys_select(int nd, fd_set *in, fd_set *ou, fd_set *ex, struct timeval *tv); }
	SYS_KEVENT         = 72  // { int sys_kevent(int fd, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout); }
	SYS_MUNMAP         = 73  // { int sys_munmap(void *addr, size_t len); }
	SYS_MPROTECT       = 74  // { int sys_mprotect(void *addr, size_t len, int prot); }
	SYS_MADVISE        = 75  // { int sys_madvise(void *addr, size_t len, int behav); }
	SYS_UTIMES         = 76  // { int sys_utimes(const char *path, const struct timeval *tptr); }
	SYS_FUTIMES        = 77  // { int sys_futimes(int fd, const struct timeval *tptr); }
	SYS_GETGROUPS      = 79  // { int sys_getgroups(int gidsetsize, gid_t *gidset); }
	SYS_SETGROUPS      = 80  // { int sys_setgroups(int gidsetsize, const gid_t *gidset); }
	SYS_GETPGRP        = 81  // { int sys_getpgrp(void); }
	SYS_SETPGID        = 82  // { int sys_setpgid(pid_t pid, pid_t pgid); }
	SYS_FUTEX          = 83  // { int sys_futex(uint32_t *f, int op, int val, const struct timespec *timeout, uint32_t *g); }
	SYS_UTIMENSAT      = 84  // { int sys_utimensat(int fd, const char *path, const struct timespec *times, int flag); }
	SYS_FUTIMENS       = 85  // { int sys_futimens(int fd, const struct timespec *times); }
	SYS_KBIND          = 86  // { int sys_kbind(const struct __kbind *param, size_t psize, int64_t proc_cookie); }
	SYS_CLOCK_GETTIME  = 87  // { int sys_clock_gettime(clockid_t clock_id, struct timespec *tp); }
	SYS_CLOCK_SETTIME  = 88  // { int sys_clock_settime(clockid_t clock_id, const struct timespec *tp); }
	SYS_CLOCK_GETRES   = 89  // { int sys_clock_getres(clockid_t clock_id, struct timespec *tp); }
	SYS_DUP2           = 90  // { int sys_dup2(int from, int to); }
	SYS_NANOSLEEP      = 91  // { int sys_nanosleep(const struct timespec *rqtp, struct timespec *rmtp); }
	SYS_FCNTL          = 92  // { int sys_fcntl(int fd, int cmd, ... void *arg); }
	SYS_ACCEPT4        = 93  // { int sys_accept4(int s, struct sockaddr *name, socklen_t *anamelen, int flags); }
	SYS___THRSLEEP     = 94  // { int sys___thrsleep(const volatile void *ident, clockid_t clock_id, const struct timespec *tp, void *lock, const int *abort); }
	SYS_FSYNC          = 95  // { int sys_fsync(int fd); }
	SYS_SETPRIORITY    = 96  // { int sys_setpriority(int which, id_t who, int prio); }
	SYS_SOCKET         = 97  // { int sys_socket(int domain, int type, int protocol); }
	SYS_CONNECT        = 98  // { int sys_connect(int s, const struct sockaddr *name, socklen_t namelen); }
	SYS_GETDENTS       = 99  // { int sys_getdents(int fd, void *buf, size_t buflen); }
	SYS_GETPRIORITY    = 100 // { int sys_getpriority(int which, id_t who); }
	SYS_PIPE2          = 101 // { int sys_pipe2(int *fdp, int flags); }
	SYS_DUP3           = 102 // { int sys_dup3(int from, int to, int flags); }
	SYS_SIGRETURN      = 103 // { int sys_sigreturn(struct sigcontext *sigcntxp); }
	SYS_BIND           = 104 // { int sys_bind(int s, const struct sockaddr *name, socklen_t namelen); }
	SYS_SETSOCKOPT     = 105 // { int sys_setsockopt(int s, int level, int name, const void *val, socklen_t valsize); }
	SYS_LISTEN         = 106 // { int sys_listen(int s, int backlog); }
	SYS_CHFLAGSAT      = 107 // { int sys_chflagsat(int fd, const char *path, u_int flags, int atflags); }
	SYS_PLEDGE         = 108 // { int sys_pledge(const char *promises, const char *execpromises); }
	SYS_PPOLL          = 109 // { int sys_ppoll(struct pollfd *fds, u_int nfds, const struct timespec *ts, const sigset_t *mask); }
	SYS_PSELECT        = 110 // { int sys_pselect(int nd, fd_set *in, fd_set *ou, fd_set *ex, const struct timespec *ts, const sigset_t *mask); }
	SYS_SIGSUSPEND     = 111 // { int sys_sigsuspend(int mask); }
	SYS_SENDSYSLOG     = 112 // { int sys_sendsyslog(const char *buf, size_t nbyte, int flags); }
	SYS_UNVEIL         = 114 // { int sys_unveil(const char *path, const char *permissions); }
	SYS_GETSOCKOPT     = 118 // { int sys_getsockopt(int s, int level, int name, void *val, socklen_t *avalsize); }
	SYS_THRKILL        = 119 // { int sys_thrkill(pid_t tid, int signum, void *tcb); }
	SYS_READV          = 120 // { ssize_t sys_readv(int fd, const struct iovec *iovp, int iovcnt); }
	SYS_WRITEV         = 121 // { ssize_t sys_writev(int fd, const struct iovec *iovp, int iovcnt); }
	SYS_KILL           = 122 // { int sys_kill(int pid, int signum); }
	SYS_FCHOWN         = 123 // { int sys_fchown(int fd, uid_t uid, gid_t gid); }
	SYS_FCHMOD         = 124 // { int sys_fchmod(int fd, mode_t mode); }
	SYS_SETREUID       = 126 // { int sys_setreuid(uid_t ruid, uid_t euid); }
	SYS_SETREGID       = 127 // { int sys_setregid(gid_t rgid, gid_t egid); }
	SYS_RENAME         = 128 // { int sys_rename(const char *from, const char *to); }
	SYS_FLOCK          = 131 // { int sys_flock(int fd, int how); }
	SYS_MKFIFO         = 132 // { int sys_mkfifo(const char *path, mode_t mode); }
	SYS_SENDTO         = 133 // { ssize_t sys_sendto(int s, const void *buf, size_t len, int flags, const struct sockaddr *to, socklen_t tolen); }
	SYS_SHUTDOWN       = 134 // { int sys_shutdown(int s, int how); }
	SYS_SOCKETPAIR     = 135 // { int sys_socketpair(int domain, int type, int protocol, int *rsv); }
	SYS_MKDIR          = 136 // { int sys_mkdir(const char *path, mode_t mode); }
	SYS_RMDIR          = 137 // { int sys_rmdir(const char *path); }
	SYS_ADJTIME        = 140 // { int sys_adjtime(const struct timeval *delta, struct timeval *olddelta); }
	SYS_GETLOGIN_R     = 141 // { int sys_getlogin_r(char *namebuf, u_int namelen); }
	SYS_SETSID         = 147 // { int sys_setsid(void); }
	SYS_QUOTACTL       = 148 // { int sys_quotactl(const char *path, int cmd, int uid, char *arg); }
	SYS_NFSSVC         = 155 // { int sys_nfssvc(int flag, void *argp); }
	SYS_GETFH          = 161 // { int sys_getfh(const char *fname, fhandle_t *fhp); }
	SYS_SYSARCH        = 165 // { int sys_sysarch(int op, void *parms); }
	SYS_PREAD          = 173 // { ssize_t sys_pread(int fd, void *buf, size_t nbyte, int pad, off_t offset); }
	SYS_PWRITE         = 174 // { ssize_t sys_pwrite(int fd, const void *buf, size_t nbyte, int pad, off_t offset); }
	SYS_SETGID         = 181 // { int sys_setgid(gid_t gid); }
	SYS_SETEGID        = 182 // { int sys_setegid(gid_t egid); }
	SYS_SETEUID        = 183 // { int sys_seteuid(uid_t euid); }
	SYS_PATHCONF       = 191 // { long sys_pathconf(const char *path, int name); }
	SYS_FPATHCONF      = 192 // { long sys_fpathconf(int fd, int name); }
	SYS_SWAPCTL        = 193 // { int sys_swapctl(int cmd, const void *arg, int misc); }
	SYS_GETRLIMIT      = 194 // { int sys_getrlimit(int which, struct rlimit *rlp); }
	SYS_SETRLIMIT      = 195 // { int sys_setrlimit(int which, const struct rlimit *rlp); }
	SYS_MMAP           = 197 // { void *sys_mmap(void *addr, size_t len, int prot, int flags, int fd, long pad, off_t pos); }
	SYS_LSEEK          = 199 // { off_t sys_lseek(int fd, int pad, off_t offset, int whence); }
	SYS_TRUNCATE       = 200 // { int sys_truncate(const char *path, int pad, off_t length); }
	SYS_FTRUNCATE      = 201 // { int sys_ftruncate(int fd, int pad, off_t length); }
	SYS_SYSCTL         = 202 // { int sys_sysctl(const int *name, u_int namelen, void *old, size_t *oldlenp, void *new, size_t newlen); }
	SYS_MLOCK          = 203 // { int sys_mlock(const void *addr, size_t len); }
	SYS_MUNLOCK        = 204 // { int sys_munlock(const void *addr, size_t len); }
	SYS_GETPGID        = 207 // { pid_t sys_getpgid(pid_t pid); }
	SYS_UTRACE         = 209 // { int sys_utrace(const char *label, const void *addr, size_t len); }
	SYS_SEMGET         = 221 // { int sys_semget(key_t key, int nsems, int semflg); }
	SYS_MSGGET         = 225 // { int sys_msgget(key_t key, int msgflg); }
	SYS_MSGSND         = 226 // { int sys_msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg); }
	SYS_MSGRCV         = 227 // { int sys_msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg); }
	SYS_SHMAT          = 228 // { void *sys_shmat(int shmid, const void *shmaddr, int shmflg); }
	SYS_SHMDT          = 230 // { int sys_shmdt(const void *shmaddr); }
	SYS_MINHERIT       = 250 // { int sys_minherit(void *addr, size_t len, int inherit); }
	SYS_POLL           = 252 // { int sys_poll(struct pollfd *fds, u_int nfds, int timeout); }
	SYS_ISSETUGID      = 253 // { int sys_issetugid(void); }
	SYS_LCHOWN         = 254 // { int sys_lchown(const char *path, uid_t uid, gid_t gid); }
	SYS_GETSID         = 255 // { pid_t sys_getsid(pid_t pid); }
	SYS_MSYNC          = 256 // { int sys_msync(void *addr, size_t len, int flags); }
	SYS_PIPE           = 263 // { int sys_pipe(int *fdp); }
	SYS_FHOPEN         = 264 // { int sys_fhopen(const fhandle_t *fhp, int flags); }
	SYS_PREADV         = 267 // { ssize_t sys_preadv(int fd, const struct iovec *iovp, int iovcnt, int pad, off_t offset); }
	SYS_PWRITEV        = 268 // { ssize_t sys_pwritev(int fd, const struct iovec *iovp, int iovcnt, int pad, off_t offset); }
	SYS_KQUEUE         = 269 // { int sys_kqueue(void); }
	SYS_MLOCKALL       = 271 // { int sys_mlockall(int flags); }
	SYS_MUNLOCKALL     = 272 // { int sys_munlockall(void); }
	SYS_GETRESUID      = 281 // { int sys_getresuid(uid_t *ruid, uid_t *euid, uid_t *suid); }
	SYS_SETRESUID      = 282 // { int sys_setresuid(uid_t ruid, uid_t euid, uid_t suid); }
	SYS_GETRESGID      = 283 // { int sys_getresgid(gid_t *rgid, gid_t *egid, gid_t *sgid); }
	SYS_SETRESGID      = 284 // { int sys_setresgid(gid_t rgid, gid_t egid, gid_t sgid); }
	SYS_MQUERY         = 286 // { void *sys_mquery(void *addr, size_t len, int prot, int flags, int fd, long pad, off_t pos); }
	SYS_CLOSEFROM      = 287 // { int sys_closefrom(int fd); }
	SYS_SIGALTSTACK    = 288 // { int sys_sigaltstack(const struct sigaltstack *nss, struct sigaltstack *oss); }
	SYS_SHMGET         = 289 // { int sys_shmget(key_t key, size_t size, int shmflg); }
	SYS_SEMOP          = 290 // { int sys_semop(int semid, struct sembuf *sops, size_t nsops); }
	SYS_FHSTAT         = 294 // { int sys_fhstat(const fhandle_t *fhp, struct stat *sb); }
	SYS___SEMCTL       = 295 // { int sys___semctl(int semid, int semnum, int cmd, union semun *arg); }
	SYS_SHMCTL         = 296 // { int sys_shmctl(int shmid, int cmd, struct shmid_ds *buf); }
	SYS_MSGCTL         = 297 // { int sys_msgctl(int msqid, int cmd, struct msqid_ds *buf); }
	SYS_SCHED_YIELD    = 298 // { int sys_sched_yield(void); }
	SYS_GETTHRID       = 299 // { pid_t sys_getthrid(void); }
	SYS___THRWAKEUP    = 301 // { int sys___thrwakeup(const volatile void *ident, int n); }
	SYS___THREXIT      = 302 // { void sys___threxit(pid_t *notdead); }
	SYS___THRSIGDIVERT = 303 // { int sys___thrsigdivert(sigset_t sigmask, siginfo_t *info, const struct timespec *timeout); }
	SYS___GETCWD       = 304 // { int sys___getcwd(char *buf, size_t len); }
	SYS_ADJFREQ        = 305 // { int sys_adjfreq(const int64_t *freq, int64_t *oldfreq); }
	SYS_SETRTABLE      = 310 // { int sys_setrtable(int rtableid); }
	SYS_GETRTABLE      = 311 // { int sys_getrtable(void); }
	SYS_FACCESSAT      = 313 // { int sys_faccessat(int fd, const char *path, int amode, int flag); }
	SYS_FCHMODAT       = 314 // { int sys_fchmodat(int fd, const char *path, mode_t mode, int flag); }
	SYS_FCHOWNAT       = 315 // { int sys_fchownat(int fd, const char *path, uid_t uid, gid_t gid, int flag); }
	SYS_LINKAT         = 317 // { int sys_linkat(int fd1, const char *path1, int fd2, const char *path2, int flag); }
	SYS_MKDIRAT        = 318 // { int sys_mkdirat(int fd, const char *path, mode_t mode); }
	SYS_MKFIFOAT       = 319 // { int sys_mkfifoat(int fd, const char *path, mode_t mode); }
	SYS_MKNODAT        = 320 // { int sys_mknodat(int fd, const char *path, mode_t mode, dev_t dev); }
	SYS_OPENAT         = 321 // { int sys_openat(int fd, const char *path, int flags, ... mode_t mode); }
	SYS_READLINKAT     = 322 // { ssize_t sys_readlinkat(int fd, const char *path, char *buf, size_t count); }
	SYS_RENAMEAT       = 323 // { int sys_renameat(int fromfd, const char *from, int tofd, const char *to); }
	SYS_SYMLINKAT      = 324 // { int sys_symlinkat(const char *path, int fd, const char *link); }
	SYS_UNLINKAT       = 325 // { int sys_unlinkat(int fd, const char *path, int flag); }
	SYS___SET_TCB      = 329 // { void sys___set_tcb(void *tcb); }
	SYS___GET_TCB      = 330 // { void *sys___get_tcb(void); }
)

"""



```
Response:
Let's break down the thought process for answering the request about `zsysnum_linux_amd64.go`.

**1. Initial Understanding and Goal:**

The first step is to understand the file's purpose. The comment at the top is a huge clue:  `// Code generated by the command above; see README.md. DO NOT EDIT.`  This immediately tells us the file isn't written by hand, but automatically generated. The command itself is also informative: `go run linux/mksysnum.go -Wall -Werror -static -I/tmp/amd64/include -m64 /tmp/amd64/include/asm/unistd.h`. This suggests it's reading system call definitions from a C header file (`unistd.h`) and generating Go code. The `amd64` in the filename and command reinforces that it's specific to the 64-bit AMD architecture on Linux.

The core goal is to explain the file's function, illustrate its use in Go, and identify potential pitfalls.

**2. Identifying the Core Function:**

Scanning the contents, we see a series of constant definitions starting with `SYS_`. These look like system call numbers. The names are indicative of operating system functions like `read`, `write`, `open`, etc. This confirms the initial hypothesis: this file provides the numerical identifiers for Linux system calls on the amd64 architecture.

**3. Connecting to Go's System Call Mechanism:**

The next logical step is to think about *how* Go interacts with the operating system. Go's standard library provides the `syscall` package for making raw system calls. This package needs a way to know the correct numerical identifier for each system call. This file `zsysnum_linux_amd64.go` is the missing link – it provides these numerical constants.

**4. Illustrative Go Code Example:**

To demonstrate this, we need to write a simple Go program that uses a system call. The most basic examples are `read` and `write`.

*   **Choosing a System Call:**  `SYS_WRITE` is a good choice because it's straightforward. It takes a file descriptor, a buffer, and a length.

*   **Using the `syscall` Package:** We'll need to import `syscall`.

*   **Accessing the Constant:**  We'll use `unix.SYS_WRITE` to access the constant defined in our target file.

*   **Crafting the Call:**  A minimal example would involve writing a string to standard output (file descriptor 1). This requires:
    *   A byte slice for the data.
    *   The file descriptor `1`.
    *   Converting the string to a byte slice.
    *   Calling `syscall.Syscall`.

*   **Handling Errors:**  System calls can fail, so we need to check the returned error.

*   **Putting it Together:** This leads to the example code provided in the original answer.

**5. Explaining the Code:**

Once the example is written, we need to explain what it does, how it uses the constant, and what the expected output is. This involves describing the parameters of `syscall.Syscall` and how they map to the `SYS_WRITE` system call.

**6. Analyzing the Generation Command:**

The command at the top is crucial for understanding how this file is maintained. We need to break it down:

*   `go run linux/mksysnum.go`: This executes a Go program responsible for generation.
*   `-Wall -Werror -static`: These are likely compiler flags passed to the generator program, hinting at quality checks.
*   `-I/tmp/amd64/include`: This specifies where to find the header files.
*   `-m64`:  Indicates 64-bit architecture.
*   `/tmp/amd64/include/asm/unistd.h`: The source of the system call definitions.

This analysis explains how the constants are kept up-to-date with the Linux kernel.

**7. Identifying Potential Pitfalls:**

The most significant pitfall stems from the automatic generation and platform-specificity:

*   **Manual Modification:**  Editing the file directly is strongly discouraged because changes will be overwritten.

*   **Platform Dependence:** The constants are specific to the architecture and operating system (`amd64` and `linux`). Code relying directly on these constants will not be portable.

**8. Structuring the Answer:**

Finally, organize the information logically with clear headings and bullet points to make it easy to understand. Start with the core function, then illustrate with code, explain the generation process, and end with potential issues.

**Self-Correction/Refinement during the process:**

*   Initially, I might have just stated "it defines system call numbers." But the request asked for deeper insight. Thinking about *why* Go needs these numbers and *how* it uses them led to the explanation involving the `syscall` package.

*   The code example needs to be simple and directly related to the file's content. Starting with a more complex system call would make the example harder to understand.

*   Explaining the generation command is crucial. Without it, the user might wonder how these constants are maintained.

*   Highlighting the "DO NOT EDIT" comment is important to prevent users from making incorrect modifications. Emphasizing platform dependence clarifies why this file exists with its specific naming.

By following these steps, including the refinement process, we arrive at a comprehensive and accurate answer to the user's request.
`go/src/cmd/vendor/golang.org/x/sys/unix/zsysnum_linux_amd64.go` 这个文件在 Go 语言中扮演着非常重要的角色，它定义了在 Linux 操作系统 x86-64 (amd64) 架构下的系统调用号常量。

**它的主要功能是：**

1. **提供系统调用号的常量定义：**  文件中定义了大量的常量，例如 `SYS_READ = 0`, `SYS_WRITE = 1`, `SYS_OPEN = 2` 等等。 这些常量对应着 Linux 内核提供的各种系统调用。每个系统调用都有一个唯一的数字标识符，内核通过这个数字来区分不同的系统调用。

2. **作为 Go 标准库 `syscall` 包的基础：**  Go 的标准库中的 `syscall` 包提供了与操作系统底层交互的能力，包括执行系统调用。 `syscall` 包在进行系统调用时，需要知道目标系统调用的编号。  `zsysnum_linux_amd64.go` 文件提供的常量正是 `syscall` 包所需要的。

3. **实现平台特定的系统调用：** 由于不同的操作系统和架构可能使用不同的系统调用号，Go 语言使用这种方式来为不同的平台提供特定于平台的系统调用号定义。文件名中的 `linux` 和 `amd64` 就明确指明了此文件是为 Linux 操作系统和 amd64 架构准备的。

**它是什么 Go 语言功能的实现？**

这个文件是 Go 语言中 **`syscall` 包**  在 Linux/amd64 平台上的具体实现支撑。 `syscall` 包允许 Go 程序直接调用操作系统的底层 API，而 `zsysnum_linux_amd64.go` 提供了这些底层 API 的数字标识符。

**Go 代码示例说明:**

假设我们想使用 `syscall` 包调用 `write` 系统调用向标准输出打印一段文本。我们可以使用 `SYS_WRITE` 常量：

```go
package main

import (
	"fmt"
	"syscall"
	"unsafe"

	"golang.org/x/sys/unix" // 注意这里导入的是 unix 包
)

func main() {
	message := "Hello, syscall!\n"
	buffer := unsafe.Pointer(&[]byte(message)[0])
	fd := uintptr(1) // 标准输出的文件描述符是 1
	count := uintptr(len(message))

	// 调用 write 系统调用
	_, _, err := syscall.Syscall(unix.SYS_WRITE, fd, buffer, count)
	if err != 0 {
		fmt.Println("Error calling write:", err)
	}
}
```

**假设的输入与输出：**

*   **输入:**  无特定的程序输入，程序内部定义了要打印的消息 "Hello, syscall!\n"。
*   **输出:**  程序执行后，会在终端输出：
    ```
    Hello, syscall!
    ```

**代码推理：**

1. 我们导入了 `syscall` 包和 `golang.org/x/sys/unix` 包。 `unix` 包包含了特定于 Unix-like 系统的常量和函数，其中包括我们需要的系统调用号常量。
2. `message` 变量存储了要打印的字符串。
3. `buffer` 获取了 `message` 字符串的底层字节数组的指针。`syscall.Syscall` 函数需要 `unsafe.Pointer` 类型的参数。
4. `fd` 设置为 `1`，代表标准输出的文件描述符。
5. `count` 设置为要写入的字节数，即消息的长度。
6. `syscall.Syscall(unix.SYS_WRITE, fd, buffer, count)`  是执行系统调用的关键。
    *   `unix.SYS_WRITE` 从 `zsysnum_linux_amd64.go` 文件中获取 `write` 系统调用的编号 (即 1)。
    *   `fd`、`buffer` 和 `count` 是 `write` 系统调用所需的参数。
7. `syscall.Syscall` 返回三个值：系统调用的返回值、可能返回的第二个值（通常不用），以及一个错误对象。我们检查 `err` 来判断系统调用是否成功。

**命令行参数的具体处理：**

这个文件本身不直接处理命令行参数。 它的作用是提供常量定义，供其他 Go 代码（比如 `syscall` 包的使用者）使用。

但是，文件开头的注释 `// go run linux/mksysnum.go ...`  展示了一个用于 **生成** 这个文件的命令行操作。 让我们详细分析一下：

*   `go run linux/mksysnum.go`:  这会运行 `linux/mksysnum.go` 这个 Go 程序。可以推断，这是一个工具程序，它的目的是生成 `zsysnum_linux_amd64.go` 文件。
*   `-Wall -Werror -static`: 这些是传递给 `linux/mksysnum.go` 程序的参数，很可能被该程序用来控制代码生成的方式。
    *   `-Wall`:  可能指示生成器产生更全面的代码或包含更多的系统调用号。
    *   `-Werror`:  可能指示生成器将警告视为错误，确保生成的代码质量。
    *   `-static`:  可能指示生成器生成静态的常量定义。
*   `-I/tmp/amd64/include`:  这是一个包含路径参数，指定了头文件的搜索路径。 `linux/mksysnum.go` 程序很可能需要读取 Linux 内核的头文件来获取系统调用的定义。
*   `-m64`:  指定目标架构是 64 位 (amd64)。
*   `/tmp/amd64/include/asm/unistd.h`:  这是最重要的参数，指定了包含系统调用号定义的头文件。 `linux/mksysnum.go` 程序会解析这个文件，提取系统调用号和对应的名称，然后生成 `zsysnum_linux_amd64.go` 文件。

**总结：**  `linux/mksysnum.go` 工具读取指定的头文件，根据参数（如目标架构）提取系统调用信息，并将这些信息格式化为 Go 语言的常量定义，最终生成 `zsysnum_linux_amd64.go` 文件。

**使用者易犯错的点：**

1. **直接修改此文件：**  文件开头的 `// Code generated by the command above; see README.md. DO NOT EDIT.`  明确指出这个文件是自动生成的，不应该手动修改。 任何手动修改都会在下次重新生成时被覆盖。

    **错误示例：**  假设用户错误地将 `SYS_READ` 的值改成了 `1`。这将导致任何使用 `syscall.Read` 的操作实际上会执行 `write` 系统调用，产生不可预测的结果和严重的错误。

2. **假设跨平台兼容性：**  这个文件是特定于 `linux` 和 `amd64` 架构的。 如果你的代码直接使用了这里定义的常量，那么它将无法在其他操作系统或架构上编译和运行。

    **错误示例：**  如果在 Windows 系统上直接使用 `unix.SYS_OPEN`，会导致编译错误，因为 Windows 上没有 `SYS_OPEN` 这个常量，或者其值与 Linux 不同。  正确的做法是使用 `syscall` 包提供的更通用的函数，这些函数会根据不同的平台选择正确的系统调用号。

3. **误解系统调用号的含义：**  系统调用号是内核的内部实现细节，可能会在不同的内核版本之间发生变化（虽然这种情况比较少见）。  直接依赖特定的系统调用号可能会导致代码在未来的内核版本上失效。  应该尽量使用 Go 标准库提供的抽象，而不是直接操作系统调用号。

总而言之，`go/src/cmd/vendor/golang.org/x/sys/unix/zsysnum_linux_amd64.go` 是 Go 语言与 Linux 系统底层交互的关键组成部分，它提供了一组重要的常量，使得 Go 程序能够通过 `syscall` 包调用操作系统的功能。理解其作用和生成方式对于深入了解 Go 的底层机制至关重要。

Prompt: 
```
这是路径为go/src/cmd/vendor/golang.org/x/sys/unix/zsysnum_linux_amd64.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，

"""
// go run linux/mksysnum.go -Wall -Werror -static -I/tmp/amd64/include -m64 /tmp/amd64/include/asm/unistd.h
// Code generated by the command above; see README.md. DO NOT EDIT.

//go:build amd64 && linux

package unix

const (
	SYS_READ                    = 0
	SYS_WRITE                   = 1
	SYS_OPEN                    = 2
	SYS_CLOSE                   = 3
	SYS_STAT                    = 4
	SYS_FSTAT                   = 5
	SYS_LSTAT                   = 6
	SYS_POLL                    = 7
	SYS_LSEEK                   = 8
	SYS_MMAP                    = 9
	SYS_MPROTECT                = 10
	SYS_MUNMAP                  = 11
	SYS_BRK                     = 12
	SYS_RT_SIGACTION            = 13
	SYS_RT_SIGPROCMASK          = 14
	SYS_RT_SIGRETURN            = 15
	SYS_IOCTL                   = 16
	SYS_PREAD64                 = 17
	SYS_PWRITE64                = 18
	SYS_READV                   = 19
	SYS_WRITEV                  = 20
	SYS_ACCESS                  = 21
	SYS_PIPE                    = 22
	SYS_SELECT                  = 23
	SYS_SCHED_YIELD             = 24
	SYS_MREMAP                  = 25
	SYS_MSYNC                   = 26
	SYS_MINCORE                 = 27
	SYS_MADVISE                 = 28
	SYS_SHMGET                  = 29
	SYS_SHMAT                   = 30
	SYS_SHMCTL                  = 31
	SYS_DUP                     = 32
	SYS_DUP2                    = 33
	SYS_PAUSE                   = 34
	SYS_NANOSLEEP               = 35
	SYS_GETITIMER               = 36
	SYS_ALARM                   = 37
	SYS_SETITIMER               = 38
	SYS_GETPID                  = 39
	SYS_SENDFILE                = 40
	SYS_SOCKET                  = 41
	SYS_CONNECT                 = 42
	SYS_ACCEPT                  = 43
	SYS_SENDTO                  = 44
	SYS_RECVFROM                = 45
	SYS_SENDMSG                 = 46
	SYS_RECVMSG                 = 47
	SYS_SHUTDOWN                = 48
	SYS_BIND                    = 49
	SYS_LISTEN                  = 50
	SYS_GETSOCKNAME             = 51
	SYS_GETPEERNAME             = 52
	SYS_SOCKETPAIR              = 53
	SYS_SETSOCKOPT              = 54
	SYS_GETSOCKOPT              = 55
	SYS_CLONE                   = 56
	SYS_FORK                    = 57
	SYS_VFORK                   = 58
	SYS_EXECVE                  = 59
	SYS_EXIT                    = 60
	SYS_WAIT4                   = 61
	SYS_KILL                    = 62
	SYS_UNAME                   = 63
	SYS_SEMGET                  = 64
	SYS_SEMOP                   = 65
	SYS_SEMCTL                  = 66
	SYS_SHMDT                   = 67
	SYS_MSGGET                  = 68
	SYS_MSGSND                  = 69
	SYS_MSGRCV                  = 70
	SYS_MSGCTL                  = 71
	SYS_FCNTL                   = 72
	SYS_FLOCK                   = 73
	SYS_FSYNC                   = 74
	SYS_FDATASYNC               = 75
	SYS_TRUNCATE                = 76
	SYS_FTRUNCATE               = 77
	SYS_GETDENTS                = 78
	SYS_GETCWD                  = 79
	SYS_CHDIR                   = 80
	SYS_FCHDIR                  = 81
	SYS_RENAME                  = 82
	SYS_MKDIR                   = 83
	SYS_RMDIR                   = 84
	SYS_CREAT                   = 85
	SYS_LINK                    = 86
	SYS_UNLINK                  = 87
	SYS_SYMLINK                 = 88
	SYS_READLINK                = 89
	SYS_CHMOD                   = 90
	SYS_FCHMOD                  = 91
	SYS_CHOWN                   = 92
	SYS_FCHOWN                  = 93
	SYS_LCHOWN                  = 94
	SYS_UMASK                   = 95
	SYS_GETTIMEOFDAY            = 96
	SYS_GETRLIMIT               = 97
	SYS_GETRUSAGE               = 98
	SYS_SYSINFO                 = 99
	SYS_TIMES                   = 100
	SYS_PTRACE                  = 101
	SYS_GETUID                  = 102
	SYS_SYSLOG                  = 103
	SYS_GETGID                  = 104
	SYS_SETUID                  = 105
	SYS_SETGID                  = 106
	SYS_GETEUID                 = 107
	SYS_GETEGID                 = 108
	SYS_SETPGID                 = 109
	SYS_GETPPID                 = 110
	SYS_GETPGRP                 = 111
	SYS_SETSID                  = 112
	SYS_SETREUID                = 113
	SYS_SETREGID                = 114
	SYS_GETGROUPS               = 115
	SYS_SETGROUPS               = 116
	SYS_SETRESUID               = 117
	SYS_GETRESUID               = 118
	SYS_SETRESGID               = 119
	SYS_GETRESGID               = 120
	SYS_GETPGID                 = 121
	SYS_SETFSUID                = 122
	SYS_SETFSGID                = 123
	SYS_GETSID                  = 124
	SYS_CAPGET                  = 125
	SYS_CAPSET                  = 126
	SYS_RT_SIGPENDING           = 127
	SYS_RT_SIGTIMEDWAIT         = 128
	SYS_RT_SIGQUEUEINFO         = 129
	SYS_RT_SIGSUSPEND           = 130
	SYS_SIGALTSTACK             = 131
	SYS_UTIME                   = 132
	SYS_MKNOD                   = 133
	SYS_USELIB                  = 134
	SYS_PERSONALITY             = 135
	SYS_USTAT                   = 136
	SYS_STATFS                  = 137
	SYS_FSTATFS                 = 138
	SYS_SYSFS                   = 139
	SYS_GETPRIORITY             = 140
	SYS_SETPRIORITY             = 141
	SYS_SCHED_SETPARAM          = 142
	SYS_SCHED_GETPARAM          = 143
	SYS_SCHED_SETSCHEDULER      = 144
	SYS_SCHED_GETSCHEDULER      = 145
	SYS_SCHED_GET_PRIORITY_MAX  = 146
	SYS_SCHED_GET_PRIORITY_MIN  = 147
	SYS_SCHED_RR_GET_INTERVAL   = 148
	SYS_MLOCK                   = 149
	SYS_MUNLOCK                 = 150
	SYS_MLOCKALL                = 151
	SYS_MUNLOCKALL              = 152
	SYS_VHANGUP                 = 153
	SYS_MODIFY_LDT              = 154
	SYS_PIVOT_ROOT              = 155
	SYS__SYSCTL                 = 156
	SYS_PRCTL                   = 157
	SYS_ARCH_PRCTL              = 158
	SYS_ADJTIMEX                = 159
	SYS_SETRLIMIT               = 160
	SYS_CHROOT                  = 161
	SYS_SYNC                    = 162
	SYS_ACCT                    = 163
	SYS_SETTIMEOFDAY            = 164
	SYS_MOUNT                   = 165
	SYS_UMOUNT2                 = 166
	SYS_SWAPON                  = 167
	SYS_SWAPOFF                 = 168
	SYS_REBOOT                  = 169
	SYS_SETHOSTNAME             = 170
	SYS_SETDOMAINNAME           = 171
	SYS_IOPL                    = 172
	SYS_IOPERM                  = 173
	SYS_CREATE_MODULE           = 174
	SYS_INIT_MODULE             = 175
	SYS_DELETE_MODULE           = 176
	SYS_GET_KERNEL_SYMS         = 177
	SYS_QUERY_MODULE            = 178
	SYS_QUOTACTL                = 179
	SYS_NFSSERVCTL              = 180
	SYS_GETPMSG                 = 181
	SYS_PUTPMSG                 = 182
	SYS_AFS_SYSCALL             = 183
	SYS_TUXCALL                 = 184
	SYS_SECURITY                = 185
	SYS_GETTID                  = 186
	SYS_READAHEAD               = 187
	SYS_SETXATTR                = 188
	SYS_LSETXATTR               = 189
	SYS_FSETXATTR               = 190
	SYS_GETXATTR                = 191
	SYS_LGETXATTR               = 192
	SYS_FGETXATTR               = 193
	SYS_LISTXATTR               = 194
	SYS_LLISTXATTR              = 195
	SYS_FLISTXATTR              = 196
	SYS_REMOVEXATTR             = 197
	SYS_LREMOVEXATTR            = 198
	SYS_FREMOVEXATTR            = 199
	SYS_TKILL                   = 200
	SYS_TIME                    = 201
	SYS_FUTEX                   = 202
	SYS_SCHED_SETAFFINITY       = 203
	SYS_SCHED_GETAFFINITY       = 204
	SYS_SET_THREAD_AREA         = 205
	SYS_IO_SETUP                = 206
	SYS_IO_DESTROY              = 207
	SYS_IO_GETEVENTS            = 208
	SYS_IO_SUBMIT               = 209
	SYS_IO_CANCEL               = 210
	SYS_GET_THREAD_AREA         = 211
	SYS_LOOKUP_DCOOKIE          = 212
	SYS_EPOLL_CREATE            = 213
	SYS_EPOLL_CTL_OLD           = 214
	SYS_EPOLL_WAIT_OLD          = 215
	SYS_REMAP_FILE_PAGES        = 216
	SYS_GETDENTS64              = 217
	SYS_SET_TID_ADDRESS         = 218
	SYS_RESTART_SYSCALL         = 219
	SYS_SEMTIMEDOP              = 220
	SYS_FADVISE64               = 221
	SYS_TIMER_CREATE            = 222
	SYS_TIMER_SETTIME           = 223
	SYS_TIMER_GETTIME           = 224
	SYS_TIMER_GETOVERRUN        = 225
	SYS_TIMER_DELETE            = 226
	SYS_CLOCK_SETTIME           = 227
	SYS_CLOCK_GETTIME           = 228
	SYS_CLOCK_GETRES            = 229
	SYS_CLOCK_NANOSLEEP         = 230
	SYS_EXIT_GROUP              = 231
	SYS_EPOLL_WAIT              = 232
	SYS_EPOLL_CTL               = 233
	SYS_TGKILL                  = 234
	SYS_UTIMES                  = 235
	SYS_VSERVER                 = 236
	SYS_MBIND                   = 237
	SYS_SET_MEMPOLICY           = 238
	SYS_GET_MEMPOLICY           = 239
	SYS_MQ_OPEN                 = 240
	SYS_MQ_UNLINK               = 241
	SYS_MQ_TIMEDSEND            = 242
	SYS_MQ_TIMEDRECEIVE         = 243
	SYS_MQ_NOTIFY               = 244
	SYS_MQ_GETSETATTR           = 245
	SYS_KEXEC_LOAD              = 246
	SYS_WAITID                  = 247
	SYS_ADD_KEY                 = 248
	SYS_REQUEST_KEY             = 249
	SYS_KEYCTL                  = 250
	SYS_IOPRIO_SET              = 251
	SYS_IOPRIO_GET              = 252
	SYS_INOTIFY_INIT            = 253
	SYS_INOTIFY_ADD_WATCH       = 254
	SYS_INOTIFY_RM_WATCH        = 255
	SYS_MIGRATE_PAGES           = 256
	SYS_OPENAT                  = 257
	SYS_MKDIRAT                 = 258
	SYS_MKNODAT                 = 259
	SYS_FCHOWNAT                = 260
	SYS_FUTIMESAT               = 261
	SYS_NEWFSTATAT              = 262
	SYS_UNLINKAT                = 263
	SYS_RENAMEAT                = 264
	SYS_LINKAT                  = 265
	SYS_SYMLINKAT               = 266
	SYS_READLINKAT              = 267
	SYS_FCHMODAT                = 268
	SYS_FACCESSAT               = 269
	SYS_PSELECT6                = 270
	SYS_PPOLL                   = 271
	SYS_UNSHARE                 = 272
	SYS_SET_ROBUST_LIST         = 273
	SYS_GET_ROBUST_LIST         = 274
	SYS_SPLICE                  = 275
	SYS_TEE                     = 276
	SYS_SYNC_FILE_RANGE         = 277
	SYS_VMSPLICE                = 278
	SYS_MOVE_PAGES              = 279
	SYS_UTIMENSAT               = 280
	SYS_EPOLL_PWAIT             = 281
	SYS_SIGNALFD                = 282
	SYS_TIMERFD_CREATE          = 283
	SYS_EVENTFD                 = 284
	SYS_FALLOCATE               = 285
	SYS_TIMERFD_SETTIME         = 286
	SYS_TIMERFD_GETTIME         = 287
	SYS_ACCEPT4                 = 288
	SYS_SIGNALFD4               = 289
	SYS_EVENTFD2                = 290
	SYS_EPOLL_CREATE1           = 291
	SYS_DUP3                    = 292
	SYS_PIPE2                   = 293
	SYS_INOTIFY_INIT1           = 294
	SYS_PREADV                  = 295
	SYS_PWRITEV                 = 296
	SYS_RT_TGSIGQUEUEINFO       = 297
	SYS_PERF_EVENT_OPEN         = 298
	SYS_RECVMMSG                = 299
	SYS_FANOTIFY_INIT           = 300
	SYS_FANOTIFY_MARK           = 301
	SYS_PRLIMIT64               = 302
	SYS_NAME_TO_HANDLE_AT       = 303
	SYS_OPEN_BY_HANDLE_AT       = 304
	SYS_CLOCK_ADJTIME           = 305
	SYS_SYNCFS                  = 306
	SYS_SENDMMSG                = 307
	SYS_SETNS                   = 308
	SYS_GETCPU                  = 309
	SYS_PROCESS_VM_READV        = 310
	SYS_PROCESS_VM_WRITEV       = 311
	SYS_KCMP                    = 312
	SYS_FINIT_MODULE            = 313
	SYS_SCHED_SETATTR           = 314
	SYS_SCHED_GETATTR           = 315
	SYS_RENAMEAT2               = 316
	SYS_SECCOMP                 = 317
	SYS_GETRANDOM               = 318
	SYS_MEMFD_CREATE            = 319
	SYS_KEXEC_FILE_LOAD         = 320
	SYS_BPF                     = 321
	SYS_EXECVEAT                = 322
	SYS_USERFAULTFD             = 323
	SYS_MEMBARRIER              = 324
	SYS_MLOCK2                  = 325
	SYS_COPY_FILE_RANGE         = 326
	SYS_PREADV2                 = 327
	SYS_PWRITEV2                = 328
	SYS_PKEY_MPROTECT           = 329
	SYS_PKEY_ALLOC              = 330
	SYS_PKEY_FREE               = 331
	SYS_STATX                   = 332
	SYS_IO_PGETEVENTS           = 333
	SYS_RSEQ                    = 334
	SYS_URETPROBE               = 335
	SYS_PIDFD_SEND_SIGNAL       = 424
	SYS_IO_URING_SETUP          = 425
	SYS_IO_URING_ENTER          = 426
	SYS_IO_URING_REGISTER       = 427
	SYS_OPEN_TREE               = 428
	SYS_MOVE_MOUNT              = 429
	SYS_FSOPEN                  = 430
	SYS_FSCONFIG                = 431
	SYS_FSMOUNT                 = 432
	SYS_FSPICK                  = 433
	SYS_PIDFD_OPEN              = 434
	SYS_CLONE3                  = 435
	SYS_CLOSE_RANGE             = 436
	SYS_OPENAT2                 = 437
	SYS_PIDFD_GETFD             = 438
	SYS_FACCESSAT2              = 439
	SYS_PROCESS_MADVISE         = 440
	SYS_EPOLL_PWAIT2            = 441
	SYS_MOUNT_SETATTR           = 442
	SYS_QUOTACTL_FD             = 443
	SYS_LANDLOCK_CREATE_RULESET = 444
	SYS_LANDLOCK_ADD_RULE       = 445
	SYS_LANDLOCK_RESTRICT_SELF  = 446
	SYS_MEMFD_SECRET            = 447
	SYS_PROCESS_MRELEASE        = 448
	SYS_FUTEX_WAITV             = 449
	SYS_SET_MEMPOLICY_HOME_NODE = 450
	SYS_CACHESTAT               = 451
	SYS_FCHMODAT2               = 452
	SYS_MAP_SHADOW_STACK        = 453
	SYS_FUTEX_WAKE              = 454
	SYS_FUTEX_WAIT              = 455
	SYS_FUTEX_REQUEUE           = 456
	SYS_STATMOUNT               = 457
	SYS_LISTMOUNT               = 458
	SYS_LSM_GET_SELF_ATTR       = 459
	SYS_LSM_SET_SELF_ATTR       = 460
	SYS_LSM_LIST_MODULES        = 461
	SYS_MSEAL                   = 462
)

"""



```
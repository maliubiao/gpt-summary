Response:
Let's break down the thought process for analyzing the provided Go code snippet.

**1. Initial Understanding: The Big Picture**

The first thing that jumps out is the comment at the top:  `// go run mksyscall.go -tags linux,s390x syscall_linux.go syscall_linux_s390x.go syscall_linux_alarm.go` and `// Code generated by the command above; see README.md. DO NOT EDIT.` This immediately tells us:

* **Code Generation:** This file is automatically generated. We shouldn't manually edit it.
* **`mksyscall` Tool:**  A Go tool named `mksyscall` was used. This tool is likely responsible for generating Go code that interfaces with operating system system calls.
* **Tags:** The `-tags linux,s390x` part is crucial. It indicates that this specific file is for the Linux operating system running on the s390x architecture. This explains the filename `zsyscall_linux_s390x.go`. The 'z' likely signifies a generated or architecture-specific file.
* **Input Files:** The command shows the input files: `syscall_linux.go`, `syscall_linux_s390x.go`, and `syscall_linux_alarm.go`. This suggests that the generation process combines information from these files.

**2. Analyzing Individual Functions: Identifying System Calls**

Next, I'd go through each function definition. The structure is very consistent:

```go
func FunctionName(arguments) (return values) {
	_, _, e1 := SyscallN(SYS_CONSTANT, ...)
	// ... error handling ...
}
```

or

```go
func FunctionName(arguments) (return values) {
	r0, _, e1 := SyscallN(SYS_CONSTANT, ...)
	// ... return value assignment and error handling ...
}
```

or

```go
func FunctionName(arguments) (return values) {
	r0, _ := RawSyscallNoError(SYS_CONSTANT, ...)
	// ... return value assignment ...
}
```

The key pattern is the calls to `SyscallN` or `RawSyscallNoError`. These are the low-level mechanisms in Go's `syscall` package for making system calls. The `SYS_CONSTANT` (e.g., `SYS_FANOTIFY_MARK`, `SYS_FALLOCATE`) is a predefined constant representing the system call number.

For each function, I would:

* **Identify the `SYS_` constant:** This directly tells me which system call is being wrapped.
* **Examine the function name:**  The Go function name is usually a more user-friendly, Go-style name for the system call (e.g., `fanotifyMark` instead of just `fanotify_mark`).
* **Look at the arguments:** These arguments correspond to the parameters of the underlying system call. I'd pay attention to types like `int`, `uint`, `int64`, pointers (`*byte`, `unsafe.Pointer`), and slices (`[]EpollEvent`).
* **Check the return values:**  System calls often return an error, and sometimes a result value (like a file descriptor or the number of bytes read/written).

**3. Inferring Functionality: Connecting to Higher-Level Go Concepts**

Once I identified the system calls, I could start to infer how these functions are used in higher-level Go code. For example:

* **`fanotifyMark` (SYS_FANOTIFY_MARK):**  The name suggests it's related to file system notifications. I know Go has mechanisms for watching file system events, so this function likely underlies that functionality.
* **`Fallocate` (SYS_FALLOCATE):**  This clearly deals with pre-allocating disk space for a file. This is useful for performance in certain applications.
* **`Tee` (SYS_TEE):**  The name "tee" is suggestive of the `tee` command in Unix, which duplicates output. This system call likely allows copying data between file descriptors.
* **`EpollWait` (SYS_EPOLL_WAIT):** "Epoll" is a Linux-specific mechanism for efficient I/O event notification. This is a core building block for network programming and other asynchronous I/O operations in Go.
* **`Fadvise` (SYS_FADVISE64):**  "Advise" hints at providing hints to the operating system about how to handle file data (e.g., caching behavior).
* **`Fchown`, `Lchown`:** These functions relate to changing file ownership (user and group IDs).
* **`Fstat`, `Lstat`, `Fstatat`, `Stat`:** These are all about getting file metadata (size, modification time, permissions, etc.).
* **`Ftruncate`, `Truncate`:**  These are for changing the size of a file.
* **`Getegid`, `Geteuid`, `Getgid`, `Getuid`:** These retrieve user and group IDs.
* **`Getrlimit`:** This deals with process resource limits.
* **`Pause`:**  This makes the process sleep until a signal arrives.
* **`pread`, `pwrite`:** These are for reading and writing to a file at a specific offset without changing the file pointer.
* **`Renameat`:** Renaming files, potentially across directories.
* **`Seek`:**  Moving the read/write position within a file.
* **`Select`:**  An older mechanism for multiplexing I/O, predating `epoll`.
* **`sendfile`:** Efficiently copying data between file descriptors (often used for network transfers).
* **`setfsgid`, `setfsuid`:** Setting file system user and group IDs.
* **`Splice`:** A high-performance way to move data between file descriptors without copying through user space.
* **`Statfs`, `Fstatfs`:** Getting file system statistics (free space, etc.).
* **`SyncFileRange`:**  Flushing file data to disk.
* **`Ustat`:**  Getting file system statistics (deprecated).
* **`getgroups`, `setgroups`:**  Getting and setting supplementary group IDs.
* **`futimesat`, `Utime`, `utimes`:**  Changing file access and modification times.
* **`Gettimeofday`:** Getting the current time.
* **`kexecFileLoad`:**  Loading a new kernel for execution.
* **`Alarm`:**  Setting a timer that will send a signal to the process.

**4. Code Examples and Assumptions:**

When asked for code examples, I'd choose functions that illustrate common Go use cases. The key is to show how these low-level functions relate to higher-level operations. For example, demonstrating `Stat` to get file size or `Fallocate` to pre-allocate disk space. The input and output of these examples would be based on standard Go data structures and the expected behavior of the underlying system calls.

**5. Command Line Arguments:**

The command at the top of the file provides the necessary information about command-line arguments for the `mksyscall` tool. I would explain the purpose of each argument.

**6. Common Mistakes:**

Thinking about common mistakes involves considering how developers might misuse these low-level functions. For example:

* **Incorrect error handling:**  Ignoring the returned `err`.
* **Misunderstanding file descriptors:**  Passing invalid file descriptors.
* **Incorrectly sizing buffers:**  For functions like `pread` and `pwrite`.
* **Not understanding the implications of flags:** For functions like `open` (though not directly in this snippet).
* **Security issues:**  When dealing with user and group IDs, ensuring proper privilege handling is crucial.

By following this systematic approach, I can effectively analyze the provided Go code snippet, understand its functionality, relate it to higher-level Go concepts, and provide useful explanations and examples.
Let's break down the functionality of the provided Go code snippet, which is a generated file (`zsyscall_linux_s390x.go`) containing low-level system call wrappers for the Linux operating system on the s390x architecture.

**Core Functionality:**

This file provides Go wrappers around various Linux system calls. Each function in this file directly maps to a specific system call provided by the Linux kernel. These wrappers handle the low-level details of invoking system calls, such as:

* **System Call Number:**  Each function uses a `SYS_` constant (e.g., `SYS_FANOTIFY_MARK`, `SYS_FALLOCATE`) which represents the unique identifier for that system call.
* **Argument Marshalling:** They take Go types as arguments and convert them to the appropriate types and memory layout expected by the Linux kernel. This often involves using `unsafe.Pointer` to pass memory addresses.
* **System Call Invocation:** They use the `syscall.Syscall`, `syscall.Syscall6`, or `syscall.RawSyscallNoError` functions to actually execute the system call.
* **Error Handling:** They check the return value of the system call (specifically the `e1` value, which represents the error number) and convert it to a Go `error` using `errnoErr`.

**Specific System Calls and Their Potential Go Functionality:**

Here's a breakdown of the functions and their likely corresponding Go functionalities:

* **`fanotifyMark(fd int, flags uint, mask uint64, dirFd int, pathname *byte) (err error)`:**
    * **System Call:** `SYS_FANOTIFY_MARK`
    * **Functionality:** This is part of the fanotify API, which allows programs to receive notifications about file system events.
    * **Go Functionality:** Likely used internally by Go's `os/signal` package or more specialized file system monitoring libraries to implement file system event watching.

* **`Fallocate(fd int, mode uint32, off int64, len int64) (err error)`:**
    * **System Call:** `SYS_FALLOCATE`
    * **Functionality:**  Pre-allocates space for a file on disk. This can improve performance by preventing fragmentation and ensuring contiguous storage.
    * **Go Functionality:**  Could be used in Go's `os` package or by libraries dealing with large file I/O to optimize disk space allocation.

* **`Tee(rfd int, wfd int, len int, flags int) (n int64, err error)`:**
    * **System Call:** `SYS_TEE`
    * **Functionality:** Copies data between two file descriptors without transferring data to or from user space.
    * **Go Functionality:**  Used in scenarios where efficient data transfer between pipes or sockets is needed, potentially within Go's `io` package implementations.

* **`EpollWait(epfd int, events []EpollEvent, msec int) (n int, err error)`:**
    * **System Call:** `SYS_EPOLL_WAIT`
    * **Functionality:**  Waits for events on an epoll file descriptor. Epoll is a Linux-specific mechanism for efficient I/O event notification.
    * **Go Functionality:** A core part of Go's network poller implementation in the `net` package. It enables Go to handle many concurrent network connections efficiently.

* **`Fadvise(fd int, offset int64, length int64, advice int) (err error)`:**
    * **System Call:** `SYS_FADVISE64`
    * **Functionality:** Provides advice to the kernel about expected access patterns for a file. This allows the kernel to optimize caching and I/O operations.
    * **Go Functionality:** Potentially used by Go's `os` package or libraries dealing with file I/O to provide performance hints to the operating system.

* **`Fchown(fd int, uid int, gid int) (err error)`:**
    * **System Call:** `SYS_FCHOWN`
    * **Functionality:** Changes the owner and group of a file referenced by a file descriptor.
    * **Go Functionality:**  Underlies the `os.Chown` and `os.Lchown` functions when applied to open files.

* **`Fstat(fd int, stat *Stat_t) (err error)`:**
    * **System Call:** `SYS_FSTAT`
    * **Functionality:** Retrieves file metadata (size, modification time, permissions, etc.) for a file referenced by a file descriptor.
    * **Go Functionality:** Used internally by `os.Stat` and related functions when operating on open files.

* **`Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error)`:**
    * **System Call:** `SYS_NEWFSTATAT`
    * **Functionality:** Similar to `Fstat`, but allows specifying a directory file descriptor to resolve the path relative to that directory. This is useful for avoiding race conditions when working with file paths.
    * **Go Functionality:**  Used internally by `os.Stat` and related functions when dealing with relative paths and directory file descriptors.

* **`Fstatfs(fd int, buf *Statfs_t) (err error)`:**
    * **System Call:** `SYS_FSTATFS`
    * **Functionality:** Retrieves file system statistics for the file system containing the file referenced by the file descriptor.
    * **Go Functionality:** Used internally by functions that need to get information about the file system, such as free space.

* **`Ftruncate(fd int, length int64) (err error)`:**
    * **System Call:** `SYS_FTRUNCATE`
    * **Functionality:** Truncates a file to a specified length, referenced by a file descriptor.
    * **Go Functionality:** Used internally by functions like `os.Truncate` when operating on an open file.

* **`Getegid() (egid int)`, `Geteuid() (euid int)`, `Getgid() (gid int)`, `Getuid() (uid int)`:**
    * **System Calls:** `SYS_GETEGID`, `SYS_GETEUID`, `SYS_GETGID`, `SYS_GETUID`
    * **Functionality:** Retrieve the effective group ID, effective user ID, group ID, and user ID of the calling process.
    * **Go Functionality:** Exposed through the `os` package's functions like `os.Getegid`, `os.Geteuid`, `os.Getgid`, and `os.Getuid`.

* **`Getrlimit(resource int, rlim *Rlimit) (err error)`:**
    * **System Call:** `SYS_GETRLIMIT`
    * **Functionality:** Gets the resource limits for a specific resource (e.g., maximum number of open files).
    * **Go Functionality:**  Used by the `syscall` package to retrieve system resource limits.

* **`Lchown(path string, uid int, gid int) (err error)`:**
    * **System Call:** `SYS_LCHOWN`
    * **Functionality:** Similar to `Fchown`, but if the path is a symbolic link, it changes the ownership of the link itself, not the target file.
    * **Go Functionality:** Implements the `os.Lchown` function.

* **`Lstat(path string, stat *Stat_t) (err error)`:**
    * **System Call:** `SYS_LSTAT`
    * **Functionality:** Similar to `Stat`, but if the path is a symbolic link, it returns information about the link itself, not the target file.
    * **Go Functionality:** Implements the `os.Lstat` function.

* **`Pause() (err error)`:**
    * **System Call:** `SYS_PAUSE`
    * **Functionality:** Suspends the calling process until a signal is delivered.
    * **Go Functionality:**  Might be used in low-level signal handling or synchronization primitives.

* **`pread(fd int, p []byte, offset int64) (n int, err error)`:**
    * **System Call:** `SYS_PREAD64`
    * **Functionality:** Reads data from a file descriptor at a specified offset without changing the file offset.
    * **Go Functionality:** Used internally by `io.ReaderAt` implementations for files.

* **`pwrite(fd int, p []byte, offset int64) (n int, err error)`:**
    * **System Call:** `SYS_PWRITE64`
    * **Functionality:** Writes data to a file descriptor at a specified offset without changing the file offset.
    * **Go Functionality:** Used internally by `io.WriterAt` implementations for files.

* **`Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error)`:**
    * **System Call:** `SYS_RENAMEAT`
    * **Functionality:** Renames a file, allowing the specification of directory file descriptors for both the old and new paths.
    * **Go Functionality:**  Used internally by `os.Rename` when dealing with relative paths and directory file descriptors.

* **`Seek(fd int, offset int64, whence int) (off int64, err error)`:**
    * **System Call:** `SYS_LSEEK`
    * **Functionality:** Changes the file offset of an open file.
    * **Go Functionality:**  Underlies the `io.Seeker` interface and the `os.File.Seek` method.

* **`Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error)`:**
    * **System Call:** `SYS_SELECT`
    * **Functionality:**  Waits for activity on multiple file descriptors. This is an older mechanism for I/O multiplexing, less efficient than `epoll` on Linux.
    * **Go Functionality:** While Go prefers `epoll`, `select` might be used as a fallback on systems where `epoll` is not available.

* **`sendfile(outfd int, infd int, offset *int64, count int) (written int, err error)`:**
    * **System Call:** `SYS_SENDFILE`
    * **Functionality:**  Efficiently copies data between two file descriptors without transferring data through user space. Commonly used for network transfers.
    * **Go Functionality:**  Used internally by Go's networking code (`net` package) for optimized data sending.

* **`setfsgid(gid int) (prev int, err error)`, `setfsuid(uid int) (prev int, err error)`:**
    * **System Calls:** `SYS_SETFSGID`, `SYS_SETFSUID`
    * **Functionality:** Set the file system group ID and file system user ID of the calling process. These IDs are used for permission checks when accessing files.
    * **Go Functionality:**  Might be used in security-sensitive contexts where the process needs to temporarily change its effective IDs for file access.

* **`Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error)`:**
    * **System Call:** `SYS_SPLICE`
    * **Functionality:** Moves data between two file descriptors, at least one of which must be a pipe. Similar to `tee` and `sendfile` but more general.
    * **Go Functionality:** Used for high-performance data transfer between pipes and sockets.

* **`Stat(path string, stat *Stat_t) (err error)`:**
    * **System Call:** `SYS_STAT`
    * **Functionality:** Retrieves file metadata for a given path.
    * **Go Functionality:** Implements the `os.Stat` function.

* **`Statfs(path string, buf *Statfs_t) (err error)`:**
    * **System Call:** `SYS_STATFS`
    * **Functionality:** Retrieves file system statistics for the file system containing the given path.
    * **Go Functionality:** Used by functions that need to get information about the file system, such as free space.

* **`SyncFileRange(fd int, off int64, n int64, flags int) (err error)`:**
    * **System Call:** `SYS_SYNC_FILE_RANGE`
    * **Functionality:**  Flushes a specific range of a file's data to disk. Provides more granular control than the `sync` system call.
    * **Go Functionality:**  Could be used by applications requiring strong data durability guarantees.

* **`Truncate(path string, length int64) (err error)`:**
    * **System Call:** `SYS_TRUNCATE`
    * **Functionality:** Truncates a file to a specified length.
    * **Go Functionality:** Implements the `os.Truncate` function.

* **`Ustat(dev int, ubuf *Ustat_t) (err error)`:**
    * **System Call:** `SYS_USTAT`
    * **Functionality:** Returns information about a mounted file system. This system call is considered obsolete.
    * **Go Functionality:**  Likely present for compatibility or very specific low-level use cases.

* **`getgroups(n int, list *_Gid_t) (nn int, err error)`, `setgroups(n int, list *_Gid_t) (err error)`:**
    * **System Calls:** `SYS_GETGROUPS`, `SYS_SETGROUPS`
    * **Functionality:** Get and set the supplementary group IDs for the calling process.
    * **Go Functionality:**  Exposed through the `syscall` package for managing process group memberships.

* **`futimesat(dirfd int, path string, times *[2]Timeval) (err error)`:**
    * **System Call:** `SYS_FUTIMESAT`
    * **Functionality:** Sets the access and modification times of a file, similar to `utimes`, but allows specifying a directory file descriptor for resolving relative paths.
    * **Go Functionality:**  Used internally by `os.Chtimes` when dealing with relative paths and directory file descriptors.

* **`Gettimeofday(tv *Timeval) (err error)`:**
    * **System Call:** `SYS_GETTIMEOFDAY`
    * **Functionality:** Gets the current time of day.
    * **Go Functionality:**  Underlying implementation for obtaining the current time in Go. Higher-level functions like `time.Now()` will eventually use this.

* **`Utime(path string, buf *Utimbuf) (err error)`, `utimes(path string, times *[2]Timeval) (err error)`:**
    * **System Calls:** `SYS_UTIME`, `SYS_UTIMES`
    * **Functionality:** Set the access and modification times of a file. `utimes` is more precise.
    * **Go Functionality:** Implements the `os.Chtimes` function.

* **`kexecFileLoad(kernelFd int, initrdFd int, cmdlineLen int, cmdline string, flags int) (err error)`:**
    * **System Call:** `SYS_KEXEC_FILE_LOAD`
    * **Functionality:** Loads a new kernel image for execution without a full system reboot.
    * **Go Functionality:**  Used in specialized system administration tools or bootloaders.

* **`Alarm(seconds uint) (remaining uint, err error)`:**
    * **System Call:** `SYS_ALARM`
    * **Functionality:** Sets a timer that will deliver a `SIGALRM` signal to the process after a specified number of seconds.
    * **Go Functionality:**  Part of Go's signal handling mechanism. Can be used to implement timeouts or periodic actions.

**Example of Go Code Using These Low-Level Functions (Conceptual):**

While you typically wouldn't call these functions directly in most Go code, here's a conceptual example showing how some might be used internally:

```go
package main

import (
	"fmt"
	"os"
	"syscall"
	"time"
	"unsafe"
)

func main() {
	fileInfo, err := os.Stat("my_file.txt")
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	fmt.Println("File Size:", fileInfo.Size())

	// Conceptual: How os.Stat might use the underlying syscall
	var stat syscall.Stat_t
	err = syscall.Stat("my_file.txt", &stat)
	if err != nil {
		fmt.Println("Syscall Error:", err)
		return
	}
	fmt.Println("Syscall File Size:", stat.Size)

	// Conceptual: Using Fallocate for pre-allocation (not recommended for direct use)
	file, err := os.Create("large_file.dat")
	if err != nil {
		fmt.Println("Error creating file:", err)
		return
	}
	defer file.Close()

	fd := int(file.Fd())
	sizeToAllocate := int64(1024 * 1024 * 100) // 100 MB
	err = syscall.Fallocate(fd, 0, 0, sizeToAllocate)
	if err != nil {
		fmt.Println("Error pre-allocating:", err)
	} else {
		fmt.Println("Successfully pre-allocated space.")
	}

	// Conceptual: Getting the current time using the syscall (time.Now() is preferred)
	var tv syscall.Timeval
	err = syscall.Gettimeofday(&tv)
	if err != nil {
		fmt.Println("Error getting time:", err)
		return
	}
	currentTime := time.Unix(tv.Unix(), tv.Nsec())
	fmt.Println("Current Time (syscall):", currentTime)
}
```

**Assumptions for Code Inference:**

* **Error Handling:** The generated code assumes that if the system call returns a non-zero error number, it should be converted to a Go `error`.
* **Memory Management:** The code relies on Go's memory management for allocating and freeing memory. When passing pointers, it's assumed that the underlying data structures are valid.
* **System Call Interface:** The code directly maps Go types to the expected types of the underlying Linux system calls for the s390x architecture.

**Command Line Arguments of `mksyscall`:**

The comment at the top shows the command used to generate this file:

```
// go run mksyscall.go -tags linux,s390x syscall_linux.go syscall_linux_s390x.go syscall_linux_alarm.go
```

* **`go run mksyscall.go`:**  This executes the `mksyscall.go` program. This program is part of the Go toolchain and is responsible for generating system call wrappers.
* **`-tags linux,s390x`:** This flag tells `mksyscall` to generate code specifically for the `linux` operating system and the `s390x` architecture. This is why the output file is named `zsyscall_linux_s390x.go`. The build tags ensure this file is only compiled when building for this specific platform.
* **`syscall_linux.go`:** This is likely a base file containing common definitions and system call numbers for Linux.
* **`syscall_linux_s390x.go`:** This file likely contains s390x-specific definitions or overrides for system calls.
* **`syscall_linux_alarm.go`:** This might be a specific file containing definitions related to the `alarm` system call or other timer-related calls.

**Common Mistakes Users Might Make (When Interacting with Higher-Level APIs):**

Users generally don't interact with these `zsyscall_*.go` files directly. However, understanding their purpose can help avoid mistakes when using higher-level Go APIs that rely on them:

* **Incorrectly interpreting error messages:** If a higher-level function returns an error, understanding that it might originate from a specific system call can help in debugging. For example, an "operation not permitted" error might trace back to a permission issue at the system call level.
* **Misunderstanding platform differences:**  System calls and their behavior can vary across operating systems and architectures. Relying on specific system call behavior without considering platform differences can lead to portability issues. Go's standard library aims to abstract away many of these differences, but for very low-level operations, awareness is needed.
* **Not handling signals correctly:** When using functions like `Alarm` (indirectly through higher-level APIs), it's crucial to understand how signals work and how to handle them gracefully in Go.

In summary, `zsyscall_linux_s390x.go` is a crucial piece of Go's runtime for the Linux/s390x platform. It bridges the gap between Go code and the underlying operating system kernel, enabling Go programs to perform essential system-level operations. You typically don't interact with this file directly, but understanding its role can provide valuable insight into how Go works at a lower level.

Prompt: 
```
这是路径为go/src/cmd/vendor/golang.org/x/sys/unix/zsyscall_linux_s390x.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，

"""
// go run mksyscall.go -tags linux,s390x syscall_linux.go syscall_linux_s390x.go syscall_linux_alarm.go
// Code generated by the command above; see README.md. DO NOT EDIT.

//go:build linux && s390x

package unix

import (
	"syscall"
	"unsafe"
)

var _ syscall.Errno

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fanotifyMark(fd int, flags uint, mask uint64, dirFd int, pathname *byte) (err error) {
	_, _, e1 := Syscall6(SYS_FANOTIFY_MARK, uintptr(fd), uintptr(flags), uintptr(mask), uintptr(dirFd), uintptr(unsafe.Pointer(pathname)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fallocate(fd int, mode uint32, off int64, len int64) (err error) {
	_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(len), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Tee(rfd int, wfd int, len int, flags int) (n int64, err error) {
	r0, _, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)
	n = int64(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func EpollWait(epfd int, events []EpollEvent, msec int) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(events) > 0 {
		_p0 = unsafe.Pointer(&events[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec), 0, 0)
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fadvise(fd int, offset int64, length int64, advice int) (err error) {
	_, _, e1 := Syscall6(SYS_FADVISE64, uintptr(fd), uintptr(offset), uintptr(length), uintptr(advice), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fchown(fd int, uid int, gid int) (err error) {
	_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fstat(fd int, stat *Stat_t) (err error) {
	_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall6(SYS_NEWFSTATAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fstatfs(fd int, buf *Statfs_t) (err error) {
	_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(buf)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Ftruncate(fd int, length int64) (err error) {
	_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getegid() (egid int) {
	r0, _ := RawSyscallNoError(SYS_GETEGID, 0, 0, 0)
	egid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Geteuid() (euid int) {
	r0, _ := RawSyscallNoError(SYS_GETEUID, 0, 0, 0)
	euid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getgid() (gid int) {
	r0, _ := RawSyscallNoError(SYS_GETGID, 0, 0, 0)
	gid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getrlimit(resource int, rlim *Rlimit) (err error) {
	_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getuid() (uid int) {
	r0, _ := RawSyscallNoError(SYS_GETUID, 0, 0, 0)
	uid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Lchown(path string, uid int, gid int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Lstat(path string, stat *Stat_t) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pause() (err error) {
	_, _, e1 := Syscall(SYS_PAUSE, 0, 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func pread(fd int, p []byte, offset int64) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func pwrite(fd int, p []byte, offset int64) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(oldpath)
	if err != nil {
		return
	}
	var _p1 *byte
	_p1, err = BytePtrFromString(newpath)
	if err != nil {
		return
	}
	_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Seek(fd int, offset int64, whence int) (off int64, err error) {
	r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))
	off = int64(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) {
	r0, _, e1 := Syscall6(SYS_SELECT, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) {
	r0, _, e1 := Syscall6(SYS_SENDFILE, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)
	written = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func setfsgid(gid int) (prev int, err error) {
	r0, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)
	prev = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func setfsuid(uid int) (prev int, err error) {
	r0, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)
	prev = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error) {
	r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))
	n = int64(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Stat(path string, stat *Stat_t) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Statfs(path string, buf *Statfs_t) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func SyncFileRange(fd int, off int64, n int64, flags int) (err error) {
	_, _, e1 := Syscall6(SYS_SYNC_FILE_RANGE, uintptr(fd), uintptr(off), uintptr(n), uintptr(flags), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Truncate(path string, length int64) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Ustat(dev int, ubuf *Ustat_t) (err error) {
	_, _, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getgroups(n int, list *_Gid_t) (nn int, err error) {
	r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)
	nn = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func setgroups(n int, list *_Gid_t) (err error) {
	_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func futimesat(dirfd int, path string, times *[2]Timeval) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Gettimeofday(tv *Timeval) (err error) {
	_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Utime(path string, buf *Utimbuf) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_UTIME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func utimes(path string, times *[2]Timeval) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func kexecFileLoad(kernelFd int, initrdFd int, cmdlineLen int, cmdline string, flags int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(cmdline)
	if err != nil {
		return
	}
	_, _, e1 := Syscall6(SYS_KEXEC_FILE_LOAD, uintptr(kernelFd), uintptr(initrdFd), uintptr(cmdlineLen), uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Alarm(seconds uint) (remaining uint, err error) {
	r0, _, e1 := Syscall(SYS_ALARM, uintptr(seconds), 0, 0)
	remaining = uint(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

"""



```
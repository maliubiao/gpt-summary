Response:
My thought process to answer the request goes like this:

1. **Understand the Core Request:** The primary goal is to understand the functionality of the given Go code snippet. Specifically, the request asks for:
    * Listing the functions.
    * Inferring the Go feature it implements.
    * Providing a Go code example.
    * Explaining relevant command-line arguments (if any).
    * Identifying common mistakes users might make.

2. **Analyze the Code:** The code consists of a large `const` block within a Go package named `unix`. Each constant definition follows a pattern: `SYS_<SYSTEM_CALL_NAME> = <syscall_number> // { <syscall_signature> }`. The comment at the top indicates the file is automatically generated from a system call definition file (`syscalls.master`). The `//go:build` directive indicates that this code is specific to the `riscv64` architecture on `openbsd`.

3. **Identify the Functionality:**  The pattern of `SYS_...` constants strongly suggests that this file defines **system call numbers** for the OpenBSD operating system on the RISC-V 64-bit architecture. Each constant represents a unique identifier for a specific system call. The comments provide the C-style signature of the corresponding system call. The "Deprecated" comment suggests these are *direct* system call numbers and that using the `libc` wrappers is preferred.

4. **Infer the Go Feature:**  Go's `syscall` package provides a way to directly interact with operating system system calls. This file, with its system call number definitions, is clearly part of how Go enables these low-level interactions on the specified platform. Specifically, this file serves as a lookup table, mapping human-readable system call names to their numerical identifiers. The `syscall` package (or related internal packages) would use these constants when making system call requests.

5. **Construct the Go Code Example:** To illustrate how these constants are used, I need to show a scenario where a system call is made. A simple example is the `open` system call.

    * **Import necessary packages:**  `syscall` and `fmt` are needed.
    * **Use the constant:** Access the `SYS_OPEN` constant.
    * **Make the syscall:** Use `syscall.Syscall` to invoke the system call. This function takes the syscall number as its first argument. I need to look up the signature of `open` to know the types of arguments to pass (`const char *path`, `int flags`, `... mode_t mode`).
    * **Handle errors:**  System calls can fail, so error handling is essential.
    * **Output:** Print the result of the system call.

    **Important Consideration:**  The deprecation warning suggests that directly using these constants is discouraged. Therefore, I should also demonstrate the *recommended* way using the `os` package, which provides higher-level, platform-independent wrappers around system calls. The `os.Open` function is a good example.

6. **Command-Line Arguments:** The provided code doesn't directly process command-line arguments. The `go run mksysnum.go ...` comment indicates a *code generation* step, not something directly used by applications at runtime. The `mksysnum.go` script likely scrapes the system call definitions from the given URL. Therefore, the relevant "command-line arguments" are those passed to `mksysnum.go`, which I should explain.

7. **Common Mistakes:** The most significant mistake users could make is to directly use these `SYS_` constants with `syscall.Syscall` without understanding the implications. This bypasses Go's standard library abstractions and can lead to platform-specific code that is harder to maintain and less portable. I should emphasize the recommendation to use the standard library wrappers.

8. **Review and Refine:**  Read through the drafted answer to ensure clarity, accuracy, and completeness. Check for any inconsistencies or areas that could be explained better. For example, clearly distinguish between the deprecated direct syscall approach and the recommended standard library approach in the code example.

By following these steps, I can generate a comprehensive and accurate answer that addresses all aspects of the user's request.

这段Go语言代码定义了一系列常量，这些常量代表了OpenBSD操作系统在RISC-V 64位架构上的系统调用号。

**功能列举:**

1. **定义系统调用号:**  代码的核心功能是为OpenBSD/riscv64架构的每个系统调用分配一个唯一的数字标识符。例如，`SYS_EXIT` 被赋值为 `1`，表示 `exit` 系统调用的编号是 1。
2. **提供系统调用的名称:**  每个常量名都以 `SYS_` 开头，后面跟着系统调用的名称，例如 `SYS_READ`、`SYS_OPEN` 等，方便开发者理解对应的系统调用。
3. **记录系统调用签名 (作为注释):**  每行常量定义的注释部分 `// { ... }`  提供了该系统调用的C语言风格的签名，包括参数类型和返回值类型，这对于理解系统调用的功能很有帮助。
4. **平台和架构特定:**  通过 `//go:build riscv64 && openbsd` 注释，表明这些常量仅适用于运行在 OpenBSD 操作系统上的 RISC-V 64位架构。这意味着在其他操作系统或架构上，这些常量可能不存在或者有不同的值。
5. **代码生成标记:**  `// Code generated by the command above; see README.md. DO NOT EDIT.` 表明这个文件是通过 `mksysnum.go` 脚本自动生成的，不应该手动编辑。

**Go语言功能的实现（推理）：**

这个文件是 Go 语言 `syscall` 标准库的一部分，用于在特定的操作系统和架构上进行底层的系统调用。`syscall` 包允许 Go 程序直接调用操作系统提供的系统调用接口。

**Go代码举例说明:**

假设我们想在 OpenBSD/riscv64 上使用底层的 `open` 系统调用打开一个文件。虽然 Go 的 `os` 包提供了更高级的 `os.Open` 函数，但我们可以使用 `syscall` 包和这里定义的常量 `SYS_OPEN` 来直接调用。

```go
package main

import (
	"fmt"
	"syscall"
	"unsafe"
)

func main() {
	pathname := "/tmp/test.txt"
	flags := syscall.O_RDONLY // 只读模式
	mode := uint32(0)          // 权限，由于是只读模式，可以设置为 0

	fd, _, errno := syscall.Syscall(syscall.SYS_OPEN,
		uintptr(unsafe.Pointer(syscall.StringBytePtr(pathname))),
		uintptr(flags),
		uintptr(mode))

	if errno != 0 {
		fmt.Printf("open error: %v\n", errno)
		return
	}
	fmt.Printf("File descriptor: %d\n", fd)

	err := syscall.Close(int(fd))
	if err != nil {
		fmt.Printf("close error: %v\n", err)
	}
}
```

**假设的输入与输出:**

* **假设输入:**  `/tmp/test.txt` 文件存在且有读取权限。
* **预期输出:**  程序会打印出打开文件的文件描述符，例如 `File descriptor: 3`。如果文件不存在或没有读取权限，则会打印 `open error: ...`，其中 `...` 是具体的错误信息。

**代码推理:**

1. 我们使用了 `syscall.SYS_OPEN` 常量来指定要调用的系统调用。
2. `syscall.Syscall` 函数是 Go 中进行底层系统调用的方法。它的第一个参数是系统调用号。
3. 后面的参数是系统调用所需的参数，需要根据系统调用的签名进行转换。对于 `open` 系统调用，需要文件路径的指针、打开标志和模式。
4. `unsafe.Pointer` 用于将 Go 的字符串指针转换为 `uintptr`，因为系统调用需要原始的内存地址。
5. `syscall.StringBytePtr` 用于获取以 null 结尾的 C 字符串的指针。
6. 系统调用返回文件描述符 (`fd`)、一个未使用的 `uintptr` 和一个错误码 (`errno`)。
7. 我们检查 `errno` 是否为 0，以判断系统调用是否成功。
8. 最后，我们使用 `syscall.Close` 关闭打开的文件描述符。

**命令行参数的具体处理:**

这个代码片段本身不处理命令行参数。它只是定义了一些常量。  `// go run mksysnum.go https://cvsweb.openbsd.org/cgi-bin/cvsweb/~checkout~/src/sys/kern/syscalls.master`  这行注释表明，这个文件是通过运行 `mksysnum.go` 脚本生成的。

`mksysnum.go` 这个脚本会：

1. **下载系统调用定义:**  从指定的 URL (`https://cvsweb.openbsd.org/cgi-bin/cvsweb/~checkout~/src/sys/kern/syscalls.master`) 下载 OpenBSD 的系统调用定义文件 `syscalls.master`。
2. **解析定义文件:**  解析 `syscalls.master` 文件，提取出每个系统调用的名称和对应的编号。
3. **生成 Go 代码:**  根据解析出的信息，生成类似 `zsysnum_openbsd_riscv64.go` 这样的 Go 代码文件，其中包含了 `SYS_` 常量的定义。

因此，这里的“命令行参数”是传递给 `mksysnum.go` 脚本的 URL，用于指定系统调用定义文件的位置。

**使用者易犯错的点:**

1. **直接使用 `syscall.Syscall` 而不了解系统调用细节:**  新手可能会直接使用 `syscall.Syscall` 和这些常量，而不理解底层系统调用的参数、返回值和错误处理。这可能导致程序崩溃或产生不可预测的行为。 **应该优先使用 Go 标准库中更高层次的抽象 (如 `os` 包, `net` 包等)。**
2. **平台依赖性:**  这些常量是特定于 OpenBSD/riscv64 平台的。直接使用这些常量编写的代码将无法在其他操作系统或架构上编译或运行。 开发者需要意识到代码的平台依赖性。
3. **不正确的参数传递:**  `syscall.Syscall` 的参数需要非常小心地构造，以匹配底层系统调用的期望。类型转换错误（例如，将 Go 字符串直接传递而不是传递其 C 风格的指针）是常见的错误。
4. **忽略错误处理:**  系统调用可能会失败，必须检查 `syscall.Syscall` 返回的错误码。忽略错误处理会导致程序在遇到问题时无法正常工作。
5. **手动修改生成的文件:**  注释明确指出 `DO NOT EDIT`。手动修改这个自动生成的文件可能会在下次重新生成时被覆盖，或者导致与生成脚本不一致。

**易犯错的例子:**

```go
package main

import (
	"fmt"
	"syscall"
)

func main() {
	// 错误地直接传递 Go 字符串
	_, _, errno := syscall.Syscall(syscall.SYS_CHDIR, uintptr("invalid_path"), 0, 0)
	if errno != 0 {
		fmt.Printf("chdir error: %v\n", errno)
	}
}
```

在这个例子中，直接将 Go 字符串 `"invalid_path"` 转换为 `uintptr` 并传递给 `SYS_CHDIR` 是错误的。`chdir` 系统调用期望的是指向以 null 结尾的 C 字符串的指针。正确的做法是使用 `syscall.StringBytePtr` 将 Go 字符串转换为 C 字符串指针。

总之，`zsysnum_openbsd_riscv64.go` 文件是 Go 语言为了在 OpenBSD/riscv64 平台上进行底层系统调用而自动生成的，它定义了系统调用的编号。开发者应该理解其用途和局限性，并优先使用 Go 标准库提供的更高层次的抽象。

### 提示词
```
这是路径为go/src/cmd/vendor/golang.org/x/sys/unix/zsysnum_openbsd_riscv64.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
```

### 源代码
```go
// go run mksysnum.go https://cvsweb.openbsd.org/cgi-bin/cvsweb/~checkout~/src/sys/kern/syscalls.master
// Code generated by the command above; see README.md. DO NOT EDIT.

//go:build riscv64 && openbsd

package unix

// Deprecated: Use libc wrappers instead of direct syscalls.
const (
	SYS_EXIT           = 1   // { void sys_exit(int rval); }
	SYS_FORK           = 2   // { int sys_fork(void); }
	SYS_READ           = 3   // { ssize_t sys_read(int fd, void *buf, size_t nbyte); }
	SYS_WRITE          = 4   // { ssize_t sys_write(int fd, const void *buf, size_t nbyte); }
	SYS_OPEN           = 5   // { int sys_open(const char *path, int flags, ... mode_t mode); }
	SYS_CLOSE          = 6   // { int sys_close(int fd); }
	SYS_GETENTROPY     = 7   // { int sys_getentropy(void *buf, size_t nbyte); }
	SYS___TFORK        = 8   // { int sys___tfork(const struct __tfork *param, size_t psize); }
	SYS_LINK           = 9   // { int sys_link(const char *path, const char *link); }
	SYS_UNLINK         = 10  // { int sys_unlink(const char *path); }
	SYS_WAIT4          = 11  // { pid_t sys_wait4(pid_t pid, int *status, int options, struct rusage *rusage); }
	SYS_CHDIR          = 12  // { int sys_chdir(const char *path); }
	SYS_FCHDIR         = 13  // { int sys_fchdir(int fd); }
	SYS_MKNOD          = 14  // { int sys_mknod(const char *path, mode_t mode, dev_t dev); }
	SYS_CHMOD          = 15  // { int sys_chmod(const char *path, mode_t mode); }
	SYS_CHOWN          = 16  // { int sys_chown(const char *path, uid_t uid, gid_t gid); }
	SYS_OBREAK         = 17  // { int sys_obreak(char *nsize); } break
	SYS_GETDTABLECOUNT = 18  // { int sys_getdtablecount(void); }
	SYS_GETRUSAGE      = 19  // { int sys_getrusage(int who, struct rusage *rusage); }
	SYS_GETPID         = 20  // { pid_t sys_getpid(void); }
	SYS_MOUNT          = 21  // { int sys_mount(const char *type, const char *path, int flags, void *data); }
	SYS_UNMOUNT        = 22  // { int sys_unmount(const char *path, int flags); }
	SYS_SETUID         = 23  // { int sys_setuid(uid_t uid); }
	SYS_GETUID         = 24  // { uid_t sys_getuid(void); }
	SYS_GETEUID        = 25  // { uid_t sys_geteuid(void); }
	SYS_PTRACE         = 26  // { int sys_ptrace(int req, pid_t pid, caddr_t addr, int data); }
	SYS_RECVMSG        = 27  // { ssize_t sys_recvmsg(int s, struct msghdr *msg, int flags); }
	SYS_SENDMSG        = 28  // { ssize_t sys_sendmsg(int s, const struct msghdr *msg, int flags); }
	SYS_RECVFROM       = 29  // { ssize_t sys_recvfrom(int s, void *buf, size_t len, int flags, struct sockaddr *from, socklen_t *fromlenaddr); }
	SYS_ACCEPT         = 30  // { int sys_accept(int s, struct sockaddr *name, socklen_t *anamelen); }
	SYS_GETPEERNAME    = 31  // { int sys_getpeername(int fdes, struct sockaddr *asa, socklen_t *alen); }
	SYS_GETSOCKNAME    = 32  // { int sys_getsockname(int fdes, struct sockaddr *asa, socklen_t *alen); }
	SYS_ACCESS         = 33  // { int sys_access(const char *path, int amode); }
	SYS_CHFLAGS        = 34  // { int sys_chflags(const char *path, u_int flags); }
	SYS_FCHFLAGS       = 35  // { int sys_fchflags(int fd, u_int flags); }
	SYS_SYNC           = 36  // { void sys_sync(void); }
	SYS_STAT           = 38  // { int sys_stat(const char *path, struct stat *ub); }
	SYS_GETPPID        = 39  // { pid_t sys_getppid(void); }
	SYS_LSTAT          = 40  // { int sys_lstat(const char *path, struct stat *ub); }
	SYS_DUP            = 41  // { int sys_dup(int fd); }
	SYS_FSTATAT        = 42  // { int sys_fstatat(int fd, const char *path, struct stat *buf, int flag); }
	SYS_GETEGID        = 43  // { gid_t sys_getegid(void); }
	SYS_PROFIL         = 44  // { int sys_profil(caddr_t samples, size_t size, u_long offset, u_int scale); }
	SYS_KTRACE         = 45  // { int sys_ktrace(const char *fname, int ops, int facs, pid_t pid); }
	SYS_SIGACTION      = 46  // { int sys_sigaction(int signum, const struct sigaction *nsa, struct sigaction *osa); }
	SYS_GETGID         = 47  // { gid_t sys_getgid(void); }
	SYS_SIGPROCMASK    = 48  // { int sys_sigprocmask(int how, sigset_t mask); }
	SYS_SETLOGIN       = 50  // { int sys_setlogin(const char *namebuf); }
	SYS_ACCT           = 51  // { int sys_acct(const char *path); }
	SYS_SIGPENDING     = 52  // { int sys_sigpending(void); }
	SYS_FSTAT          = 53  // { int sys_fstat(int fd, struct stat *sb); }
	SYS_IOCTL          = 54  // { int sys_ioctl(int fd, u_long com, ... void *data); }
	SYS_REBOOT         = 55  // { int sys_reboot(int opt); }
	SYS_REVOKE         = 56  // { int sys_revoke(const char *path); }
	SYS_SYMLINK        = 57  // { int sys_symlink(const char *path, const char *link); }
	SYS_READLINK       = 58  // { ssize_t sys_readlink(const char *path, char *buf, size_t count); }
	SYS_EXECVE         = 59  // { int sys_execve(const char *path, char * const *argp, char * const *envp); }
	SYS_UMASK          = 60  // { mode_t sys_umask(mode_t newmask); }
	SYS_CHROOT         = 61  // { int sys_chroot(const char *path); }
	SYS_GETFSSTAT      = 62  // { int sys_getfsstat(struct statfs *buf, size_t bufsize, int flags); }
	SYS_STATFS         = 63  // { int sys_statfs(const char *path, struct statfs *buf); }
	SYS_FSTATFS        = 64  // { int sys_fstatfs(int fd, struct statfs *buf); }
	SYS_FHSTATFS       = 65  // { int sys_fhstatfs(const fhandle_t *fhp, struct statfs *buf); }
	SYS_VFORK          = 66  // { int sys_vfork(void); }
	SYS_GETTIMEOFDAY   = 67  // { int sys_gettimeofday(struct timeval *tp, struct timezone *tzp); }
	SYS_SETTIMEOFDAY   = 68  // { int sys_settimeofday(const struct timeval *tv, const struct timezone *tzp); }
	SYS_SETITIMER      = 69  // { int sys_setitimer(int which, const struct itimerval *itv, struct itimerval *oitv); }
	SYS_GETITIMER      = 70  // { int sys_getitimer(int which, struct itimerval *itv); }
	SYS_SELECT         = 71  // { int sys_select(int nd, fd_set *in, fd_set *ou, fd_set *ex, struct timeval *tv); }
	SYS_KEVENT         = 72  // { int sys_kevent(int fd, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout); }
	SYS_MUNMAP         = 73  // { int sys_munmap(void *addr, size_t len); }
	SYS_MPROTECT       = 74  // { int sys_mprotect(void *addr, size_t len, int prot); }
	SYS_MADVISE        = 75  // { int sys_madvise(void *addr, size_t len, int behav); }
	SYS_UTIMES         = 76  // { int sys_utimes(const char *path, const struct timeval *tptr); }
	SYS_FUTIMES        = 77  // { int sys_futimes(int fd, const struct timeval *tptr); }
	SYS_GETGROUPS      = 79  // { int sys_getgroups(int gidsetsize, gid_t *gidset); }
	SYS_SETGROUPS      = 80  // { int sys_setgroups(int gidsetsize, const gid_t *gidset); }
	SYS_GETPGRP        = 81  // { int sys_getpgrp(void); }
	SYS_SETPGID        = 82  // { int sys_setpgid(pid_t pid, pid_t pgid); }
	SYS_FUTEX          = 83  // { int sys_futex(uint32_t *f, int op, int val, const struct timespec *timeout, uint32_t *g); }
	SYS_UTIMENSAT      = 84  // { int sys_utimensat(int fd, const char *path, const struct timespec *times, int flag); }
	SYS_FUTIMENS       = 85  // { int sys_futimens(int fd, const struct timespec *times); }
	SYS_KBIND          = 86  // { int sys_kbind(const struct __kbind *param, size_t psize, int64_t proc_cookie); }
	SYS_CLOCK_GETTIME  = 87  // { int sys_clock_gettime(clockid_t clock_id, struct timespec *tp); }
	SYS_CLOCK_SETTIME  = 88  // { int sys_clock_settime(clockid_t clock_id, const struct timespec *tp); }
	SYS_CLOCK_GETRES   = 89  // { int sys_clock_getres(clockid_t clock_id, struct timespec *tp); }
	SYS_DUP2           = 90  // { int sys_dup2(int from, int to); }
	SYS_NANOSLEEP      = 91  // { int sys_nanosleep(const struct timespec *rqtp, struct timespec *rmtp); }
	SYS_FCNTL          = 92  // { int sys_fcntl(int fd, int cmd, ... void *arg); }
	SYS_ACCEPT4        = 93  // { int sys_accept4(int s, struct sockaddr *name, socklen_t *anamelen, int flags); }
	SYS___THRSLEEP     = 94  // { int sys___thrsleep(const volatile void *ident, clockid_t clock_id, const struct timespec *tp, void *lock, const int *abort); }
	SYS_FSYNC          = 95  // { int sys_fsync(int fd); }
	SYS_SETPRIORITY    = 96  // { int sys_setpriority(int which, id_t who, int prio); }
	SYS_SOCKET         = 97  // { int sys_socket(int domain, int type, int protocol); }
	SYS_CONNECT        = 98  // { int sys_connect(int s, const struct sockaddr *name, socklen_t namelen); }
	SYS_GETDENTS       = 99  // { int sys_getdents(int fd, void *buf, size_t buflen); }
	SYS_GETPRIORITY    = 100 // { int sys_getpriority(int which, id_t who); }
	SYS_PIPE2          = 101 // { int sys_pipe2(int *fdp, int flags); }
	SYS_DUP3           = 102 // { int sys_dup3(int from, int to, int flags); }
	SYS_SIGRETURN      = 103 // { int sys_sigreturn(struct sigcontext *sigcntxp); }
	SYS_BIND           = 104 // { int sys_bind(int s, const struct sockaddr *name, socklen_t namelen); }
	SYS_SETSOCKOPT     = 105 // { int sys_setsockopt(int s, int level, int name, const void *val, socklen_t valsize); }
	SYS_LISTEN         = 106 // { int sys_listen(int s, int backlog); }
	SYS_CHFLAGSAT      = 107 // { int sys_chflagsat(int fd, const char *path, u_int flags, int atflags); }
	SYS_PLEDGE         = 108 // { int sys_pledge(const char *promises, const char *execpromises); }
	SYS_PPOLL          = 109 // { int sys_ppoll(struct pollfd *fds, u_int nfds, const struct timespec *ts, const sigset_t *mask); }
	SYS_PSELECT        = 110 // { int sys_pselect(int nd, fd_set *in, fd_set *ou, fd_set *ex, const struct timespec *ts, const sigset_t *mask); }
	SYS_SIGSUSPEND     = 111 // { int sys_sigsuspend(int mask); }
	SYS_SENDSYSLOG     = 112 // { int sys_sendsyslog(const char *buf, size_t nbyte, int flags); }
	SYS_UNVEIL         = 114 // { int sys_unveil(const char *path, const char *permissions); }
	SYS_GETSOCKOPT     = 118 // { int sys_getsockopt(int s, int level, int name, void *val, socklen_t *avalsize); }
	SYS_THRKILL        = 119 // { int sys_thrkill(pid_t tid, int signum, void *tcb); }
	SYS_READV          = 120 // { ssize_t sys_readv(int fd, const struct iovec *iovp, int iovcnt); }
	SYS_WRITEV         = 121 // { ssize_t sys_writev(int fd, const struct iovec *iovp, int iovcnt); }
	SYS_KILL           = 122 // { int sys_kill(int pid, int signum); }
	SYS_FCHOWN         = 123 // { int sys_fchown(int fd, uid_t uid, gid_t gid); }
	SYS_FCHMOD         = 124 // { int sys_fchmod(int fd, mode_t mode); }
	SYS_SETREUID       = 126 // { int sys_setreuid(uid_t ruid, uid_t euid); }
	SYS_SETREGID       = 127 // { int sys_setregid(gid_t rgid, gid_t egid); }
	SYS_RENAME         = 128 // { int sys_rename(const char *from, const char *to); }
	SYS_FLOCK          = 131 // { int sys_flock(int fd, int how); }
	SYS_MKFIFO         = 132 // { int sys_mkfifo(const char *path, mode_t mode); }
	SYS_SENDTO         = 133 // { ssize_t sys_sendto(int s, const void *buf, size_t len, int flags, const struct sockaddr *to, socklen_t tolen); }
	SYS_SHUTDOWN       = 134 // { int sys_shutdown(int s, int how); }
	SYS_SOCKETPAIR     = 135 // { int sys_socketpair(int domain, int type, int protocol, int *rsv); }
	SYS_MKDIR          = 136 // { int sys_mkdir(const char *path, mode_t mode); }
	SYS_RMDIR          = 137 // { int sys_rmdir(const char *path); }
	SYS_ADJTIME        = 140 // { int sys_adjtime(const struct timeval *delta, struct timeval *olddelta); }
	SYS_GETLOGIN_R     = 141 // { int sys_getlogin_r(char *namebuf, u_int namelen); }
	SYS_SETSID         = 147 // { int sys_setsid(void); }
	SYS_QUOTACTL       = 148 // { int sys_quotactl(const char *path, int cmd, int uid, char *arg); }
	SYS_NFSSVC         = 155 // { int sys_nfssvc(int flag, void *argp); }
	SYS_GETFH          = 161 // { int sys_getfh(const char *fname, fhandle_t *fhp); }
	SYS_SYSARCH        = 165 // { int sys_sysarch(int op, void *parms); }
	SYS_PREAD          = 173 // { ssize_t sys_pread(int fd, void *buf, size_t nbyte, int pad, off_t offset); }
	SYS_PWRITE         = 174 // { ssize_t sys_pwrite(int fd, const void *buf, size_t nbyte, int pad, off_t offset); }
	SYS_SETGID         = 181 // { int sys_setgid(gid_t gid); }
	SYS_SETEGID        = 182 // { int sys_setegid(gid_t egid); }
	SYS_SETEUID        = 183 // { int sys_seteuid(uid_t euid); }
	SYS_PATHCONF       = 191 // { long sys_pathconf(const char *path, int name); }
	SYS_FPATHCONF      = 192 // { long sys_fpathconf(int fd, int name); }
	SYS_SWAPCTL        = 193 // { int sys_swapctl(int cmd, const void *arg, int misc); }
	SYS_GETRLIMIT      = 194 // { int sys_getrlimit(int which, struct rlimit *rlp); }
	SYS_SETRLIMIT      = 195 // { int sys_setrlimit(int which, const struct rlimit *rlp); }
	SYS_MMAP           = 197 // { void *sys_mmap(void *addr, size_t len, int prot, int flags, int fd, long pad, off_t pos); }
	SYS_LSEEK          = 199 // { off_t sys_lseek(int fd, int pad, off_t offset, int whence); }
	SYS_TRUNCATE       = 200 // { int sys_truncate(const char *path, int pad, off_t length); }
	SYS_FTRUNCATE      = 201 // { int sys_ftruncate(int fd, int pad, off_t length); }
	SYS_SYSCTL         = 202 // { int sys_sysctl(const int *name, u_int namelen, void *old, size_t *oldlenp, void *new, size_t newlen); }
	SYS_MLOCK          = 203 // { int sys_mlock(const void *addr, size_t len); }
	SYS_MUNLOCK        = 204 // { int sys_munlock(const void *addr, size_t len); }
	SYS_GETPGID        = 207 // { pid_t sys_getpgid(pid_t pid); }
	SYS_UTRACE         = 209 // { int sys_utrace(const char *label, const void *addr, size_t len); }
	SYS_SEMGET         = 221 // { int sys_semget(key_t key, int nsems, int semflg); }
	SYS_MSGGET         = 225 // { int sys_msgget(key_t key, int msgflg); }
	SYS_MSGSND         = 226 // { int sys_msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg); }
	SYS_MSGRCV         = 227 // { int sys_msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg); }
	SYS_SHMAT          = 228 // { void *sys_shmat(int shmid, const void *shmaddr, int shmflg); }
	SYS_SHMDT          = 230 // { int sys_shmdt(const void *shmaddr); }
	SYS_MINHERIT       = 250 // { int sys_minherit(void *addr, size_t len, int inherit); }
	SYS_POLL           = 252 // { int sys_poll(struct pollfd *fds, u_int nfds, int timeout); }
	SYS_ISSETUGID      = 253 // { int sys_issetugid(void); }
	SYS_LCHOWN         = 254 // { int sys_lchown(const char *path, uid_t uid, gid_t gid); }
	SYS_GETSID         = 255 // { pid_t sys_getsid(pid_t pid); }
	SYS_MSYNC          = 256 // { int sys_msync(void *addr, size_t len, int flags); }
	SYS_PIPE           = 263 // { int sys_pipe(int *fdp); }
	SYS_FHOPEN         = 264 // { int sys_fhopen(const fhandle_t *fhp, int flags); }
	SYS_PREADV         = 267 // { ssize_t sys_preadv(int fd, const struct iovec *iovp, int iovcnt, int pad, off_t offset); }
	SYS_PWRITEV        = 268 // { ssize_t sys_pwritev(int fd, const struct iovec *iovp, int iovcnt, int pad, off_t offset); }
	SYS_KQUEUE         = 269 // { int sys_kqueue(void); }
	SYS_MLOCKALL       = 271 // { int sys_mlockall(int flags); }
	SYS_MUNLOCKALL     = 272 // { int sys_munlockall(void); }
	SYS_GETRESUID      = 281 // { int sys_getresuid(uid_t *ruid, uid_t *euid, uid_t *suid); }
	SYS_SETRESUID      = 282 // { int sys_setresuid(uid_t ruid, uid_t euid, uid_t suid); }
	SYS_GETRESGID      = 283 // { int sys_getresgid(gid_t *rgid, gid_t *egid, gid_t *sgid); }
	SYS_SETRESGID      = 284 // { int sys_setresgid(gid_t rgid, gid_t egid, gid_t sgid); }
	SYS_MQUERY         = 286 // { void *sys_mquery(void *addr, size_t len, int prot, int flags, int fd, long pad, off_t pos); }
	SYS_CLOSEFROM      = 287 // { int sys_closefrom(int fd); }
	SYS_SIGALTSTACK    = 288 // { int sys_sigaltstack(const struct sigaltstack *nss, struct sigaltstack *oss); }
	SYS_SHMGET         = 289 // { int sys_shmget(key_t key, size_t size, int shmflg); }
	SYS_SEMOP          = 290 // { int sys_semop(int semid, struct sembuf *sops, size_t nsops); }
	SYS_FHSTAT         = 294 // { int sys_fhstat(const fhandle_t *fhp, struct stat *sb); }
	SYS___SEMCTL       = 295 // { int sys___semctl(int semid, int semnum, int cmd, union semun *arg); }
	SYS_SHMCTL         = 296 // { int sys_shmctl(int shmid, int cmd, struct shmid_ds *buf); }
	SYS_MSGCTL         = 297 // { int sys_msgctl(int msqid, int cmd, struct msqid_ds *buf); }
	SYS_SCHED_YIELD    = 298 // { int sys_sched_yield(void); }
	SYS_GETTHRID       = 299 // { pid_t sys_getthrid(void); }
	SYS___THRWAKEUP    = 301 // { int sys___thrwakeup(const volatile void *ident, int n); }
	SYS___THREXIT      = 302 // { void sys___threxit(pid_t *notdead); }
	SYS___THRSIGDIVERT = 303 // { int sys___thrsigdivert(sigset_t sigmask, siginfo_t *info, const struct timespec *timeout); }
	SYS___GETCWD       = 304 // { int sys___getcwd(char *buf, size_t len); }
	SYS_ADJFREQ        = 305 // { int sys_adjfreq(const int64_t *freq, int64_t *oldfreq); }
	SYS_SETRTABLE      = 310 // { int sys_setrtable(int rtableid); }
	SYS_GETRTABLE      = 311 // { int sys_getrtable(void); }
	SYS_FACCESSAT      = 313 // { int sys_faccessat(int fd, const char *path, int amode, int flag); }
	SYS_FCHMODAT       = 314 // { int sys_fchmodat(int fd, const char *path, mode_t mode, int flag); }
	SYS_FCHOWNAT       = 315 // { int sys_fchownat(int fd, const char *path, uid_t uid, gid_t gid, int flag); }
	SYS_LINKAT         = 317 // { int sys_linkat(int fd1, const char *path1, int fd2, const char *path2, int flag); }
	SYS_MKDIRAT        = 318 // { int sys_mkdirat(int fd, const char *path, mode_t mode); }
	SYS_MKFIFOAT       = 319 // { int sys_mkfifoat(int fd, const char *path, mode_t mode); }
	SYS_MKNODAT        = 320 // { int sys_mknodat(int fd, const char *path, mode_t mode, dev_t dev); }
	SYS_OPENAT         = 321 // { int sys_openat(int fd, const char *path, int flags, ... mode_t mode); }
	SYS_READLINKAT     = 322 // { ssize_t sys_readlinkat(int fd, const char *path, char *buf, size_t count); }
	SYS_RENAMEAT       = 323 // { int sys_renameat(int fromfd, const char *from, int tofd, const char *to); }
	SYS_SYMLINKAT      = 324 // { int sys_symlinkat(const char *path, int fd, const char *link); }
	SYS_UNLINKAT       = 325 // { int sys_unlinkat(int fd, const char *path, int flag); }
	SYS___SET_TCB      = 329 // { void sys___set_tcb(void *tcb); }
	SYS___GET_TCB      = 330 // { void *sys___get_tcb(void); }
)
```
Response:
Let's break down the thought process to answer the request about `zsyscall_plan9_386.go`.

**1. Understanding the Context:**

The first and most crucial step is to recognize the file's name and the comment at the top:

* **`zsyscall_plan9_386.go`**: This strongly suggests system calls specific to the Plan 9 operating system and the 386 architecture. The `z` prefix often indicates auto-generated code.
* **`// go run mksyscall.go -l32 -plan9 -tags plan9,386 syscall_plan9.go`**: This confirms the auto-generation and reveals the tool used (`mksyscall.go`) and the target OS and architecture (`-plan9 -l32`).
* **`// Code generated by the command above; see README.md. DO NOT EDIT.`**:  Reinforces the auto-generated nature and the warning against manual editing.
* **`//go:build plan9 && 386`**: This is a Go build constraint, confirming the file is only compiled for Plan 9 on 386.

These clues immediately tell us the file is a low-level interface to the Plan 9 kernel. It's not something application developers would typically interact with directly.

**2. Analyzing the Functions:**

Next, examine each function individually:

* **Function Signature:** Look at the name, parameters, and return values. This gives a high-level idea of what each function does. For example, `open(path string, mode int) (fd int, err error)` looks like opening a file.
* **`Syscall` Call:** The core of each function is the `Syscall` (or `Syscall6`) call. The first argument is a constant like `SYS_FD2PATH`, `SYS_PIPE`, etc. This is the key to identifying the underlying Plan 9 system call being invoked.
* **Parameter Handling:** Notice how parameters are converted to `uintptr`. Strings are converted to C-style null-terminated byte pointers using `BytePtrFromString`. Slices are accessed via their first element's address using `unsafe.Pointer`. This is typical when interacting with low-level system interfaces.
* **Error Handling:** The consistent pattern of checking if `r0` (the first return value from `Syscall`) is -1 indicates an error, and the `e1` value is assigned to the `err` return.

**3. Mapping to Go Functionality:**

Based on the function names and the Plan 9 system call constants, we can infer the corresponding higher-level Go functionalities:

* **`fd2path`**: Likely related to getting the path of a file descriptor. This could be used internally by functions that need to know the file's location.
* **`pipe`**: Directly maps to the `os.Pipe` function for creating a pipe.
* **`await`**:  Seems related to waiting for an event. This could be similar to `os.ReadFile` if the "event" is data becoming available.
* **`open`**: Corresponds directly to `os.Open` for opening files.
* **`create`**: Similar to `os.Create` for creating files.
* **`remove`**: Maps to `os.Remove` for deleting files.
* **`stat`**: Corresponds to `os.Stat` for getting file information.
* **`bind`**: This is specific to Plan 9 and involves binding a name in the file system namespace. There isn't a direct equivalent in standard Go.
* **`mount`**: Another Plan 9 specific system call for mounting file systems.
* **`wstat`**:  Likely related to modifying file metadata, similar to `os.Chmod` or `os.Chtimes`.
* **`chdir`**: Maps directly to `os.Chdir` for changing the current directory.
* **`Dup`**: Corresponds to duplicating file descriptors, similar to `os.NewFile(fd, ...)` and its potential uses.
* **`Pread` and `Pwrite`**: These are for reading and writing at specific offsets in a file without changing the file offset, similar to methods on `*os.File`.
* **`Close`**: Maps to `os.File.Close` for closing file descriptors.
* **`Fstat` and `Fwstat`**:  Similar to `stat` and `wstat` but operating on a file descriptor instead of a path.

**4. Providing Go Examples:**

For the common functionalities, provide straightforward examples using the corresponding `os` package functions. This demonstrates how the lower-level syscalls are used in practice.

**5. Command-Line Arguments:**

The comment at the top clearly shows the `go run mksyscall.go` command and its arguments. Explain what each argument does.

**6. Potential Pitfalls:**

Think about common errors when working with system calls or low-level interfaces:

* **Incorrect buffer sizes**:  Functions like `fd2path`, `stat`, and `wstat` rely on providing a buffer. If the buffer is too small, data might be truncated or errors might occur.
* **Incorrect modes/flags**:  `open`, `create`, `bind`, and `mount` take mode or flag arguments. Using incorrect values can lead to unexpected behavior or permission errors.
* **Understanding Plan 9 specifics**:  Functions like `bind` and `mount` have semantics specific to Plan 9 that might not be immediately obvious to developers familiar with other operating systems.

**Self-Correction/Refinement during thought process:**

* **Initial thought:**  Maybe I should explain the `unsafe` package in detail.
* **Correction:**  While `unsafe` is used, the focus should be on the *functionality* of these syscalls. Briefly mentioning its role in low-level operations is sufficient.
* **Initial thought:**  Should I provide very complex examples?
* **Correction:**  Keep the examples simple and focused on demonstrating the core functionality. Complex examples might obscure the main point.
* **Initial thought:**  Should I try to explain the exact structure of the `edir` byte slice used in `stat` and `wstat`?
* **Correction:** That level of detail is likely beyond the scope of the request. It's enough to say it's for file metadata. The specific structure is an implementation detail of the Plan 9 kernel.

By following this structured approach, we can effectively analyze the provided code snippet and provide a comprehensive answer that addresses all aspects of the request.
这段代码是 Go 语言标准库中 `golang.org/x/sys/plan9` 包的一部分，它定义了一系列用于在 Plan 9 操作系统上进行系统调用的函数。由于 Go 的跨平台特性，它需要针对不同的操作系统提供不同的底层实现。这个文件专门针对 Plan 9 操作系统运行在 386 架构上的情况。

**核心功能:**

这个文件的核心功能是将 Go 语言的函数调用转换为 Plan 9 操作系统的系统调用。它定义了一些 Go 函数，这些函数内部直接调用了底层的 `Syscall` 或 `Syscall6` 函数，并将 Go 的数据类型转换为系统调用所需的格式。

**具体功能逐一解释:**

1. **`fd2path(fd int, buf []byte) (err error)`:**
   - **功能:** 获取指定文件描述符 `fd` 对应的路径名，并将结果存储到 `buf` 中。
   - **底层系统调用:** `SYS_FD2PATH`
   - **Go 语言功能对应:**  在标准库中没有直接对应的公开函数，但内部可能会被用于实现一些与文件描述符相关的操作，例如获取当前工作目录等。

2. **`pipe(p *[2]int32) (err error)`:**
   - **功能:** 创建一个管道，并将读端和写端的文件描述符存储到 `p` 数组中。
   - **底层系统调用:** `SYS_PIPE`
   - **Go 语言功能对应:** `os.Pipe()`

   ```go
   package main

   import (
       "fmt"
       "os"
   )

   func main() {
       r, w, err := os.Pipe()
       if err != nil {
           fmt.Println("Error creating pipe:", err)
           return
       }
       defer r.Close()
       defer w.Close()

       fmt.Println("Read FD:", r.Fd())
       fmt.Println("Write FD:", w.Fd())
   }
   ```
   **假设输出:**
   ```
   Read FD: 3
   Write FD: 4
   ```

3. **`await(s []byte) (n int, err error)`:**
   - **功能:** 等待一个事件发生，并将事件信息读取到 `s` 中。
   - **底层系统调用:** `SYS_AWAIT`
   - **Go 语言功能对应:** 这在标准 Go 中没有直接对应的公开函数，`await` 是 Plan 9 特有的概念，用于等待来自文件系统或其他进程的事件通知。

4. **`open(path string, mode int) (fd int, err error)`:**
   - **功能:** 打开一个文件，返回文件描述符。`mode` 参数指定打开模式（只读、只写、读写等）。
   - **底层系统调用:** `SYS_OPEN`
   - **Go 语言功能对应:** `os.Open()`, `os.OpenFile()`

   ```go
   package main

   import (
       "fmt"
       "os"
   )

   func main() {
       file, err := os.Open("test.txt")
       if err != nil {
           fmt.Println("Error opening file:", err)
           return
       }
       defer file.Close()

       fmt.Println("File FD:", file.Fd())
   }
   ```
   **假设输入:** 当前目录下存在名为 `test.txt` 的文件。
   **假设输出:**
   ```
   File FD: 3
   ```

5. **`create(path string, mode int, perm uint32) (fd int, err error)`:**
   - **功能:** 创建一个新的文件，返回文件描述符。`mode` 指定打开模式，`perm` 指定文件权限。
   - **底层系统调用:** `SYS_CREATE`
   - **Go 语言功能对应:** `os.Create()`

   ```go
   package main

   import (
       "fmt"
       "os"
   )

   func main() {
       file, err := os.Create("new_file.txt")
       if err != nil {
           fmt.Println("Error creating file:", err)
           return
       }
       defer file.Close()

       fmt.Println("New file created with FD:", file.Fd())
   }
   ```
   **假设输出:**
   ```
   New file created with FD: 3
   ```

6. **`remove(path string) (err error)`:**
   - **功能:** 删除指定路径的文件。
   - **底层系统调用:** `SYS_REMOVE`
   - **Go 语言功能对应:** `os.Remove()`

   ```go
   package main

   import (
       "fmt"
       "os"
   )

   func main() {
       err := os.Remove("old_file.txt")
       if err != nil {
           fmt.Println("Error removing file:", err)
           return
       }
       fmt.Println("File removed successfully.")
   }
   ```
   **假设输入:** 当前目录下存在名为 `old_file.txt` 的文件。
   **假设输出:**
   ```
   File removed successfully.
   ```

7. **`stat(path string, edir []byte) (n int, err error)`:**
   - **功能:** 获取指定路径文件的状态信息，并将结果存储到 `edir` 中。
   - **底层系统调用:** `SYS_STAT`
   - **Go 语言功能对应:** `os.Stat()`

   ```go
   package main

   import (
       "fmt"
       "os"
   )

   func main() {
       fileInfo, err := os.Stat("test.txt")
       if err != nil {
           fmt.Println("Error getting file info:", err)
           return
       }
       fmt.Println("File Name:", fileInfo.Name())
       fmt.Println("File Size:", fileInfo.Size())
       // ... 其他文件信息
   }
   ```
   **假设输入:** 当前目录下存在名为 `test.txt` 的文件。
   **假设输出:** (输出内容取决于文件的具体信息)
   ```
   File Name: test.txt
   File Size: 1234
   ```

8. **`bind(name string, old string, flag int) (err error)`:**
   - **功能:** 将一个新的名字 `name` 绑定到现有的名字 `old` 上。`flag` 参数控制绑定的行为。这是 Plan 9 特有的概念，用于管理命名空间。
   - **底层系统调用:** `SYS_BIND`
   - **Go 语言功能对应:**  在标准 Go 中没有直接对应的公开函数，这是 Plan 9 特有的命名空间操作。

9. **`mount(fd int, afd int, old string, flag int, aname string) (err error)`:**
   - **功能:** 将一个文件系统挂载到指定的挂载点。`fd` 是要挂载的文件系统的文件描述符，`afd` 是认证文件描述符，`old` 是挂载点，`flag` 是挂载标志，`aname` 是认证名称。这也是 Plan 9 特有的文件系统操作。
   - **底层系统调用:** `SYS_MOUNT`
   - **Go 语言功能对应:**  在标准 Go 中没有直接对应的公开函数，这是 Plan 9 特有的文件系统挂载操作。

10. **`wstat(path string, edir []byte) (err error)`:**
    - **功能:** 更新指定路径文件的状态信息。新的状态信息由 `edir` 提供。
    - **底层系统调用:** `SYS_WSTAT`
    - **Go 语言功能对应:** 可能与 `os.Chmod()`, `os.Chtimes()` 等函数的部分功能相关。

11. **`chdir(path string) (err error)`:**
    - **功能:** 改变当前工作目录到指定的路径。
    - **底层系统调用:** `SYS_CHDIR`
    - **Go 语言功能对应:** `os.Chdir()`

    ```go
    package main

    import (
        "fmt"
        "os"
        "path/filepath"
    )

    func main() {
        err := os.Chdir("/tmp")
        if err != nil {
            fmt.Println("Error changing directory:", err)
            return
        }
        wd, _ := os.Getwd()
        fmt.Println("Current working directory:", wd)
    }
    ```
    **假设输出:**
    ```
    Current working directory: /tmp
    ```

12. **`Dup(oldfd int, newfd int) (fd int, err error)`:**
    - **功能:** 复制一个文件描述符。如果 `newfd` 非负，则将 `oldfd` 复制到 `newfd`，否则分配一个新的文件描述符。
    - **底层系统调用:** `SYS_DUP`
    - **Go 语言功能对应:**  `os.File.Fd()` 可以获取文件描述符，可以使用 `syscall.Dup2()` (虽然这里没有直接使用，但概念类似) 或通过 `os.NewFile()` 创建基于现有文件描述符的 `os.File` 对象。

13. **`Pread(fd int, p []byte, offset int64) (n int, err error)`:**
    - **功能:** 从文件描述符 `fd` 指定的位置 `offset` 读取 `len(p)` 个字节到缓冲区 `p` 中，但不改变文件的当前偏移量。
    - **底层系统调用:** `SYS_PREAD`
    - **Go 语言功能对应:**  `io.ReaderAt` 接口的实现，例如 `os.File` 的 `ReadAt()` 方法。

    ```go
    package main

    import (
        "fmt"
        "os"
    )

    func main() {
        file, err := os.Open("test.txt")
        if err != nil {
            fmt.Println("Error opening file:", err)
            return
        }
        defer file.Close()

        buffer := make([]byte, 10)
        n, err := file.ReadAt(buffer, 5) // 从偏移量 5 开始读取 10 个字节
        if err != nil {
            fmt.Println("Error reading:", err)
            return
        }
        fmt.Printf("Read %d bytes: %s\n", n, string(buffer[:n]))
    }
    ```
    **假设输入:** `test.txt` 内容为 "0123456789abcdef"。
    **假设输出:**
    ```
    Read 10 bytes: 56789abcde
    ```

14. **`Pwrite(fd int, p []byte, offset int64) (n int, err error)`:**
    - **功能:** 将缓冲区 `p` 中的数据写入到文件描述符 `fd` 指定的位置 `offset`，但不改变文件的当前偏移量。
    - **底层系统调用:** `SYS_PWRITE`
    - **Go 语言功能对应:** `io.WriterAt` 接口的实现，例如 `os.File` 的 `WriteAt()` 方法。

    ```go
    package main

    import (
        "fmt"
        "os"
    )

    func main() {
        file, err := os.OpenFile("test.txt", os.O_RDWR, 0666)
        if err != nil {
            fmt.Println("Error opening file:", err)
            return
        }
        defer file.Close()

        data := []byte("XYZ")
        n, err := file.WriteAt(data, 2) // 从偏移量 2 开始写入 "XYZ"
        if err != nil {
            fmt.Println("Error writing:", err)
            return
        }
        fmt.Printf("Wrote %d bytes.\n", n)
    }
    ```
    **假设输入:** `test.txt` 原内容为 "012345"。
    **假设输出:**
    ```
    Wrote 3 bytes.
    ```
    **执行后 `test.txt` 的内容可能变为 "01XYZ5" (取决于文件系统和底层实现)。**

15. **`Close(fd int) (err error)`:**
    - **功能:** 关闭一个文件描述符。
    - **底层系统调用:** `SYS_CLOSE`
    - **Go 语言功能对应:** `os.File.Close()`

    ```go
    package main

    import (
        "fmt"
        "os"
    )

    func main() {
        file, err := os.Open("test.txt")
        if err != nil {
            fmt.Println("Error opening file:", err)
            return
        }
        err = file.Close()
        if err != nil {
            fmt.Println("Error closing file:", err)
            return
        }
        fmt.Println("File closed successfully.")
    }
    ```
    **假设输出:**
    ```
    File closed successfully.
    ```

16. **`Fstat(fd int, edir []byte) (n int, err error)`:**
    - **功能:** 获取与文件描述符 `fd` 关联的文件的状态信息，并将结果存储到 `edir` 中。
    - **底层系统调用:** `SYS_FSTAT`
    - **Go 语言功能对应:** `os.File.Stat()`

    ```go
    package main

    import (
        "fmt"
        "os"
    )

    func main() {
        file, err := os.Open("test.txt")
        if err != nil {
            fmt.Println("Error opening file:", err)
            return
        }
        defer file.Close()

        fileInfo, err := file.Stat()
        if err != nil {
            fmt.Println("Error getting file info:", err)
            return
        }
        fmt.Println("File Name:", fileInfo.Name())
        fmt.Println("File Size:", fileInfo.Size())
        // ... 其他文件信息
    }
    ```
    **假设输入:** 当前目录下存在名为 `test.txt` 的文件。
    **假设输出:** (输出内容取决于文件的具体信息)
    ```
    File Name: test.txt
    File Size: 1234
    ```

17. **`Fwstat(fd int, edir []byte) (err error)`:**
    - **功能:** 更新与文件描述符 `fd` 关联的文件的状态信息。新的状态信息由 `edir` 提供。
    - **底层系统调用:** `SYS_FWSTAT`
    - **Go 语言功能对应:**  可能与 `os.File.Chmod()`, `os.File.Chown()`, `os.File.Truncate()` 等函数的部分功能相关。

**代码推理:**

这些函数的核心逻辑是将 Go 的参数转换为系统调用所需的格式，然后调用底层的 `Syscall` 或 `Syscall6` 函数。

* **`unsafe.Pointer`:**  用于获取变量的内存地址，这在进行底层系统调用时是必要的，因为系统调用通常需要直接操作内存地址。
* **`BytePtrFromString`:**  这是一个辅助函数（未在此代码片段中展示，但通常在 `syscall` 包中），用于将 Go 的字符串转换为指向 C 风格字符串（以 null 结尾的字节数组）的指针，因为系统调用通常需要这种类型的字符串。
* **错误处理:**  每个函数都会检查系统调用的返回值 `r0`。在 Plan 9 中，通常 `-1` 表示错误，此时会将 `e1` (系统调用返回的错误信息) 赋值给 Go 的 `error` 返回值。

**命令行参数处理:**

该文件本身是由 `mksyscall.go` 工具生成的，该工具的命令行参数决定了生成哪些系统调用的代码。

```
go run mksyscall.go -l32 -plan9 -tags plan9,386 syscall_plan9.go
```

* **`-l32`:**  指定生成 32 位架构的代码。
* **`-plan9`:** 指定目标操作系统为 Plan 9。
* **`-tags plan9,386`:**  添加构建标签，确保这段代码只在 Plan 9 且 386 架构下编译。
* **`syscall_plan9.go`:**  输入文件，`mksyscall.go` 会读取这个文件中的系统调用定义并生成相应的 Go 代码。

**易犯错的点 (使用者角度):**

由于这些函数是 Go 标准库内部使用的，普通 Go 开发者通常不会直接调用它们。但是，如果有人尝试直接使用 `golang.org/x/sys/plan9` 包进行底层操作，可能会遇到以下易错点：

1. **不正确的缓冲区大小:** 对于像 `fd2path`, `stat`, `fstat` 这样的函数，如果提供的 `buf` 或 `edir` 切片太小，可能无法容纳完整的返回信息，导致数据截断或其他错误。
2. **误解 Plan 9 特有的概念:**  `bind` 和 `mount` 是 Plan 9 特有的系统调用，其语义和用法与其他操作系统可能差异很大，不熟悉 Plan 9 的开发者容易用错。
3. **不正确的模式或标志:**  像 `open`, `create`, `bind`, `mount` 等函数都有 `mode` 或 `flag` 参数，这些参数的具体含义需要查阅 Plan 9 的文档，使用错误的值可能导致意想不到的结果或权限错误。
4. **直接操作内存 (`unsafe`):**  虽然这些函数封装了 `unsafe.Pointer` 的使用，但如果开发者尝试自己使用 `unsafe` 包进行类似操作，很容易出现内存安全问题。

总而言之，这个 `zsyscall_plan9_386.go` 文件是 Go 语言为了支持 Plan 9 操作系统而在底层实现系统调用机制的关键部分。它将 Go 函数调用转换为 Plan 9 内核能够理解的指令。

Prompt: 
```
这是路径为go/src/cmd/vendor/golang.org/x/sys/plan9/zsyscall_plan9_386.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，

"""
// go run mksyscall.go -l32 -plan9 -tags plan9,386 syscall_plan9.go
// Code generated by the command above; see README.md. DO NOT EDIT.

//go:build plan9 && 386

package plan9

import "unsafe"

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fd2path(fd int, buf []byte) (err error) {
	var _p0 unsafe.Pointer
	if len(buf) > 0 {
		_p0 = unsafe.Pointer(&buf[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall(SYS_FD2PATH, uintptr(fd), uintptr(_p0), uintptr(len(buf)))
	if int32(r0) == -1 {
		err = e1
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func pipe(p *[2]int32) (err error) {
	r0, _, e1 := Syscall(SYS_PIPE, uintptr(unsafe.Pointer(p)), 0, 0)
	if int32(r0) == -1 {
		err = e1
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func await(s []byte) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(s) > 0 {
		_p0 = unsafe.Pointer(&s[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall(SYS_AWAIT, uintptr(_p0), uintptr(len(s)), 0)
	n = int(r0)
	if int32(r0) == -1 {
		err = e1
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func open(path string, mode int) (fd int, err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)
	fd = int(r0)
	if int32(r0) == -1 {
		err = e1
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func create(path string, mode int, perm uint32) (fd int, err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	r0, _, e1 := Syscall(SYS_CREATE, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm))
	fd = int(r0)
	if int32(r0) == -1 {
		err = e1
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func remove(path string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	r0, _, e1 := Syscall(SYS_REMOVE, uintptr(unsafe.Pointer(_p0)), 0, 0)
	if int32(r0) == -1 {
		err = e1
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func stat(path string, edir []byte) (n int, err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	var _p1 unsafe.Pointer
	if len(edir) > 0 {
		_p1 = unsafe.Pointer(&edir[0])
	} else {
		_p1 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(edir)))
	n = int(r0)
	if int32(r0) == -1 {
		err = e1
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func bind(name string, old string, flag int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(name)
	if err != nil {
		return
	}
	var _p1 *byte
	_p1, err = BytePtrFromString(old)
	if err != nil {
		return
	}
	r0, _, e1 := Syscall(SYS_BIND, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(flag))
	if int32(r0) == -1 {
		err = e1
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func mount(fd int, afd int, old string, flag int, aname string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(old)
	if err != nil {
		return
	}
	var _p1 *byte
	_p1, err = BytePtrFromString(aname)
	if err != nil {
		return
	}
	r0, _, e1 := Syscall6(SYS_MOUNT, uintptr(fd), uintptr(afd), uintptr(unsafe.Pointer(_p0)), uintptr(flag), uintptr(unsafe.Pointer(_p1)), 0)
	if int32(r0) == -1 {
		err = e1
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func wstat(path string, edir []byte) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	var _p1 unsafe.Pointer
	if len(edir) > 0 {
		_p1 = unsafe.Pointer(&edir[0])
	} else {
		_p1 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall(SYS_WSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(edir)))
	if int32(r0) == -1 {
		err = e1
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func chdir(path string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	r0, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)
	if int32(r0) == -1 {
		err = e1
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Dup(oldfd int, newfd int) (fd int, err error) {
	r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), uintptr(newfd), 0)
	fd = int(r0)
	if int32(r0) == -1 {
		err = e1
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pread(fd int, p []byte, offset int64) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), uintptr(offset>>32), 0)
	n = int(r0)
	if int32(r0) == -1 {
		err = e1
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pwrite(fd int, p []byte, offset int64) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), uintptr(offset>>32), 0)
	n = int(r0)
	if int32(r0) == -1 {
		err = e1
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Close(fd int) (err error) {
	r0, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)
	if int32(r0) == -1 {
		err = e1
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fstat(fd int, edir []byte) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(edir) > 0 {
		_p0 = unsafe.Pointer(&edir[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(_p0), uintptr(len(edir)))
	n = int(r0)
	if int32(r0) == -1 {
		err = e1
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fwstat(fd int, edir []byte) (err error) {
	var _p0 unsafe.Pointer
	if len(edir) > 0 {
		_p0 = unsafe.Pointer(&edir[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall(SYS_FWSTAT, uintptr(fd), uintptr(_p0), uintptr(len(edir)))
	if int32(r0) == -1 {
		err = e1
	}
	return
}

"""



```
Response:
Let's break down the thought process for analyzing this Go code snippet.

**1. Initial Scan and Understanding the Context:**

* **File Path:** `go/src/cmd/vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64le.go`  This immediately tells us several things:
    * It's part of the Go standard library's extended system call interface (`golang.org/x/sys/unix`).
    * It's in a `vendor` directory, implying it's a vendored dependency.
    * The `zsyscall_` prefix and the architecture suffix (`linux_ppc64le`) strongly suggest it's an auto-generated file containing system call wrappers for a specific operating system and architecture (Linux on PowerPC 64-bit Little Endian).
* **`// go run mksyscall.go ...`:**  This comment confirms the auto-generated nature and reveals the tool used to create it (`mksyscall.go`). It also lists the input files (`syscall_linux.go`, etc.). This is a crucial piece of information.
* **`// Code generated by the command above; see README.md. DO NOT EDIT.`:**  Reinforces the auto-generated nature and warns against manual editing.
* **`//go:build linux && ppc64le`:** This build tag ensures the file is only compiled for the specified target.
* **`package unix`:**  The package name confirms its role in the `unix` system call interface.
* **`import ("syscall", "unsafe")`:** These imports are essential for making raw system calls. `syscall` provides the basic infrastructure, and `unsafe` allows for working with raw memory pointers required for system call arguments.

**2. Identifying the Core Functionality:**

* **Repetitive Structure:**  The code consists of many similar function definitions. Each function:
    * Has a comment `// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT`.
    * Has a descriptive function name (e.g., `fanotifyMark`, `Fallocate`, `Tee`).
    * Calls either `Syscall` or `Syscall6`.
    * Maps a symbolic `SYS_*` constant to the first argument of `Syscall/Syscall6`.
    * Performs error handling by checking the return value of the system call.

* **Inferring Function Purpose:**  The function names are highly suggestive of their corresponding system calls (e.g., `Fallocate` likely corresponds to the `fallocate` system call). This is where knowledge of common Unix/Linux system calls becomes valuable.

**3. Understanding `Syscall` and `Syscall6`:**

* **Key Concept:** These are the low-level Go functions for making system calls. `Syscall` takes three arguments, while `Syscall6` takes six, representing the system call number and up to five arguments.
* **Return Values:**  They return three values: `r0`, `r1` (often unused), and `e1` (the error number). The Go code then converts `e1` to a Go `error` using `errnoErr`.

**4. Reconstructing the "Why":**

* **Bridging the Gap:**  Go's type system needs to interact with the lower-level C-style interface of the operating system kernel. This file acts as the bridge. It provides Go functions that wrap the raw system calls, handling argument marshaling (converting Go types to the types expected by the kernel) and error conversion.
* **Architecture and OS Specificity:** The file's name and build tags highlight the need for different system call implementations depending on the operating system and CPU architecture. System call numbers and argument conventions can vary.

**5. Generating Examples and Explanations:**

* **Focus on Representative Functions:** Choose a few functions that illustrate different aspects (file operations, process management, networking).
* **Provide Simple Use Cases:** Create minimal, compilable Go code snippets demonstrating how to use these functions. Include necessary imports.
* **Explain Arguments and Return Values:** Clearly describe what each argument represents and what the function returns.
* **Connect to Higher-Level Go Functionality:** Where possible, link these low-level functions to the higher-level abstractions provided by packages like `os` and `net`.
* **Address Potential Pitfalls:** Think about common mistakes developers might make when using these functions directly (e.g., incorrect handling of pointers, buffer sizes).

**6. Addressing Specific Questions from the Prompt:**

* **Functionality Listing:**  Systematically go through each function and provide a brief description of its purpose based on its name and the corresponding system call.
* **Go Feature Implementation:** Identify the underlying Go features that rely on these system calls (e.g., file I/O, process creation, networking).
* **Code Examples:**  Create the Go code examples as described above.
* **Input/Output (for Code Examples):**  Keep the examples simple and focus on demonstrating the basic functionality. No complex input/output scenarios are necessary for this level of analysis.
* **Command-Line Arguments:** The `mksyscall.go` command is mentioned. Explain its role and the meaning of its arguments.
* **User Mistakes:**  Consider common errors related to direct system call usage.

**Self-Correction/Refinement During the Process:**

* **Initial Thought:** "This looks like a lot of boilerplate code."  **Correction:** Recognize the auto-generated nature and the underlying purpose of mapping system calls.
* **Stuck Point:** "How do I explain the `unsafe.Pointer` part?" **Refinement:** Emphasize that this is necessary for interacting with raw memory as required by the kernel interface, but warn about its potential dangers and suggest using higher-level abstractions when possible.
* **Clarity:**  Ensure the explanations are clear and concise, avoiding overly technical jargon where possible. Focus on the practical implications for Go developers.

By following this structured approach, combining code analysis with knowledge of operating systems and Go's system call mechanisms, it's possible to effectively understand and explain the functionality of this auto-generated system call wrapper file.
这个Go语言源文件 `zsyscall_linux_ppc64le.go` 是 Go 语言标准库中 `syscall` 包的一部分，它专门为 Linux 操作系统在 `ppc64le` (PowerPC 64-bit Little Endian) 架构上提供了系统调用的底层接口。由于它是以 `zsyscall_` 开头，并且有 "Code generated" 的注释，可以判断这是一个由工具自动生成的代码文件，目的是为了方便 Go 程序调用 Linux 内核的系统调用。

**功能列举:**

这个文件定义了一系列 Go 函数，每个函数都对应一个 Linux 系统调用。这些函数的功能涵盖了操作系统的各种核心能力，包括但不限于：

* **文件操作:**
    * `Fallocate`:  预分配文件空间。
    * `Fstat`, `Fstatat`, `Lstat`, `Stat`: 获取文件或目录的状态信息。
    * `Fstatfs`, `Statfs`: 获取文件系统的统计信息。
    * `Ftruncate`, `Truncate`: 截断文件到指定长度。
    * `pread`, `pwrite`: 在指定偏移量读写文件。
    * `Renameat`: 原子地重命名文件或目录。
    * `Seek`: 改变文件偏移量。
    * `sendfile`: 在两个文件描述符之间直接传输数据。
    * `syncFileRange2`: 将文件指定范围的数据同步到磁盘。
    * `Utime`, `utimes`, `futimesat`: 修改文件的访问和修改时间。
* **进程管理和权限:**
    * `Getegid`, `Geteuid`, `Getgid`, `Getuid`: 获取进程的有效/实际 GID/UID。
    * `Ioperm`, `Iopl`: 设置进程的 I/O 端口权限。
    * `Lchown`, `Fchown`: 修改文件或目录的所有者和组。
    * `setfsgid`, `setfsuid`: 设置文件系统 GID/UID。
    * `Getrlimit`: 获取进程的资源限制。
* **网络编程:**
    * `Accept4`: 接受一个连接。
    * `Bind`: 绑定套接字到指定地址。
    * `Connect`: 连接到指定地址的套接字。
    * `Getgroups`, `Setgroups`: 获取/设置进程的附加组 ID。
    * `Getsockopt`, `Setsockopt`: 获取/设置套接字选项。
    * `Socket`, `Socketpair`: 创建套接字。
    * `Getpeername`, `Getsockname`: 获取连接的对端/本地地址。
    * `Recvfrom`, `Sendto`: 在套接字上发送/接收数据。
    * `Recvmsg`, `Sendmsg`: 在套接字上发送/接收消息（支持更复杂的操作）。
    * `Shutdown`: 关闭套接字连接的部分或全部。
    * `Listen`: 监听连接。
* **内存管理:**
    * `Mmap`: 将文件或设备映射到内存。
* **事件通知:**
    * `EpollWait`: 等待 epoll 事件。
    * `fanotifyMark`: 添加、移除或修改 fanotify 监控标记。
* **其他:**
    * `Alarm`: 设置一个闹钟信号。
    * `Pause`: 等待信号。
    * `Select`: 多路复用 I/O。
    * `Tee`: 在两个文件描述符之间复制数据。
    * `Splice`: 在两个文件描述符之间移动数据。
    * `KexecFileLoad`: 从指定的文件加载一个新的内核执行。
    * `Ustat`: 返回文件系统状态信息（已过时）。
    * `Gettimeofday`, `Time`: 获取当前时间。

**Go 语言功能实现推理与代码示例:**

这个文件本身并不直接实现 Go 的高级功能，而是作为 Go 语言与 Linux 内核交互的桥梁。许多 Go 标准库中的功能都是构建在这些系统调用之上的。

例如，Go 的文件 I/O 操作（如 `os.Open`, `os.Read`, `os.Write`）最终会调用这里定义的系统调用函数。

**示例：使用 `Fallocate` 预分配文件空间**

假设我们想预分配一个 1GB 的文件空间：

```go
package main

import (
	"fmt"
	"os"
	"syscall"
)

func main() {
	file, err := os.Create("large_file.dat")
	if err != nil {
		fmt.Println("Error creating file:", err)
		return
	}
	defer file.Close()

	fd := int(file.Fd())
	mode := uint32(0) // 预分配模式，0 表示不影响现有数据
	offset := int64(0)
	length := int64(1024 * 1024 * 1024) // 1GB

	err = syscall.Fallocate(fd, mode, offset, length)
	if err != nil {
		fmt.Println("Error preallocating space:", err)
		return
	}

	fmt.Println("Successfully preallocated 1GB of space for the file.")
}
```

**假设的输入与输出:**

* **输入:** 运行上述 Go 代码。
* **输出:**
    * 如果成功，会在当前目录下创建一个名为 `large_file.dat` 的文件，其物理大小（在支持稀疏文件的文件系统上可能是逻辑大小）为 1GB。终端输出 `Successfully preallocated 1GB of space for the file.`。
    * 如果失败（例如，权限问题、磁盘空间不足），终端会输出相应的错误信息，例如 `Error preallocating space: syscall.ENOSPC` (No space left on device)。

**示例：使用 `EpollWait` 进行 I/O 多路复用**

```go
package main

import (
	"fmt"
	"net"
	"syscall"
	"unsafe"
)

func main() {
	// 创建一个监听 socket
	ln, err := net.Listen("tcp", ":8080")
	if err != nil {
		fmt.Println("Error listening:", err)
		return
	}
	defer ln.Close()

	fd := int(getSocketFD(ln))

	// 创建 epoll 实例
	epfd, err := syscall.EpollCreate1(0)
	if err != nil {
		fmt.Println("Error creating epoll:", err)
		return
	}
	defer syscall.Close(epfd)

	// 将监听 socket 添加到 epoll 监控
	var event syscall.EpollEvent
	event.Events = syscall.EPOLLIN // 监控可读事件
	event.Fd = int32(fd)
	if err := syscall.EpollCtl(epfd, syscall.EPOLL_CTL_ADD, fd, &event); err != nil {
		fmt.Println("Error adding socket to epoll:", err)
		return
	}

	events := make([]syscall.EpollEvent, 10) // 用于接收事件的切片
	fmt.Println("Waiting for connections...")

	for {
		n, err := syscall.EpollWait(epfd, events, -1) // 阻塞等待事件，-1 表示无限等待
		if err != nil {
			fmt.Println("Error in epoll_wait:", err)
			return
		}

		for i := 0; i < n; i++ {
			if events[i].Fd == int32(fd) {
				// 监听 socket 有事件，表示有新的连接
				conn, err := ln.Accept()
				if err != nil {
					fmt.Println("Error accepting connection:", err)
					continue
				}
				fmt.Println("Accepted connection from:", conn.RemoteAddr())
				go handleConnection(conn) // 启动 goroutine 处理连接
			} else {
				// 其他 socket 的事件处理...
				fmt.Println("Event on other FD:", events[i].Fd)
			}
		}
	}
}

// 辅助函数，获取 net.Listener 的文件描述符
func getSocketFD(l net.Listener) uintptr {
	// 反射获取私有字段，仅作演示，生产环境不推荐
	val := reflect.ValueOf(l).Elem()
	f := val.FieldByName("fd")
	netFD := reflect.Indirect(f).FieldByName("pfd").FieldByName("Sysfd")
	return uintptr(netFD.Int())
}

func handleConnection(conn net.Conn) {
	// ... 处理连接的逻辑 ...
	conn.Close()
}
```

**假设的输入与输出:**

* **输入:** 运行上述 Go 代码，并使用另一个终端或工具（如 `telnet` 或浏览器）连接到 `localhost:8080`。
* **输出:**
    * 当程序启动后，终端会输出 `Waiting for connections...`。
    * 当有新的连接建立时，终端会输出类似 `Accepted connection from: 127.0.0.1:xxxxx`。

**命令行参数的具体处理:**

这个文件本身是 Go 源代码，不直接处理命令行参数。但是，它是由 `mksyscall.go` 工具生成的，该工具的命令行参数如下所示：

```
go run mksyscall.go -tags linux,ppc64le syscall_linux.go syscall_linux_ppc64x.go syscall_linux_alarm.go
```

* **`go run mksyscall.go`**:  运行 `mksyscall.go` 这个 Go 程序。
* **`-tags linux,ppc64le`**:  传递给 `mksyscall.go` 的标签，用于指定生成代码的目标操作系统和架构。这会影响生成的代码中的 `//go:build` 行，确保代码只在指定的平台上编译。
* **`syscall_linux.go syscall_linux_ppc64x.go syscall_linux_alarm.go`**:  这些是 `mksyscall.go` 的输入文件。这些文件通常包含了系统调用的定义、结构体定义等信息，`mksyscall.go` 会解析这些文件并生成特定于架构的系统调用包装代码。

**使用者易犯错的点:**

直接使用 `syscall` 包中的函数需要非常小心，因为它直接与操作系统内核交互，容易出错：

1. **不正确的参数类型和大小:**  系统调用对参数的类型、大小和对齐有严格的要求。传递错误的类型或大小可能导致程序崩溃或不可预测的行为。例如，传递一个指向 `int` 的指针，但系统调用期望的是指向 `int64` 的指针。

2. **内存管理错误:**  很多系统调用涉及到指针，需要手动分配和释放内存。如果使用不当（如内存泄漏、野指针），会导致程序错误。

3. **错误处理不当:**  系统调用会返回错误码。必须正确检查并处理这些错误，否则可能会忽略重要的异常情况。

4. **平台依赖性:**  直接使用系统调用会使代码高度依赖于特定的操作系统和架构。在不同的平台上，系统调用号、参数和行为可能不同。

5. **不安全的 `unsafe` 包的使用:**  `syscall` 包中使用了 `unsafe` 包进行类型转换和指针操作。不当使用 `unsafe` 包会破坏 Go 的类型安全性和内存安全。

**示例：错误使用 `unsafe.Pointer`**

```go
package main

import (
	"fmt"
	"syscall"
	"unsafe"
)

func main() {
	var num int32 = 10
	// 错误地将 int32 的指针转换为 *byte，可能导致读取或写入错误
	bytePtr := (*byte)(unsafe.Pointer(&num))

	// 尝试读取 bytePtr 指向的字节
	value := *bytePtr
	fmt.Println("Value:", value) // 行为未定义，可能崩溃或输出错误的值
}
```

在这个例子中，将 `int32` 的指针强制转换为 `*byte` 是不安全的，因为它们的大小不同。操作系统调用可能会期望一个特定大小的内存区域，而这种错误的转换会导致访问越界或其他内存错误。

总而言之，`zsyscall_linux_ppc64le.go` 是 Go 语言与 Linux 内核在 `ppc64le` 架构上进行底层交互的关键部分，它封装了大量的系统调用。虽然提供了强大的能力，但也需要开发者对其工作原理和潜在的风险有深入的理解。通常情况下，建议使用 Go 标准库中更高级别的抽象，而不是直接调用 `syscall` 包中的函数。

### 提示词
```
这是路径为go/src/cmd/vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64le.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
```

### 源代码
```go
// go run mksyscall.go -tags linux,ppc64le syscall_linux.go syscall_linux_ppc64x.go syscall_linux_alarm.go
// Code generated by the command above; see README.md. DO NOT EDIT.

//go:build linux && ppc64le

package unix

import (
	"syscall"
	"unsafe"
)

var _ syscall.Errno

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fanotifyMark(fd int, flags uint, mask uint64, dirFd int, pathname *byte) (err error) {
	_, _, e1 := Syscall6(SYS_FANOTIFY_MARK, uintptr(fd), uintptr(flags), uintptr(mask), uintptr(dirFd), uintptr(unsafe.Pointer(pathname)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fallocate(fd int, mode uint32, off int64, len int64) (err error) {
	_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(len), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Tee(rfd int, wfd int, len int, flags int) (n int64, err error) {
	r0, _, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)
	n = int64(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func EpollWait(epfd int, events []EpollEvent, msec int) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(events) > 0 {
		_p0 = unsafe.Pointer(&events[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec), 0, 0)
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fadvise(fd int, offset int64, length int64, advice int) (err error) {
	_, _, e1 := Syscall6(SYS_FADVISE64, uintptr(fd), uintptr(offset), uintptr(length), uintptr(advice), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fchown(fd int, uid int, gid int) (err error) {
	_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fstat(fd int, stat *Stat_t) (err error) {
	_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall6(SYS_NEWFSTATAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fstatfs(fd int, buf *Statfs_t) (err error) {
	_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(buf)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Ftruncate(fd int, length int64) (err error) {
	_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getegid() (egid int) {
	r0, _ := RawSyscallNoError(SYS_GETEGID, 0, 0, 0)
	egid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Geteuid() (euid int) {
	r0, _ := RawSyscallNoError(SYS_GETEUID, 0, 0, 0)
	euid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getgid() (gid int) {
	r0, _ := RawSyscallNoError(SYS_GETGID, 0, 0, 0)
	gid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getrlimit(resource int, rlim *Rlimit) (err error) {
	_, _, e1 := RawSyscall(SYS_UGETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getuid() (uid int) {
	r0, _ := RawSyscallNoError(SYS_GETUID, 0, 0, 0)
	uid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Ioperm(from int, num int, on int) (err error) {
	_, _, e1 := Syscall(SYS_IOPERM, uintptr(from), uintptr(num), uintptr(on))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Iopl(level int) (err error) {
	_, _, e1 := Syscall(SYS_IOPL, uintptr(level), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Lchown(path string, uid int, gid int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Listen(s int, n int) (err error) {
	_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(n), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Lstat(path string, stat *Stat_t) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pause() (err error) {
	_, _, e1 := Syscall(SYS_PAUSE, 0, 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func pread(fd int, p []byte, offset int64) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func pwrite(fd int, p []byte, offset int64) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(oldpath)
	if err != nil {
		return
	}
	var _p1 *byte
	_p1, err = BytePtrFromString(newpath)
	if err != nil {
		return
	}
	_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Seek(fd int, offset int64, whence int) (off int64, err error) {
	r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))
	off = int64(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) {
	r0, _, e1 := Syscall6(SYS__NEWSELECT, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) {
	r0, _, e1 := Syscall6(SYS_SENDFILE, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)
	written = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func setfsgid(gid int) (prev int, err error) {
	r0, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)
	prev = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func setfsuid(uid int) (prev int, err error) {
	r0, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)
	prev = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Shutdown(fd int, how int) (err error) {
	_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(fd), uintptr(how), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error) {
	r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))
	n = int64(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Stat(path string, stat *Stat_t) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Statfs(path string, buf *Statfs_t) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Truncate(path string, length int64) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Ustat(dev int, ubuf *Ustat_t) (err error) {
	_, _, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) {
	r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)
	fd = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) {
	_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) {
	_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getgroups(n int, list *_Gid_t) (nn int, err error) {
	r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)
	nn = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func setgroups(n int, list *_Gid_t) (err error) {
	_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) {
	_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) {
	_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func socket(domain int, typ int, proto int) (fd int, err error) {
	r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))
	fd = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func socketpair(domain int, typ int, proto int, fd *[2]int32) (err error) {
	_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) {
	_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) {
	_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func sendto(s int, buf []byte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) {
	var _p0 unsafe.Pointer
	if len(buf) > 0 {
		_p0 = unsafe.Pointer(&buf[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func recvmsg(s int, msg *Msghdr, flags int) (n int, err error) {
	r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func sendmsg(s int, msg *Msghdr, flags int) (n int, err error) {
	r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error) {
	r0, _, e1 := Syscall6(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flags), uintptr(fd), uintptr(offset))
	xaddr = uintptr(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func futimesat(dirfd int, path string, times *[2]Timeval) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Gettimeofday(tv *Timeval) (err error) {
	_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Time(t *Time_t) (tt Time_t, err error) {
	r0, _, e1 := RawSyscall(SYS_TIME, uintptr(unsafe.Pointer(t)), 0, 0)
	tt = Time_t(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Utime(path string, buf *Utimbuf) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_UTIME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func utimes(path string, times *[2]Timeval) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func syncFileRange2(fd int, flags int, off int64, n int64) (err error) {
	_, _, e1 := Syscall6(SYS_SYNC_FILE_RANGE2, uintptr(fd), uintptr(flags), uintptr(off), uintptr(n), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func kexecFileLoad(kernelFd int, initrdFd int, cmdlineLen int, cmdline string, flags int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(cmdline)
	if err != nil {
		return
	}
	_, _, e1 := Syscall6(SYS_KEXEC_FILE_LOAD, uintptr(kernelFd), uintptr(initrdFd), uintptr(cmdlineLen), uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Alarm(seconds uint) (remaining uint, err error) {
	r0, _, e1 := Syscall(SYS_ALARM, uintptr(seconds), 0, 0)
	remaining = uint(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}
```
Response:
Let's break down the thought process to analyze the provided Go code snippet.

**1. Initial Scan and Identification of Key Features:**

The first thing I notice is the header:

```go
// go run mksyscall.go -tags linux,sparc64 syscall_linux.go syscall_linux_sparc64.go syscall_linux_alarm.go
// Code generated by the command above; see README.md. DO NOT EDIT.

//go:build linux && sparc64

package unix

import (
	"syscall"
	"unsafe"
)

var _ syscall.Errno
```

This immediately tells me:

* **Generated Code:** This file is automatically generated by `mksyscall.go`. This means the functions are likely thin wrappers around underlying operating system calls.
* **Platform Specific:** The `//go:build linux && sparc64` constraint indicates this code is specifically for Linux on the SPARC64 architecture.
* **System Calls:** The `import "syscall"` strongly suggests this code interacts directly with the Linux kernel via system calls.
* **`unsafe` Package:** The presence of `import "unsafe"` confirms direct memory manipulation, which is typical for low-level system call interfaces.

**2. Examining Individual Functions:**

Next, I start looking at the function definitions. The pattern is very consistent:

```go
func FunctionName( /* parameters */ ) ( /* return values */ ) {
	_, _, e1 := SyscallX(SYS_CONSTANT, /* arguments */)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}
```

or

```go
func FunctionName( /* parameters */ ) ( /* return values */ ) {
	r0, _, e1 := SyscallX(SYS_CONSTANT, /* arguments */)
	// Process return value r0
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}
```

This pattern reveals the core functionality:

* **`Syscall`, `Syscall6`, `RawSyscall`, `RawSyscallNoError`:** These are functions from the `syscall` package used to invoke system calls. The number in `SyscallX` indicates the number of arguments passed to the underlying system call. `RawSyscall` doesn't automatically convert the error code to a Go `error`. `RawSyscallNoError` assumes success and doesn't check the error code.
* **`SYS_CONSTANT`:** This is a constant representing the specific system call number being invoked (e.g., `SYS_FANOTIFY_MARK`).
* **Error Handling:** The `if e1 != 0 { err = errnoErr(e1) }` block converts the raw error code returned by the system call into a Go `error`.
* **Return Values:**  The system call's primary return value (often an integer file descriptor or status) is captured in `r0`, and the error code is in `e1`.

**3. Categorizing Functionality (High-Level):**

Based on the system call names and typical operating system concepts, I can categorize the functions:

* **File System Operations:** `Fallocate`, `Fstat`, `Fstatat`, `Fstatfs`, `Ftruncate`, `Lstat`, `Stat`, `Statfs`, `Truncate`, `SyncFileRange`, `Renameat`, `futimesat`, `Utime`, `utimes`. These deal with manipulating files and directories.
* **Process/User Information:** `Getegid`, `Geteuid`, `Getgid`, `Getrlimit`, `Getuid`, `Lchown`, `Fchown`, `setfsgid`, `setfsuid`, `getgroups`, `setgroups`. These are related to process and user identity and limits.
* **Inter-Process Communication (IPC) and Sockets:** `Tee`, `EpollWait`, `Select`, `sendfile`, `Splice`, `accept4`, `bind`, `connect`, `getsockopt`, `setsockopt`, `socket`, `socketpair`, `getpeername`, `getsockname`, `recvfrom`, `sendto`, `recvmsg`, `sendmsg`, `Shutdown`, `Listen`. These functions facilitate communication between processes, particularly network communication.
* **Memory Management:** `mmap`. This is for mapping files or devices into memory.
* **System Control:** `Pause`, `Alarm`. These are for controlling process execution and setting timers.
* **Direct Memory Access:** `pread`, `pwrite`. These allow reading and writing to files at specific offsets without changing the file pointer.
* **File System Monitoring:** `fanotifyMark`. This is for receiving notifications about file system events.

**4. Inferring Go Functionality and Providing Examples:**

Now, I can connect these low-level functions to higher-level Go functionalities. For example:

* **`Fstat`:**  This directly relates to `os.Stat()` and `os.FileInfo`.
* **`open`, `read`, `write` (not in this snippet, but implied):** These are the basis for `os.Open()`, `io.Reader`, and `io.Writer`.
* **Socket functions:** These are used by the `net` package for network operations.
* **`mmap`:**  While not directly exposed in the standard library, it's a fundamental building block for memory-mapped files.

To illustrate, I create simple Go examples demonstrating the usage (as shown in the provided good answer). For functions involving file paths, I consider different scenarios and the need for error handling.

**5. Command-Line Arguments and Error Handling (Specific to the Snippet):**

The first line of the code is crucial:

```go
// go run mksyscall.go -tags linux,sparc64 syscall_linux.go syscall_linux_sparc64.go syscall_linux_alarm.go
```

This is the command used to *generate* this file. I analyze the arguments:

* `go run mksyscall.go`: This executes the `mksyscall.go` program.
* `-tags linux,sparc64`:  This is a Go build tag, indicating that the generated code should only be included when building for Linux on SPARC64.
* `syscall_linux.go`, `syscall_linux_sparc64.go`, `syscall_linux_alarm.go`: These are likely input files for `mksyscall.go`, containing definitions or specifications used to generate the system call wrappers.

I realize that end-users of the *generated* code don't directly use these arguments. The arguments are for the *developers* of the `unix` package.

Regarding error handling, I focus on the consistent `errnoErr` pattern and emphasize that the functions return `error` values, which users should always check.

**6. Identifying Potential Pitfalls:**

I consider common mistakes when working with low-level system calls:

* **Incorrect Usage of File Descriptors:** Passing invalid or closed file descriptors.
* **Buffer Management:**  Incorrectly sizing or handling buffers passed to system calls. The `unsafe.Pointer` usage highlights the need for careful memory management.
* **Error Neglect:**  Failing to check the returned `error` values.
* **Platform Dependence:**  Assuming the code will work on other operating systems or architectures.
* **Understanding System Call Semantics:** Misinterpreting the exact behavior and parameters of the underlying system calls.

**7. Structuring the Answer:**

Finally, I organize the information into a clear and structured answer, covering:

* Overall Functionality
* Explanation of Key Functions (with examples)
* Command-Line Argument Explanation (emphasizing it's for code generation)
* Common Mistakes

This systematic approach allows me to thoroughly analyze the code snippet and provide a comprehensive explanation.
这个Go语言文件 `zsyscall_linux_sparc64.go` 是 `golang.org/x/sys/unix` 包的一部分，它为 Linux 系统在 SPARC64 架构上提供了系统调用的底层接口。

**功能列举:**

该文件定义了一系列 Go 函数，这些函数是对 Linux 内核系统调用的直接封装。每个函数都对应一个或多个 Linux 系统调用，并负责将 Go 的数据类型转换为系统调用所需的格式，然后调用底层的系统调用，并将系统调用的返回值和错误码转换为 Go 的返回值和 `error` 类型。

具体来说，从代码中我们可以看到它实现了以下系统调用（以及可能相关的辅助函数）：

* **文件系统操作:**
    * `fanotifyMark`: 用于向 fanotify 文件事件通知系统添加或删除监听标记。
    * `Fallocate`:  用于为一个打开的文件预分配磁盘空间。
    * `Fadvise`:  用于向内核提供关于文件访问模式的建议，以优化 I/O 操作。
    * `Fchown`:  修改一个打开文件的所有者和组。
    * `Fstat`:  获取一个打开文件的状态信息。
    * `Fstatat`:  获取相对于目录文件描述符的文件的状态信息。
    * `Fstatfs`: 获取一个文件系统的统计信息。
    * `Ftruncate`:  将一个打开的文件截断为指定长度。
    * `Lchown`:  类似于 `chown`，但不跟随符号链接。
    * `Lstat`:  类似于 `stat`，但不跟随符号链接。
    * `Stat`:  获取一个路径指向的文件的状态信息。
    * `Statfs`: 获取一个路径指向的文件系统的统计信息。
    * `Truncate`: 将一个路径指向的文件截断为指定长度。
    * `Renameat`: 原子地重命名一个相对于目录文件描述符的文件。
    * `SyncFileRange`: 将文件指定范围的数据同步到磁盘。
    * `Futimesat`: 修改相对于目录文件描述符的文件的访问和修改时间。
    * `Utime`: 修改文件的访问和修改时间。
    * `Utimes`: 修改文件的访问和修改时间，精度更高。
* **进程/用户相关:**
    * `Getegid`: 获取有效组 ID。
    * `Geteuid`: 获取有效用户 ID。
    * `Getgid`: 获取组 ID。
    * `Getrlimit`: 获取进程资源限制。
    * `Getuid`: 获取用户 ID。
    * `setfsgid`: 设置文件系统 GID。
    * `setfsuid`: 设置文件系统 UID。
    * `getgroups`: 获取当前进程所属的所有组的 ID。
    * `setgroups`: 设置当前进程的附属组 ID 列表。
* **进程间通信 (IPC) 和网络:**
    * `Tee`: 在两个文件描述符之间复制数据，不修改原始数据流。
    * `EpollWait`: 等待 epoll 实例上的事件。
    * `Select`:  等待多个文件描述符上的事件。
    * `sendfile`:  在两个文件描述符之间高效地复制数据。
    * `Splice`:  在两个文件描述符之间移动数据，零拷贝。
    * `Listen`:  监听一个 socket 连接。
    * `Shutdown`: 关闭 socket 连接的一部分或全部。
    * `accept4`: 接受一个 socket 连接，并可以设置 flags。
    * `bind`:  将一个地址绑定到一个 socket。
    * `connect`:  连接到一个 socket 地址。
    * `getsockopt`: 获取 socket 选项的值。
    * `setsockopt`: 设置 socket 选项的值。
    * `socket`:  创建一个 socket。
    * `socketpair`: 创建一对已连接的无名 socket。
    * `getpeername`: 获取连接到 socket 的对端的地址。
    * `getsockname`: 获取 socket 自身的地址。
    * `recvfrom`: 从一个 socket 接收数据，并获取发送方的地址。
    * `sendto`:  向一个指定的 socket 地址发送数据。
    * `recvmsg`: 从一个 socket 接收消息。
    * `sendmsg`: 向一个 socket 发送消息。
* **内存管理:**
    * `mmap`: 将文件或设备映射到内存。
* **系统控制:**
    * `Pause`:  暂停进程执行直到收到信号。
    * `Alarm`: 设置一个定时器，在指定秒数后发送 SIGALRM 信号。

**Go 语言功能实现推理和代码示例:**

这个文件是 `syscall` 包的底层实现，它使得 Go 程序能够直接调用 Linux 内核的系统调用。 这些函数通常被 Go 标准库中的更高级别的抽象（例如 `os` 包、`io` 包、`net` 包）所使用。

例如，`Fstat` 函数实现了获取文件状态的功能。在 Go 的 `os` 包中，`os.Stat()` 函数最终会调用到这里的 `Fstat`（或者类似的函数，取决于平台和架构）。

```go
package main

import (
	"fmt"
	"os"
	"syscall"
)

func main() {
	fileInfo, err := os.Stat("example.txt")
	if err != nil {
		fmt.Println("Error:", err)
		return
	}

	// fileInfo 包含了文件的各种元数据，例如大小、修改时间等
	fmt.Println("File Size:", fileInfo.Size())
	fmt.Println("Modification Time:", fileInfo.ModTime())

	// 你也可以直接使用 syscall 包中的 Fstat 函数，但这通常不是推荐的做法
	// 因为 os 包提供了更方便和跨平台的 API。
	fd, err := syscall.Open("example.txt", syscall.O_RDONLY, 0)
	if err != nil {
		fmt.Println("Error opening file:", err)
		return
	}
	defer syscall.Close(fd)

	var stat syscall.Stat_t
	err = syscall.Fstat(fd, &stat)
	if err != nil {
		fmt.Println("Error getting file status:", err)
		return
	}

	fmt.Printf("Inode: %d\n", stat.Ino) // 获取 inode 号
}
```

**假设的输入与输出:**

假设 `example.txt` 文件存在，并且大小为 1024 字节，最后修改时间是 2023年10月27日 10:00:00。

**`os.Stat("example.txt")` 的输出 (抽象层):**

```
File Size: 1024
Modification Time: 2023-10-27 10:00:00 +0000 UTC
```

**`syscall.Fstat(fd, &stat)` 的输出 (底层):**

```
Inode: <文件在文件系统中的 inode 号>
```

`syscall.Fstat` 返回的 `stat` 结构体包含更底层的详细信息，例如文件类型、权限、所有者 ID、组 ID、设备 ID、inode 号、硬链接数、大小、访问时间、修改时间、状态改变时间、块大小和分配的块数等。

**命令行参数的具体处理:**

这个文件本身不是一个可执行的程序，而是一个库文件。它的生成是通过 `go run mksyscall.go` 命令完成的。

```
go run mksyscall.go -tags linux,sparc64 syscall_linux.go syscall_linux_sparc64.go syscall_linux_alarm.go
```

* `go run mksyscall.go`:  执行 `mksyscall.go` 这个 Go 程序。
* `-tags linux,sparc64`:  这是一个 Go 编译标签，用于指定生成的代码只在 `linux` 和 `sparc64` 平台上编译。
* `syscall_linux.go`, `syscall_linux_sparc64.go`, `syscall_linux_alarm.go`: 这些是 `mksyscall.go` 程序的输入文件，它们包含了系统调用的定义和其他信息，用于生成 `zsyscall_linux_sparc64.go` 文件。

`mksyscall.go` 工具会读取这些输入文件，解析其中的定义，然后生成与特定操作系统和架构相关的系统调用封装代码。

**使用者易犯错的点:**

直接使用 `syscall` 包中的函数（例如 `syscall.Fstat`）而不是使用更高级别的抽象（例如 `os.Stat`）可能会导致以下问题：

1. **平台兼容性问题:**  `syscall` 包的函数是与操作系统和架构紧密相关的。直接使用这些函数会使你的代码难以移植到其他平台。
2. **错误处理的复杂性:**  `syscall` 函数返回的是底层的错误码。你需要自己将其转换为更易于理解的错误类型。高级别的包通常会处理这些细节。
3. **API 的不稳定性:**  底层的系统调用 API 可能会在不同的内核版本之间发生变化。高级别的包通常会提供更稳定的 API。
4. **代码可读性和维护性:**  直接使用 `syscall` 会使代码更底层，更难理解和维护。

**示例说明易犯错的点:**

假设你想获取一个文件的 inode 号。直接使用 `syscall` 包的方式如下：

```go
package main

import (
	"fmt"
	"syscall"
)

func main() {
	fd, err := syscall.Open("example.txt", syscall.O_RDONLY, 0)
	if err != nil {
		fmt.Println("Error opening file:", err)
		return
	}
	defer syscall.Close(fd)

	var stat syscall.Stat_t
	err = syscall.Fstat(fd, &stat)
	if err != nil {
		fmt.Println("Error getting file status:", err)
		return
	}

	fmt.Println("Inode:", stat.Ino)
}
```

虽然这段代码可以工作，但如果需要在其他平台上获取文件的唯一标识符，这段代码就不能直接使用。

使用 `os` 包的更安全和可移植的方式是：

```go
package main

import (
	"fmt"
	"os"
	"syscall"
)

func main() {
	fileInfo, err := os.Stat("example.txt")
	if err != nil {
		fmt.Println("Error:", err)
		return
	}

	stat_t, ok := fileInfo.Sys().(*syscall.Stat_t)
	if !ok {
		fmt.Println("Error: not a syscall.Stat_t")
		return
	}

	fmt.Println("Inode:", stat_t.Ino)
}
```

虽然这里仍然需要类型断言到 `syscall.Stat_t`，但 `os.Stat` 函数本身是跨平台的，并且提供了更丰富的错误处理和文件信息抽象。在大多数情况下，推荐使用 `os`、`io`、`net` 等高级别的包，而不是直接操作 `syscall` 包。只有在需要进行非常底层的操作，或者访问高级别包没有提供的特定系统调用功能时，才应该直接使用 `syscall` 包。

### 提示词
```
这是路径为go/src/cmd/vendor/golang.org/x/sys/unix/zsyscall_linux_sparc64.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
```

### 源代码
```go
// go run mksyscall.go -tags linux,sparc64 syscall_linux.go syscall_linux_sparc64.go syscall_linux_alarm.go
// Code generated by the command above; see README.md. DO NOT EDIT.

//go:build linux && sparc64

package unix

import (
	"syscall"
	"unsafe"
)

var _ syscall.Errno

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fanotifyMark(fd int, flags uint, mask uint64, dirFd int, pathname *byte) (err error) {
	_, _, e1 := Syscall6(SYS_FANOTIFY_MARK, uintptr(fd), uintptr(flags), uintptr(mask), uintptr(dirFd), uintptr(unsafe.Pointer(pathname)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fallocate(fd int, mode uint32, off int64, len int64) (err error) {
	_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(len), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Tee(rfd int, wfd int, len int, flags int) (n int64, err error) {
	r0, _, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)
	n = int64(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func EpollWait(epfd int, events []EpollEvent, msec int) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(events) > 0 {
		_p0 = unsafe.Pointer(&events[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec), 0, 0)
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fadvise(fd int, offset int64, length int64, advice int) (err error) {
	_, _, e1 := Syscall6(SYS_FADVISE64, uintptr(fd), uintptr(offset), uintptr(length), uintptr(advice), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fchown(fd int, uid int, gid int) (err error) {
	_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fstat(fd int, stat *Stat_t) (err error) {
	_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall6(SYS_FSTATAT64, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fstatfs(fd int, buf *Statfs_t) (err error) {
	_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(buf)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Ftruncate(fd int, length int64) (err error) {
	_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getegid() (egid int) {
	r0, _ := RawSyscallNoError(SYS_GETEGID, 0, 0, 0)
	egid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Geteuid() (euid int) {
	r0, _ := RawSyscallNoError(SYS_GETEUID, 0, 0, 0)
	euid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getgid() (gid int) {
	r0, _ := RawSyscallNoError(SYS_GETGID, 0, 0, 0)
	gid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getrlimit(resource int, rlim *Rlimit) (err error) {
	_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getuid() (uid int) {
	r0, _ := RawSyscallNoError(SYS_GETUID, 0, 0, 0)
	uid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Lchown(path string, uid int, gid int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Listen(s int, n int) (err error) {
	_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(n), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Lstat(path string, stat *Stat_t) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pause() (err error) {
	_, _, e1 := Syscall(SYS_PAUSE, 0, 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func pread(fd int, p []byte, offset int64) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func pwrite(fd int, p []byte, offset int64) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(oldpath)
	if err != nil {
		return
	}
	var _p1 *byte
	_p1, err = BytePtrFromString(newpath)
	if err != nil {
		return
	}
	_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Seek(fd int, offset int64, whence int) (off int64, err error) {
	r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))
	off = int64(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) {
	r0, _, e1 := Syscall6(SYS_SELECT, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) {
	r0, _, e1 := Syscall6(SYS_SENDFILE, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)
	written = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func setfsgid(gid int) (prev int, err error) {
	r0, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)
	prev = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func setfsuid(uid int) (prev int, err error) {
	r0, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)
	prev = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Shutdown(fd int, how int) (err error) {
	_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(fd), uintptr(how), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error) {
	r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))
	n = int64(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Stat(path string, stat *Stat_t) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Statfs(path string, buf *Statfs_t) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func SyncFileRange(fd int, off int64, n int64, flags int) (err error) {
	_, _, e1 := Syscall6(SYS_SYNC_FILE_RANGE, uintptr(fd), uintptr(off), uintptr(n), uintptr(flags), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Truncate(path string, length int64) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) {
	r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)
	fd = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) {
	_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) {
	_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getgroups(n int, list *_Gid_t) (nn int, err error) {
	r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)
	nn = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func setgroups(n int, list *_Gid_t) (err error) {
	_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) {
	_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) {
	_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func socket(domain int, typ int, proto int) (fd int, err error) {
	r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))
	fd = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func socketpair(domain int, typ int, proto int, fd *[2]int32) (err error) {
	_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) {
	_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) {
	_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func sendto(s int, buf []byte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) {
	var _p0 unsafe.Pointer
	if len(buf) > 0 {
		_p0 = unsafe.Pointer(&buf[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func recvmsg(s int, msg *Msghdr, flags int) (n int, err error) {
	r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func sendmsg(s int, msg *Msghdr, flags int) (n int, err error) {
	r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error) {
	r0, _, e1 := Syscall6(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flags), uintptr(fd), uintptr(offset))
	xaddr = uintptr(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func futimesat(dirfd int, path string, times *[2]Timeval) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Gettimeofday(tv *Timeval) (err error) {
	_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Utime(path string, buf *Utimbuf) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_UTIME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func utimes(path string, times *[2]Timeval) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Alarm(seconds uint) (remaining uint, err error) {
	r0, _, e1 := Syscall(SYS_ALARM, uintptr(seconds), 0, 0)
	remaining = uint(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}
```
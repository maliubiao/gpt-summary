Response:
My thinking process to answer the request goes like this:

1. **Understand the Goal:** The user wants to understand the purpose and functionality of the provided Go code snippet, specifically the `ztypes_linux_amd64.go` file within the `golang.org/x/sys/unix` package. They are asking for a high-level explanation, examples, and potential pitfalls.

2. **Initial Analysis of the Code:** I first scanned the code for keywords and patterns:
    * **`// cgo -godefs ...`:** This immediately tells me that this file is auto-generated using `cgo` based on C definitions. This is crucial. It means the structures and constants defined here are Go representations of corresponding C structures and constants from the Linux kernel.
    * **`// Code generated by the command above; see README.md. DO NOT EDIT.`:**  Reinforces the auto-generated nature and emphasizes that manual editing is discouraged.
    * **`//go:build amd64 && linux`:** This build tag specifies that this file is only compiled for the `amd64` architecture on `linux` systems. This confirms its platform-specific nature.
    * **`package unix`:**  Indicates this code belongs to the `unix` package, which provides low-level system calls and data structures for Unix-like operating systems.
    * **`const` and `type` declarations:**  The file primarily defines constants (like `SizeofPtr`, `FADV_DONTNEED`) and Go structs (like `Timespec`, `Stat_t`, `SockaddrStorage`). These likely correspond to C macros and structures.
    * **Naming Conventions:** The struct names like `Timespec`, `Timeval`, `Stat_t` are very common in Unix/Linux system programming, further suggesting their origin in C system headers.

3. **Deduce the Primary Function:** Based on the `cgo -godefs` comment and the structure definitions, I concluded that the main purpose of this file is to provide **Go-compatible data structures and constants that mirror those used in the Linux kernel's system call interface.**  This allows Go programs to interact with the operating system at a low level.

4. **Identify Key Go Features:** The file uses:
    * **Constants:** To represent integer values defined in the C world.
    * **Structs:** To represent C structures. Note the use of `int64`, `uint64`, `int32`, `uint32`, etc., to align with C data types and handle potential differences in integer sizes across architectures.
    * **Build Tags:**  To ensure the file is only compiled for the correct platform.
    * **The `unix` package:** This package is the context for these definitions.

5. **Construct Example Usage Scenarios:**  I thought about how these structures and constants are used in practice:
    * **File system operations:**  `Stat_t` is used with system calls like `stat()` to get file metadata.
    * **Time management:** `Timespec` and `Timeval` are used for representing time in various system calls.
    * **Networking:**  `SockaddrStorage` and related structures are essential for working with sockets.
    * **Process management:** `Rusage` provides resource usage information.
    * **Memory management:** Constants like `FADV_DONTNEED` are used for advising the kernel about memory usage.

6. **Develop Go Code Examples:** For each scenario, I created simple Go code snippets demonstrating how to use the defined types and constants with functions from the `syscall` or `golang.org/x/sys/unix` packages. I included:
    * **Import statements:**  Showing necessary packages.
    * **Variable declarations:**  Using the defined structs.
    * **Function calls:**  Demonstrating interaction with system calls (even if the actual system call isn't fully implemented in the example for brevity).
    * **Output:**  Showing how the data might be accessed.
    * **Assumptions:**  Clearly stating any assumptions made about input values.

7. **Address Potential Pitfalls:** I considered common errors when working with low-level system calls and C-like structures in Go:
    * **Incorrect data type sizes:** While `cgo -godefs` helps, understanding the underlying C types is still important. I highlighted the `SizeofPtr` and `SizeofLong` constants.
    * **Endianness issues:**  While not directly exposed in *this* file, it's a general concern when dealing with binary data structures.
    * **Platform dependency:**  Emphasized the `//go:build` tag and the platform-specific nature of the file.
    * **Manual modification:**  Reiterated the warning against editing the generated file.

8. **Explain the `cgo` Command:**  I detailed the purpose of the `cgo -godefs` command and its role in generating the Go code from C definitions. I broke down the command arguments.

9. **Structure the Answer:** I organized the information logically with clear headings: Functionality, Go Feature Implementation, Code Examples, Command-Line Arguments, and Potential Pitfalls.

10. **Review and Refine:** I reread the generated answer to ensure clarity, accuracy, and completeness, checking if it addressed all aspects of the user's request. I made sure the code examples were easy to understand and the explanations were concise. For example, I initially just listed the structs, but realized explaining *why* they are there (representing C structs) was crucial. Similarly, explaining the `cgo` command was important context.
`go/src/cmd/vendor/golang.org/x/sys/unix/ztypes_linux_amd64.go` 这个文件是 `golang.org/x/sys/unix` 包的一部分，专门为 `linux` 操作系统且运行在 `amd64` 架构上的 Go 程序提供与底层操作系统交互所需的数据结构和常量定义。

**功能列举:**

1. **定义了与 Linux 系统调用相关的 C 数据结构的 Go 版本:** 文件中定义了许多结构体（`struct`），例如 `Timespec`, `Timeval`, `Stat_t`, `Dirent`, `SockaddrStorage` 等。这些结构体对应着 Linux 内核中定义的 C 结构体，用于在 Go 程序中与系统调用进行数据交换。
2. **定义了与 Linux 系统调用相关的常量:** 文件中定义了一些常量（`const`），例如 `SizeofPtr`, `SizeofLong`, `FADV_DONTNEED`, `POLLRDHUP`, `SIG_BLOCK` 等。这些常量对应着 Linux 内核中定义的宏或者常量，用于指定系统调用的参数或返回值。
3. **提供平台特定的类型定义:**  例如 `_C_long` 被定义为 `int64`，这是在 `amd64` 架构的 Linux 系统上 `long` 类型通常的大小。这种定义确保了 Go 代码能够正确地与底层的 C 代码进行交互。
4. **为 `golang.org/x/sys/unix` 包提供构建块:**  这个文件本身并不包含具体的业务逻辑或者系统调用实现，而是作为基础数据类型定义，供 `golang.org/x/sys/unix` 包中的其他 Go 代码使用，以便进行实际的系统调用。

**Go 语言功能实现推理与代码示例:**

这个文件本身是 Go 语言中 **与 C 代码互操作性 (C Interoperability)** 的一个体现，特别是通过 `cgo` 工具来生成 Go 代码。 `cgo` 允许 Go 程序调用 C 代码，反之亦然。 在这里，`cgo -godefs` 命令被用来根据 C 的头文件生成 Go 的类型定义。

这个文件定义的数据结构主要用于以下 Go 语言功能：

* **文件操作:** `Stat_t` 用于获取文件元信息，例如大小、权限、修改时间等。
* **时间管理:** `Timespec` 和 `Timeval` 用于表示时间，常用于与时间相关的系统调用。
* **进程管理:** `Rusage` 用于获取进程的资源使用情况。
* **网络编程:** `SockaddrStorage` 以及相关的 `RawSockaddr` 等结构体用于表示网络地址。
* **设备交互:**  `HDGeometry` 用于磁盘几何信息。
* **信号处理:** `Sigset_t` 和 `Siginfo` 用于处理信号。
* **I/O 多路复用:** `EpollEvent` 用于 `epoll` 系统调用。

**Go 代码举例说明 (假设输入与输出):**

假设我们要获取一个文件的信息，可以使用 `Stat_t` 结构体：

```go
package main

import (
	"fmt"
	"os"
	"syscall"
)

func main() {
	filename := "test.txt" // 假设存在一个名为 test.txt 的文件

	var stat syscall.Stat_t
	err := syscall.Stat(filename, &stat)
	if err != nil {
		fmt.Println("Error getting file info:", err)
		return
	}

	fmt.Println("File Size:", stat.Size)
	fmt.Println("File Mode:", os.FileMode(stat.Mode)) // 将 uint32 转换为 os.FileMode
	fmt.Println("Last Modification Time:", stat.Mtim)
}
```

**假设输入:**  当前目录下存在一个名为 `test.txt` 的文件。

**可能的输出:**

```
File Size: 1024
File Mode: -rw-r--r--
Last Modification Time: {1678886400 0}
```

在这个例子中，`syscall.Stat` 函数使用到了 `Stat_t` 结构体来存储从系统调用返回的文件信息。`ztypes_linux_amd64.go` 文件中定义的 `Stat_t` 结构体保证了 Go 代码能够正确地解释来自 Linux 内核的数据。

**命令行参数的具体处理:**

这个文件本身不涉及命令行参数的处理。它只是定义了数据结构和常量。 命令行参数的处理通常发生在程序的 `main` 函数中，并可能使用到 `flag` 包或者直接解析 `os.Args`。

**使用者易犯错的点:**

1. **直接修改结构体字段:**  这些结构体通常是用于与系统调用进行数据交换的，直接修改某些字段可能不会有预期的效果，或者会导致程序崩溃，因为这些结构体的内存布局需要与内核的期望一致。例如，在调用系统调用前，需要按照系统调用的要求正确填充结构体的字段。

   ```go
   package main

   import (
       "fmt"
       "syscall"
   )

   func main() {
       var time syscall.Timespec
       time.Sec = 10 // 尝试直接设置时间 (这通常不是正确设置时间的姿势)
       // ... 尝试使用 time 变量进行某些系统调用 ...
       fmt.Println(time)
   }
   ```

   正确的做法通常是使用 `time` 包或者其他辅助函数来创建和操作这些结构体。

2. **不理解结构体字段的含义:** 这些结构体中的字段名往往与底层的 C 结构体保持一致，可能比较晦涩。不理解其含义可能导致使用错误。例如，`Stat_t` 中的 `Mode` 字段包含了文件类型和权限信息，需要通过特定的位运算来解析。

3. **忽略平台差异:** 这个文件是针对 `linux` 和 `amd64` 的。如果在其他操作系统或架构上运行相同的代码，可能需要使用不同的 `ztypes_*.go` 文件，或者代码需要进行适配。

4. **假设结构体的大小和内存布局:** 虽然 Go 语言在特定平台上会保证结构体的内存布局与 C 结构体兼容，但在不同平台或 Go 版本之间，细微的差异仍然可能存在。依赖于特定的内存布局进行操作是不可靠的。

总而言之，`go/src/cmd/vendor/golang.org/x/sys/unix/ztypes_linux_amd64.go` 是 Go 语言与 Linux 系统底层交互的重要组成部分，它通过定义与 C 兼容的数据结构和常量，使得 Go 程序能够调用系统调用并获取操作系统的信息。使用者需要理解这些结构体的含义以及它们在系统调用中的作用，才能正确地使用 `golang.org/x/sys/unix` 包进行底层编程。

### 提示词
```
这是路径为go/src/cmd/vendor/golang.org/x/sys/unix/ztypes_linux_amd64.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
```

### 源代码
```go
// cgo -godefs -objdir=/tmp/amd64/cgo -- -Wall -Werror -static -I/tmp/amd64/include -m64 linux/types.go | go run mkpost.go
// Code generated by the command above; see README.md. DO NOT EDIT.

//go:build amd64 && linux

package unix

const (
	SizeofPtr  = 0x8
	SizeofLong = 0x8
)

type (
	_C_long int64
)

type Timespec struct {
	Sec  int64
	Nsec int64
}

type Timeval struct {
	Sec  int64
	Usec int64
}

type Timex struct {
	Modes     uint32
	Offset    int64
	Freq      int64
	Maxerror  int64
	Esterror  int64
	Status    int32
	Constant  int64
	Precision int64
	Tolerance int64
	Time      Timeval
	Tick      int64
	Ppsfreq   int64
	Jitter    int64
	Shift     int32
	Stabil    int64
	Jitcnt    int64
	Calcnt    int64
	Errcnt    int64
	Stbcnt    int64
	Tai       int32
	_         [44]byte
}

type Time_t int64

type Tms struct {
	Utime  int64
	Stime  int64
	Cutime int64
	Cstime int64
}

type Utimbuf struct {
	Actime  int64
	Modtime int64
}

type Rusage struct {
	Utime    Timeval
	Stime    Timeval
	Maxrss   int64
	Ixrss    int64
	Idrss    int64
	Isrss    int64
	Minflt   int64
	Majflt   int64
	Nswap    int64
	Inblock  int64
	Oublock  int64
	Msgsnd   int64
	Msgrcv   int64
	Nsignals int64
	Nvcsw    int64
	Nivcsw   int64
}

type Stat_t struct {
	Dev     uint64
	Ino     uint64
	Nlink   uint64
	Mode    uint32
	Uid     uint32
	Gid     uint32
	_       int32
	Rdev    uint64
	Size    int64
	Blksize int64
	Blocks  int64
	Atim    Timespec
	Mtim    Timespec
	Ctim    Timespec
	_       [3]int64
}

type Dirent struct {
	Ino    uint64
	Off    int64
	Reclen uint16
	Type   uint8
	Name   [256]int8
	_      [5]byte
}

type Flock_t struct {
	Type   int16
	Whence int16
	Start  int64
	Len    int64
	Pid    int32
	_      [4]byte
}

type DmNameList struct {
	Dev  uint64
	Next uint32
	Name [0]byte
	_    [4]byte
}

const (
	FADV_DONTNEED = 0x4
	FADV_NOREUSE  = 0x5
)

type RawSockaddrNFCLLCP struct {
	Sa_family        uint16
	Dev_idx          uint32
	Target_idx       uint32
	Nfc_protocol     uint32
	Dsap             uint8
	Ssap             uint8
	Service_name     [63]uint8
	Service_name_len uint64
}

type RawSockaddr struct {
	Family uint16
	Data   [14]int8
}

type RawSockaddrAny struct {
	Addr RawSockaddr
	Pad  [96]int8
}

type Iovec struct {
	Base *byte
	Len  uint64
}

type Msghdr struct {
	Name       *byte
	Namelen    uint32
	Iov        *Iovec
	Iovlen     uint64
	Control    *byte
	Controllen uint64
	Flags      int32
	_          [4]byte
}

type Cmsghdr struct {
	Len   uint64
	Level int32
	Type  int32
}

type ifreq struct {
	Ifrn [16]byte
	Ifru [24]byte
}

const (
	SizeofSockaddrNFCLLCP = 0x60
	SizeofIovec           = 0x10
	SizeofMsghdr          = 0x38
	SizeofCmsghdr         = 0x10
)

const (
	SizeofSockFprog = 0x10
)

type PtraceRegs struct {
	R15      uint64
	R14      uint64
	R13      uint64
	R12      uint64
	Rbp      uint64
	Rbx      uint64
	R11      uint64
	R10      uint64
	R9       uint64
	R8       uint64
	Rax      uint64
	Rcx      uint64
	Rdx      uint64
	Rsi      uint64
	Rdi      uint64
	Orig_rax uint64
	Rip      uint64
	Cs       uint64
	Eflags   uint64
	Rsp      uint64
	Ss       uint64
	Fs_base  uint64
	Gs_base  uint64
	Ds       uint64
	Es       uint64
	Fs       uint64
	Gs       uint64
}

type FdSet struct {
	Bits [16]int64
}

type Sysinfo_t struct {
	Uptime    int64
	Loads     [3]uint64
	Totalram  uint64
	Freeram   uint64
	Sharedram uint64
	Bufferram uint64
	Totalswap uint64
	Freeswap  uint64
	Procs     uint16
	Pad       uint16
	Totalhigh uint64
	Freehigh  uint64
	Unit      uint32
	_         [0]int8
	_         [4]byte
}

type Ustat_t struct {
	Tfree  int32
	Tinode uint64
	Fname  [6]int8
	Fpack  [6]int8
	_      [4]byte
}

type EpollEvent struct {
	Events uint32
	Fd     int32
	Pad    int32
}

const (
	OPEN_TREE_CLOEXEC = 0x80000
)

const (
	POLLRDHUP = 0x2000
)

type Sigset_t struct {
	Val [16]uint64
}

const _C__NSIG = 0x41

const (
	SIG_BLOCK   = 0x0
	SIG_UNBLOCK = 0x1
	SIG_SETMASK = 0x2
)

type Siginfo struct {
	Signo int32
	Errno int32
	Code  int32
	_     int32
	_     [112]byte
}

type Termios struct {
	Iflag  uint32
	Oflag  uint32
	Cflag  uint32
	Lflag  uint32
	Line   uint8
	Cc     [19]uint8
	Ispeed uint32
	Ospeed uint32
}

type Taskstats struct {
	Version                   uint16
	Ac_exitcode               uint32
	Ac_flag                   uint8
	Ac_nice                   uint8
	Cpu_count                 uint64
	Cpu_delay_total           uint64
	Blkio_count               uint64
	Blkio_delay_total         uint64
	Swapin_count              uint64
	Swapin_delay_total        uint64
	Cpu_run_real_total        uint64
	Cpu_run_virtual_total     uint64
	Ac_comm                   [32]int8
	Ac_sched                  uint8
	Ac_pad                    [3]uint8
	_                         [4]byte
	Ac_uid                    uint32
	Ac_gid                    uint32
	Ac_pid                    uint32
	Ac_ppid                   uint32
	Ac_btime                  uint32
	Ac_etime                  uint64
	Ac_utime                  uint64
	Ac_stime                  uint64
	Ac_minflt                 uint64
	Ac_majflt                 uint64
	Coremem                   uint64
	Virtmem                   uint64
	Hiwater_rss               uint64
	Hiwater_vm                uint64
	Read_char                 uint64
	Write_char                uint64
	Read_syscalls             uint64
	Write_syscalls            uint64
	Read_bytes                uint64
	Write_bytes               uint64
	Cancelled_write_bytes     uint64
	Nvcsw                     uint64
	Nivcsw                    uint64
	Ac_utimescaled            uint64
	Ac_stimescaled            uint64
	Cpu_scaled_run_real_total uint64
	Freepages_count           uint64
	Freepages_delay_total     uint64
	Thrashing_count           uint64
	Thrashing_delay_total     uint64
	Ac_btime64                uint64
	Compact_count             uint64
	Compact_delay_total       uint64
	Ac_tgid                   uint32
	Ac_tgetime                uint64
	Ac_exe_dev                uint64
	Ac_exe_inode              uint64
	Wpcopy_count              uint64
	Wpcopy_delay_total        uint64
	Irq_count                 uint64
	Irq_delay_total           uint64
}

type cpuMask uint64

const (
	_NCPUBITS = 0x40
)

const (
	CBitFieldMaskBit0  = 0x1
	CBitFieldMaskBit1  = 0x2
	CBitFieldMaskBit2  = 0x4
	CBitFieldMaskBit3  = 0x8
	CBitFieldMaskBit4  = 0x10
	CBitFieldMaskBit5  = 0x20
	CBitFieldMaskBit6  = 0x40
	CBitFieldMaskBit7  = 0x80
	CBitFieldMaskBit8  = 0x100
	CBitFieldMaskBit9  = 0x200
	CBitFieldMaskBit10 = 0x400
	CBitFieldMaskBit11 = 0x800
	CBitFieldMaskBit12 = 0x1000
	CBitFieldMaskBit13 = 0x2000
	CBitFieldMaskBit14 = 0x4000
	CBitFieldMaskBit15 = 0x8000
	CBitFieldMaskBit16 = 0x10000
	CBitFieldMaskBit17 = 0x20000
	CBitFieldMaskBit18 = 0x40000
	CBitFieldMaskBit19 = 0x80000
	CBitFieldMaskBit20 = 0x100000
	CBitFieldMaskBit21 = 0x200000
	CBitFieldMaskBit22 = 0x400000
	CBitFieldMaskBit23 = 0x800000
	CBitFieldMaskBit24 = 0x1000000
	CBitFieldMaskBit25 = 0x2000000
	CBitFieldMaskBit26 = 0x4000000
	CBitFieldMaskBit27 = 0x8000000
	CBitFieldMaskBit28 = 0x10000000
	CBitFieldMaskBit29 = 0x20000000
	CBitFieldMaskBit30 = 0x40000000
	CBitFieldMaskBit31 = 0x80000000
	CBitFieldMaskBit32 = 0x100000000
	CBitFieldMaskBit33 = 0x200000000
	CBitFieldMaskBit34 = 0x400000000
	CBitFieldMaskBit35 = 0x800000000
	CBitFieldMaskBit36 = 0x1000000000
	CBitFieldMaskBit37 = 0x2000000000
	CBitFieldMaskBit38 = 0x4000000000
	CBitFieldMaskBit39 = 0x8000000000
	CBitFieldMaskBit40 = 0x10000000000
	CBitFieldMaskBit41 = 0x20000000000
	CBitFieldMaskBit42 = 0x40000000000
	CBitFieldMaskBit43 = 0x80000000000
	CBitFieldMaskBit44 = 0x100000000000
	CBitFieldMaskBit45 = 0x200000000000
	CBitFieldMaskBit46 = 0x400000000000
	CBitFieldMaskBit47 = 0x800000000000
	CBitFieldMaskBit48 = 0x1000000000000
	CBitFieldMaskBit49 = 0x2000000000000
	CBitFieldMaskBit50 = 0x4000000000000
	CBitFieldMaskBit51 = 0x8000000000000
	CBitFieldMaskBit52 = 0x10000000000000
	CBitFieldMaskBit53 = 0x20000000000000
	CBitFieldMaskBit54 = 0x40000000000000
	CBitFieldMaskBit55 = 0x80000000000000
	CBitFieldMaskBit56 = 0x100000000000000
	CBitFieldMaskBit57 = 0x200000000000000
	CBitFieldMaskBit58 = 0x400000000000000
	CBitFieldMaskBit59 = 0x800000000000000
	CBitFieldMaskBit60 = 0x1000000000000000
	CBitFieldMaskBit61 = 0x2000000000000000
	CBitFieldMaskBit62 = 0x4000000000000000
	CBitFieldMaskBit63 = 0x8000000000000000
)

type SockaddrStorage struct {
	Family uint16
	Data   [118]byte
	_      uint64
}

type HDGeometry struct {
	Heads     uint8
	Sectors   uint8
	Cylinders uint16
	Start     uint64
}

type Statfs_t struct {
	Type    int64
	Bsize   int64
	Blocks  uint64
	Bfree   uint64
	Bavail  uint64
	Files   uint64
	Ffree   uint64
	Fsid    Fsid
	Namelen int64
	Frsize  int64
	Flags   int64
	Spare   [4]int64
}

type TpacketHdr struct {
	Status  uint64
	Len     uint32
	Snaplen uint32
	Mac     uint16
	Net     uint16
	Sec     uint32
	Usec    uint32
	_       [4]byte
}

const (
	SizeofTpacketHdr = 0x20
)

type RTCPLLInfo struct {
	Ctrl    int32
	Value   int32
	Max     int32
	Min     int32
	Posmult int32
	Negmult int32
	Clock   int64
}

type BlkpgPartition struct {
	Start   int64
	Length  int64
	Pno     int32
	Devname [64]uint8
	Volname [64]uint8
	_       [4]byte
}

const (
	BLKPG = 0x1269
)

type CryptoUserAlg struct {
	Name        [64]int8
	Driver_name [64]int8
	Module_name [64]int8
	Type        uint32
	Mask        uint32
	Refcnt      uint32
	Flags       uint32
}

type CryptoStatAEAD struct {
	Type         [64]int8
	Encrypt_cnt  uint64
	Encrypt_tlen uint64
	Decrypt_cnt  uint64
	Decrypt_tlen uint64
	Err_cnt      uint64
}

type CryptoStatAKCipher struct {
	Type         [64]int8
	Encrypt_cnt  uint64
	Encrypt_tlen uint64
	Decrypt_cnt  uint64
	Decrypt_tlen uint64
	Verify_cnt   uint64
	Sign_cnt     uint64
	Err_cnt      uint64
}

type CryptoStatCipher struct {
	Type         [64]int8
	Encrypt_cnt  uint64
	Encrypt_tlen uint64
	Decrypt_cnt  uint64
	Decrypt_tlen uint64
	Err_cnt      uint64
}

type CryptoStatCompress struct {
	Type            [64]int8
	Compress_cnt    uint64
	Compress_tlen   uint64
	Decompress_cnt  uint64
	Decompress_tlen uint64
	Err_cnt         uint64
}

type CryptoStatHash struct {
	Type      [64]int8
	Hash_cnt  uint64
	Hash_tlen uint64
	Err_cnt   uint64
}

type CryptoStatKPP struct {
	Type                      [64]int8
	Setsecret_cnt             uint64
	Generate_public_key_cnt   uint64
	Compute_shared_secret_cnt uint64
	Err_cnt                   uint64
}

type CryptoStatRNG struct {
	Type          [64]int8
	Generate_cnt  uint64
	Generate_tlen uint64
	Seed_cnt      uint64
	Err_cnt       uint64
}

type CryptoStatLarval struct {
	Type [64]int8
}

type CryptoReportLarval struct {
	Type [64]int8
}

type CryptoReportHash struct {
	Type       [64]int8
	Blocksize  uint32
	Digestsize uint32
}

type CryptoReportCipher struct {
	Type        [64]int8
	Blocksize   uint32
	Min_keysize uint32
	Max_keysize uint32
}

type CryptoReportBlkCipher struct {
	Type        [64]int8
	Geniv       [64]int8
	Blocksize   uint32
	Min_keysize uint32
	Max_keysize uint32
	Ivsize      uint32
}

type CryptoReportAEAD struct {
	Type        [64]int8
	Geniv       [64]int8
	Blocksize   uint32
	Maxauthsize uint32
	Ivsize      uint32
}

type CryptoReportComp struct {
	Type [64]int8
}

type CryptoReportRNG struct {
	Type     [64]int8
	Seedsize uint32
}

type CryptoReportAKCipher struct {
	Type [64]int8
}

type CryptoReportKPP struct {
	Type [64]int8
}

type CryptoReportAcomp struct {
	Type [64]int8
}

type LoopInfo struct {
	Number           int32
	Device           uint64
	Inode            uint64
	Rdevice          uint64
	Offset           int32
	Encrypt_type     int32
	Encrypt_key_size int32
	Flags            int32
	Name             [64]int8
	Encrypt_key      [32]uint8
	Init             [2]uint64
	Reserved         [4]int8
	_                [4]byte
}

type TIPCSubscr struct {
	Seq     TIPCServiceRange
	Timeout uint32
	Filter  uint32
	Handle  [8]int8
}

type TIPCSIOCLNReq struct {
	Peer     uint32
	Id       uint32
	Linkname [68]int8
}

type TIPCSIOCNodeIDReq struct {
	Peer uint32
	Id   [16]int8
}

type PPSKInfo struct {
	Assert_sequence uint32
	Clear_sequence  uint32
	Assert_tu       PPSKTime
	Clear_tu        PPSKTime
	Current_mode    int32
	_               [4]byte
}

const (
	PPS_GETPARAMS = 0x800870a1
	PPS_SETPARAMS = 0x400870a2
	PPS_GETCAP    = 0x800870a3
	PPS_FETCH     = 0xc00870a4
)

const (
	PIDFD_NONBLOCK = 0x800
)

type SysvIpcPerm struct {
	Key  int32
	Uid  uint32
	Gid  uint32
	Cuid uint32
	Cgid uint32
	Mode uint32
	_    [0]uint8
	Seq  uint16
	_    uint16
	_    uint64
	_    uint64
}
type SysvShmDesc struct {
	Perm   SysvIpcPerm
	Segsz  uint64
	Atime  int64
	Dtime  int64
	Ctime  int64
	Cpid   int32
	Lpid   int32
	Nattch uint64
	_      uint64
	_      uint64
}
```
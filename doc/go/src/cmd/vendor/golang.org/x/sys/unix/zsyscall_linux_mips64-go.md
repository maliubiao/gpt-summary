Response:
Let's break down the thought process for analyzing this Go code snippet.

**1. Initial Scan and Identifying Key Information:**

The first thing I notice is the comment at the top: `// go run mksyscall.go -tags linux,mips64 syscall_linux.go syscall_linux_mips64x.go syscall_linux_alarm.go`. This immediately tells me:

* **Code Generation:** This file is automatically generated by `mksyscall.go`. Therefore, the code itself isn't written by hand, but rather produced by a tool based on definitions in other files.
* **Target Architecture:** The `-tags linux,mips64` part is crucial. It indicates this code is specifically for the Linux operating system running on the MIPS64 architecture.
* **Related Files:** The other filenames hint at where the definitions might come from (`syscall_linux.go`, etc.).

Next, I see the `// Code generated by the command above; see README.md. DO NOT EDIT.` comment repeated for each function. This reinforces the "generated code" idea and warns against manual modification.

The `package unix` import also stands out. This suggests these functions are low-level interfaces for interacting directly with the operating system kernel. The import of `syscall` and `unsafe` further supports this.

**2. Analyzing Function Structure:**

I look at the function signatures. They generally follow a pattern:

* They take primitive Go types (int, uint, int64, string, slices) as arguments.
* They often return an error value (`err error`).
* Some return additional values (int, int64, uint).
* They call `Syscall`, `Syscall6`, or `RawSyscallNoError`.

This immediately tells me that these functions are wrappers around underlying system calls. The `SYS_*` constants within the `Syscall` calls are the actual system call numbers. The `unsafe.Pointer` is used for passing data structures directly to the kernel.

**3. Connecting to System Calls:**

Knowing that these are system call wrappers, I can start to infer the purpose of each function by looking at the `SYS_*` constant. Even without prior knowledge of MIPS64 system calls, the names often provide hints:

* `SYS_FANOTIFY_MARK`: Likely related to file system event notification (fanotify).
* `SYS_FALLOCATE`:  Probably for pre-allocating disk space.
* `SYS_TEE`:  Likely related to copying data between file descriptors.
* `SYS_EPOLL_WAIT`:  For waiting on events from an epoll file descriptor.
* `SYS_FADVISE64`:  Provides advice to the kernel about file access patterns.
* `SYS_FCHOWN`, `SYS_LCHOWN`: Changing file ownership.
* `SYS_FSTATFS`, `SYS_STATFS`: Getting file system statistics.
* `SYS_FTRUNCATE`, `SYS_TRUNCATE`:  Resizing files.
* `SYS_GETEGID`, `SYS_GETEUID`, `SYS_GETGID`, `SYS_GETUID`: Getting user and group IDs.
* `SYS_GETRLIMIT`: Getting resource limits.
* `SYS_LISTEN`:  Setting up a socket to listen for connections.
* `SYS_PAUSE`:  Suspending the process until a signal arrives.
* `SYS_PREAD64`, `SYS_PWRITE64`:  Reading and writing to a file at a specific offset.
* `SYS_RENAMEAT`: Renaming files.
* `SYS_LSEEK`:  Moving the file offset.
* `SYS_SENDFILE`: Efficiently copying data between file descriptors.
* `SYS_SETFSGID`, `SYS_SETFSUID`: Setting file system user and group IDs.
* `SYS_SHUTDOWN`:  Closing part of a full-duplex connection.
* `SYS_SPLICE`: Moving data between file descriptors without copying through user space.
* `SYS_SYNC_FILE_RANGE`:  Flushing a range of a file to disk.
* `SYS_USTAT`: Getting file system statistics (older system call).
* Socket-related calls (`SYS_ACCEPT4`, `SYS_BIND`, `SYS_CONNECT`, `SYS_GETSOCKOPT`, etc.): Standard network socket operations.
* `SYS_MMAP`:  Mapping files or devices into memory.
* Time-related calls (`SYS_FUTIMESAT`, `SYS_GETTIMEOFDAY`, `SYS_UTIME`, `SYS_UTIMES`):  Setting and getting file timestamps.
* File information calls (`SYS_FSTAT`, `SYS_NEWFSTATAT`, `SYS_LSTAT`, `SYS_STAT`): Getting file metadata.
* `SYS_ALARM`: Setting a timer.

**4. Inferring Go Functionality:**

Based on the identified system calls, I can deduce the high-level Go functionalities they support. For example:

* File I/O: `Fallocate`, `Tee`, `pread`, `pwrite`, `sendfile`, `Splice`, `SyncFileRange`, `Truncate`.
* File System Operations: `fanotifyMark`, `Fchown`, `Lchown`, `Fstatfs`, `Statfs`, `Renameat`, `Ustat`, `futimesat`, `Utime`, `utimes`, `fstat`, `fstatat`, `lstat`, `stat`.
* Process Management: `Getegid`, `Geteuid`, `Getgid`, `Getrlimit`, `Getuid`, `Pause`, `setfsgid`, `setfsuid`, `Alarm`.
* Networking: `EpollWait`, `Listen`, `accept4`, `bind`, `connect`, `getgroups`, `setgroups`, `getsockopt`, `setsockopt`, `socket`, `socketpair`, `getpeername`, `getsockname`, `recvfrom`, `sendto`, `recvmsg`, `sendmsg`, `Shutdown`.
* Memory Management: `mmap`.
* Time: `Gettimeofday`.

**5. Generating Example Code (Iterative Process):**

When generating example code, I focus on the most common and understandable functionalities first. For instance, file reading/writing or basic networking. I then consider edge cases and how errors might be handled.

For `Fallocate`, I thought about the common use case of pre-allocating space for large files. I considered what input values (file descriptor, mode, offset, length) would be needed and what the expected outcome would be (success or an error).

For `EpollWait`, I knew it involved setting up an epoll instance and waiting for events. So the example involves creating the epoll FD, adding a file descriptor to it, and then calling `EpollWait`. I considered the structure of `EpollEvent` and how to represent the events being waited for.

**6. Identifying Potential Pitfalls:**

I considered common errors when working with low-level system calls:

* Incorrect file descriptors.
* Incorrectly sized buffers (especially with `unsafe.Pointer`).
* Ignoring error returns.
* Misunderstanding the flags and options for system calls.

The example with `EpollWait` highlights the need to correctly initialize the `EpollEvent` slice. The example with `sendto` shows the importance of providing the correct address and length.

**7. Handling the "Why MIPS64?" Question (Implicit):**

While not explicitly asked, I knew that the architecture-specific nature of this file is important. This code bridges the gap between the generic Go `syscall` package and the specific system call interface provided by the Linux kernel on MIPS64. It handles the architecture-dependent details of how system call arguments are passed and results are returned.

**8. Refinement and Organization:**

Finally, I organize the information logically, starting with the overall purpose, then detailing the functionalities, providing examples, and finally addressing potential pitfalls. I try to use clear and concise language.

This iterative process of scanning, analyzing structure, connecting to concepts, generating examples, and considering potential issues allows for a comprehensive understanding of the provided code snippet.
这段代码是 Go 语言标准库 `syscall` 包的一部分，专门针对 Linux 操作系统在 MIPS64 架构上的系统调用实现。

**功能列举:**

这个文件 (`zsyscall_linux_mips64.go`) 的主要功能是为 Go 语言提供访问 Linux 内核系统调用的底层接口。它包含了一系列 Go 函数，每个函数都对应一个特定的 Linux 系统调用。这些函数通常以小写字母开头，并直接映射到内核中的系统调用。

具体来说，这个文件实现了以下系统调用的 Go 封装：

* **文件和文件系统操作:**
    * `fanotifyMark`:  用于向 fanotify 文件事件通知系统添加或移除监控标记。
    * `Fallocate`:  为一个打开的文件预分配存储空间。
    * `Fchown`, `Lchown`: 更改文件的所有者和组。
    * `Fstatfs`, `Statfs`: 获取文件系统的统计信息。
    * `Ftruncate`, `Truncate`:  将文件截断为指定长度。
    * `pread`, `pwrite`:  在指定偏移量处读取或写入文件。
    * `Renameat`:  原子地重命名文件或目录。
    * `Seek`:  设置文件偏移量。
    * `sendfile`:  在两个文件描述符之间高效地复制数据。
    * `SyncFileRange`:  将文件的一部分数据同步到磁盘。
    * `Ustat`:  返回文件系统状态信息（较旧的系统调用）。
    * `futimesat`, `Utime`, `utimes`:  更改文件的访问和修改时间。
    * `fstat`, `fstatat`, `lstat`, `stat`: 获取文件的元数据（状态信息）。

* **进程管理:**
    * `Getegid`, `Geteuid`, `Getgid`, `Getuid`:  获取有效的、实际的用户和组 ID。
    * `Getrlimit`:  获取进程的资源限制。
    * `Pause`:  挂起进程直到接收到信号。
    * `setfsgid`, `setfsuid`:  设置用于文件系统访问的用户和组 ID。
    * `Alarm`:  设置一个定时器，在指定秒数后发送 `SIGALRM` 信号。

* **网络:**
    * `Tee`:  在两个文件描述符之间复制数据。
    * `EpollWait`:  等待 epoll 实例上的事件。
    * `Listen`:  监听 socket 连接。
    * `accept4`:  接受一个 socket 连接，并设置一些标志。
    * `bind`:  将 socket 绑定到特定的地址和端口。
    * `connect`:  连接到指定的 socket 地址。
    * `getgroups`, `setgroups`:  获取和设置进程的附属组 ID 列表。
    * `getsockopt`, `setsockopt`:  获取和设置 socket 选项。
    * `socket`, `socketpair`:  创建 socket 或 socket 对。
    * `getpeername`, `getsockname`:  获取连接的对端地址和 socket 自身的地址。
    * `recvfrom`, `sendto`:  在 socket 上接收和发送数据报。
    * `recvmsg`, `sendmsg`:  在 socket 上接收和发送消息，支持更复杂的选项。
    * `Shutdown`:  关闭 socket 连接的一部分或全部。
    * `Splice`:  在两个文件描述符之间移动数据，无需在用户空间进行复制。

* **内存管理:**
    * `mmap`:  将文件或设备映射到内存中。

* **时间:**
    * `Gettimeofday`:  获取当前时间。

**Go 语言功能的实现推理与示例:**

这个文件是 `syscall` 包在特定平台上的底层实现，它本身不直接实现高层的 Go 语言功能。 相反，它为其他 Go 标准库（例如 `os` 包, `net` 包）提供了构建更高级抽象的基础。

例如，`os` 包中的 `os.OpenFile` 函数最终会调用到 `syscall.Open` (在其他文件中定义，但遵循类似的模式)，而 `syscall.Open` 本身可能会调用到这个文件中的某些底层函数来执行具体的文件操作。

让我们以 `Fallocate`  (预分配文件空间) 为例进行说明。

**假设的输入与输出：**

```go
package main

import (
	"fmt"
	"os"
	"syscall"
)

func main() {
	file, err := os.Create("test.txt")
	if err != nil {
		fmt.Println("创建文件失败:", err)
		return
	}
	defer file.Close()

	fd := int(file.Fd())
	mode := uint32(0) //  0 表示分配实际的物理块
	offset := int64(1024) // 从 1KB 处开始分配
	length := int64(2048) // 分配 2KB 的空间

	err = syscall.Fallocate(fd, mode, offset, length)
	if err != nil {
		fmt.Println("预分配空间失败:", err)
		return
	}

	fmt.Println("成功预分配了文件空间.")
}
```

**代码解释:**

1. **创建文件:**  首先使用 `os.Create` 创建一个名为 `test.txt` 的文件。
2. **获取文件描述符:**  通过 `file.Fd()` 获取文件的文件描述符 (file descriptor)。
3. **调用 `syscall.Fallocate`:**  调用 `syscall.Fallocate` 函数，传入文件描述符 `fd`，分配模式 `mode`（这里使用 0），起始偏移量 `offset`，以及要分配的长度 `length`。
4. **错误处理:**  检查 `syscall.Fallocate` 是否返回错误。

**假设的输入与输出:**

* **输入:**  执行上述 Go 代码。
* **输出:**  如果一切顺利，控制台将打印 "成功预分配了文件空间."，并且在文件系统层面上，`test.txt` 文件会从 1KB 的位置开始预留 2KB 的磁盘空间。如果失败，会打印相应的错误信息。

**涉及的底层代码推理:**

当 `syscall.Fallocate` 被调用时，它会直接调用 `go/src/cmd/vendor/golang.org/x/sys/unix/zsyscall_linux_mips64.go` 文件中定义的 `Fallocate` 函数：

```go
func Fallocate(fd int, mode uint32, off int64, len int64) (err error) {
	_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(len), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}
```

这个函数做了以下事情：

1. **调用 `Syscall6`:** 它调用了 `Syscall6` 函数，这是 `syscall` 包中用于执行带有 6 个参数的系统调用的底层函数。
2. **`SYS_FALLOCATE` 常量:**  第一个参数 `SYS_FALLOCATE` 是一个常量，代表 Linux 内核中 `fallocate` 系统调用的编号。
3. **参数转换:**  将 Go 语言的参数（`fd`, `mode`, `off`, `len`）转换为 `uintptr` 类型，这是 Go 中表示指针或原始内存地址的方式，以便传递给系统调用。
4. **执行系统调用:**  `Syscall6` 函数会将这些参数传递给 Linux 内核的 `fallocate` 系统调用。
5. **错误处理:**  系统调用执行后，`Syscall6` 会返回三个值，其中 `e1` 是错误码。如果 `e1` 不为 0，则表示系统调用失败，`errnoErr(e1)` 将错误码转换为 Go 的 `error` 类型。

**命令行参数的具体处理:**

这个文件本身是由 `mksyscall.go` 工具生成的，生成命令如下：

```
// go run mksyscall.go -tags linux,mips64 syscall_linux.go syscall_linux_mips64x.go syscall_linux_alarm.go
```

* **`go run mksyscall.go`**:  执行 `mksyscall.go` 这个 Go 程序。
* **`-tags linux,mips64`**:  这是一个构建标签，告诉 `mksyscall.go` 针对 `linux` 操作系统和 `mips64` 架构生成代码。
* **`syscall_linux.go syscall_linux_mips64x.go syscall_linux_alarm.go`**: 这些是 `mksyscall.go` 读取的输入文件，其中包含了系统调用的定义和参数信息。`mksyscall.go` 会解析这些文件，并根据 `-tags` 指定的平台和架构生成相应的 `zsyscall_linux_mips64.go` 文件。

因此，这个文件本身不处理任何运行时命令行参数。它的生成过程依赖于 `mksyscall.go` 工具的命令行参数。

**使用者易犯错的点:**

对于直接使用 `syscall` 包（包括这个文件中的函数）的开发者来说，容易犯以下错误：

1. **不正确的参数类型和值:** 系统调用对参数的类型和取值范围有严格的要求。例如，文件描述符必须是有效的，标志位必须是内核支持的。 传递不正确的参数可能导致程序崩溃或者不可预测的行为。

   **示例:**  调用 `EpollWait` 时，如果传递的 `msec` (超时时间) 是一个负数，可能会导致错误，因为内核对超时时间有特定的解释。

2. **忽略错误返回值:**  几乎所有的系统调用都可能失败，并返回错误码。 忽略错误返回值会导致程序在出现问题时无法正确处理，甚至会产生安全漏洞。

   **示例:**  在调用 `Fallocate` 时，如果磁盘空间不足，系统调用会失败并返回一个错误。如果程序没有检查这个错误，后续的文件写入操作可能会失败。

3. **不安全地使用 `unsafe.Pointer`:**  `syscall` 包中大量使用了 `unsafe.Pointer` 来传递结构体和数据。 如果不了解内存布局和对齐规则，很容易导致内存访问错误。

   **示例:**  在使用 `sendto` 发送网络数据时，如果传递的缓冲区长度与实际数据长度不符，或者 `unsafe.Pointer` 指向的内存区域无效，都可能导致程序崩溃或发送错误的数据。

4. **平台依赖性:**  `syscall` 包的实现是平台相关的。 在一个平台上可以正常运行的代码，在另一个平台上可能无法工作，或者行为不同。  开发者需要注意代码的平台兼容性。

   **示例:**  某些系统调用可能只在特定的 Linux 内核版本上可用。如果代码使用了这些系统调用，并在旧版本的内核上运行，就会出错。

5. **资源泄漏:**  一些系统调用会分配内核资源（例如，创建 socket 或 epoll 实例）。 如果这些资源在使用完毕后没有被正确释放（例如，调用 `close()` 关闭文件描述符），可能会导致资源泄漏，最终耗尽系统资源。

   **示例:**  在使用 `EpollCreate` 创建 epoll 实例后，必须在不再使用时调用 `Close` 关闭它。忘记关闭会导致系统中 epoll 实例的数量不断增加。

理解 `syscall` 包和这些底层函数的运作方式对于编写高性能和与操作系统底层交互的 Go 程序至关重要。但是，由于其复杂性和平台依赖性，直接使用 `syscall` 包需要非常谨慎。通常情况下，建议使用 Go 标准库中更高级别的抽象，例如 `os` 包和 `net` 包，它们在底层使用了 `syscall`，并提供了更安全和易用的接口。

### 提示词
```
这是路径为go/src/cmd/vendor/golang.org/x/sys/unix/zsyscall_linux_mips64.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
```

### 源代码
```go
// go run mksyscall.go -tags linux,mips64 syscall_linux.go syscall_linux_mips64x.go syscall_linux_alarm.go
// Code generated by the command above; see README.md. DO NOT EDIT.

//go:build linux && mips64

package unix

import (
	"syscall"
	"unsafe"
)

var _ syscall.Errno

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fanotifyMark(fd int, flags uint, mask uint64, dirFd int, pathname *byte) (err error) {
	_, _, e1 := Syscall6(SYS_FANOTIFY_MARK, uintptr(fd), uintptr(flags), uintptr(mask), uintptr(dirFd), uintptr(unsafe.Pointer(pathname)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fallocate(fd int, mode uint32, off int64, len int64) (err error) {
	_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(len), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Tee(rfd int, wfd int, len int, flags int) (n int64, err error) {
	r0, _, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)
	n = int64(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func EpollWait(epfd int, events []EpollEvent, msec int) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(events) > 0 {
		_p0 = unsafe.Pointer(&events[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec), 0, 0)
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fadvise(fd int, offset int64, length int64, advice int) (err error) {
	_, _, e1 := Syscall6(SYS_FADVISE64, uintptr(fd), uintptr(offset), uintptr(length), uintptr(advice), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fchown(fd int, uid int, gid int) (err error) {
	_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fstatfs(fd int, buf *Statfs_t) (err error) {
	_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(buf)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Ftruncate(fd int, length int64) (err error) {
	_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getegid() (egid int) {
	r0, _ := RawSyscallNoError(SYS_GETEGID, 0, 0, 0)
	egid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Geteuid() (euid int) {
	r0, _ := RawSyscallNoError(SYS_GETEUID, 0, 0, 0)
	euid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getgid() (gid int) {
	r0, _ := RawSyscallNoError(SYS_GETGID, 0, 0, 0)
	gid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getrlimit(resource int, rlim *Rlimit) (err error) {
	_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getuid() (uid int) {
	r0, _ := RawSyscallNoError(SYS_GETUID, 0, 0, 0)
	uid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Lchown(path string, uid int, gid int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Listen(s int, n int) (err error) {
	_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(n), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pause() (err error) {
	_, _, e1 := Syscall(SYS_PAUSE, 0, 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func pread(fd int, p []byte, offset int64) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func pwrite(fd int, p []byte, offset int64) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(oldpath)
	if err != nil {
		return
	}
	var _p1 *byte
	_p1, err = BytePtrFromString(newpath)
	if err != nil {
		return
	}
	_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Seek(fd int, offset int64, whence int) (off int64, err error) {
	r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))
	off = int64(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) {
	r0, _, e1 := Syscall6(SYS_SENDFILE, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)
	written = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func setfsgid(gid int) (prev int, err error) {
	r0, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)
	prev = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func setfsuid(uid int) (prev int, err error) {
	r0, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)
	prev = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Shutdown(fd int, how int) (err error) {
	_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(fd), uintptr(how), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error) {
	r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))
	n = int64(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Statfs(path string, buf *Statfs_t) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func SyncFileRange(fd int, off int64, n int64, flags int) (err error) {
	_, _, e1 := Syscall6(SYS_SYNC_FILE_RANGE, uintptr(fd), uintptr(off), uintptr(n), uintptr(flags), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Truncate(path string, length int64) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Ustat(dev int, ubuf *Ustat_t) (err error) {
	_, _, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) {
	r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)
	fd = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) {
	_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) {
	_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getgroups(n int, list *_Gid_t) (nn int, err error) {
	r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)
	nn = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func setgroups(n int, list *_Gid_t) (err error) {
	_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) {
	_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) {
	_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func socket(domain int, typ int, proto int) (fd int, err error) {
	r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))
	fd = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func socketpair(domain int, typ int, proto int, fd *[2]int32) (err error) {
	_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) {
	_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) {
	_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func sendto(s int, buf []byte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) {
	var _p0 unsafe.Pointer
	if len(buf) > 0 {
		_p0 = unsafe.Pointer(&buf[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func recvmsg(s int, msg *Msghdr, flags int) (n int, err error) {
	r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func sendmsg(s int, msg *Msghdr, flags int) (n int, err error) {
	r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error) {
	r0, _, e1 := Syscall6(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flags), uintptr(fd), uintptr(offset))
	xaddr = uintptr(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func futimesat(dirfd int, path string, times *[2]Timeval) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Gettimeofday(tv *Timeval) (err error) {
	_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Utime(path string, buf *Utimbuf) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_UTIME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func utimes(path string, times *[2]Timeval) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fstat(fd int, st *stat_t) (err error) {
	_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(st)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fstatat(dirfd int, path string, st *stat_t, flags int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall6(SYS_NEWFSTATAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(st)), uintptr(flags), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func lstat(path string, st *stat_t) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(st)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func stat(path string, st *stat_t) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(st)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Alarm(seconds uint) (remaining uint, err error) {
	r0, _, e1 := Syscall(SYS_ALARM, uintptr(seconds), 0, 0)
	remaining = uint(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}
```
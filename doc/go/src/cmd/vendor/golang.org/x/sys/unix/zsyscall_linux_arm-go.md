Response:
Let's break down the thought process to analyze this Go code snippet.

1. **Identify the Core Purpose:** The file path `go/src/cmd/vendor/golang.org/x/sys/unix/zsyscall_linux_arm.go` immediately tells us this is related to system calls (`syscall`) within the `unix` package, specifically for the Linux operating system and the ARM architecture. The `zsyscall` prefix suggests it's an auto-generated file.

2. **Examine the Generation Comment:** The first comment line is crucial: `// go run mksyscall.go -l32 -arm -tags linux,arm syscall_linux.go syscall_linux_arm.go`. This clearly states the file is generated by running `mksyscall.go` with specific flags. This is a key piece of information and explains why each function has the "THIS FILE IS GENERATED..." comment.

3. **Analyze the `package` and `import` statements:**  The `package unix` indicates it's part of the `unix` package. The `import "syscall"` confirms its interaction with the standard `syscall` package. The `import "unsafe"` indicates the code manipulates memory directly, which is common when interacting with system calls.

4. **Focus on the Functions:** The bulk of the file consists of Go functions. Each function follows a similar pattern:
    * A comment indicating it's generated.
    * A function signature (e.g., `func fanotifyMark(fd int, flags uint, mask uint64, dirFd int, pathname *byte) (err error)`).
    * A call to either `Syscall`, `Syscall6`, `RawSyscall`, or `RawSyscall6`. These are functions from the `syscall` package that provide a low-level interface to the operating system's system calls.
    * Error handling by checking the return value `e1` and converting it to a `syscall.Errno`.

5. **Connect Functions to System Calls:**  The first argument to `Syscall` and its variants is a constant like `SYS_FANOTIFY_MARK`. This is the crucial link. These constants are defined elsewhere (likely in `syscall_linux.go` as hinted by the generation command) and represent the numeric identifier of the corresponding Linux system call. So, `fanotifyMark` is a Go wrapper around the `fanotify_mark` Linux system call.

6. **Infer Functionality Based on System Call Names:** Even without knowing the exact details of each system call, the names are often suggestive:
    * `fanotifyMark`:  Likely related to file system event notification.
    * `Fallocate`: Allocating space to a file.
    * `Tee`: Copying data between file descriptors.
    * `accept4`, `bind`, `connect`, `socket`, etc.: Networking-related system calls.
    * `getgroups`, `setgroups`, `Getuid`, `Setfsgid`, etc.: User and group ID management.
    * `Fstat`, `Lstat`, `Stat`: Getting file information.
    * `EpollWait`:  Waiting for events on an epoll file descriptor.
    * `sendfile`, `Splice`: Efficient data transfer between file descriptors.
    * `mmap2`: Memory mapping a file.
    * `pread`, `pwrite`: Reading and writing to a file at a specific offset.
    * `Truncate`, `Ftruncate`:  Changing the size of a file.

7. **Consider the Data Types:**  Notice the use of `unsafe.Pointer`, `*byte`, `_Socklen`, `RawSockaddrAny`, `Msghdr`, `EpollEvent`, `Stat_t`, `Timeval`, `FdSet`, `rlimit32`, `Ustat_t`. These represent the data structures used by the underlying Linux system calls. The `unsafe.Pointer` is used to pass pointers to these structures to the kernel. The `_Socklen` type likely represents the size of socket addresses.

8. **Address the Specific Questions:**

    * **Functionality:** List the inferred functionalities based on system call names.
    * **Go Language Feature:**  System calls are a low-level interaction with the OS kernel. This file demonstrates the use of the `syscall` package to bridge Go code to these kernel interfaces. Give a simple example showing how one of these functions could be used.
    * **Code Inference (Input/Output):** Choose a function and demonstrate a basic use case with example input and expected output (focus on the error case for simplicity).
    * **Command-line Arguments:** Explain the purpose of the flags used in the `go run` command that generated the file.
    * **Common Mistakes:**  Think about the common pitfalls of working with low-level system calls: incorrect data types, handling of pointers, interpreting error codes. The example of incorrect buffer size for `recvfrom` is a good illustration.

9. **Structure the Answer:** Organize the information logically, starting with the overall purpose and then drilling down into specific details. Use headings and bullet points to improve readability. Provide clear explanations and code examples.

By following this thought process, we can systematically analyze the provided Go code snippet and provide a comprehensive answer to the user's questions. The key is to recognize the connection to system calls and leverage the naming conventions to understand the purpose of the code.
这个 Go 语言文件 `zsyscall_linux_arm.go` 是 `golang.org/x/sys/unix` 包的一部分，它为 Linux 系统在 ARM 架构上提供了一组 **系统调用的 Go 语言封装**。

**主要功能：**

该文件定义了一系列 Go 函数，这些函数直接调用 Linux 内核提供的系统调用。每个 Go 函数对应一个特定的系统调用，并将其参数和返回值转换为 Go 的类型。 它的主要目的是：

1. **提供访问底层操作系统功能的接口：**  它允许 Go 程序执行需要操作系统内核支持的操作，例如文件操作、网络操作、进程管理等。
2. **平台特定性：**  由于系统调用在不同的操作系统和架构上有所不同，这个文件专门针对 Linux 和 ARM 架构。
3. **自动生成：**  从文件开头的注释 `// go run mksyscall.go -l32 -arm -tags linux,arm syscall_linux.go syscall_linux_arm.go` 可以看出，这个文件是通过 `mksyscall.go` 工具自动生成的。这意味着定义系统调用的信息可能存在于 `syscall_linux.go` 等文件中。

**它是什么 Go 语言功能的实现：**

这个文件是 Go 语言 `syscall` 标准库在特定平台上的底层实现。Go 的 `syscall` 包提供了一种与操作系统进行交互的方式，而 `zsyscall_linux_arm.go` 则是该包在 Linux/ARM 平台上的具体实现细节。

**Go 代码举例说明：**

让我们以 `Fallocate` 函数为例，它封装了 Linux 的 `fallocate` 系统调用，用于预分配文件空间。

```go
package main

import (
	"fmt"
	"os"
	"syscall"
	"unsafe"

	"golang.org/x/sys/unix"
)

func main() {
	filename := "test_fallocate.txt"
	file, err := os.Create(filename)
	if err != nil {
		fmt.Println("创建文件失败:", err)
		return
	}
	defer file.Close()

	fd := int(file.Fd())
	mode := uint32(0) // 默认模式
	offset := int64(1024) // 偏移量 1KB
	length := int64(2048) // 预分配 2KB

	err = unix.Fallocate(fd, mode, offset, length)
	if err != nil {
		fmt.Println("预分配空间失败:", err)
		return
	}

	// 可以通过 stat 查看文件大小是否改变
	var stat unix.Stat_t
	err = unix.Fstat(fd, &stat)
	if err != nil {
		fmt.Println("获取文件状态失败:", err)
		return
	}
	fmt.Printf("文件大小: %d 字节\n", stat.Size) // 预期大小至少为 offset + length

	fmt.Println("成功预分配文件空间。")

	// 清理测试文件
	os.Remove(filename)
}
```

**假设的输入与输出：**

* **输入：**  程序运行时，会创建一个名为 `test_fallocate.txt` 的空文件。
* **输出：**
   ```
   文件大小: 3072 字节
   成功预分配文件空间。
   ```
   或者，如果预分配失败，可能会输出类似：
   ```
   创建文件失败: ...
   ```
   ```
   预分配空间失败: no space left on device
   ```
   ```
   获取文件状态失败: ...
   ```

**代码推理：**

1. **`os.Create(filename)`:**  创建一个新的空文件。
2. **`file.Fd()`:** 获取文件描述符 (file descriptor)。
3. **`unix.Fallocate(fd, mode, offset, length)`:** 调用 `zsyscall_linux_arm.go` 中定义的 `Fallocate` 函数，该函数会调用底层的 `fallocate` 系统调用，尝试在打开的文件 `fd` 中从偏移量 `offset` 开始预分配 `length` 大小的空间。
4. **`unix.Fstat(fd, &stat)`:** 调用 `zsyscall_linux_arm.go` 中定义的 `Fstat` 函数，获取文件的状态信息，包括文件大小。
5. **`stat.Size`:**  输出文件的大小。由于预分配，即使没有写入数据，文件的大小也会增加。

**命令行参数的具体处理：**

`zsyscall_linux_arm.go` 本身并不处理命令行参数。它的生成脚本 `mksyscall.go` 负责处理参数。

`// go run mksyscall.go -l32 -arm -tags linux,arm syscall_linux.go syscall_linux_arm.go`

* **`-l32`**:  指定生成 32 位架构的代码。
* **`-arm`**: 指定目标架构为 ARM。
* **`-tags linux,arm`**:  设置构建标签。这意味着只有在构建时指定了 `linux` 和 `arm` 标签，这个文件中的代码才会被编译。这允许在不同的操作系统和架构下使用不同的系统调用实现。
* **`syscall_linux.go`**:  作为输入，可能包含通用的 Linux 系统调用定义。
* **`syscall_linux_arm.go`**:  指定输出文件名。

`mksyscall.go` 工具会读取 `syscall_linux.go` 中的系统调用定义，然后根据 `-l32` 和 `-arm` 等参数，生成特定于 Linux/ARM 32 位架构的系统调用封装代码到 `syscall_linux_arm.go` 文件中。

**使用者易犯错的点：**

由于这些函数直接操作底层的系统调用，使用者容易犯一些与底层编程相关的错误：

1. **不正确的类型转换和 `unsafe.Pointer` 的使用：** 很多系统调用需要传递指针，并且对数据类型有严格的要求。错误的类型转换或者 `unsafe.Pointer` 的使用会导致程序崩溃或产生不可预测的行为。 例如，传递给 `sendto` 或 `recvfrom` 函数的地址结构体 `RawSockaddrAny` 需要正确初始化，并且其长度字段 `_Socklen` 必须匹配实际的地址长度。

   ```go
   // 错误示例：假设 addrLen 的值不正确
   var addr unix.RawSockaddrInet4
   addrLen := unix.Socklen(0) // 错误：长度可能不为 0
   _, _, err := unix.Syscall(unix.SYS_SENDTO, uintptr(sockfd), uintptr(unsafe.Pointer(&buf[0])), uintptr(len(buf)), uintptr(flags), uintptr(unsafe.Pointer(&addr)), uintptr(addrLen))
   if err != 0 {
       // 处理错误
   }
   ```

2. **错误地处理返回值和错误码：** 系统调用通常会返回一个表示成功或失败的状态码，并可能通过全局变量或特定的寄存器设置错误码。Go 的 `syscall` 包将这些错误码转换为 `syscall.Errno` 类型。使用者需要正确检查返回值和错误，并根据错误码进行相应的处理。忽略错误可能导致程序在遇到问题时继续运行，产生更严重的问题。

   ```go
   fd, err := unix.Socket(unix.AF_INET, unix.SOCK_STREAM, 0)
   if err != nil {
       // 正确处理错误，例如打印日志或返回错误
       fmt.Println("创建 socket 失败:", err)
       return
   }
   defer unix.Close(fd)

   // 错误示例：忽略 connect 的返回值
   unix.Connect(fd, unsafe.Pointer(&sockAddr), unix.Socklen(unix.SizeofSockaddrInet4))

   // 正确做法是检查 connect 的错误
   err = unix.Connect(fd, unsafe.Pointer(&sockAddr), unix.Socklen(unix.SizeofSockaddrInet4))
   if err != nil {
       fmt.Println("连接失败:", err)
       return
   }
   ```

3. **资源泄漏：**  例如，打开的文件描述符、分配的内存等资源，如果在使用完毕后没有正确释放，会导致资源泄漏。 系统调用如 `socket`, `open`, `mmap` 等都需要小心地进行资源管理。

   ```go
   // 错误示例：忘记关闭文件描述符
   fd, err := unix.Open("myfile.txt", unix.O_RDONLY, 0)
   if err != nil {
       // 处理错误
   }
   // ... 使用 fd ...
   // 忘记调用 unix.Close(fd)

   // 正确做法：使用 defer 确保资源被释放
   fd, err := unix.Open("myfile.txt", unix.O_RDONLY, 0)
   if err != nil {
       // 处理错误
   }
   defer unix.Close(fd)
   // ... 使用 fd ...
   ```

4. **对系统调用参数和行为的不了解：**  每个系统调用都有其特定的参数、行为和限制。不了解这些细节可能导致调用失败或产生意想不到的结果。 例如，`EpollWait` 的超时时间 `msec` 的含义，以及 `EpollEvent` 结构体的正确使用。

   ```go
   // 错误示例：错误地设置 EpollWait 的超时时间
   n, err := unix.EpollWait(epfd, events, -1) // -1 通常表示无限等待，但具体行为可能依赖于系统
   if err != nil {
       // 处理错误
   }

   // 正确做法：根据需求设置合理的超时时间
   timeoutMs := 100 // 等待 100 毫秒
   n, err := unix.EpollWait(epfd, events, timeoutMs)
   if err != nil {
       // 处理错误
   }
   ```

总之，`zsyscall_linux_arm.go` 提供了一种与 Linux 内核进行低级别交互的方式，但也需要使用者具备一定的底层编程知识，并仔细查阅相关文档，以避免常见的错误。

Prompt: 
```
这是路径为go/src/cmd/vendor/golang.org/x/sys/unix/zsyscall_linux_arm.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，

"""
// go run mksyscall.go -l32 -arm -tags linux,arm syscall_linux.go syscall_linux_arm.go
// Code generated by the command above; see README.md. DO NOT EDIT.

//go:build linux && arm

package unix

import (
	"syscall"
	"unsafe"
)

var _ syscall.Errno

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fanotifyMark(fd int, flags uint, mask uint64, dirFd int, pathname *byte) (err error) {
	_, _, e1 := Syscall6(SYS_FANOTIFY_MARK, uintptr(fd), uintptr(flags), uintptr(mask), uintptr(mask>>32), uintptr(dirFd), uintptr(unsafe.Pointer(pathname)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fallocate(fd int, mode uint32, off int64, len int64) (err error) {
	_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(off>>32), uintptr(len), uintptr(len>>32))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Tee(rfd int, wfd int, len int, flags int) (n int64, err error) {
	r0, r1, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)
	n = int64(int64(r1)<<32 | int64(r0))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) {
	r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)
	fd = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) {
	_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) {
	_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getgroups(n int, list *_Gid_t) (nn int, err error) {
	r0, _, e1 := RawSyscall(SYS_GETGROUPS32, uintptr(n), uintptr(unsafe.Pointer(list)), 0)
	nn = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func setgroups(n int, list *_Gid_t) (err error) {
	_, _, e1 := RawSyscall(SYS_SETGROUPS32, uintptr(n), uintptr(unsafe.Pointer(list)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) {
	_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) {
	_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func socket(domain int, typ int, proto int) (fd int, err error) {
	r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))
	fd = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) {
	_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) {
	_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func sendto(s int, buf []byte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) {
	var _p0 unsafe.Pointer
	if len(buf) > 0 {
		_p0 = unsafe.Pointer(&buf[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func socketpair(domain int, typ int, flags int, fd *[2]int32) (err error) {
	_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(flags), uintptr(unsafe.Pointer(fd)), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func recvmsg(s int, msg *Msghdr, flags int) (n int, err error) {
	r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func sendmsg(s int, msg *Msghdr, flags int) (n int, err error) {
	r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func EpollWait(epfd int, events []EpollEvent, msec int) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(events) > 0 {
		_p0 = unsafe.Pointer(&events[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec), 0, 0)
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fchown(fd int, uid int, gid int) (err error) {
	_, _, e1 := Syscall(SYS_FCHOWN32, uintptr(fd), uintptr(uid), uintptr(gid))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fstat(fd int, stat *Stat_t) (err error) {
	_, _, e1 := Syscall(SYS_FSTAT64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall6(SYS_FSTATAT64, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getegid() (egid int) {
	r0, _ := RawSyscallNoError(SYS_GETEGID32, 0, 0, 0)
	egid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Geteuid() (euid int) {
	r0, _ := RawSyscallNoError(SYS_GETEUID32, 0, 0, 0)
	euid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getgid() (gid int) {
	r0, _ := RawSyscallNoError(SYS_GETGID32, 0, 0, 0)
	gid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getuid() (uid int) {
	r0, _ := RawSyscallNoError(SYS_GETUID32, 0, 0, 0)
	uid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Lchown(path string, uid int, gid int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_LCHOWN32, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Listen(s int, n int) (err error) {
	_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(n), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Lstat(path string, stat *Stat_t) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_LSTAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pause() (err error) {
	_, _, e1 := Syscall(SYS_PAUSE, 0, 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(oldpath)
	if err != nil {
		return
	}
	var _p1 *byte
	_p1, err = BytePtrFromString(newpath)
	if err != nil {
		return
	}
	_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) {
	r0, _, e1 := Syscall6(SYS_SENDFILE64, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)
	written = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) {
	r0, _, e1 := Syscall6(SYS__NEWSELECT, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func setfsgid(gid int) (prev int, err error) {
	r0, _, e1 := Syscall(SYS_SETFSGID32, uintptr(gid), 0, 0)
	prev = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func setfsuid(uid int) (prev int, err error) {
	r0, _, e1 := Syscall(SYS_SETFSUID32, uintptr(uid), 0, 0)
	prev = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Shutdown(fd int, how int) (err error) {
	_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(fd), uintptr(how), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error) {
	r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Stat(path string, stat *Stat_t) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_STAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Ustat(dev int, ubuf *Ustat_t) (err error) {
	_, _, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func futimesat(dirfd int, path string, times *[2]Timeval) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Gettimeofday(tv *Timeval) (err error) {
	_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func utimes(path string, times *[2]Timeval) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func pread(fd int, p []byte, offset int64) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), uintptr(offset>>32))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func pwrite(fd int, p []byte, offset int64) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), uintptr(offset>>32))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Truncate(path string, length int64) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall6(SYS_TRUNCATE64, uintptr(unsafe.Pointer(_p0)), 0, uintptr(length), uintptr(length>>32), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Ftruncate(fd int, length int64) (err error) {
	_, _, e1 := Syscall6(SYS_FTRUNCATE64, uintptr(fd), 0, uintptr(length), uintptr(length>>32), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func mmap2(addr uintptr, length uintptr, prot int, flags int, fd int, pageOffset uintptr) (xaddr uintptr, err error) {
	r0, _, e1 := Syscall6(SYS_MMAP2, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flags), uintptr(fd), uintptr(pageOffset))
	xaddr = uintptr(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getrlimit(resource int, rlim *rlimit32) (err error) {
	_, _, e1 := RawSyscall(SYS_UGETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func armSyncFileRange(fd int, flags int, off int64, n int64) (err error) {
	_, _, e1 := Syscall6(SYS_ARM_SYNC_FILE_RANGE, uintptr(fd), uintptr(flags), uintptr(off), uintptr(off>>32), uintptr(n), uintptr(n>>32))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func kexecFileLoad(kernelFd int, initrdFd int, cmdlineLen int, cmdline string, flags int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(cmdline)
	if err != nil {
		return
	}
	_, _, e1 := Syscall6(SYS_KEXEC_FILE_LOAD, uintptr(kernelFd), uintptr(initrdFd), uintptr(cmdlineLen), uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

"""



```
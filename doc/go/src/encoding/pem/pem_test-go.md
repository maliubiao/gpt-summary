Response:
Let's break down the thought process for analyzing the provided Go code snippet.

1. **Understanding the Goal:** The request asks for an analysis of the Go code, specifically `pem_test.go`. The keywords are "functions", "Go language feature", "code examples", "assumptions", "command-line arguments", and "common mistakes."  The expected output is in Chinese.

2. **Initial Scan for Clues:**  The filename `pem_test.go` strongly suggests this code is for testing the `encoding/pem` package in Go. The imports confirm this (`encoding/pem`, `testing`). The presence of `Test...` functions is another strong indicator of testing code.

3. **Identifying Core Functionality:**  Quickly skimming the function names and variable names gives a high-level view of what's being tested:
    * `TestGetLine`:  Likely testing a function to extract a line from a byte slice.
    * `TestDecode`:  Testing the decoding of PEM encoded data. The variables `pemData`, `certificate`, and `privateKey` are key here.
    * `TestBadDecode`: Testing how the decoder handles invalid PEM data.
    * `TestCVE202224675`: Specifically testing for a vulnerability fix.
    * `TestEncode`: Testing the encoding of data into PEM format.
    * `TestLineBreaker`: Testing a mechanism for adding line breaks in PEM encoding.
    * `TestFuzz`:  Using fuzzing to test the encoder and decoder.
    * `BenchmarkEncode`, `BenchmarkDecode`: Performance testing of encoding and decoding.

4. **Analyzing Key Functions and Data Structures:**

    * **`getLine`:** The tests in `TestGetLine` show how `getLine` splits a byte slice into a line and the remaining data, handling various line endings (`\n`, `\r`, `\r\n`).

    * **`Decode`:** `TestDecode` demonstrates decoding multiple PEM blocks from a single byte slice (`pemData`). It checks the `Type`, `Headers`, and `Bytes` of the decoded `Block`s. The tests with "EMPTY" blocks and "HEADERS" block are important to note. The `TestBadDecode` section confirms how `Decode` should behave with invalid PEM formats – returning `nil` and the original input. The CVE test shows how `Decode` handles potential stack overflow issues.

    * **`Encode` and `EncodeToMemory`:**  `TestEncode` shows a simple case of encoding a `Block` to a byte slice. `EncodeToMemory` is a convenience function for this.

    * **`lineBreaker`:**  The `TestLineBreaker` tests show how this type (likely a `writer`) adds line breaks after every 64 characters, which is standard for PEM.

    * **`Block` struct:**  The `certificate`, `privateKey`, and `privateKey2` variables and the `TestDecode` and `TestEncode` functions reveal the structure of a `Block`: `Type` (string), `Headers` (map[string]string), and `Bytes` ([]byte).

5. **Inferring the Go Language Feature:** Based on the function names (`Encode`, `Decode`), the data format (text-based with specific delimiters), and the presence of headers and data, the core Go language feature being implemented is **PEM (Privacy Enhanced Mail) encoding and decoding.** PEM is a common format for encoding cryptographic keys, certificates, and other data.

6. **Providing Code Examples:**  Now, it's time to create illustrative Go code snippets based on the understanding gained. Focus on demonstrating the core `Encode` and `Decode` functions. Include examples with headers to make it more comprehensive.

7. **Reasoning About Inputs and Outputs:**  For the code examples, it's important to define clear inputs (a `pem.Block` for encoding, PEM-formatted string for decoding) and expected outputs (PEM-formatted string for encoding, a `pem.Block` for decoding).

8. **Command-Line Arguments:**  Carefully review the code. There are *no* command-line arguments being processed in this *test* file. The tests are driven by the Go testing framework. Therefore, the answer must state this clearly.

9. **Common Mistakes:**  Examine the `badPEMTests` and the logic in `TestBadDecode`. These tests highlight common errors users might make when constructing PEM data manually:
    * Incorrect number of dashes in the BEGIN/END lines.
    * Trailing non-whitespace characters.
    * Mismatched BEGIN and END types.
    * Missing spaces in the BEGIN/END lines.
    * Missing newline after headers.

10. **Structuring the Answer in Chinese:**  Finally, organize the findings into a clear and concise Chinese answer, addressing each point of the original request. Use appropriate technical terms in Chinese. Ensure the code examples are correctly formatted and easy to understand.

11. **Review and Refine:**  Read through the entire answer to check for accuracy, completeness, and clarity. Ensure that the Chinese is natural and grammatically correct.

Self-Correction/Refinement during the process:

* Initially, I might have just focused on `Encode` and `Decode`. But the `getLine` and `lineBreaker` tests provide important context about the underlying mechanics. Including an explanation of these adds value.
*  It's crucial to explicitly state that no command-line arguments are processed *in this file*.
*  The common mistakes section directly stems from the `badPEMTests`, making it easy to identify and illustrate.
*  Using the `reflect.DeepEqual` function in the tests is a good point to highlight as a common practice in Go testing.

By following these steps, the provided detailed Chinese answer can be constructed systematically.
这段代码是 Go 语言 `encoding/pem` 包的一部分，专门用于进行 **PEM (Privacy Enhanced Mail)** 格式数据的编码和解码的测试。  它包含了多个测试函数，旨在验证 `encoding/pem` 包的各项功能是否正常工作。

以下是代码中各个部分的功能详解：

**1. `getLine` 函数的测试 (`TestGetLine`)**

* **功能:** `getLine` 函数（虽然在这里只看到了测试，但根据测试推断，它应该是 `encoding/pem` 包内部的一个辅助函数）的功能是从给定的字节切片中提取一行文本。它会识别 `\n`, `\r`, 和 `\r\n` 作为行尾符。
* **测试用例:** `getLineTests` 包含了各种边界情况的输入，例如：
    * 没有换行符的单行字符串。
    * 带有不同换行符的单行字符串。
    * 包含换行符的多行字符串。
    * 以换行符开头的字符串。
    * 包含制表符和空格的字符串。
* **代码推理与示例:**
    ```go
    package main

    import (
        "fmt"
    )

    // 假设的 getLine 函数实现 (实际实现可能在 encoding/pem 内部)
    func getLine(data []byte) (line, rest []byte) {
        for i, b := range data {
            if b == '\n' {
                return data[:i], data[i+1:]
            }
            if b == '\r' {
                if i+1 < len(data) && data[i+1] == '\n' {
                    return data[:i], data[i+2:]
                }
                return data[:i], data[i+1:]
            }
        }
        return data, nil
    }

    func main() {
        input := []byte("abc\r\nd")
        line, rest := getLine(input)
        fmt.Printf("Line: %s\n", string(line))
        fmt.Printf("Rest: %s\n", string(rest))

        input2 := []byte("abc\n")
        line2, rest2 := getLine(input2)
        fmt.Printf("Line2: %s\n", string(line2))
        fmt.Printf("Rest2: %s\n", string(rest2))
    }
    ```
    **假设输入：** `"abc\r\nd"`  **输出：** `Line: abc`, `Rest: d`
    **假设输入：** `"abc\n"`    **输出：** `Line2: abc`, `Rest2: `

**2. `Decode` 函数的测试 (`TestDecode`)**

* **功能:** `Decode` 函数是 `encoding/pem` 包的核心功能，用于解码 PEM 格式的数据。它接收一个字节切片，尝试从中解析出一个 PEM 数据块 (`Block`)，并返回解析出的数据块和剩余未解析的部分。
* **测试用例:** `TestDecode` 使用了预定义的 PEM 数据 `pemData`，其中包含了多个 PEM 数据块（证书、私钥、空块、带有 Header 的块）。测试用例验证了以下几点：
    * 能否正确解码多个连续的 PEM 数据块。
    * 解码后的 `Block` 结构体是否包含正确的 `Type`，`Headers`，和 `Bytes`。
    * 能否正确处理空的 PEM 数据块。
    * 能否正确处理带有自定义 Header 的 PEM 数据块。
    * 解码完成后，剩余的数据是否为空。
    * 能否解码不同格式的私钥 (`pemPrivateKey2`)。
* **代码推理与示例:**
    ```go
    package main

    import (
        "encoding/pem"
        "fmt"
    )

    func main() {
        pemString := `-----BEGIN CERTIFICATE-----
MIIC8jCCA9oCAgkA0QGRSOi4izANBgkqhkiG9w0BAQsFADCBkDELMAkGA1UEBhMC
VVMxCzAJBgNVBAgMAkNBMRMwEQYDVQQHDApTYWNyYW1lbnRvMRMwEQYDVQQKDApT
... (省略证书内容) ...
-----END CERTIFICATE-----`

        block, rest := pem.Decode([]byte(pemString))
        if block != nil {
            fmt.Printf("Decoded Type: %s\n", block.Type)
            fmt.Printf("Decoded Headers: %v\n", block.Headers)
            fmt.Printf("Decoded Bytes (length): %d\n", len(block.Bytes))
            fmt.Printf("Remaining data: %s\n", string(rest))
        } else {
            fmt.Println("Decoding failed")
        }
    }
    ```
    **假设输入：** 一个有效的 PEM 格式的证书字符串。
    **输出：** 打印解码后的 `Type`（"CERTIFICATE"），`Headers`（可能为空），`Bytes` 的长度，以及剩余的数据（应该为空）。

**3. 处理错误的 PEM 数据 (`TestBadDecode`)**

* **功能:** `TestBadDecode` 测试 `Decode` 函数在遇到格式错误的 PEM 数据时的行为。它定义了一系列包含不同错误的 PEM 字符串。
* **测试用例:** `badPEMTests` 包含了各种错误的 PEM 格式，例如：
    * `pemTooFewEndingDashes`: 结尾的短划线数量不足。
    * `pemTooManyEndingDashes`: 结尾的短划线数量过多。
    * `pemTrailingNonWhitespace`: 结尾存在非空白字符。
    * `pemWrongEndingType`: `BEGIN` 和 `END` 的类型不匹配。
    * `pemMissingEndingSpace`: `END` 行缺少空格。
    * `pemRepeatingBegin`:  重复的 `BEGIN` 行。
    * `pemMissingEndLine`:  缺少 `END` 行。
* **预期行为:**  对于这些错误的输入，`Decode` 函数应该返回 `nil` 作为解码后的 `Block`，并且返回的剩余数据应该与原始输入相同，表示解码失败。

**4. 防止 CVE-2022-24675 漏洞的测试 (`TestCVE202224675`)**

* **功能:** 这个测试专门用于验证是否修复了 CVE-2022-24675 漏洞。该漏洞与处理大量重复的 `-----BEGIN -----` 行有关，可能导致栈溢出。
* **测试用例:**  构造一个包含大量重复 `-----BEGIN \n` 的输入。
* **预期行为:** 在修复漏洞后，`Decode` 函数应该能够处理这个输入而不会崩溃，并返回 `nil` 和原始输入。

**5. `Encode` 函数的测试 (`TestEncode`)**

* **功能:** `Encode` 函数将 `Block` 结构体编码成 PEM 格式的字节切片，并写入提供的 `io.Writer`。`EncodeToMemory` 是一个辅助函数，直接将编码结果返回为 `[]byte`。
* **测试用例:** `TestEncode` 使用 `privateKey2` 这个 `Block` 结构体，将其编码，并与预期的 PEM 字符串 `pemPrivateKey2` 进行比较。
* **代码推理与示例:**
    ```go
    package main

    import (
        "bytes"
        "encoding/pem"
        "fmt"
    )

    func main() {
        block := &pem.Block{
            Type:  "MY DATA",
            Headers: map[string]string{
                "Custom-Header": "some value",
            },
            Bytes: []byte("this is my data"),
        }

        var buf bytes.Buffer
        err := pem.Encode(&buf, block)
        if err != nil {
            fmt.Println("Encoding error:", err)
            return
        }
        fmt.Println(buf.String())

        encodedData := pem.EncodeToMemory(block)
        fmt.Println(string(encodedData))
    }
    ```
    **假设输入：** 一个包含 `Type`, `Headers`, 和 `Bytes` 的 `pem.Block` 结构体。
    **输出：**  类似于以下的 PEM 格式字符串：
    ```
    -----BEGIN MY DATA-----
    Custom-Header: some value

    dGhpcyBpcyBteSBkYXRh
    -----END MY DATA-----
    ```

**6. `lineBreaker` 的测试 (`TestLineBreaker`)**

* **功能:** `lineBreaker` 结构体（可能是一个内部的 `io.Writer` 实现）负责在编码 PEM 数据时，每隔 64 个字符插入一个换行符，这是 PEM 格式的规范。
* **测试用例:** `lineBreakerTests` 包含不同长度的输入字符串，测试了 `lineBreaker` 是否能在正确的位置插入换行符。
* **代码推理与示例:**  `lineBreaker` 通常不会直接被用户调用，而是作为 `Encode` 函数内部的一部分工作流程。 它的作用是格式化输出。

**7. Fuzzing 测试 (`TestFuzz`)**

* **功能:** Fuzzing 是一种自动化测试技术，通过生成大量的随机或半随机输入来测试程序的健壮性。`TestFuzz` 使用 `testing/quick` 包来进行属性测试，生成随机的 `Block` 结构体，然后进行编码和解码，验证编码后解码的结果是否与原始数据一致。
* **测试逻辑:**
    * `isBad` 函数判断字符串是否包含不应出现在 PEM Header 中的字符（换行符）或首尾有空格。
    * `testRoundtrip` 函数接收一个 `Block` 结构体，对其进行编码，再解码，然后比较原始的 `Block` 和解码后的 `Block` 是否相等。它还会检查编码解码后是否有剩余数据。为了避免 `quick.Check` 生成不合法的 Header，测试中加入了对 `Type` 和 `Headers` 的校验。
* **优点:** Fuzzing 可以发现一些边界情况和意想不到的错误，这些错误可能很难通过人工编写的测试用例发现。

**8. 性能基准测试 (`BenchmarkEncode`, `BenchmarkDecode`)**

* **功能:** 这两个函数用于衡量 `Encode` 和 `Decode` 函数的性能。它们会执行大量的编码和解码操作，并报告每次操作所花费的时间和处理的数据量。
* **目的:** 帮助开发者了解代码的性能瓶颈，并在修改代码后检查性能是否下降。

**命令行参数处理:**

在这个测试文件中，**没有涉及到任何命令行参数的处理**。这是一个单元测试文件，它的执行是由 Go 的 `testing` 包驱动的，而不是通过命令行参数来控制行为。

**使用者易犯错的点 (基于 `TestBadDecode`):**

1. **错误的 BEGIN/END 行格式:**
   ```
   -----BEGIN CERTIFICATE-----  <-- 正确
   -----BEGIN CERTIFICATE----   <-- 错误：缺少一个短划线
   ----BEGIN CERTIFICATE-----   <-- 错误：缺少一个短划线
   -----END CERTIFICATE-----    <-- 正确
   -----END CERTIFICATE----     <-- 错误
   ----END CERTIFICATE-----     <-- 错误
   ```

2. **BEGIN 和 END 类型不匹配:**
   ```
   -----BEGIN CERTIFICATE-----
   ...
   -----END RSA PRIVATE KEY-----  <-- 错误：类型不匹配
   ```

3. **结尾存在非空白字符:**
   ```
   -----BEGIN CERTIFICATE-----
   ...
   -----END CERTIFICATE-----  . <-- 错误：结尾多了个点
   ```

4. **END 行缺少空格:**
   ```
   -----BEGIN CERTIFICATE-----
   ...
   -----ENDCERTIFICATE-----  <-- 错误：缺少空格
   ```

5. **Header 后缺少换行符:** 虽然在 `TestBadDecode` 中没有直接体现，但在 `pemData` 的例子中，有一个被注释掉的例子展示了如果 Header 后面没有换行符会导致解析失败。这是使用者容易忽略的。

总而言之，这个 `pem_test.go` 文件通过大量的测试用例，细致地验证了 `encoding/pem` 包的编码和解码功能，包括对各种边界情况和错误情况的处理，以及性能表现。它对于确保 `encoding/pem` 包的稳定性和可靠性至关重要。

Prompt: 
```
这是路径为go/src/encoding/pem/pem_test.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
请用中文回答。

"""
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pem

import (
	"bytes"
	"io"
	"reflect"
	"strings"
	"testing"
	"testing/quick"
)

type GetLineTest struct {
	in, out1, out2 string
}

var getLineTests = []GetLineTest{
	{"abc", "abc", ""},
	{"abc\r", "abc\r", ""},
	{"abc\n", "abc", ""},
	{"abc\r\n", "abc", ""},
	{"abc\nd", "abc", "d"},
	{"abc\r\nd", "abc", "d"},
	{"\nabc", "", "abc"},
	{"\r\nabc", "", "abc"},
	{"abc\t \nd", "abc", "d"},
	{"\t abc\nd", "\t abc", "d"},
	{"abc\n\t d", "abc", "\t d"},
	{"abc\nd\t ", "abc", "d\t "},
}

func TestGetLine(t *testing.T) {
	for i, test := range getLineTests {
		x, y := getLine([]byte(test.in))
		if string(x) != test.out1 || string(y) != test.out2 {
			t.Errorf("#%d got:%+v,%+v want:%s,%s", i, x, y, test.out1, test.out2)
		}
	}
}

func TestDecode(t *testing.T) {
	result, remainder := Decode([]byte(pemData))
	if !reflect.DeepEqual(result, certificate) {
		t.Errorf("#0 got:%#v want:%#v", result, certificate)
	}
	result, remainder = Decode(remainder)
	if !reflect.DeepEqual(result, privateKey) {
		t.Errorf("#1 got:%#v want:%#v", result, privateKey)
	}

	isEmpty := func(block *Block) bool {
		return block != nil && block.Type == "EMPTY" && len(block.Headers) == 0 && len(block.Bytes) == 0
	}
	result, remainder = Decode(remainder)
	if !isEmpty(result) {
		t.Errorf("#2 should be empty but got:%#v", result)
	}
	result, remainder = Decode(remainder)
	if !isEmpty(result) {
		t.Errorf("#3 should be empty but got:%#v", result)
	}
	result, remainder = Decode(remainder)
	if !isEmpty(result) {
		t.Errorf("#4 should be empty but got:%#v", result)
	}

	result, remainder = Decode(remainder)
	if result == nil || result.Type != "HEADERS" || len(result.Headers) != 1 {
		t.Errorf("#5 expected single header block but got :%v", result)
	}

	if len(remainder) != 0 {
		t.Errorf("expected nothing remaining of pemData, but found %s", string(remainder))
	}

	result, _ = Decode([]byte(pemPrivateKey2))
	if !reflect.DeepEqual(result, privateKey2) {
		t.Errorf("#2 got:%#v want:%#v", result, privateKey2)
	}
}

const pemTooFewEndingDashes = `
-----BEGIN FOO-----
dGVzdA==
-----END FOO----`

const pemTooManyEndingDashes = `
-----BEGIN FOO-----
dGVzdA==
-----END FOO------`

const pemTrailingNonWhitespace = `
-----BEGIN FOO-----
dGVzdA==
-----END FOO----- .`

const pemWrongEndingType = `
-----BEGIN FOO-----
dGVzdA==
-----END BAR-----`

const pemMissingEndingSpace = `
-----BEGIN FOO-----
dGVzdA==
-----ENDBAR-----`

const pemMissingEndLine = `
-----BEGIN FOO-----
Header: 1`

var pemRepeatingBegin = strings.Repeat("-----BEGIN \n", 10)

var badPEMTests = []struct {
	name  string
	input string
}{
	{
		"too few trailing dashes",
		pemTooFewEndingDashes,
	},
	{
		"too many trailing dashes",
		pemTooManyEndingDashes,
	},
	{
		"trailing non-whitespace",
		pemTrailingNonWhitespace,
	},
	{
		"incorrect ending type",
		pemWrongEndingType,
	},
	{
		"missing ending space",
		pemMissingEndingSpace,
	},
	{
		"repeating begin",
		pemRepeatingBegin,
	},
	{
		"missing end line",
		pemMissingEndLine,
	},
}

func TestBadDecode(t *testing.T) {
	for _, test := range badPEMTests {
		result, rest := Decode([]byte(test.input))
		if result != nil {
			t.Errorf("unexpected success while parsing %q", test.name)
		}
		if string(rest) != test.input {
			t.Errorf("unexpected rest: %q; want = %q", rest, test.input)
		}
	}
}

func TestCVE202224675(t *testing.T) {
	// Prior to CVE-2022-24675, this input would cause a stack overflow.
	input := []byte(strings.Repeat("-----BEGIN \n", 10000000))
	result, rest := Decode(input)
	if result != nil || !bytes.Equal(rest, input) {
		t.Errorf("Encode of %#v decoded as %#v", input, rest)
	}
}

func TestEncode(t *testing.T) {
	r := EncodeToMemory(privateKey2)
	if string(r) != pemPrivateKey2 {
		t.Errorf("got:%s want:%s", r, pemPrivateKey2)
	}
}

type lineBreakerTest struct {
	in, out string
}

const sixtyFourCharString = "0123456789012345678901234567890123456789012345678901234567890123"

var lineBreakerTests = []lineBreakerTest{
	{"", ""},
	{"a", "a\n"},
	{"ab", "ab\n"},
	{sixtyFourCharString, sixtyFourCharString + "\n"},
	{sixtyFourCharString + "X", sixtyFourCharString + "\nX\n"},
	{sixtyFourCharString + sixtyFourCharString, sixtyFourCharString + "\n" + sixtyFourCharString + "\n"},
}

func TestLineBreaker(t *testing.T) {
	for i, test := range lineBreakerTests {
		buf := new(strings.Builder)
		var breaker lineBreaker
		breaker.out = buf
		_, err := breaker.Write([]byte(test.in))
		if err != nil {
			t.Errorf("#%d: error from Write: %s", i, err)
			continue
		}
		err = breaker.Close()
		if err != nil {
			t.Errorf("#%d: error from Close: %s", i, err)
			continue
		}

		if got := buf.String(); got != test.out {
			t.Errorf("#%d: got:%s want:%s", i, got, test.out)
		}
	}

	for i, test := range lineBreakerTests {
		buf := new(strings.Builder)
		var breaker lineBreaker
		breaker.out = buf

		for i := 0; i < len(test.in); i++ {
			_, err := breaker.Write([]byte(test.in[i : i+1]))
			if err != nil {
				t.Errorf("#%d: error from Write (byte by byte): %s", i, err)
				continue
			}
		}
		err := breaker.Close()
		if err != nil {
			t.Errorf("#%d: error from Close (byte by byte): %s", i, err)
			continue
		}

		if got := buf.String(); got != test.out {
			t.Errorf("#%d: (byte by byte) got:%s want:%s", i, got, test.out)
		}
	}
}

func TestFuzz(t *testing.T) {
	// PEM is a text-based format. Assume header fields with leading/trailing spaces
	// or embedded newlines will not round trip correctly and don't need to be tested.
	isBad := func(s string) bool {
		return strings.ContainsAny(s, "\r\n") || strings.TrimSpace(s) != s
	}

	testRoundtrip := func(block Block) bool {
		// Reject bad Type
		// Type with colons will proceed as key/val pair and cause an error.
		if isBad(block.Type) || strings.Contains(block.Type, ":") {
			return true
		}
		for key, val := range block.Headers {
			// Reject bad key/val.
			// Also, keys with colons cannot be encoded, because : is the key: val separator.
			if isBad(key) || isBad(val) || strings.Contains(key, ":") {
				return true
			}
		}

		var buf bytes.Buffer
		if err := Encode(&buf, &block); err != nil {
			t.Errorf("Encode of %#v resulted in error: %s", &block, err)
			return false
		}
		decoded, rest := Decode(buf.Bytes())
		if block.Headers == nil {
			// Encoder supports nil Headers but decoder returns initialized.
			block.Headers = make(map[string]string)
		}
		if block.Bytes == nil {
			// Encoder supports nil Bytes but decoder returns initialized.
			block.Bytes = make([]byte, 0)
		}
		if !reflect.DeepEqual(decoded, &block) {
			t.Errorf("Encode of %#v decoded as %#v", &block, decoded)
			return false
		}
		if len(rest) != 0 {
			t.Errorf("Encode of %#v decoded correctly, but with %x left over", block, rest)
			return false
		}
		return true
	}

	// Explicitly test the empty block.
	if !testRoundtrip(Block{
		Type:    "EMPTY",
		Headers: make(map[string]string),
		Bytes:   []byte{},
	}) {
		return
	}

	quick.Check(testRoundtrip, nil)
}

func BenchmarkEncode(b *testing.B) {
	data := &Block{Bytes: make([]byte, 65536)}
	b.SetBytes(int64(len(data.Bytes)))
	for i := 0; i < b.N; i++ {
		Encode(io.Discard, data)
	}
}

func BenchmarkDecode(b *testing.B) {
	block := &Block{Bytes: make([]byte, 65536)}
	data := EncodeToMemory(block)
	b.SetBytes(int64(len(data)))
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		Decode(data)
	}
}

var pemData = testingKey(`verify return:0
-----BEGIN CERTIFICATE-----
sdlfkjskldfj
  -----BEGIN CERTIFICATE-----
---
Certificate chain
 0 s:/C=AU/ST=Somewhere/L=Someplace/O=Foo Bar/CN=foo.example.com
   i:/C=ZA/O=CA Inc./CN=CA Inc
-----BEGIN CERTIFICATE-----
testing
-----BEGIN CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIID6TCCA1ICAQEwDQYJKoZIhvcNAQEFBQAwgYsxCzAJBgNVBAYTAlVTMRMwEQYD
VQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQHEw1TYW4gRnJhbmNpc2NvMRQwEgYDVQQK
EwtHb29nbGUgSW5jLjEMMAoGA1UECxMDRW5nMQwwCgYDVQQDEwNhZ2wxHTAbBgkq
hkiG9w0BCQEWDmFnbEBnb29nbGUuY29tMB4XDTA5MDkwOTIyMDU0M1oXDTEwMDkw
OTIyMDU0M1owajELMAkGA1UEBhMCQVUxEzARBgNVBAgTClNvbWUtU3RhdGUxITAf
BgNVBAoTGEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDEjMCEGA1UEAxMaZXVyb3Bh
LnNmby5jb3JwLmdvb2dsZS5jb20wggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIK
AoICAQC6pgYt7/EibBDumASF+S0qvqdL/f+nouJw2T1Qc8GmXF/iiUcrsgzh/Fd8
pDhz/T96Qg9IyR4ztuc2MXrmPra+zAuSf5bevFReSqvpIt8Duv0HbDbcqs/XKPfB
uMDe+of7a9GCywvAZ4ZUJcp0thqD9fKTTjUWOBzHY1uNE4RitrhmJCrbBGXbJ249
bvgmb7jgdInH2PU7PT55hujvOoIsQW2osXBFRur4pF1wmVh4W4lTLD6pjfIMUcML
ICHEXEN73PDic8KS3EtNYCwoIld+tpIBjE1QOb1KOyuJBNW6Esw9ALZn7stWdYcE
qAwvv20egN2tEXqj7Q4/1ccyPZc3PQgC3FJ8Be2mtllM+80qf4dAaQ/fWvCtOrQ5
pnfe9juQvCo8Y0VGlFcrSys/MzSg9LJ/24jZVgzQved/Qupsp89wVidwIzjt+WdS
fyWfH0/v1aQLvu5cMYuW//C0W2nlYziL5blETntM8My2ybNARy3ICHxCBv2RNtPI
WQVm+E9/W5rwh2IJR4DHn2LHwUVmT/hHNTdBLl5Uhwr4Wc7JhE7AVqb14pVNz1lr
5jxsp//ncIwftb7mZQ3DF03Yna+jJhpzx8CQoeLT6aQCHyzmH68MrHHT4MALPyUs
Pomjn71GNTtDeWAXibjCgdL6iHACCF6Htbl0zGlG0OAK+bdn0QIDAQABMA0GCSqG
SIb3DQEBBQUAA4GBAOKnQDtqBV24vVqvesL5dnmyFpFPXBn3WdFfwD6DzEb21UVG
5krmJiu+ViipORJPGMkgoL6BjU21XI95VQbun5P8vvg8Z+FnFsvRFY3e1CCzAVQY
ZsUkLw2I7zI/dNlWdB8Xp7v+3w9sX5N3J/WuJ1KOO5m26kRlHQo7EzT3974g
-----END CERTIFICATE-----
 1 s:/C=ZA/O=Ca Inc./CN=CA Inc

-----BEGIN RSA TESTING KEY-----
Proc-Type: 4,ENCRYPTED
DEK-Info: DES-EDE3-CBC,80C7C7A09690757A

eQp5ZkH6CyHBz7BZfUPxyLCCmftsBJ7HlqGb8Ld21cSwnzWZ4/SIlhyrUtsfw7VR
2TTwA+odo9ex7GdxOTaH8oZFumIRoiEjHsk8U7Bhntp+ekkPP79xunnN7hb7hkhr
yGDQZgA7s2cQHQ71v3gwT2BACAft26jCjbM1wgNzBnJ8M0Rzn68YWqaPtdBu8qb/
zVR5JB1mnqvTSbFsfF5yMc6o2WQ9jJCl6KypnMl+BpL+dlvdjYVK4l9lYsB1Hs3d
+zDBbWxos818zzhS8/y6eIfiSG27cqrbhURbmgiSfDXjncK4m/pLcQ7mmBL6mFOr
3Pj4jepzgOiFRL6MKE//h62fZvI1ErYr8VunHEykgKNhChDvb1RO6LEfqKBu+Ivw
TB6fBhW3TCLMnVPYVoYwA+fHNTmZZm8BEonlIMfI+KktjWUg4Oia+NI6vKcPpFox
hSnlGgCtvfEaq5/H4kHJp95eOpnFsLviw2seHNkz/LxJMRP1X428+DpYW/QD/0JU
tJSuC/q9FUHL6RI3u/Asrv8pCb4+D7i1jW/AMIdJTtycOGsbPxQA7yHMWujHmeb1
BTiHcL3s3KrJu1vDVrshvxfnz71KTeNnZH8UbOqT5i7fPGyXtY1XJddcbI/Q6tXf
wHFsZc20TzSdsVLBtwksUacpbDogcEVMctnNrB8FIrB3vZEv9Q0Z1VeY7nmTpF+6
a+z2P7acL7j6A6Pr3+q8P9CPiPC7zFonVzuVPyB8GchGR2hytyiOVpuD9+k8hcuw
ZWAaUoVtWIQ52aKS0p19G99hhb+IVANC4akkdHV4SP8i7MVNZhfUmg==
-----END RSA TESTING KEY-----


-----BEGIN EMPTY-----
-----END EMPTY-----

-----BEGIN EMPTY-----

-----END EMPTY-----

-----BEGIN EMPTY-----


-----END EMPTY-----

# This shouldn't be recognised because of the missing newline after the
headers.
-----BEGIN HEADERS-----
Header: 1
-----END HEADERS-----

# This should be valid, however.
-----BEGIN HEADERS-----
Header: 1

-----END HEADERS-----`)

var certificate = &Block{Type: "CERTIFICATE",
	Headers: map[string]string{},
	Bytes: []uint8{0x30, 0x82, 0x3, 0xe9, 0x30, 0x82, 0x3, 0x52, 0x2, 0x1,
		0x1, 0x30, 0xd, 0x6, 0x9, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0xd,
		0x1, 0x1, 0x5, 0x5, 0x0, 0x30, 0x81, 0x8b, 0x31, 0xb, 0x30,
		0x9, 0x6, 0x3, 0x55, 0x4, 0x6, 0x13, 0x2, 0x55, 0x53, 0x31,
		0x13, 0x30, 0x11, 0x6, 0x3, 0x55, 0x4, 0x8, 0x13, 0xa, 0x43,
		0x61, 0x6c, 0x69, 0x66, 0x6f, 0x72, 0x6e, 0x69, 0x61, 0x31,
		0x16, 0x30, 0x14, 0x6, 0x3, 0x55, 0x4, 0x7, 0x13, 0xd, 0x53,
		0x61, 0x6e, 0x20, 0x46, 0x72, 0x61, 0x6e, 0x63, 0x69, 0x73,
		0x63, 0x6f, 0x31, 0x14, 0x30, 0x12, 0x6, 0x3, 0x55, 0x4, 0xa,
		0x13, 0xb, 0x47, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x20, 0x49,
		0x6e, 0x63, 0x2e, 0x31, 0xc, 0x30, 0xa, 0x6, 0x3, 0x55, 0x4,
		0xb, 0x13, 0x3, 0x45, 0x6e, 0x67, 0x31, 0xc, 0x30, 0xa, 0x6,
		0x3, 0x55, 0x4, 0x3, 0x13, 0x3, 0x61, 0x67, 0x6c, 0x31, 0x1d,
		0x30, 0x1b, 0x6, 0x9, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0xd, 0x1,
		0x9, 0x1, 0x16, 0xe, 0x61, 0x67, 0x6c, 0x40, 0x67, 0x6f, 0x6f,
		0x67, 0x6c, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x30, 0x1e, 0x17,
		0xd, 0x30, 0x39, 0x30, 0x39, 0x30, 0x39, 0x32, 0x32, 0x30,
		0x35, 0x34, 0x33, 0x5a, 0x17, 0xd, 0x31, 0x30, 0x30, 0x39,
		0x30, 0x39, 0x32, 0x32, 0x30, 0x35, 0x34, 0x33, 0x5a, 0x30,
		0x6a, 0x31, 0xb, 0x30, 0x9, 0x6, 0x3, 0x55, 0x4, 0x6, 0x13,
		0x2, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11, 0x6, 0x3, 0x55, 0x4,
		0x8, 0x13, 0xa, 0x53, 0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74, 0x61,
		0x74, 0x65, 0x31, 0x21, 0x30, 0x1f, 0x6, 0x3, 0x55, 0x4, 0xa,
		0x13, 0x18, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x65, 0x74,
		0x20, 0x57, 0x69, 0x64, 0x67, 0x69, 0x74, 0x73, 0x20, 0x50,
		0x74, 0x79, 0x20, 0x4c, 0x74, 0x64, 0x31, 0x23, 0x30, 0x21,
		0x6, 0x3, 0x55, 0x4, 0x3, 0x13, 0x1a, 0x65, 0x75, 0x72, 0x6f,
		0x70, 0x61, 0x2e, 0x73, 0x66, 0x6f, 0x2e, 0x63, 0x6f, 0x72,
		0x70, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x63,
		0x6f, 0x6d, 0x30, 0x82, 0x2, 0x22, 0x30, 0xd, 0x6, 0x9, 0x2a,
		0x86, 0x48, 0x86, 0xf7, 0xd, 0x1, 0x1, 0x1, 0x5, 0x0, 0x3,
		0x82, 0x2, 0xf, 0x0, 0x30, 0x82, 0x2, 0xa, 0x2, 0x82, 0x2, 0x1,
		0x0, 0xba, 0xa6, 0x6, 0x2d, 0xef, 0xf1, 0x22, 0x6c, 0x10, 0xee,
		0x98, 0x4, 0x85, 0xf9, 0x2d, 0x2a, 0xbe, 0xa7, 0x4b, 0xfd,
		0xff, 0xa7, 0xa2, 0xe2, 0x70, 0xd9, 0x3d, 0x50, 0x73, 0xc1,
		0xa6, 0x5c, 0x5f, 0xe2, 0x89, 0x47, 0x2b, 0xb2, 0xc, 0xe1,
		0xfc, 0x57, 0x7c, 0xa4, 0x38, 0x73, 0xfd, 0x3f, 0x7a, 0x42,
		0xf, 0x48, 0xc9, 0x1e, 0x33, 0xb6, 0xe7, 0x36, 0x31, 0x7a,
		0xe6, 0x3e, 0xb6, 0xbe, 0xcc, 0xb, 0x92, 0x7f, 0x96, 0xde,
		0xbc, 0x54, 0x5e, 0x4a, 0xab, 0xe9, 0x22, 0xdf, 0x3, 0xba,
		0xfd, 0x7, 0x6c, 0x36, 0xdc, 0xaa, 0xcf, 0xd7, 0x28, 0xf7,
		0xc1, 0xb8, 0xc0, 0xde, 0xfa, 0x87, 0xfb, 0x6b, 0xd1, 0x82,
		0xcb, 0xb, 0xc0, 0x67, 0x86, 0x54, 0x25, 0xca, 0x74, 0xb6,
		0x1a, 0x83, 0xf5, 0xf2, 0x93, 0x4e, 0x35, 0x16, 0x38, 0x1c,
		0xc7, 0x63, 0x5b, 0x8d, 0x13, 0x84, 0x62, 0xb6, 0xb8, 0x66,
		0x24, 0x2a, 0xdb, 0x4, 0x65, 0xdb, 0x27, 0x6e, 0x3d, 0x6e,
		0xf8, 0x26, 0x6f, 0xb8, 0xe0, 0x74, 0x89, 0xc7, 0xd8, 0xf5,
		0x3b, 0x3d, 0x3e, 0x79, 0x86, 0xe8, 0xef, 0x3a, 0x82, 0x2c,
		0x41, 0x6d, 0xa8, 0xb1, 0x70, 0x45, 0x46, 0xea, 0xf8, 0xa4,
		0x5d, 0x70, 0x99, 0x58, 0x78, 0x5b, 0x89, 0x53, 0x2c, 0x3e,
		0xa9, 0x8d, 0xf2, 0xc, 0x51, 0xc3, 0xb, 0x20, 0x21, 0xc4, 0x5c,
		0x43, 0x7b, 0xdc, 0xf0, 0xe2, 0x73, 0xc2, 0x92, 0xdc, 0x4b,
		0x4d, 0x60, 0x2c, 0x28, 0x22, 0x57, 0x7e, 0xb6, 0x92, 0x1,
		0x8c, 0x4d, 0x50, 0x39, 0xbd, 0x4a, 0x3b, 0x2b, 0x89, 0x4,
		0xd5, 0xba, 0x12, 0xcc, 0x3d, 0x0, 0xb6, 0x67, 0xee, 0xcb,
		0x56, 0x75, 0x87, 0x4, 0xa8, 0xc, 0x2f, 0xbf, 0x6d, 0x1e, 0x80,
		0xdd, 0xad, 0x11, 0x7a, 0xa3, 0xed, 0xe, 0x3f, 0xd5, 0xc7,
		0x32, 0x3d, 0x97, 0x37, 0x3d, 0x8, 0x2, 0xdc, 0x52, 0x7c, 0x5,
		0xed, 0xa6, 0xb6, 0x59, 0x4c, 0xfb, 0xcd, 0x2a, 0x7f, 0x87,
		0x40, 0x69, 0xf, 0xdf, 0x5a, 0xf0, 0xad, 0x3a, 0xb4, 0x39,
		0xa6, 0x77, 0xde, 0xf6, 0x3b, 0x90, 0xbc, 0x2a, 0x3c, 0x63,
		0x45, 0x46, 0x94, 0x57, 0x2b, 0x4b, 0x2b, 0x3f, 0x33, 0x34,
		0xa0, 0xf4, 0xb2, 0x7f, 0xdb, 0x88, 0xd9, 0x56, 0xc, 0xd0,
		0xbd, 0xe7, 0x7f, 0x42, 0xea, 0x6c, 0xa7, 0xcf, 0x70, 0x56,
		0x27, 0x70, 0x23, 0x38, 0xed, 0xf9, 0x67, 0x52, 0x7f, 0x25,
		0x9f, 0x1f, 0x4f, 0xef, 0xd5, 0xa4, 0xb, 0xbe, 0xee, 0x5c,
		0x31, 0x8b, 0x96, 0xff, 0xf0, 0xb4, 0x5b, 0x69, 0xe5, 0x63,
		0x38, 0x8b, 0xe5, 0xb9, 0x44, 0x4e, 0x7b, 0x4c, 0xf0, 0xcc,
		0xb6, 0xc9, 0xb3, 0x40, 0x47, 0x2d, 0xc8, 0x8, 0x7c, 0x42, 0x6,
		0xfd, 0x91, 0x36, 0xd3, 0xc8, 0x59, 0x5, 0x66, 0xf8, 0x4f,
		0x7f, 0x5b, 0x9a, 0xf0, 0x87, 0x62, 0x9, 0x47, 0x80, 0xc7,
		0x9f, 0x62, 0xc7, 0xc1, 0x45, 0x66, 0x4f, 0xf8, 0x47, 0x35,
		0x37, 0x41, 0x2e, 0x5e, 0x54, 0x87, 0xa, 0xf8, 0x59, 0xce,
		0xc9, 0x84, 0x4e, 0xc0, 0x56, 0xa6, 0xf5, 0xe2, 0x95, 0x4d,
		0xcf, 0x59, 0x6b, 0xe6, 0x3c, 0x6c, 0xa7, 0xff, 0xe7, 0x70,
		0x8c, 0x1f, 0xb5, 0xbe, 0xe6, 0x65, 0xd, 0xc3, 0x17, 0x4d,
		0xd8, 0x9d, 0xaf, 0xa3, 0x26, 0x1a, 0x73, 0xc7, 0xc0, 0x90,
		0xa1, 0xe2, 0xd3, 0xe9, 0xa4, 0x2, 0x1f, 0x2c, 0xe6, 0x1f,
		0xaf, 0xc, 0xac, 0x71, 0xd3, 0xe0, 0xc0, 0xb, 0x3f, 0x25, 0x2c,
		0x3e, 0x89, 0xa3, 0x9f, 0xbd, 0x46, 0x35, 0x3b, 0x43, 0x79,
		0x60, 0x17, 0x89, 0xb8, 0xc2, 0x81, 0xd2, 0xfa, 0x88, 0x70,
		0x2, 0x8, 0x5e, 0x87, 0xb5, 0xb9, 0x74, 0xcc, 0x69, 0x46, 0xd0,
		0xe0, 0xa, 0xf9, 0xb7, 0x67, 0xd1, 0x2, 0x3, 0x1, 0x0, 0x1,
		0x30, 0xd, 0x6, 0x9, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0xd, 0x1,
		0x1, 0x5, 0x5, 0x0, 0x3, 0x81, 0x81, 0x0, 0xe2, 0xa7, 0x40,
		0x3b, 0x6a, 0x5, 0x5d, 0xb8, 0xbd, 0x5a, 0xaf, 0x7a, 0xc2,
		0xf9, 0x76, 0x79, 0xb2, 0x16, 0x91, 0x4f, 0x5c, 0x19, 0xf7,
		0x59, 0xd1, 0x5f, 0xc0, 0x3e, 0x83, 0xcc, 0x46, 0xf6, 0xd5,
		0x45, 0x46, 0xe6, 0x4a, 0xe6, 0x26, 0x2b, 0xbe, 0x56, 0x28,
		0xa9, 0x39, 0x12, 0x4f, 0x18, 0xc9, 0x20, 0xa0, 0xbe, 0x81,
		0x8d, 0x4d, 0xb5, 0x5c, 0x8f, 0x79, 0x55, 0x6, 0xee, 0x9f,
		0x93, 0xfc, 0xbe, 0xf8, 0x3c, 0x67, 0xe1, 0x67, 0x16, 0xcb,
		0xd1, 0x15, 0x8d, 0xde, 0xd4, 0x20, 0xb3, 0x1, 0x54, 0x18,
		0x66, 0xc5, 0x24, 0x2f, 0xd, 0x88, 0xef, 0x32, 0x3f, 0x74,
		0xd9, 0x56, 0x74, 0x1f, 0x17, 0xa7, 0xbb, 0xfe, 0xdf, 0xf,
		0x6c, 0x5f, 0x93, 0x77, 0x27, 0xf5, 0xae, 0x27, 0x52, 0x8e,
		0x3b, 0x99, 0xb6, 0xea, 0x44, 0x65, 0x1d, 0xa, 0x3b, 0x13,
		0x34, 0xf7, 0xf7, 0xbe, 0x20,
	},
}

var privateKey = &Block{Type: "RSA PRIVATE KEY",
	Headers: map[string]string{"DEK-Info": "DES-EDE3-CBC,80C7C7A09690757A", "Proc-Type": "4,ENCRYPTED"},
	Bytes: []uint8{0x79, 0xa, 0x79, 0x66, 0x41, 0xfa, 0xb,
		0x21, 0xc1, 0xcf, 0xb0, 0x59, 0x7d, 0x43, 0xf1, 0xc8, 0xb0,
		0x82, 0x99, 0xfb, 0x6c, 0x4, 0x9e, 0xc7, 0x96, 0xa1, 0x9b,
		0xf0, 0xb7, 0x76, 0xd5, 0xc4, 0xb0, 0x9f, 0x35, 0x99, 0xe3,
		0xf4, 0x88, 0x96, 0x1c, 0xab, 0x52, 0xdb, 0x1f, 0xc3, 0xb5,
		0x51, 0xd9, 0x34, 0xf0, 0x3, 0xea, 0x1d, 0xa3, 0xd7, 0xb1,
		0xec, 0x67, 0x71, 0x39, 0x36, 0x87, 0xf2, 0x86, 0x45, 0xba,
		0x62, 0x11, 0xa2, 0x21, 0x23, 0x1e, 0xc9, 0x3c, 0x53, 0xb0,
		0x61, 0x9e, 0xda, 0x7e, 0x7a, 0x49, 0xf, 0x3f, 0xbf, 0x71,
		0xba, 0x79, 0xcd, 0xee, 0x16, 0xfb, 0x86, 0x48, 0x6b, 0xc8,
		0x60, 0xd0, 0x66, 0x0, 0x3b, 0xb3, 0x67, 0x10, 0x1d, 0xe,
		0xf5, 0xbf, 0x78, 0x30, 0x4f, 0x60, 0x40, 0x8, 0x7, 0xed,
		0xdb, 0xa8, 0xc2, 0x8d, 0xb3, 0x35, 0xc2, 0x3, 0x73, 0x6,
		0x72, 0x7c, 0x33, 0x44, 0x73, 0x9f, 0xaf, 0x18, 0x5a, 0xa6,
		0x8f, 0xb5, 0xd0, 0x6e, 0xf2, 0xa6, 0xff, 0xcd, 0x54, 0x79,
		0x24, 0x1d, 0x66, 0x9e, 0xab, 0xd3, 0x49, 0xb1, 0x6c, 0x7c,
		0x5e, 0x72, 0x31, 0xce, 0xa8, 0xd9, 0x64, 0x3d, 0x8c, 0x90,
		0xa5, 0xe8, 0xac, 0xa9, 0x9c, 0xc9, 0x7e, 0x6, 0x92, 0xfe,
		0x76, 0x5b, 0xdd, 0x8d, 0x85, 0x4a, 0xe2, 0x5f, 0x65, 0x62,
		0xc0, 0x75, 0x1e, 0xcd, 0xdd, 0xfb, 0x30, 0xc1, 0x6d, 0x6c,
		0x68, 0xb3, 0xcd, 0x7c, 0xcf, 0x38, 0x52, 0xf3, 0xfc, 0xba,
		0x78, 0x87, 0xe2, 0x48, 0x6d, 0xbb, 0x72, 0xaa, 0xdb, 0x85,
		0x44, 0x5b, 0x9a, 0x8, 0x92, 0x7c, 0x35, 0xe3, 0x9d, 0xc2,
		0xb8, 0x9b, 0xfa, 0x4b, 0x71, 0xe, 0xe6, 0x98, 0x12, 0xfa,
		0x98, 0x53, 0xab, 0xdc, 0xf8, 0xf8, 0x8d, 0xea, 0x73, 0x80,
		0xe8, 0x85, 0x44, 0xbe, 0x8c, 0x28, 0x4f, 0xff, 0x87, 0xad,
		0x9f, 0x66, 0xf2, 0x35, 0x12, 0xb6, 0x2b, 0xf1, 0x5b, 0xa7,
		0x1c, 0x4c, 0xa4, 0x80, 0xa3, 0x61, 0xa, 0x10, 0xef, 0x6f,
		0x54, 0x4e, 0xe8, 0xb1, 0x1f, 0xa8, 0xa0, 0x6e, 0xf8, 0x8b,
		0xf0, 0x4c, 0x1e, 0x9f, 0x6, 0x15, 0xb7, 0x4c, 0x22, 0xcc,
		0x9d, 0x53, 0xd8, 0x56, 0x86, 0x30, 0x3, 0xe7, 0xc7, 0x35,
		0x39, 0x99, 0x66, 0x6f, 0x1, 0x12, 0x89, 0xe5, 0x20, 0xc7,
		0xc8, 0xf8, 0xa9, 0x2d, 0x8d, 0x65, 0x20, 0xe0, 0xe8, 0x9a,
		0xf8, 0xd2, 0x3a, 0xbc, 0xa7, 0xf, 0xa4, 0x5a, 0x31, 0x85,
		0x29, 0xe5, 0x1a, 0x0, 0xad, 0xbd, 0xf1, 0x1a, 0xab, 0x9f,
		0xc7, 0xe2, 0x41, 0xc9, 0xa7, 0xde, 0x5e, 0x3a, 0x99, 0xc5,
		0xb0, 0xbb, 0xe2, 0xc3, 0x6b, 0x1e, 0x1c, 0xd9, 0x33, 0xfc,
		0xbc, 0x49, 0x31, 0x13, 0xf5, 0x5f, 0x8d, 0xbc, 0xf8, 0x3a,
		0x58, 0x5b, 0xf4, 0x3, 0xff, 0x42, 0x54, 0xb4, 0x94, 0xae,
		0xb, 0xfa, 0xbd, 0x15, 0x41, 0xcb, 0xe9, 0x12, 0x37, 0xbb,
		0xf0, 0x2c, 0xae, 0xff, 0x29, 0x9, 0xbe, 0x3e, 0xf, 0xb8,
		0xb5, 0x8d, 0x6f, 0xc0, 0x30, 0x87, 0x49, 0x4e, 0xdc, 0x9c,
		0x38, 0x6b, 0x1b, 0x3f, 0x14, 0x0, 0xef, 0x21, 0xcc, 0x5a,
		0xe8, 0xc7, 0x99, 0xe6, 0xf5, 0x5, 0x38, 0x87, 0x70, 0xbd,
		0xec, 0xdc, 0xaa, 0xc9, 0xbb, 0x5b, 0xc3, 0x56, 0xbb, 0x21,
		0xbf, 0x17, 0xe7, 0xcf, 0xbd, 0x4a, 0x4d, 0xe3, 0x67, 0x64,
		0x7f, 0x14, 0x6c, 0xea, 0x93, 0xe6, 0x2e, 0xdf, 0x3c, 0x6c,
		0x97, 0xb5, 0x8d, 0x57, 0x25, 0xd7, 0x5c, 0x6c, 0x8f, 0xd0,
		0xea, 0xd5, 0xdf, 0xc0, 0x71, 0x6c, 0x65, 0xcd, 0xb4, 0x4f,
		0x34, 0x9d, 0xb1, 0x52, 0xc1, 0xb7, 0x9, 0x2c, 0x51, 0xa7,
		0x29, 0x6c, 0x3a, 0x20, 0x70, 0x45, 0x4c, 0x72, 0xd9, 0xcd,
		0xac, 0x1f, 0x5, 0x22, 0xb0, 0x77, 0xbd, 0x91, 0x2f, 0xf5,
		0xd, 0x19, 0xd5, 0x57, 0x98, 0xee, 0x79, 0x93, 0xa4, 0x5f,
		0xba, 0x6b, 0xec, 0xf6, 0x3f, 0xb6, 0x9c, 0x2f, 0xb8, 0xfa,
		0x3, 0xa3, 0xeb, 0xdf, 0xea, 0xbc, 0x3f, 0xd0, 0x8f, 0x88,
		0xf0, 0xbb, 0xcc, 0x5a, 0x27, 0x57, 0x3b, 0x95, 0x3f, 0x20,
		0x7c, 0x19, 0xc8, 0x46, 0x47, 0x68, 0x72, 0xb7, 0x28, 0x8e,
		0x56, 0x9b, 0x83, 0xf7, 0xe9, 0x3c, 0x85, 0xcb, 0xb0, 0x65,
		0x60, 0x1a, 0x52, 0x85, 0x6d, 0x58, 0x84, 0x39, 0xd9, 0xa2,
		0x92, 0xd2, 0x9d, 0x7d, 0x1b, 0xdf, 0x61, 0x85, 0xbf, 0x88,
		0x54, 0x3, 0x42, 0xe1, 0xa9, 0x24, 0x74, 0x75, 0x78, 0x48,
		0xff, 0x22, 0xec, 0xc5, 0x4d, 0x66, 0x17, 0xd4, 0x9a,
	},
}

var privateKey2 = &Block{
	Type: "RSA PRIVATE KEY",
	Headers: map[string]string{
		"Proc-Type":      "4,ENCRYPTED",
		"DEK-Info":       "AES-128-CBC,BFCD243FEDBB40A4AA6DDAA1335473A4",
		"Content-Domain": "RFC822",
	},
	Bytes: []uint8{
		0xa8, 0x35, 0xcc, 0x2b, 0xb9, 0xcb, 0x21, 0xab, 0xc0,
		0x9d, 0x76, 0x61, 0x0, 0xf4, 0x81, 0xad, 0x69, 0xd2,
		0xc0, 0x42, 0x41, 0x3b, 0xe4, 0x3c, 0xaf, 0x59, 0x5e,
		0x6d, 0x2a, 0x3c, 0x9c, 0xa1, 0xa4, 0x5e, 0x68, 0x37,
		0xc4, 0x8c, 0x70, 0x1c, 0xa9, 0x18, 0xe6, 0xc2, 0x2b,
		0x8a, 0x91, 0xdc, 0x2d, 0x1f, 0x8, 0x23, 0x39, 0xf1,
		0x4b, 0x8b, 0x1b, 0x2f, 0x46, 0xb, 0xb2, 0x26, 0xba,
		0x4f, 0x40, 0x80, 0x39, 0xc4, 0xb1, 0xcb, 0x3b, 0xb4,
		0x65, 0x3f, 0x1b, 0xb2, 0xf7, 0x8, 0xd2, 0xc6, 0xd5,
		0xa8, 0x9f, 0x23, 0x69, 0xb6, 0x3d, 0xf9, 0xac, 0x1c,
		0xb3, 0x13, 0x87, 0x64, 0x4, 0x37, 0xdb, 0x40, 0xc8,
		0x82, 0xc, 0xd0, 0xf8, 0x21, 0x7c, 0xdc, 0xbd, 0x9, 0x4,
		0x20, 0x16, 0xb0, 0x97, 0xe2, 0x6d, 0x56, 0x1d, 0xe3,
		0xec, 0xf0, 0xfc, 0xe2, 0x56, 0xad, 0xa4, 0x3, 0x70,
		0x6d, 0x63, 0x3c, 0x1, 0xbe, 0x3e, 0x28, 0x38, 0x6f,
		0xc0, 0xe6, 0xfd, 0x85, 0xd1, 0x53, 0xa8, 0x9b, 0xcb,
		0xd4, 0x4, 0xb1, 0x73, 0xb9, 0x73, 0x32, 0xd6, 0x7a,
		0xc6, 0x29, 0x25, 0xa5, 0xda, 0x17, 0x93, 0x7a, 0x10,
		0xe8, 0x41, 0xfb, 0xa5, 0x17, 0x20, 0xf8, 0x4e, 0xe9,
		0xe3, 0x8f, 0x51, 0x20, 0x13, 0xbb, 0xde, 0xb7, 0x93,
		0xae, 0x13, 0x8a, 0xf6, 0x9, 0xf4, 0xa6, 0x41, 0xe0,
		0x2b, 0x51, 0x1a, 0x30, 0x38, 0xd, 0xb1, 0x3b, 0x67,
		0x87, 0x64, 0xf5, 0xca, 0x32, 0x67, 0xd1, 0xc8, 0xa5,
		0x3d, 0x23, 0x72, 0xc4, 0x6, 0xaf, 0x8f, 0x7b, 0x26,
		0xac, 0x3c, 0x75, 0x91, 0xa1, 0x0, 0x13, 0xc6, 0x5c,
		0x49, 0xd5, 0x3c, 0xe7, 0xb2, 0xb2, 0x99, 0xe0, 0xd5,
		0x25, 0xfa, 0xe2, 0x12, 0x80, 0x37, 0x85, 0xcf, 0x92,
		0xca, 0x1b, 0x9f, 0xf3, 0x4e, 0xd8, 0x80, 0xef, 0x3c,
		0xce, 0xcd, 0xf5, 0x90, 0x9e, 0xf9, 0xa7, 0xb2, 0xc,
		0x49, 0x4, 0xf1, 0x9, 0x8f, 0xea, 0x63, 0xd2, 0x70,
		0xbb, 0x86, 0xbf, 0x34, 0xab, 0xb2, 0x3, 0xb1, 0x59,
		0x33, 0x16, 0x17, 0xb0, 0xdb, 0x77, 0x38, 0xf4, 0xb4,
		0x94, 0xb, 0x25, 0x16, 0x7e, 0x22, 0xd4, 0xf9, 0x22,
		0xb9, 0x78, 0xa3, 0x4, 0x84, 0x4, 0xd2, 0xda, 0x84,
		0x2d, 0x63, 0xdd, 0xf8, 0x50, 0x6a, 0xf6, 0xe3, 0xf5,
		0x65, 0x40, 0x7c, 0xa9,
	},
}

var pemPrivateKey2 = testingKey(`-----BEGIN RSA TESTING KEY-----
Proc-Type: 4,ENCRYPTED
Content-Domain: RFC822
DEK-Info: AES-128-CBC,BFCD243FEDBB40A4AA6DDAA1335473A4

qDXMK7nLIavAnXZhAPSBrWnSwEJBO+Q8r1lebSo8nKGkXmg3xIxwHKkY5sIripHc
LR8IIznxS4sbL0YLsia6T0CAOcSxyzu0ZT8bsvcI0sbVqJ8jabY9+awcsxOHZAQ3
20DIggzQ+CF83L0JBCAWsJfibVYd4+zw/OJWraQDcG1jPAG+Pig4b8Dm/YXRU6ib
y9QEsXO5czLWesYpJaXaF5N6EOhB+6UXIPhO6eOPUSATu963k64TivYJ9KZB4CtR
GjA4DbE7Z4dk9coyZ9HIpT0jcsQGr497Jqw8dZGhABPGXEnVPOeyspng1SX64hKA
N4XPksobn/NO2IDvPM7N9ZCe+aeyDEkE8QmP6mPScLuGvzSrsgOxWTMWF7Dbdzj0
tJQLJRZ+ItT5Irl4owSEBNLahC1j3fhQavbj9WVAfKk=
-----END RSA TESTING KEY-----
`)

func TestBadEncode(t *testing.T) {
	b := &Block{Type: "BAD", Headers: map[string]string{"X:Y": "Z"}}
	var buf bytes.Buffer
	if err := Encode(&buf, b); err == nil {
		t.Fatalf("Encode did not report invalid header")
	}
	if buf.Len() != 0 {
		t.Fatalf("Encode wrote data before reporting invalid header")
	}
	if data := EncodeToMemory(b); data != nil {
		t.Fatalf("EncodeToMemory returned non-nil data")
	}
}

func testingKey(s string) string { return strings.ReplaceAll(s, "TESTING KEY", "PRIVATE KEY") }

"""



```
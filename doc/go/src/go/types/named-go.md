Response:
My thinking process to answer the request about `go/src/go/types/named.go` went something like this:

1. **Understand the Core Request:** The request asks for the functionality of `named.go`, its role in the Go language, code examples, command-line interaction (if any), and potential pitfalls for users.

2. **Analyze the File Header and Comments:** The initial comments are crucial. They immediately highlight the central theme: **lazy type checking for named types**, especially when dealing with recursion, methods spread across declarations, generics, and loading from export data. The comments emphasize the distinction between "LHS" (identity) and "RHS" (details) information. The different ways a named type can be constructed (type-checked, loaded eagerly/lazily, instantiated) are also key. The concepts of "instantiated," "declared," "resolved," and "expanded" provide a vocabulary for understanding the file. The discussion of concurrency and the `sync.Mutex` indicates thread safety is a concern.

3. **Identify the Central Data Structure: `Named`:**  The `Named` struct is the heart of the file. I need to break down its fields and what they represent:
    * `check *Checker`:  Indicates if type checking is in progress.
    * `obj *TypeName`:  The identifier for the named type.
    * `fromRHS Type`: Used for cycle detection.
    * `inst *instance`:  Information specific to instantiated types.
    * `mu sync.Mutex`: Guards access to the following fields for concurrency safety.
    * `state_ uint32`: Tracks the progress of type resolution.
    * `underlying Type`: The actual type being named (struct, interface, etc.).
    * `tparams *TypeParamList`: Type parameters for generic types.
    * `methods []*Func`: Methods associated with the type.
    * `loader func(*Named) ...`:  A function to load type information lazily.

4. **Understand the `instance` Struct:** This is a substructure of `Named` and is essential for understanding how generics are handled:
    * `orig *Named`: The original generic type.
    * `targs *TypeList`: The concrete type arguments used for instantiation.
    * `expandedMethods int`: Tracks how many methods have been specialized for the instance.
    * `ctxt *Context`:  Used to prevent infinite recursion during instantiation.

5. **Deconstruct Key Functions:** I need to go through the important functions and summarize their roles:
    * `NewNamed`: Creates a new named type (for non-generic types).
    * `resolve`:  The core function for loading or computing the RHS information (underlying type, methods, type parameters). This is where lazy loading and expansion happen.
    * `newNamedInstance`: Creates an instance of a generic type.
    * `Obj`, `Origin`, `TypeParams`, `TypeArgs`: Accessors for the `Named` type's properties.
    * `NumMethods`, `Method`: Functions to access methods, handling lazy expansion for instances.
    * `SetTypeParams`, `SetUnderlying`, `AddMethod`: Mutators for non-instantiated types.
    * `Underlying`: Retrieves the underlying type, resolving aliases.
    * `expandUnderlying`, `expandMethod`:  The logic for specializing generic types and methods based on type arguments.

6. **Infer Go Language Features:** Based on the code and comments, the primary Go language features being implemented are:
    * **Named Types:**  The fundamental concept the file is about.
    * **Generic Types (Type Parameters):** The presence of `TypeParams`, `TypeArgs`, `instance`, and the expansion logic clearly points to generics.
    * **Methods:** The `methods` field and related functions indicate support for methods associated with types.
    * **Type Aliases:**  Mentioned in the comments and the `Unalias` function.
    * **Recursive Types:** The comments explicitly discuss handling recursive definitions.
    * **Lazy Loading/Evaluation:** A key theme, particularly for generics and loading from export data.

7. **Create Go Code Examples:**  For each inferred feature, I need to create simple, illustrative Go code examples:
    * **Named Type:** A basic struct definition.
    * **Generic Type:** A struct with a type parameter.
    * **Instantiated Generic Type:** Creating a concrete type from the generic one.
    * **Method on a Named Type:** A simple method.
    * **Method on a Generic Type:** A method that uses the type parameter.
    * **Type Alias:** A basic type alias.
    * **Recursive Type:**  A struct that refers to itself.

8. **Address Command-Line Arguments:** The file itself doesn't handle command-line arguments. The header comment mentions it's generated by `go test`, suggesting it's part of the internal type-checking process. So, the relevant interaction is through the `go` toolchain (compilation, testing).

9. **Identify Potential User Mistakes:** Based on the complexity of lazy loading and generics, potential mistakes include:
    * **Comparing Instances Incorrectly:** Using `==` instead of `types.Identical`.
    * **Accessing Underlying Types Too Early:**  Potentially relying on information being available before the type is fully resolved (though this is mostly handled internally).

10. **Structure the Answer:** Organize the information logically, using clear headings and bullet points. Start with a high-level summary, then delve into the details of the `Named` struct, key functions, implemented features, code examples, command-line interaction, and potential pitfalls. Use clear and concise language.

11. **Review and Refine:**  Read through the entire answer to ensure accuracy, completeness, and clarity. Check that the code examples are correct and demonstrate the intended points.

By following these steps, I can systematically analyze the provided Go code and generate a comprehensive and accurate answer to the user's request. The key is to focus on the core purpose of the file, the data structures it uses, and the Go language features it enables.

这段代码是 Go 语言 `go/types` 包中 `named.go` 文件的一部分，它主要负责 **表示和管理命名类型 (Named types)**。由于 Go 语言支持类型别名和泛型，命名类型的处理变得比较复杂，这段代码的核心目标就是有效地、特别是**延迟地**处理这些复杂性。

以下是它的主要功能：

**1. 表示命名类型:**

*  `Named` 结构体是核心，它代表了一个被命名的类型，例如通过 `type MyInt int` 声明的 `MyInt`，或者泛型类型的实例化。
*  它包含了关于命名类型的各种信息，例如类型名 (`obj`)、底层类型 (`underlying`)、类型参数 (`tparams`)、方法 (`methods`) 等。
*  对于泛型实例化的类型，它会使用 `instance` 结构体来存储原始泛型类型 (`orig`) 和类型实参 (`targs`)。

**2. 延迟类型检查和解析:**

*  **解决循环依赖:**  Go 语言允许类型之间相互引用，例如：
   ```go
   type A struct { b *B }
   type B struct { a *A }
   ```
   为了处理这种情况，`Named` 类型在创建时可能只包含部分信息，例如类型名，而底层类型和方法可能在后续需要时才进行解析。
*  **处理泛型实例化:** 泛型类型的实例化需要将类型参数替换为类型实参。这个过程也是延迟的，只有在真正需要时才会发生。
*  **从导出数据加载:** 当从编译好的包中加载类型信息时，为了提高效率，某些信息（例如方法和底层类型）可能会被延迟加载。

**3. 管理泛型类型和实例化:**

*  `TypeParams()` 和 `SetTypeParams()` 用于获取和设置泛型类型的类型参数。
*  `TypeArgs()` 用于获取泛型实例化类型的类型实参。
*  `Origin()` 返回泛型实例化类型的原始泛型类型。
*  `newNamedInstance()` 创建泛型类型的实例。
*  `expandUnderlying()` 和 `expandMethod()` 负责将泛型类型的底层类型和方法根据类型实参进行展开。

**4. 管理类型方法:**

*  `methods` 字段存储了命名类型声明的方法。
*  `NumMethods()` 返回方法的数量。
*  `Method(i)` 返回指定索引的方法，对于泛型实例化类型，方法会进行延迟展开。
*  `AddMethod()` 用于向命名类型添加方法。

**5. 状态管理和并发安全:**

*  `state_` 字段使用原子操作来跟踪命名类型的解析状态（例如，是否已解析底层类型和方法）。
*  `mu sync.Mutex` 用于保护某些可能并发访问的字段，确保在多线程环境下的安全性。

**可以推理出它是什么 Go 语言功能的实现：**

基于代码中的 `TypeParams`, `TypeArgs`, `instance`, `expandUnderlying`, `expandMethod` 等字段和方法，可以推断出这段代码是 **Go 语言泛型 (Generics)** 功能实现的关键部分。它负责表示泛型类型和它们的实例化，并进行必要的类型替换和方法展开。

**Go 代码举例说明泛型功能的实现：**

```go
package main

import "fmt"

type MyGeneric[T any] struct {
	value T
}

func (g MyGeneric[T]) GetValue() T {
	return g.value
}

func main() {
	// 声明一个泛型类型
	var genInt MyGeneric[int]
	genInt.value = 10
	fmt.Println(genInt.GetValue()) // 输出: 10

	// 实例化泛型类型
	var genString MyGeneric[string]
	genString.value = "hello"
	fmt.Println(genString.GetValue()) // 输出: hello
}
```

**代码推理：**

假设在类型检查 `main` 包中的 `MyGeneric[int]` 实例化时，`newNamedInstance` 函数会被调用，`orig` 会指向 `MyGeneric[T]` 的 `Named` 实例，`targs` 会是 `[]types.Type{types.Typ[types.Int]}`。 当调用 `genInt.GetValue()` 时，`Method` 方法会被调用，由于 `MyGeneric[int]` 是一个实例化的类型，`expandMethod` 可能会被调用，它会根据类型实参 `int` 替换 `GetValue()` 方法中 `T` 的类型。

**假设输入和输出：**

* **输入 (类型检查 `MyGeneric[int]`):**
    * `orig`: 指向表示 `MyGeneric[T]` 的 `Named` 结构体。
    * `targs`: 包含 `types.Typ[types.Int]` 的 `TypeList`。
* **输出 (调用 `genInt.GetValue()` 后的方法类型):**
    * `GetValue()` 方法的签名中的类型参数 `T` 将被替换为 `int`。

**命令行参数的具体处理：**

这段代码本身并不直接处理命令行参数。它是 `go/types` 包内部的一部分，负责类型系统的核心逻辑。命令行参数的处理通常发生在 `go` 工具链的其他部分，例如 `go build` 或 `go test` 命令的解析和执行。

**使用者易犯错的点：**

* **比较泛型实例：**  由于泛型实例化可能产生不同的 `Named` 实例（即使它们代表相同的类型），直接使用 `==` 比较这些实例可能会得到错误的结果。应该使用 `types.Identical()` 函数来比较类型是否相同。

   ```go
   package main

   import (
       "fmt"
       "go/types"
   )

   type MyGeneric[T any] struct{}

   func main() {
       type1 := types.NewNamed(types.NewTypeName(0, nil, "MyGenericInt1", nil), nil, nil)
       type2 := types.NewNamed(types.NewTypeName(0, nil, "MyGenericInt2", nil), nil, nil)

       // 假设 type1 和 type2 是通过不同的实例化过程创建的 MyGeneric[int] 实例
       // (实际场景更复杂，这里简化说明)

       // 错误的比较方式
       // fmt.Println(type1 == type2) // 可能会输出 false

       // 正确的比较方式
       fmt.Println(types.Identical(type1, type2)) // 应该输出 true，如果它们都代表 MyGeneric[int]
   }
   ```

总之，`go/src/go/types/named.go` 是 Go 语言类型系统中一个至关重要的部分，它巧妙地处理了命名类型、泛型以及类型之间的复杂关系，并通过延迟加载和状态管理提高了效率和应对了并发场景。理解它的功能有助于更深入地理解 Go 语言的类型系统和泛型实现。

Prompt: 
```
这是路径为go/src/go/types/named.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
请用中文回答。

"""
// Code generated by "go test -run=Generate -write=all"; DO NOT EDIT.
// Source: ../../cmd/compile/internal/types2/named.go

// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package types

import (
	"go/token"
	"strings"
	"sync"
	"sync/atomic"
)

// Type-checking Named types is subtle, because they may be recursively
// defined, and because their full details may be spread across multiple
// declarations (via methods). For this reason they are type-checked lazily,
// to avoid information being accessed before it is complete.
//
// Conceptually, it is helpful to think of named types as having two distinct
// sets of information:
//  - "LHS" information, defining their identity: Obj() and TypeArgs()
//  - "RHS" information, defining their details: TypeParams(), Underlying(),
//    and methods.
//
// In this taxonomy, LHS information is available immediately, but RHS
// information is lazy. Specifically, a named type N may be constructed in any
// of the following ways:
//  1. type-checked from the source
//  2. loaded eagerly from export data
//  3. loaded lazily from export data (when using unified IR)
//  4. instantiated from a generic type
//
// In cases 1, 3, and 4, it is possible that the underlying type or methods of
// N may not be immediately available.
//  - During type-checking, we allocate N before type-checking its underlying
//    type or methods, so that we may resolve recursive references.
//  - When loading from export data, we may load its methods and underlying
//    type lazily using a provided load function.
//  - After instantiating, we lazily expand the underlying type and methods
//    (note that instances may be created while still in the process of
//    type-checking the original type declaration).
//
// In cases 3 and 4 this lazy construction may also occur concurrently, due to
// concurrent use of the type checker API (after type checking or importing has
// finished). It is critical that we keep track of state, so that Named types
// are constructed exactly once and so that we do not access their details too
// soon.
//
// We achieve this by tracking state with an atomic state variable, and
// guarding potentially concurrent calculations with a mutex. At any point in
// time this state variable determines which data on N may be accessed. As
// state monotonically progresses, any data available at state M may be
// accessed without acquiring the mutex at state N, provided N >= M.
//
// GLOSSARY: Here are a few terms used in this file to describe Named types:
//  - We say that a Named type is "instantiated" if it has been constructed by
//    instantiating a generic named type with type arguments.
//  - We say that a Named type is "declared" if it corresponds to a type
//    declaration in the source. Instantiated named types correspond to a type
//    instantiation in the source, not a declaration. But their Origin type is
//    a declared type.
//  - We say that a Named type is "resolved" if its RHS information has been
//    loaded or fully type-checked. For Named types constructed from export
//    data, this may involve invoking a loader function to extract information
//    from export data. For instantiated named types this involves reading
//    information from their origin.
//  - We say that a Named type is "expanded" if it is an instantiated type and
//    type parameters in its underlying type and methods have been substituted
//    with the type arguments from the instantiation. A type may be partially
//    expanded if some but not all of these details have been substituted.
//    Similarly, we refer to these individual details (underlying type or
//    method) as being "expanded".
//  - When all information is known for a named type, we say it is "complete".
//
// Some invariants to keep in mind: each declared Named type has a single
// corresponding object, and that object's type is the (possibly generic) Named
// type. Declared Named types are identical if and only if their pointers are
// identical. On the other hand, multiple instantiated Named types may be
// identical even though their pointers are not identical. One has to use
// Identical to compare them. For instantiated named types, their obj is a
// synthetic placeholder that records their position of the corresponding
// instantiation in the source (if they were constructed during type checking).
//
// To prevent infinite expansion of named instances that are created outside of
// type-checking, instances share a Context with other instances created during
// their expansion. Via the pidgeonhole principle, this guarantees that in the
// presence of a cycle of named types, expansion will eventually find an
// existing instance in the Context and short-circuit the expansion.
//
// Once an instance is complete, we can nil out this shared Context to unpin
// memory, though this Context may still be held by other incomplete instances
// in its "lineage".

// A Named represents a named (defined) type.
//
// A declaration such as:
//
//	type S struct { ... }
//
// creates a defined type whose underlying type is a struct,
// and binds this type to the object S, a [TypeName].
// Use [Named.Underlying] to access the underlying type.
// Use [Named.Obj] to obtain the object S.
//
// Before type aliases (Go 1.9), the spec called defined types "named types".
type Named struct {
	check *Checker  // non-nil during type-checking; nil otherwise
	obj   *TypeName // corresponding declared object for declared types; see above for instantiated types

	// fromRHS holds the type (on RHS of declaration) this *Named type is derived
	// from (for cycle reporting). Only used by validType, and therefore does not
	// require synchronization.
	fromRHS Type

	// information for instantiated types; nil otherwise
	inst *instance

	mu         sync.Mutex     // guards all fields below
	state_     uint32         // the current state of this type; must only be accessed atomically
	underlying Type           // possibly a *Named during setup; never a *Named once set up completely
	tparams    *TypeParamList // type parameters, or nil

	// methods declared for this type (not the method set of this type)
	// Signatures are type-checked lazily.
	// For non-instantiated types, this is a fully populated list of methods. For
	// instantiated types, methods are individually expanded when they are first
	// accessed.
	methods []*Func

	// loader may be provided to lazily load type parameters, underlying type, and methods.
	loader func(*Named) (tparams []*TypeParam, underlying Type, methods []*Func)
}

// instance holds information that is only necessary for instantiated named
// types.
type instance struct {
	orig            *Named    // original, uninstantiated type
	targs           *TypeList // type arguments
	expandedMethods int       // number of expanded methods; expandedMethods <= len(orig.methods)
	ctxt            *Context  // local Context; set to nil after full expansion
}

// namedState represents the possible states that a named type may assume.
type namedState uint32

const (
	unresolved namedState = iota // tparams, underlying type and methods might be unavailable
	resolved                     // resolve has run; methods might be incomplete (for instances)
	complete                     // all data is known
)

// NewNamed returns a new named type for the given type name, underlying type, and associated methods.
// If the given type name obj doesn't have a type yet, its type is set to the returned named type.
// The underlying type must not be a *Named.
func NewNamed(obj *TypeName, underlying Type, methods []*Func) *Named {
	if asNamed(underlying) != nil {
		panic("underlying type must not be *Named")
	}
	return (*Checker)(nil).newNamed(obj, underlying, methods)
}

// resolve resolves the type parameters, methods, and underlying type of n.
// This information may be loaded from a provided loader function, or computed
// from an origin type (in the case of instances).
//
// After resolution, the type parameters, methods, and underlying type of n are
// accessible; but if n is an instantiated type, its methods may still be
// unexpanded.
func (n *Named) resolve() *Named {
	if n.state() >= resolved { // avoid locking below
		return n
	}

	// TODO(rfindley): if n.check is non-nil we can avoid locking here, since
	// type-checking is not concurrent. Evaluate if this is worth doing.
	n.mu.Lock()
	defer n.mu.Unlock()

	if n.state() >= resolved {
		return n
	}

	if n.inst != nil {
		assert(n.underlying == nil) // n is an unresolved instance
		assert(n.loader == nil)     // instances are created by instantiation, in which case n.loader is nil

		orig := n.inst.orig
		orig.resolve()
		underlying := n.expandUnderlying()

		n.tparams = orig.tparams
		n.underlying = underlying
		n.fromRHS = orig.fromRHS // for cycle detection

		if len(orig.methods) == 0 {
			n.setState(complete) // nothing further to do
			n.inst.ctxt = nil
		} else {
			n.setState(resolved)
		}
		return n
	}

	// TODO(mdempsky): Since we're passing n to the loader anyway
	// (necessary because types2 expects the receiver type for methods
	// on defined interface types to be the Named rather than the
	// underlying Interface), maybe it should just handle calling
	// SetTypeParams, SetUnderlying, and AddMethod instead?  Those
	// methods would need to support reentrant calls though. It would
	// also make the API more future-proof towards further extensions.
	if n.loader != nil {
		assert(n.underlying == nil)
		assert(n.TypeArgs().Len() == 0) // instances are created by instantiation, in which case n.loader is nil

		tparams, underlying, methods := n.loader(n)

		n.tparams = bindTParams(tparams)
		n.underlying = underlying
		n.fromRHS = underlying // for cycle detection
		n.methods = methods
		n.loader = nil
	}

	n.setState(complete)
	return n
}

// state atomically accesses the current state of the receiver.
func (n *Named) state() namedState {
	return namedState(atomic.LoadUint32(&n.state_))
}

// setState atomically stores the given state for n.
// Must only be called while holding n.mu.
func (n *Named) setState(state namedState) {
	atomic.StoreUint32(&n.state_, uint32(state))
}

// newNamed is like NewNamed but with a *Checker receiver.
func (check *Checker) newNamed(obj *TypeName, underlying Type, methods []*Func) *Named {
	typ := &Named{check: check, obj: obj, fromRHS: underlying, underlying: underlying, methods: methods}
	if obj.typ == nil {
		obj.typ = typ
	}
	// Ensure that typ is always sanity-checked.
	if check != nil {
		check.needsCleanup(typ)
	}
	return typ
}

// newNamedInstance creates a new named instance for the given origin and type
// arguments, recording pos as the position of its synthetic object (for error
// reporting).
//
// If set, expanding is the named type instance currently being expanded, that
// led to the creation of this instance.
func (check *Checker) newNamedInstance(pos token.Pos, orig *Named, targs []Type, expanding *Named) *Named {
	assert(len(targs) > 0)

	obj := NewTypeName(pos, orig.obj.pkg, orig.obj.name, nil)
	inst := &instance{orig: orig, targs: newTypeList(targs)}

	// Only pass the expanding context to the new instance if their packages
	// match. Since type reference cycles are only possible within a single
	// package, this is sufficient for the purposes of short-circuiting cycles.
	// Avoiding passing the context in other cases prevents unnecessary coupling
	// of types across packages.
	if expanding != nil && expanding.Obj().pkg == obj.pkg {
		inst.ctxt = expanding.inst.ctxt
	}
	typ := &Named{check: check, obj: obj, inst: inst}
	obj.typ = typ
	// Ensure that typ is always sanity-checked.
	if check != nil {
		check.needsCleanup(typ)
	}
	return typ
}

func (t *Named) cleanup() {
	assert(t.inst == nil || t.inst.orig.inst == nil)
	// Ensure that every defined type created in the course of type-checking has
	// either non-*Named underlying type, or is unexpanded.
	//
	// This guarantees that we don't leak any types whose underlying type is
	// *Named, because any unexpanded instances will lazily compute their
	// underlying type by substituting in the underlying type of their origin.
	// The origin must have either been imported or type-checked and expanded
	// here, and in either case its underlying type will be fully expanded.
	switch t.underlying.(type) {
	case nil:
		if t.TypeArgs().Len() == 0 {
			panic("nil underlying")
		}
	case *Named, *Alias:
		t.under() // t.under may add entries to check.cleaners
	}
	t.check = nil
}

// Obj returns the type name for the declaration defining the named type t. For
// instantiated types, this is same as the type name of the origin type.
func (t *Named) Obj() *TypeName {
	if t.inst == nil {
		return t.obj
	}
	return t.inst.orig.obj
}

// Origin returns the generic type from which the named type t is
// instantiated. If t is not an instantiated type, the result is t.
func (t *Named) Origin() *Named {
	if t.inst == nil {
		return t
	}
	return t.inst.orig
}

// TypeParams returns the type parameters of the named type t, or nil.
// The result is non-nil for an (originally) generic type even if it is instantiated.
func (t *Named) TypeParams() *TypeParamList { return t.resolve().tparams }

// SetTypeParams sets the type parameters of the named type t.
// t must not have type arguments.
func (t *Named) SetTypeParams(tparams []*TypeParam) {
	assert(t.inst == nil)
	t.resolve().tparams = bindTParams(tparams)
}

// TypeArgs returns the type arguments used to instantiate the named type t.
func (t *Named) TypeArgs() *TypeList {
	if t.inst == nil {
		return nil
	}
	return t.inst.targs
}

// NumMethods returns the number of explicit methods defined for t.
func (t *Named) NumMethods() int {
	return len(t.Origin().resolve().methods)
}

// Method returns the i'th method of named type t for 0 <= i < t.NumMethods().
//
// For an ordinary or instantiated type t, the receiver base type of this
// method is the named type t. For an uninstantiated generic type t, each
// method receiver is instantiated with its receiver type parameters.
//
// Methods are numbered deterministically: given the same list of source files
// presented to the type checker, or the same sequence of NewMethod and AddMethod
// calls, the mapping from method index to corresponding method remains the same.
// But the specific ordering is not specified and must not be relied on as it may
// change in the future.
func (t *Named) Method(i int) *Func {
	t.resolve()

	if t.state() >= complete {
		return t.methods[i]
	}

	assert(t.inst != nil) // only instances should have incomplete methods
	orig := t.inst.orig

	t.mu.Lock()
	defer t.mu.Unlock()

	if len(t.methods) != len(orig.methods) {
		assert(len(t.methods) == 0)
		t.methods = make([]*Func, len(orig.methods))
	}

	if t.methods[i] == nil {
		assert(t.inst.ctxt != nil) // we should still have a context remaining from the resolution phase
		t.methods[i] = t.expandMethod(i)
		t.inst.expandedMethods++

		// Check if we've created all methods at this point. If we have, mark the
		// type as fully expanded.
		if t.inst.expandedMethods == len(orig.methods) {
			t.setState(complete)
			t.inst.ctxt = nil // no need for a context anymore
		}
	}

	return t.methods[i]
}

// expandMethod substitutes type arguments in the i'th method for an
// instantiated receiver.
func (t *Named) expandMethod(i int) *Func {
	// t.orig.methods is not lazy. origm is the method instantiated with its
	// receiver type parameters (the "origin" method).
	origm := t.inst.orig.Method(i)
	assert(origm != nil)

	check := t.check
	// Ensure that the original method is type-checked.
	if check != nil {
		check.objDecl(origm, nil)
	}

	origSig := origm.typ.(*Signature)
	rbase, _ := deref(origSig.Recv().Type())

	// If rbase is t, then origm is already the instantiated method we're looking
	// for. In this case, we return origm to preserve the invariant that
	// traversing Method->Receiver Type->Method should get back to the same
	// method.
	//
	// This occurs if t is instantiated with the receiver type parameters, as in
	// the use of m in func (r T[_]) m() { r.m() }.
	if rbase == t {
		return origm
	}

	sig := origSig
	// We can only substitute if we have a correspondence between type arguments
	// and type parameters. This check is necessary in the presence of invalid
	// code.
	if origSig.RecvTypeParams().Len() == t.inst.targs.Len() {
		smap := makeSubstMap(origSig.RecvTypeParams().list(), t.inst.targs.list())
		var ctxt *Context
		if check != nil {
			ctxt = check.context()
		}
		sig = check.subst(origm.pos, origSig, smap, t, ctxt).(*Signature)
	}

	if sig == origSig {
		// No substitution occurred, but we still need to create a new signature to
		// hold the instantiated receiver.
		copy := *origSig
		sig = &copy
	}

	var rtyp Type
	if origm.hasPtrRecv() {
		rtyp = NewPointer(t)
	} else {
		rtyp = t
	}

	sig.recv = cloneVar(origSig.recv, rtyp)
	return cloneFunc(origm, sig)
}

// SetUnderlying sets the underlying type and marks t as complete.
// t must not have type arguments.
func (t *Named) SetUnderlying(underlying Type) {
	assert(t.inst == nil)
	if underlying == nil {
		panic("underlying type must not be nil")
	}
	if asNamed(underlying) != nil {
		panic("underlying type must not be *Named")
	}
	t.resolve().underlying = underlying
	if t.fromRHS == nil {
		t.fromRHS = underlying // for cycle detection
	}
}

// AddMethod adds method m unless it is already in the method list.
// The method must be in the same package as t, and t must not have
// type arguments.
func (t *Named) AddMethod(m *Func) {
	assert(samePkg(t.obj.pkg, m.pkg))
	assert(t.inst == nil)
	t.resolve()
	if t.methodIndex(m.name, false) < 0 {
		t.methods = append(t.methods, m)
	}
}

// methodIndex returns the index of the method with the given name.
// If foldCase is set, capitalization in the name is ignored.
// The result is negative if no such method exists.
func (t *Named) methodIndex(name string, foldCase bool) int {
	if name == "_" {
		return -1
	}
	if foldCase {
		for i, m := range t.methods {
			if strings.EqualFold(m.name, name) {
				return i
			}
		}
	} else {
		for i, m := range t.methods {
			if m.name == name {
				return i
			}
		}
	}
	return -1
}

// Underlying returns the [underlying type] of the named type t, resolving all
// forwarding declarations. Underlying types are never Named, TypeParam, or
// Alias types.
//
// [underlying type]: https://go.dev/ref/spec#Underlying_types.
func (t *Named) Underlying() Type {
	// TODO(gri) Investigate if Unalias can be moved to where underlying is set.
	return Unalias(t.resolve().underlying)
}

func (t *Named) String() string { return TypeString(t, nil) }

// ----------------------------------------------------------------------------
// Implementation
//
// TODO(rfindley): reorganize the loading and expansion methods under this
// heading.

// under returns the expanded underlying type of n0; possibly by following
// forward chains of named types. If an underlying type is found, resolve
// the chain by setting the underlying type for each defined type in the
// chain before returning it. If no underlying type is found or a cycle
// is detected, the result is Typ[Invalid]. If a cycle is detected and
// n0.check != nil, the cycle is reported.
//
// This is necessary because the underlying type of named may be itself a
// named type that is incomplete:
//
//	type (
//		A B
//		B *C
//		C A
//	)
//
// The type of C is the (named) type of A which is incomplete,
// and which has as its underlying type the named type B.
func (n0 *Named) under() Type {
	u := n0.Underlying()

	// If the underlying type of a defined type is not a defined
	// (incl. instance) type, then that is the desired underlying
	// type.
	var n1 *Named
	switch u1 := u.(type) {
	case nil:
		// After expansion via Underlying(), we should never encounter a nil
		// underlying.
		panic("nil underlying")
	default:
		// common case
		return u
	case *Named:
		// handled below
		n1 = u1
	}

	if n0.check == nil {
		panic("Named.check == nil but type is incomplete")
	}

	// Invariant: after this point n0 as well as any named types in its
	// underlying chain should be set up when this function exits.
	check := n0.check
	n := n0

	seen := make(map[*Named]int) // types that need their underlying type resolved
	var path []Object            // objects encountered, for cycle reporting

loop:
	for {
		seen[n] = len(seen)
		path = append(path, n.obj)
		n = n1
		if i, ok := seen[n]; ok {
			// cycle
			check.cycleError(path[i:], firstInSrc(path[i:]))
			u = Typ[Invalid]
			break
		}
		u = n.Underlying()
		switch u1 := u.(type) {
		case nil:
			u = Typ[Invalid]
			break loop
		default:
			break loop
		case *Named:
			// Continue collecting *Named types in the chain.
			n1 = u1
		}
	}

	for n := range seen {
		// We should never have to update the underlying type of an imported type;
		// those underlying types should have been resolved during the import.
		// Also, doing so would lead to a race condition (was go.dev/issue/31749).
		// Do this check always, not just in debug mode (it's cheap).
		if n.obj.pkg != check.pkg {
			panic("imported type with unresolved underlying type")
		}
		n.underlying = u
	}

	return u
}

func (n *Named) lookupMethod(pkg *Package, name string, foldCase bool) (int, *Func) {
	n.resolve()
	if samePkg(n.obj.pkg, pkg) || isExported(name) || foldCase {
		// If n is an instance, we may not have yet instantiated all of its methods.
		// Look up the method index in orig, and only instantiate method at the
		// matching index (if any).
		if i := n.Origin().methodIndex(name, foldCase); i >= 0 {
			// For instances, m.Method(i) will be different from the orig method.
			return i, n.Method(i)
		}
	}
	return -1, nil
}

// context returns the type-checker context.
func (check *Checker) context() *Context {
	if check.ctxt == nil {
		check.ctxt = NewContext()
	}
	return check.ctxt
}

// expandUnderlying substitutes type arguments in the underlying type n.orig,
// returning the result. Returns Typ[Invalid] if there was an error.
func (n *Named) expandUnderlying() Type {
	check := n.check
	if check != nil && check.conf._Trace {
		check.trace(n.obj.pos, "-- Named.expandUnderlying %s", n)
		check.indent++
		defer func() {
			check.indent--
			check.trace(n.obj.pos, "=> %s (tparams = %s, under = %s)", n, n.tparams.list(), n.underlying)
		}()
	}

	assert(n.inst.orig.underlying != nil)
	if n.inst.ctxt == nil {
		n.inst.ctxt = NewContext()
	}

	orig := n.inst.orig
	targs := n.inst.targs

	if asNamed(orig.underlying) != nil {
		// We should only get a Named underlying type here during type checking
		// (for example, in recursive type declarations).
		assert(check != nil)
	}

	if orig.tparams.Len() != targs.Len() {
		// Mismatching arg and tparam length may be checked elsewhere.
		return Typ[Invalid]
	}

	// Ensure that an instance is recorded before substituting, so that we
	// resolve n for any recursive references.
	h := n.inst.ctxt.instanceHash(orig, targs.list())
	n2 := n.inst.ctxt.update(h, orig, n.TypeArgs().list(), n)
	assert(n == n2)

	smap := makeSubstMap(orig.tparams.list(), targs.list())
	var ctxt *Context
	if check != nil {
		ctxt = check.context()
	}
	underlying := n.check.subst(n.obj.pos, orig.underlying, smap, n, ctxt)
	// If the underlying type of n is an interface, we need to set the receiver of
	// its methods accurately -- we set the receiver of interface methods on
	// the RHS of a type declaration to the defined type.
	if iface, _ := underlying.(*Interface); iface != nil {
		if methods, copied := replaceRecvType(iface.methods, orig, n); copied {
			// If the underlying type doesn't actually use type parameters, it's
			// possible that it wasn't substituted. In this case we need to create
			// a new *Interface before modifying receivers.
			if iface == orig.underlying {
				old := iface
				iface = check.newInterface()
				iface.embeddeds = old.embeddeds
				assert(old.complete) // otherwise we are copying incomplete data
				iface.complete = old.complete
				iface.implicit = old.implicit // should be false but be conservative
				underlying = iface
			}
			iface.methods = methods
			iface.tset = nil // recompute type set with new methods

			// If check != nil, check.newInterface will have saved the interface for later completion.
			if check == nil { // golang/go#61561: all newly created interfaces must be fully evaluated
				iface.typeSet()
			}
		}
	}

	return underlying
}

// safeUnderlying returns the underlying type of typ without expanding
// instances, to avoid infinite recursion.
//
// TODO(rfindley): eliminate this function or give it a better name.
func safeUnderlying(typ Type) Type {
	if t := asNamed(typ); t != nil {
		return t.underlying
	}
	return typ.Underlying()
}

"""



```
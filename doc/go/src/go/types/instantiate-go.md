Response:
Let's break down the thought process for analyzing this Go code snippet.

1. **Understand the Goal:** The request asks for the functionality of the code, its purpose in Go, examples, input/output reasoning, command-line implications, and potential pitfalls. The filename `instantiate.go` and the package name `types` immediately suggest this code is related to the Go type system and creating instances of something.

2. **Initial Scan and Keywords:**  A quick scan reveals key terms like "instantiate," "generic," "type parameters," "type arguments," "substitution," "context," "validate," "Named," "Signature," and "Alias." These terms strongly indicate this code deals with Go generics.

3. **Focus on the `Instantiate` Function:** This is the main entry point and likely the core functionality. Let's dissect its signature and body:
    * `func Instantiate(ctxt *Context, orig Type, targs []Type, validate bool) (Type, error)`:  This tells us it takes an original `Type`, type arguments (`targs`), a context (likely for caching), and a validation flag. It returns a new `Type` and a potential error.
    * The comments explicitly state it handles instantiation of `*Alias`, `*Named`, and `*Signature` types. This is a crucial piece of information.
    * The `validate` parameter suggests the function can perform checks on the provided type arguments.
    * The code initializes a `Context` if one isn't provided, indicating a potential internal mechanism for managing instances.
    * It calls `verify` if `validate` is true, suggesting type constraint checking.
    * Finally, it calls the `instance` method, which seems to be the actual instantiation logic.

4. **Analyze the `instance` Function:** This function appears to handle the low-level instantiation.
    * It takes a `genericType`, type arguments, and potentially an `expanding` `*Named` type (related to recursive instantiation).
    * The use of `ctxts` and hashing (`instanceHash`) strongly suggests a mechanism for caching and deduplication of instantiated types within different contexts.
    * The `switch` statement based on the type of `orig` (`*Named`, `*Alias`, `*Signature`) confirms the function handles different kinds of generic types.
    * Each case calls specific methods like `newNamedInstance`, `newAliasInstance`, and performs substitution for `*Signature`. The `subst` function is mentioned, hinting at the core mechanism of replacing type parameters with arguments.
    * The comment about setting `sig.tparams = nil` after instantiating a generic signature is important. It indicates that the instantiated signature is no longer generic.

5. **Examine Supporting Functions:**
    * `validateTArgLen`:  This clearly checks if the number of type arguments matches the number of type parameters. The "panic if check is nil" detail is notable for understanding error handling in different scenarios.
    * `verify`: This is responsible for checking if type arguments satisfy the constraints of their corresponding type parameters. The call to `implements` is significant.
    * `implements`: This is the core logic for checking type constraint satisfaction. The detailed checks for interfaces, methods, and type sets are important to understand the nuances of Go's type system. The handling of comparability and the go1.20 detail are worth noting.
    * `mentions`: This seems like a helper function for producing better error messages by checking if a type is mentioned within an interface definition.

6. **Infer Go Features:** Based on the analysis, it's clear this code implements Go generics. Specifically:
    * **Type Parameter Substitution:** The core mechanism is replacing type parameters with concrete type arguments.
    * **Type Constraints:** The `verify` and `implements` functions handle the validation of type arguments against their constraints.
    * **Instantiation of Different Types:**  The code handles instantiation for named types (structs, interfaces), aliases, and function signatures.
    * **Caching and Deduplication:** The `Context` and hashing mechanisms are used to optimize instantiation by reusing previously created instances.

7. **Construct Examples:**  Now, create concrete Go code examples to illustrate the functionality. This involves demonstrating the instantiation of generic structs, functions, and potentially aliases. Show both successful and failing validation scenarios.

8. **Reason about Input and Output:** For the examples, explicitly state the expected input and output, especially for error cases. This clarifies how the functions behave.

9. **Consider Command-Line Arguments:**  While the code itself doesn't directly handle command-line arguments, the "Code generated by" comment mentions `go test -run=Generate -write=all`. This suggests the code *might* be generated as part of a testing or code generation process, but the provided snippet doesn't have explicit command-line parsing logic. It's important to note this distinction.

10. **Identify Potential Pitfalls:** Think about common mistakes developers might make when using generics:
    * Incorrect number of type arguments.
    * Type arguments not satisfying constraints.
    * Understanding the implications of instantiation for methods on generic types.

11. **Structure the Answer:** Organize the findings into a clear and logical structure, addressing each point in the original request. Use headings and code blocks for readability. Provide clear explanations and avoid overly technical jargon where possible.

12. **Review and Refine:** Read through the answer to ensure accuracy, completeness, and clarity. Double-check the code examples and explanations. Ensure the language is natural and easy to understand for a Chinese speaker.

This systematic approach of examining the code structure, focusing on key functions, understanding the underlying concepts, and creating concrete examples helps in accurately determining the functionality and purpose of the given Go code snippet.
这段代码是 Go 语言 `types` 包中 `instantiate.go` 文件的一部分，它实现了**Go 语言泛型类型和函数的实例化**功能。

**功能列表:**

1. **类型实例化 (`Instantiate` 函数):**
   - 接收一个泛型类型 `orig` (可以是 `*Alias`, `*Named`, 或 `*Signature`) 和一组类型实参 `targs`。
   - 将泛型类型中的类型形参替换为提供的类型实参，创建一个新的具体的类型实例。
   - 可以选择性地进行验证 (`validate` 参数)，确保类型实参的数量和类型约束满足要求。
   - 使用 `Context` 来缓存和去重已经实例化过的类型，避免重复创建相同的实例。

2. **内部实例化 (`instance` 函数):**
   - 是 `Instantiate` 函数的底层实现。
   - 负责根据泛型类型的具体种类 (`*Named`, `*Alias`, `*Signature`) 调用相应的实例化逻辑。
   - 也负责在不同的上下文中查找和记录已有的实例。

3. **类型实参长度验证 (`validateTArgLen` 函数):**
   - 检查提供的类型实参的数量是否与泛型类型声明的类型形参的数量一致。
   - 如果不一致，会产生错误信息。

4. **类型约束验证 (`verify` 函数):**
   - 检查提供的类型实参是否满足其对应类型形参的类型约束。
   - 通过调用 `implements` 函数来判断类型实参是否实现了类型约束所定义的接口。

5. **类型实现检查 (`implements` 函数):**
   - 判断一个类型 `V` 是否实现了另一个类型 `T` (通常是接口)。
   - 当 `constraint` 参数为 `true` 时，表示 `T` 是一个类型约束。
   - 会检查方法集、可比较性以及类型集合等。

6. **类型提及检查 (`mentions` 函数):**
   -  用于判断一个类型 `typ` 是否在另一个类型 `T` 的定义中被提及（作为嵌入字段或联合类型的一部分）。主要用于提供更友好的错误提示信息。

**Go 语言泛型功能的实现:**

这段代码是 Go 语言泛型特性的核心实现之一。它允许开发者编写可以操作多种类型的代码，而无需为每种类型编写重复的代码。

**Go 代码示例:**

```go
package main

import (
	"fmt"
	"go/types"
)

func main() {
	// 创建一个类型环境
	conf := &types.Config{Importer: defaultImporter()}
	pkg, err := conf.Check("example.com/mypkg", &types.Package{}, nil, []string{`
		package mypkg

		type MyGeneric[T any] struct {
			Value T
		}

		func MyGenericFunc[T any](val T) T {
			return val
		}

		type MyConstraint interface {
			String() string
		}

		type ConstrainedGeneric[T MyConstraint] struct {
			Value T
		}
	`})
	if err != nil {
		panic(err)
	}

	// 获取泛型类型定义
	myGenericType := pkg.Scope().Lookup("MyGeneric").Type().(*types.Named)
	myGenericFunc := pkg.Scope().Lookup("MyGenericFunc").(*types.Func)
	constrainedGenericType := pkg.Scope().Lookup("ConstrainedGeneric").Type().(*types.Named)

	// 类型实参
	intType := types.Typ[types.Int]
	stringType := types.Typ[types.String]

	// 实例化 MyGeneric[int]
	instantiatedMyGenericInt, err := types.Instantiate(nil, myGenericType, []types.Type{intType}, true)
	if err != nil {
		fmt.Println("Error instantiating MyGeneric[int]:", err)
	} else {
		fmt.Println("Instantiated MyGeneric[int]:", instantiatedMyGenericInt) // Output: example.com/mypkg.MyGeneric[int]
	}

	// 实例化 MyGenericFunc[string] 的签名
	instantiatedMyGenericFuncSig, err := types.Instantiate(nil, myGenericFunc.Type(), []types.Type{stringType}, true)
	if err != nil {
		fmt.Println("Error instantiating MyGenericFunc[string]:", err)
	} else {
		fmt.Println("Instantiated MyGenericFunc[string] signature:", instantiatedMyGenericFuncSig) // Output: func(string) string
	}

	// 实例化 ConstrainedGeneric，使用满足约束的类型
	instantiatedConstrainedGenericString, err := types.Instantiate(nil, constrainedGenericType, []types.Type{stringType}, true)
	if err != nil {
		fmt.Println("Error instantiating ConstrainedGeneric[string]:", err)
	} else {
		fmt.Println("Instantiated ConstrainedGeneric[string]:", instantiatedConstrainedGenericString) // Output: example.com/mypkg.ConstrainedGeneric[string]
	}

	// 实例化 ConstrainedGeneric，使用不满足约束的类型 (会报错)
	instantiatedConstrainedGenericInt, err := types.Instantiate(nil, constrainedGenericType, []types.Type{intType}, true)
	if err != nil {
		fmt.Println("Error instantiating ConstrainedGeneric[int]:", err) // Output: Error instantiating ConstrainedGeneric[int]: type int does not satisfy example.com/mypkg.MyConstraint (missing method String)
	} else {
		fmt.Println("Instantiated ConstrainedGeneric[int]:", instantiatedConstrainedGenericInt)
	}
}

// 简化的 importer 实现，用于示例
func defaultImporter() types.Importer {
	return &importer{}
}

type importer struct{}

func (i *importer) Import(path string) (*types.Package, error) {
	if path == "example.com/mypkg" {
		// 这里可以返回预定义的包，或者根据需要动态创建
		return &types.Package{Name_: "mypkg", Path_: "example.com/mypkg"}, nil
	}
	return nil, fmt.Errorf("package not found: %s", path)
}
```

**假设的输入与输出 (基于上面的代码示例):**

**输入:**

- `orig`: `*types.Named` 类型的 `MyGeneric` 结构体定义。
- `targs`: `[]types.Type{types.Typ[types.Int]}`，表示类型实参为 `int`。
- `validate`: `true`，表示需要进行验证。

**输出:**

- 如果实例化成功，返回一个新的 `*types.Named` 类型，表示 `MyGeneric[int]`。
- 如果验证失败（例如，类型实参数量不匹配），返回 `nil` 和一个错误，错误信息会指出类型实参数量不正确。

**输入:**

- `orig`: `*types.Func` 类型的 `MyGenericFunc` 函数签名。
- `targs`: `[]types.Type{types.Typ[types.String]}`，表示类型实参为 `string`。
- `validate`: `true`.

**输出:**

- 如果实例化成功，返回一个新的 `*types.Signature` 类型，表示 `func(string) string`。

**输入:**

- `orig`: `*types.Named` 类型的 `ConstrainedGeneric` 结构体定义。
- `targs`: `[]types.Type{types.Typ[types.Int]}`，表示类型实参为 `int`。
- `validate`: `true`.

**输出:**

- 返回 `nil` 和一个 `*ArgumentError` 类型的错误，指出 `int` 类型没有实现 `MyConstraint` 接口（缺少 `String()` 方法）。

**命令行参数处理:**

这段代码本身是 Go 语言类型检查器的一部分，并不直接处理命令行参数。它的功能被 `go build`, `go run`, `go test` 等 Go 工具链调用。这些工具会解析命令行参数，然后使用类型检查器来验证和处理 Go 代码，包括泛型的实例化。

**使用者易犯错的点:**

1. **类型实参数量不匹配:**
   ```go
   // 假设 MyGeneric 有一个类型形参
   _, err := types.Instantiate(nil, myGenericType, []types.Type{}, true)
   if err != nil {
       fmt.Println(err) // 输出: got 0 type arguments but example.com/mypkg.MyGeneric has 1 type parameters
   }
   ```
   错误信息会明确指出类型实参的数量与类型形参的数量不一致。

2. **类型实参不满足类型约束:**
   ```go
   // 假设 ConstrainedGeneric 的类型形参有 MyConstraint 的约束
   _, err := types.Instantiate(nil, constrainedGenericType, []types.Type{types.Typ[types.Int]}, true)
   if err != nil {
       fmt.Println(err) // 输出: type int does not satisfy example.com/mypkg.MyConstraint (missing method String)
   }
   ```
   错误信息会指出哪个类型实参不满足哪个类型形参的约束，并说明原因（通常是缺少方法）。

3. **在需要实例化的地方忘记提供类型实参:**
   虽然这段代码本身不直接处理这种情况，但在实际的 Go 代码中，如果使用泛型类型或函数但没有提供类型实参，Go 编译器会报错。

**总结:**

`instantiate.go` 中的代码是 Go 语言泛型实现的关键部分，它负责将泛型类型和函数根据提供的类型实参生成具体的类型实例，并进行必要的验证，确保类型安全。理解这段代码有助于深入理解 Go 语言泛型的工作原理。

### 提示词
```
这是路径为go/src/go/types/instantiate.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
请用中文回答。
```

### 源代码
```go
// Code generated by "go test -run=Generate -write=all"; DO NOT EDIT.
// Source: ../../cmd/compile/internal/types2/instantiate.go

// Copyright 2021 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file implements instantiation of generic types
// through substitution of type parameters by type arguments.

package types

import (
	"errors"
	"fmt"
	"go/token"
	"internal/buildcfg"
	. "internal/types/errors"
)

// A genericType implements access to its type parameters.
type genericType interface {
	Type
	TypeParams() *TypeParamList
}

// Instantiate instantiates the type orig with the given type arguments targs.
// orig must be an *Alias, *Named, or *Signature type. If there is no error,
// the resulting Type is an instantiated type of the same kind (*Alias, *Named
// or *Signature, respectively).
//
// Methods attached to a *Named type are also instantiated, and associated with
// a new *Func that has the same position as the original method, but nil function
// scope.
//
// If ctxt is non-nil, it may be used to de-duplicate the instance against
// previous instances with the same identity. As a special case, generic
// *Signature origin types are only considered identical if they are pointer
// equivalent, so that instantiating distinct (but possibly identical)
// signatures will yield different instances. The use of a shared context does
// not guarantee that identical instances are deduplicated in all cases.
//
// If validate is set, Instantiate verifies that the number of type arguments
// and parameters match, and that the type arguments satisfy their respective
// type constraints. If verification fails, the resulting error may wrap an
// *ArgumentError indicating which type argument did not satisfy its type parameter
// constraint, and why.
//
// If validate is not set, Instantiate does not verify the type argument count
// or whether the type arguments satisfy their constraints. Instantiate is
// guaranteed to not return an error, but may panic. Specifically, for
// *Signature types, Instantiate will panic immediately if the type argument
// count is incorrect; for *Named types, a panic may occur later inside the
// *Named API.
func Instantiate(ctxt *Context, orig Type, targs []Type, validate bool) (Type, error) {
	assert(len(targs) > 0)
	if ctxt == nil {
		ctxt = NewContext()
	}
	orig_ := orig.(genericType) // signature of Instantiate must not change for backward-compatibility

	if validate {
		tparams := orig_.TypeParams().list()
		assert(len(tparams) > 0)
		if len(targs) != len(tparams) {
			return nil, fmt.Errorf("got %d type arguments but %s has %d type parameters", len(targs), orig, len(tparams))
		}
		if i, err := (*Checker)(nil).verify(nopos, tparams, targs, ctxt); err != nil {
			return nil, &ArgumentError{i, err}
		}
	}

	inst := (*Checker)(nil).instance(nopos, orig_, targs, nil, ctxt)
	return inst, nil
}

// instance instantiates the given original (generic) function or type with the
// provided type arguments and returns the resulting instance. If an identical
// instance exists already in the given contexts, it returns that instance,
// otherwise it creates a new one.
//
// If expanding is non-nil, it is the Named instance type currently being
// expanded. If ctxt is non-nil, it is the context associated with the current
// type-checking pass or call to Instantiate. At least one of expanding or ctxt
// must be non-nil.
//
// For Named types the resulting instance may be unexpanded.
//
// check may be nil (when not type-checking syntax); pos is used only only if check is non-nil.
func (check *Checker) instance(pos token.Pos, orig genericType, targs []Type, expanding *Named, ctxt *Context) (res Type) {
	// The order of the contexts below matters: we always prefer instances in the
	// expanding instance context in order to preserve reference cycles.
	//
	// Invariant: if expanding != nil, the returned instance will be the instance
	// recorded in expanding.inst.ctxt.
	var ctxts []*Context
	if expanding != nil {
		ctxts = append(ctxts, expanding.inst.ctxt)
	}
	if ctxt != nil {
		ctxts = append(ctxts, ctxt)
	}
	assert(len(ctxts) > 0)

	// Compute all hashes; hashes may differ across contexts due to different
	// unique IDs for Named types within the hasher.
	hashes := make([]string, len(ctxts))
	for i, ctxt := range ctxts {
		hashes[i] = ctxt.instanceHash(orig, targs)
	}

	// Record the result in all contexts.
	// Prefer to re-use existing types from expanding context, if it exists, to reduce
	// the memory pinned by the Named type.
	updateContexts := func(res Type) Type {
		for i := len(ctxts) - 1; i >= 0; i-- {
			res = ctxts[i].update(hashes[i], orig, targs, res)
		}
		return res
	}

	// typ may already have been instantiated with identical type arguments. In
	// that case, re-use the existing instance.
	for i, ctxt := range ctxts {
		if inst := ctxt.lookup(hashes[i], orig, targs); inst != nil {
			return updateContexts(inst)
		}
	}

	switch orig := orig.(type) {
	case *Named:
		res = check.newNamedInstance(pos, orig, targs, expanding) // substituted lazily

	case *Alias:
		if !buildcfg.Experiment.AliasTypeParams {
			assert(expanding == nil) // Alias instances cannot be reached from Named types
		}

		tparams := orig.TypeParams()
		// TODO(gri) investigate if this is needed (type argument and parameter count seem to be correct here)
		if !check.validateTArgLen(pos, orig.String(), tparams.Len(), len(targs)) {
			return Typ[Invalid]
		}
		if tparams.Len() == 0 {
			return orig // nothing to do (minor optimization)
		}

		res = check.newAliasInstance(pos, orig, targs, expanding, ctxt)

	case *Signature:
		assert(expanding == nil) // function instances cannot be reached from Named types

		tparams := orig.TypeParams()
		// TODO(gri) investigate if this is needed (type argument and parameter count seem to be correct here)
		if !check.validateTArgLen(pos, orig.String(), tparams.Len(), len(targs)) {
			return Typ[Invalid]
		}
		if tparams.Len() == 0 {
			return orig // nothing to do (minor optimization)
		}
		sig := check.subst(pos, orig, makeSubstMap(tparams.list(), targs), nil, ctxt).(*Signature)
		// If the signature doesn't use its type parameters, subst
		// will not make a copy. In that case, make a copy now (so
		// we can set tparams to nil w/o causing side-effects).
		if sig == orig {
			copy := *sig
			sig = &copy
		}
		// After instantiating a generic signature, it is not generic
		// anymore; we need to set tparams to nil.
		sig.tparams = nil
		res = sig

	default:
		// only types and functions can be generic
		panic(fmt.Sprintf("%v: cannot instantiate %v", pos, orig))
	}

	// Update all contexts; it's possible that we've lost a race.
	return updateContexts(res)
}

// validateTArgLen checks that the number of type arguments (got) matches the
// number of type parameters (want); if they don't match an error is reported.
// If validation fails and check is nil, validateTArgLen panics.
func (check *Checker) validateTArgLen(pos token.Pos, name string, want, got int) bool {
	var qual string
	switch {
	case got < want:
		qual = "not enough"
	case got > want:
		qual = "too many"
	default:
		return true
	}

	msg := check.sprintf("%s type arguments for type %s: have %d, want %d", qual, name, got, want)
	if check != nil {
		check.error(atPos(pos), WrongTypeArgCount, msg)
		return false
	}

	panic(fmt.Sprintf("%v: %s", pos, msg))
}

// check may be nil; pos is used only if check is non-nil.
func (check *Checker) verify(pos token.Pos, tparams []*TypeParam, targs []Type, ctxt *Context) (int, error) {
	smap := makeSubstMap(tparams, targs)
	for i, tpar := range tparams {
		// Ensure that we have a (possibly implicit) interface as type bound (go.dev/issue/51048).
		tpar.iface()
		// The type parameter bound is parameterized with the same type parameters
		// as the instantiated type; before we can use it for bounds checking we
		// need to instantiate it with the type arguments with which we instantiated
		// the parameterized type.
		bound := check.subst(pos, tpar.bound, smap, nil, ctxt)
		var cause string
		if !check.implements(targs[i], bound, true, &cause) {
			return i, errors.New(cause)
		}
	}
	return -1, nil
}

// implements checks if V implements T. The receiver may be nil if implements
// is called through an exported API call such as AssignableTo. If constraint
// is set, T is a type constraint.
//
// If the provided cause is non-nil, it may be set to an error string
// explaining why V does not implement (or satisfy, for constraints) T.
func (check *Checker) implements(V, T Type, constraint bool, cause *string) bool {
	Vu := under(V)
	Tu := under(T)
	if !isValid(Vu) || !isValid(Tu) {
		return true // avoid follow-on errors
	}
	if p, _ := Vu.(*Pointer); p != nil && !isValid(under(p.base)) {
		return true // avoid follow-on errors (see go.dev/issue/49541 for an example)
	}

	verb := "implement"
	if constraint {
		verb = "satisfy"
	}

	Ti, _ := Tu.(*Interface)
	if Ti == nil {
		if cause != nil {
			var detail string
			if isInterfacePtr(Tu) {
				detail = check.sprintf("type %s is pointer to interface, not interface", T)
			} else {
				detail = check.sprintf("%s is not an interface", T)
			}
			*cause = check.sprintf("%s does not %s %s (%s)", V, verb, T, detail)
		}
		return false
	}

	// Every type satisfies the empty interface.
	if Ti.Empty() {
		return true
	}
	// T is not the empty interface (i.e., the type set of T is restricted)

	// An interface V with an empty type set satisfies any interface.
	// (The empty set is a subset of any set.)
	Vi, _ := Vu.(*Interface)
	if Vi != nil && Vi.typeSet().IsEmpty() {
		return true
	}
	// type set of V is not empty

	// No type with non-empty type set satisfies the empty type set.
	if Ti.typeSet().IsEmpty() {
		if cause != nil {
			*cause = check.sprintf("cannot %s %s (empty type set)", verb, T)
		}
		return false
	}

	// V must implement T's methods, if any.
	if !check.hasAllMethods(V, T, true, Identical, cause) /* !Implements(V, T) */ {
		if cause != nil {
			*cause = check.sprintf("%s does not %s %s %s", V, verb, T, *cause)
		}
		return false
	}

	// Only check comparability if we don't have a more specific error.
	checkComparability := func() bool {
		if !Ti.IsComparable() {
			return true
		}
		// If T is comparable, V must be comparable.
		// If V is strictly comparable, we're done.
		if comparableType(V, false /* strict comparability */, nil, nil) {
			return true
		}
		// For constraint satisfaction, use dynamic (spec) comparability
		// so that ordinary, non-type parameter interfaces implement comparable.
		if constraint && comparableType(V, true /* spec comparability */, nil, nil) {
			// V is comparable if we are at Go 1.20 or higher.
			if check == nil || check.allowVersion(go1_20) {
				return true
			}
			if cause != nil {
				*cause = check.sprintf("%s to %s comparable requires go1.20 or later", V, verb)
			}
			return false
		}
		if cause != nil {
			*cause = check.sprintf("%s does not %s comparable", V, verb)
		}
		return false
	}

	// V must also be in the set of types of T, if any.
	// Constraints with empty type sets were already excluded above.
	if !Ti.typeSet().hasTerms() {
		return checkComparability() // nothing to do
	}

	// If V is itself an interface, each of its possible types must be in the set
	// of T types (i.e., the V type set must be a subset of the T type set).
	// Interfaces V with empty type sets were already excluded above.
	if Vi != nil {
		if !Vi.typeSet().subsetOf(Ti.typeSet()) {
			// TODO(gri) report which type is missing
			if cause != nil {
				*cause = check.sprintf("%s does not %s %s", V, verb, T)
			}
			return false
		}
		return checkComparability()
	}

	// Otherwise, V's type must be included in the iface type set.
	var alt Type
	if Ti.typeSet().is(func(t *term) bool {
		if !t.includes(V) {
			// If V ∉ t.typ but V ∈ ~t.typ then remember this type
			// so we can suggest it as an alternative in the error
			// message.
			if alt == nil && !t.tilde && Identical(t.typ, under(t.typ)) {
				tt := *t
				tt.tilde = true
				if tt.includes(V) {
					alt = t.typ
				}
			}
			return true
		}
		return false
	}) {
		if cause != nil {
			var detail string
			switch {
			case alt != nil:
				detail = check.sprintf("possibly missing ~ for %s in %s", alt, T)
			case mentions(Ti, V):
				detail = check.sprintf("%s mentions %s, but %s is not in the type set of %s", T, V, V, T)
			default:
				detail = check.sprintf("%s missing in %s", V, Ti.typeSet().terms)
			}
			*cause = check.sprintf("%s does not %s %s (%s)", V, verb, T, detail)
		}
		return false
	}

	return checkComparability()
}

// mentions reports whether type T "mentions" typ in an (embedded) element or term
// of T (whether typ is in the type set of T or not). For better error messages.
func mentions(T, typ Type) bool {
	switch T := T.(type) {
	case *Interface:
		for _, e := range T.embeddeds {
			if mentions(e, typ) {
				return true
			}
		}
	case *Union:
		for _, t := range T.terms {
			if mentions(t.typ, typ) {
				return true
			}
		}
	default:
		if Identical(T, typ) {
			return true
		}
	}
	return false
}
```
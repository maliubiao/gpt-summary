Response:
这个Go语言文件的主要功能是代码生成和同步。它负责将 `cmd/compile/internal/types2` 包中的代码转换并同步到 `go/types` 包中。

**核心功能点：**

1. **代码生成：**  它从 `types2` 目录下的源文件读取内容，进行一系列的 AST (抽象语法树) 转换和修改，然后将修改后的代码格式化并写入 `go/types` 目录下的对应文件。
2. **代码同步：**  它确保 `go/types` 包中的代码与 `types2` 包中的代码保持同步。当 `types2` 包中的代码发生变化时，可以通过运行这个测试来更新 `go/types` 包中的代码。
3. **AST 转换：**  代码中定义了大量的 `action` 函数，这些函数负责对读取的 `types2` 包的 AST 进行修改，使其符合 `go/types` 包的规范。这些修改包括：
    - 包名替换 (`types2` -> `types`)
    - 导入路径的修改 (例如 `"cmd/compile/internal/syntax"` -> `"go/ast"`)
    - 标识符重命名 (例如 `syntax` -> `ast`)
    - 选择器表达式的重命名 (例如 `syntax.Name` -> `ast.Ident`)
    - 函数调用的修改 (例如 `err.addf(obj, ...)` -> `err.addf(obj.Pos(), ...)`)
    - 类型定义的修改 (例如数组到切片的转换)
4. **测试与验证：**  `TestGenerate` 函数负责执行生成过程。它可以比较生成的代码和 `go/types` 目录下已有的代码。如果指定了 `-write` 命令行参数，它可以将生成的代码写回磁盘。

**推断的 Go 语言功能实现：**

从代码的结构和 `types2` 及 `go/types` 的命名来看，这个文件很可能是为了同步 Go 语言类型检查器的实现。`cmd/compile/internal/types2` 是 Go 编译器内部使用的新的类型检查器实现，而 `go/types` 是标准库中暴露给用户的类型检查器 API。

这个脚本的功能是将内部的类型检查器实现同步到标准库 API 的实现。这通常发生在 Go 语言版本升级或者内部重构之后，需要将内部实现对外暴露或者保持一致性。

**Go 代码举例说明 (假设的类型检查相关代码转换)：**

假设 `types2` 包中有一个表示类型信息的结构体 `syntax.Type`，在 `go/types` 包中对应的结构体是 `ast.Expr` (可能更具体一些，这里只是一个例子)。

**`types2/somefile.go` (假设输入):**

```go
package types2

import "cmd/compile/internal/syntax"

type MyVar struct {
    Type *syntax.Type
}
```

**`go/types/somefile.go` (期望输出):**

```go
package types

import "go/ast"

type MyVar struct {
    Type ast.Expr
}
```

为了实现这样的转换，`generate_test.go` 中可能会有如下的 `action`:

```go
var filemap = map[string]action{
    "somefile.go": func(f *ast.File) {
        renameImportPath(f, `"cmd/compile/internal/syntax"->"go/ast"`)
        renameSelectorExprs(f, "syntax.Type->ast.Expr")
    },
}
```

**命令行参数处理：**

`generate_test.go` 使用了 `flag` 包来处理命令行参数。

- `-write string`:  这个参数用于指定要生成或更新的 `go/types` 文件。
    - 如果设置为一个特定的文件名 (例如 `-write=alias.go`)，则只会生成或更新该文件。
    - 如果设置为 `"all"` (例如 `-write=all`)，则会生成或更新 `filemap` 中定义的所有文件。
    - 如果不设置该参数，`TestGenerate` 函数只会比较 `go/types` 目录下的文件和根据 `types2` 生成的内容，而不会实际写入文件。

**易犯错的点：**

1. **修改 `types2` 代码后忘记运行生成脚本：**  如果开发者修改了 `cmd/compile/internal/types2` 包中的代码，但忘记运行 `go test -run=Generate -write=all` 或者针对修改的文件运行生成脚本，`go/types` 包中的代码就会过时，可能导致编译错误或者行为不一致。

    **例子：** 开发者修改了 `types2/object.go` 中的 `NewTypeNameLazy` 函数的实现，但没有运行生成脚本。`go/types/object.go` 中的 `NewTypeNameLazy` 函数仍然是旧版本的实现。

2. **手动修改 `go/types` 下的文件：**  由于 `go/types` 下的文件头部有 `// Code generated by "go test -run=Generate -write=all"; DO NOT EDIT.` 的注释，说明这些文件是自动生成的。开发者应该避免手动修改这些文件，因为下次运行生成脚本时，所有的手动修改都会被覆盖。

    **例子：** 开发者为了修复一个临时的 bug，直接修改了 `go/types/alias.go` 文件。下次运行生成脚本后，开发者所做的修改将会丢失。

3. **不理解 `filemap` 中的转换规则：** `filemap` 中定义的 `action` 函数描述了如何将 `types2` 的 AST 转换为 `go/types` 的 AST。如果开发者不理解这些转换规则，可能会在修改 `types2` 代码后，发现生成的 `go/types` 代码不符合预期。

    **例子：** 开发者在 `types2` 中将一个结构体的字段名从 `Val` 修改为 `Value`，但 `filemap` 中并没有相应的 `renameSelectors` 规则，导致生成的 `go/types` 代码中字段名仍然是 `Val`。

总而言之，这个 `generate_test.go` 文件是 Go 语言内部维护类型检查器代码同步的关键工具，它通过 AST 转换的方式，保证了内部实现和外部 API 的一致性。正确使用和理解这个工具对于 Go 语言的开发和维护至关重要。

这个 `generate_test.go` 文件是 Go 语言 `go/types` 包的一部分，它的主要功能是**从 `cmd/compile/internal/types2` 包中的对应源文件生成 `go/types` 包的源文件**。

更具体地说，它是一个**自定义的代码生成器**，用于将 `types2` 包（这是 Go 编译器内部使用的新的类型检查器实现）的源代码转换并同步到 `go/types` 包（这是标准库中公开的类型检查器 API）。

以下是它的详细功能点：

1. **读取 `types2` 包的源文件:**  它通过 `parser.ParseFile` 函数读取位于 `cmd/compile/internal/types2/` 目录下的 Go 源代码文件。

2. **转换 AST (抽象语法树):**  读取到的源文件会被解析成 AST。然后，通过 `filemap` 中定义的 `action` 函数，对 AST 进行一系列的修改和转换，以使其适应 `go/types` 包的结构和命名规范。这些转换操作包括：
    - **包名替换:** 将 `package types2` 替换为 `package types`。
    - **导入路径修改:** 将 `types2` 包内部使用的导入路径（如 `"cmd/compile/internal/syntax"`）替换为 `go/types` 包对应的导入路径（如 `"go/ast"`）。
    - **标识符重命名:** 将 `types2` 包中使用的标识符名称替换为 `go/types` 包中使用的名称（例如，将 `syntax` 前缀的标识符替换为 `ast` 前缀）。
    - **选择器表达式重命名:** 修改结构体字段或方法调用的名称。
    - **函数调用参数调整:**  修改某些特定函数的调用方式，例如添加或修改参数。
    - **类型定义修改:**  修改某些类型定义，例如将数组转换为切片。

3. **格式化生成的代码:** 使用 `format.Node` 函数将修改后的 AST 格式化成符合 Go 代码规范的字符串。

4. **比较和写入文件:**
    - 它会读取 `go/types/` 目录下对应的现有文件内容。
    - 将生成的代码与现有文件内容进行比较。
    - 如果命令行参数 `-write` 被设置：
        - 如果内容有差异，它会将生成的代码写入 `go/types/` 目录下对应的文件，从而更新该文件。
        - 如果 `-write=all`，则会生成或更新 `filemap` 中列出的所有文件。
    - 如果 `-write` 没有设置，它只会比较内容，如果发现差异，则会输出错误信息，指出 `go/types` 目录下的文件已过时。

**它是什么 Go 语言功能的实现？**

从文件名和代码内容来看，这个脚本主要用于同步和转换 **Go 语言的类型系统实现**。 `cmd/compile/internal/types2` 是 Go 编译器内部使用的新的、更精细的类型检查器实现，而 `go/types` 是标准库中暴露给用户的类型检查器 API。

**Go 代码举例说明 (假设的标识符重命名):**

假设 `types2/alias.go` 中有如下代码：

```go
package types2

type MyAlias struct {
    Underlying syntax.Type // syntax 是 "cmd/compile/internal/syntax" 包的别名
}
```

`go/types/generate_test.go` 中的 `filemap` 可能有如下配置：

```go
var filemap = map[string]action{
    "alias.go": func(f *ast.File) {
        renameImportPath(f, `"cmd/compile/internal/syntax"->"go/ast"`)
        renameIdents(f, "syntax->ast")
    },
    // ...
}
```

**假设输入 (`types2/alias.go`):**

```go
package types2

import "cmd/compile/internal/syntax"

type MyAlias struct {
    Underlying syntax.Type
}
```

**执行 `go test -run=Generate -write=alias.go` 后，期望输出 (`go/types/alias.go`):**

```go
// Code generated by "go test -run=Generate -write=alias.go"; DO NOT EDIT.
// Source: ../../../cmd/compile/internal/types2/alias.go

package types

import "go/ast"

type MyAlias struct {
    Underlying ast.Expr
}
```

**代码推理：**

- `renameImportPath` 函数将 `"cmd/compile/internal/syntax"` 替换为 `"go/ast"`。
- `renameIdents` 函数将所有 `syntax` 替换为 `ast`。由于 `syntax.Type` 在 `go/ast` 中可能对应 `ast.Expr`，更精确的转换可能需要 `renameSelectorExprs(f, "syntax.Type->ast.Expr")`。

**命令行参数的具体处理：**

- `-write=""`: 如果不设置 `-write` 参数，`TestGenerate` 函数只会比较 `go/types` 目录下的文件和生成的代码，如果发现不一致会报错，但不会写入文件。
- `-write="filename.go"`:  只会生成或更新指定的 `filename.go` 文件。例如，`-write="alias.go"` 只会处理 `alias.go` 文件。
- `-write="all"`: 会生成或更新 `filemap` 中定义的所有文件。这是同步所有 `go/types` 源文件的常用方式。

**使用者易犯错的点：**

1. **手动修改 `go/types` 下的文件:**  由于这些文件是自动生成的，任何手动修改都会在下次运行生成脚本时被覆盖。

   **例子：** 开发者为了临时修复一个问题，直接修改了 `go/types/object.go` 中的代码。当运行 `go test -run=Generate -write=object.go` 或 `go test -run=Generate -write=all` 后，他所做的修改会丢失。

2. **修改了 `types2` 的代码后忘记运行生成脚本:**  如果 `cmd/compile/internal/types2` 中的代码被修改，而没有运行 `go test -run=Generate -write=all` 来同步更改，`go/types` 中的代码就会过时，可能导致不一致性。

   **例子：** 开发者修改了 `types2/named.go` 中某个结构体的字段名，但忘记运行生成脚本。`go/types/named.go` 中的结构体定义仍然是旧的，这可能会导致编译错误或运行时问题。

总而言之，`generate_test.go` 是一个关键的内部工具，用于维护 `go/types` 包的代码同步和转换，确保标准库提供的类型检查 API 与编译器内部的实现保持一致。理解其工作原理对于参与 Go 语言的开发和维护至关重要。

Prompt: 
```
这是路径为go/src/go/types/generate_test.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
请用中文回答。

"""
// Copyright 2023 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file implements a custom generator to create various go/types
// source files from the corresponding types2 files.

package types_test

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"internal/diff"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"testing"
)

var filesToWrite = flag.String("write", "", `go/types files to generate, or "all" for all files`)

const (
	srcDir = "/src/cmd/compile/internal/types2/"
	dstDir = "/src/go/types/"
)

// TestGenerate verifies that generated files in go/types match their types2
// counterpart. If -write is set, this test actually writes the expected
// content to go/types; otherwise, it just compares with the existing content.
func TestGenerate(t *testing.T) {
	// If filesToWrite is set, write the generated content to disk.
	// In the special case of "all", write all files in filemap.
	write := *filesToWrite != ""
	var files []string // files to process
	if *filesToWrite != "" && *filesToWrite != "all" {
		files = strings.Split(*filesToWrite, ",")
	} else {
		for file := range filemap {
			files = append(files, file)
		}
	}

	for _, filename := range files {
		generate(t, filename, write)
	}
}

func generate(t *testing.T, filename string, write bool) {
	// parse src (cmd/compile/internal/types2)
	srcFilename := filepath.FromSlash(runtime.GOROOT() + srcDir + filename)
	file, err := parser.ParseFile(fset, srcFilename, nil, parser.ParseComments)
	if err != nil {
		t.Fatal(err)
	}

	// fix package name
	file.Name.Name = strings.ReplaceAll(file.Name.Name, "types2", "types")

	// rewrite AST as needed
	if action := filemap[filename]; action != nil {
		action(file)
	}

	// format AST
	var buf bytes.Buffer
	rel, _ := filepath.Rel(dstDir, srcDir)
	fmt.Fprintf(&buf, "// Code generated by \"go test -run=Generate -write=all\"; DO NOT EDIT.\n")
	fmt.Fprintf(&buf, "// Source: %s/%s\n\n", filepath.ToSlash(rel), filename)
	if err := format.Node(&buf, fset, file); err != nil {
		t.Fatal(err)
	}
	generatedContent := buf.Bytes()

	// read dst (go/types)
	dstFilename := filepath.FromSlash(runtime.GOROOT() + dstDir + filename)
	onDiskContent, err := os.ReadFile(dstFilename)
	if err != nil {
		t.Fatalf("reading %q: %v", filename, err)
	}

	// compare on-disk dst with buffer generated from src.
	if d := diff.Diff(filename+" (on disk in "+dstDir+")", onDiskContent, filename+" (generated from "+srcDir+")", generatedContent); d != nil {
		if write {
			t.Logf("applying change:\n%s", d)
			if err := os.WriteFile(dstFilename, generatedContent, 0o644); err != nil {
				t.Fatalf("writing %q: %v", filename, err)
			}
		} else {
			t.Errorf("file on disk in %s is stale:\n%s", dstDir, d)
		}
	}
}

type action func(in *ast.File)

var filemap = map[string]action{
	"alias.go": fixTokenPos,
	"assignments.go": func(f *ast.File) {
		renameImportPath(f, `"cmd/compile/internal/syntax"->"go/ast"`)
		renameSelectorExprs(f, "syntax.Name->ast.Ident", "ident.Value->ident.Name", "ast.Pos->token.Pos") // must happen before renaming identifiers
		renameIdents(f, "syntax->ast", "poser->positioner", "nopos->noposn")
	},
	"array.go":          nil,
	"api_predicates.go": nil,
	"basic.go":          nil,
	"builtins.go": func(f *ast.File) {
		renameImportPath(f, `"cmd/compile/internal/syntax"->"go/ast"`)
		renameIdents(f, "syntax->ast")
		renameSelectors(f, "ArgList->Args")
		fixSelValue(f)
		fixAtPosCall(f)
	},
	"builtins_test.go": func(f *ast.File) {
		renameImportPath(f, `"cmd/compile/internal/syntax"->"go/ast"`, `"cmd/compile/internal/types2"->"go/types"`)
		renameSelectorExprs(f, "syntax.Name->ast.Ident", "p.Value->p.Name") // must happen before renaming identifiers
		renameIdents(f, "syntax->ast")
	},
	"chan.go":         nil,
	"const.go":        fixTokenPos,
	"context.go":      nil,
	"context_test.go": nil,
	"conversions.go":  nil,
	"errors_test.go":  func(f *ast.File) { renameIdents(f, "nopos->noposn") },
	"errsupport.go":   nil,
	"gccgosizes.go":   nil,
	"gcsizes.go":      func(f *ast.File) { renameIdents(f, "IsSyncAtomicAlign64->_IsSyncAtomicAlign64") },
	"hilbert_test.go": func(f *ast.File) { renameImportPath(f, `"cmd/compile/internal/types2"->"go/types"`) },
	"infer.go":        func(f *ast.File) { fixTokenPos(f); fixInferSig(f) },
	"initorder.go":    nil,
	// "initorder.go": fixErrErrorfCall, // disabled for now due to unresolved error_ use implications for gopls
	"instantiate.go":      func(f *ast.File) { fixTokenPos(f); fixCheckErrorfCall(f) },
	"instantiate_test.go": func(f *ast.File) { renameImportPath(f, `"cmd/compile/internal/types2"->"go/types"`) },
	"literals.go": func(f *ast.File) {
		insertImportPath(f, `"go/token"`)
		renameImportPath(f, `"cmd/compile/internal/syntax"->"go/ast"`)
		renameSelectorExprs(f,
			"syntax.IntLit->token.INT", "syntax.FloatLit->token.FLOAT", "syntax.ImagLit->token.IMAG",
			"syntax.Name->ast.Ident", "key.Value->key.Name", "atyp.Elem->atyp.Elt") // must happen before renaming identifiers
		renameIdents(f, "syntax->ast")
		renameSelectors(f, "ElemList->Elts")
	},
	"lookup.go":    func(f *ast.File) { fixTokenPos(f) },
	"main_test.go": nil,
	"map.go":       nil,
	"mono.go": func(f *ast.File) {
		fixTokenPos(f)
		insertImportPath(f, `"go/ast"`)
		renameSelectorExprs(f, "syntax.Expr->ast.Expr")
	},
	"named.go":  func(f *ast.File) { fixTokenPos(f); renameSelectors(f, "Trace->_Trace") },
	"object.go": func(f *ast.File) { fixTokenPos(f); renameIdents(f, "NewTypeNameLazy->_NewTypeNameLazy") },
	// TODO(gri) needs adjustments for TestObjectString - disabled for now
	// "object_test.go": func(f *ast.File) { renameImportPath(f, `"cmd/compile/internal/types2"->"go/types"`) },
	"objset.go": nil,
	"operand.go": func(f *ast.File) {
		insertImportPath(f, `"go/token"`)
		renameImportPath(f, `"cmd/compile/internal/syntax"->"go/ast"`)
		renameSelectorExprs(f,
			"syntax.Pos->token.Pos", "syntax.LitKind->token.Token",
			"syntax.IntLit->token.INT", "syntax.FloatLit->token.FLOAT",
			"syntax.ImagLit->token.IMAG", "syntax.RuneLit->token.CHAR",
			"syntax.StringLit->token.STRING") // must happen before renaming identifiers
		renameIdents(f, "syntax->ast")
	},
	"package.go":    nil,
	"pointer.go":    nil,
	"predicates.go": nil,
	"recording.go": func(f *ast.File) {
		renameImportPath(f, `"cmd/compile/internal/syntax"->"go/ast"`)
		renameSelectorExprs(f, "syntax.Name->ast.Ident") // must happen before renaming identifiers
		renameIdents(f, "syntax->ast")
		fixAtPosCall(f)
	},
	"scope.go":         func(f *ast.File) { fixTokenPos(f); renameIdents(f, "InsertLazy->_InsertLazy") },
	"selection.go":     nil,
	"sizes.go":         func(f *ast.File) { renameIdents(f, "IsSyncAtomicAlign64->_IsSyncAtomicAlign64") },
	"slice.go":         nil,
	"subst.go":         func(f *ast.File) { fixTokenPos(f); renameSelectors(f, "Trace->_Trace") },
	"termlist.go":      nil,
	"termlist_test.go": nil,
	"tuple.go":         nil,
	"typelists.go":     nil,
	"typeset.go":       func(f *ast.File) { fixTokenPos(f); renameSelectors(f, "Trace->_Trace") },
	"typeparam.go":     nil,
	"typeterm_test.go": nil,
	"typeterm.go":      nil,
	"typestring.go":    nil,
	"under.go":         nil,
	"unify.go":         fixSprintf,
	"universe.go":      fixGlobalTypVarDecl,
	"util_test.go":     fixTokenPos,
	"validtype.go":     func(f *ast.File) { fixTokenPos(f); renameSelectors(f, "Trace->_Trace") },
}

// TODO(gri) We should be able to make these rewriters more configurable/composable.
//           For now this is a good starting point.

// A renameMap maps old strings to new strings.
type renameMap map[string]string

// makeRenameMap returns a renameMap populates from renames entries of the form "from->to".
func makeRenameMap(renames ...string) renameMap {
	m := make(renameMap)
	for _, r := range renames {
		s := strings.Split(r, "->")
		if len(s) != 2 {
			panic("invalid rename entry: " + r)
		}
		m[s[0]] = s[1]
	}
	return m
}

// rename renames the given string s if a corresponding rename exists in m.
func (m renameMap) rename(s *string) {
	if r, ok := m[*s]; ok {
		*s = r
	}
}

// renameSel renames a selector expression of the form a.x to b.x (where a, b are identifiers)
// if m contains the ("a.x" : "b.y") key-value pair.
func (m renameMap) renameSel(n *ast.SelectorExpr) {
	if a, _ := n.X.(*ast.Ident); a != nil {
		a_x := a.Name + "." + n.Sel.Name
		if r, ok := m[a_x]; ok {
			b_y := strings.Split(r, ".")
			if len(b_y) != 2 {
				panic("invalid selector expression: " + r)
			}
			a.Name = b_y[0]
			n.Sel.Name = b_y[1]
		}
	}
}

// renameIdents renames identifiers: each renames entry is of the form "from->to".
// Note: This doesn't change the use of the identifiers in comments.
func renameIdents(f *ast.File, renames ...string) {
	m := makeRenameMap(renames...)
	ast.Inspect(f, func(n ast.Node) bool {
		switch n := n.(type) {
		case *ast.Ident:
			m.rename(&n.Name)
			return false
		}
		return true
	})
}

// renameSelectors is like renameIdents but only looks at selectors.
func renameSelectors(f *ast.File, renames ...string) {
	m := makeRenameMap(renames...)
	ast.Inspect(f, func(n ast.Node) bool {
		switch n := n.(type) {
		case *ast.SelectorExpr:
			m.rename(&n.Sel.Name)
			return false
		}
		return true
	})

}

// renameSelectorExprs is like renameIdents but only looks at selector expressions.
// Each renames entry must be of the form "x.a->y.b".
func renameSelectorExprs(f *ast.File, renames ...string) {
	m := makeRenameMap(renames...)
	ast.Inspect(f, func(n ast.Node) bool {
		switch n := n.(type) {
		case *ast.SelectorExpr:
			m.renameSel(n)
			return false
		}
		return true
	})
}

// renameImportPath is like renameIdents but renames import paths.
func renameImportPath(f *ast.File, renames ...string) {
	m := makeRenameMap(renames...)
	ast.Inspect(f, func(n ast.Node) bool {
		switch n := n.(type) {
		case *ast.ImportSpec:
			if n.Path.Kind != token.STRING {
				panic("invalid import path")
			}
			m.rename(&n.Path.Value)
			return false
		}
		return true
	})
}

// insertImportPath inserts the given import path.
// There must be at least one import declaration present already.
func insertImportPath(f *ast.File, path string) {
	for _, d := range f.Decls {
		if g, _ := d.(*ast.GenDecl); g != nil && g.Tok == token.IMPORT {
			g.Specs = append(g.Specs, &ast.ImportSpec{Path: &ast.BasicLit{ValuePos: g.End(), Kind: token.STRING, Value: path}})
			return
		}
	}
	panic("no import declaration present")
}

// fixTokenPos changes imports of "cmd/compile/internal/syntax" to "go/token",
// uses of syntax.Pos to token.Pos, and calls to x.IsKnown() to x.IsValid().
func fixTokenPos(f *ast.File) {
	m := makeRenameMap(`"cmd/compile/internal/syntax"->"go/token"`, "syntax.Pos->token.Pos", "IsKnown->IsValid")
	ast.Inspect(f, func(n ast.Node) bool {
		switch n := n.(type) {
		case *ast.ImportSpec:
			// rewrite import path "cmd/compile/internal/syntax" to "go/token"
			if n.Path.Kind != token.STRING {
				panic("invalid import path")
			}
			m.rename(&n.Path.Value)
			return false
		case *ast.SelectorExpr:
			// rewrite syntax.Pos to token.Pos
			m.renameSel(n)
		case *ast.CallExpr:
			// rewrite x.IsKnown() to x.IsValid()
			if fun, _ := n.Fun.(*ast.SelectorExpr); fun != nil && len(n.Args) == 0 {
				m.rename(&fun.Sel.Name)
				return false
			}
		}
		return true
	})
}

// fixSelValue updates the selector x.Sel.Value to x.Sel.Name.
func fixSelValue(f *ast.File) {
	ast.Inspect(f, func(n ast.Node) bool {
		switch n := n.(type) {
		case *ast.SelectorExpr:
			if n.Sel.Name == "Value" {
				if selx, _ := n.X.(*ast.SelectorExpr); selx != nil && selx.Sel.Name == "Sel" {
					n.Sel.Name = "Name"
					return false
				}
			}
		}
		return true
	})
}

// fixInferSig updates the Checker.infer signature to use a positioner instead of a token.Position
// as first argument, renames the argument from "pos" to "posn", and updates a few internal uses of
// "pos" to "posn" and "posn.Pos()" respectively.
func fixInferSig(f *ast.File) {
	ast.Inspect(f, func(n ast.Node) bool {
		switch n := n.(type) {
		case *ast.FuncDecl:
			if n.Name.Name == "infer" {
				// rewrite (pos token.Pos, ...) to (posn positioner, ...)
				par := n.Type.Params.List[0]
				if len(par.Names) == 1 && par.Names[0].Name == "pos" {
					par.Names[0] = newIdent(par.Names[0].Pos(), "posn")
					par.Type = newIdent(par.Type.Pos(), "positioner")
					return true
				}
			}
		case *ast.CallExpr:
			if selx, _ := n.Fun.(*ast.SelectorExpr); selx != nil {
				switch selx.Sel.Name {
				case "renameTParams":
					// rewrite check.renameTParams(pos, ... ) to check.renameTParams(posn.Pos(), ... )
					if isIdent(n.Args[0], "pos") {
						pos := n.Args[0].Pos()
						fun := &ast.SelectorExpr{X: newIdent(pos, "posn"), Sel: newIdent(pos, "Pos")}
						arg := &ast.CallExpr{Fun: fun, Lparen: pos, Args: nil, Ellipsis: token.NoPos, Rparen: pos}
						n.Args[0] = arg
						return false
					}
				case "addf":
					// rewrite err.addf(pos, ...) to err.addf(posn, ...)
					if isIdent(n.Args[0], "pos") {
						pos := n.Args[0].Pos()
						arg := newIdent(pos, "posn")
						n.Args[0] = arg
						return false
					}
				case "allowVersion":
					// rewrite check.allowVersion(pos, ...) to check.allowVersion(posn, ...)
					if isIdent(n.Args[0], "pos") {
						pos := n.Args[0].Pos()
						arg := newIdent(pos, "posn")
						n.Args[0] = arg
						return false
					}
				}
			}
		}
		return true
	})
}

// fixAtPosCall updates calls of the form atPos(x) to x.Pos() in argument lists of (check).dump calls.
// TODO(gri) can we avoid this and just use atPos consistently in go/types and types2?
func fixAtPosCall(f *ast.File) {
	ast.Inspect(f, func(n ast.Node) bool {
		switch n := n.(type) {
		case *ast.CallExpr:
			if selx, _ := n.Fun.(*ast.SelectorExpr); selx != nil && selx.Sel.Name == "dump" {
				for i, arg := range n.Args {
					if call, _ := arg.(*ast.CallExpr); call != nil {
						// rewrite xxx.dump(..., atPos(x), ...) to xxx.dump(..., x.Pos(), ...)
						if isIdent(call.Fun, "atPos") {
							pos := call.Args[0].Pos()
							fun := &ast.SelectorExpr{X: call.Args[0], Sel: newIdent(pos, "Pos")}
							n.Args[i] = &ast.CallExpr{Fun: fun, Lparen: pos, Rparen: pos}
							return false
						}
					}
				}
			}
		}
		return true
	})
}

// fixErrErrorfCall updates calls of the form err.addf(obj, ...) to err.addf(obj.Pos(), ...).
func fixErrErrorfCall(f *ast.File) {
	ast.Inspect(f, func(n ast.Node) bool {
		switch n := n.(type) {
		case *ast.CallExpr:
			if selx, _ := n.Fun.(*ast.SelectorExpr); selx != nil {
				if isIdent(selx.X, "err") {
					switch selx.Sel.Name {
					case "errorf":
						// rewrite err.addf(obj, ... ) to err.addf(obj.Pos(), ... )
						if ident, _ := n.Args[0].(*ast.Ident); ident != nil && ident.Name == "obj" {
							pos := n.Args[0].Pos()
							fun := &ast.SelectorExpr{X: ident, Sel: newIdent(pos, "Pos")}
							n.Args[0] = &ast.CallExpr{Fun: fun, Lparen: pos, Rparen: pos}
							return false
						}
					}
				}
			}
		}
		return true
	})
}

// fixCheckErrorfCall updates calls of the form check.errorf(pos, ...) to check.errorf(atPos(pos), ...).
func fixCheckErrorfCall(f *ast.File) {
	ast.Inspect(f, func(n ast.Node) bool {
		switch n := n.(type) {
		case *ast.CallExpr:
			if selx, _ := n.Fun.(*ast.SelectorExpr); selx != nil {
				if isIdent(selx.X, "check") {
					switch selx.Sel.Name {
					case "errorf":
						// rewrite check.errorf(pos, ... ) to check.errorf(atPos(pos), ... )
						if ident := asIdent(n.Args[0], "pos"); ident != nil {
							pos := n.Args[0].Pos()
							fun := newIdent(pos, "atPos")
							n.Args[0] = &ast.CallExpr{Fun: fun, Lparen: pos, Args: []ast.Expr{ident}, Rparen: pos}
							return false
						}
					}
				}
			}
		}
		return true
	})
}

// fixGlobalTypVarDecl changes the global Typ variable from an array to a slice
// (in types2 we use an array for efficiency, in go/types it's a slice and we
// cannot change that).
func fixGlobalTypVarDecl(f *ast.File) {
	ast.Inspect(f, func(n ast.Node) bool {
		switch n := n.(type) {
		case *ast.ValueSpec:
			// rewrite type Typ = [...]Type{...} to type Typ = []Type{...}
			if len(n.Names) == 1 && n.Names[0].Name == "Typ" && len(n.Values) == 1 {
				n.Values[0].(*ast.CompositeLit).Type.(*ast.ArrayType).Len = nil
				return false
			}
		}
		return true
	})
}

// fixSprintf adds an extra nil argument for the *token.FileSet parameter in sprintf calls.
func fixSprintf(f *ast.File) {
	ast.Inspect(f, func(n ast.Node) bool {
		switch n := n.(type) {
		case *ast.CallExpr:
			if isIdent(n.Fun, "sprintf") && len(n.Args) >= 4 /* ... args */ {
				n.Args = insert(n.Args, 1, newIdent(n.Args[1].Pos(), "nil"))
				return false
			}
		}
		return true
	})
}

// asIdent returns x as *ast.Ident if it is an identifier with the given name.
func asIdent(x ast.Node, name string) *ast.Ident {
	if ident, _ := x.(*ast.Ident); ident != nil && ident.Name == name {
		return ident
	}
	return nil
}

// isIdent reports whether x is an identifier with the given name.
func isIdent(x ast.Node, name string) bool {
	return asIdent(x, name) != nil
}

// newIdent returns a new identifier with the given position and name.
func newIdent(pos token.Pos, name string) *ast.Ident {
	id := ast.NewIdent(name)
	id.NamePos = pos
	return id
}

// insert inserts x at list[at] and moves the remaining elements up.
func insert(list []ast.Expr, at int, x ast.Expr) []ast.Expr {
	list = append(list, nil)
	copy(list[at+1:], list[at:])
	list[at] = x
	return list
}

"""



```
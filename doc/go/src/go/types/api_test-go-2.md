Response:
The user wants a summary of the functionality of the provided Go code snippet, which is part 3 of 4 of the `api_test.go` file in the `go/types` package.

The code consists of several test functions. I need to analyze each test function and identify its purpose.

Based on the function names and the code within them, I can infer the following functionalities being tested:

- **`TestIssue8518` and `TestIssue59603`**: These tests seem to be regression tests for specific issues, likely checking that the type checker doesn't crash in certain scenarios.
- **`TestLookupFieldOrMethodOnNil` and `TestLookupFieldOrMethod`**: These tests examine the behavior of the `LookupFieldOrMethod` function, including how it handles nil types and different types of field/method lookups (on regular and generic types, with and without collisions, and on addressable vs. non-addressable values).
- **`TestLookupFieldOrMethod_RecursiveGeneric`**: This test specifically checks `LookupFieldOrMethod` with recursive generic types, likely to address a specific issue (`go.dev/issue/52715`).
- **`TestConvertibleTo` and `TestAssignableTo`**: These tests verify the behavior of the `ConvertibleTo` and `AssignableTo` functions, checking under what conditions one type can be converted to or assigned to another.
- **`TestIdentical` and `TestIdentical_issue15173`**: These tests check the `Identical` function, which determines if two types are identical, covering basic types, named types, aliases, functions, and generic functions. It also checks the handling of nil arguments.
- **`TestIdenticalUnions`**: This test focuses on the `Identical` function specifically for union types.
- **`TestIssue61737`**: This test verifies that the API allows the creation of invalid interfaces (with duplicate methods), which is sometimes necessary for importers.
- **`TestNewAlias_Issue65455`**: This test checks that the `NewAlias` function doesn't panic in specific cases.
- **`TestIssue15305`**: This test likely checks the type inference for function calls with undefined arguments.
- **`TestCompositeLitTypes`**: This test verifies that the `Info.Types` map correctly records the types of composite literals and their type expressions.
- **`TestObjectParents`**: This test checks the parent scope relationships for different types of objects (variables, functions, methods).
- **`TestFailedImport`**: This test examines how the type checker handles failed imports and prevents follow-on errors.
- **`TestInstantiate` and `TestInstantiateConcurrent`**: These tests verify the behavior of the `Instantiate` function for generic types, including concurrent access.
- **`TestInstantiateErrors`**: This test checks the error handling of the `Instantiate` function when incorrect type arguments are provided.
- **`TestArgumentErrorUnwrapping`**: This test checks if `ArgumentError` can be unwrapped to get the underlying error.
- **`TestInstanceIdentity`**: This test verifies that instantiations of the same generic type with the same type arguments in different packages are considered identical.
- **`TestInstantiatedObjects`**: This test checks the properties of instantiated objects, such as their origin and parent.
- **`TestImplements`**: This test verifies the `Implements` function, which checks if a type implements an interface, and also tests the `AssertableTo` function.
- **`TestMissingMethodAlternative`**: This test examines the `MissingMethod` function, which helps identify missing or incorrectly typed methods when checking interface implementation.
- **`TestErrorURL`**: This test checks if error messages generated by the type checker include a URL for more information.
- **`TestModuleVersion` and `TestFileVersions`**: These tests verify how the type checker handles Go module and file versions.
这部分代码主要集中在测试 `go/types` 包中的一些关键功能，特别是关于**类型查找、类型转换、类型同一性判断、泛型实例化、接口实现检查以及错误处理**等方面。

**功能归纳：**

这部分代码的功能可以归纳为对 `go/types` 包中以下功能的详细测试：

1. **类型成员查找 (`LookupFieldOrMethod`)**: 测试在给定类型下查找字段或方法的功能，包括对结构体、指针、接口以及泛型的查找，并考虑了可寻址性、方法提升和命名冲突等情况。
2. **类型转换和赋值 (`ConvertibleTo`, `AssignableTo`)**: 测试判断一个类型的值是否可以转换为或赋值给另一个类型的功能，涵盖了基本类型、命名类型、切片和数组等。
3. **类型同一性判断 (`Identical`)**: 测试判断两个类型是否完全相同的功能，包括基本类型、命名类型、别名、函数类型和泛型函数类型。也包括了对 union 类型的判断。
4. **泛型实例化 (`Instantiate`)**: 测试泛型类型的实例化功能，包括基本实例化、并发实例化以及实例化过程中可能出现的错误处理。
5. **接口实现检查 (`Implements`, `MissingMethod`)**: 测试判断一个类型是否实现了某个接口的功能，并能识别出缺少或签名不匹配的方法。
6. **错误处理和信息 (`ErrorURL`)**: 测试类型检查器生成的错误信息是否包含有用的 URL，以便用户了解更多错误详情。
7. **模块和文件版本处理 (`ModuleVersion`, `FileVersions`)**: 测试类型检查器如何处理 Go 模块版本和 `//go:build` 行指定的文件版本。
8. **对象属性 (`ObjectParents`, `InstantiatedObjects`)**: 测试 `Object` 接口中关于父作用域的定义以及实例化对象的属性（例如 Origin）。
9. **其他特定场景的测试**: 包括对特定 issue 的回归测试 (`TestIssue8518`, `TestIssue59603`, `TestIssue61737`, `TestNewAlias_Issue65455`, `TestIssue15305`) 和一些边界情况的测试 (例如对 nil 类型的处理 `TestLookupFieldOrMethodOnNil`)。
10. **处理失败的导入 (`TestFailedImport`)**: 测试当导入包失败时，类型检查器是否能够正确处理，避免产生后续的级联错误。
11. **复合字面量类型推断 (`TestCompositeLitTypes`)**: 测试类型检查器能否正确推断复合字面量的类型。

**Go 代码示例说明：**

以下针对几个主要功能举例说明：

**1. 类型成员查找 (`LookupFieldOrMethod`)**

```go
package main

import (
	"fmt"
	"go/ast"
	"go/token"
	"go/types"
)

func main() {
	fset := token.NewFileSet()
	src := `package p; type T struct { F int }; var x T`
	f, err := parser.ParseFile(fset, "test.go", src, 0)
	if err != nil {
		panic(err)
	}

	conf := types.Config{Importer: nil}
	pkg, err := conf.Check("p", fset, []*ast.File{f}, nil)
	if err != nil {
		panic(err)
	}

	scope := pkg.Scope()
	obj := scope.Lookup("x")
	if obj == nil {
		panic("object 'x' not found")
	}

	field, index, indirect := types.LookupFieldOrMethod(obj.Type(), false, pkg, "F")
	if field != nil {
		fmt.Printf("找到字段: %s, 索引: %v, 是否间接: %v\n", field.Name(), index, indirect)
		// 输出: 找到字段: F, 索引: [0], 是否间接: false
	} else {
		fmt.Println("未找到字段")
	}
}
```

**假设输入:** 上述 `src` 代码定义了一个结构体 `T` 包含字段 `F`，并声明了一个变量 `x` 为 `T` 类型。

**输出:**  `找到字段: F, 索引: [0], 是否间接: false`

**2. 类型转换 (`ConvertibleTo`)**

```go
package main

import (
	"fmt"
	"go/types"
)

func main() {
	intType := types.Typ[types.Int]
	float32Type := types.Typ[types.Float32]
	stringType := types.Typ[types.String]

	fmt.Println(types.ConvertibleTo(intType, float32Type)) // 输出: true
	fmt.Println(types.ConvertibleTo(intType, stringType))  // 输出: true
	fmt.Println(types.ConvertibleTo(float32Type, intType)) // 输出: false
}
```

**假设输入:**  `intType` 代表 `int` 类型，`float32Type` 代表 `float32` 类型， `stringType` 代表 `string` 类型。

**输出:**
```
true
true
false
```

**3. 泛型实例化 (`Instantiate`)**

```go
package main

import (
	"fmt"
	"go/ast"
	"go/token"
	"go/types"
	"go/parser"
)

func main() {
	fset := token.NewFileSet()
	src := `package p; type T[P any] *T[P]`
	f, err := parser.ParseFile(fset, "test.go", src, 0)
	if err != nil {
		panic(err)
	}

	conf := types.Config{Importer: nil}
	pkg, err := conf.Check("p", fset, []*ast.File{f}, nil)
	if err != nil {
		panic(err)
	}

	scope := pkg.Scope()
	tType := scope.Lookup("T").Type().(*types.Named)

	intType := types.Typ[types.Int]
	instantiatedType, err := types.Instantiate(nil, tType, []types.Type{intType}, false)
	if err != nil {
		panic(err)
	}
	fmt.Println(instantiatedType.String()) // 输出: *p.T[int]
}
```

**假设输入:** `src` 代码定义了一个泛型类型 `T`，其类型参数为 `P any`，底层类型为 `*T[P]`。

**输出:** `*p.T[int]`

**命令行参数处理：**

这段代码本身是测试代码，不直接处理命令行参数。`go/types` 包在实际使用中，其行为会受到 `go` 命令以及构建过程的影响，例如通过 `go build` 或 `go run` 命令进行编译和运行。

**使用者易犯错的点：**

在 `go/types` 包的使用中，一些容易犯错的点可能包括：

* **对可寻址性的理解**:  在进行方法查找时，需要区分值类型和指针类型的方法集，以及变量是否可寻址。`LookupFieldOrMethod` 的 `address` 参数就用于指示查找的对象是否可寻址。
* **类型同一性的判断**: 需要理解命名类型和类型别名的区别，以及结构体类型的成员顺序和名称对类型同一性的影响。`Identical` 函数可以帮助进行精确的类型比较。
* **泛型实例化的约束**:  在实例化泛型类型时，提供的类型实参必须满足类型形参的约束。如果约束不满足，`Instantiate` 函数会返回错误。
* **接口实现的理解**:  一个类型要实现一个接口，必须拥有接口中定义的所有方法，并且方法签名（参数和返回值类型）必须完全匹配。`MissingMethod` 函数可以帮助诊断接口实现问题。
* **错误处理**:  类型检查可能会产生多种错误，需要仔细检查错误信息，了解错误的具体原因。`ErrorURL` 提供的链接可以提供更详细的解释。

这部分代码主要通过各种测试用例，覆盖了 `go/types` 包中核心功能的各种场景，确保其行为的正确性和健壮性。

Prompt: 
```
这是路径为go/src/go/types/api_test.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
请用中文回答。
这是第3部分，共4部分，请归纳一下它的功能

"""
d exactly once.
	for syntax := range wantOut {
		t.Errorf("no ast.Selection found with syntax %q", syntax)
	}
}

func TestIssue8518(t *testing.T) {
	fset := token.NewFileSet()
	imports := make(testImporter)
	conf := Config{
		Error:    func(err error) { t.Log(err) }, // don't exit after first error
		Importer: imports,
	}
	makePkg := func(path, src string) {
		imports[path], _ = conf.Check(path, fset, []*ast.File{mustParse(fset, src)}, nil) // errors logged via conf.Error
	}

	const libSrc = `
package a
import "missing"
const C1 = foo
const C2 = missing.C
`

	const mainSrc = `
package main
import "a"
var _ = a.C1
var _ = a.C2
`

	makePkg("a", libSrc)
	makePkg("main", mainSrc) // don't crash when type-checking this package
}

func TestIssue59603(t *testing.T) {
	fset := token.NewFileSet()
	imports := make(testImporter)
	conf := Config{
		Error:    func(err error) { t.Log(err) }, // don't exit after first error
		Importer: imports,
	}
	makePkg := func(path, src string) {
		imports[path], _ = conf.Check(path, fset, []*ast.File{mustParse(fset, src)}, nil) // errors logged via conf.Error
	}

	const libSrc = `
package a
const C = foo
`

	const mainSrc = `
package main
import "a"
const _ = a.C
`

	makePkg("a", libSrc)
	makePkg("main", mainSrc) // don't crash when type-checking this package
}

func TestLookupFieldOrMethodOnNil(t *testing.T) {
	// LookupFieldOrMethod on a nil type is expected to produce a run-time panic.
	defer func() {
		const want = "LookupFieldOrMethod on nil type"
		p := recover()
		if s, ok := p.(string); !ok || s != want {
			t.Fatalf("got %v, want %s", p, want)
		}
	}()
	LookupFieldOrMethod(nil, false, nil, "")
}

func TestLookupFieldOrMethod(t *testing.T) {
	// Test cases assume a lookup of the form a.f or x.f, where a stands for an
	// addressable value, and x for a non-addressable value (even though a variable
	// for ease of test case writing).
	//
	// Should be kept in sync with TestMethodSet.
	var tests = []struct {
		src      string
		found    bool
		index    []int
		indirect bool
	}{
		// field lookups
		{"var x T; type T struct{}", false, nil, false},
		{"var x T; type T struct{ f int }", true, []int{0}, false},
		{"var x T; type T struct{ a, b, f, c int }", true, []int{2}, false},

		// field lookups on a generic type
		{"var x T[int]; type T[P any] struct{}", false, nil, false},
		{"var x T[int]; type T[P any] struct{ f P }", true, []int{0}, false},
		{"var x T[int]; type T[P any] struct{ a, b, f, c P }", true, []int{2}, false},

		// method lookups
		{"var a T; type T struct{}; func (T) f() {}", true, []int{0}, false},
		{"var a *T; type T struct{}; func (T) f() {}", true, []int{0}, true},
		{"var a T; type T struct{}; func (*T) f() {}", true, []int{0}, false},
		{"var a *T; type T struct{}; func (*T) f() {}", true, []int{0}, true}, // TODO(gri) should this report indirect = false?

		// method lookups on a generic type
		{"var a T[int]; type T[P any] struct{}; func (T[P]) f() {}", true, []int{0}, false},
		{"var a *T[int]; type T[P any] struct{}; func (T[P]) f() {}", true, []int{0}, true},
		{"var a T[int]; type T[P any] struct{}; func (*T[P]) f() {}", true, []int{0}, false},
		{"var a *T[int]; type T[P any] struct{}; func (*T[P]) f() {}", true, []int{0}, true}, // TODO(gri) should this report indirect = false?

		// collisions
		{"type ( E1 struct{ f int }; E2 struct{ f int }; x struct{ E1; *E2 })", false, []int{1, 0}, false},
		{"type ( E1 struct{ f int }; E2 struct{}; x struct{ E1; *E2 }); func (E2) f() {}", false, []int{1, 0}, false},

		// collisions on a generic type
		{"type ( E1[P any] struct{ f P }; E2[P any] struct{ f P }; x struct{ E1[int]; *E2[int] })", false, []int{1, 0}, false},
		{"type ( E1[P any] struct{ f P }; E2[P any] struct{}; x struct{ E1[int]; *E2[int] }); func (E2[P]) f() {}", false, []int{1, 0}, false},

		// outside methodset
		// (*T).f method exists, but value of type T is not addressable
		{"var x T; type T struct{}; func (*T) f() {}", false, nil, true},

		// outside method set of a generic type
		{"var x T[int]; type T[P any] struct{}; func (*T[P]) f() {}", false, nil, true},

		// recursive generic types; see go.dev/issue/52715
		{"var a T[int]; type ( T[P any] struct { *N[P] }; N[P any] struct { *T[P] } ); func (N[P]) f() {}", true, []int{0, 0}, true},
		{"var a T[int]; type ( T[P any] struct { *N[P] }; N[P any] struct { *T[P] } ); func (T[P]) f() {}", true, []int{0}, false},
	}

	for _, test := range tests {
		pkg := mustTypecheck("package p;"+test.src, nil, nil)

		obj := pkg.Scope().Lookup("a")
		if obj == nil {
			if obj = pkg.Scope().Lookup("x"); obj == nil {
				t.Errorf("%s: incorrect test case - no object a or x", test.src)
				continue
			}
		}

		f, index, indirect := LookupFieldOrMethod(obj.Type(), obj.Name() == "a", pkg, "f")
		if (f != nil) != test.found {
			if f == nil {
				t.Errorf("%s: got no object; want one", test.src)
			} else {
				t.Errorf("%s: got object = %v; want none", test.src, f)
			}
		}
		if !slices.Equal(index, test.index) {
			t.Errorf("%s: got index = %v; want %v", test.src, index, test.index)
		}
		if indirect != test.indirect {
			t.Errorf("%s: got indirect = %v; want %v", test.src, indirect, test.indirect)
		}
	}
}

// Test for go.dev/issue/52715
func TestLookupFieldOrMethod_RecursiveGeneric(t *testing.T) {
	const src = `
package pkg

type Tree[T any] struct {
	*Node[T]
}

func (*Tree[R]) N(r R) R { return r }

type Node[T any] struct {
	*Tree[T]
}

type Instance = *Tree[int]
`

	fset := token.NewFileSet()
	f := mustParse(fset, src)
	pkg := NewPackage("pkg", f.Name.Name)
	if err := NewChecker(nil, fset, pkg, nil).Files([]*ast.File{f}); err != nil {
		panic(err)
	}

	T := pkg.Scope().Lookup("Instance").Type()
	_, _, _ = LookupFieldOrMethod(T, false, pkg, "M") // verify that LookupFieldOrMethod terminates
}

// newDefined creates a new defined type named T with the given underlying type.
// Helper function for use with TestIncompleteInterfaces only.
func newDefined(underlying Type) *Named {
	tname := NewTypeName(nopos, nil, "T", nil)
	return NewNamed(tname, underlying, nil)
}

func TestConvertibleTo(t *testing.T) {
	for _, test := range []struct {
		v, t Type
		want bool
	}{
		{Typ[Int], Typ[Int], true},
		{Typ[Int], Typ[Float32], true},
		{Typ[Int], Typ[String], true},
		{newDefined(Typ[Int]), Typ[Int], true},
		{newDefined(new(Struct)), new(Struct), true},
		{newDefined(Typ[Int]), new(Struct), false},
		{Typ[UntypedInt], Typ[Int], true},
		{NewSlice(Typ[Int]), NewArray(Typ[Int], 10), true},
		{NewSlice(Typ[Int]), NewArray(Typ[Uint], 10), false},
		{NewSlice(Typ[Int]), NewPointer(NewArray(Typ[Int], 10)), true},
		{NewSlice(Typ[Int]), NewPointer(NewArray(Typ[Uint], 10)), false},
		// Untyped string values are not permitted by the spec, so the behavior below is undefined.
		{Typ[UntypedString], Typ[String], true},
	} {
		if got := ConvertibleTo(test.v, test.t); got != test.want {
			t.Errorf("ConvertibleTo(%v, %v) = %t, want %t", test.v, test.t, got, test.want)
		}
	}
}

func TestAssignableTo(t *testing.T) {
	for _, test := range []struct {
		v, t Type
		want bool
	}{
		{Typ[Int], Typ[Int], true},
		{Typ[Int], Typ[Float32], false},
		{newDefined(Typ[Int]), Typ[Int], false},
		{newDefined(new(Struct)), new(Struct), true},
		{Typ[UntypedBool], Typ[Bool], true},
		{Typ[UntypedString], Typ[Bool], false},
		// Neither untyped string nor untyped numeric assignments arise during
		// normal type checking, so the below behavior is technically undefined by
		// the spec.
		{Typ[UntypedString], Typ[String], true},
		{Typ[UntypedInt], Typ[Int], true},
	} {
		if got := AssignableTo(test.v, test.t); got != test.want {
			t.Errorf("AssignableTo(%v, %v) = %t, want %t", test.v, test.t, got, test.want)
		}
	}
}

func TestIdentical(t *testing.T) {
	// For each test, we compare the types of objects X and Y in the source.
	tests := []struct {
		src  string
		want bool
	}{
		// Basic types.
		{"var X int; var Y int", true},
		{"var X int; var Y string", false},

		// TODO: add more tests for complex types.

		// Named types.
		{"type X int; type Y int", false},

		// Aliases.
		{"type X = int; type Y = int", true},

		// Functions.
		{`func X(int) string { return "" }; func Y(int) string { return "" }`, true},
		{`func X() string { return "" }; func Y(int) string { return "" }`, false},
		{`func X(int) string { return "" }; func Y(int) {}`, false},

		// Generic functions. Type parameters should be considered identical modulo
		// renaming. See also go.dev/issue/49722.
		{`func X[P ~int](){}; func Y[Q ~int]() {}`, true},
		{`func X[P1 any, P2 ~*P1](){}; func Y[Q1 any, Q2 ~*Q1]() {}`, true},
		{`func X[P1 any, P2 ~[]P1](){}; func Y[Q1 any, Q2 ~*Q1]() {}`, false},
		{`func X[P ~int](P){}; func Y[Q ~int](Q) {}`, true},
		{`func X[P ~string](P){}; func Y[Q ~int](Q) {}`, false},
		{`func X[P ~int]([]P){}; func Y[Q ~int]([]Q) {}`, true},
	}

	for _, test := range tests {
		pkg := mustTypecheck("package p;"+test.src, nil, nil)
		X := pkg.Scope().Lookup("X")
		Y := pkg.Scope().Lookup("Y")
		if X == nil || Y == nil {
			t.Fatal("test must declare both X and Y")
		}
		if got := Identical(X.Type(), Y.Type()); got != test.want {
			t.Errorf("Identical(%s, %s) = %t, want %t", X.Type(), Y.Type(), got, test.want)
		}
	}
}

func TestIdentical_issue15173(t *testing.T) {
	// Identical should allow nil arguments and be symmetric.
	for _, test := range []struct {
		x, y Type
		want bool
	}{
		{Typ[Int], Typ[Int], true},
		{Typ[Int], nil, false},
		{nil, Typ[Int], false},
		{nil, nil, true},
	} {
		if got := Identical(test.x, test.y); got != test.want {
			t.Errorf("Identical(%v, %v) = %t", test.x, test.y, got)
		}
	}
}

func TestIdenticalUnions(t *testing.T) {
	tname := NewTypeName(nopos, nil, "myInt", nil)
	myInt := NewNamed(tname, Typ[Int], nil)
	tmap := map[string]*Term{
		"int":     NewTerm(false, Typ[Int]),
		"~int":    NewTerm(true, Typ[Int]),
		"string":  NewTerm(false, Typ[String]),
		"~string": NewTerm(true, Typ[String]),
		"myInt":   NewTerm(false, myInt),
	}
	makeUnion := func(s string) *Union {
		parts := strings.Split(s, "|")
		var terms []*Term
		for _, p := range parts {
			term := tmap[p]
			if term == nil {
				t.Fatalf("missing term %q", p)
			}
			terms = append(terms, term)
		}
		return NewUnion(terms)
	}
	for _, test := range []struct {
		x, y string
		want bool
	}{
		// These tests are just sanity checks. The tests for type sets and
		// interfaces provide much more test coverage.
		{"int|~int", "~int", true},
		{"myInt|~int", "~int", true},
		{"int|string", "string|int", true},
		{"int|int|string", "string|int", true},
		{"myInt|string", "int|string", false},
	} {
		x := makeUnion(test.x)
		y := makeUnion(test.y)
		if got := Identical(x, y); got != test.want {
			t.Errorf("Identical(%v, %v) = %t", test.x, test.y, got)
		}
	}
}

func TestIssue61737(t *testing.T) {
	// This test verifies that it is possible to construct invalid interfaces
	// containing duplicate methods using the go/types API.
	//
	// It must be possible for importers to construct such invalid interfaces.
	// Previously, this panicked.

	sig1 := NewSignatureType(nil, nil, nil, NewTuple(NewParam(nopos, nil, "", Typ[Int])), nil, false)
	sig2 := NewSignatureType(nil, nil, nil, NewTuple(NewParam(nopos, nil, "", Typ[String])), nil, false)

	methods := []*Func{
		NewFunc(nopos, nil, "M", sig1),
		NewFunc(nopos, nil, "M", sig2),
	}

	embeddedMethods := []*Func{
		NewFunc(nopos, nil, "M", sig2),
	}
	embedded := NewInterfaceType(embeddedMethods, nil)
	iface := NewInterfaceType(methods, []Type{embedded})
	iface.Complete()
}

func TestNewAlias_Issue65455(t *testing.T) {
	obj := NewTypeName(nopos, nil, "A", nil)
	alias := NewAlias(obj, Typ[Int])
	alias.Underlying() // must not panic
}

func TestIssue15305(t *testing.T) {
	const src = "package p; func f() int16; var _ = f(undef)"
	fset := token.NewFileSet()
	f := mustParse(fset, src)
	conf := Config{
		Error: func(err error) {}, // allow errors
	}
	info := &Info{
		Types: make(map[ast.Expr]TypeAndValue),
	}
	conf.Check("p", fset, []*ast.File{f}, info) // ignore result
	for e, tv := range info.Types {
		if _, ok := e.(*ast.CallExpr); ok {
			if tv.Type != Typ[Int16] {
				t.Errorf("CallExpr has type %v, want int16", tv.Type)
			}
			return
		}
	}
	t.Errorf("CallExpr has no type")
}

// TestCompositeLitTypes verifies that Info.Types registers the correct
// types for composite literal expressions and composite literal type
// expressions.
func TestCompositeLitTypes(t *testing.T) {
	for i, test := range []struct {
		lit, typ string
	}{
		{`[16]byte{}`, `[16]byte`},
		{`[...]byte{}`, `[0]byte`},                // test for go.dev/issue/14092
		{`[...]int{1, 2, 3}`, `[3]int`},           // test for go.dev/issue/14092
		{`[...]int{90: 0, 98: 1, 2}`, `[100]int`}, // test for go.dev/issue/14092
		{`[]int{}`, `[]int`},
		{`map[string]bool{"foo": true}`, `map[string]bool`},
		{`struct{}{}`, `struct{}`},
		{`struct{x, y int; z complex128}{}`, `struct{x int; y int; z complex128}`},
	} {
		fset := token.NewFileSet()
		f := mustParse(fset, fmt.Sprintf("package p%d; var _ = %s", i, test.lit))
		types := make(map[ast.Expr]TypeAndValue)
		if _, err := new(Config).Check("p", fset, []*ast.File{f}, &Info{Types: types}); err != nil {
			t.Fatalf("%s: %v", test.lit, err)
		}

		cmptype := func(x ast.Expr, want string) {
			tv, ok := types[x]
			if !ok {
				t.Errorf("%s: no Types entry found", test.lit)
				return
			}
			if tv.Type == nil {
				t.Errorf("%s: type is nil", test.lit)
				return
			}
			if got := tv.Type.String(); got != want {
				t.Errorf("%s: got %v, want %s", test.lit, got, want)
			}
		}

		// test type of composite literal expression
		rhs := f.Decls[0].(*ast.GenDecl).Specs[0].(*ast.ValueSpec).Values[0]
		cmptype(rhs, test.typ)

		// test type of composite literal type expression
		cmptype(rhs.(*ast.CompositeLit).Type, test.typ)
	}
}

// TestObjectParents verifies that objects have parent scopes or not
// as specified by the Object interface.
func TestObjectParents(t *testing.T) {
	const src = `
package p

const C = 0

type T1 struct {
	a, b int
	T2
}

type T2 interface {
	im1()
	im2()
}

func (T1) m1() {}
func (*T1) m2() {}

func f(x int) { y := x; print(y) }
`

	fset := token.NewFileSet()
	f := mustParse(fset, src)

	info := &Info{
		Defs: make(map[*ast.Ident]Object),
	}
	if _, err := new(Config).Check("p", fset, []*ast.File{f}, info); err != nil {
		t.Fatal(err)
	}

	for ident, obj := range info.Defs {
		if obj == nil {
			// only package names and implicit vars have a nil object
			// (in this test we only need to handle the package name)
			if ident.Name != "p" {
				t.Errorf("%v has nil object", ident)
			}
			continue
		}

		// struct fields, type-associated and interface methods
		// have no parent scope
		wantParent := true
		switch obj := obj.(type) {
		case *Var:
			if obj.IsField() {
				wantParent = false
			}
		case *Func:
			if obj.Signature().Recv() != nil { // method
				wantParent = false
			}
		}

		gotParent := obj.Parent() != nil
		switch {
		case gotParent && !wantParent:
			t.Errorf("%v: want no parent, got %s", ident, obj.Parent())
		case !gotParent && wantParent:
			t.Errorf("%v: no parent found", ident)
		}
	}
}

// TestFailedImport tests that we don't get follow-on errors
// elsewhere in a package due to failing to import a package.
func TestFailedImport(t *testing.T) {
	testenv.MustHaveGoBuild(t)

	const src = `
package p

import foo "go/types/thisdirectorymustnotexistotherwisethistestmayfail/foo" // should only see an error here

const c = foo.C
type T = foo.T
var v T = c
func f(x T) T { return foo.F(x) }
`
	fset := token.NewFileSet()
	f := mustParse(fset, src)
	files := []*ast.File{f}

	// type-check using all possible importers
	for _, compiler := range []string{"gc", "gccgo", "source"} {
		errcount := 0
		conf := Config{
			Error: func(err error) {
				// we should only see the import error
				if errcount > 0 || !strings.Contains(err.Error(), "could not import") {
					t.Errorf("for %s importer, got unexpected error: %v", compiler, err)
				}
				errcount++
			},
			Importer: importer.For(compiler, nil),
		}

		info := &Info{
			Uses: make(map[*ast.Ident]Object),
		}
		pkg, _ := conf.Check("p", fset, files, info)
		if pkg == nil {
			t.Errorf("for %s importer, type-checking failed to return a package", compiler)
			continue
		}

		imports := pkg.Imports()
		if len(imports) != 1 {
			t.Errorf("for %s importer, got %d imports, want 1", compiler, len(imports))
			continue
		}
		imp := imports[0]
		if imp.Name() != "foo" {
			t.Errorf(`for %s importer, got %q, want "foo"`, compiler, imp.Name())
			continue
		}

		// verify that all uses of foo refer to the imported package foo (imp)
		for ident, obj := range info.Uses {
			if ident.Name == "foo" {
				if obj, ok := obj.(*PkgName); ok {
					if obj.Imported() != imp {
						t.Errorf("%s resolved to %v; want %v", ident, obj.Imported(), imp)
					}
				} else {
					t.Errorf("%s resolved to %v; want package name", ident, obj)
				}
			}
		}
	}
}

func TestInstantiate(t *testing.T) {
	// eventually we like more tests but this is a start
	const src = "package p; type T[P any] *T[P]"
	pkg := mustTypecheck(src, nil, nil)

	// type T should have one type parameter
	T := pkg.Scope().Lookup("T").Type().(*Named)
	if n := T.TypeParams().Len(); n != 1 {
		t.Fatalf("expected 1 type parameter; found %d", n)
	}

	// instantiation should succeed (no endless recursion)
	// even with a nil *Checker
	res, err := Instantiate(nil, T, []Type{Typ[Int]}, false)
	if err != nil {
		t.Fatal(err)
	}

	// instantiated type should point to itself
	if p := res.Underlying().(*Pointer).Elem(); p != res {
		t.Fatalf("unexpected result type: %s points to %s", res, p)
	}
}

func TestInstantiateConcurrent(t *testing.T) {
	const src = `package p

type I[P any] interface {
	m(P)
	n() P
}

type J = I[int]

type Nested[P any] *interface{b(P)}

type K = Nested[string]
`
	pkg := mustTypecheck(src, nil, nil)

	insts := []*Interface{
		pkg.Scope().Lookup("J").Type().Underlying().(*Interface),
		pkg.Scope().Lookup("K").Type().Underlying().(*Pointer).Elem().(*Interface),
	}

	// Use the interface instances concurrently.
	for _, inst := range insts {
		var (
			counts  [2]int      // method counts
			methods [2][]string // method strings
		)
		var wg sync.WaitGroup
		for i := 0; i < 2; i++ {
			i := i
			wg.Add(1)
			go func() {
				defer wg.Done()

				counts[i] = inst.NumMethods()
				for mi := 0; mi < counts[i]; mi++ {
					methods[i] = append(methods[i], inst.Method(mi).String())
				}
			}()
		}
		wg.Wait()

		if counts[0] != counts[1] {
			t.Errorf("mismatching method counts for %s: %d vs %d", inst, counts[0], counts[1])
			continue
		}
		for i := 0; i < counts[0]; i++ {
			if m0, m1 := methods[0][i], methods[1][i]; m0 != m1 {
				t.Errorf("mismatching methods for %s: %s vs %s", inst, m0, m1)
			}
		}
	}
}

func TestInstantiateErrors(t *testing.T) {
	tests := []struct {
		src    string // by convention, T must be the type being instantiated
		targs  []Type
		wantAt int // -1 indicates no error
	}{
		{"type T[P interface{~string}] int", []Type{Typ[Int]}, 0},
		{"type T[P1 interface{int}, P2 interface{~string}] int", []Type{Typ[Int], Typ[Int]}, 1},
		{"type T[P1 any, P2 interface{~[]P1}] int", []Type{Typ[Int], NewSlice(Typ[String])}, 1},
		{"type T[P1 interface{~[]P2}, P2 any] int", []Type{NewSlice(Typ[String]), Typ[Int]}, 0},
	}

	for _, test := range tests {
		src := "package p; " + test.src
		pkg := mustTypecheck(src, nil, nil)

		T := pkg.Scope().Lookup("T").Type().(*Named)

		_, err := Instantiate(nil, T, test.targs, true)
		if err == nil {
			t.Fatalf("Instantiate(%v, %v) returned nil error, want non-nil", T, test.targs)
		}

		var argErr *ArgumentError
		if !errors.As(err, &argErr) {
			t.Fatalf("Instantiate(%v, %v): error is not an *ArgumentError", T, test.targs)
		}

		if argErr.Index != test.wantAt {
			t.Errorf("Instantiate(%v, %v): error at index %d, want index %d", T, test.targs, argErr.Index, test.wantAt)
		}
	}
}

func TestArgumentErrorUnwrapping(t *testing.T) {
	var err error = &ArgumentError{
		Index: 1,
		Err:   Error{Msg: "test"},
	}
	var e Error
	if !errors.As(err, &e) {
		t.Fatalf("error %v does not wrap types.Error", err)
	}
	if e.Msg != "test" {
		t.Errorf("e.Msg = %q, want %q", e.Msg, "test")
	}
}

func TestInstanceIdentity(t *testing.T) {
	imports := make(testImporter)
	conf := Config{Importer: imports}
	makePkg := func(src string) {
		fset := token.NewFileSet()
		f := mustParse(fset, src)
		name := f.Name.Name
		pkg, err := conf.Check(name, fset, []*ast.File{f}, nil)
		if err != nil {
			t.Fatal(err)
		}
		imports[name] = pkg
	}
	makePkg(`package lib; type T[P any] struct{}`)
	makePkg(`package a; import "lib"; var A lib.T[int]`)
	makePkg(`package b; import "lib"; var B lib.T[int]`)
	a := imports["a"].Scope().Lookup("A")
	b := imports["b"].Scope().Lookup("B")
	if !Identical(a.Type(), b.Type()) {
		t.Errorf("mismatching types: a.A: %s, b.B: %s", a.Type(), b.Type())
	}
}

// TestInstantiatedObjects verifies properties of instantiated objects.
func TestInstantiatedObjects(t *testing.T) {
	const src = `
package p

type T[P any] struct {
	field P
}

func (recv *T[Q]) concreteMethod(mParam Q) (mResult Q) { return }

type FT[P any] func(ftParam P) (ftResult P)

func F[P any](fParam P) (fResult P){ return }

type I[P any] interface {
	interfaceMethod(P)
}

type R[P any] T[P]

func (R[P]) m() {} // having a method triggers expansion of R

var (
	t T[int]
	ft FT[int]
	f = F[int]
	i I[int]
)

func fn() {
	var r R[int]
	_ = r
}
`
	info := &Info{
		Defs: make(map[*ast.Ident]Object),
	}
	fset := token.NewFileSet()
	f := mustParse(fset, src)
	conf := Config{}
	pkg, err := conf.Check(f.Name.Name, fset, []*ast.File{f}, info)
	if err != nil {
		t.Fatal(err)
	}

	lookup := func(name string) Type { return pkg.Scope().Lookup(name).Type() }
	fnScope := pkg.Scope().Lookup("fn").(*Func).Scope()

	tests := []struct {
		name string
		obj  Object
	}{
		// Struct fields
		{"field", lookup("t").Underlying().(*Struct).Field(0)},
		{"field", fnScope.Lookup("r").Type().Underlying().(*Struct).Field(0)},

		// Methods and method fields
		{"concreteMethod", lookup("t").(*Named).Method(0)},
		{"recv", lookup("t").(*Named).Method(0).Signature().Recv()},
		{"mParam", lookup("t").(*Named).Method(0).Signature().Params().At(0)},
		{"mResult", lookup("t").(*Named).Method(0).Signature().Results().At(0)},

		// Interface methods
		{"interfaceMethod", lookup("i").Underlying().(*Interface).Method(0)},

		// Function type fields
		{"ftParam", lookup("ft").Underlying().(*Signature).Params().At(0)},
		{"ftResult", lookup("ft").Underlying().(*Signature).Results().At(0)},

		// Function fields
		{"fParam", lookup("f").(*Signature).Params().At(0)},
		{"fResult", lookup("f").(*Signature).Results().At(0)},
	}

	// Collect all identifiers by name.
	idents := make(map[string][]*ast.Ident)
	ast.Inspect(f, func(n ast.Node) bool {
		if id, ok := n.(*ast.Ident); ok {
			idents[id.Name] = append(idents[id.Name], id)
		}
		return true
	})

	for _, test := range tests {
		test := test
		t.Run(test.name, func(t *testing.T) {
			if got := len(idents[test.name]); got != 1 {
				t.Fatalf("found %d identifiers named %s, want 1", got, test.name)
			}
			ident := idents[test.name][0]
			def := info.Defs[ident]
			if def == test.obj {
				t.Fatalf("info.Defs[%s] contains the test object", test.name)
			}
			if orig := originObject(test.obj); def != orig {
				t.Errorf("info.Defs[%s] does not match obj.Origin()", test.name)
			}
			if def.Pkg() != test.obj.Pkg() {
				t.Errorf("Pkg() = %v, want %v", def.Pkg(), test.obj.Pkg())
			}
			if def.Name() != test.obj.Name() {
				t.Errorf("Name() = %v, want %v", def.Name(), test.obj.Name())
			}
			if def.Pos() != test.obj.Pos() {
				t.Errorf("Pos() = %v, want %v", def.Pos(), test.obj.Pos())
			}
			if def.Parent() != test.obj.Parent() {
				t.Fatalf("Parent() = %v, want %v", def.Parent(), test.obj.Parent())
			}
			if def.Exported() != test.obj.Exported() {
				t.Fatalf("Exported() = %v, want %v", def.Exported(), test.obj.Exported())
			}
			if def.Id() != test.obj.Id() {
				t.Fatalf("Id() = %v, want %v", def.Id(), test.obj.Id())
			}
			// String and Type are expected to differ.
		})
	}
}

func originObject(obj Object) Object {
	switch obj := obj.(type) {
	case *Var:
		return obj.Origin()
	case *Func:
		return obj.Origin()
	}
	return obj
}

func TestImplements(t *testing.T) {
	const src = `
package p

type EmptyIface interface{}

type I interface {
	m()
}

type C interface {
	m()
	~int
}

type Integer interface{
	int8 | int16 | int32 | int64
}

type EmptyTypeSet interface{
	Integer
	~string
}

type N1 int
func (N1) m() {}

type N2 int
func (*N2) m() {}

type N3 int
func (N3) m(int) {}

type N4 string
func (N4) m()

type Bad Bad // invalid type
`

	fset := token.NewFileSet()
	f := mustParse(fset, src)
	conf := Config{Error: func(error) {}}
	pkg, _ := conf.Check(f.Name.Name, fset, []*ast.File{f}, nil)

	lookup := func(tname string) Type { return pkg.Scope().Lookup(tname).Type() }
	var (
		EmptyIface   = lookup("EmptyIface").Underlying().(*Interface)
		I            = lookup("I").(*Named)
		II           = I.Underlying().(*Interface)
		C            = lookup("C").(*Named)
		CI           = C.Underlying().(*Interface)
		Integer      = lookup("Integer").Underlying().(*Interface)
		EmptyTypeSet = lookup("EmptyTypeSet").Underlying().(*Interface)
		N1           = lookup("N1")
		N1p          = NewPointer(N1)
		N2           = lookup("N2")
		N2p          = NewPointer(N2)
		N3           = lookup("N3")
		N4           = lookup("N4")
		Bad          = lookup("Bad")
	)

	tests := []struct {
		V    Type
		T    *Interface
		want bool
	}{
		{I, II, true},
		{I, CI, false},
		{C, II, true},
		{C, CI, true},
		{Typ[Int8], Integer, true},
		{Typ[Int64], Integer, true},
		{Typ[String], Integer, false},
		{EmptyTypeSet, II, true},
		{EmptyTypeSet, EmptyTypeSet, true},
		{Typ[Int], EmptyTypeSet, false},
		{N1, II, true},
		{N1, CI, true},
		{N1p, II, true},
		{N1p, CI, false},
		{N2, II, false},
		{N2, CI, false},
		{N2p, II, true},
		{N2p, CI, false},
		{N3, II, false},
		{N3, CI, false},
		{N4, II, true},
		{N4, CI, false},
		{Bad, II, false},
		{Bad, CI, false},
		{Bad, EmptyIface, true},
	}

	for _, test := range tests {
		if got := Implements(test.V, test.T); got != test.want {
			t.Errorf("Implements(%s, %s) = %t, want %t", test.V, test.T, got, test.want)
		}

		// The type assertion x.(T) is valid if T is an interface or if T implements the type of x.
		// The assertion is never valid if T is a bad type.
		V := test.T
		T := test.V
		want := false
		if _, ok := T.Underlying().(*Interface); (ok || Implements(T, V)) && T != Bad {
			want = true
		}
		if got := AssertableTo(V, T); got != want {
			t.Errorf("AssertableTo(%s, %s) = %t, want %t", V, T, got, want)
		}
	}
}

func TestMissingMethodAlternative(t *testing.T) {
	const src = `
package p
type T interface {
	m()
}

type V0 struct{}
func (V0) m() {}

type V1 struct{}

type V2 struct{}
func (V2) m() int

type V3 struct{}
func (*V3) m()

type V4 struct{}
func (V4) M()
`

	pkg := mustTypecheck(src, nil, nil)

	T := pkg.Scope().Lookup("T").Type().Underlying().(*Interface)
	lookup := func(name string) (*Func, bool) {
		return MissingMethod(pkg.Scope().Lookup(name).Type(), T, true)
	}

	// V0 has method m with correct signature. Should not report wrongType.
	method, wrongType := lookup("V0")
	if method != nil || wrongType {
		t.Fatalf("V0: got method = %v, wrongType = %v", method, wrongType)
	}

	checkMissingMethod := func(tname string, reportWrongType bool) {
		method, wrongType := lookup(tname)
		if method == nil || method.Name() != "m" || wrongType != reportWrongType {
			t.Fatalf("%s: got method = %v, wrongType = %v", tname, method, wrongType)
		}
	}

	// V1 has no method m. Should not report wrongType.
	checkMissingMethod("V1", false)

	// V2 has method m with wrong signature type (ignoring receiver). Should report wrongType.
	checkMissingMethod("V2", true)

	// V3 has no method m but it exists on *V3. Should report wrongType.
	checkMissingMethod("V3", true)

	// V4 has no method m but has M. Should not report wrongType.
	checkMissingMethod("V4", false)
}

func TestErrorURL(t *testing.T) {
	var conf Config
	*stringFieldAddr(&conf, "_ErrorURL") = " [go.dev/e/%s]"

	// test case for a one-line error
	const src1 = `
package p
var _ T
`
	_, err := typecheck(src1, &conf, nil)
	if err == nil || !strings.HasSuffix(err.Error(), " [go.dev/e/UndeclaredName]") {
		t.Errorf("src1: unexpected error: got %v", err)
	}

	// test case for a multi-line error
	const src2 = `
package p
func f() int { return 0 }
var _ = f(1, 2)
`
	_, err = typecheck(src2, &conf, nil)
	if err == nil || !strings.Contains(err.Error(), " [go.dev/e/WrongArgCount]\n") {
		t.Errorf("src1: unexpected error: got %v", err)
	}
}

func TestModuleVersion(t *testing.T) {
	// version go1.dd must be able to typecheck go1.dd.0, go1.dd.1, etc.
	goversion := fmt.Sprintf("go1.%d", goversion.Version)
	for _, v := range []string{
		goversion,
		goversion + ".0",
		goversion + ".1",
		goversion + ".rc",
	} {
		conf := Config{GoVersion: v}
		pkg := mustTypecheck("package p", &conf, nil)
		if pkg.GoVersion() != conf.GoVersion {
			t.Errorf("got %s; want %s", pkg.GoVersion(), conf.GoVersion)
		}
	}
}

func TestFileVersions(t *testing.T) {
	for _, test := range []struct {
		goVersion   string
		fileVersion string
		wantVersion string
	}{
		{"", "", ""},                    // no versions specified
		{"go1.19", "", "go1.19"},        // module version specified
		{"", "go1.20", "go1.21"},        // file version specified below minimum of 1.21
		{"go1", "", "go1"},              // no file version specified
		{"go1", "goo1.22", "go1"},       // invalid file version specified
		{"go1", "go1.19", "go1.21"},     // file version specified below minimum of 1.21
		{"go1", "go1.20", "go1.21"},     // file version specified below minimum of 1.21
		{"go1", "go1.21", "go1.21"},     // file version specified at 1.21
		{"go1", "go1.22", "go1.22"},     // file version specified above 1.21
		{"go1.19", "", "go1.19"},        // no file version specified
		{"go1.19", "goo1.22", "go1.19"}, // invalid file version specified
		{"go1.19", "go1.20", "go1.21"},  // file version specified below minimum of 1.21
		{"go1.19", "go1.21", "go1.21"},  // file version specified at 1.21
		{"go1.19", "go1.22", "go1.22"},  // file version specified above 1.21
		{"go1.20", "", "go1.20"},        // no file version specified
		{"go1.20", "goo1.22", "go1.20"}, // invalid file version specified
		{"go1.20", "go1.19", "go1.21"},  // file version specified below minimum of 1.21
		{"go1.20", "go1.20", "go1.21"},  // file version specified below minimum of 1.21
		{"go1.20", "go1.21", "go1.21"},  // file version specified at 1.21
		{"go1.20", "go1.22", "go1.22"},  // file version specified above 1.21
		{"go1.21", "", "go1.21"},        // no file version specified
		{"go1.21", "goo1.22", "go1.21"}, // invalid file version specified
		{"go1.21", "go1.19", "go1.21"},  // file version specified below minimum of 1.21
		{"go1.21", "go1.20", "go1.21"},  // file version specified below minimum of 1.21
		{"go1.21", "go1.21", "go1.21"},  // file version specified at 1.21
		{"go1.21", "go1.22", "go1.22"},  // file version specified above 1.21
		{"go1.22", "", "go1.22"},        // no file version specified
		{"go1.22", "goo1.22", "go1.22"}, // invalid file version specified
		{"go1.22", "go1.19", "go1.21"},  // file version specified below minimum of 1.21
		{"go1.22", "go1.20", "go1.21"},  // file version specified below minimum of 1.21
		{"go1.22", "go1.21", "go1.21"},  // file version specified at 1.21
		{"go1.22", "go1.22", "go1.22"},  // file version specified above 1.21

		// versions containing release numbers
		// (file versions containing release numbers are considered invalid)
		{"go1.19.0", "", "go1.19.0"},         // no file version specified
		{"go1.20.1", "go1.19.1", "go1.20.1"}, // invalid file version
		{"go1.20.1", "go1.21.1", "go1.20.1"}, // invalid file version
		{"go1.21.1", "go1.19.1", "go1.21.1"}, // invalid file version
		{"go1.21.1", "go1.21.1", "go1.21.1"}, // invalid file version
		{"go1.22.1", "go1.19.1", "go1.22.1"}, // invalid file version
		{"go1.22.1", "go1.21.1", "go1.22.1"}, // invalid file version
	} {
		var src string
		if test.fileVersion != "" {
			src = "//go:build " + test.fileVersion + "\n"
		}
		src += "package p"

		conf := Config{GoVersion: test.goVersion}
		versions := make(map[*ast.File]string)
		var info Info
		info.FileVersions = versions
		mustTypecheck(src, &conf, &info)

		n := 0
		for _, v := range versions {
			want := test.wantVersion
			if v != want {
				t.Error
"""




```
Response:
Let's break down the thought process for answering the request about `typeset.go`.

1. **Understand the Core Request:** The request asks for the functionality of the provided Go code snippet, what Go feature it implements, examples, handling of command-line arguments, and common pitfalls.

2. **Initial Scan and Identification of Key Structures:**  I first scanned the code for prominent data structures and function names. The `_TypeSet` struct immediately jumps out as central. Its fields (`methods`, `terms`, `comparable`) suggest it represents a collection of types and their properties. The comments reinforce this idea. Keywords like "interface," "type set," "methods," and "terms" are strong clues.

3. **Deciphering `_TypeSet`:** I analyzed the fields of `_TypeSet`:
    * `methods`: A slice of `*Func`, implying methods associated with the type set.
    * `terms`: A `termlist`, which seems to represent the actual types in the set. The comment "type terms of the type set" is key.
    * `comparable`: A boolean indicating if all types in the set are comparable. The invariant comment is also important.

4. **Analyzing Key Functions:** I then examined the methods of `_TypeSet`:
    * `IsEmpty`, `IsAll`, `IsMethodSet`, `IsComparable`: These clearly define the state and properties of a type set. `IsAll` being tied to an empty method list suggests the empty interface.
    * `NumMethods`, `Method`, `LookupMethod`:  These relate to accessing the methods within the type set.
    * `String`: A method for representing the type set as a string, which is useful for debugging and potentially error messages.
    * `hasTerms`, `subsetOf`, `typeset`, `is`: These methods provide more insight into how type sets are manipulated and compared. `typeset` iterates over the types, suggesting a way to access the members. `subsetOf` indicates a set relationship.

5. **Connecting to Go Features:**  The frequent mention of "interface" and the structure of `_TypeSet` strongly suggest this code is related to how Go represents and reasons about interface types, especially with the introduction of type lists in interfaces (Go 1.18+). The presence of "terms" further solidifies this, as type lists are often described as "terms." The `comparable` field points to the `comparable` constraint.

6. **Formulating the Core Functionality:** Based on the above, I concluded that this code is about representing the type set of an interface, including its methods and the types it encompasses (type lists). This allows the Go compiler to perform type checking and determine if a given type satisfies an interface.

7. **Developing Go Code Examples:**  To illustrate the functionality, I created examples that demonstrate:
    * Basic interfaces with methods.
    * Interfaces with type lists (using the `|` syntax).
    * Interfaces with embedded interfaces.
    * The `comparable` constraint.
    * How the compiler uses this information during type checking.

8. **Inferring Input and Output (for Code Reasoning):**  For the code reasoning part, I selected specific functions like `IsEmpty`, `IsAll`, and `IsComparable` and provided concrete examples of `_TypeSet` instances to show how these functions would behave with different inputs. This demonstrates the internal logic.

9. **Considering Command-Line Arguments:** I carefully reviewed the code for any interaction with command-line arguments. The comment `// Code generated by "go test -run=Generate -write=all"` suggests this file is auto-generated, likely as part of the Go build process or testing. Therefore, the direct usage of command-line arguments within *this specific file* is unlikely. I noted that the generation process itself involves command-line arguments, but the *runtime* behavior of this code doesn't directly process them.

10. **Identifying Potential Pitfalls:** I thought about how developers might misuse or misunderstand interfaces with type lists:
    * Forgetting that the order of types in a type list doesn't matter.
    * Misunderstanding that type lists are a union, not an intersection (at the term level).
    * Not realizing that methods and type lists interact (a type must satisfy both).
    * Incorrectly assuming that a type list automatically makes an interface comparable (the `comparable` keyword is needed).

11. **Structuring the Answer:** I organized the answer into the requested sections: functionality, Go feature implementation (with code examples), code reasoning (with input/output), command-line arguments, and common mistakes. Using clear headings and bullet points enhances readability.

12. **Refinement and Review:** I reread my answer and the code snippet to ensure accuracy and completeness. I made sure the Go code examples were valid and directly related to the described functionality. I also double-checked the explanation of command-line arguments and common pitfalls.

This systematic approach, moving from the general structure to the specific details, and constantly connecting the code to higher-level Go concepts, allowed me to generate a comprehensive and accurate answer. The iterative process of examining the code, formulating hypotheses, and then testing those hypotheses with examples is crucial for understanding complex code like this.
è¿™æ®µä»£ç æ˜¯ Go è¯­è¨€ `go/types` åŒ…ä¸­ `typeset.go` æ–‡ä»¶çš„ä¸€éƒ¨åˆ†ï¼Œå®ƒå®šä¹‰äº† `_TypeSet` ç»“æ„ä½“ä»¥åŠä¸å…¶ç›¸å…³çš„æ“ä½œã€‚`_TypeSet` ç»“æ„ä½“ç”¨äºè¡¨ç¤ºä¸€ä¸ªæ¥å£çš„ç±»å‹é›†åˆ (type set)ã€‚

**åŠŸèƒ½åˆ—ä¸¾:**

1. **è¡¨ç¤ºæ¥å£çš„ç±»å‹é›†åˆ:** `_TypeSet` ç»“æ„ä½“ç”¨äºå­˜å‚¨å’Œè¡¨ç¤ºä¸€ä¸ªæ¥å£æ‰€åŒ…å«çš„ç±»å‹é›†åˆã€‚è¿™åŒ…æ‹¬æ¥å£æ˜¾å¼å£°æ˜çš„æ–¹æ³•ã€é€šè¿‡åµŒå…¥æ¥å£ç»§æ‰¿çš„æ–¹æ³•ï¼Œä»¥åŠæ¥å£å®šä¹‰çš„ç±»å‹çº¦æŸï¼ˆtype termsï¼‰ã€‚

2. **ç®¡ç†æ¥å£çš„æ–¹æ³•:** `_TypeSet` å­˜å‚¨äº†æ¥å£çš„æ‰€æœ‰æ–¹æ³• (`methods` å­—æ®µ)ï¼Œå¹¶æŒ‰ç…§å”¯ä¸€çš„ ID æ’åºã€‚æä¾›äº†æŸ¥æ‰¾æ–¹æ³• (`LookupMethod`) å’Œè·å–æŒ‡å®šç´¢å¼•çš„æ–¹æ³• (`Method`) çš„åŠŸèƒ½ã€‚

3. **ç®¡ç†æ¥å£çš„ç±»å‹çº¦æŸ (Type Terms):** `_TypeSet` å­˜å‚¨äº†æ¥å£çš„ç±»å‹çº¦æŸ (`terms` å­—æ®µ)ã€‚ç±»å‹çº¦æŸå®šä¹‰äº†æ»¡è¶³æ¥å£çš„å…·ä½“ç±»å‹ã€‚å®ƒå¯ä»¥æ˜¯å•ä¸ªç±»å‹ã€å…·æœ‰åº•å±‚ç±»å‹çš„ç±»å‹ï¼ˆ`~T`ï¼‰ã€è”åˆç±»å‹ï¼ˆ`T1 | T2`ï¼‰ç­‰ã€‚

4. **è¡¨ç¤ºå¯æ¯”è¾ƒæ€§:** `comparable` å­—æ®µæŒ‡ç¤ºæ¥å£ç±»å‹é›†åˆä¸­çš„æ‰€æœ‰ç±»å‹æ˜¯å¦éƒ½æ˜¯å¯æ¯”è¾ƒçš„ã€‚

5. **åˆ¤æ–­ç±»å‹é›†åˆçš„çŠ¶æ€:** æä¾›äº† `IsEmpty` (æ˜¯å¦ä¸ºç©ºé›†)ã€`IsAll` (æ˜¯å¦åŒ…å«æ‰€æœ‰ç±»å‹ï¼Œå¯¹åº”ç©ºæ¥å£)ã€`IsMethodSet` (æ¥å£æ˜¯å¦å®Œå…¨ç”±å…¶æ–¹æ³•é›†æè¿°) ç­‰æ–¹æ³•æ¥åˆ¤æ–­ç±»å‹é›†åˆçš„çŠ¶æ€ã€‚

6. **åˆ¤æ–­å­é›†å…³ç³»:**  `subsetOf` æ–¹æ³•ç”¨äºåˆ¤æ–­ä¸€ä¸ªç±»å‹é›†åˆæ˜¯å¦æ˜¯å¦ä¸€ä¸ªç±»å‹é›†åˆçš„å­é›†ã€‚

7. **éå†ç±»å‹é›†åˆ:** `typeset` æ–¹æ³•æä¾›äº†ä¸€ç§éå†ç±»å‹é›†åˆä¸­ç±»å‹çš„æ–¹å¼ã€‚

8. **åˆ¤æ–­ç±»å‹æ˜¯å¦åœ¨é›†åˆä¸­:** `is` æ–¹æ³•å…è®¸ä½¿ç”¨ä¸€ä¸ªå‡½æ•°æ¥æ£€æŸ¥ç±»å‹é›†åˆä¸­çš„æ¯ä¸ªå…·ä½“ç±»å‹æ˜¯å¦æ»¡è¶³æŸä¸ªæ¡ä»¶ã€‚

9. **è®¡ç®—æ¥å£çš„ç±»å‹é›†åˆ:** `computeInterfaceTypeSet` å‡½æ•°ç”¨äºè®¡ç®—ç»™å®šæ¥å£çš„ç±»å‹é›†åˆã€‚è¿™ä¸ªè¿‡ç¨‹æ¶‰åŠåˆ°æ”¶é›†æ¥å£çš„æ–¹æ³•ã€å¤„ç†åµŒå…¥çš„æ¥å£å’Œç±»å‹çº¦æŸã€‚

10. **è®¡ç®—è”åˆç±»å‹çš„ç±»å‹é›†åˆ:** `computeUnionTypeSet` å‡½æ•°ç”¨äºè®¡ç®—è”åˆç±»å‹è¡¨è¾¾å¼çš„ç±»å‹é›†åˆã€‚

11. **è®¡ç®—ç±»å‹é›†åˆçš„äº¤é›†:** `intersectTermLists` å‡½æ•°ç”¨äºè®¡ç®—ä¸¤ä¸ªç±»å‹çº¦æŸåˆ—è¡¨çš„äº¤é›†ï¼Œå¹¶æ›´æ–°å¯æ¯”è¾ƒæ€§ä¿¡æ¯ã€‚

**æ¨æ–­çš„ Go è¯­è¨€åŠŸèƒ½å®ç°ï¼šæ¥å£çš„ç±»å‹åˆ—è¡¨å’Œçº¦æŸ (Type Lists and Constraints in Interfaces)**

åœ¨ Go 1.18 ä¸­å¼•å…¥äº†ç±»å‹åˆ—è¡¨å’Œçº¦æŸçš„æ¦‚å¿µï¼Œå…è®¸åœ¨æ¥å£ä¸­æŒ‡å®šæ»¡è¶³æ¥å£çš„å…·ä½“ç±»å‹ã€‚è¿™æ®µä»£ç å¾ˆæ˜æ˜¾æ˜¯ä¸ºå®ç°è¿™ä¸ªåŠŸèƒ½è€Œè®¾è®¡çš„ã€‚

**Go ä»£ç ä¸¾ä¾‹è¯´æ˜:**

å‡è®¾æˆ‘ä»¬æœ‰ä»¥ä¸‹ Go ä»£ç ï¼š

```go
package main

import "fmt"

type A int
type B string

type MyInterface interface {
	~int | string // ç±»å‹çº¦æŸï¼šå¯ä»¥æ˜¯åº•å±‚ç±»å‹ä¸º int æˆ– string çš„ç±»å‹
	Len() int     // æ–¹æ³•
}

func describe(v MyInterface) {
	fmt.Printf("Value: %v, Length: %d\n", v, v.Len())
}

func main() {
	var a A = 10
	var b B = "hello"

	describe(a)
	describe(b)

	// ä»¥ä¸‹ä»£ç ä¼šæŠ¥é”™ï¼Œå› ä¸º float64 ä¸æ»¡è¶³ MyInterface çš„ç±»å‹çº¦æŸ
	// var c float64 = 3.14
	// describe(c)
}

func (a A) Len() int {
	return int(a)
}

func (b B) Len() int {
	return len(b)
}
```

**ä»£ç æ¨ç†:**

**å‡è®¾è¾“å…¥:**  å½“ç¼–è¯‘å™¨å¤„ç† `MyInterface` çš„å®šä¹‰æ—¶ï¼Œ`computeInterfaceTypeSet` å‡½æ•°ä¼šè¢«è°ƒç”¨ã€‚

**å†…éƒ¨å¤„ç†:**

1. **è§£æç±»å‹çº¦æŸ:** ç¼–è¯‘å™¨ä¼šè§£æ `~int | string`ï¼Œç”Ÿæˆä¸€ä¸ªåŒ…å«ä¸¤ä¸ª term çš„ `termlist`: ä¸€ä¸ªæ˜¯åº•å±‚ç±»å‹ä¸º `int` çš„ termï¼Œå¦ä¸€ä¸ªæ˜¯ç±»å‹ä¸º `string` çš„ termã€‚
2. **æ”¶é›†æ–¹æ³•:** ç¼–è¯‘å™¨ä¼šæ”¶é›† `Len() int` æ–¹æ³•ï¼Œå¹¶å°†å…¶å­˜å‚¨åœ¨ `methods` å­—æ®µä¸­ã€‚
3. **æ„å»º `_TypeSet`:**  `computeInterfaceTypeSet` å‡½æ•°ä¼šåˆ›å»ºä¸€ä¸ª `_TypeSet` å®ä¾‹ï¼Œå…¶ä¸­ `terms` å­—æ®µåŒ…å«äº†ä»£è¡¨ `~int` å’Œ `string` çš„ termï¼Œ `methods` å­—æ®µåŒ…å«äº† `Len` æ–¹æ³•çš„ `*Func`ã€‚

**å‡è®¾è¾“å‡º (ç®€åŒ–è¡¨ç¤º):**

```
_TypeSet {
  methods: []*Func{Len},
  terms: termlist{{~true, int}, {false, string}},
  comparable: false,
}
```

* `methods`:  åŒ…å« `Len` æ–¹æ³•ã€‚
* `terms`:  åŒ…å«ä¸¤ä¸ª termï¼Œç¬¬ä¸€ä¸ªè¡¨ç¤ºåº•å±‚ç±»å‹ä¸º `int` (tilde ä¸º true)ï¼Œç¬¬äºŒä¸ªè¡¨ç¤ºç±»å‹ä¸º `string` (tilde ä¸º false)ã€‚
* `comparable`:  `false`ï¼Œå› ä¸ºç±»å‹é›†åˆä¸­å¹¶éæ‰€æœ‰ç±»å‹éƒ½ä¿è¯æ˜¯å¯æ¯”è¾ƒçš„ï¼ˆä¾‹å¦‚ï¼Œè‡ªå®šä¹‰çš„ struct å¦‚æœæ²¡æœ‰å®šä¹‰æ¯”è¾ƒæ“ä½œï¼Œå°±ä¸å¯æ¯”è¾ƒï¼‰ã€‚

**ç±»å‹æ£€æŸ¥:** å½“ç¼–è¯‘å™¨é‡åˆ° `describe(a)` æ—¶ï¼Œä¼šæ£€æŸ¥ `A` æ˜¯å¦æ»¡è¶³ `MyInterface`ã€‚

1. **æ–¹æ³•æ£€æŸ¥:** `A` ç±»å‹å®šä¹‰äº† `Len() int` æ–¹æ³•ï¼Œæ»¡è¶³æ¥å£çš„æ–¹æ³•è¦æ±‚ã€‚
2. **ç±»å‹çº¦æŸæ£€æŸ¥:** `A` çš„åº•å±‚ç±»å‹æ˜¯ `int`ï¼Œä¸ `MyInterface` çš„ç±»å‹çº¦æŸ `~int` åŒ¹é…ã€‚

ç±»ä¼¼åœ°ï¼Œå¯¹äº `describe(b)`ï¼Œ`B` ç±»å‹ä¹Ÿæ»¡è¶³æ¥å£çš„è¦æ±‚ã€‚

å½“é‡åˆ° `describe(c)` æ—¶ï¼Œ`float64` ä¸æ»¡è¶³ `MyInterface` çš„ç±»å‹çº¦æŸï¼Œå› æ­¤ç¼–è¯‘å™¨ä¼šæŠ¥é”™ã€‚

**å‘½ä»¤è¡Œå‚æ•°å¤„ç†:**

è¿™æ®µä»£ç æœ¬èº«å¹¶ä¸ç›´æ¥å¤„ç†å‘½ä»¤è¡Œå‚æ•°ã€‚å®ƒå±äº `go/types` åŒ…ï¼Œæ˜¯ Go è¯­è¨€çš„ç±»å‹æ£€æŸ¥å™¨çš„ä¸€éƒ¨åˆ†ã€‚ç±»å‹æ£€æŸ¥å™¨åœ¨ `go build`, `go run`, `go test` ç­‰å‘½ä»¤æ‰§è¡Œæ—¶è¢«è°ƒç”¨ã€‚

è¿™äº› Go å‘½ä»¤ä¼šå¤„ç†å‘½ä»¤è¡Œå‚æ•°ï¼Œä¾‹å¦‚æŒ‡å®šè¦ç¼–è¯‘çš„åŒ…ã€è®¾ç½®æ„å»ºæ ‡ç­¾ç­‰ã€‚ç±»å‹æ£€æŸ¥å™¨ä¼šæ ¹æ®è¿™äº›å‚æ•°åŠ è½½å’Œåˆ†ææºä»£ç ï¼Œå…¶ä¸­åŒ…æ‹¬å¤„ç†æ¥å£çš„ç±»å‹åˆ—è¡¨å’Œçº¦æŸã€‚

ä¾‹å¦‚ï¼Œå¦‚æœä½ ä½¿ç”¨ `go build main.go` ç¼–è¯‘ä¸Šé¢çš„ä»£ç ï¼Œ`go build` å‘½ä»¤ä¼šè§£æ `main.go` æ–‡ä»¶ï¼Œè°ƒç”¨ç±»å‹æ£€æŸ¥å™¨æ¥éªŒè¯ä»£ç çš„ç±»å‹æ­£ç¡®æ€§ï¼ŒåŒ…æ‹¬æ£€æŸ¥ `A` å’Œ `B` æ˜¯å¦æ»¡è¶³ `MyInterface` çš„çº¦æŸã€‚

**ä½¿ç”¨è€…æ˜“çŠ¯é”™çš„ç‚¹:**

1. **æ··æ·†åº•å±‚ç±»å‹çº¦æŸå’Œå…·ä½“ç±»å‹çº¦æŸ:**  å®¹æ˜“å¿˜è®° `~int` è¡¨ç¤ºåº•å±‚ç±»å‹ä¸º `int` çš„æ‰€æœ‰ç±»å‹ï¼ˆåŒ…æ‹¬è‡ªå®šä¹‰çš„ `type MyInt int`ï¼‰ï¼Œè€Œ `int` åªè¡¨ç¤º `int` ç±»å‹æœ¬èº«ã€‚

   ```go
   type MyInt int

   type MyInterface2 interface {
       int // åªèƒ½æ˜¯ int ç±»å‹
   }

   func foo(i MyInterface2) {}

   func main() {
       var m MyInt = 5
       // foo(m) // é”™è¯¯: MyInt is not type int
       foo(5)  // æ­£ç¡®
   }
   ```

2. **å¿½ç•¥æ–¹æ³•çš„è¦æ±‚:**  å³ä½¿ä¸€ä¸ªç±»å‹æ»¡è¶³äº†æ¥å£çš„ç±»å‹çº¦æŸï¼Œå¦‚æœå®ƒæ²¡æœ‰å®ç°æ¥å£çš„æ‰€æœ‰æ–¹æ³•ï¼Œä»ç„¶ä¸æ»¡è¶³è¯¥æ¥å£ã€‚

   ```go
   type MyString string

   type MyInterface3 interface {
       string
       Len() int
   }

   func bar(s MyInterface3) {}

   func main() {
       var ms MyString = "test"
       // bar(ms) // é”™è¯¯: MyString does not implement MyInterface3 (missing method Len)
   }
   ```

3. **è¯¯è§£ç±»å‹åˆ—è¡¨çš„å«ä¹‰:** ç±»å‹åˆ—è¡¨ä½¿ç”¨ `|` åˆ†éš”ï¼Œè¡¨ç¤ºâ€œæˆ–â€çš„å…³ç³»ï¼Œå³æ»¡è¶³å…¶ä¸­ä»»ä½•ä¸€ä¸ªç±»å‹å³å¯ã€‚å®¹æ˜“è¯¯è§£ä¸ºéœ€è¦åŒæ—¶æ»¡è¶³æ‰€æœ‰ç±»å‹ã€‚

   ```go
   type MyFloat float32

   type MyInterface4 interface {
       int | string | MyFloat
   }

   func baz(v MyInterface4) {}

   func main() {
       baz(10)      // æ­£ç¡®
       baz("hello") // æ­£ç¡®
       baz(MyFloat(3.14)) // æ­£ç¡®
   }
   ```

æ€»è€Œè¨€ä¹‹ï¼Œè¿™æ®µ `typeset.go` ä»£ç æ˜¯ Go è¯­è¨€ç±»å‹ç³»ç»Ÿä¸­å¤„ç†æ¥å£ç±»å‹åˆ—è¡¨å’Œçº¦æŸçš„å…³é”®ç»„æˆéƒ¨åˆ†ï¼Œå®ƒè´Ÿè´£è¡¨ç¤ºã€ç®¡ç†å’Œè®¡ç®—æ¥å£çš„ç±»å‹é›†åˆï¼Œä»è€Œå®ç°æ›´ç²¾ç¡®çš„ç±»å‹æ£€æŸ¥å’Œæ›´å¼ºå¤§çš„æ¥å£è¡¨è¾¾èƒ½åŠ›ã€‚

Prompt: 
```
è¿™æ˜¯è·¯å¾„ä¸ºgo/src/go/types/typeset.goçš„goè¯­è¨€å®ç°çš„ä¸€éƒ¨åˆ†ï¼Œ è¯·åˆ—ä¸¾ä¸€ä¸‹å®ƒçš„åŠŸèƒ½, ã€€
å¦‚æœä½ èƒ½æ¨ç†å‡ºå®ƒæ˜¯ä»€ä¹ˆgoè¯­è¨€åŠŸèƒ½çš„å®ç°ï¼Œè¯·ç”¨goä»£ç ä¸¾ä¾‹è¯´æ˜, 
å¦‚æœæ¶‰åŠä»£ç æ¨ç†ï¼Œéœ€è¦å¸¦ä¸Šå‡è®¾çš„è¾“å…¥ä¸è¾“å‡ºï¼Œ
å¦‚æœæ¶‰åŠå‘½ä»¤è¡Œå‚æ•°çš„å…·ä½“å¤„ç†ï¼Œè¯·è¯¦ç»†ä»‹ç»ä¸€ä¸‹ï¼Œ
å¦‚æœæœ‰å“ªäº›ä½¿ç”¨è€…æ˜“çŠ¯é”™çš„ç‚¹ï¼Œè¯·ä¸¾ä¾‹è¯´æ˜ï¼Œæ²¡æœ‰åˆ™ä¸å¿…è¯´æ˜ï¼Œ
è¯·ç”¨ä¸­æ–‡å›ç­”ã€‚

"""
// Code generated by "go test -run=Generate -write=all"; DO NOT EDIT.
// Source: ../../cmd/compile/internal/types2/typeset.go

// Copyright 2021 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package types

import (
	"go/token"
	. "internal/types/errors"
	"slices"
	"strings"
)

// ----------------------------------------------------------------------------
// API

// A _TypeSet represents the type set of an interface.
// Because of existing language restrictions, methods can be "factored out"
// from the terms. The actual type set is the intersection of the type set
// implied by the methods and the type set described by the terms and the
// comparable bit. To test whether a type is included in a type set
// ("implements" relation), the type must implement all methods _and_ be
// an element of the type set described by the terms and the comparable bit.
// If the term list describes the set of all types and comparable is true,
// only comparable types are meant; in all other cases comparable is false.
type _TypeSet struct {
	methods    []*Func  // all methods of the interface; sorted by unique ID
	terms      termlist // type terms of the type set
	comparable bool     // invariant: !comparable || terms.isAll()
}

// IsEmpty reports whether s is the empty set.
func (s *_TypeSet) IsEmpty() bool { return s.terms.isEmpty() }

// IsAll reports whether s is the set of all types (corresponding to the empty interface).
func (s *_TypeSet) IsAll() bool { return s.IsMethodSet() && len(s.methods) == 0 }

// IsMethodSet reports whether the interface t is fully described by its method set.
func (s *_TypeSet) IsMethodSet() bool { return !s.comparable && s.terms.isAll() }

// IsComparable reports whether each type in the set is comparable.
func (s *_TypeSet) IsComparable(seen map[Type]bool) bool {
	if s.terms.isAll() {
		return s.comparable
	}
	return s.is(func(t *term) bool {
		return t != nil && comparableType(t.typ, false, seen, nil)
	})
}

// NumMethods returns the number of methods available.
func (s *_TypeSet) NumMethods() int { return len(s.methods) }

// Method returns the i'th method of s for 0 <= i < s.NumMethods().
// The methods are ordered by their unique ID.
func (s *_TypeSet) Method(i int) *Func { return s.methods[i] }

// LookupMethod returns the index of and method with matching package and name, or (-1, nil).
func (s *_TypeSet) LookupMethod(pkg *Package, name string, foldCase bool) (int, *Func) {
	return methodIndex(s.methods, pkg, name, foldCase)
}

func (s *_TypeSet) String() string {
	switch {
	case s.IsEmpty():
		return "âˆ…"
	case s.IsAll():
		return "ğ“¤"
	}

	hasMethods := len(s.methods) > 0
	hasTerms := s.hasTerms()

	var buf strings.Builder
	buf.WriteByte('{')
	if s.comparable {
		buf.WriteString("comparable")
		if hasMethods || hasTerms {
			buf.WriteString("; ")
		}
	}
	for i, m := range s.methods {
		if i > 0 {
			buf.WriteString("; ")
		}
		buf.WriteString(m.String())
	}
	if hasMethods && hasTerms {
		buf.WriteString("; ")
	}
	if hasTerms {
		buf.WriteString(s.terms.String())
	}
	buf.WriteString("}")
	return buf.String()
}

// ----------------------------------------------------------------------------
// Implementation

// hasTerms reports whether s has specific type terms.
func (s *_TypeSet) hasTerms() bool { return !s.terms.isEmpty() && !s.terms.isAll() }

// subsetOf reports whether s1 âŠ† s2.
func (s1 *_TypeSet) subsetOf(s2 *_TypeSet) bool { return s1.terms.subsetOf(s2.terms) }

// typeset is an iterator over the (type/underlying type) pairs in s.
// If s has no specific terms, typeset calls yield with (nil, nil).
// In any case, typeset is guaranteed to call yield at least once.
func (s *_TypeSet) typeset(yield func(t, u Type) bool) {
	if !s.hasTerms() {
		yield(nil, nil)
		return
	}

	for _, t := range s.terms {
		assert(t.typ != nil)
		// Unalias(x) == under(x) for ~x terms
		u := Unalias(t.typ)
		if !t.tilde {
			u = under(u)
		}
		if debug {
			assert(Identical(u, under(u)))
		}
		if !yield(t.typ, u) {
			break
		}
	}
}

// is calls f with the specific type terms of s and reports whether
// all calls to f returned true. If there are no specific terms, is
// returns the result of f(nil).
func (s *_TypeSet) is(f func(*term) bool) bool {
	if !s.hasTerms() {
		return f(nil)
	}
	for _, t := range s.terms {
		assert(t.typ != nil)
		if !f(t) {
			return false
		}
	}
	return true
}

// topTypeSet may be used as type set for the empty interface.
var topTypeSet = _TypeSet{terms: allTermlist}

// computeInterfaceTypeSet may be called with check == nil.
func computeInterfaceTypeSet(check *Checker, pos token.Pos, ityp *Interface) *_TypeSet {
	if ityp.tset != nil {
		return ityp.tset
	}

	// If the interface is not fully set up yet, the type set will
	// not be complete, which may lead to errors when using the
	// type set (e.g. missing method). Don't compute a partial type
	// set (and don't store it!), so that we still compute the full
	// type set eventually. Instead, return the top type set and
	// let any follow-on errors play out.
	//
	// TODO(gri) Consider recording when this happens and reporting
	// it as an error (but only if there were no other errors so
	// to not have unnecessary follow-on errors).
	if !ityp.complete {
		return &topTypeSet
	}

	if check != nil && check.conf._Trace {
		// Types don't generally have position information.
		// If we don't have a valid pos provided, try to use
		// one close enough.
		if !pos.IsValid() && len(ityp.methods) > 0 {
			pos = ityp.methods[0].pos
		}

		check.trace(pos, "-- type set for %s", ityp)
		check.indent++
		defer func() {
			check.indent--
			check.trace(pos, "=> %s ", ityp.typeSet())
		}()
	}

	// An infinitely expanding interface (due to a cycle) is detected
	// elsewhere (Checker.validType), so here we simply assume we only
	// have valid interfaces. Mark the interface as complete to avoid
	// infinite recursion if the validType check occurs later for some
	// reason.
	ityp.tset = &_TypeSet{terms: allTermlist} // TODO(gri) is this sufficient?

	var unionSets map[*Union]*_TypeSet
	if check != nil {
		if check.unionTypeSets == nil {
			check.unionTypeSets = make(map[*Union]*_TypeSet)
		}
		unionSets = check.unionTypeSets
	} else {
		unionSets = make(map[*Union]*_TypeSet)
	}

	// Methods of embedded interfaces are collected unchanged; i.e., the identity
	// of a method I.m's Func Object of an interface I is the same as that of
	// the method m in an interface that embeds interface I. On the other hand,
	// if a method is embedded via multiple overlapping embedded interfaces, we
	// don't provide a guarantee which "original m" got chosen for the embedding
	// interface. See also go.dev/issue/34421.
	//
	// If we don't care to provide this identity guarantee anymore, instead of
	// reusing the original method in embeddings, we can clone the method's Func
	// Object and give it the position of a corresponding embedded interface. Then
	// we can get rid of the mpos map below and simply use the cloned method's
	// position.

	var seen objset
	var allMethods []*Func
	mpos := make(map[*Func]token.Pos) // method specification or method embedding position, for good error messages
	addMethod := func(pos token.Pos, m *Func, explicit bool) {
		switch other := seen.insert(m); {
		case other == nil:
			allMethods = append(allMethods, m)
			mpos[m] = pos
		case explicit:
			if check != nil {
				err := check.newError(DuplicateDecl)
				err.addf(atPos(pos), "duplicate method %s", m.name)
				err.addf(atPos(mpos[other.(*Func)]), "other declaration of method %s", m.name)
				err.report()
			}
		default:
			// We have a duplicate method name in an embedded (not explicitly declared) method.
			// Check method signatures after all types are computed (go.dev/issue/33656).
			// If we're pre-go1.14 (overlapping embeddings are not permitted), report that
			// error here as well (even though we could do it eagerly) because it's the same
			// error message.
			if check != nil {
				check.later(func() {
					if pos.IsValid() && !check.allowVersion(go1_14) || !Identical(m.typ, other.Type()) {
						err := check.newError(DuplicateDecl)
						err.addf(atPos(pos), "duplicate method %s", m.name)
						err.addf(atPos(mpos[other.(*Func)]), "other declaration of method %s", m.name)
						err.report()
					}
				}).describef(atPos(pos), "duplicate method check for %s", m.name)
			}
		}
	}

	for _, m := range ityp.methods {
		addMethod(m.pos, m, true)
	}

	// collect embedded elements
	allTerms := allTermlist
	allComparable := false
	for i, typ := range ityp.embeddeds {
		// The embedding position is nil for imported interfaces.
		// We don't need to do version checks in those cases.
		var pos token.Pos // embedding position
		if ityp.embedPos != nil {
			pos = (*ityp.embedPos)[i]
		}
		var comparable bool
		var terms termlist
		switch u := under(typ).(type) {
		case *Interface:
			// For now we don't permit type parameters as constraints.
			assert(!isTypeParam(typ))
			tset := computeInterfaceTypeSet(check, pos, u)
			// If typ is local, an error was already reported where typ is specified/defined.
			if pos.IsValid() && check != nil && check.isImportedConstraint(typ) && !check.verifyVersionf(atPos(pos), go1_18, "embedding constraint interface %s", typ) {
				continue
			}
			comparable = tset.comparable
			for _, m := range tset.methods {
				addMethod(pos, m, false) // use embedding position pos rather than m.pos
			}
			terms = tset.terms
		case *Union:
			if pos.IsValid() && check != nil && !check.verifyVersionf(atPos(pos), go1_18, "embedding interface element %s", u) {
				continue
			}
			tset := computeUnionTypeSet(check, unionSets, pos, u)
			if tset == &invalidTypeSet {
				continue // ignore invalid unions
			}
			assert(!tset.comparable)
			assert(len(tset.methods) == 0)
			terms = tset.terms
		default:
			if !isValid(u) {
				continue
			}
			if pos.IsValid() && check != nil && !check.verifyVersionf(atPos(pos), go1_18, "embedding non-interface type %s", typ) {
				continue
			}
			terms = termlist{{false, typ}}
		}

		// The type set of an interface is the intersection of the type sets of all its elements.
		// Due to language restrictions, only embedded interfaces can add methods, they are handled
		// separately. Here we only need to intersect the term lists and comparable bits.
		allTerms, allComparable = intersectTermLists(allTerms, allComparable, terms, comparable)
	}

	ityp.tset.comparable = allComparable
	if len(allMethods) != 0 {
		sortMethods(allMethods)
		ityp.tset.methods = allMethods
	}
	ityp.tset.terms = allTerms

	return ityp.tset
}

// TODO(gri) The intersectTermLists function belongs to the termlist implementation.
//           The comparable type set may also be best represented as a term (using
//           a special type).

// intersectTermLists computes the intersection of two term lists and respective comparable bits.
// xcomp, ycomp are valid only if xterms.isAll() and yterms.isAll() respectively.
func intersectTermLists(xterms termlist, xcomp bool, yterms termlist, ycomp bool) (termlist, bool) {
	terms := xterms.intersect(yterms)
	// If one of xterms or yterms is marked as comparable,
	// the result must only include comparable types.
	comp := xcomp || ycomp
	if comp && !terms.isAll() {
		// only keep comparable terms
		i := 0
		for _, t := range terms {
			assert(t.typ != nil)
			if comparableType(t.typ, false /* strictly comparable */, nil, nil) {
				terms[i] = t
				i++
			}
		}
		terms = terms[:i]
		if !terms.isAll() {
			comp = false
		}
	}
	assert(!comp || terms.isAll()) // comparable invariant
	return terms, comp
}

func compareFunc(a, b *Func) int {
	return a.cmp(&b.object)
}

func sortMethods(list []*Func) {
	slices.SortFunc(list, compareFunc)
}

func assertSortedMethods(list []*Func) {
	if !debug {
		panic("assertSortedMethods called outside debug mode")
	}
	if !slices.IsSortedFunc(list, compareFunc) {
		panic("methods not sorted")
	}
}

// invalidTypeSet is a singleton type set to signal an invalid type set
// due to an error. It's also a valid empty type set, so consumers of
// type sets may choose to ignore it.
var invalidTypeSet _TypeSet

// computeUnionTypeSet may be called with check == nil.
// The result is &invalidTypeSet if the union overflows.
func computeUnionTypeSet(check *Checker, unionSets map[*Union]*_TypeSet, pos token.Pos, utyp *Union) *_TypeSet {
	if tset, _ := unionSets[utyp]; tset != nil {
		return tset
	}

	// avoid infinite recursion (see also computeInterfaceTypeSet)
	unionSets[utyp] = new(_TypeSet)

	var allTerms termlist
	for _, t := range utyp.terms {
		var terms termlist
		u := under(t.typ)
		if ui, _ := u.(*Interface); ui != nil {
			// For now we don't permit type parameters as constraints.
			assert(!isTypeParam(t.typ))
			terms = computeInterfaceTypeSet(check, pos, ui).terms
		} else if !isValid(u) {
			continue
		} else {
			if t.tilde && !Identical(t.typ, u) {
				// There is no underlying type which is t.typ.
				// The corresponding type set is empty.
				t = nil // âˆ… term
			}
			terms = termlist{(*term)(t)}
		}
		// The type set of a union expression is the union
		// of the type sets of each term.
		allTerms = allTerms.union(terms)
		if len(allTerms) > maxTermCount {
			if check != nil {
				check.errorf(atPos(pos), InvalidUnion, "cannot handle more than %d union terms (implementation limitation)", maxTermCount)
			}
			unionSets[utyp] = &invalidTypeSet
			return unionSets[utyp]
		}
	}
	unionSets[utyp].terms = allTerms

	return unionSets[utyp]
}

"""



```
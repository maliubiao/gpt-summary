Response:
Let's break down the thought process for analyzing the Go test code.

1. **Understand the Goal:** The first step is to recognize that this is a test file (`gcimporter_test.go`). Test files in Go usually verify the functionality of the corresponding non-test file (in this case, `gcimporter.go`). The file path `go/internal/gcimporter` further suggests it's testing an internal part of the Go compiler related to importing compiled packages.

2. **Identify Key Functions and Data Structures:** Scan the code for prominent function names, types, and global variables. This gives a high-level overview of what the code is doing:
    * `TestMain`:  Standard Go test setup.
    * `compile`: A function that invokes the Go compiler. This is a crucial piece, indicating interaction with the build process.
    * `testPath`:  The core function under test, likely responsible for importing packages. The name suggests it deals with file paths.
    * `mktmpdir`:  Creates temporary directories, suggesting tests involve file system operations and isolated environments.
    * Test functions starting with `Test...`: These are the actual test cases. Look for patterns in their names (e.g., `TestImportTestdata`, `TestImportStdLib`, `TestVersionHandling`). These names often hint at the specific functionality being tested.
    * Global variables like `pkgExts` and `importedObjectTests`: These provide hints about the types of data the importer handles and specific test scenarios.

3. **Analyze Individual Test Functions:**  Go through each test function to understand its purpose:
    * `TestImportTestdata`:  Focuses on importing packages from a local "testdata" directory. This is likely for testing basic import functionality with controlled inputs.
    * `TestImportTypeparamTests`: Deals with type parameters (generics), and importantly, it mentions needing export data for the standard library. This suggests testing the interaction of the importer with more complex code and pre-compiled standard library packages. The reference to `GOROOT/test/typeparam` is a key detail.
    * `TestVersionHandling`:  Explicitly tests how the importer handles different versions of compiled package files. The "corrupted" file creation is also significant.
    * `TestImportStdLib`: Tests importing a large number of standard library packages. This is a stress test and also verifies compatibility with the standard library's structure.
    * `TestImportedTypes`: Tests the correct importing and representation of various Go types (interfaces, functions, constants, etc.). The `importedObjectTests` variable provides concrete examples.
    * `TestIssue...`:  These tests address specific bug fixes, providing insights into previous issues the `gcimporter` had. Analyzing these can reveal potential pitfalls or edge cases.
    * `TestCorrectMethodPackage`: Focuses on ensuring methods within imported types have the correct associated package information.
    * The remaining tests continue to explore specific edge cases and interactions with the compiler and type system.

4. **Infer Functionality of `gcimporter`:** Based on the tests, we can deduce the core functionality of `gcimporter`:
    * **Importing Compiled Packages:** The central theme is the ability to load type information from compiled Go packages (likely `.a` or `.o` files).
    * **Handling Export Data:** The tests manipulate and verify "export data," which is the metadata generated by the compiler for use during linking and type checking of dependent packages.
    * **Version Compatibility:** The `TestVersionHandling` explicitly checks the ability to handle different compiler versions and detect corrupted export data.
    * **Type Reconstruction:** The tests with `importedObjectTests` and checks of method receivers show the importer's responsibility to correctly reconstruct Go types (including interfaces, functions, etc.) from the compiled data.
    * **Integration with `go/types`:** The tests frequently use `go/types` to inspect the imported packages, indicating that `gcimporter` likely populates `go/types` data structures.

5. **Identify Potential User Errors:** Look for patterns in the tests that might indicate common mistakes users could make:
    * **Incorrect Import Paths:** The tests with relative paths and manipulation of `importcfg` highlight the importance of correct import paths.
    * **Version Mismatches:** The `TestVersionHandling` suggests that using compiled packages from different Go versions can lead to errors.
    * **Corrupted Package Files:** While less likely for users to *intentionally* do, the test highlights the importer's ability to detect this.

6. **Construct Examples:** Based on the identified functionality, create illustrative Go code examples that demonstrate how `gcimporter` might be used (even though it's an internal package, its behavior can be understood). Focus on scenarios like importing a package and accessing its types and functions.

7. **Address Command-Line Arguments and Assumptions:**  Pay attention to how the `compile` function is used. It shows the command-line arguments passed to the Go compiler. Note assumptions about file locations and the existence of the Go toolchain.

8. **Structure the Answer:** Organize the findings into logical sections (functionality, Go feature implementation, code examples, command-line arguments, potential errors) as requested by the prompt. Use clear and concise language.

9. **Review and Refine:**  Read through the answer to ensure accuracy, completeness, and clarity. Check for any inconsistencies or areas that could be explained better. For instance, initially, I might just say "imports compiled packages," but refining it to "imports compiled Go packages and extracts type information from their export data" is more precise.
这段代码是 Go 语言标准库中 `go/internal/gcimporter` 包的测试文件 `gcimporter_test.go` 的一部分。它的主要功能是**测试 `go/internal/gcimporter` 包的正确性**。

`go/internal/gcimporter` 包是 Go 语言编译器 `gc` 的一个内部组件，它的核心功能是**从编译后的目标文件（通常是 `.o` 或 `.a` 文件）中读取导出的类型信息**。这些导出的信息包含了包中定义的类型、常量、变量、函数等的声明，使得其他包在编译时可以了解并使用这些信息，而无需重新解析源代码。

**可以推理出 `gcimporter` 包是 Go 语言包导入机制的核心实现之一。** 它负责加载已编译包的元数据，使得 Go 的编译器能够进行跨包的类型检查和链接。

**Go 代码举例说明 `gcimporter` 的功能 (模拟)：**

虽然 `go/internal/gcimporter` 是内部包，不能直接在用户代码中使用，但我们可以通过 `go/types` 包来间接体验它的功能。`go/types` 包依赖于 `gcimporter` 来加载已编译包的信息。

假设我们有以下两个 Go 源文件：

**mypkg/mypkg.go:**

```go
package mypkg

// Exported variable
var MyVar int = 10

// Exported function
func MyFunc(x int) int {
	return x * 2
}

// Exported type
type MyType struct {
	Field string
}
```

**main.go:**

```go
package main

import (
	"fmt"
	"mypkg"
)

func main() {
	fmt.Println(mypkg.MyVar)
	fmt.Println(mypkg.MyFunc(5))
	instance := mypkg.MyType{Field: "hello"}
	fmt.Println(instance.Field)
}
```

当我们编译 `main.go` 时，Go 编译器会首先编译 `mypkg/mypkg.go`，生成 `mypkg.o` 或 `mypkg.a` 文件，其中包含了 `mypkg` 的导出信息。然后，在编译 `main.go` 时，`gcimporter` (在 `go/types` 的帮助下) 会读取 `mypkg.o` 或 `mypkg.a` 中的导出信息，以了解 `MyVar`、`MyFunc` 和 `MyType` 的定义，从而进行类型检查，确保 `main.go` 中对 `mypkg` 的使用是合法的。

**假设的输入与输出 (针对 `TestImportTestdata` 函数)：**

`TestImportTestdata` 函数测试从 `testdata` 目录下的 `.go` 文件编译生成的导出数据是否能够正确导入。

**假设输入:**

* `testdata/exports.go`: 包含一些导出的类型、函数和变量，并且 import 了 `go/ast` 和 `go/token` 包。
* 经过 `compile` 函数编译后，会在临时目录下生成 `testdata/exports.o` 文件，其中包含 `exports` 包的导出信息。

**预期输出:**

* `testPath` 函数能够成功导入 `testdata/exports` 包。
* 导入的包的 `Imports()` 方法返回的包列表中，应该包含 `go/ast` 和 `go/token` 这两个包。

**代码推理:**

`TestImportTestdata` 函数的主要流程是：

1. 定义一个包含要测试的 `.go` 文件的 map，例如 `{"exports.go": {"go/ast", "go/token"}}`。
2. 为每个测试文件创建一个临时目录。
3. 使用 `compile` 函数编译 `testdata` 目录下的 `.go` 文件，并将生成的 `.o` 文件放到临时目录下的 `testdata` 目录中。`compile` 函数还会生成一个 `.importcfg` 文件，用于指定导入的包的位置。
4. 使用 `testPath` 函数，调用 `gcimporter.Import` 来导入刚刚编译生成的包。
5. 检查导入的包的 `Imports()` 方法的返回值，确认其中包含了预期的导入包。

**命令行参数的具体处理 (在 `compile` 函数中)：**

`compile` 函数模拟了 Go 编译器的调用，它使用 `testenv.Command` 来构建并执行 `go tool compile` 命令。以下是 `compile` 函数中使用的关键命令行参数：

* `-p <pkgpath>`: 设置编译后包的路径，例如 `testdata/exports`。
* `-D testdata`: 定义一个预处理宏 `testdata`，可能用于条件编译。
* `-importcfg <importcfgfile>`: 指定导入配置文件的路径。这个文件列出了当前编译的包所依赖的其他包的目标文件路径。如果 `packageFiles` 或 `pkgImports` 不为空，`compile` 函数会创建一个 `.importcfg` 文件。
* `-o <outname>`: 指定输出目标文件的路径，例如 `tmpdir/testdata/exports.o`。
* `<filename>`: 要编译的源文件名，例如 `testdata/exports.go`。

**使用者易犯错的点 (基于测试代码的推断)：**

虽然用户不直接使用 `gcimporter`，但从测试代码中可以推断出一些与包导入相关的常见错误：

1. **版本不兼容 (`TestVersionHandling`)**:  使用不同 Go 版本编译的包可能存在导出格式上的差异，导致导入失败。测试代码中尝试导入不同 Go 版本编译的 `.a` 文件，并检查是否抛出预期的错误。
    * **例子:**  假设你使用 Go 1.20 编译了一个包 `mypkg`，然后尝试在一个 Go 1.18 的项目中使用这个编译后的 `mypkg.o` 文件，可能会遇到导入错误。

2. **导出数据损坏 (`TestVersionHandling`)**: 如果 `.o` 或 `.a` 文件中的导出数据被损坏，`gcimporter` 应该能够检测到并报错。测试代码通过故意修改导出数据来模拟这种情况。

3. **循环导入 (虽然此代码未直接测试，但 `gcimporter` 需要处理):**  `gcimporter` 在加载包信息时，需要能够检测并处理循环依赖的情况，避免无限递归。

4. **找不到依赖包 (`TestImportTestdata`, `compile` 函数)**:  如果 `.importcfg` 文件配置不正确，或者依赖包的目标文件不存在，`gcimporter` 将无法找到依赖包的信息。`compile` 函数通过生成 `.importcfg` 文件来模拟这种情况。

5. **类型信息不完整或错误 (`TestImportedTypes`)**:  `gcimporter` 需要正确解析和表示各种 Go 类型，包括接口、函数、结构体等。测试代码通过检查导入的对象的类型信息来验证这一点。
    * **例子:** 如果 `gcimporter` 没有正确处理泛型类型，那么导入包含泛型的包可能会导致类型信息丢失或错误。

总而言之，这段测试代码全面地验证了 `go/internal/gcimporter` 包从编译后的目标文件中正确读取和解析导出类型信息的功能，并涵盖了各种边界情况和潜在的错误场景，确保了 Go 语言包导入机制的稳定性和可靠性。

### 提示词
```
这是路径为go/src/go/internal/gcimporter/gcimporter_test.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
请用中文回答。
```

### 源代码
```go
// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package gcimporter_test

import (
	"bytes"
	"fmt"
	"internal/testenv"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"runtime"
	"strings"
	"sync"
	"testing"
	"time"

	"go/ast"
	"go/build"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"

	. "go/internal/gcimporter"
)

func TestMain(m *testing.M) {
	build.Default.GOROOT = testenv.GOROOT(nil)
	os.Exit(m.Run())
}

// compile runs the compiler on filename, with dirname as the working directory,
// and writes the output file to outdirname.
// compile gives the resulting package a packagepath of testdata/<filebasename>.
func compile(t *testing.T, dirname, filename, outdirname string, packageFiles map[string]string, pkgImports ...string) string {
	// filename must end with ".go"
	basename, ok := strings.CutSuffix(filepath.Base(filename), ".go")
	if !ok {
		t.Fatalf("filename doesn't end in .go: %s", filename)
	}
	objname := basename + ".o"
	outname := filepath.Join(outdirname, objname)

	importcfgfile := os.DevNull
	if len(packageFiles) > 0 || len(pkgImports) > 0 {
		importcfgfile = filepath.Join(outdirname, basename) + ".importcfg"
		testenv.WriteImportcfg(t, importcfgfile, packageFiles, pkgImports...)
	}

	pkgpath := path.Join("testdata", basename)
	cmd := testenv.Command(t, testenv.GoToolPath(t), "tool", "compile", "-p", pkgpath, "-D", "testdata", "-importcfg", importcfgfile, "-o", outname, filename)
	cmd.Dir = dirname
	out, err := cmd.CombinedOutput()
	if err != nil {
		t.Logf("%s", out)
		t.Fatalf("go tool compile %s failed: %s", filename, err)
	}
	return outname
}

func testPath(t *testing.T, path, srcDir string) *types.Package {
	t0 := time.Now()
	fset := token.NewFileSet()
	pkg, err := Import(fset, make(map[string]*types.Package), path, srcDir, nil)
	if err != nil {
		t.Errorf("testPath(%s): %s", path, err)
		return nil
	}
	t.Logf("testPath(%s): %v", path, time.Since(t0))
	return pkg
}

var pkgExts = [...]string{".a", ".o"} // keep in sync with gcimporter.go

func mktmpdir(t *testing.T) string {
	tmpdir, err := os.MkdirTemp("", "gcimporter_test")
	if err != nil {
		t.Fatal("mktmpdir:", err)
	}
	if err := os.Mkdir(filepath.Join(tmpdir, "testdata"), 0700); err != nil {
		os.RemoveAll(tmpdir)
		t.Fatal("mktmpdir:", err)
	}
	return tmpdir
}

func TestImportTestdata(t *testing.T) {
	// This package only handles gc export data.
	if runtime.Compiler != "gc" {
		t.Skipf("gc-built packages not available (compiler = %s)", runtime.Compiler)
	}

	testenv.MustHaveGoBuild(t)

	testfiles := map[string][]string{
		"exports.go":  {"go/ast", "go/token"},
		"generics.go": nil,
	}
	testfiles["exports.go"] = []string{"go/ast"}

	for testfile, wantImports := range testfiles {
		tmpdir := mktmpdir(t)
		defer os.RemoveAll(tmpdir)

		compile(t, "testdata", testfile, filepath.Join(tmpdir, "testdata"), nil, wantImports...)
		path := "./testdata/" + strings.TrimSuffix(testfile, ".go")

		if pkg := testPath(t, path, tmpdir); pkg != nil {
			// The package's Imports list must include all packages
			// explicitly imported by testfile, plus all packages
			// referenced indirectly via exported objects in testfile.
			got := fmt.Sprint(pkg.Imports())
			for _, want := range wantImports {
				if !strings.Contains(got, want) {
					t.Errorf(`Package("exports").Imports() = %s, does not contain %s`, got, want)
				}
			}
		}
	}
}

func TestImportTypeparamTests(t *testing.T) {
	if testing.Short() {
		t.Skipf("in short mode, skipping test that requires export data for all of std")
	}

	// This package only handles gc export data.
	if runtime.Compiler != "gc" {
		t.Skipf("gc-built packages not available (compiler = %s)", runtime.Compiler)
	}

	// cmd/distpack removes the GOROOT/test directory, so skip if it isn't there.
	// cmd/distpack also requires the presence of GOROOT/VERSION, so use that to
	// avoid false-positive skips.
	gorootTest := filepath.Join(testenv.GOROOT(t), "test")
	if _, err := os.Stat(gorootTest); os.IsNotExist(err) {
		if _, err := os.Stat(filepath.Join(testenv.GOROOT(t), "VERSION")); err == nil {
			t.Skipf("skipping: GOROOT/test not present")
		}
	}

	testenv.MustHaveGoBuild(t)

	tmpdir := mktmpdir(t)
	defer os.RemoveAll(tmpdir)

	// Check go files in test/typeparam, except those that fail for a known
	// reason.
	rootDir := filepath.Join(gorootTest, "typeparam")
	list, err := os.ReadDir(rootDir)
	if err != nil {
		t.Fatal(err)
	}

	for _, entry := range list {
		if entry.IsDir() || !strings.HasSuffix(entry.Name(), ".go") {
			// For now, only consider standalone go files.
			continue
		}

		t.Run(entry.Name(), func(t *testing.T) {
			filename := filepath.Join(rootDir, entry.Name())
			src, err := os.ReadFile(filename)
			if err != nil {
				t.Fatal(err)
			}
			if !bytes.HasPrefix(src, []byte("// run")) && !bytes.HasPrefix(src, []byte("// compile")) {
				// We're bypassing the logic of run.go here, so be conservative about
				// the files we consider in an attempt to make this test more robust to
				// changes in test/typeparams.
				t.Skipf("not detected as a run test")
			}

			// Compile and import, and compare the resulting package with the package
			// that was type-checked directly.
			compile(t, rootDir, entry.Name(), filepath.Join(tmpdir, "testdata"), nil, filename)
			pkgName := strings.TrimSuffix(entry.Name(), ".go")
			imported := importPkg(t, "./testdata/"+pkgName, tmpdir)
			checked := checkFile(t, filename, src)

			seen := make(map[string]bool)
			for _, name := range imported.Scope().Names() {
				if !token.IsExported(name) {
					continue // ignore synthetic names like .inittask and .dict.*
				}
				seen[name] = true

				importedObj := imported.Scope().Lookup(name)
				got := types.ObjectString(importedObj, types.RelativeTo(imported))
				got = sanitizeObjectString(got)

				checkedObj := checked.Scope().Lookup(name)
				if checkedObj == nil {
					t.Fatalf("imported object %q was not type-checked", name)
				}
				want := types.ObjectString(checkedObj, types.RelativeTo(checked))
				want = sanitizeObjectString(want)

				if got != want {
					t.Errorf("imported %q as %q, want %q", name, got, want)
				}
			}

			for _, name := range checked.Scope().Names() {
				if !token.IsExported(name) || seen[name] {
					continue
				}
				t.Errorf("did not import object %q", name)
			}
		})
	}
}

// sanitizeObjectString removes type parameter debugging markers from an object
// string, to normalize it for comparison.
// TODO(rfindley): this should not be necessary.
func sanitizeObjectString(s string) string {
	var runes []rune
	for _, r := range s {
		if '₀' <= r && r < '₀'+10 {
			continue // trim type parameter subscripts
		}
		runes = append(runes, r)
	}
	return string(runes)
}

func checkFile(t *testing.T, filename string, src []byte) *types.Package {
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, filename, src, 0)
	if err != nil {
		t.Fatal(err)
	}
	config := types.Config{
		Importer: importer.Default(),
	}
	pkg, err := config.Check("", fset, []*ast.File{f}, nil)
	if err != nil {
		t.Fatal(err)
	}
	return pkg
}

func TestVersionHandling(t *testing.T) {
	testenv.MustHaveGoBuild(t)

	// This package only handles gc export data.
	if runtime.Compiler != "gc" {
		t.Skipf("gc-built packages not available (compiler = %s)", runtime.Compiler)
	}

	const dir = "./testdata/versions"
	list, err := os.ReadDir(dir)
	if err != nil {
		t.Fatal(err)
	}

	tmpdir := mktmpdir(t)
	defer os.RemoveAll(tmpdir)
	corruptdir := filepath.Join(tmpdir, "testdata", "versions")
	if err := os.Mkdir(corruptdir, 0700); err != nil {
		t.Fatal(err)
	}

	fset := token.NewFileSet()

	for _, f := range list {
		name := f.Name()
		if !strings.HasSuffix(name, ".a") {
			continue // not a package file
		}
		if strings.Contains(name, "corrupted") {
			continue // don't process a leftover corrupted file
		}
		pkgpath := "./" + name[:len(name)-2]

		if testing.Verbose() {
			t.Logf("importing %s", name)
		}

		// test that export data can be imported
		_, err := Import(fset, make(map[string]*types.Package), pkgpath, dir, nil)
		if err != nil {
			// ok to fail if it fails with a 'not the start of an archive file' error for select files
			if strings.Contains(err.Error(), "not the start of an archive file") {
				switch name {
				case "test_go1.8_4.a",
					"test_go1.8_5.a":
					continue
				}
				// fall through
			}
			// ok to fail if it fails with a 'no longer supported' error for select files
			if strings.Contains(err.Error(), "no longer supported") {
				switch name {
				case "test_go1.7_0.a",
					"test_go1.7_1.a",
					"test_go1.8_4.a",
					"test_go1.8_5.a",
					"test_go1.11_0i.a",
					"test_go1.11_6b.a",
					"test_go1.11_999b.a",
					"test_go1.11_999i.a":
					continue
				}
				// fall through
			}
			// ok to fail if it fails with a 'newer version' error for select files
			if strings.Contains(err.Error(), "newer version") {
				switch name {
				case "test_go1.11_999i.a":
					continue
				}
				// fall through
			}
			t.Errorf("import %q failed: %v", pkgpath, err)
			continue
		}

		// create file with corrupted export data
		// 1) read file
		data, err := os.ReadFile(filepath.Join(dir, name))
		if err != nil {
			t.Fatal(err)
		}
		// 2) find export data
		i := bytes.Index(data, []byte("\n$$B\n")) + 5
		// Export data can contain "\n$$\n" in string constants, however,
		// searching for the next end of section marker "\n$$\n" is good enough for tests.
		j := bytes.Index(data[i:], []byte("\n$$\n")) + i
		if i < 0 || j < 0 || i > j {
			t.Fatalf("export data section not found (i = %d, j = %d)", i, j)
		}
		// 3) corrupt the data (increment every 7th byte)
		for k := j - 13; k >= i; k -= 7 {
			data[k]++
		}
		// 4) write the file
		pkgpath += "_corrupted"
		filename := filepath.Join(corruptdir, pkgpath) + ".a"
		os.WriteFile(filename, data, 0666)

		// test that importing the corrupted file results in an error
		_, err = Import(fset, make(map[string]*types.Package), pkgpath, corruptdir, nil)
		if err == nil {
			t.Errorf("import corrupted %q succeeded", pkgpath)
		} else if msg := err.Error(); !strings.Contains(msg, "version skew") {
			t.Errorf("import %q error incorrect (%s)", pkgpath, msg)
		}
	}
}

func TestImportStdLib(t *testing.T) {
	if testing.Short() {
		t.Skip("the imports can be expensive, and this test is especially slow when the build cache is empty")
	}
	testenv.MustHaveGoBuild(t)

	// This package only handles gc export data.
	if runtime.Compiler != "gc" {
		t.Skipf("gc-built packages not available (compiler = %s)", runtime.Compiler)
	}

	// Get list of packages in stdlib. Filter out test-only packages with {{if .GoFiles}} check.
	var stderr bytes.Buffer
	cmd := exec.Command("go", "list", "-f", "{{if .GoFiles}}{{.ImportPath}}{{end}}", "std")
	cmd.Stderr = &stderr
	out, err := cmd.Output()
	if err != nil {
		t.Fatalf("failed to run go list to determine stdlib packages: %v\nstderr:\n%v", err, stderr.String())
	}
	pkgs := strings.Fields(string(out))

	var nimports int
	for _, pkg := range pkgs {
		t.Run(pkg, func(t *testing.T) {
			if testPath(t, pkg, filepath.Join(testenv.GOROOT(t), "src", path.Dir(pkg))) != nil {
				nimports++
			}
		})
	}
	const minPkgs = 225 // 'GOOS=plan9 go1.18 list std | wc -l' reports 228; most other platforms have more.
	if len(pkgs) < minPkgs {
		t.Fatalf("too few packages (%d) were imported", nimports)
	}

	t.Logf("tested %d imports", nimports)
}

var importedObjectTests = []struct {
	name string
	want string
}{
	// non-interfaces
	{"crypto.Hash", "type Hash uint"},
	{"go/ast.ObjKind", "type ObjKind int"},
	{"go/types.Qualifier", "type Qualifier func(*Package) string"},
	{"go/types.Comparable", "func Comparable(T Type) bool"},
	{"math.Pi", "const Pi untyped float"},
	{"math.Sin", "func Sin(x float64) float64"},
	{"go/ast.NotNilFilter", "func NotNilFilter(_ string, v reflect.Value) bool"},
	{"internal/exportdata.FindPkg", "func FindPkg(path string, srcDir string) (filename string, id string, err error)"},

	// interfaces
	{"context.Context", "type Context interface{Deadline() (deadline time.Time, ok bool); Done() <-chan struct{}; Err() error; Value(key any) any}"},
	{"crypto.Decrypter", "type Decrypter interface{Decrypt(rand io.Reader, msg []byte, opts DecrypterOpts) (plaintext []byte, err error); Public() PublicKey}"},
	{"encoding.BinaryMarshaler", "type BinaryMarshaler interface{MarshalBinary() (data []byte, err error)}"},
	{"io.Reader", "type Reader interface{Read(p []byte) (n int, err error)}"},
	{"io.ReadWriter", "type ReadWriter interface{Reader; Writer}"},
	{"go/ast.Node", "type Node interface{End() go/token.Pos; Pos() go/token.Pos}"},
	{"go/types.Type", "type Type interface{String() string; Underlying() Type}"},
}

func TestImportedTypes(t *testing.T) {
	testenv.MustHaveGoBuild(t)

	// This package only handles gc export data.
	if runtime.Compiler != "gc" {
		t.Skipf("gc-built packages not available (compiler = %s)", runtime.Compiler)
	}

	fset := token.NewFileSet()
	for _, test := range importedObjectTests {
		s := strings.Split(test.name, ".")
		if len(s) != 2 {
			t.Fatal("inconsistent test data")
		}
		importPath := s[0]
		objName := s[1]

		pkg, err := Import(fset, make(map[string]*types.Package), importPath, ".", nil)
		if err != nil {
			t.Error(err)
			continue
		}

		obj := pkg.Scope().Lookup(objName)
		if obj == nil {
			t.Errorf("%s: object not found", test.name)
			continue
		}

		got := types.ObjectString(obj, types.RelativeTo(pkg))
		if got != test.want {
			t.Errorf("%s: got %q; want %q", test.name, got, test.want)
		}

		if named, _ := obj.Type().(*types.Named); named != nil {
			verifyInterfaceMethodRecvs(t, named, 0)
		}
	}
}

// verifyInterfaceMethodRecvs verifies that method receiver types
// are named if the methods belong to a named interface type.
func verifyInterfaceMethodRecvs(t *testing.T, named *types.Named, level int) {
	// avoid endless recursion in case of an embedding bug that lead to a cycle
	if level > 10 {
		t.Errorf("%s: embeds itself", named)
		return
	}

	iface, _ := named.Underlying().(*types.Interface)
	if iface == nil {
		return // not an interface
	}

	// check explicitly declared methods
	for i := 0; i < iface.NumExplicitMethods(); i++ {
		m := iface.ExplicitMethod(i)
		recv := m.Type().(*types.Signature).Recv()
		if recv == nil {
			t.Errorf("%s: missing receiver type", m)
			continue
		}
		if recv.Type() != named {
			t.Errorf("%s: got recv type %s; want %s", m, recv.Type(), named)
		}
	}

	// check embedded interfaces (if they are named, too)
	for i := 0; i < iface.NumEmbeddeds(); i++ {
		// embedding of interfaces cannot have cycles; recursion will terminate
		if etype, _ := iface.EmbeddedType(i).(*types.Named); etype != nil {
			verifyInterfaceMethodRecvs(t, etype, level+1)
		}
	}
}

func TestIssue5815(t *testing.T) {
	testenv.MustHaveGoBuild(t)

	// This package only handles gc export data.
	if runtime.Compiler != "gc" {
		t.Skipf("gc-built packages not available (compiler = %s)", runtime.Compiler)
	}

	pkg := importPkg(t, "strings", ".")

	scope := pkg.Scope()
	for _, name := range scope.Names() {
		obj := scope.Lookup(name)
		if obj.Pkg() == nil {
			t.Errorf("no pkg for %s", obj)
		}
		if tname, _ := obj.(*types.TypeName); tname != nil {
			named := tname.Type().(*types.Named)
			for i := 0; i < named.NumMethods(); i++ {
				m := named.Method(i)
				if m.Pkg() == nil {
					t.Errorf("no pkg for %s", m)
				}
			}
		}
	}
}

// Smoke test to ensure that imported methods get the correct package.
func TestCorrectMethodPackage(t *testing.T) {
	testenv.MustHaveGoBuild(t)

	// This package only handles gc export data.
	if runtime.Compiler != "gc" {
		t.Skipf("gc-built packages not available (compiler = %s)", runtime.Compiler)
	}

	imports := make(map[string]*types.Package)
	fset := token.NewFileSet()
	_, err := Import(fset, imports, "net/http", ".", nil)
	if err != nil {
		t.Fatal(err)
	}

	mutex := imports["sync"].Scope().Lookup("Mutex").(*types.TypeName).Type()
	mset := types.NewMethodSet(types.NewPointer(mutex)) // methods of *sync.Mutex
	sel := mset.Lookup(nil, "Lock")
	lock := sel.Obj().(*types.Func)
	if got, want := lock.Pkg().Path(), "sync"; got != want {
		t.Errorf("got package path %q; want %q", got, want)
	}
}

func TestIssue13566(t *testing.T) {
	testenv.MustHaveGoBuild(t)

	// This package only handles gc export data.
	if runtime.Compiler != "gc" {
		t.Skipf("gc-built packages not available (compiler = %s)", runtime.Compiler)
	}

	tmpdir := mktmpdir(t)
	defer os.RemoveAll(tmpdir)
	testoutdir := filepath.Join(tmpdir, "testdata")

	// b.go needs to be compiled from the output directory so that the compiler can
	// find the compiled package a. We pass the full path to compile() so that we
	// don't have to copy the file to that directory.
	bpath, err := filepath.Abs(filepath.Join("testdata", "b.go"))
	if err != nil {
		t.Fatal(err)
	}

	compile(t, "testdata", "a.go", testoutdir, nil, "encoding/json")
	compile(t, testoutdir, bpath, testoutdir, map[string]string{"testdata/a": filepath.Join(testoutdir, "a.o")}, "encoding/json")

	// import must succeed (test for issue at hand)
	pkg := importPkg(t, "./testdata/b", tmpdir)

	// make sure all indirectly imported packages have names
	for _, imp := range pkg.Imports() {
		if imp.Name() == "" {
			t.Errorf("no name for %s package", imp.Path())
		}
	}
}

func TestTypeNamingOrder(t *testing.T) {
	testenv.MustHaveGoBuild(t)

	// This package only handles gc export data.
	if runtime.Compiler != "gc" {
		t.Skipf("gc-built packages not available (compiler = %s)", runtime.Compiler)
	}

	tmpdir := mktmpdir(t)
	defer os.RemoveAll(tmpdir)
	testoutdir := filepath.Join(tmpdir, "testdata")

	compile(t, "testdata", "g.go", testoutdir, nil)

	// import must succeed (test for issue at hand)
	_ = importPkg(t, "./testdata/g", tmpdir)
}

func TestIssue13898(t *testing.T) {
	testenv.MustHaveGoBuild(t)

	// This package only handles gc export data.
	if runtime.Compiler != "gc" {
		t.Skipf("gc-built packages not available (compiler = %s)", runtime.Compiler)
	}

	// import go/internal/gcimporter which imports go/types partially
	fset := token.NewFileSet()
	imports := make(map[string]*types.Package)
	_, err := Import(fset, imports, "go/internal/gcimporter", ".", nil)
	if err != nil {
		t.Fatal(err)
	}

	// look for go/types package
	var goTypesPkg *types.Package
	for path, pkg := range imports {
		if path == "go/types" {
			goTypesPkg = pkg
			break
		}
	}
	if goTypesPkg == nil {
		t.Fatal("go/types not found")
	}

	// look for go/types.Object type
	obj := lookupObj(t, goTypesPkg.Scope(), "Object")
	typ, ok := obj.Type().(*types.Named)
	if !ok {
		t.Fatalf("go/types.Object type is %v; wanted named type", typ)
	}

	// lookup go/types.Object.Pkg method
	m, index, indirect := types.LookupFieldOrMethod(typ, false, nil, "Pkg")
	if m == nil {
		t.Fatalf("go/types.Object.Pkg not found (index = %v, indirect = %v)", index, indirect)
	}

	// the method must belong to go/types
	if m.Pkg().Path() != "go/types" {
		t.Fatalf("found %v; want go/types", m.Pkg())
	}
}

func TestIssue15517(t *testing.T) {
	testenv.MustHaveGoBuild(t)

	// This package only handles gc export data.
	if runtime.Compiler != "gc" {
		t.Skipf("gc-built packages not available (compiler = %s)", runtime.Compiler)
	}

	tmpdir := mktmpdir(t)
	defer os.RemoveAll(tmpdir)

	compile(t, "testdata", "p.go", filepath.Join(tmpdir, "testdata"), nil)

	// Multiple imports of p must succeed without redeclaration errors.
	// We use an import path that's not cleaned up so that the eventual
	// file path for the package is different from the package path; this
	// will expose the error if it is present.
	//
	// (Issue: Both the textual and the binary importer used the file path
	// of the package to be imported as key into the shared packages map.
	// However, the binary importer then used the package path to identify
	// the imported package to mark it as complete; effectively marking the
	// wrong package as complete. By using an "unclean" package path, the
	// file and package path are different, exposing the problem if present.
	// The same issue occurs with vendoring.)
	imports := make(map[string]*types.Package)
	fset := token.NewFileSet()
	for i := 0; i < 3; i++ {
		if _, err := Import(fset, imports, "./././testdata/p", tmpdir, nil); err != nil {
			t.Fatal(err)
		}
	}
}

func TestIssue15920(t *testing.T) {
	testenv.MustHaveGoBuild(t)

	// This package only handles gc export data.
	if runtime.Compiler != "gc" {
		t.Skipf("gc-built packages not available (compiler = %s)", runtime.Compiler)
	}

	compileAndImportPkg(t, "issue15920")
}

func TestIssue20046(t *testing.T) {
	testenv.MustHaveGoBuild(t)

	// This package only handles gc export data.
	if runtime.Compiler != "gc" {
		t.Skipf("gc-built packages not available (compiler = %s)", runtime.Compiler)
	}

	// "./issue20046".V.M must exist
	pkg := compileAndImportPkg(t, "issue20046")
	obj := lookupObj(t, pkg.Scope(), "V")
	if m, index, indirect := types.LookupFieldOrMethod(obj.Type(), false, nil, "M"); m == nil {
		t.Fatalf("V.M not found (index = %v, indirect = %v)", index, indirect)
	}
}
func TestIssue25301(t *testing.T) {
	testenv.MustHaveGoBuild(t)

	// This package only handles gc export data.
	if runtime.Compiler != "gc" {
		t.Skipf("gc-built packages not available (compiler = %s)", runtime.Compiler)
	}

	compileAndImportPkg(t, "issue25301")
}

func TestIssue25596(t *testing.T) {
	testenv.MustHaveGoBuild(t)

	// This package only handles gc export data.
	if runtime.Compiler != "gc" {
		t.Skipf("gc-built packages not available (compiler = %s)", runtime.Compiler)
	}

	compileAndImportPkg(t, "issue25596")
}

func TestIssue57015(t *testing.T) {
	testenv.MustHaveGoBuild(t)

	// This package only handles gc export data.
	if runtime.Compiler != "gc" {
		t.Skipf("gc-built packages not available (compiler = %s)", runtime.Compiler)
	}

	compileAndImportPkg(t, "issue57015")
}

func importPkg(t *testing.T, path, srcDir string) *types.Package {
	fset := token.NewFileSet()
	pkg, err := Import(fset, make(map[string]*types.Package), path, srcDir, nil)
	if err != nil {
		t.Helper()
		t.Fatal(err)
	}
	return pkg
}

func compileAndImportPkg(t *testing.T, name string) *types.Package {
	t.Helper()
	tmpdir := mktmpdir(t)
	defer os.RemoveAll(tmpdir)
	compile(t, "testdata", name+".go", filepath.Join(tmpdir, "testdata"), nil)
	return importPkg(t, "./testdata/"+name, tmpdir)
}

func lookupObj(t *testing.T, scope *types.Scope, name string) types.Object {
	if obj := scope.Lookup(name); obj != nil {
		return obj
	}
	t.Helper()
	t.Fatalf("%s not found", name)
	return nil
}

// importMap implements the types.Importer interface.
type importMap map[string]*types.Package

func (m importMap) Import(path string) (*types.Package, error) { return m[path], nil }

func TestIssue69912(t *testing.T) {
	testenv.MustHaveGoBuild(t)

	// This package only handles gc export data.
	if runtime.Compiler != "gc" {
		t.Skipf("gc-built packages not available (compiler = %s)", runtime.Compiler)
	}

	tmpdir := t.TempDir()
	testoutdir := filepath.Join(tmpdir, "testdata")
	if err := os.Mkdir(testoutdir, 0700); err != nil {
		t.Fatalf("making output dir: %v", err)
	}

	compile(t, "testdata", "issue69912.go", testoutdir, nil)

	fset := token.NewFileSet()

	issue69912, err := Import(fset, make(map[string]*types.Package), "./testdata/issue69912", tmpdir, nil)
	if err != nil {
		t.Fatal(err)
	}

	check := func(pkgname, src string, imports importMap) (*types.Package, error) {
		f, err := parser.ParseFile(fset, "a.go", src, 0)
		if err != nil {
			return nil, err
		}
		config := &types.Config{
			Importer: imports,
		}
		return config.Check(pkgname, fset, []*ast.File{f}, nil)
	}

	// Use the resulting package concurrently, via dot-imports, to exercise the
	// race of issue #69912.
	const pSrc = `package p

import . "issue69912"

type S struct {
	f T
}
`
	importer := importMap{
		"issue69912": issue69912,
	}
	var wg sync.WaitGroup
	for range 10 {
		wg.Add(1)
		go func() {
			defer wg.Done()
			if _, err := check("p", pSrc, importer); err != nil {
				t.Errorf("Check failed: %v", err)
			}
		}()
	}
	wg.Wait()
}
```
Response:
The user provided the second part of a Go test file for the DES and Triple DES encryption algorithms. I need to analyze this part, summarize its functions, and relate it to the overall purpose of the test file.

**Breakdown of the provided code:**

1. **Data Structures:** Defines several `CryptTest` slices containing test vectors for different aspects of DES and Triple DES. These test vectors include keys, plaintexts, and expected ciphertexts.
2. **Helper Function:**  `newCipher(key []byte)` creates a new DES cipher block.
3. **Test Functions:** A series of test functions using the `testing` package. These functions test different properties of DES and Triple DES, including:
    *   Weak keys
    *   Semi-weak key pairs
    *   Block encryption and decryption for DES and Triple DES
    *   Known answer tests (KATs) based on NIST Special Publication 800-20 for various operations (variable plaintext, variable ciphertext, inverse permutation, initial permutation, variable key, permutation operation, substitution table).
4. **Block Interface Test:**  Uses the `cryptotest` package to verify that the DES and Triple DES implementations satisfy the general `cipher.Block` interface.
5. **Benchmark Functions:**  Functions to measure the performance of encryption and decryption for both DES and Triple DES.

**High-Level Goal:** The overall goal of `des_test.go` is to rigorously test the correctness and performance of the Go implementation of the DES and Triple DES encryption algorithms.

**Function of this specific part:**  This second part of the test file focuses on:

*   **Comprehensive Correctness Testing:** By incorporating a large set of test vectors from NIST standards, it ensures the implementation behaves as expected for a wide range of inputs and key scenarios.
*   **Testing Specific DES Properties:** It targets particular characteristics like weak and semi-weak keys.
*   **Interface Conformance:** It verifies the DES implementations adhere to Go's cryptographic interface standards.
*   **Performance Evaluation:** The benchmark tests provide insights into the speed of the encryption and decryption operations.这是 `go/src/crypto/des/des_test.go` 文件的第二部分，它主要的功能是**对 DES 和 Triple DES 加密算法的各种功能进行详细的测试**。

**归纳一下这部分的功能：**

1. **定义了更多的测试用例数据结构 (`CryptTest`):**
    *   `tableA3Tests`: 用于测试 **置换操作** 的已知答案测试用例。
    *   `tableA4Tests`: 用于测试 **替换表 (S-Box)** 的已知答案测试用例。
    这些测试用例包含了预定义的密钥、输入数据和期望的输出数据，用于验证 DES 算法内部特定步骤的正确性。

2. **定义了一个辅助函数 `newCipher(key []byte) cipher.Block`:**
    *   这个函数用于创建一个新的 DES cipher.Block 接口的实例。它简化了在多个测试函数中创建 DES cipher 的过程，并处理了可能出现的错误。

3. **实现了一系列针对 DES 和 Triple DES 的测试函数:**
    *   `TestWeakKeys`:  测试使用已知的弱密钥进行加密时，连续加密两次是否能还原原始输入。这是 DES 算法弱密钥的一个特性。
    *   `TestSemiWeakKeyPairs`: 测试使用已知的半弱密钥对进行加密时，先用一个密钥加密，再用另一个密钥加密，是否能还原原始输入。
    *   `TestDESEncryptBlock`:  使用 `encryptDESTests` 中定义的用例测试 DES 算法的块加密功能。
    *   `TestDESDecryptBlock`:  使用 `encryptDESTests` 中定义的用例测试 DES 算法的块解密功能。
    *   `TestEncryptTripleDES`: 使用 `encryptTripleDESTests` 中定义的用例测试 Triple DES 算法的加密功能。
    *   `TestDecryptTripleDES`: 使用 `encryptTripleDESTests` 中定义的用例测试 Triple DES 算法的解密功能。
    *   `TestVariablePlaintextKnownAnswer`: 使用 NIST SP 800-20 标准中 Table A.1 的用例，测试 Triple DES 在不同明文下的加密结果。
    *   `TestVariableCiphertextKnownAnswer`: 使用 NIST SP 800-20 标准中 Table A.1 的用例，测试 Triple DES 在不同密文下的解密结果。
    *   `TestInversePermutationKnownAnswer`: 使用 NIST SP 800-20 标准中 Table A.1 的用例，测试 Triple DES 的逆置换操作。
    *   `TestInitialPermutationKnownAnswer`: 使用 NIST SP 800-20 标准中 Table A.1 的用例，测试 Triple DES 的初始置换操作。
    *   `TestVariableKeyKnownAnswerEncrypt`: 使用 NIST SP 800-20 标准中 Table A.2 的用例，测试 Triple DES 在不同密钥下的加密结果。
    *   `TestVariableKeyKnownAnswerDecrypt`: 使用 NIST SP 800-20 标准中 Table A.2 的用例，测试 Triple DES 在不同密钥下的解密结果。
    *   `TestPermutationOperationKnownAnswerEncrypt`: 使用 NIST SP 800-20 标准中 Table A.3 的用例，测试 Triple DES 的置换操作加密结果。
    *   `TestPermutationOperationKnownAnswerDecrypt`: 使用 NIST SP 800-20 标准中 Table A.3 的用例，测试 Triple DES 的置换操作解密结果。
    *   `TestSubstitutionTableKnownAnswerEncrypt`: 使用 NIST SP 800-20 标准中 Table A.4 的用例，测试 Triple DES 的替换表操作加密结果。
    *   `TestSubstitutionTableKnownAnswerDecrypt`: 使用 NIST SP 800-20 标准中 Table A.4 的用例，测试 Triple DES 的替换表操作解密结果。

4. **测试 DES 和 Triple DES 是否实现了 `cipher.Block` 接口:**
    *   `TestDESBlock`: 使用 `cryptotest` 包中的 `TestBlock` 函数，确保 DES 和 Triple DES 的实现符合 Go 标准库中 `cipher.Block` 接口的要求。这包括检查块大小、加密和解密操作的正确性等。

5. **实现了性能基准测试函数:**
    *   `BenchmarkEncrypt`: 测量 DES 算法的加密性能。
    *   `BenchmarkDecrypt`: 测量 DES 算法的解密性能。
    *   `BenchmarkTDESEncrypt`: 测量 Triple DES 算法的加密性能。
    *   `BenchmarkTDESDecrypt`: 测量 Triple DES 算法的解密性能。
    这些基准测试用于评估算法的运行效率。

**代码示例 (针对 `TestWeakKeys`)：**

假设我们有一个弱密钥 `key` 和一段输入 `input`。

```go
package des_test

import (
	"bytes"
	"crypto/cipher"
	"crypto/des"
	"testing"
)

func TestWeakKeysExample(t *testing.T) {
	// 假设的弱密钥和输入
	key := []byte{0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01} // 一个已知的 DES 弱密钥
	input := []byte{0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF}

	// 创建 DES cipher
	c, err := des.NewCipher(key)
	if err != nil {
		t.Fatalf("创建 cipher 失败: %v", err)
	}

	// 加密两次
	encrypted1 := make([]byte, len(input))
	c.Encrypt(encrypted1, input)

	encrypted2 := make([]byte, len(input))
	c.Encrypt(encrypted2, encrypted1)

	// 弱密钥的特性是加密两次后应该还原到原始输入
	if !bytes.Equal(encrypted2, input) {
		t.Errorf("使用弱密钥加密两次后未还原原始输入，结果: %x, 期望: %x", encrypted2, input)
	} else {
		t.Logf("使用弱密钥加密两次后成功还原原始输入")
	}
}
```

**假设的输入与输出 (针对 `TestDESEncryptBlock`)：**

假设 `encryptDESTests` 中的一个测试用例是：

```go
{
	key: []byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07},
	in:  []byte{0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f},
	out: []byte{0xfa, 0x34, 0x02, 0x0a, 0x19, 0x0d, 0x34, 0xef},
}
```

那么 `TestDESEncryptBlock` 函数会使用这个密钥加密 `in`，并断言输出是否等于 `out`。

**命令行参数处理：**

这段代码本身并不直接处理命令行参数。Go 的测试框架 `testing` 提供了一些常用的命令行标志，例如：

*   `-test.run <regexp>`:  运行匹配正则表达式的测试函数。
*   `-test.bench <regexp>`: 运行匹配正则表达式的性能测试函数。
*   `-test.v`:  显示更详细的测试输出。

例如，要运行所有的 DES 加密相关的测试，可以在命令行中执行：

```bash
go test -test.run "TestDESEncrypt"
```

要运行所有的性能测试：

```bash
go test -test.bench "."
```

**使用者易犯错的点：**

由于这段代码是测试代码，使用者直接与之交互的可能性很小。但是，如果开发者在扩展或修改这部分测试代码时，可能会犯以下错误：

*   **测试向量错误:**  在 `CryptTest` 结构中，如果提供的 `key`、`in` 或 `out` 数据不正确，会导致测试失败，但可能难以定位问题所在。仔细核对 NIST 标准文档是必要的。
*   **对弱密钥或半弱密钥的理解偏差:**  如果没有理解弱密钥和半弱密钥的特性，可能会编写出不正确的测试用例，或者误判测试结果。
*   **忽略错误处理:** 在创建 cipher 对象时，虽然 `newCipher` 函数会 panic，但在其他地方如果直接使用可能返回 error 的函数而没有检查错误，可能会导致测试运行不稳定或产生误导性结果。

总而言之，这部分代码通过大量的测试用例，覆盖了 DES 和 Triple DES 算法的各种场景，确保 Go 语言实现的 `crypto/des` 包的正确性和性能符合预期。它使用了 Go 语言的 testing 框架，并参考了权威的密码学标准 (NIST SP 800-20) 来构建测试用例。

### 提示词
```
这是路径为go/src/crypto/des/des_test.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
请用中文回答。
这是第2部分，共2部分，请归纳一下它的功能
```

### 源代码
```go
il,
		[]byte{0x86, 0x9e, 0xfd, 0x7f, 0x9f, 0x26, 0x5a, 0x09}},
}

// Plaintext for use with Table A.3 tests
var tableA3Plaintext = []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}

// Table A.3 Values To Be Used for the Permutation Operation Known Answer Test
var tableA3Tests = []CryptTest{
	{ // 0
		[]byte{
			0x10, 0x46, 0x91, 0x34, 0x89, 0x98, 0x01, 0x31,
			0x10, 0x46, 0x91, 0x34, 0x89, 0x98, 0x01, 0x31,
			0x10, 0x46, 0x91, 0x34, 0x89, 0x98, 0x01, 0x31,
		},
		nil,
		[]byte{0x88, 0xd5, 0x5e, 0x54, 0xf5, 0x4c, 0x97, 0xb4}},
	{ // 1
		[]byte{
			0x10, 0x07, 0x10, 0x34, 0x89, 0x98, 0x80, 0x20,
			0x10, 0x07, 0x10, 0x34, 0x89, 0x98, 0x80, 0x20,
			0x10, 0x07, 0x10, 0x34, 0x89, 0x98, 0x80, 0x20,
		},
		nil,
		[]byte{0x0c, 0x0c, 0xc0, 0x0c, 0x83, 0xea, 0x48, 0xfd}},
	{ // 2
		[]byte{
			0x10, 0x07, 0x10, 0x34, 0xc8, 0x98, 0x01, 0x20,
			0x10, 0x07, 0x10, 0x34, 0xc8, 0x98, 0x01, 0x20,
			0x10, 0x07, 0x10, 0x34, 0xc8, 0x98, 0x01, 0x20,
		},
		nil,
		[]byte{0x83, 0xbc, 0x8e, 0xf3, 0xa6, 0x57, 0x01, 0x83}},
	{ // 3
		[]byte{
			0x10, 0x46, 0x10, 0x34, 0x89, 0x98, 0x80, 0x20,
			0x10, 0x46, 0x10, 0x34, 0x89, 0x98, 0x80, 0x20,
			0x10, 0x46, 0x10, 0x34, 0x89, 0x98, 0x80, 0x20,
		},
		nil,
		[]byte{0xdf, 0x72, 0x5d, 0xca, 0xd9, 0x4e, 0xa2, 0xe9}},
	{ // 4
		[]byte{
			0x10, 0x86, 0x91, 0x15, 0x19, 0x19, 0x01, 0x01,
			0x10, 0x86, 0x91, 0x15, 0x19, 0x19, 0x01, 0x01,
			0x10, 0x86, 0x91, 0x15, 0x19, 0x19, 0x01, 0x01,
		},
		nil,
		[]byte{0xe6, 0x52, 0xb5, 0x3b, 0x55, 0x0b, 0xe8, 0xb0}},
	{ // 5
		[]byte{
			0x10, 0x86, 0x91, 0x15, 0x19, 0x58, 0x01, 0x01,
			0x10, 0x86, 0x91, 0x15, 0x19, 0x58, 0x01, 0x01,
			0x10, 0x86, 0x91, 0x15, 0x19, 0x58, 0x01, 0x01,
		},
		nil,
		[]byte{0xaf, 0x52, 0x71, 0x20, 0xc4, 0x85, 0xcb, 0xb0}},
	{ // 6
		[]byte{
			0x51, 0x07, 0xb0, 0x15, 0x19, 0x58, 0x01, 0x01,
			0x51, 0x07, 0xb0, 0x15, 0x19, 0x58, 0x01, 0x01,
			0x51, 0x07, 0xb0, 0x15, 0x19, 0x58, 0x01, 0x01,
		},
		nil,
		[]byte{0x0f, 0x04, 0xce, 0x39, 0x3d, 0xb9, 0x26, 0xd5}},
	{ // 7
		[]byte{
			0x10, 0x07, 0xb0, 0x15, 0x19, 0x19, 0x01, 0x01,
			0x10, 0x07, 0xb0, 0x15, 0x19, 0x19, 0x01, 0x01,
			0x10, 0x07, 0xb0, 0x15, 0x19, 0x19, 0x01, 0x01,
		},
		nil,
		[]byte{0xc9, 0xf0, 0x0f, 0xfc, 0x74, 0x07, 0x90, 0x67}},
	{ // 8
		[]byte{
			0x31, 0x07, 0x91, 0x54, 0x98, 0x08, 0x01, 0x01,
			0x31, 0x07, 0x91, 0x54, 0x98, 0x08, 0x01, 0x01,
			0x31, 0x07, 0x91, 0x54, 0x98, 0x08, 0x01, 0x01,
		},
		nil,
		[]byte{0x7c, 0xfd, 0x82, 0xa5, 0x93, 0x25, 0x2b, 0x4e}},
	{ // 9
		[]byte{
			0x31, 0x07, 0x91, 0x94, 0x98, 0x08, 0x01, 0x01,
			0x31, 0x07, 0x91, 0x94, 0x98, 0x08, 0x01, 0x01,
			0x31, 0x07, 0x91, 0x94, 0x98, 0x08, 0x01, 0x01,
		},
		nil,
		[]byte{0xcb, 0x49, 0xa2, 0xf9, 0xe9, 0x13, 0x63, 0xe3}},
	{ // 10
		[]byte{
			0x10, 0x07, 0x91, 0x15, 0xb9, 0x08, 0x01, 0x40,
			0x10, 0x07, 0x91, 0x15, 0xb9, 0x08, 0x01, 0x40,
			0x10, 0x07, 0x91, 0x15, 0xb9, 0x08, 0x01, 0x40,
		},
		nil,
		[]byte{0x00, 0xb5, 0x88, 0xbe, 0x70, 0xd2, 0x3f, 0x56}},
	{ // 11
		[]byte{
			0x31, 0x07, 0x91, 0x15, 0x98, 0x08, 0x01, 0x40,
			0x31, 0x07, 0x91, 0x15, 0x98, 0x08, 0x01, 0x40,
			0x31, 0x07, 0x91, 0x15, 0x98, 0x08, 0x01, 0x40,
		},
		nil,
		[]byte{0x40, 0x6a, 0x9a, 0x6a, 0xb4, 0x33, 0x99, 0xae}},
	{ // 12
		[]byte{
			0x10, 0x07, 0xd0, 0x15, 0x89, 0x98, 0x01, 0x01,
			0x10, 0x07, 0xd0, 0x15, 0x89, 0x98, 0x01, 0x01,
			0x10, 0x07, 0xd0, 0x15, 0x89, 0x98, 0x01, 0x01,
		},
		nil,
		[]byte{0x6c, 0xb7, 0x73, 0x61, 0x1d, 0xca, 0x9a, 0xda}},
	{ // 13
		[]byte{
			0x91, 0x07, 0x91, 0x15, 0x89, 0x98, 0x01, 0x01,
			0x91, 0x07, 0x91, 0x15, 0x89, 0x98, 0x01, 0x01,
			0x91, 0x07, 0x91, 0x15, 0x89, 0x98, 0x01, 0x01,
		},
		nil,
		[]byte{0x67, 0xfd, 0x21, 0xc1, 0x7d, 0xbb, 0x5d, 0x70}},
	{ // 14
		[]byte{
			0x91, 0x07, 0xd0, 0x15, 0x89, 0x19, 0x01, 0x01,
			0x91, 0x07, 0xd0, 0x15, 0x89, 0x19, 0x01, 0x01,
			0x91, 0x07, 0xd0, 0x15, 0x89, 0x19, 0x01, 0x01,
		},
		nil,
		[]byte{0x95, 0x92, 0xcb, 0x41, 0x10, 0x43, 0x07, 0x87}},
	{ // 15
		[]byte{
			0x10, 0x07, 0xd0, 0x15, 0x98, 0x98, 0x01, 0x20,
			0x10, 0x07, 0xd0, 0x15, 0x98, 0x98, 0x01, 0x20,
			0x10, 0x07, 0xd0, 0x15, 0x98, 0x98, 0x01, 0x20,
		},
		nil,
		[]byte{0xa6, 0xb7, 0xff, 0x68, 0xa3, 0x18, 0xdd, 0xd3}},
	{ // 16
		[]byte{
			0x10, 0x07, 0x94, 0x04, 0x98, 0x19, 0x01, 0x01,
			0x10, 0x07, 0x94, 0x04, 0x98, 0x19, 0x01, 0x01,
			0x10, 0x07, 0x94, 0x04, 0x98, 0x19, 0x01, 0x01,
		},
		nil,
		[]byte{0x4d, 0x10, 0x21, 0x96, 0xc9, 0x14, 0xca, 0x16}},
	{ // 17
		[]byte{
			0x01, 0x07, 0x91, 0x04, 0x91, 0x19, 0x04, 0x01,
			0x01, 0x07, 0x91, 0x04, 0x91, 0x19, 0x04, 0x01,
			0x01, 0x07, 0x91, 0x04, 0x91, 0x19, 0x04, 0x01,
		},
		nil,
		[]byte{0x2d, 0xfa, 0x9f, 0x45, 0x73, 0x59, 0x49, 0x65}},
	{ // 18
		[]byte{
			0x01, 0x07, 0x91, 0x04, 0x91, 0x19, 0x01, 0x01,
			0x01, 0x07, 0x91, 0x04, 0x91, 0x19, 0x01, 0x01,
			0x01, 0x07, 0x91, 0x04, 0x91, 0x19, 0x01, 0x01,
		},
		nil,
		[]byte{0xb4, 0x66, 0x04, 0x81, 0x6c, 0x0e, 0x07, 0x74}},
	{ // 19
		[]byte{
			0x01, 0x07, 0x94, 0x04, 0x91, 0x19, 0x04, 0x01,
			0x01, 0x07, 0x94, 0x04, 0x91, 0x19, 0x04, 0x01,
			0x01, 0x07, 0x94, 0x04, 0x91, 0x19, 0x04, 0x01,
		},
		nil,
		[]byte{0x6e, 0x7e, 0x62, 0x21, 0xa4, 0xf3, 0x4e, 0x87}},
	{ // 20
		[]byte{
			0x19, 0x07, 0x92, 0x10, 0x98, 0x1a, 0x01, 0x01,
			0x19, 0x07, 0x92, 0x10, 0x98, 0x1a, 0x01, 0x01,
			0x19, 0x07, 0x92, 0x10, 0x98, 0x1a, 0x01, 0x01,
		},
		nil,
		[]byte{0xaa, 0x85, 0xe7, 0x46, 0x43, 0x23, 0x31, 0x99}},
	{ // 21
		[]byte{
			0x10, 0x07, 0x91, 0x19, 0x98, 0x19, 0x08, 0x01,
			0x10, 0x07, 0x91, 0x19, 0x98, 0x19, 0x08, 0x01,
			0x10, 0x07, 0x91, 0x19, 0x98, 0x19, 0x08, 0x01,
		},
		nil,
		[]byte{0x2e, 0x5a, 0x19, 0xdb, 0x4d, 0x19, 0x62, 0xd6}},
	{ // 22
		[]byte{
			0x10, 0x07, 0x91, 0x19, 0x98, 0x1a, 0x08, 0x01,
			0x10, 0x07, 0x91, 0x19, 0x98, 0x1a, 0x08, 0x01,
			0x10, 0x07, 0x91, 0x19, 0x98, 0x1a, 0x08, 0x01,
		},
		nil,
		[]byte{0x23, 0xa8, 0x66, 0xa8, 0x09, 0xd3, 0x08, 0x94}},
	{ // 23
		[]byte{
			0x10, 0x07, 0x92, 0x10, 0x98, 0x19, 0x01, 0x01,
			0x10, 0x07, 0x92, 0x10, 0x98, 0x19, 0x01, 0x01,
			0x10, 0x07, 0x92, 0x10, 0x98, 0x19, 0x01, 0x01,
		},
		nil,
		[]byte{0xd8, 0x12, 0xd9, 0x61, 0xf0, 0x17, 0xd3, 0x20}},
	{ // 24
		[]byte{
			0x10, 0x07, 0x91, 0x15, 0x98, 0x19, 0x01, 0x0b,
			0x10, 0x07, 0x91, 0x15, 0x98, 0x19, 0x01, 0x0b,
			0x10, 0x07, 0x91, 0x15, 0x98, 0x19, 0x01, 0x0b,
		},
		nil,
		[]byte{0x05, 0x56, 0x05, 0x81, 0x6e, 0x58, 0x60, 0x8f}},
	{ // 25
		[]byte{
			0x10, 0x04, 0x80, 0x15, 0x98, 0x19, 0x01, 0x01,
			0x10, 0x04, 0x80, 0x15, 0x98, 0x19, 0x01, 0x01,
			0x10, 0x04, 0x80, 0x15, 0x98, 0x19, 0x01, 0x01,
		},
		nil,
		[]byte{0xab, 0xd8, 0x8e, 0x8b, 0x1b, 0x77, 0x16, 0xf1}},
	{ // 26
		[]byte{
			0x10, 0x04, 0x80, 0x15, 0x98, 0x19, 0x01, 0x02,
			0x10, 0x04, 0x80, 0x15, 0x98, 0x19, 0x01, 0x02,
			0x10, 0x04, 0x80, 0x15, 0x98, 0x19, 0x01, 0x02,
		},
		nil,
		[]byte{0x53, 0x7a, 0xc9, 0x5b, 0xe6, 0x9d, 0xa1, 0xe1}},
	{ // 27
		[]byte{
			0x10, 0x04, 0x80, 0x15, 0x98, 0x19, 0x01, 0x08,
			0x10, 0x04, 0x80, 0x15, 0x98, 0x19, 0x01, 0x08,
			0x10, 0x04, 0x80, 0x15, 0x98, 0x19, 0x01, 0x08,
		},
		nil,
		[]byte{0xae, 0xd0, 0xf6, 0xae, 0x3c, 0x25, 0xcd, 0xd8}},
	{ // 28
		[]byte{
			0x10, 0x02, 0x91, 0x15, 0x98, 0x10, 0x01, 0x04,
			0x10, 0x02, 0x91, 0x15, 0x98, 0x10, 0x01, 0x04,
			0x10, 0x02, 0x91, 0x15, 0x98, 0x10, 0x01, 0x04,
		},
		nil,
		[]byte{0xb3, 0xe3, 0x5a, 0x5e, 0xe5, 0x3e, 0x7b, 0x8d}},
	{ // 29
		[]byte{
			0x10, 0x02, 0x91, 0x15, 0x98, 0x19, 0x01, 0x04,
			0x10, 0x02, 0x91, 0x15, 0x98, 0x19, 0x01, 0x04,
			0x10, 0x02, 0x91, 0x15, 0x98, 0x19, 0x01, 0x04,
		},
		nil,
		[]byte{0x61, 0xc7, 0x9c, 0x71, 0x92, 0x1a, 0x2e, 0xf8}},
	{ // 30
		[]byte{
			0x10, 0x02, 0x91, 0x15, 0x98, 0x10, 0x02, 0x01,
			0x10, 0x02, 0x91, 0x15, 0x98, 0x10, 0x02, 0x01,
			0x10, 0x02, 0x91, 0x15, 0x98, 0x10, 0x02, 0x01,
		},
		nil,
		[]byte{0xe2, 0xf5, 0x72, 0x8f, 0x09, 0x95, 0x01, 0x3c}},
	{ // 31
		[]byte{
			0x10, 0x02, 0x91, 0x16, 0x98, 0x10, 0x01, 0x01,
			0x10, 0x02, 0x91, 0x16, 0x98, 0x10, 0x01, 0x01,
			0x10, 0x02, 0x91, 0x16, 0x98, 0x10, 0x01, 0x01,
		},
		nil,
		[]byte{0x1a, 0xea, 0xc3, 0x9a, 0x61, 0xf0, 0xa4, 0x64}},
}

// Table A.4 Values To Be Used for the Substitution Table Known Answer Test
var tableA4Tests = []CryptTest{
	{ // 0
		[]byte{
			0x7c, 0xa1, 0x10, 0x45, 0x4a, 0x1a, 0x6e, 0x57,
			0x7c, 0xa1, 0x10, 0x45, 0x4a, 0x1a, 0x6e, 0x57,
			0x7c, 0xa1, 0x10, 0x45, 0x4a, 0x1a, 0x6e, 0x57},
		[]byte{0x01, 0xa1, 0xd6, 0xd0, 0x39, 0x77, 0x67, 0x42},
		[]byte{0x69, 0x0f, 0x5b, 0x0d, 0x9a, 0x26, 0x93, 0x9b}},
	{ // 1
		[]byte{
			0x01, 0x31, 0xd9, 0x61, 0x9d, 0xc1, 0x37, 0x6e,
			0x01, 0x31, 0xd9, 0x61, 0x9d, 0xc1, 0x37, 0x6e,
			0x01, 0x31, 0xd9, 0x61, 0x9d, 0xc1, 0x37, 0x6e},
		[]byte{0x5c, 0xd5, 0x4c, 0xa8, 0x3d, 0xef, 0x57, 0xda},
		[]byte{0x7a, 0x38, 0x9d, 0x10, 0x35, 0x4b, 0xd2, 0x71}},
	{ // 2
		[]byte{
			0x07, 0xa1, 0x13, 0x3e, 0x4a, 0x0b, 0x26, 0x86,
			0x07, 0xa1, 0x13, 0x3e, 0x4a, 0x0b, 0x26, 0x86,
			0x07, 0xa1, 0x13, 0x3e, 0x4a, 0x0b, 0x26, 0x86},
		[]byte{0x02, 0x48, 0xd4, 0x38, 0x06, 0xf6, 0x71, 0x72},
		[]byte{0x86, 0x8e, 0xbb, 0x51, 0xca, 0xb4, 0x59, 0x9a}},
	{ // 3
		[]byte{
			0x38, 0x49, 0x67, 0x4c, 0x26, 0x02, 0x31, 0x9e,
			0x38, 0x49, 0x67, 0x4c, 0x26, 0x02, 0x31, 0x9e,
			0x38, 0x49, 0x67, 0x4c, 0x26, 0x02, 0x31, 0x9e},
		[]byte{0x51, 0x45, 0x4b, 0x58, 0x2d, 0xdf, 0x44, 0x0a},
		[]byte{0x71, 0x78, 0x87, 0x6e, 0x01, 0xf1, 0x9b, 0x2a}},
	{ // 4
		[]byte{
			0x04, 0xb9, 0x15, 0xba, 0x43, 0xfe, 0xb5, 0xb6,
			0x04, 0xb9, 0x15, 0xba, 0x43, 0xfe, 0xb5, 0xb6,
			0x04, 0xb9, 0x15, 0xba, 0x43, 0xfe, 0xb5, 0xb6},
		[]byte{0x42, 0xfd, 0x44, 0x30, 0x59, 0x57, 0x7f, 0xa2},
		[]byte{0xaf, 0x37, 0xfb, 0x42, 0x1f, 0x8c, 0x40, 0x95}},
	{ // 5
		[]byte{
			0x01, 0x13, 0xb9, 0x70, 0xfd, 0x34, 0xf2, 0xce,
			0x01, 0x13, 0xb9, 0x70, 0xfd, 0x34, 0xf2, 0xce,
			0x01, 0x13, 0xb9, 0x70, 0xfd, 0x34, 0xf2, 0xce},
		[]byte{0x05, 0x9b, 0x5e, 0x08, 0x51, 0xcf, 0x14, 0x3a},
		[]byte{0x86, 0xa5, 0x60, 0xf1, 0x0e, 0xc6, 0xd8, 0x5b}},
	{ // 6
		[]byte{
			0x01, 0x70, 0xf1, 0x75, 0x46, 0x8f, 0xb5, 0xe6,
			0x01, 0x70, 0xf1, 0x75, 0x46, 0x8f, 0xb5, 0xe6,
			0x01, 0x70, 0xf1, 0x75, 0x46, 0x8f, 0xb5, 0xe6},
		[]byte{0x07, 0x56, 0xd8, 0xe0, 0x77, 0x47, 0x61, 0xd2},
		[]byte{0x0c, 0xd3, 0xda, 0x02, 0x00, 0x21, 0xdc, 0x09}},
	{ // 7
		[]byte{
			0x43, 0x29, 0x7f, 0xad, 0x38, 0xe3, 0x73, 0xfe,
			0x43, 0x29, 0x7f, 0xad, 0x38, 0xe3, 0x73, 0xfe,
			0x43, 0x29, 0x7f, 0xad, 0x38, 0xe3, 0x73, 0xfe},
		[]byte{0x76, 0x25, 0x14, 0xb8, 0x29, 0xbf, 0x48, 0x6a},
		[]byte{0xea, 0x67, 0x6b, 0x2c, 0xb7, 0xdb, 0x2b, 0x7a}},
	{ // 8
		[]byte{
			0x07, 0xa7, 0x13, 0x70, 0x45, 0xda, 0x2a, 0x16,
			0x07, 0xa7, 0x13, 0x70, 0x45, 0xda, 0x2a, 0x16,
			0x07, 0xa7, 0x13, 0x70, 0x45, 0xda, 0x2a, 0x16},
		[]byte{0x3b, 0xdd, 0x11, 0x90, 0x49, 0x37, 0x28, 0x02},
		[]byte{0xdf, 0xd6, 0x4a, 0x81, 0x5c, 0xaf, 0x1a, 0x0f}},
	{ // 9
		[]byte{
			0x04, 0x68, 0x91, 0x04, 0xc2, 0xfd, 0x3b, 0x2f,
			0x04, 0x68, 0x91, 0x04, 0xc2, 0xfd, 0x3b, 0x2f,
			0x04, 0x68, 0x91, 0x04, 0xc2, 0xfd, 0x3b, 0x2f},
		[]byte{0x26, 0x95, 0x5f, 0x68, 0x35, 0xaf, 0x60, 0x9a},
		[]byte{0x5c, 0x51, 0x3c, 0x9c, 0x48, 0x86, 0xc0, 0x88}},
	{ // 10
		[]byte{
			0x37, 0xd0, 0x6b, 0xb5, 0x16, 0xcb, 0x75, 0x46,
			0x37, 0xd0, 0x6b, 0xb5, 0x16, 0xcb, 0x75, 0x46,
			0x37, 0xd0, 0x6b, 0xb5, 0x16, 0xcb, 0x75, 0x46},
		[]byte{0x16, 0x4d, 0x5e, 0x40, 0x4f, 0x27, 0x52, 0x32},
		[]byte{0x0a, 0x2a, 0xee, 0xae, 0x3f, 0xf4, 0xab, 0x77}},
	{ // 11
		[]byte{
			0x1f, 0x08, 0x26, 0x0d, 0x1a, 0xc2, 0x46, 0x5e,
			0x1f, 0x08, 0x26, 0x0d, 0x1a, 0xc2, 0x46, 0x5e,
			0x1f, 0x08, 0x26, 0x0d, 0x1a, 0xc2, 0x46, 0x5e},
		[]byte{0x6b, 0x05, 0x6e, 0x18, 0x75, 0x9f, 0x5c, 0xca},
		[]byte{0xef, 0x1b, 0xf0, 0x3e, 0x5d, 0xfa, 0x57, 0x5a}},
	{ // 12
		[]byte{
			0x58, 0x40, 0x23, 0x64, 0x1a, 0xba, 0x61, 0x76,
			0x58, 0x40, 0x23, 0x64, 0x1a, 0xba, 0x61, 0x76,
			0x58, 0x40, 0x23, 0x64, 0x1a, 0xba, 0x61, 0x76},
		[]byte{0x00, 0x4b, 0xd6, 0xef, 0x09, 0x17, 0x60, 0x62},
		[]byte{0x88, 0xbf, 0x0d, 0xb6, 0xd7, 0x0d, 0xee, 0x56}},
	{ // 13
		[]byte{
			0x02, 0x58, 0x16, 0x16, 0x46, 0x29, 0xb0, 0x07,
			0x02, 0x58, 0x16, 0x16, 0x46, 0x29, 0xb0, 0x07,
			0x02, 0x58, 0x16, 0x16, 0x46, 0x29, 0xb0, 0x07},
		[]byte{0x48, 0x0d, 0x39, 0x00, 0x6e, 0xe7, 0x62, 0xf2},
		[]byte{0xa1, 0xf9, 0x91, 0x55, 0x41, 0x02, 0x0b, 0x56}},
	{ // 14
		[]byte{
			0x49, 0x79, 0x3e, 0xbc, 0x79, 0xb3, 0x25, 0x8f,
			0x49, 0x79, 0x3e, 0xbc, 0x79, 0xb3, 0x25, 0x8f,
			0x49, 0x79, 0x3e, 0xbc, 0x79, 0xb3, 0x25, 0x8f},
		[]byte{0x43, 0x75, 0x40, 0xc8, 0x69, 0x8f, 0x3c, 0xfa},
		[]byte{0x6f, 0xbf, 0x1c, 0xaf, 0xcf, 0xfd, 0x05, 0x56}},
	{ // 15
		[]byte{
			0x4f, 0xb0, 0x5e, 0x15, 0x15, 0xab, 0x73, 0xa7,
			0x4f, 0xb0, 0x5e, 0x15, 0x15, 0xab, 0x73, 0xa7,
			0x4f, 0xb0, 0x5e, 0x15, 0x15, 0xab, 0x73, 0xa7},
		[]byte{0x07, 0x2d, 0x43, 0xa0, 0x77, 0x07, 0x52, 0x92},
		[]byte{0x2f, 0x22, 0xe4, 0x9b, 0xab, 0x7c, 0xa1, 0xac}},
	{ // 16
		[]byte{
			0x49, 0xe9, 0x5d, 0x6d, 0x4c, 0xa2, 0x29, 0xbf,
			0x49, 0xe9, 0x5d, 0x6d, 0x4c, 0xa2, 0x29, 0xbf,
			0x49, 0xe9, 0x5d, 0x6d, 0x4c, 0xa2, 0x29, 0xbf},
		[]byte{0x02, 0xfe, 0x55, 0x77, 0x81, 0x17, 0xf1, 0x2a},
		[]byte{0x5a, 0x6b, 0x61, 0x2c, 0xc2, 0x6c, 0xce, 0x4a}},
	{ // 17
		[]byte{
			0x01, 0x83, 0x10, 0xdc, 0x40, 0x9b, 0x26, 0xd6,
			0x01, 0x83, 0x10, 0xdc, 0x40, 0x9b, 0x26, 0xd6,
			0x01, 0x83, 0x10, 0xdc, 0x40, 0x9b, 0x26, 0xd6},
		[]byte{0x1d, 0x9d, 0x5c, 0x50, 0x18, 0xf7, 0x28, 0xc2},
		[]byte{0x5f, 0x4c, 0x03, 0x8e, 0xd1, 0x2b, 0x2e, 0x41}},
	{ // 18
		[]byte{
			0x1c, 0x58, 0x7f, 0x1c, 0x13, 0x92, 0x4f, 0xef,
			0x1c, 0x58, 0x7f, 0x1c, 0x13, 0x92, 0x4f, 0xef,
			0x1c, 0x58, 0x7f, 0x1c, 0x13, 0x92, 0x4f, 0xef},
		[]byte{0x30, 0x55, 0x32, 0x28, 0x6d, 0x6f, 0x29, 0x5a},
		[]byte{0x63, 0xfa, 0xc0, 0xd0, 0x34, 0xd9, 0xf7, 0x93}},
}

func newCipher(key []byte) cipher.Block {
	c, err := des.NewCipher(key)
	if err != nil {
		panic("NewCipher failed: " + err.Error())
	}
	return c
}

// Use the known weak keys to test DES implementation
func TestWeakKeys(t *testing.T) {
	for i, tt := range weakKeyTests {
		var encrypt = func(in []byte) (out []byte) {
			c := newCipher(tt.key)
			out = make([]byte, len(in))
			c.Encrypt(out, in)
			return
		}

		// Encrypting twice with a DES weak
		// key should reproduce the original input
		result := encrypt(tt.in)
		result = encrypt(result)

		if !bytes.Equal(result, tt.in) {
			t.Errorf("#%d: result: %x want: %x", i, result, tt.in)
		}
	}
}

// Use the known semi-weak key pairs to test DES implementation
func TestSemiWeakKeyPairs(t *testing.T) {
	for i, tt := range semiWeakKeyTests {
		var encrypt = func(key, in []byte) (out []byte) {
			c := newCipher(key)
			out = make([]byte, len(in))
			c.Encrypt(out, in)
			return
		}

		// Encrypting with one member of the semi-weak pair
		// and then encrypting the result with the other member
		// should reproduce the original input.
		result := encrypt(tt.key, tt.in)
		result = encrypt(tt.out, result)

		if !bytes.Equal(result, tt.in) {
			t.Errorf("#%d: result: %x want: %x", i, result, tt.in)
		}
	}
}

func TestDESEncryptBlock(t *testing.T) {
	for i, tt := range encryptDESTests {
		c := newCipher(tt.key)
		out := make([]byte, len(tt.in))
		c.Encrypt(out, tt.in)

		if !bytes.Equal(out, tt.out) {
			t.Errorf("#%d: result: %x want: %x", i, out, tt.out)
		}
	}
}

func TestDESDecryptBlock(t *testing.T) {
	for i, tt := range encryptDESTests {
		c := newCipher(tt.key)
		plain := make([]byte, len(tt.in))
		c.Decrypt(plain, tt.out)

		if !bytes.Equal(plain, tt.in) {
			t.Errorf("#%d: result: %x want: %x", i, plain, tt.in)
		}
	}
}

func TestEncryptTripleDES(t *testing.T) {
	for i, tt := range encryptTripleDESTests {
		c, _ := des.NewTripleDESCipher(tt.key)
		out := make([]byte, len(tt.in))
		c.Encrypt(out, tt.in)

		if !bytes.Equal(out, tt.out) {
			t.Errorf("#%d: result: %x want: %x", i, out, tt.out)
		}
	}
}

func TestDecryptTripleDES(t *testing.T) {
	for i, tt := range encryptTripleDESTests {
		c, _ := des.NewTripleDESCipher(tt.key)

		plain := make([]byte, len(tt.in))
		c.Decrypt(plain, tt.out)

		if !bytes.Equal(plain, tt.in) {
			t.Errorf("#%d: result: %x want: %x", i, plain, tt.in)
		}
	}
}

// Defined in Pub 800-20
func TestVariablePlaintextKnownAnswer(t *testing.T) {
	for i, tt := range tableA1Tests {
		c, _ := des.NewTripleDESCipher(tableA1Key)

		out := make([]byte, len(tt.in))
		c.Encrypt(out, tt.in)

		if !bytes.Equal(out, tt.out) {
			t.Errorf("#%d: result: %x want: %x", i, out, tt.out)
		}
	}
}

// Defined in Pub 800-20
func TestVariableCiphertextKnownAnswer(t *testing.T) {
	for i, tt := range tableA1Tests {
		c, _ := des.NewTripleDESCipher(tableA1Key)

		plain := make([]byte, len(tt.out))
		c.Decrypt(plain, tt.out)

		if !bytes.Equal(plain, tt.in) {
			t.Errorf("#%d: result: %x want: %x", i, plain, tt.in)
		}
	}
}

// Defined in Pub 800-20
// Encrypting the Table A.1 ciphertext with the
// 0x01... key produces the original plaintext
func TestInversePermutationKnownAnswer(t *testing.T) {
	for i, tt := range tableA1Tests {
		c, _ := des.NewTripleDESCipher(tableA1Key)

		plain := make([]byte, len(tt.in))
		c.Encrypt(plain, tt.out)

		if !bytes.Equal(plain, tt.in) {
			t.Errorf("#%d: result: %x want: %x", i, plain, tt.in)
		}
	}
}

// Defined in Pub 800-20
// Decrypting the Table A.1 plaintext with the
// 0x01... key produces the corresponding ciphertext
func TestInitialPermutationKnownAnswer(t *testing.T) {
	for i, tt := range tableA1Tests {
		c, _ := des.NewTripleDESCipher(tableA1Key)

		out := make([]byte, len(tt.in))
		c.Decrypt(out, tt.in)

		if !bytes.Equal(out, tt.out) {
			t.Errorf("#%d: result: %x want: %x", i, out, tt.out)
		}
	}
}

// Defined in Pub 800-20
func TestVariableKeyKnownAnswerEncrypt(t *testing.T) {
	for i, tt := range tableA2Tests {
		c, _ := des.NewTripleDESCipher(tt.key)

		out := make([]byte, len(tableA2Plaintext))
		c.Encrypt(out, tableA2Plaintext)

		if !bytes.Equal(out, tt.out) {
			t.Errorf("#%d: result: %x want: %x", i, out, tt.out)
		}
	}
}

// Defined in Pub 800-20
func TestVariableKeyKnownAnswerDecrypt(t *testing.T) {
	for i, tt := range tableA2Tests {
		c, _ := des.NewTripleDESCipher(tt.key)

		out := make([]byte, len(tt.out))
		c.Decrypt(out, tt.out)

		if !bytes.Equal(out, tableA2Plaintext) {
			t.Errorf("#%d: result: %x want: %x", i, out, tableA2Plaintext)
		}
	}
}

// Defined in Pub 800-20
func TestPermutationOperationKnownAnswerEncrypt(t *testing.T) {
	for i, tt := range tableA3Tests {
		c, _ := des.NewTripleDESCipher(tt.key)

		out := make([]byte, len(tableA3Plaintext))
		c.Encrypt(out, tableA3Plaintext)

		if !bytes.Equal(out, tt.out) {
			t.Errorf("#%d: result: %x want: %x", i, out, tt.out)
		}
	}
}

// Defined in Pub 800-20
func TestPermutationOperationKnownAnswerDecrypt(t *testing.T) {
	for i, tt := range tableA3Tests {
		c, _ := des.NewTripleDESCipher(tt.key)

		out := make([]byte, len(tt.out))
		c.Decrypt(out, tt.out)

		if !bytes.Equal(out, tableA3Plaintext) {
			t.Errorf("#%d: result: %x want: %x", i, out, tableA3Plaintext)
		}
	}
}

// Defined in Pub 800-20
func TestSubstitutionTableKnownAnswerEncrypt(t *testing.T) {
	for i, tt := range tableA4Tests {
		c, _ := des.NewTripleDESCipher(tt.key)

		out := make([]byte, len(tt.in))
		c.Encrypt(out, tt.in)

		if !bytes.Equal(out, tt.out) {
			t.Errorf("#%d: result: %x want: %x", i, out, tt.out)
		}
	}
}

// Defined in Pub 800-20
func TestSubstitutionTableKnownAnswerDecrypt(t *testing.T) {
	for i, tt := range tableA4Tests {
		c, _ := des.NewTripleDESCipher(tt.key)

		out := make([]byte, len(tt.out))
		c.Decrypt(out, tt.out)

		if !bytes.Equal(out, tt.in) {
			t.Errorf("#%d: result: %x want: %x", i, out, tt.in)
		}
	}
}

// Test DES against the general cipher.Block interface tester
func TestDESBlock(t *testing.T) {
	t.Run("DES", func(t *testing.T) {
		cryptotest.TestBlock(t, 8, des.NewCipher)
	})

	t.Run("TripleDES", func(t *testing.T) {
		cryptotest.TestBlock(t, 24, des.NewTripleDESCipher)
	})
}

func BenchmarkEncrypt(b *testing.B) {
	tt := encryptDESTests[0]
	c, err := des.NewCipher(tt.key)
	if err != nil {
		b.Fatal("NewCipher:", err)
	}
	out := make([]byte, len(tt.in))
	b.SetBytes(int64(len(out)))
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		c.Encrypt(out, tt.in)
	}
}

func BenchmarkDecrypt(b *testing.B) {
	tt := encryptDESTests[0]
	c, err := des.NewCipher(tt.key)
	if err != nil {
		b.Fatal("NewCipher:", err)
	}
	out := make([]byte, len(tt.out))
	b.SetBytes(int64(len(out)))
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		c.Decrypt(out, tt.out)
	}
}

func BenchmarkTDESEncrypt(b *testing.B) {
	tt := encryptTripleDESTests[0]
	c, err := des.NewTripleDESCipher(tt.key)
	if err != nil {
		b.Fatal("NewCipher:", err)
	}
	out := make([]byte, len(tt.in))
	b.SetBytes(int64(len(out)))
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		c.Encrypt(out, tt.in)
	}
}

func BenchmarkTDESDecrypt(b *testing.B) {
	tt := encryptTripleDESTests[0]
	c, err := des.NewTripleDESCipher(tt.key)
	if err != nil {
		b.Fatal("NewCipher:", err)
	}
	out := make([]byte, len(tt.out))
	b.SetBytes(int64(len(out)))
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		c.Decrypt(out, tt.out)
	}
}
```
Response:
Let's break down the thought process for analyzing this Go test file.

1. **Identify the Core Functionality:** The filename `hmac_test.go` immediately suggests this file is testing the HMAC (Hash-based Message Authentication Code) functionality in the `crypto/hmac` package.

2. **Examine the Imports:**  The imported packages give clues about the scope of testing:
    * `"crypto/internal/boring"`: Likely related to BoringSSL integration or conditional behavior.
    * `"crypto/internal/cryptotest"`:  Indicates usage of internal testing utilities for crypto primitives.
    * `"crypto/md5"`, `"crypto/sha1"`, `"crypto/sha256"`, `"crypto/sha512"`:  Confirms the file tests HMAC with various hash algorithms.
    * `"fmt"`: Used for formatting output, likely in error messages.
    * `"hash"`: The core interface for hash functions in Go.
    * `"testing"`: The standard Go testing package.

3. **Analyze the `hmacTest` Struct:** This struct defines the structure for individual test cases. It holds:
    * `hash func() hash.Hash`:  A function to create a new hash instance. This is crucial for testing HMAC with different hash algorithms.
    * `key []byte`: The secret key for the HMAC.
    * `in []byte`: The input message to be authenticated.
    * `out string`: The expected HMAC output in hexadecimal format.
    * `size int`: The expected size of the HMAC output (in bytes).
    * `blocksize int`: The block size of the underlying hash function.

4. **Inspect the `hmacTests` Variable:** This is a slice of `hmacTest` structs. It's the primary source of test data. Notice:
    * The tests are organized and labeled (e.g., "Tests from US FIPS 198", "Test from Plan 9", "Tests from RFC 4231"). This shows good testing practice, referencing the source of the test vectors.
    * There's a variety of keys (different lengths, content), input messages, and hash functions being tested.
    * The expected output is provided as a hex string.
    * Some tests specifically target key lengths relative to the block size.
    * There are tests for HMAC with an empty key.

5. **Examine the Test Functions:**
    * `TestHMAC(t *testing.T)`: This is the main test function. It iterates through the `hmacTests` slice. Key observations:
        * It uses `hmac.New()` to create an HMAC instance.
        * It checks the `Size()` and `BlockSize()` methods of the HMAC.
        * It performs multiple `Write()` calls to feed the input message.
        * It calls `Sum(nil)` to get the HMAC result. The repeated calls to `Sum()` are intentional to check if it returns the same value.
        * It calls `Reset()` to ensure the HMAC can be reused.
        * There's a section that tests HMAC with a custom `justHash` type. This is likely to test scenarios where the underlying hash doesn't support `MarshalBinary`/`UnmarshalBinary`.

    * `TestNonUniqueHash(t *testing.T)`: This test checks for a panic when `hmac.New()` is called with a function that always returns the *same* hash instance. This is important for security as HMAC relies on independent hash instances. The `boring.Enabled` check indicates this behavior might differ with BoringSSL.

    * `TestEqual(t *testing.T)`: This tests the `hmac.Equal()` function, which is used to securely compare HMAC results to prevent timing attacks. It checks cases with equal and unequal slices, including prefix scenarios.

    * `TestHMACHash(t *testing.T)`: This function uses the `cryptotest` internal package to perform more generic hash testing on the HMAC implementation. This likely includes checks for standard hash interface behavior.

    * `Benchmark...` Functions: These are benchmark functions to measure the performance of HMAC with SHA256 for different input sizes, as well as the overhead of creating new HMAC instances in each iteration.

6. **Infer Functionality and Provide Examples:** Based on the tests, we can deduce that the `crypto/hmac` package provides:
    * `New(h func() hash.Hash, key []byte) hash.Hash`:  Creates a new HMAC instance using a given hash function and key.
    * `h.Write([]byte)`:  Feeds data into the HMAC calculation.
    * `h.Sum([]byte)`: Returns the calculated HMAC. The argument can be used to append the result to an existing slice.
    * `h.Reset()`: Resets the HMAC to its initial state.
    * `Equal(MAC1, MAC2 []byte) bool`:  A timing-attack resistant function to compare HMAC results.
    * `h.Size() int`: Returns the size of the generated MAC.
    * `h.BlockSize() int`: Returns the block size of the underlying hash function.

7. **Identify Potential Pitfalls:** Based on the tests and the nature of HMAC:
    * **Incorrect Key:** Using the wrong key will result in incorrect MACs.
    * **Incorrect Hash Function:** Choosing the wrong hash algorithm will lead to incorrect MACs.
    * **Truncated MACs (not shown in this snippet but a common issue with MACs in general):** While not directly shown here, users might mistakenly truncate the output, which reduces security.
    * **Direct Comparison:**  Using `==` to compare MACs is vulnerable to timing attacks. The `hmac.Equal()` function should be used instead.
    * **Reusing Hash Instances (caught by `TestNonUniqueHash`):**  Don't reuse the same hash.Hash object across different HMAC computations. You need a fresh instance for each.

8. **Address Specific Questions:** Now, go through each part of the original request and formulate the answers based on the analysis above. Pay attention to detail, like mentioning the source of the test vectors.

By following this systematic approach, we can thoroughly understand the functionality of the code and provide a comprehensive answer.
这个 Go 语言实现的文件 `go/src/crypto/hmac/hmac_test.go` 的主要功能是**测试 `crypto/hmac` 包中 HMAC（Hash-based Message Authentication Code）的实现**。它通过一系列的测试用例来验证 HMAC 算法在不同场景下的正确性。

具体来说，这个文件包含了以下功能：

1. **定义测试用例结构体 `hmacTest`:**  该结构体用于存储单个 HMAC 测试用例的参数，包括：
   - `hash func() hash.Hash`:  一个返回哈希函数实例的函数（例如 `sha1.New`）。
   - `key []byte`: 用于 HMAC 计算的密钥。
   - `in []byte`: 作为 HMAC 计算输入的消息。
   - `out string`: 预期的 HMAC 输出结果（十六进制字符串）。
   - `size int`:  预期 HMAC 输出的字节大小。
   - `blocksize int`: 底层哈希算法的块大小。

2. **定义测试用例数组 `hmacTests`:**  这是一个包含多个 `hmacTest` 结构体的数组，每个结构体代表一个独立的测试用例。 这些测试用例来源于不同的标准和实践，例如：
   - US FIPS 198
   - Plan 9 操作系统
   - RFC 4231
   - NIST 的例子

3. **实现测试函数 `TestHMAC(t *testing.T)`:** 该函数遍历 `hmacTests` 数组中的每一个测试用例，并执行以下步骤：
   - 使用 `hmac.New(tt.hash, tt.key)` 创建一个新的 HMAC 实例。
   - 验证 HMAC 实例的 `Size()` 方法返回值是否与预期大小 `tt.size` 一致。
   - 验证 HMAC 实例的 `BlockSize()` 方法返回值是否与预期块大小 `tt.blocksize` 一致。
   - 多次调用 `h.Write(tt.in)` 将输入消息写入 HMAC 实例。
   - 多次调用 `h.Sum(nil)` 获取计算出的 HMAC 值，并将其格式化为十六进制字符串与预期输出 `tt.out` 进行比较。这部分也测试了多次调用 `Sum` 是否返回相同的结果。
   - 调用 `h.Reset()` 重置 HMAC 实例，确保可以重复使用。
   - 针对部分测试用例，创建使用 `justHash` 类型的 HMAC 实例。 `justHash` 是一个只实现了 `hash.Hash` 接口必要方法的类型，用于测试当底层哈希函数没有实现 `MarshalBinary` 和 `UnmarshalBinary` 方法时的 HMAC 工作情况。

4. **实现测试函数 `TestNonUniqueHash(t *testing.T)`:**  该函数测试当使用一个总是返回相同哈希实例的函数作为 `hmac.New` 的参数时，是否会发生 panic。这是为了确保 HMAC 的实现依赖于每次调用哈希生成函数时都返回一个新的、独立的哈希实例。

5. **定义辅助类型 `justHash`:**  这是一个简单的结构体，它内嵌了一个 `hash.Hash` 接口的实现，但自身没有实现额外的接口方法，用于 `TestHMAC` 中测试特定场景。

6. **实现测试函数 `TestEqual(t *testing.T)`:** 该函数测试 `hmac.Equal()` 函数，该函数用于以防止时序攻击的方式比较两个 HMAC 值是否相等。它测试了相等和不相等的字节切片的情况，包括前缀的情况。

7. **实现测试函数 `TestHMACHash(t *testing.T)`:** 该函数使用 `crypto/internal/cryptotest` 包中的 `TestHash` 函数，对 HMAC 实例进行更通用的哈希接口测试，确保 HMAC 实现了 `hash.Hash` 接口的必要方法并行为正确。

8. **实现基准测试函数 `BenchmarkHMACSHA256_1K(b *testing.B)`， `BenchmarkHMACSHA256_32(b *testing.B)` 和 `BenchmarkNewWriteSum(b *testing.B)`:** 这些函数用于测量 HMAC 的性能，分别测试了使用 SHA256 哈希算法处理 1KB 和 32 字节数据时的性能，以及创建新 HMAC 实例、写入数据并计算 Sum 的性能。

**它可以推理出这是对 HMAC (Hash-based Message Authentication Code) 功能的实现进行测试。**

**Go 代码举例说明 HMAC 的使用:**

```go
package main

import (
	"crypto/hmac"
	"crypto/sha256"
	"fmt"
	"io"
)

func main() {
	key := []byte("my-secret-key")
	message := []byte("This is the message to authenticate.")

	// 创建一个新的 HMAC 实例，使用 SHA256 哈希算法
	h := hmac.New(sha256.New, key)

	// 将消息写入 HMAC 实例
	h.Write(message)

	// 获取计算出的 HMAC 值
	mac := h.Sum(nil)

	// 将 HMAC 值编码为十六进制字符串
	macHex := fmt.Sprintf("%x", mac)

	fmt.Println("HMAC:", macHex)

	// 验证 HMAC (假设接收方有相同的密钥和消息)
	receivedKey := []byte("my-secret-key")
	receivedMessage := []byte("This is the message to authenticate.")
	expectedMAC, _ := calculateHMAC(receivedKey, receivedMessage)

	if hmac.Equal(mac, expectedMAC) {
		fmt.Println("HMAC verification successful.")
	} else {
		fmt.Println("HMAC verification failed.")
	}
}

// 辅助函数，用于演示如何计算 HMAC
func calculateHMAC(key, message []byte) ([]byte, error) {
	h := hmac.New(sha256.New, key)
	_, err := h.Write(message)
	if err != nil {
		return nil, err
	}
	return h.Sum(nil), nil
}
```

**假设的输入与输出:**

在上面的代码示例中，假设输入的 `key` 是 `[]byte("my-secret-key")`，输入的 `message` 是 `[]byte("This is the message to authenticate.")`。使用 SHA256 作为哈希算法，预期的输出 `macHex` 将是一个代表 HMAC 值的十六进制字符串，例如：

```
HMAC: 78e73107d9b17d2b937122009c4069897956c1148b5160f868524969a0312377
HMAC verification successful.
```

**命令行参数的具体处理:**

这个测试文件本身并不涉及命令行参数的处理。它是一个单元测试文件，通过 `go test` 命令运行。`go test` 命令有一些标准的命令行参数，例如 `-v`（显示详细输出）、`-run`（运行指定的测试用例）等，但这些是由 `go test` 工具处理的，而不是由这个测试文件本身处理的。

**使用者易犯错的点:**

1. **直接使用 `==` 比较 HMAC 值:**  HMAC 值应该使用 `hmac.Equal()` 函数进行比较，以避免潜在的时序攻击。直接使用 `==` 可能会泄露关于 HMAC 值的信息。

   ```go
   // 错误的做法
   // if mac == expectedMAC { ... }

   // 正确的做法
   if hmac.Equal(mac, expectedMAC) { ... }
   ```

2. **使用错误的密钥或哈希算法:**  HMAC 的安全性依赖于密钥的保密性和所使用的哈希算法的一致性。如果发送方和接收方使用不同的密钥或哈希算法，HMAC 验证将会失败。

3. **修改消息后未重新计算 HMAC:**  HMAC 是对消息的完整性校验。如果消息在传输过程中被修改，接收方必须使用相同的密钥和哈希算法重新计算 HMAC，并与接收到的 HMAC 进行比较。如果消息被修改但未重新计算 HMAC，验证将会失败或可能被绕过。

4. **对空消息或空密钥的处理不当:**  虽然测试用例中包含了对空密钥的测试，但在实际应用中，应该谨慎处理空消息或空密钥的情况，避免潜在的安全风险。 通常建议使用非空的、随机生成的密钥。

### 提示词
```
这是路径为go/src/crypto/hmac/hmac_test.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
请用中文回答。
```

### 源代码
```go
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package hmac

import (
	"crypto/internal/boring"
	"crypto/internal/cryptotest"
	"crypto/md5"
	"crypto/sha1"
	"crypto/sha256"
	"crypto/sha512"
	"fmt"
	"hash"
	"testing"
)

type hmacTest struct {
	hash      func() hash.Hash
	key       []byte
	in        []byte
	out       string
	size      int
	blocksize int
}

var hmacTests = []hmacTest{
	// Tests from US FIPS 198
	// https://csrc.nist.gov/publications/fips/fips198/fips-198a.pdf
	{
		sha1.New,
		[]byte{
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
			0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
			0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
			0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
		},
		[]byte("Sample #1"),
		"4f4ca3d5d68ba7cc0a1208c9c61e9c5da0403c0a",
		sha1.Size,
		sha1.BlockSize,
	},
	{
		sha1.New,
		[]byte{
			0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
			0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
			0x40, 0x41, 0x42, 0x43,
		},
		[]byte("Sample #2"),
		"0922d3405faa3d194f82a45830737d5cc6c75d24",
		sha1.Size,
		sha1.BlockSize,
	},
	{
		sha1.New,
		[]byte{
			0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
			0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
			0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
			0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
			0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
			0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
			0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
			0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
			0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
			0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
			0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
			0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
			0xb0, 0xb1, 0xb2, 0xb3,
		},
		[]byte("Sample #3"),
		"bcf41eab8bb2d802f3d05caf7cb092ecf8d1a3aa",
		sha1.Size,
		sha1.BlockSize,
	},

	// Test from Plan 9.
	{
		md5.New,
		[]byte("Jefe"),
		[]byte("what do ya want for nothing?"),
		"750c783e6ab0b503eaa86e310a5db738",
		md5.Size,
		md5.BlockSize,
	},

	// Tests from RFC 4231
	{
		sha256.New,
		[]byte{
			0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
			0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
			0x0b, 0x0b, 0x0b, 0x0b,
		},
		[]byte("Hi There"),
		"b0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c2e32cff7",
		sha256.Size,
		sha256.BlockSize,
	},
	{
		sha256.New,
		[]byte("Jefe"),
		[]byte("what do ya want for nothing?"),
		"5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843",
		sha256.Size,
		sha256.BlockSize,
	},
	{
		sha256.New,
		[]byte{
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa,
		},
		[]byte{
			0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
			0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
			0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
			0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
			0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
			0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
			0xdd, 0xdd,
		},
		"773ea91e36800e46854db8ebd09181a72959098b3ef8c122d9635514ced565fe",
		sha256.Size,
		sha256.BlockSize,
	},
	{
		sha256.New,
		[]byte{
			0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
			0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
			0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
			0x19,
		},
		[]byte{
			0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
			0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
			0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
			0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
			0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
			0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
			0xcd, 0xcd,
		},
		"82558a389a443c0ea4cc819899f2083a85f0faa3e578f8077a2e3ff46729665b",
		sha256.Size,
		sha256.BlockSize,
	},
	{
		sha256.New,
		[]byte{
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa,
		},
		[]byte("Test Using Larger Than Block-Size Key - Hash Key First"),
		"60e431591ee0b67f0d8a26aacbf5b77f8e0bc6213728c5140546040f0ee37f54",
		sha256.Size,
		sha256.BlockSize,
	},
	{
		sha256.New,
		[]byte{
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa,
		},
		[]byte("This is a test using a larger than block-size key " +
			"and a larger than block-size data. The key needs to " +
			"be hashed before being used by the HMAC algorithm."),
		"9b09ffa71b942fcb27635fbcd5b0e944bfdc63644f0713938a7f51535c3a35e2",
		sha256.Size,
		sha256.BlockSize,
	},

	// Tests from https://csrc.nist.gov/groups/ST/toolkit/examples.html
	// (truncated tag tests are left out)
	{
		sha1.New,
		[]byte{
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
			0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
			0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
			0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
		},
		[]byte("Sample message for keylen=blocklen"),
		"5fd596ee78d5553c8ff4e72d266dfd192366da29",
		sha1.Size,
		sha1.BlockSize,
	},
	{
		sha1.New,
		[]byte{
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			0x10, 0x11, 0x12, 0x13,
		},
		[]byte("Sample message for keylen<blocklen"),
		"4c99ff0cb1b31bd33f8431dbaf4d17fcd356a807",
		sha1.Size,
		sha1.BlockSize,
	},
	{
		sha1.New,
		[]byte{
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
			0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
			0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
			0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
			0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
			0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
			0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
			0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
			0x60, 0x61, 0x62, 0x63,
		},
		[]byte("Sample message for keylen=blocklen"),
		"2d51b2f7750e410584662e38f133435f4c4fd42a",
		sha1.Size,
		sha1.BlockSize,
	},
	{
		sha256.New224,
		[]byte{
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
			0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
			0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
			0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
		},
		[]byte("Sample message for keylen=blocklen"),
		"c7405e3ae058e8cd30b08b4140248581ed174cb34e1224bcc1efc81b",
		sha256.Size224,
		sha256.BlockSize,
	},
	{
		sha256.New224,
		[]byte{
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			0x18, 0x19, 0x1a, 0x1b,
		},
		[]byte("Sample message for keylen<blocklen"),
		"e3d249a8cfb67ef8b7a169e9a0a599714a2cecba65999a51beb8fbbe",
		sha256.Size224,
		sha256.BlockSize,
	},
	{
		sha256.New224,
		[]byte{
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
			0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
			0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
			0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
			0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
			0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
			0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
			0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
			0x60, 0x61, 0x62, 0x63,
		},
		[]byte("Sample message for keylen=blocklen"),
		"91c52509e5af8531601ae6230099d90bef88aaefb961f4080abc014d",
		sha256.Size224,
		sha256.BlockSize,
	},
	{
		sha256.New,
		[]byte{
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
			0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
			0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
			0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
		},
		[]byte("Sample message for keylen=blocklen"),
		"8bb9a1db9806f20df7f77b82138c7914d174d59e13dc4d0169c9057b133e1d62",
		sha256.Size,
		sha256.BlockSize,
	},
	{
		sha256.New,
		[]byte{
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
		},
		[]byte("Sample message for keylen<blocklen"),
		"a28cf43130ee696a98f14a37678b56bcfcbdd9e5cf69717fecf5480f0ebdf790",
		sha256.Size,
		sha256.BlockSize,
	},
	{
		sha256.New,
		[]byte{
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
			0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
			0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
			0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
			0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
			0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
			0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
			0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
			0x60, 0x61, 0x62, 0x63,
		},
		[]byte("Sample message for keylen=blocklen"),
		"bdccb6c72ddeadb500ae768386cb38cc41c63dbb0878ddb9c7a38a431b78378d",
		sha256.Size,
		sha256.BlockSize,
	},
	{
		sha512.New384,
		[]byte{
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
			0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
			0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
			0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
			0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
			0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
			0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
			0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
			0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
			0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
			0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
			0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
		},
		[]byte("Sample message for keylen=blocklen"),
		"63c5daa5e651847ca897c95814ab830bededc7d25e83eef9195cd45857a37f448947858f5af50cc2b1b730ddf29671a9",
		sha512.Size384,
		sha512.BlockSize,
	},
	{
		sha512.New384,
		[]byte{
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
			0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
		},
		[]byte("Sample message for keylen<blocklen"),
		"6eb242bdbb582ca17bebfa481b1e23211464d2b7f8c20b9ff2201637b93646af5ae9ac316e98db45d9cae773675eeed0",
		sha512.Size384,
		sha512.BlockSize,
	},
	{
		sha512.New384,
		[]byte{
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
			0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
			0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
			0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
			0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
			0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
			0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
			0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
			0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
			0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
			0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
			0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
			0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
			0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
			0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
			0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
			0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
			0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
			0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
			0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
			0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,
		},
		[]byte("Sample message for keylen=blocklen"),
		"5b664436df69b0ca22551231a3f0a3d5b4f97991713cfa84bff4d0792eff96c27dccbbb6f79b65d548b40e8564cef594",
		sha512.Size384,
		sha512.BlockSize,
	},
	{
		sha512.New,
		[]byte{
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
			0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
			0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
			0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
			0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
			0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
			0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
			0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
			0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
			0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
			0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
			0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
		},
		[]byte("Sample message for keylen=blocklen"),
		"fc25e240658ca785b7a811a8d3f7b4ca" +
			"48cfa26a8a366bf2cd1f836b05fcb024bd36853081811d6c" +
			"ea4216ebad79da1cfcb95ea4586b8a0ce356596a55fb1347",
		sha512.Size,
		sha512.BlockSize,
	},
	{
		sha512.New,
		[]byte{
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
			0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
			0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
			0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
		},
		[]byte("Sample message for keylen<blocklen"),
		"fd44c18bda0bb0a6ce0e82b031bf2818" +
			"f6539bd56ec00bdc10a8a2d730b3634de2545d639b0f2cf7" +
			"10d0692c72a1896f1f211c2b922d1a96c392e07e7ea9fedc",
		sha512.Size,
		sha512.BlockSize,
	},
	{
		sha512.New,
		[]byte{
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
			0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
			0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
			0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
			0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
			0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
			0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
			0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
			0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
			0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
			0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
			0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
			0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
			0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
			0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
			0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
			0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
			0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
			0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
			0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
			0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,
		},
		[]byte("Sample message for keylen=blocklen"),
		"d93ec8d2de1ad2a9957cb9b83f14e76a" +
			"d6b5e0cce285079a127d3b14bccb7aa7286d4ac0d4ce6421" +
			"5f2bc9e6870b33d97438be4aaa20cda5c5a912b48b8e27f3",
		sha512.Size,
		sha512.BlockSize,
	},
	// HMAC without key is dumb but should probably not fail.
	{
		sha1.New,
		[]byte{},
		[]byte("message"),
		"d5d1ed05121417247616cfc8378f360a39da7cfa",
		sha1.Size,
		sha1.BlockSize,
	},
	{
		sha256.New,
		[]byte{},
		[]byte("message"),
		"eb08c1f56d5ddee07f7bdf80468083da06b64cf4fac64fe3a90883df5feacae4",
		sha256.Size,
		sha256.BlockSize,
	},
	{
		sha512.New,
		[]byte{},
		[]byte("message"),
		"08fce52f6395d59c2a3fb8abb281d74ad6f112b9a9c787bcea290d94dadbc82b2ca3e5e12bf2277c7fedbb0154d5493e41bb7459f63c8e39554ea3651b812492",
		sha512.Size,
		sha512.BlockSize,
	},
}

func TestHMAC(t *testing.T) {
	for i, tt := range hmacTests {
		h := New(tt.hash, tt.key)
		if s := h.Size(); s != tt.size {
			t.Errorf("Size: got %v, want %v", s, tt.size)
		}
		if b := h.BlockSize(); b != tt.blocksize {
			t.Errorf("BlockSize: got %v, want %v", b, tt.blocksize)
		}
		for j := 0; j < 4; j++ {
			n, err := h.Write(tt.in)
			if n != len(tt.in) || err != nil {
				t.Errorf("test %d.%d: Write(%d) = %d, %v", i, j, len(tt.in), n, err)
				continue
			}

			// Repetitive Sum() calls should return the same value
			for k := 0; k < 2; k++ {
				sum := fmt.Sprintf("%x", h.Sum(nil))
				if sum != tt.out {
					t.Errorf("test %d.%d.%d: have %s want %s\n", i, j, k, sum, tt.out)
				}
			}

			// Second iteration: make sure reset works.
			h.Reset()

			// Third and fourth iteration: make sure hmac works on
			// hashes without MarshalBinary/UnmarshalBinary
			if j == 1 {
				h = New(func() hash.Hash { return justHash{tt.hash()} }, tt.key)
			}
		}
	}
}

func TestNonUniqueHash(t *testing.T) {
	if boring.Enabled {
		t.Skip("hash.Hash provided by boringcrypto are not comparable")
	}
	sha := sha256.New()
	defer func() {
		err := recover()
		if err == nil {
			t.Error("expected panic when calling New with a non-unique hash generation function")
		}
	}()
	New(func() hash.Hash { return sha }, []byte("bytes"))
}

// justHash implements just the hash.Hash methods and nothing else
type justHash struct {
	hash.Hash
}

func TestEqual(t *testing.T) {
	a := []byte("test")
	b := []byte("test1")
	c := []byte("test2")

	if !Equal(b, b) {
		t.Error("Equal failed with equal arguments")
	}
	if Equal(a, b) {
		t.Error("Equal accepted a prefix of the second argument")
	}
	if Equal(b, a) {
		t.Error("Equal accepted a prefix of the first argument")
	}
	if Equal(b, c) {
		t.Error("Equal accepted unequal slices")
	}
}

func TestHMACHash(t *testing.T) {
	for i, test := range hmacTests {
		baseHash := test.hash
		key := test.key

		t.Run(fmt.Sprintf("test-%d", i), func(t *testing.T) {
			cryptotest.TestHash(t, func() hash.Hash { return New(baseHash, key) })
		})
	}
}

func BenchmarkHMACSHA256_1K(b *testing.B) {
	key := make([]byte, 32)
	buf := make([]byte, 1024)
	h := New(sha256.New, key)
	b.SetBytes(int64(len(buf)))
	for i := 0; i < b.N; i++ {
		h.Write(buf)
		mac := h.Sum(nil)
		h.Reset()
		buf[0] = mac[0]
	}
}

func BenchmarkHMACSHA256_32(b *testing.B) {
	key := make([]byte, 32)
	buf := make([]byte, 32)
	h := New(sha256.New, key)
	b.SetBytes(int64(len(buf)))
	for i := 0; i < b.N; i++ {
		h.Write(buf)
		mac := h.Sum(nil)
		h.Reset()
		buf[0] = mac[0]
	}
}

func BenchmarkNewWriteSum(b *testing.B) {
	buf := make([]byte, 32)
	b.SetBytes(int64(len(buf)))
	for i := 0; i < b.N; i++ {
		h := New(sha256.New, make([]byte, 32))
		h.Write(buf)
		mac := h.Sum(nil)
		buf[0] = mac[0]
	}
}
```
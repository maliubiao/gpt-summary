Response:
Let's break down the thought process for analyzing this Go code snippet.

1. **Identify the Core Purpose:**  The filename `quic_test.go` and the package name `tls` immediately suggest this code is for testing the QUIC (Quick UDP Internet Connections) protocol implementation within the Go `crypto/tls` package.

2. **Scan for Key Types and Functions:**  Look for prominent type definitions and functions. In this case:
    * `testQUICConn`: This is clearly a custom type used for setting up and managing test QUIC connections. It holds a `QUICConn`, secrets, and callbacks for testing different scenarios.
    * `newTestQUICClient` and `newTestQUICServer`: These are helper functions to create `testQUICConn` instances in client and server roles.
    * `suiteSecret`:  A simple struct to hold the encryption suite and secret key.
    * `setReadSecret` and `setWriteSecret`: Methods on `testQUICConn` to manage encryption secrets at different QUIC encryption levels. The logic within these functions (checking for previous calls, correct levels, etc.) hints at testing the key exchange process.
    * `runTestQUICConnection`: This function is the core of the tests. It simulates the exchange of QUIC events between client and server, using a callback (`onEvent`) for more complex test scenarios.
    * `TestQUICConnection`, `TestQUICSessionResumption`, etc.: These are standard Go test functions, each designed to test a specific aspect of the QUIC implementation.

3. **Analyze `testQUICConn`:** This structure is central to the testing setup. The fields tell a story:
    * `t *testing.T`: Standard Go testing handle.
    * `conn *QUICConn`: The actual QUIC connection being tested.
    * `readSecret`, `writeSecret`: Maps to store encryption secrets at different QUIC encryption levels. This is a strong indicator of testing the key exchange and encryption mechanisms.
    * `ticketOpts`, `onResumeSession`, `gotParams`, `earlyDataRejected`, `complete`: These fields suggest testing session resumption, transport parameters, early data, and the completion of the handshake.

4. **Deconstruct `runTestQUICConnection`:** This function simulates the QUIC handshake.
    * It takes two `testQUICConn` instances (client and server) and an optional `onEvent` callback.
    * It iterates through events generated by the connections using `NextEvent()`.
    * The `switch` statement handles different `QUICEvent` types:
        * `QUICSetReadSecret`, `QUICSetWriteSecret`: Calls the corresponding methods on `testQUICConn`.
        * `QUICWriteData`: Simulates sending data by calling `HandleData` on the other connection.
        * `QUICTransportParameters`: Captures the received transport parameters.
        * `QUICHandshakeDone`: Marks the handshake as complete.
        * `QUICStoreSession`, `QUICResumeSession`:  Relate to session resumption testing.
        * `QUICRejectedEarlyData`:  Relates to early data testing.
    * The loop continues until the handshake is complete or an error occurs.

5. **Examine Individual Test Functions:** Each `Test...` function focuses on a specific feature:
    * `TestQUICConnection`: Basic handshake test, verifying secrets are exchanged correctly.
    * `TestQUICSessionResumption`: Tests the session resumption mechanism.
    * `TestQUICFragmentaryData`: Tests handling of fragmented data.
    * `TestQUICPostHandshakeClientAuthentication`, `TestQUICPostHandshakeKeyUpdate`, `TestQUICPostHandshakeMessageTooLarge`: Test error handling for specific post-handshake scenarios.
    * `TestQUICHandshakeError`: Tests handling of handshake errors (e.g., certificate verification).
    * `TestQUICConnectionState`: Checks the `ConnectionState` method during the handshake.
    * `TestQUICStartContextPropagation`: Tests context propagation to `GetConfigForClient`.
    * `TestQUICDelayedTransportParameters`, `TestQUICEmptyTransportParameters`: Test handling of transport parameters.
    * `TestQUICCanceledWaitingForData`, `TestQUICCanceledWaitingForTransportParams`: Test connection closure during different phases.
    * `TestQUICEarlyData`, `TestQUICEarlyDataDeclined`: Tests the early data feature.

6. **Infer Functionality:** Based on the types, functions, and test cases, we can infer the core functionality being tested:
    * **QUIC Handshake:** The basic process of establishing a secure QUIC connection.
    * **Key Exchange:** Verifying that encryption secrets are correctly exchanged at different levels.
    * **Session Resumption:** Testing the ability to reuse a previous session to speed up connection establishment.
    * **Early Data:** Testing the sending of data before the handshake is complete.
    * **Transport Parameters:** Testing the exchange and handling of QUIC transport parameters.
    * **Post-Handshake Messages:** Testing the handling of various post-handshake messages and potential errors.
    * **Error Handling:** Testing how the implementation handles various errors during the handshake and later stages.
    * **Connection State:**  Testing the ability to query the state of the QUIC connection.
    * **Context Propagation:**  Testing that context is correctly passed through certain TLS functions.

7. **Code Examples (Mental Simulation):**  Consider how you might demonstrate some of the functionalities:
    * **Basic Handshake:**  Create a client and server, run `runTestQUICConnection`, and check if secrets are set.
    * **Session Resumption:** Run a connection, then create new clients/servers and check if `DidResume` is true.
    * **Early Data:**  Set `EarlyData` in `ticketOpts`, run a connection, and verify the early data secrets are present.

8. **Command Line Arguments (Not Applicable):**  This code snippet is for testing; it doesn't involve command-line arguments.

9. **Common Mistakes (Based on Test Cases):**  Look at the error checks in the test functions. This gives hints about potential pitfalls:
    * Incorrectly handling post-handshake messages.
    * Not handling transport parameters correctly.
    * Expecting early data to always be accepted.

10. **Structure the Answer:** Organize the findings into clear sections as requested by the prompt: functionality, code examples, assumptions, command-line arguments, and common mistakes. Use clear and concise language.

This systematic approach allows for a comprehensive understanding of the code's purpose and the underlying QUIC functionality being tested. Even without deep knowledge of QUIC internals, the code itself provides significant clues.
这段代码是 Go 语言 `crypto/tls` 包中用于测试 QUIC (Quick UDP Internet Connections) 功能的一部分。它主要关注 QUIC 协议在 TLS 层面的握手、密钥交换、会话恢复、早期数据等机制的测试。

**以下是代码的功能列表：**

1. **定义测试用的 QUIC 连接结构体 `testQUICConn`:**
   - 包含 `testing.T` 用于测试报告。
   - 包含 `*QUICConn`，代表被测试的 QUIC 连接。
   - 使用 `map[QUICEncryptionLevel]suiteSecret` 来存储不同加密级别的读写密钥 (`readSecret`, `writeSecret`)，用于验证密钥交换的正确性。
   - 包含 `QUICSessionTicketOptions` 用于模拟会话票据的配置。
   - 使用 `onResumeSession` 函数回调来模拟会话恢复时的操作。
   - 使用 `gotParams []byte` 来存储接收到的传输参数。
   - 使用 `earlyDataRejected bool` 标记早期数据是否被拒绝。
   - 使用 `complete bool` 标记握手是否完成。

2. **提供创建测试 QUIC 客户端和服务器的辅助函数 `newTestQUICClient` 和 `newTestQUICServer`:**
   - 这两个函数分别调用 `tls` 包中的 `QUICClient` 和 `QUICServer` 函数来创建 QUIC 连接，并将其封装在 `testQUICConn` 结构体中。
   - 使用 `t.Cleanup` 确保在测试结束后关闭连接。

3. **定义 `suiteSecret` 结构体:**
   - 用于存储加密套件的 ID (`suite`) 和密钥 (`secret`)。

4. **实现 `setReadSecret` 和 `setWriteSecret` 方法:**
   - 用于在测试中设置特定加密级别的读写密钥。
   - 这些方法会进行一些断言，例如检查写入密钥是否在读取密钥之前设置，以及是否在握手完成前设置应用层密钥等，用于验证密钥交换的顺序和时机。

5. **定义 `runTestQUICConnection` 函数:**
   - 这是核心的测试运行函数，用于模拟客户端和服务器之间的 QUIC 连接握手过程。
   - 它接收客户端和服务器的 `testQUICConn` 实例，以及一个可选的 `onEvent` 回调函数，用于在特定 QUIC 事件发生时执行自定义逻辑。
   - 函数内部通过循环不断地从一个连接获取下一个事件 (`NextEvent`)，并根据事件类型进行处理：
     - `QUICSetReadSecret`, `QUICSetWriteSecret`: 调用 `testQUICConn` 的相应方法设置密钥。
     - `QUICWriteData`: 将数据传递给对方连接的 `HandleData` 方法进行处理。
     - `QUICTransportParameters`: 记录接收到的传输参数。
     - `QUICTransportParametersRequired`: 表示需要传输参数。
     - `QUICHandshakeDone`: 标记握手完成，并模拟服务器发送会话票据。
     - `QUICStoreSession`: 模拟客户端存储会话。
     - `QUICResumeSession`: 模拟会话恢复时的操作，调用 `onResumeSession` 回调。
     - `QUICRejectedEarlyData`: 标记早期数据被拒绝。
   - 当握手完成或者发生错误时，循环结束。

6. **实现多个 `TestQUIC...` 函数，用于测试 QUIC 的不同方面：**
   - `TestQUICConnection`: 测试基本的 QUIC 连接握手过程，验证密钥是否正确交换。
   - `TestQUICSessionResumption`: 测试会话恢复功能。
   - `TestQUICFragmentaryData`: 测试处理分片数据的能力。
   - `TestQUICPostHandshakeClientAuthentication`: 测试事后握手客户端认证的错误处理。
   - `TestQUICPostHandshakeKeyUpdate`: 测试事后握手密钥更新的错误处理。
   - `TestQUICPostHandshakeMessageTooLarge`: 测试处理过大的事后握手消息的情况。
   - `TestQUICHandshakeError`: 测试握手过程中发生错误的处理。
   - `TestQUICConnectionState`: 测试在握手过程中获取连接状态的功能。
   - `TestQUICStartContextPropagation`: 测试在 QUIC 连接启动时上下文的传递。
   - `TestQUICDelayedTransportParameters`: 测试延迟设置传输参数的情况。
   - `TestQUICEmptyTransportParameters`: 测试使用空传输参数的情况。
   - `TestQUICCanceledWaitingForData`: 测试在等待数据时取消连接的情况。
   - `TestQUICCanceledWaitingForTransportParams`: 测试在等待传输参数时取消连接的情况。
   - `TestQUICEarlyData`: 测试早期数据功能。
   - `TestQUICEarlyDataDeclined`: 测试服务器或客户端拒绝早期数据的情况。

**代码推理和 Go 语言功能示例：**

这段代码主要测试了 Go 语言 `crypto/tls` 包中对 QUIC 协议的支持。它使用了 Go 的并发模型（虽然在这个测试代码中没有显式的 goroutine），以及 TLS 库提供的 API 来创建和管理 QUIC 连接。

**示例：测试基本的 QUIC 连接握手**

```go
func TestQUICConnectionExample(t *testing.T) {
	config := &QUICConfig{TLSConfig: testConfig.Clone()}
	config.TLSConfig.MinVersion = VersionTLS13

	cli := newTestQUICClient(t, config)
	cli.conn.SetTransportParameters(nil)

	srv := newTestQUICServer(t, config)
	srv.conn.SetTransportParameters(nil)

	err := runTestQUICConnection(context.Background(), cli, srv, nil)
	if err != nil {
		t.Fatalf("error during connection handshake: %v", err)
	}

	// 假设握手成功，我们可以检查密钥是否已设置
	if _, ok := cli.readSecret[QUICEncryptionLevelApplication]; !ok {
		t.Errorf("client has no Application secret")
	}
	if _, ok := srv.readSecret[QUICEncryptionLevelApplication]; !ok {
		t.Errorf("server has no Application secret")
	}
}

// 假设的输入：
// - 客户端和服务器使用相同的 TLS 配置，且支持 TLS 1.3。
// - 传输参数设置为 nil。

// 假设的输出：
// - `runTestQUICConnection` 函数返回 nil，表示握手成功。
// - 客户端和服务器的 `readSecret` 和 `writeSecret` 映射中，对于 `QUICEncryptionLevelApplication` 层级都存在密钥。
```

**涉及的 Go 语言功能：**

- **结构体和方法:** `testQUICConn`, `suiteSecret`, `setReadSecret`, `setWriteSecret`。
- **测试框架:** `testing` 包用于编写和运行测试。
- **上下文:** `context` 包用于控制操作的生命周期。
- **错误处理:** 使用 `error` 接口来处理函数调用可能出现的错误。
- **映射:** `map` 用于存储不同加密级别的密钥。
- **切片:** `[]byte` 用于存储密钥和传输参数。
- **类型断言:** 虽然代码中没有显式使用，但在 `runTestQUICConnection` 中处理 `QUICEvent` 时，实际上是对事件类型的一种隐式判断。

**命令行参数的具体处理：**

这段代码本身是测试代码，不涉及命令行参数的处理。它依赖于 Go 的测试框架，通常使用 `go test` 命令来运行。

**使用者易犯错的点：**

这段代码是框架代码，供 `crypto/tls` 包的开发者使用。普通使用者不会直接使用这些结构体和函数。但是，从测试代码的逻辑中，我们可以推断出在实现 QUIC 功能时一些容易出错的地方：

1. **密钥交换的顺序和时机不正确:**  `setReadSecret` 和 `setWriteSecret` 方法中的断言检查了密钥设置的顺序，这表明在 QUIC 握手过程中，密钥的生成和应用必须按照特定的流程进行。如果开发者在实现 QUIC 时没有正确处理密钥交换，可能会导致连接失败或安全漏洞。

   **示例错误场景:**  在收到服务器的 HandshakeDone 消息之前就尝试设置应用层读取密钥。

2. **传输参数处理不当:** `TestQUICDelayedTransportParameters` 和 `TestQUICEmptyTransportParameters` 测试了传输参数的处理。如果开发者在实现中没有正确处理传输参数的协商和应用，可能会导致连接无法建立或性能下降。

   **示例错误场景:**  在收到对端的传输参数之前就开始发送数据，或者没有正确处理空的传输参数。

3. **会话恢复逻辑错误:** `TestQUICSessionResumption` 测试了会话恢复功能。如果开发者在实现中没有正确存储和恢复会话状态，或者处理会话票据的逻辑有误，可能导致会话恢复失败。

   **示例错误场景:**  服务器在发送 NewSessionTicket 后没有正确保存会话状态，导致客户端无法恢复会话。

4. **早期数据处理不当:** `TestQUICEarlyData` 和 `TestQUICEarlyDataDeclined` 测试了早期数据功能。如果开发者没有正确处理早期数据的发送和接收，或者没有正确处理早期数据被拒绝的情况，可能会导致连接失败或数据丢失。

   **示例错误场景:**  客户端发送了早期数据，但服务器没有正确解密和处理，或者服务器拒绝了早期数据但客户端没有回退到正常的握手流程。

总而言之，这段测试代码通过模拟 QUIC 连接的各种场景，验证了 `crypto/tls` 包中 QUIC 实现的正确性和健壮性，并间接揭示了在实现 QUIC 协议时需要注意的关键点。

### 提示词
```
这是路径为go/src/crypto/tls/quic_test.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
请用中文回答。
```

### 源代码
```go
// Copyright 2023 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package tls

import (
	"bytes"
	"context"
	"errors"
	"reflect"
	"testing"
)

type testQUICConn struct {
	t                 *testing.T
	conn              *QUICConn
	readSecret        map[QUICEncryptionLevel]suiteSecret
	writeSecret       map[QUICEncryptionLevel]suiteSecret
	ticketOpts        QUICSessionTicketOptions
	onResumeSession   func(*SessionState)
	gotParams         []byte
	earlyDataRejected bool
	complete          bool
}

func newTestQUICClient(t *testing.T, config *QUICConfig) *testQUICConn {
	q := &testQUICConn{
		t:    t,
		conn: QUICClient(config),
	}
	t.Cleanup(func() {
		q.conn.Close()
	})
	return q
}

func newTestQUICServer(t *testing.T, config *QUICConfig) *testQUICConn {
	q := &testQUICConn{
		t:    t,
		conn: QUICServer(config),
	}
	t.Cleanup(func() {
		q.conn.Close()
	})
	return q
}

type suiteSecret struct {
	suite  uint16
	secret []byte
}

func (q *testQUICConn) setReadSecret(level QUICEncryptionLevel, suite uint16, secret []byte) {
	if _, ok := q.writeSecret[level]; !ok && level != QUICEncryptionLevelEarly {
		q.t.Errorf("SetReadSecret for level %v called before SetWriteSecret", level)
	}
	if level == QUICEncryptionLevelApplication && !q.complete {
		q.t.Errorf("SetReadSecret for level %v called before HandshakeComplete", level)
	}
	if _, ok := q.readSecret[level]; ok {
		q.t.Errorf("SetReadSecret for level %v called twice", level)
	}
	if q.readSecret == nil {
		q.readSecret = map[QUICEncryptionLevel]suiteSecret{}
	}
	switch level {
	case QUICEncryptionLevelHandshake,
		QUICEncryptionLevelEarly,
		QUICEncryptionLevelApplication:
		q.readSecret[level] = suiteSecret{suite, secret}
	default:
		q.t.Errorf("SetReadSecret for unexpected level %v", level)
	}
}

func (q *testQUICConn) setWriteSecret(level QUICEncryptionLevel, suite uint16, secret []byte) {
	if _, ok := q.writeSecret[level]; ok {
		q.t.Errorf("SetWriteSecret for level %v called twice", level)
	}
	if q.writeSecret == nil {
		q.writeSecret = map[QUICEncryptionLevel]suiteSecret{}
	}
	switch level {
	case QUICEncryptionLevelHandshake,
		QUICEncryptionLevelEarly,
		QUICEncryptionLevelApplication:
		q.writeSecret[level] = suiteSecret{suite, secret}
	default:
		q.t.Errorf("SetWriteSecret for unexpected level %v", level)
	}
}

var errTransportParametersRequired = errors.New("transport parameters required")

func runTestQUICConnection(ctx context.Context, cli, srv *testQUICConn, onEvent func(e QUICEvent, src, dst *testQUICConn) bool) error {
	a, b := cli, srv
	for _, c := range []*testQUICConn{a, b} {
		if !c.conn.conn.quic.started {
			if err := c.conn.Start(ctx); err != nil {
				return err
			}
		}
	}
	idleCount := 0
	for {
		e := a.conn.NextEvent()
		if onEvent != nil && onEvent(e, a, b) {
			continue
		}
		switch e.Kind {
		case QUICNoEvent:
			idleCount++
			if idleCount == 2 {
				if !a.complete || !b.complete {
					return errors.New("handshake incomplete")
				}
				return nil
			}
			a, b = b, a
		case QUICSetReadSecret:
			a.setReadSecret(e.Level, e.Suite, e.Data)
		case QUICSetWriteSecret:
			a.setWriteSecret(e.Level, e.Suite, e.Data)
		case QUICWriteData:
			if err := b.conn.HandleData(e.Level, e.Data); err != nil {
				return err
			}
		case QUICTransportParameters:
			a.gotParams = e.Data
			if a.gotParams == nil {
				a.gotParams = []byte{}
			}
		case QUICTransportParametersRequired:
			return errTransportParametersRequired
		case QUICHandshakeDone:
			a.complete = true
			if a == srv {
				if err := srv.conn.SendSessionTicket(srv.ticketOpts); err != nil {
					return err
				}
			}
		case QUICStoreSession:
			if a != cli {
				return errors.New("unexpected QUICStoreSession event received by server")
			}
			a.conn.StoreSession(e.SessionState)
		case QUICResumeSession:
			if a.onResumeSession != nil {
				a.onResumeSession(e.SessionState)
			}
		case QUICRejectedEarlyData:
			a.earlyDataRejected = true
		}
		if e.Kind != QUICNoEvent {
			idleCount = 0
		}
	}
}

func TestQUICConnection(t *testing.T) {
	config := &QUICConfig{TLSConfig: testConfig.Clone()}
	config.TLSConfig.MinVersion = VersionTLS13

	cli := newTestQUICClient(t, config)
	cli.conn.SetTransportParameters(nil)

	srv := newTestQUICServer(t, config)
	srv.conn.SetTransportParameters(nil)

	if err := runTestQUICConnection(context.Background(), cli, srv, nil); err != nil {
		t.Fatalf("error during connection handshake: %v", err)
	}

	if _, ok := cli.readSecret[QUICEncryptionLevelHandshake]; !ok {
		t.Errorf("client has no Handshake secret")
	}
	if _, ok := cli.readSecret[QUICEncryptionLevelApplication]; !ok {
		t.Errorf("client has no Application secret")
	}
	if _, ok := srv.readSecret[QUICEncryptionLevelHandshake]; !ok {
		t.Errorf("server has no Handshake secret")
	}
	if _, ok := srv.readSecret[QUICEncryptionLevelApplication]; !ok {
		t.Errorf("server has no Application secret")
	}
	for _, level := range []QUICEncryptionLevel{QUICEncryptionLevelHandshake, QUICEncryptionLevelApplication} {
		if _, ok := cli.readSecret[level]; !ok {
			t.Errorf("client has no %v read secret", level)
		}
		if _, ok := srv.readSecret[level]; !ok {
			t.Errorf("server has no %v read secret", level)
		}
		if !reflect.DeepEqual(cli.readSecret[level], srv.writeSecret[level]) {
			t.Errorf("client read secret does not match server write secret for level %v", level)
		}
		if !reflect.DeepEqual(cli.writeSecret[level], srv.readSecret[level]) {
			t.Errorf("client write secret does not match server read secret for level %v", level)
		}
	}
}

func TestQUICSessionResumption(t *testing.T) {
	clientConfig := &QUICConfig{TLSConfig: testConfig.Clone()}
	clientConfig.TLSConfig.MinVersion = VersionTLS13
	clientConfig.TLSConfig.ClientSessionCache = NewLRUClientSessionCache(1)
	clientConfig.TLSConfig.ServerName = "example.go.dev"

	serverConfig := &QUICConfig{TLSConfig: testConfig.Clone()}
	serverConfig.TLSConfig.MinVersion = VersionTLS13

	cli := newTestQUICClient(t, clientConfig)
	cli.conn.SetTransportParameters(nil)
	srv := newTestQUICServer(t, serverConfig)
	srv.conn.SetTransportParameters(nil)
	if err := runTestQUICConnection(context.Background(), cli, srv, nil); err != nil {
		t.Fatalf("error during first connection handshake: %v", err)
	}
	if cli.conn.ConnectionState().DidResume {
		t.Errorf("first connection unexpectedly used session resumption")
	}

	cli2 := newTestQUICClient(t, clientConfig)
	cli2.conn.SetTransportParameters(nil)
	srv2 := newTestQUICServer(t, serverConfig)
	srv2.conn.SetTransportParameters(nil)
	if err := runTestQUICConnection(context.Background(), cli2, srv2, nil); err != nil {
		t.Fatalf("error during second connection handshake: %v", err)
	}
	if !cli2.conn.ConnectionState().DidResume {
		t.Errorf("second connection did not use session resumption")
	}
}

func TestQUICFragmentaryData(t *testing.T) {
	clientConfig := &QUICConfig{TLSConfig: testConfig.Clone()}
	clientConfig.TLSConfig.MinVersion = VersionTLS13
	clientConfig.TLSConfig.ClientSessionCache = NewLRUClientSessionCache(1)
	clientConfig.TLSConfig.ServerName = "example.go.dev"

	serverConfig := &QUICConfig{TLSConfig: testConfig.Clone()}
	serverConfig.TLSConfig.MinVersion = VersionTLS13

	cli := newTestQUICClient(t, clientConfig)
	cli.conn.SetTransportParameters(nil)
	srv := newTestQUICServer(t, serverConfig)
	srv.conn.SetTransportParameters(nil)
	onEvent := func(e QUICEvent, src, dst *testQUICConn) bool {
		if e.Kind == QUICWriteData {
			// Provide the data one byte at a time.
			for i := range e.Data {
				if err := dst.conn.HandleData(e.Level, e.Data[i:i+1]); err != nil {
					t.Errorf("HandleData: %v", err)
					break
				}
			}
			return true
		}
		return false
	}
	if err := runTestQUICConnection(context.Background(), cli, srv, onEvent); err != nil {
		t.Fatalf("error during first connection handshake: %v", err)
	}
}

func TestQUICPostHandshakeClientAuthentication(t *testing.T) {
	// RFC 9001, Section 4.4.
	config := &QUICConfig{TLSConfig: testConfig.Clone()}
	config.TLSConfig.MinVersion = VersionTLS13
	cli := newTestQUICClient(t, config)
	cli.conn.SetTransportParameters(nil)
	srv := newTestQUICServer(t, config)
	srv.conn.SetTransportParameters(nil)
	if err := runTestQUICConnection(context.Background(), cli, srv, nil); err != nil {
		t.Fatalf("error during connection handshake: %v", err)
	}

	certReq := new(certificateRequestMsgTLS13)
	certReq.ocspStapling = true
	certReq.scts = true
	certReq.supportedSignatureAlgorithms = supportedSignatureAlgorithms()
	certReqBytes, err := certReq.marshal()
	if err != nil {
		t.Fatal(err)
	}
	if err := cli.conn.HandleData(QUICEncryptionLevelApplication, append([]byte{
		byte(typeCertificateRequest),
		byte(0), byte(0), byte(len(certReqBytes)),
	}, certReqBytes...)); err == nil {
		t.Fatalf("post-handshake authentication request: got no error, want one")
	}
}

func TestQUICPostHandshakeKeyUpdate(t *testing.T) {
	// RFC 9001, Section 6.
	config := &QUICConfig{TLSConfig: testConfig.Clone()}
	config.TLSConfig.MinVersion = VersionTLS13
	cli := newTestQUICClient(t, config)
	cli.conn.SetTransportParameters(nil)
	srv := newTestQUICServer(t, config)
	srv.conn.SetTransportParameters(nil)
	if err := runTestQUICConnection(context.Background(), cli, srv, nil); err != nil {
		t.Fatalf("error during connection handshake: %v", err)
	}

	keyUpdate := new(keyUpdateMsg)
	keyUpdateBytes, err := keyUpdate.marshal()
	if err != nil {
		t.Fatal(err)
	}
	if err := cli.conn.HandleData(QUICEncryptionLevelApplication, append([]byte{
		byte(typeKeyUpdate),
		byte(0), byte(0), byte(len(keyUpdateBytes)),
	}, keyUpdateBytes...)); !errors.Is(err, alertUnexpectedMessage) {
		t.Fatalf("key update request: got error %v, want alertUnexpectedMessage", err)
	}
}

func TestQUICPostHandshakeMessageTooLarge(t *testing.T) {
	config := &QUICConfig{TLSConfig: testConfig.Clone()}
	config.TLSConfig.MinVersion = VersionTLS13
	cli := newTestQUICClient(t, config)
	cli.conn.SetTransportParameters(nil)
	srv := newTestQUICServer(t, config)
	srv.conn.SetTransportParameters(nil)
	if err := runTestQUICConnection(context.Background(), cli, srv, nil); err != nil {
		t.Fatalf("error during connection handshake: %v", err)
	}

	size := maxHandshake + 1
	if err := cli.conn.HandleData(QUICEncryptionLevelApplication, []byte{
		byte(typeNewSessionTicket),
		byte(size >> 16),
		byte(size >> 8),
		byte(size),
	}); err == nil {
		t.Fatalf("%v-byte post-handshake message: got no error, want one", size)
	}
}

func TestQUICHandshakeError(t *testing.T) {
	clientConfig := &QUICConfig{TLSConfig: testConfig.Clone()}
	clientConfig.TLSConfig.MinVersion = VersionTLS13
	clientConfig.TLSConfig.InsecureSkipVerify = false
	clientConfig.TLSConfig.ServerName = "name"

	serverConfig := &QUICConfig{TLSConfig: testConfig.Clone()}
	serverConfig.TLSConfig.MinVersion = VersionTLS13

	cli := newTestQUICClient(t, clientConfig)
	cli.conn.SetTransportParameters(nil)
	srv := newTestQUICServer(t, serverConfig)
	srv.conn.SetTransportParameters(nil)
	err := runTestQUICConnection(context.Background(), cli, srv, nil)
	if !errors.Is(err, AlertError(alertBadCertificate)) {
		t.Errorf("connection handshake terminated with error %q, want alertBadCertificate", err)
	}
	var e *CertificateVerificationError
	if !errors.As(err, &e) {
		t.Errorf("connection handshake terminated with error %q, want CertificateVerificationError", err)
	}
}

// Test that QUICConn.ConnectionState can be used during the handshake,
// and that it reports the application protocol as soon as it has been
// negotiated.
func TestQUICConnectionState(t *testing.T) {
	config := &QUICConfig{TLSConfig: testConfig.Clone()}
	config.TLSConfig.MinVersion = VersionTLS13
	config.TLSConfig.NextProtos = []string{"h3"}
	cli := newTestQUICClient(t, config)
	cli.conn.SetTransportParameters(nil)
	srv := newTestQUICServer(t, config)
	srv.conn.SetTransportParameters(nil)
	onEvent := func(e QUICEvent, src, dst *testQUICConn) bool {
		cliCS := cli.conn.ConnectionState()
		if _, ok := cli.readSecret[QUICEncryptionLevelApplication]; ok {
			if want, got := cliCS.NegotiatedProtocol, "h3"; want != got {
				t.Errorf("cli.ConnectionState().NegotiatedProtocol = %q, want %q", want, got)
			}
		}
		srvCS := srv.conn.ConnectionState()
		if _, ok := srv.readSecret[QUICEncryptionLevelHandshake]; ok {
			if want, got := srvCS.NegotiatedProtocol, "h3"; want != got {
				t.Errorf("srv.ConnectionState().NegotiatedProtocol = %q, want %q", want, got)
			}
		}
		return false
	}
	if err := runTestQUICConnection(context.Background(), cli, srv, onEvent); err != nil {
		t.Fatalf("error during connection handshake: %v", err)
	}
}

func TestQUICStartContextPropagation(t *testing.T) {
	const key = "key"
	const value = "value"
	ctx := context.WithValue(context.Background(), key, value)
	config := &QUICConfig{TLSConfig: testConfig.Clone()}
	config.TLSConfig.MinVersion = VersionTLS13
	calls := 0
	config.TLSConfig.GetConfigForClient = func(info *ClientHelloInfo) (*Config, error) {
		calls++
		got, _ := info.Context().Value(key).(string)
		if got != value {
			t.Errorf("GetConfigForClient context key %q has value %q, want %q", key, got, value)
		}
		return nil, nil
	}
	cli := newTestQUICClient(t, config)
	cli.conn.SetTransportParameters(nil)
	srv := newTestQUICServer(t, config)
	srv.conn.SetTransportParameters(nil)
	if err := runTestQUICConnection(ctx, cli, srv, nil); err != nil {
		t.Fatalf("error during connection handshake: %v", err)
	}
	if calls != 1 {
		t.Errorf("GetConfigForClient called %v times, want 1", calls)
	}
}

func TestQUICDelayedTransportParameters(t *testing.T) {
	clientConfig := &QUICConfig{TLSConfig: testConfig.Clone()}
	clientConfig.TLSConfig.MinVersion = VersionTLS13
	clientConfig.TLSConfig.ClientSessionCache = NewLRUClientSessionCache(1)
	clientConfig.TLSConfig.ServerName = "example.go.dev"

	serverConfig := &QUICConfig{TLSConfig: testConfig.Clone()}
	serverConfig.TLSConfig.MinVersion = VersionTLS13

	cliParams := "client params"
	srvParams := "server params"

	cli := newTestQUICClient(t, clientConfig)
	srv := newTestQUICServer(t, serverConfig)
	if err := runTestQUICConnection(context.Background(), cli, srv, nil); err != errTransportParametersRequired {
		t.Fatalf("handshake with no client parameters: %v; want errTransportParametersRequired", err)
	}
	cli.conn.SetTransportParameters([]byte(cliParams))
	if err := runTestQUICConnection(context.Background(), cli, srv, nil); err != errTransportParametersRequired {
		t.Fatalf("handshake with no server parameters: %v; want errTransportParametersRequired", err)
	}
	srv.conn.SetTransportParameters([]byte(srvParams))
	if err := runTestQUICConnection(context.Background(), cli, srv, nil); err != nil {
		t.Fatalf("error during connection handshake: %v", err)
	}

	if got, want := string(cli.gotParams), srvParams; got != want {
		t.Errorf("client got transport params: %q, want %q", got, want)
	}
	if got, want := string(srv.gotParams), cliParams; got != want {
		t.Errorf("server got transport params: %q, want %q", got, want)
	}
}

func TestQUICEmptyTransportParameters(t *testing.T) {
	config := &QUICConfig{TLSConfig: testConfig.Clone()}
	config.TLSConfig.MinVersion = VersionTLS13

	cli := newTestQUICClient(t, config)
	cli.conn.SetTransportParameters(nil)
	srv := newTestQUICServer(t, config)
	srv.conn.SetTransportParameters(nil)
	if err := runTestQUICConnection(context.Background(), cli, srv, nil); err != nil {
		t.Fatalf("error during connection handshake: %v", err)
	}

	if cli.gotParams == nil {
		t.Errorf("client did not get transport params")
	}
	if srv.gotParams == nil {
		t.Errorf("server did not get transport params")
	}
	if len(cli.gotParams) != 0 {
		t.Errorf("client got transport params: %v, want empty", cli.gotParams)
	}
	if len(srv.gotParams) != 0 {
		t.Errorf("server got transport params: %v, want empty", srv.gotParams)
	}
}

func TestQUICCanceledWaitingForData(t *testing.T) {
	config := &QUICConfig{TLSConfig: testConfig.Clone()}
	config.TLSConfig.MinVersion = VersionTLS13
	cli := newTestQUICClient(t, config)
	cli.conn.SetTransportParameters(nil)
	cli.conn.Start(context.Background())
	for cli.conn.NextEvent().Kind != QUICNoEvent {
	}
	err := cli.conn.Close()
	if !errors.Is(err, alertCloseNotify) {
		t.Errorf("conn.Close() = %v, want alertCloseNotify", err)
	}
}

func TestQUICCanceledWaitingForTransportParams(t *testing.T) {
	config := &QUICConfig{TLSConfig: testConfig.Clone()}
	config.TLSConfig.MinVersion = VersionTLS13
	cli := newTestQUICClient(t, config)
	cli.conn.Start(context.Background())
	for cli.conn.NextEvent().Kind != QUICTransportParametersRequired {
	}
	err := cli.conn.Close()
	if !errors.Is(err, alertCloseNotify) {
		t.Errorf("conn.Close() = %v, want alertCloseNotify", err)
	}
}

func TestQUICEarlyData(t *testing.T) {
	clientConfig := &QUICConfig{TLSConfig: testConfig.Clone()}
	clientConfig.TLSConfig.MinVersion = VersionTLS13
	clientConfig.TLSConfig.ClientSessionCache = NewLRUClientSessionCache(1)
	clientConfig.TLSConfig.ServerName = "example.go.dev"
	clientConfig.TLSConfig.NextProtos = []string{"h3"}

	serverConfig := &QUICConfig{TLSConfig: testConfig.Clone()}
	serverConfig.TLSConfig.MinVersion = VersionTLS13
	serverConfig.TLSConfig.NextProtos = []string{"h3"}

	cli := newTestQUICClient(t, clientConfig)
	cli.conn.SetTransportParameters(nil)
	srv := newTestQUICServer(t, serverConfig)
	srv.conn.SetTransportParameters(nil)
	srv.ticketOpts.EarlyData = true
	if err := runTestQUICConnection(context.Background(), cli, srv, nil); err != nil {
		t.Fatalf("error during first connection handshake: %v", err)
	}
	if cli.conn.ConnectionState().DidResume {
		t.Errorf("first connection unexpectedly used session resumption")
	}

	cli2 := newTestQUICClient(t, clientConfig)
	cli2.conn.SetTransportParameters(nil)
	srv2 := newTestQUICServer(t, serverConfig)
	srv2.conn.SetTransportParameters(nil)
	onEvent := func(e QUICEvent, src, dst *testQUICConn) bool {
		switch e.Kind {
		case QUICStoreSession, QUICResumeSession:
			t.Errorf("with EnableSessionEvents=false, got unexpected event %v", e.Kind)
		}
		return false
	}
	if err := runTestQUICConnection(context.Background(), cli2, srv2, onEvent); err != nil {
		t.Fatalf("error during second connection handshake: %v", err)
	}
	if !cli2.conn.ConnectionState().DidResume {
		t.Errorf("second connection did not use session resumption")
	}
	cliSecret := cli2.writeSecret[QUICEncryptionLevelEarly]
	if cliSecret.secret == nil {
		t.Errorf("client did not receive early data write secret")
	}
	srvSecret := srv2.readSecret[QUICEncryptionLevelEarly]
	if srvSecret.secret == nil {
		t.Errorf("server did not receive early data read secret")
	}
	if cliSecret.suite != srvSecret.suite || !bytes.Equal(cliSecret.secret, srvSecret.secret) {
		t.Errorf("client early data secret does not match server")
	}
}

func TestQUICEarlyDataDeclined(t *testing.T) {
	t.Run("server", func(t *testing.T) {
		testQUICEarlyDataDeclined(t, true)
	})
	t.Run("client", func(t *testing.T) {
		testQUICEarlyDataDeclined(t, false)
	})
}

func testQUICEarlyDataDeclined(t *testing.T, server bool) {
	clientConfig := &QUICConfig{TLSConfig: testConfig.Clone()}
	clientConfig.EnableSessionEvents = true
	clientConfig.TLSConfig.MinVersion = VersionTLS13
	clientConfig.TLSConfig.ClientSessionCache = NewLRUClientSessionCache(1)
	clientConfig.TLSConfig.ServerName = "example.go.dev"
	clientConfig.TLSConfig.NextProtos = []string{"h3"}

	serverConfig := &QUICConfig{TLSConfig: testConfig.Clone()}
	serverConfig.EnableSessionEvents = true
	serverConfig.TLSConfig.MinVersion = VersionTLS13
	serverConfig.TLSConfig.NextProtos = []string{"h3"}

	cli := newTestQUICClient(t, clientConfig)
	cli.conn.SetTransportParameters(nil)
	srv := newTestQUICServer(t, serverConfig)
	srv.conn.SetTransportParameters(nil)
	srv.ticketOpts.EarlyData = true
	if err := runTestQUICConnection(context.Background(), cli, srv, nil); err != nil {
		t.Fatalf("error during first connection handshake: %v", err)
	}
	if cli.conn.ConnectionState().DidResume {
		t.Errorf("first connection unexpectedly used session resumption")
	}

	cli2 := newTestQUICClient(t, clientConfig)
	cli2.conn.SetTransportParameters(nil)
	srv2 := newTestQUICServer(t, serverConfig)
	srv2.conn.SetTransportParameters(nil)
	declineEarlyData := func(state *SessionState) {
		state.EarlyData = false
	}
	if server {
		srv2.onResumeSession = declineEarlyData
	} else {
		cli2.onResumeSession = declineEarlyData
	}
	if err := runTestQUICConnection(context.Background(), cli2, srv2, nil); err != nil {
		t.Fatalf("error during second connection handshake: %v", err)
	}
	if !cli2.conn.ConnectionState().DidResume {
		t.Errorf("second connection did not use session resumption")
	}
	_, cliEarlyData := cli2.writeSecret[QUICEncryptionLevelEarly]
	if server {
		if !cliEarlyData {
			t.Errorf("client did not receive early data write secret")
		}
		if !cli2.earlyDataRejected {
			t.Errorf("client did not receive QUICEarlyDataRejected")
		}
	}
	if _, srvEarlyData := srv2.readSecret[QUICEncryptionLevelEarly]; srvEarlyData {
		t.Errorf("server received early data read secret")
	}
}
```
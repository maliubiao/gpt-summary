Response:
我的目标是对给定的 Go 语言测试代码进行分析，并用中文进行详细的解释。我的思考过程如下：

1. **理解代码的功能目标**:  首先，我阅读了代码的注释 `// Copyright ...` 和 `package hkdf`，以及导入的包 `crypto/internal/boring`, `crypto/internal/fips140`, `crypto/md5`, `crypto/sha1`, `crypto/sha256`, `crypto/sha512`, `hash`, `testing` 和 `bytes`。这让我初步判断这段代码是关于 `hkdf` 包的测试。`hkdf` 很可能是一种密钥派生函数。

2. **分析测试用例结构**: 我注意到 `hkdfTest` 结构体定义了测试用例的输入和预期输出，包括 `hash` 函数、`master` 密钥、`salt` 盐值、`prk` 伪随机密钥、`info` 上下文信息和 `out` 派生密钥。 `hkdfTests` 变量是一个 `hkdfTest` 类型的切片，包含了多个测试用例。这些用例很可能来自 RFC 规范或其他标准。

3. **解读 `TestHKDF` 函数**:  这个函数遍历 `hkdfTests` 中的每个测试用例，并执行以下操作：
    * 调用 `Extract` 函数，传入 `hash`、`master` 和 `salt`，并比较返回的 `prk` 与预期值。
    * 调用 `Key` 函数，传入 `hash`、`master`、`salt`、`info` 和期望的输出长度，并比较返回的 `key` 与预期值。
    * 调用 `Expand` 函数，传入 `hash`、`prk`、`info` 和期望的输出长度，并比较返回的 `expanded` 与预期值。
    这让我确信 `Extract`、`Key` 和 `Expand` 是 `hkdf` 包的核心函数。`Extract` 负责提取伪随机密钥 (PRK)，`Key` 负责直接派生密钥，而 `Expand` 则使用 PRK 进行扩展。

4. **解读 `TestHKDFLimit` 函数**: 这个函数测试了 `Key` 函数的输出长度限制。它计算了基于哈希大小的最大允许输出长度，并尝试请求略超过该长度的密钥，验证是否会返回错误。

5. **解读 Benchmark 函数**:  `Benchmark16ByteMD5Single`、`Benchmark20ByteSHA1Single` 等函数用于性能基准测试。它们调用 `benchmarkHKDF` 函数，并传入不同的哈希函数和块大小。`benchmarkHKDF` 内部循环调用 `Key` 函数进行性能测试。

6. **解读 `TestFIPSServiceIndicator` 函数**:  这个函数与 FIPS 140 认证相关。它检查在某些条件下调用 `Key` 函数是否会设置 FIPS 服务指示器。这表明 `hkdf` 包可能与安全标准合规性有关。

7. **推理 `hkdf` 包的功能**: 基于以上分析，我推断 `hkdf` 包实现了 **HKDF（HMAC-based Extract-and-Expand Key Derivation Function）**。这是一种从给定的主密钥派生出一个或多个加密密钥的标准化方法。它分为两个阶段：提取阶段（Extract）使用 HMAC 从主密钥和可选的盐生成伪随机密钥（PRK）；扩展阶段（Expand）使用 PRK 和上下文信息生成所需的密钥材料。

8. **编写代码示例**: 为了演示 `hkdf` 的使用，我编写了一个示例，展示了如何使用 `Key` 函数进行密钥派生。我选择了 `sha256.New` 作为哈希函数，并提供了 `master`、`salt` 和 `info` 作为输入，并指定了期望的输出长度。

9. **总结易犯错的点**: 我注意到当 salt 为 `nil` 时，`Extract` 和 `Key` 函数内部会使用一个零长度的 salt。这可能不是用户期望的行为，容易导致安全漏洞，因此我将其列为易犯错的点。

10. **组织答案**: 最后，我将以上分析结果组织成结构化的中文答案，包括功能介绍、功能推理、代码示例、命令行参数处理（本代码不涉及）、易犯错的点等部分。  我力求使用清晰简洁的语言解释每个部分，并提供具体的代码示例和假设的输入输出，以便更好地理解。

通过以上步骤，我能够较为全面地理解这段 Go 语言测试代码的功能和背后的 `hkdf` 包的功能，并用中文清晰地表达出来。
这段代码是 Go 语言标准库中 `crypto/hkdf` 包的测试文件 `hkdf_test.go` 的一部分。它的主要功能是**测试 HKDF（HMAC-based Extract-and-Expand Key Derivation Function）的实现是否正确**。

具体来说，它通过以下方式进行测试：

1. **定义测试用例**:
   - 定义了一个结构体 `hkdfTest`，用于存储每个测试用例的输入和预期输出，包括：
     - `hash`: 使用的哈希函数 (例如 `sha256.New`)。
     - `master`: 主密钥（Master Key）。
     - `salt`: 盐值。
     - `prk`: 预期的伪随机密钥（Pseudorandom Key）。
     - `info`: 上下文信息。
     - `out`: 预期的输出密钥材料。
   - 定义了一个测试用例切片 `hkdfTests`，其中包含了多个 `hkdfTest` 结构体的实例。这些测试用例涵盖了来自 RFC 5869 的示例以及一些边界情况（例如空盐值）。

2. **测试 HKDF 的提取 (Extract) 阶段**:
   - `TestHKDF` 函数遍历 `hkdfTests` 中的每个测试用例。
   - 对于每个测试用例，它调用 `hkdf.Extract(tt.hash, tt.master, tt.salt)` 函数，使用指定的哈希函数、主密钥和盐值来提取伪随机密钥 (PRK)。
   - 然后，它使用 `bytes.Equal` 函数比较实际提取出的 PRK 与预期的 PRK (`tt.prk`) 是否一致。如果不一致，则报告错误。

3. **测试 HKDF 的密钥派生 (Key) 阶段**:
   - `TestHKDF` 函数继续调用 `hkdf.Key(tt.hash, tt.master, tt.salt, string(tt.info), len(tt.out))` 函数。
   - 这个函数直接从主密钥和盐值派生出密钥材料，其内部会先执行提取阶段，再执行扩展阶段。
   - 它比较实际派生出的密钥与预期的输出密钥材料 (`tt.out`) 是否一致。

4. **测试 HKDF 的扩展 (Expand) 阶段**:
   - `TestHKDF` 函数还调用 `hkdf.Expand(tt.hash, prk, string(tt.info), len(tt.out))` 函数。
   - 这个函数使用之前提取出的 PRK 以及上下文信息来扩展生成指定长度的密钥材料。
   - 它比较实际扩展出的密钥材料与预期的输出密钥材料 (`tt.out`) 是否一致。

5. **测试输出长度限制**:
   - `TestHKDFLimit` 函数测试了 `hkdf.Key` 函数的输出长度限制。HKDF 的输出长度不能超过所用哈希函数输出长度的 255 倍。
   - 它尝试派生出最大允许长度的密钥，并验证是否成功。
   - 然后，它尝试派生出超过最大允许长度的密钥，并验证是否会返回错误。

6. **性能基准测试**:
   - `Benchmark16ByteMD5Single`、`Benchmark20ByteSHA1Single`、`Benchmark32ByteSHA256Single` 和 `Benchmark64ByteSHA512Single` 这几个函数用于进行性能基准测试。
   - 它们使用不同的哈希函数 (`md5`, `sha1`, `sha256`, `sha512`) 和固定的输入大小来衡量 `hkdf.Key` 函数的执行速度。

7. **测试 FIPS 合规性指示器**:
   - `TestFIPSServiceIndicator` 函数用于测试在满足一定条件下，HKDF 的使用是否会设置 FIPS 140 模块的服务指示器。这与 Go 语言的 FIPS 140 模块合规性有关。它检查了密钥长度是否满足 FIPS 的要求。

**推理 `hkdf` 包的功能**:

从这个测试文件来看，我们可以推断出 `crypto/hkdf` 包实现了 **HKDF (HMAC-based Extract-and-Expand Key Derivation Function)** 算法。HKDF 是一种标准的密钥派生函数，常用于从共享密钥材料（例如，通过 Diffie-Hellman 密钥交换获得的共享秘密）派生出一个或多个适合特定用途的密钥。

**Go 代码举例说明**:

以下代码演示了如何使用 `crypto/hkdf` 包的 `Key` 函数来派生密钥：

```go
package main

import (
	"crypto/hkdf"
	"crypto/sha256"
	"fmt"
	"io"
)

func main() {
	masterKey := []byte("this is a shared secret")
	salt := []byte("this is some salt")
	info := []byte("this is some context")
	keyLength := 32 // 期望的密钥长度

	// 使用 HKDF 的 Key 函数派生密钥
	key, err := hkdf.Key(sha256.New, masterKey, salt, string(info), keyLength)
	if err != nil {
		fmt.Println("密钥派生失败:", err)
		return
	}

	fmt.Printf("派生的密钥: %x\n", key)

	// 或者，先提取 PRK，再扩展
	prk, err := hkdf.Extract(sha256.New, masterKey, salt)
	if err != nil {
		fmt.Println("PRK 提取失败:", err)
		return
	}
	expandedKey, err := hkdf.Expand(sha256.New, prk, string(info), keyLength)
	if err != nil {
		fmt.Println("密钥扩展失败:", err)
		return
	}
	fmt.Printf("扩展的密钥: %x\n", expandedKey)

	// 使用 NewReader 可以按需读取密钥材料
	reader := hkdf.NewReader(sha256.New, masterKey, salt, string(info))
	readKey := make([]byte, keyLength)
	_, err = io.ReadFull(reader, readKey)
	if err != nil {
		fmt.Println("从 Reader 读取密钥失败:", err)
		return
	}
	fmt.Printf("从 Reader 读取的密钥: %x\n", readKey)
}
```

**假设的输入与输出**:

假设我们使用上面的代码，输入如下：

- `masterKey`: `"this is a shared secret"`
- `salt`: `"this is some salt"`
- `info`: `"this is some context"`
- `keyLength`: `32`

输出可能如下（每次运行输出的密钥会不同，因为 HKDF 的目的是产生伪随机输出）：

```
派生的密钥: 3c0b5d98a7e0c4f2b8d6a1e93f5b7d2c1e8a9b4d6f7c3e0a1b2d4f6e8c9a0b1c
扩展的密钥: 3c0b5d98a7e0c4f2b8d6a1e93f5b7d2c1e8a9b4d6f7c3e0a1b2d4f6e8c9a0b1c
从 Reader 读取的密钥: 3c0b5d98a7e0c4f2b8d6a1e93f5b7d2c1e8a9b4d6f7c3e0a1b2d4f6e8c9a0b1c
```

**命令行参数的具体处理**:

这段测试代码本身不涉及命令行参数的处理。它是一个单元测试文件，通常通过 `go test` 命令来运行。`go test` 命令有一些常用的参数，例如 `-v` (显示详细输出)、`-run <正则表达式>` (运行匹配的测试用例) 等，但这与 `hkdf_test.go` 的内部逻辑无关。

**使用者易犯错的点**:

1. **盐值 (Salt) 的使用**:  虽然 HKDF 允许盐值为空，但强烈建议提供一个随机的、与密钥材料无关的盐值。**重复使用相同的主密钥和空盐值会导致相同的 PRK，从而降低安全性。**

   **错误示例:**

   ```go
   key1, _ := hkdf.Key(sha256.New, []byte("mysecret"), nil, "context1", 32)
   key2, _ := hkdf.Key(sha256.New, []byte("mysecret"), nil, "context2", 32)
   // key1 和 key2 可能会有较高的相关性，因为使用了相同的主密钥和空盐值。
   ```

   **正确示例:**

   ```go
   import "crypto/rand"

   func generateRandomSalt(length int) ([]byte, error) {
       salt := make([]byte, length)
       _, err := rand.Read(salt)
       if err != nil {
           return nil, err
       }
       return salt, nil
   }

   func main() {
       masterKey := []byte("mysecret")
       salt1, _ := generateRandomSalt(16)
       salt2, _ := generateRandomSalt(16)

       key1, _ := hkdf.Key(sha256.New, masterKey, salt1, "context1", 32)
       key2, _ := hkdf.Key(sha256.New, masterKey, salt2, "context2", 32)
       // key1 和 key2 具有更好的独立性，因为使用了不同的随机盐值。
   }
   ```

2. **信息 (Info) 的使用**:  信息参数用于区分不同用途的派生密钥。**在不同的上下文中使用相同的 Master Key 和 Salt，但不提供不同的 Info，会导致派生出相同的密钥。**

   **错误示例:**

   ```go
   masterKey := []byte("mysecret")
   salt, _ := generateRandomSalt(16)
   keyForEncryption, _ := hkdf.Key(sha256.New, masterKey, salt, "", 32)
   keyForAuthentication, _ := hkdf.Key(sha256.New, masterKey, salt, "", 32)
   // keyForEncryption 和 keyForAuthentication 将是相同的，不安全。
   ```

   **正确示例:**

   ```go
   masterKey := []byte("mysecret")
   salt, _ := generateRandomSalt(16)
   keyForEncryption, _ := hkdf.Key(sha256.New, masterKey, salt, "encryption", 32)
   keyForAuthentication, _ := hkdf.Key(sha256.New, masterKey, salt, "authentication", 32)
   // keyForEncryption 和 keyForAuthentication 将是不同的，更安全。
   ```

3. **输出长度限制**:  正如 `TestHKDFLimit` 所测试的，尝试派生过长的密钥会导致错误。使用者需要注意 HKDF 的输出长度限制。

总而言之，`go/src/crypto/hkdf/hkdf_test.go` 文件的主要作用是验证 `crypto/hkdf` 包中 HKDF 算法实现的正确性，并通过各种测试用例覆盖不同的场景和边界情况。 通过阅读这个测试文件，我们可以更好地理解 HKDF 算法的工作原理和 `crypto/hkdf` 包的使用方法。

Prompt: 
```
这是路径为go/src/crypto/hkdf/hkdf_test.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
请用中文回答。

"""
// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package hkdf

import (
	"bytes"
	"crypto/internal/boring"
	"crypto/internal/fips140"
	"crypto/md5"
	"crypto/sha1"
	"crypto/sha256"
	"crypto/sha512"
	"hash"
	"testing"
)

type hkdfTest struct {
	hash   func() hash.Hash
	master []byte
	salt   []byte
	prk    []byte
	info   []byte
	out    []byte
}

var hkdfTests = []hkdfTest{
	// Tests from RFC 5869
	{
		sha256.New,
		[]byte{
			0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
			0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
			0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
		},
		[]byte{
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			0x08, 0x09, 0x0a, 0x0b, 0x0c,
		},
		[]byte{
			0x07, 0x77, 0x09, 0x36, 0x2c, 0x2e, 0x32, 0xdf,
			0x0d, 0xdc, 0x3f, 0x0d, 0xc4, 0x7b, 0xba, 0x63,
			0x90, 0xb6, 0xc7, 0x3b, 0xb5, 0x0f, 0x9c, 0x31,
			0x22, 0xec, 0x84, 0x4a, 0xd7, 0xc2, 0xb3, 0xe5,
		},
		[]byte{
			0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
			0xf8, 0xf9,
		},
		[]byte{
			0x3c, 0xb2, 0x5f, 0x25, 0xfa, 0xac, 0xd5, 0x7a,
			0x90, 0x43, 0x4f, 0x64, 0xd0, 0x36, 0x2f, 0x2a,
			0x2d, 0x2d, 0x0a, 0x90, 0xcf, 0x1a, 0x5a, 0x4c,
			0x5d, 0xb0, 0x2d, 0x56, 0xec, 0xc4, 0xc5, 0xbf,
			0x34, 0x00, 0x72, 0x08, 0xd5, 0xb8, 0x87, 0x18,
			0x58, 0x65,
		},
	},
	{
		sha256.New,
		[]byte{
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
			0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
			0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
			0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
			0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
			0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
		},
		[]byte{
			0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
			0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
			0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
			0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
			0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
			0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
			0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
			0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
			0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
			0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
		},
		[]byte{
			0x06, 0xa6, 0xb8, 0x8c, 0x58, 0x53, 0x36, 0x1a,
			0x06, 0x10, 0x4c, 0x9c, 0xeb, 0x35, 0xb4, 0x5c,
			0xef, 0x76, 0x00, 0x14, 0x90, 0x46, 0x71, 0x01,
			0x4a, 0x19, 0x3f, 0x40, 0xc1, 0x5f, 0xc2, 0x44,
		},
		[]byte{
			0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
			0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
			0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,
			0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
			0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,
			0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
			0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,
			0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
			0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
			0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,
		},
		[]byte{
			0xb1, 0x1e, 0x39, 0x8d, 0xc8, 0x03, 0x27, 0xa1,
			0xc8, 0xe7, 0xf7, 0x8c, 0x59, 0x6a, 0x49, 0x34,
			0x4f, 0x01, 0x2e, 0xda, 0x2d, 0x4e, 0xfa, 0xd8,
			0xa0, 0x50, 0xcc, 0x4c, 0x19, 0xaf, 0xa9, 0x7c,
			0x59, 0x04, 0x5a, 0x99, 0xca, 0xc7, 0x82, 0x72,
			0x71, 0xcb, 0x41, 0xc6, 0x5e, 0x59, 0x0e, 0x09,
			0xda, 0x32, 0x75, 0x60, 0x0c, 0x2f, 0x09, 0xb8,
			0x36, 0x77, 0x93, 0xa9, 0xac, 0xa3, 0xdb, 0x71,
			0xcc, 0x30, 0xc5, 0x81, 0x79, 0xec, 0x3e, 0x87,
			0xc1, 0x4c, 0x01, 0xd5, 0xc1, 0xf3, 0x43, 0x4f,
			0x1d, 0x87,
		},
	},
	{
		sha256.New,
		[]byte{
			0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
			0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
			0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
		},
		[]byte{},
		[]byte{
			0x19, 0xef, 0x24, 0xa3, 0x2c, 0x71, 0x7b, 0x16,
			0x7f, 0x33, 0xa9, 0x1d, 0x6f, 0x64, 0x8b, 0xdf,
			0x96, 0x59, 0x67, 0x76, 0xaf, 0xdb, 0x63, 0x77,
			0xac, 0x43, 0x4c, 0x1c, 0x29, 0x3c, 0xcb, 0x04,
		},
		[]byte{},
		[]byte{
			0x8d, 0xa4, 0xe7, 0x75, 0xa5, 0x63, 0xc1, 0x8f,
			0x71, 0x5f, 0x80, 0x2a, 0x06, 0x3c, 0x5a, 0x31,
			0xb8, 0xa1, 0x1f, 0x5c, 0x5e, 0xe1, 0x87, 0x9e,
			0xc3, 0x45, 0x4e, 0x5f, 0x3c, 0x73, 0x8d, 0x2d,
			0x9d, 0x20, 0x13, 0x95, 0xfa, 0xa4, 0xb6, 0x1a,
			0x96, 0xc8,
		},
	},
	{
		sha256.New,
		[]byte{
			0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
			0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
			0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
		},
		nil,
		[]byte{
			0x19, 0xef, 0x24, 0xa3, 0x2c, 0x71, 0x7b, 0x16,
			0x7f, 0x33, 0xa9, 0x1d, 0x6f, 0x64, 0x8b, 0xdf,
			0x96, 0x59, 0x67, 0x76, 0xaf, 0xdb, 0x63, 0x77,
			0xac, 0x43, 0x4c, 0x1c, 0x29, 0x3c, 0xcb, 0x04,
		},
		nil,
		[]byte{
			0x8d, 0xa4, 0xe7, 0x75, 0xa5, 0x63, 0xc1, 0x8f,
			0x71, 0x5f, 0x80, 0x2a, 0x06, 0x3c, 0x5a, 0x31,
			0xb8, 0xa1, 0x1f, 0x5c, 0x5e, 0xe1, 0x87, 0x9e,
			0xc3, 0x45, 0x4e, 0x5f, 0x3c, 0x73, 0x8d, 0x2d,
			0x9d, 0x20, 0x13, 0x95, 0xfa, 0xa4, 0xb6, 0x1a,
			0x96, 0xc8,
		},
	},
	{
		sha1.New,
		[]byte{
			0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
			0x0b, 0x0b, 0x0b,
		},
		[]byte{
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			0x08, 0x09, 0x0a, 0x0b, 0x0c,
		},
		[]byte{
			0x9b, 0x6c, 0x18, 0xc4, 0x32, 0xa7, 0xbf, 0x8f,
			0x0e, 0x71, 0xc8, 0xeb, 0x88, 0xf4, 0xb3, 0x0b,
			0xaa, 0x2b, 0xa2, 0x43,
		},
		[]byte{
			0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
			0xf8, 0xf9,
		},
		[]byte{
			0x08, 0x5a, 0x01, 0xea, 0x1b, 0x10, 0xf3, 0x69,
			0x33, 0x06, 0x8b, 0x56, 0xef, 0xa5, 0xad, 0x81,
			0xa4, 0xf1, 0x4b, 0x82, 0x2f, 0x5b, 0x09, 0x15,
			0x68, 0xa9, 0xcd, 0xd4, 0xf1, 0x55, 0xfd, 0xa2,
			0xc2, 0x2e, 0x42, 0x24, 0x78, 0xd3, 0x05, 0xf3,
			0xf8, 0x96,
		},
	},
	{
		sha1.New,
		[]byte{
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
			0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
			0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
			0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
			0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
			0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
		},
		[]byte{
			0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
			0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
			0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
			0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
			0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
			0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
			0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
			0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
			0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
			0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
		},
		[]byte{
			0x8a, 0xda, 0xe0, 0x9a, 0x2a, 0x30, 0x70, 0x59,
			0x47, 0x8d, 0x30, 0x9b, 0x26, 0xc4, 0x11, 0x5a,
			0x22, 0x4c, 0xfa, 0xf6,
		},
		[]byte{
			0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
			0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
			0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,
			0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
			0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,
			0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
			0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,
			0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
			0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
			0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,
		},
		[]byte{
			0x0b, 0xd7, 0x70, 0xa7, 0x4d, 0x11, 0x60, 0xf7,
			0xc9, 0xf1, 0x2c, 0xd5, 0x91, 0x2a, 0x06, 0xeb,
			0xff, 0x6a, 0xdc, 0xae, 0x89, 0x9d, 0x92, 0x19,
			0x1f, 0xe4, 0x30, 0x56, 0x73, 0xba, 0x2f, 0xfe,
			0x8f, 0xa3, 0xf1, 0xa4, 0xe5, 0xad, 0x79, 0xf3,
			0xf3, 0x34, 0xb3, 0xb2, 0x02, 0xb2, 0x17, 0x3c,
			0x48, 0x6e, 0xa3, 0x7c, 0xe3, 0xd3, 0x97, 0xed,
			0x03, 0x4c, 0x7f, 0x9d, 0xfe, 0xb1, 0x5c, 0x5e,
			0x92, 0x73, 0x36, 0xd0, 0x44, 0x1f, 0x4c, 0x43,
			0x00, 0xe2, 0xcf, 0xf0, 0xd0, 0x90, 0x0b, 0x52,
			0xd3, 0xb4,
		},
	},
	{
		sha1.New,
		[]byte{
			0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
			0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
			0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
		},
		[]byte{},
		[]byte{
			0xda, 0x8c, 0x8a, 0x73, 0xc7, 0xfa, 0x77, 0x28,
			0x8e, 0xc6, 0xf5, 0xe7, 0xc2, 0x97, 0x78, 0x6a,
			0xa0, 0xd3, 0x2d, 0x01,
		},
		[]byte{},
		[]byte{
			0x0a, 0xc1, 0xaf, 0x70, 0x02, 0xb3, 0xd7, 0x61,
			0xd1, 0xe5, 0x52, 0x98, 0xda, 0x9d, 0x05, 0x06,
			0xb9, 0xae, 0x52, 0x05, 0x72, 0x20, 0xa3, 0x06,
			0xe0, 0x7b, 0x6b, 0x87, 0xe8, 0xdf, 0x21, 0xd0,
			0xea, 0x00, 0x03, 0x3d, 0xe0, 0x39, 0x84, 0xd3,
			0x49, 0x18,
		},
	},
	{
		sha1.New,
		[]byte{
			0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
			0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
			0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
		},
		nil,
		[]byte{
			0x2a, 0xdc, 0xca, 0xda, 0x18, 0x77, 0x9e, 0x7c,
			0x20, 0x77, 0xad, 0x2e, 0xb1, 0x9d, 0x3f, 0x3e,
			0x73, 0x13, 0x85, 0xdd,
		},
		nil,
		[]byte{
			0x2c, 0x91, 0x11, 0x72, 0x04, 0xd7, 0x45, 0xf3,
			0x50, 0x0d, 0x63, 0x6a, 0x62, 0xf6, 0x4f, 0x0a,
			0xb3, 0xba, 0xe5, 0x48, 0xaa, 0x53, 0xd4, 0x23,
			0xb0, 0xd1, 0xf2, 0x7e, 0xbb, 0xa6, 0xf5, 0xe5,
			0x67, 0x3a, 0x08, 0x1d, 0x70, 0xcc, 0xe7, 0xac,
			0xfc, 0x48,
		},
	},
}

func TestHKDF(t *testing.T) {
	for i, tt := range hkdfTests {
		prk, err := Extract(tt.hash, tt.master, tt.salt)
		if err != nil {
			t.Errorf("test %d: PRK extraction failed: %v", i, err)
		}
		if !bytes.Equal(prk, tt.prk) {
			t.Errorf("test %d: incorrect PRK: have %v, need %v.", i, prk, tt.prk)
		}

		key, err := Key(tt.hash, tt.master, tt.salt, string(tt.info), len(tt.out))
		if err != nil {
			t.Errorf("test %d: key derivation failed: %v", i, err)
		}

		if !bytes.Equal(key, tt.out) {
			t.Errorf("test %d: incorrect output: have %v, need %v.", i, key, tt.out)
		}

		expanded, err := Expand(tt.hash, prk, string(tt.info), len(tt.out))
		if err != nil {
			t.Errorf("test %d: key expansion failed: %v", i, err)
		}

		if !bytes.Equal(expanded, tt.out) {
			t.Errorf("test %d: incorrect output from Expand: have %v, need %v.", i, expanded, tt.out)
		}
	}
}

func TestHKDFLimit(t *testing.T) {
	hash := sha1.New
	master := []byte{0x00, 0x01, 0x02, 0x03}
	info := ""
	limit := hash().Size() * 255

	// The maximum output bytes should be extractable
	out, err := Key(hash, master, nil, info, limit)
	if err != nil || len(out) != limit {
		t.Errorf("key derivation failed: %v", err)
	}

	// Reading one more should return an error
	_, err = Key(hash, master, nil, info, limit+1)
	if err == nil {
		t.Error("expected key derivation to fail, but it succeeded")
	}
}

func Benchmark16ByteMD5Single(b *testing.B) {
	benchmarkHKDF(md5.New, 16, b)
}

func Benchmark20ByteSHA1Single(b *testing.B) {
	benchmarkHKDF(sha1.New, 20, b)
}

func Benchmark32ByteSHA256Single(b *testing.B) {
	benchmarkHKDF(sha256.New, 32, b)
}

func Benchmark64ByteSHA512Single(b *testing.B) {
	benchmarkHKDF(sha512.New, 64, b)
}

func benchmarkHKDF(hasher func() hash.Hash, block int, b *testing.B) {
	master := []byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07}
	salt := []byte{0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17}
	info := string([]byte{0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27})

	b.SetBytes(int64(block))
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		_, err := Key(hasher, master, salt, info, hasher().Size())
		if err != nil {
			b.Errorf("failed to derive key: %v", err)
		}
	}
}

func TestFIPSServiceIndicator(t *testing.T) {
	if boring.Enabled {
		t.Skip("in BoringCrypto mode HMAC is not from the Go FIPS module")
	}

	fips140.ResetServiceIndicator()
	_, err := Key(sha256.New, []byte("YELLOW SUBMARINE"), nil, "", 32)
	if err != nil {
		panic(err)
	}
	if !fips140.ServiceIndicator() {
		t.Error("FIPS service indicator should be set")
	}

	// Key too short.
	fips140.ResetServiceIndicator()
	_, err = Key(sha256.New, []byte("key"), nil, "", 32)
	if err != nil {
		panic(err)
	}
	if fips140.ServiceIndicator() {
		t.Error("FIPS service indicator should not be set")
	}

	// Salt and info are short, which is ok, but translates to a short HMAC key.
	fips140.ResetServiceIndicator()
	_, err = Key(sha256.New, []byte("YELLOW SUBMARINE"), []byte("salt"), "info", 32)
	if !fips140.ServiceIndicator() {
		t.Error("FIPS service indicator should be set")
	}
}

"""



```
Response:
Let's break down the thought process for analyzing this Go code snippet.

**1. Initial Understanding - What is it?**

The first lines are crucial: `// Code generated by generate.go. DO NOT EDIT.` and the package name `nistec`. This immediately tells me:

* **Auto-generated code:**  This isn't code a human likely wrote directly. It's probably the output of a tool. This implies a focus on performance and strict adherence to a specification.
* **`nistec` package:**  This suggests something related to NIST elliptic curves. The filename `p384.go` confirms it's specifically for the P-384 curve.
* **`crypto/internal/fips140`:** This is a big clue. It means this code is part of Go's FIPS 140-2 validated cryptographic library. FIPS compliance brings very specific requirements for correctness and security.

**2. Identifying Key Data Structures and Types:**

The `P384Point` struct is central. It represents a point on the elliptic curve. The fields `x`, `y`, and `z` being of type `*fiat.P384Element` indicates a projective coordinate representation. This is often used in elliptic curve cryptography for efficiency in certain operations.

**3. Analyzing the Functions - Functionality and Purpose:**

I go through each function, trying to understand its role:

* **`p384ElementLength`:**  A constant defining the byte length of field elements. This is expected for fixed-size elliptic curves.
* **`P384Point` struct:**  As mentioned, the core data structure. The comment clarifies the projective coordinates.
* **`NewP384Point()`:**  Creates the point at infinity. This is a standard concept in elliptic curve groups.
* **`SetGenerator()`:** Sets the point to the standard generator point of the P-384 curve. The hardcoded byte arrays are the coordinates of this generator.
* **`Set()`:**  A simple copy operation between two `P384Point`s.
* **`SetBytes()`:**  This is important. It handles decoding a byte slice into a `P384Point`. The different cases (infinity, uncompressed, compressed) correspond to standard elliptic curve point encodings. The "SEC 1, Version 2.0, Section 2.3.4" comment is a direct reference to the relevant standard. The checks for point validity (`p384CheckOnCurve`) are essential for security.
* **`_p384B` and `p384B()`:**  This looks like a way to lazily initialize the constant 'b' used in the P-384 curve equation. The `sync.Once` ensures it's only computed once.
* **`p384Polynomial()`:**  Calculates the right-hand side of the elliptic curve equation (y² = x³ - 3x + b).
* **`p384CheckOnCurve()`:** Verifies if a given (x, y) pair lies on the P-384 curve.
* **`Bytes()`:**  Encodes the point into its uncompressed representation. The "SEC 1, Version 2.0, Section 2.3.3" comment is important.
* **`BytesX()`:** Returns the x-coordinate as a byte slice.
* **`BytesCompressed()`:** Encodes the point in its compressed representation.
* **`Add()`:** Implements point addition. The comment referencing the "Complete addition formulas" paper is a strong indicator of optimized, potentially constant-time implementation.
* **`Double()`:** Implements point doubling. Similar to `Add`, the reference to the paper suggests careful implementation.
* **`Select()`:**  A constant-time conditional selection between two points. This is crucial for security in cryptographic operations to prevent timing attacks.
* **`p384Table` and its `Select()`:**  This is a precomputed table of point multiples for efficient scalar multiplication. The constant-time selection within the table is also important.
* **`ScalarMult()`:** Implements scalar multiplication (multiplying a point by an integer scalar). The use of the `p384Table` is a standard optimization.
* **`generatorTable()`:**  Precomputes tables for scalar multiplication with the generator point. This is a further optimization for the common case of scalar base multiplication.
* **`ScalarBaseMult()`:**  Implements scalar multiplication with the generator point, utilizing the precomputed `generatorTable`.
* **`p384Sqrt()` and `p384SqrtCandidate()`:**  Implement the square root operation in the finite field, which is needed for decoding compressed points. The comments explain the specific algorithm used (based on the fact that p = 3 mod 4).

**4. Identifying Go Language Features and Examples:**

As I understand the functions, I can connect them to general Go concepts and create illustrative examples:

* **Structs and Methods:** The `P384Point` struct and its associated methods are classic Go.
* **Constants:** `p384ElementLength`.
* **Byte Slices:** Used for representing coordinates and encoded points.
* **Error Handling:**  The `error` return values in functions like `SetBytes`, `BytesX`, `ScalarMult`, and `ScalarBaseMult`.
* **Lazy Initialization (`sync.Once`):**  Used for `_p384B` and `p384GeneratorTable`.
* **Constant-Time Operations:**  The comments and implementation of `Select` and the table lookups hint at this.
* **Code Generation:**  The initial comment indicates this.
* **Internal Packages:** The `crypto/internal/...` path signifies that this is not part of the public API.

**5. Code Reasoning and Examples with Input/Output:**

For functions like `SetBytes`, `Bytes`, `BytesCompressed`, `Add`, `Double`, `ScalarMult`, and `ScalarBaseMult`, I can create simple examples by either:

* **Referring to standard values:**  The generator point is defined, so I can use its compressed or uncompressed representation as input to `SetBytes`.
* **Making up simple cases:**  Adding the point at infinity to another point, doubling the point at infinity.
* **Hypothesizing inputs and tracing the logic:** For example, if I provide a valid compressed point to `SetBytes`, I expect a `P384Point` to be returned.

**6. Command-Line Arguments and Potential Mistakes:**

Since the code is part of a library, it doesn't directly handle command-line arguments. The focus is on the API. For common mistakes, I think about how a *user* of this library might misuse it:

* **Incorrect byte array lengths for `SetBytes`:**  Providing a byte slice that doesn't match the expected compressed or uncompressed length.
* **Providing invalid compressed points to `SetBytes`:**  Bytes that don't correspond to a point on the curve.
* **Assuming the zero value of `P384Point` is valid:** The comment explicitly states it's not.

**7. Structuring the Answer:**

Finally, I organize the information into the requested sections:

* **功能列举:** A concise list of the functions and their purposes.
* **Go 语言功能实现推理和代码举例:** Demonstrating the use of the key functions with concrete Go code, including example inputs and expected outputs.
* **代码推理 (with input/output):**  Providing more detailed examples and tracing the execution flow.
* **命令行参数处理:**  Explaining that this is a library and doesn't directly handle command-line arguments.
* **使用者易犯错的点:**  Listing potential pitfalls for developers using this code.

This systematic approach allows me to thoroughly analyze the code snippet and provide a comprehensive answer that addresses all aspects of the prompt.
这个go语言文件 `go/src/crypto/internal/fips140/nistec/p384.go` 是 Go 语言密码学库中，专门用于实现 **NIST P-384 椭圆曲线** 相关功能的代码。由于它位于 `crypto/internal/fips140` 路径下，可以推断出这个实现是为了满足 **FIPS 140-2** 标准的要求。

以下是该文件包含的主要功能：

1. **定义 P-384 曲线的点的表示：**
   - 定义了 `P384Point` 结构体，用于表示 P-384 曲线上的点。它使用射影坐标 (X:Y:Z) 来提高某些运算的效率。
   - `x`, `y`, `z` 字段都是 `*fiat.P384Element` 类型，这表明底层使用了 `fiat` 包提供的针对 P-384 曲线素域元素的优化实现。

2. **创建和设置 P-384 曲线上的点：**
   - `NewP384Point()`: 创建并返回一个表示无穷远点的 `P384Point`。
   - `SetGenerator()`: 将 `P384Point` 设置为 P-384 曲线的规范生成元。生成元的坐标是硬编码在代码中的。
   - `Set(q *P384Point)`: 将一个 `P384Point` 的值复制给另一个。
   - `SetBytes(b []byte)`:  根据 SEC 1 标准，将字节切片 `b` 解码为 `P384Point`。它支持解码无穷远点、未压缩格式和压缩格式的点。如果字节切片表示的点不在曲线之上，则返回错误。

3. **P-384 曲线的常数：**
   - `p384ElementLength`: 定义了底域和标量域元素的字节长度 (48 字节)。
   - `p384B()`:  返回 P-384 曲线方程 `y² = x³ - 3x + b` 中的常数 `b`。使用了 `sync.Once` 来保证只初始化一次。

4. **P-384 曲线上的运算：**
   - `p384Polynomial(y2, x *fiat.P384Element)`: 计算 P-384 曲线方程的右侧 `x³ - 3x + b`。
   - `p384CheckOnCurve(x, y *fiat.P384Element)`: 检查给定的 (x, y) 坐标是否在 P-384 曲线之上。
   - `Bytes()`: 将 `P384Point` 编码为未压缩格式的字节切片。
   - `BytesX()`: 返回 `P384Point` 的 x 坐标的字节切片。
   - `BytesCompressed()`: 将 `P384Point` 编码为压缩格式的字节切片。
   - `Add(p1, p2 *P384Point)`: 计算两个 `P384Point` 的和，并存储到接收者 `q` 中。使用了完整的加法公式，即使当两个点相同时也能正确计算。
   - `Double(p *P384Point)`: 计算 `P384Point` 的两倍，并存储到接收者 `q` 中。使用了完整的倍点公式。
   - `Select(p1, p2 *P384Point, cond int)`:  根据条件 `cond` 选择 `p1` 或 `p2` 赋值给 `q`。这是一个常量时间操作，用于防止侧信道攻击。
   - `ScalarMult(q *P384Point, scalar []byte)`: 计算标量乘法 `scalar * q`，并将结果存储到接收者 `p` 中。它使用滑动窗口算法进行优化。
   - `ScalarBaseMult(scalar []byte)`: 计算标量与基点（生成元）的乘法 `scalar * B`，并将结果存储到接收者 `p` 中。它使用了预计算的表格来加速运算。

5. **标量乘法加速的辅助结构：**
   - `p384Table`: 定义了一个存储基点多个倍点的表格，用于加速标量乘法。
   - `Select(p *P384Point, n uint8)` (在 `p384Table` 上):  常量时间地从表格中选择基点的 `n` 倍点。
   - `generatorTable()`: 返回一个预计算的生成元倍点表格，用于 `ScalarBaseMult`。使用了 `sync.Once` 来保证只初始化一次。

6. **平方根运算：**
   - `p384Sqrt(e, x *fiat.P384Element)`: 计算有限域元素的平方根。如果 `x` 不是平方剩余，则返回 `false`。
   - `p384SqrtCandidate(z, x *fiat.P384Element)`: 计算平方根的候选值。

**推理：这是一个 NIST P-384 椭圆曲线的实现，用于椭圆曲线密码学（ECC）运算。** 它提供了创建点、点加、倍点、标量乘法等核心操作，并且考虑了安全性和性能，例如使用射影坐标、常量时间操作以及预计算表格。 这个实现很可能被用于实现数字签名算法（如 ECDSA）或密钥交换协议（如 ECDH）中，涉及到 P-384 曲线的部分。

**Go 代码举例说明：**

```go
package main

import (
	"crypto/internal/fips140/nistec"
	"fmt"
)

func main() {
	// 创建一个新的 P384Point（无穷远点）
	p := nistec.NewP384Point()
	fmt.Println("Initial Point (Infinity):", p.Bytes())

	// 设置为生成元
	g := nistec.NewP384Point()
	g.SetGenerator()
	fmt.Println("Generator Point:", g.Bytes())

	// 从字节解码一个未压缩的点
	uncompressedBytes := g.Bytes()
	p1 := nistec.NewP384Point()
	p1.SetBytes(uncompressedBytes)
	fmt.Println("Point from Uncompressed Bytes:", p1.Bytes())

	// 从字节解码一个压缩的点
	compressedBytes := g.BytesCompressed()
	p2 := nistec.NewP384Point()
	p2.SetBytes(compressedBytes)
	fmt.Println("Point from Compressed Bytes:", p2.Bytes())

	// 点加
	sum := nistec.NewP384Point()
	sum.Add(p1, p2)
	fmt.Println("Sum of points:", sum.Bytes())

	// 标量乘法 (例如计算 2 * G)
	scalar := []byte{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // 标量为 2
	}
	scaledG := nistec.NewP384Point()
	scaledG.ScalarBaseMult(scalar)
	fmt.Println("2 * Generator:", scaledG.Bytes())
}
```

**假设的输入与输出：**

上述代码中，输入主要是对 `SetBytes` 函数提供的字节切片。

- **输入 (uncompressedBytes):**  生成元 `g` 的未压缩字节表示，例如：
  ```
  [4 170 135 202 34 190 139 5 55 142 177 199 30 243 32 173 116 110 29 59 98 139 167 155 152 89 247 65 224 130 84 42 56 85 2 242 93 191 85 41 108 58 84 94 56 114 118 10 183 54 23 214 74 150 38 44 111 93 152 152 220 41 248 244 29 189 40 154 20 124 233 218 49 19 181 240 184 192 10 96 177 206 29 126 129 157 122 67 29 124 144 234 14 95]
  ```
- **输出 (p1.Bytes()):** 应该与 `uncompressedBytes` 相同。
- **输入 (compressedBytes):** 生成元 `g` 的压缩字节表示，例如：
  ```
  [3 170 135 202 34 190 139 5 55 142 177 199 30 243 32 173 116 110 29 59 98 139 167 155 152 89 247 65 224 130 84 42 56]
  ```
- **输出 (p2.Bytes()):** 应该解码为与生成元相同的未压缩表示。
- **输入 (scalar):**  表示标量 2 的字节切片。
- **输出 (scaledG.Bytes()):** 应该是生成元的两倍点的未压缩表示。

**命令行参数的具体处理：**

这个代码文件本身是库的一部分，并不直接处理命令行参数。 如果要使用这个库实现一个命令行工具，需要在调用这个库的代码中处理命令行参数。 例如，可以使用 `flag` 包来解析命令行参数，然后将参数传递给 `nistec` 包中的函数。

**使用者易犯错的点：**

1. **误用零值 `P384Point`：** `P384Point` 的零值不是一个有效的点。必须使用 `NewP384Point()` 创建点，或者使用 `Set...` 方法初始化。

   ```go
   // 错误示例
   var p nistec.P384Point
   // p 是零值，不能直接使用其方法，例如 p.Add(...) 会导致错误。

   // 正确示例
   p := nistec.NewP384Point()
   ```

2. **`SetBytes` 的输入字节切片格式错误：** `SetBytes` 期望特定的字节切片格式（无穷远点、压缩或未压缩）。如果提供了错误的格式或长度，会返回错误。

   ```go
   // 错误示例：错误的字节长度
   invalidBytes := []byte{0x01, 0x02, 0x03}
   point := nistec.NewP384Point()
   _, err := point.SetBytes(invalidBytes)
   if err != nil {
       fmt.Println("Error setting bytes:", err) // 会输出 "invalid P384 point encoding"
   }

   // 错误示例：无效的压缩点前缀
   invalidCompressed := []byte{0x01, /* 错误的压缩前缀 */ 0xaa, 0xbb, /* ... 46 more bytes */}
   point2 := nistec.NewP384Point()
   _, err = point2.SetBytes(invalidCompressed)
   if err != nil {
       fmt.Println("Error setting compressed bytes:", err) // 也可能输出 "invalid P384 point encoding"
   }
   ```

3. **忘记检查 `SetBytes` 的错误：** `SetBytes` 在解析失败时会返回错误，使用者需要检查并处理这些错误。

   ```go
   point := nistec.NewP384Point()
   _, err := point.SetBytes(someBytes)
   if err != nil {
       // 必须处理错误，例如记录日志或返回给调用者
       fmt.Errorf("failed to decode point: %w", err)
       return
   }
   // 只有 err 为 nil 时，point 才是有效的
   ```

4. **标量乘法时标量字节切片的长度错误：** `ScalarMult` 和 `ScalarBaseMult` 期望标量是特定长度的字节切片（对于 P-384 是 48 字节）。如果长度不正确，`ScalarBaseMult` 会直接返回错误。

   ```go
   // 错误示例：标量长度错误
   shortScalar := []byte{0x01, 0x02, 0x03}
   g := nistec.NewP384Point().SetGenerator()
   result := nistec.NewP384Point()
   _, err := result.ScalarBaseMult(shortScalar)
   if err != nil {
       fmt.Println("ScalarBaseMult error:", err) // 会输出 "invalid scalar length"
   }
   ```

理解这些潜在的错误点可以帮助使用者更安全、更正确地使用 `crypto/internal/fips140/nistec/p384.go` 提供的功能。

Prompt: 
```
这是路径为go/src/crypto/internal/fips140/nistec/p384.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
请用中文回答。

"""
// Copyright 2022 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Code generated by generate.go. DO NOT EDIT.

package nistec

import (
	"crypto/internal/fips140/nistec/fiat"
	"crypto/internal/fips140/subtle"
	"errors"
	"sync"
)

// p384ElementLength is the length of an element of the base or scalar field,
// which have the same bytes length for all NIST P curves.
const p384ElementLength = 48

// P384Point is a P384 point. The zero value is NOT valid.
type P384Point struct {
	// The point is represented in projective coordinates (X:Y:Z),
	// where x = X/Z and y = Y/Z.
	x, y, z *fiat.P384Element
}

// NewP384Point returns a new P384Point representing the point at infinity point.
func NewP384Point() *P384Point {
	return &P384Point{
		x: new(fiat.P384Element),
		y: new(fiat.P384Element).One(),
		z: new(fiat.P384Element),
	}
}

// SetGenerator sets p to the canonical generator and returns p.
func (p *P384Point) SetGenerator() *P384Point {
	p.x.SetBytes([]byte{0xaa, 0x87, 0xca, 0x22, 0xbe, 0x8b, 0x5, 0x37, 0x8e, 0xb1, 0xc7, 0x1e, 0xf3, 0x20, 0xad, 0x74, 0x6e, 0x1d, 0x3b, 0x62, 0x8b, 0xa7, 0x9b, 0x98, 0x59, 0xf7, 0x41, 0xe0, 0x82, 0x54, 0x2a, 0x38, 0x55, 0x2, 0xf2, 0x5d, 0xbf, 0x55, 0x29, 0x6c, 0x3a, 0x54, 0x5e, 0x38, 0x72, 0x76, 0xa, 0xb7})
	p.y.SetBytes([]byte{0x36, 0x17, 0xde, 0x4a, 0x96, 0x26, 0x2c, 0x6f, 0x5d, 0x9e, 0x98, 0xbf, 0x92, 0x92, 0xdc, 0x29, 0xf8, 0xf4, 0x1d, 0xbd, 0x28, 0x9a, 0x14, 0x7c, 0xe9, 0xda, 0x31, 0x13, 0xb5, 0xf0, 0xb8, 0xc0, 0xa, 0x60, 0xb1, 0xce, 0x1d, 0x7e, 0x81, 0x9d, 0x7a, 0x43, 0x1d, 0x7c, 0x90, 0xea, 0xe, 0x5f})
	p.z.One()
	return p
}

// Set sets p = q and returns p.
func (p *P384Point) Set(q *P384Point) *P384Point {
	p.x.Set(q.x)
	p.y.Set(q.y)
	p.z.Set(q.z)
	return p
}

// SetBytes sets p to the compressed, uncompressed, or infinity value encoded in
// b, as specified in SEC 1, Version 2.0, Section 2.3.4. If the point is not on
// the curve, it returns nil and an error, and the receiver is unchanged.
// Otherwise, it returns p.
func (p *P384Point) SetBytes(b []byte) (*P384Point, error) {
	switch {
	// Point at infinity.
	case len(b) == 1 && b[0] == 0:
		return p.Set(NewP384Point()), nil

	// Uncompressed form.
	case len(b) == 1+2*p384ElementLength && b[0] == 4:
		x, err := new(fiat.P384Element).SetBytes(b[1 : 1+p384ElementLength])
		if err != nil {
			return nil, err
		}
		y, err := new(fiat.P384Element).SetBytes(b[1+p384ElementLength:])
		if err != nil {
			return nil, err
		}
		if err := p384CheckOnCurve(x, y); err != nil {
			return nil, err
		}
		p.x.Set(x)
		p.y.Set(y)
		p.z.One()
		return p, nil

	// Compressed form.
	case len(b) == 1+p384ElementLength && (b[0] == 2 || b[0] == 3):
		x, err := new(fiat.P384Element).SetBytes(b[1:])
		if err != nil {
			return nil, err
		}

		// y² = x³ - 3x + b
		y := p384Polynomial(new(fiat.P384Element), x)
		if !p384Sqrt(y, y) {
			return nil, errors.New("invalid P384 compressed point encoding")
		}

		// Select the positive or negative root, as indicated by the least
		// significant bit, based on the encoding type byte.
		otherRoot := new(fiat.P384Element)
		otherRoot.Sub(otherRoot, y)
		cond := y.Bytes()[p384ElementLength-1]&1 ^ b[0]&1
		y.Select(otherRoot, y, int(cond))

		p.x.Set(x)
		p.y.Set(y)
		p.z.One()
		return p, nil

	default:
		return nil, errors.New("invalid P384 point encoding")
	}
}

var _p384B *fiat.P384Element
var _p384BOnce sync.Once

func p384B() *fiat.P384Element {
	_p384BOnce.Do(func() {
		_p384B, _ = new(fiat.P384Element).SetBytes([]byte{0xb3, 0x31, 0x2f, 0xa7, 0xe2, 0x3e, 0xe7, 0xe4, 0x98, 0x8e, 0x5, 0x6b, 0xe3, 0xf8, 0x2d, 0x19, 0x18, 0x1d, 0x9c, 0x6e, 0xfe, 0x81, 0x41, 0x12, 0x3, 0x14, 0x8, 0x8f, 0x50, 0x13, 0x87, 0x5a, 0xc6, 0x56, 0x39, 0x8d, 0x8a, 0x2e, 0xd1, 0x9d, 0x2a, 0x85, 0xc8, 0xed, 0xd3, 0xec, 0x2a, 0xef})
	})
	return _p384B
}

// p384Polynomial sets y2 to x³ - 3x + b, and returns y2.
func p384Polynomial(y2, x *fiat.P384Element) *fiat.P384Element {
	y2.Square(x)
	y2.Mul(y2, x)

	threeX := new(fiat.P384Element).Add(x, x)
	threeX.Add(threeX, x)
	y2.Sub(y2, threeX)

	return y2.Add(y2, p384B())
}

func p384CheckOnCurve(x, y *fiat.P384Element) error {
	// y² = x³ - 3x + b
	rhs := p384Polynomial(new(fiat.P384Element), x)
	lhs := new(fiat.P384Element).Square(y)
	if rhs.Equal(lhs) != 1 {
		return errors.New("P384 point not on curve")
	}
	return nil
}

// Bytes returns the uncompressed or infinity encoding of p, as specified in
// SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the point at
// infinity is shorter than all other encodings.
func (p *P384Point) Bytes() []byte {
	// This function is outlined to make the allocations inline in the caller
	// rather than happen on the heap.
	var out [1 + 2*p384ElementLength]byte
	return p.bytes(&out)
}

func (p *P384Point) bytes(out *[1 + 2*p384ElementLength]byte) []byte {
	if p.z.IsZero() == 1 {
		return append(out[:0], 0)
	}

	zinv := new(fiat.P384Element).Invert(p.z)
	x := new(fiat.P384Element).Mul(p.x, zinv)
	y := new(fiat.P384Element).Mul(p.y, zinv)

	buf := append(out[:0], 4)
	buf = append(buf, x.Bytes()...)
	buf = append(buf, y.Bytes()...)
	return buf
}

// BytesX returns the encoding of the x-coordinate of p, as specified in SEC 1,
// Version 2.0, Section 2.3.5, or an error if p is the point at infinity.
func (p *P384Point) BytesX() ([]byte, error) {
	// This function is outlined to make the allocations inline in the caller
	// rather than happen on the heap.
	var out [p384ElementLength]byte
	return p.bytesX(&out)
}

func (p *P384Point) bytesX(out *[p384ElementLength]byte) ([]byte, error) {
	if p.z.IsZero() == 1 {
		return nil, errors.New("P384 point is the point at infinity")
	}

	zinv := new(fiat.P384Element).Invert(p.z)
	x := new(fiat.P384Element).Mul(p.x, zinv)

	return append(out[:0], x.Bytes()...), nil
}

// BytesCompressed returns the compressed or infinity encoding of p, as
// specified in SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the
// point at infinity is shorter than all other encodings.
func (p *P384Point) BytesCompressed() []byte {
	// This function is outlined to make the allocations inline in the caller
	// rather than happen on the heap.
	var out [1 + p384ElementLength]byte
	return p.bytesCompressed(&out)
}

func (p *P384Point) bytesCompressed(out *[1 + p384ElementLength]byte) []byte {
	if p.z.IsZero() == 1 {
		return append(out[:0], 0)
	}

	zinv := new(fiat.P384Element).Invert(p.z)
	x := new(fiat.P384Element).Mul(p.x, zinv)
	y := new(fiat.P384Element).Mul(p.y, zinv)

	// Encode the sign of the y coordinate (indicated by the least significant
	// bit) as the encoding type (2 or 3).
	buf := append(out[:0], 2)
	buf[0] |= y.Bytes()[p384ElementLength-1] & 1
	buf = append(buf, x.Bytes()...)
	return buf
}

// Add sets q = p1 + p2, and returns q. The points may overlap.
func (q *P384Point) Add(p1, p2 *P384Point) *P384Point {
	// Complete addition formula for a = -3 from "Complete addition formulas for
	// prime order elliptic curves" (https://eprint.iacr.org/2015/1060), §A.2.

	t0 := new(fiat.P384Element).Mul(p1.x, p2.x)  // t0 := X1 * X2
	t1 := new(fiat.P384Element).Mul(p1.y, p2.y)  // t1 := Y1 * Y2
	t2 := new(fiat.P384Element).Mul(p1.z, p2.z)  // t2 := Z1 * Z2
	t3 := new(fiat.P384Element).Add(p1.x, p1.y)  // t3 := X1 + Y1
	t4 := new(fiat.P384Element).Add(p2.x, p2.y)  // t4 := X2 + Y2
	t3.Mul(t3, t4)                               // t3 := t3 * t4
	t4.Add(t0, t1)                               // t4 := t0 + t1
	t3.Sub(t3, t4)                               // t3 := t3 - t4
	t4.Add(p1.y, p1.z)                           // t4 := Y1 + Z1
	x3 := new(fiat.P384Element).Add(p2.y, p2.z)  // X3 := Y2 + Z2
	t4.Mul(t4, x3)                               // t4 := t4 * X3
	x3.Add(t1, t2)                               // X3 := t1 + t2
	t4.Sub(t4, x3)                               // t4 := t4 - X3
	x3.Add(p1.x, p1.z)                           // X3 := X1 + Z1
	y3 := new(fiat.P384Element).Add(p2.x, p2.z)  // Y3 := X2 + Z2
	x3.Mul(x3, y3)                               // X3 := X3 * Y3
	y3.Add(t0, t2)                               // Y3 := t0 + t2
	y3.Sub(x3, y3)                               // Y3 := X3 - Y3
	z3 := new(fiat.P384Element).Mul(p384B(), t2) // Z3 := b * t2
	x3.Sub(y3, z3)                               // X3 := Y3 - Z3
	z3.Add(x3, x3)                               // Z3 := X3 + X3
	x3.Add(x3, z3)                               // X3 := X3 + Z3
	z3.Sub(t1, x3)                               // Z3 := t1 - X3
	x3.Add(t1, x3)                               // X3 := t1 + X3
	y3.Mul(p384B(), y3)                          // Y3 := b * Y3
	t1.Add(t2, t2)                               // t1 := t2 + t2
	t2.Add(t1, t2)                               // t2 := t1 + t2
	y3.Sub(y3, t2)                               // Y3 := Y3 - t2
	y3.Sub(y3, t0)                               // Y3 := Y3 - t0
	t1.Add(y3, y3)                               // t1 := Y3 + Y3
	y3.Add(t1, y3)                               // Y3 := t1 + Y3
	t1.Add(t0, t0)                               // t1 := t0 + t0
	t0.Add(t1, t0)                               // t0 := t1 + t0
	t0.Sub(t0, t2)                               // t0 := t0 - t2
	t1.Mul(t4, y3)                               // t1 := t4 * Y3
	t2.Mul(t0, y3)                               // t2 := t0 * Y3
	y3.Mul(x3, z3)                               // Y3 := X3 * Z3
	y3.Add(y3, t2)                               // Y3 := Y3 + t2
	x3.Mul(t3, x3)                               // X3 := t3 * X3
	x3.Sub(x3, t1)                               // X3 := X3 - t1
	z3.Mul(t4, z3)                               // Z3 := t4 * Z3
	t1.Mul(t3, t0)                               // t1 := t3 * t0
	z3.Add(z3, t1)                               // Z3 := Z3 + t1

	q.x.Set(x3)
	q.y.Set(y3)
	q.z.Set(z3)
	return q
}

// Double sets q = p + p, and returns q. The points may overlap.
func (q *P384Point) Double(p *P384Point) *P384Point {
	// Complete addition formula for a = -3 from "Complete addition formulas for
	// prime order elliptic curves" (https://eprint.iacr.org/2015/1060), §A.2.

	t0 := new(fiat.P384Element).Square(p.x)      // t0 := X ^ 2
	t1 := new(fiat.P384Element).Square(p.y)      // t1 := Y ^ 2
	t2 := new(fiat.P384Element).Square(p.z)      // t2 := Z ^ 2
	t3 := new(fiat.P384Element).Mul(p.x, p.y)    // t3 := X * Y
	t3.Add(t3, t3)                               // t3 := t3 + t3
	z3 := new(fiat.P384Element).Mul(p.x, p.z)    // Z3 := X * Z
	z3.Add(z3, z3)                               // Z3 := Z3 + Z3
	y3 := new(fiat.P384Element).Mul(p384B(), t2) // Y3 := b * t2
	y3.Sub(y3, z3)                               // Y3 := Y3 - Z3
	x3 := new(fiat.P384Element).Add(y3, y3)      // X3 := Y3 + Y3
	y3.Add(x3, y3)                               // Y3 := X3 + Y3
	x3.Sub(t1, y3)                               // X3 := t1 - Y3
	y3.Add(t1, y3)                               // Y3 := t1 + Y3
	y3.Mul(x3, y3)                               // Y3 := X3 * Y3
	x3.Mul(x3, t3)                               // X3 := X3 * t3
	t3.Add(t2, t2)                               // t3 := t2 + t2
	t2.Add(t2, t3)                               // t2 := t2 + t3
	z3.Mul(p384B(), z3)                          // Z3 := b * Z3
	z3.Sub(z3, t2)                               // Z3 := Z3 - t2
	z3.Sub(z3, t0)                               // Z3 := Z3 - t0
	t3.Add(z3, z3)                               // t3 := Z3 + Z3
	z3.Add(z3, t3)                               // Z3 := Z3 + t3
	t3.Add(t0, t0)                               // t3 := t0 + t0
	t0.Add(t3, t0)                               // t0 := t3 + t0
	t0.Sub(t0, t2)                               // t0 := t0 - t2
	t0.Mul(t0, z3)                               // t0 := t0 * Z3
	y3.Add(y3, t0)                               // Y3 := Y3 + t0
	t0.Mul(p.y, p.z)                             // t0 := Y * Z
	t0.Add(t0, t0)                               // t0 := t0 + t0
	z3.Mul(t0, z3)                               // Z3 := t0 * Z3
	x3.Sub(x3, z3)                               // X3 := X3 - Z3
	z3.Mul(t0, t1)                               // Z3 := t0 * t1
	z3.Add(z3, z3)                               // Z3 := Z3 + Z3
	z3.Add(z3, z3)                               // Z3 := Z3 + Z3

	q.x.Set(x3)
	q.y.Set(y3)
	q.z.Set(z3)
	return q
}

// Select sets q to p1 if cond == 1, and to p2 if cond == 0.
func (q *P384Point) Select(p1, p2 *P384Point, cond int) *P384Point {
	q.x.Select(p1.x, p2.x, cond)
	q.y.Select(p1.y, p2.y, cond)
	q.z.Select(p1.z, p2.z, cond)
	return q
}

// A p384Table holds the first 15 multiples of a point at offset -1, so [1]P
// is at table[0], [15]P is at table[14], and [0]P is implicitly the identity
// point.
type p384Table [15]*P384Point

// Select selects the n-th multiple of the table base point into p. It works in
// constant time by iterating over every entry of the table. n must be in [0, 15].
func (table *p384Table) Select(p *P384Point, n uint8) {
	if n >= 16 {
		panic("nistec: internal error: p384Table called with out-of-bounds value")
	}
	p.Set(NewP384Point())
	for i := uint8(1); i < 16; i++ {
		cond := subtle.ConstantTimeByteEq(i, n)
		p.Select(table[i-1], p, cond)
	}
}

// ScalarMult sets p = scalar * q, and returns p.
func (p *P384Point) ScalarMult(q *P384Point, scalar []byte) (*P384Point, error) {
	// Compute a p384Table for the base point q. The explicit NewP384Point
	// calls get inlined, letting the allocations live on the stack.
	var table = p384Table{NewP384Point(), NewP384Point(), NewP384Point(),
		NewP384Point(), NewP384Point(), NewP384Point(), NewP384Point(),
		NewP384Point(), NewP384Point(), NewP384Point(), NewP384Point(),
		NewP384Point(), NewP384Point(), NewP384Point(), NewP384Point()}
	table[0].Set(q)
	for i := 1; i < 15; i += 2 {
		table[i].Double(table[i/2])
		table[i+1].Add(table[i], q)
	}

	// Instead of doing the classic double-and-add chain, we do it with a
	// four-bit window: we double four times, and then add [0-15]P.
	t := NewP384Point()
	p.Set(NewP384Point())
	for i, byte := range scalar {
		// No need to double on the first iteration, as p is the identity at
		// this point, and [N]∞ = ∞.
		if i != 0 {
			p.Double(p)
			p.Double(p)
			p.Double(p)
			p.Double(p)
		}

		windowValue := byte >> 4
		table.Select(t, windowValue)
		p.Add(p, t)

		p.Double(p)
		p.Double(p)
		p.Double(p)
		p.Double(p)

		windowValue = byte & 0b1111
		table.Select(t, windowValue)
		p.Add(p, t)
	}

	return p, nil
}

var p384GeneratorTable *[p384ElementLength * 2]p384Table
var p384GeneratorTableOnce sync.Once

// generatorTable returns a sequence of p384Tables. The first table contains
// multiples of G. Each successive table is the previous table doubled four
// times.
func (p *P384Point) generatorTable() *[p384ElementLength * 2]p384Table {
	p384GeneratorTableOnce.Do(func() {
		p384GeneratorTable = new([p384ElementLength * 2]p384Table)
		base := NewP384Point().SetGenerator()
		for i := 0; i < p384ElementLength*2; i++ {
			p384GeneratorTable[i][0] = NewP384Point().Set(base)
			for j := 1; j < 15; j++ {
				p384GeneratorTable[i][j] = NewP384Point().Add(p384GeneratorTable[i][j-1], base)
			}
			base.Double(base)
			base.Double(base)
			base.Double(base)
			base.Double(base)
		}
	})
	return p384GeneratorTable
}

// ScalarBaseMult sets p = scalar * B, where B is the canonical generator, and
// returns p.
func (p *P384Point) ScalarBaseMult(scalar []byte) (*P384Point, error) {
	if len(scalar) != p384ElementLength {
		return nil, errors.New("invalid scalar length")
	}
	tables := p.generatorTable()

	// This is also a scalar multiplication with a four-bit window like in
	// ScalarMult, but in this case the doublings are precomputed. The value
	// [windowValue]G added at iteration k would normally get doubled
	// (totIterations-k)×4 times, but with a larger precomputation we can
	// instead add [2^((totIterations-k)×4)][windowValue]G and avoid the
	// doublings between iterations.
	t := NewP384Point()
	p.Set(NewP384Point())
	tableIndex := len(tables) - 1
	for _, byte := range scalar {
		windowValue := byte >> 4
		tables[tableIndex].Select(t, windowValue)
		p.Add(p, t)
		tableIndex--

		windowValue = byte & 0b1111
		tables[tableIndex].Select(t, windowValue)
		p.Add(p, t)
		tableIndex--
	}

	return p, nil
}

// p384Sqrt sets e to a square root of x. If x is not a square, p384Sqrt returns
// false and e is unchanged. e and x can overlap.
func p384Sqrt(e, x *fiat.P384Element) (isSquare bool) {
	candidate := new(fiat.P384Element)
	p384SqrtCandidate(candidate, x)
	square := new(fiat.P384Element).Square(candidate)
	if square.Equal(x) != 1 {
		return false
	}
	e.Set(candidate)
	return true
}

// p384SqrtCandidate sets z to a square root candidate for x. z and x must not overlap.
func p384SqrtCandidate(z, x *fiat.P384Element) {
	// Since p = 3 mod 4, exponentiation by (p + 1) / 4 yields a square root candidate.
	//
	// The sequence of 14 multiplications and 381 squarings is derived from the
	// following addition chain generated with github.com/mmcloughlin/addchain v0.4.0.
	//
	//	_10      = 2*1
	//	_11      = 1 + _10
	//	_110     = 2*_11
	//	_111     = 1 + _110
	//	_111000  = _111 << 3
	//	_111111  = _111 + _111000
	//	_1111110 = 2*_111111
	//	_1111111 = 1 + _1111110
	//	x12      = _1111110 << 5 + _111111
	//	x24      = x12 << 12 + x12
	//	x31      = x24 << 7 + _1111111
	//	x32      = 2*x31 + 1
	//	x63      = x32 << 31 + x31
	//	x126     = x63 << 63 + x63
	//	x252     = x126 << 126 + x126
	//	x255     = x252 << 3 + _111
	//	return     ((x255 << 33 + x32) << 64 + 1) << 30
	//
	var t0 = new(fiat.P384Element)
	var t1 = new(fiat.P384Element)
	var t2 = new(fiat.P384Element)

	z.Square(x)
	z.Mul(x, z)
	z.Square(z)
	t0.Mul(x, z)
	z.Square(t0)
	for s := 1; s < 3; s++ {
		z.Square(z)
	}
	t1.Mul(t0, z)
	t2.Square(t1)
	z.Mul(x, t2)
	for s := 0; s < 5; s++ {
		t2.Square(t2)
	}
	t1.Mul(t1, t2)
	t2.Square(t1)
	for s := 1; s < 12; s++ {
		t2.Square(t2)
	}
	t1.Mul(t1, t2)
	for s := 0; s < 7; s++ {
		t1.Square(t1)
	}
	t1.Mul(z, t1)
	z.Square(t1)
	z.Mul(x, z)
	t2.Square(z)
	for s := 1; s < 31; s++ {
		t2.Square(t2)
	}
	t1.Mul(t1, t2)
	t2.Square(t1)
	for s := 1; s < 63; s++ {
		t2.Square(t2)
	}
	t1.Mul(t1, t2)
	t2.Square(t1)
	for s := 1; s < 126; s++ {
		t2.Square(t2)
	}
	t1.Mul(t1, t2)
	for s := 0; s < 3; s++ {
		t1.Square(t1)
	}
	t0.Mul(t0, t1)
	for s := 0; s < 33; s++ {
		t0.Square(t0)
	}
	z.Mul(z, t0)
	for s := 0; s < 64; s++ {
		z.Square(z)
	}
	z.Mul(x, z)
	for s := 0; s < 30; s++ {
		z.Square(z)
	}
}

"""



```
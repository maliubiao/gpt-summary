Response:
Let's break down the thought process for analyzing this Go test file.

1. **Identify the Core Functionality:** The file name `pss_test.go` and the package declaration `package rsa_test` strongly suggest that this code tests the PSS (Probabilistic Signature Scheme) functionality within the `crypto/rsa` package in Go's standard library.

2. **Scan for Test Functions:**  The `testing` package is imported, and functions starting with `Test` are the standard way to write tests in Go. Quickly identify these: `TestPSSGolden`, `TestPSSOpenSSL`, `TestPSSNilOpts`, `TestPSSSigning`, `TestPSS513`, `TestInvalidPSSSaltLength`, and `TestHashOverride`. Each of these likely tests a specific aspect of PSS.

3. **Analyze Individual Test Functions (Iterative Process):**

   * **`TestPSSGolden`:**  The comment `tests all the test vectors in pss-vect.txt...` is a huge clue. The code opens a file (`pss-vect.txt.bz2`), reads it, and parses its contents. The markers "START NEW KEY" and "START NEW SIGNATURE" indicate the structure of the test data. The core logic involves extracting key parameters and signatures, then using `VerifyPSS` to check if the signatures are valid for the given keys and messages. This test focuses on interoperability with standard test vectors.

   * **`TestPSSOpenSSL`:** The comment mentions verifying a PSS signature from OpenSSL. The code hardcodes a signature (`sig`) generated by an OpenSSL command. It then uses `VerifyPSS` to check if Go can verify this signature. This tests interoperability with OpenSSL's PSS implementation.

   * **`TestPSSNilOpts`:** This test simply calls `SignPSS` with `nil` for the `PSSOptions`. This checks if the signing function handles `nil` options gracefully (presumably using default values).

   * **`TestPSSSigning`:** The name suggests testing the signing process. The code defines `saltLengthCombinations`, which indicates it's testing different configurations of salt lengths for signing and verification. It iterates through these combinations, calls `SignPSS`, then `VerifyPSS`, and checks if the verification succeeds or fails as expected, considering FIPS mode.

   * **`TestPSS513`:** The comment refers to "Issue 42741" and RFC 8017, hinting at a specific edge case related to the RSA modulus size (513 bits). The code generates a 513-bit key, signs a message, and verifies the signature. This is likely a regression test for a specific bug or an attempt to ensure compliance with the RFC.

   * **`TestInvalidPSSSaltLength`:**  The name is self-explanatory. The code attempts to sign and verify with an invalid salt length (-2) and checks if the expected error is returned.

   * **`TestHashOverride`:** The comment "opts.Hash overrides the passed hash argument" is key. The code signs a message using `crypto.SHA256` as the function argument but provides `crypto.SHA512` in the `PSSOptions`. It then verifies with `crypto.SHA512` but also tries to verify with `crypto.SHA256` in `PSSOptions` to demonstrate the override behavior (or lack thereof in `VerifyPSS`).

4. **Identify Helper Functions:**  Functions like `bigFromHex`, `intFromHex`, and `fromHex` are clearly helper functions used to parse the test data in `TestPSSGolden`.

5. **Infer Functionality (High-Level):** Based on the individual tests, the overall functionality being tested is the PSS signature scheme implementation in the `crypto/rsa` package. This includes:
    * **Signing:**  Creating PSS signatures.
    * **Verification:** Checking the validity of PSS signatures.
    * **Salt Length Handling:** Testing different salt length options (automatic, equal to hash length, specific lengths).
    * **Interoperability:**  Verifying signatures generated by other tools (OpenSSL) and conforming to standard test vectors.
    * **Error Handling:** Ensuring proper error messages for invalid inputs.
    * **Hash Function Handling:**  Investigating how hash functions are used in signing and verification, including the impact of `PSSOptions`.

6. **Go Code Examples:** To illustrate, choose a relatively simple test case like `TestPSSNilOpts` or a core function like `VerifyPSS` used in multiple tests. Show the basic usage of `SignPSS` and `VerifyPSS`.

7. **Code Reasoning with Input/Output (for `TestPSSGolden`):**  Focus on the core loop in `TestPSSGolden`. Explain how the test file is parsed and how the extracted values (modulus, public exponent, message, signature) are used as inputs to `VerifyPSS`. Since the test expects successful verification, the output is implicitly "no error".

8. **Command-Line Arguments (if applicable):**  In this specific code, there are no explicit command-line argument parsing. However, the `t.Setenv("GODEBUG", ...)` calls are relevant. Explain that these environment variables can influence the behavior of the tests, specifically `rsa1024min`.

9. **Common Mistakes:** Look for patterns in the tests that highlight potential pitfalls for users. The `TestInvalidPSSSaltLength` and `TestHashOverride` tests are good examples of testing for incorrect usage. Explain the consequences of using incorrect salt lengths or misunderstanding the role of the `Hash` option in `SignPSS` and `VerifyPSS`.

10. **Structure and Refine:** Organize the information logically. Start with a high-level summary, then delve into the details of each test function. Provide clear Go code examples and explanations for code reasoning and potential mistakes. Use clear and concise language.

By following these steps, we can systematically analyze the given Go test file and provide a comprehensive explanation of its functionality.
这个 Go 语言文件 `go/src/crypto/rsa/pss_test.go` 的主要功能是**测试 `crypto/rsa` 包中关于 PSS (Probabilistic Signature Scheme) 签名和验证的实现**。它包含了多个测试用例，覆盖了 PSS 的不同方面，例如使用标准测试向量、与 OpenSSL 的互操作性、不同的盐长度配置以及错误处理等。

下面我们来详细列举一下它的功能点，并用 Go 代码举例说明：

**1. 测试基于标准测试向量的 PSS 签名和验证 (`TestPSSGolden`)**

*   **功能:** 该测试函数读取并解析来自 `testdata/pss-vect.txt.bz2` 文件的 PSS 标准测试向量。这些向量包含了不同的 RSA 公钥、消息以及对应的 PSS 签名。
*   **实现:** 它通过 `os.Open` 打开压缩的测试向量文件，然后使用 `bufio.Scanner` 逐行读取。一个 goroutine 被用来预处理这些行，合并多行值，移除十六进制值中的空格，并识别新的密钥和签名块的起始。
*   **代码示例:**

```go
func TestPSSGolden(t *testing.T) {
    inFile, err := os.Open("testdata/pss-vect.txt.bz2")
    if err != nil {
        t.Fatalf("Failed to open input file: %s", err)
    }
    defer inFile.Close()

    // ... (预处理文件内容的逻辑) ...

    var key *PublicKey
    var hashed []byte
    hash := crypto.SHA1
    h := hash.New()
    opts := &PSSOptions{
        SaltLength: PSSSaltLengthEqualsHash,
    }

    for marker := range values {
        switch marker {
        case newKeyMarker:
            key = new(PublicKey)
            nHex, _ := <-values
            key.N = bigFromHex(nHex)
            key.E = intFromHex(<-values)
            // ... (读取其他密钥参数) ...
        case newSignatureMarker:
            msg := fromHex(<-values)
            <-values // skip salt
            sig := fromHex(<-values)

            h.Reset()
            h.Write(msg)
            hashed = h.Sum(hashed[:0])

            if err := VerifyPSS(key, hash, hashed, sig, opts); err != nil {
                t.Error(err)
            }
        }
    }
}
```

*   **假设的输入与输出:** 假设 `pss-vect.txt.bz2` 中包含一个密钥和一个对应的签名。
    *   **输入:** 从文件中解析出的 RSA 公钥 `key`，消息 `msg` (例如 "test message")，以及 PSS 签名 `sig`。
    *   **处理:**  `TestPSSGolden` 函数会计算消息的哈希值 `hashed`，然后使用 `VerifyPSS` 函数，将 `key`、使用的哈希算法（这里是 SHA1）、`hashed`、`sig` 以及 PSS 选项 `opts` 传递给它。
    *   **输出:** 如果签名验证成功，`VerifyPSS` 返回 `nil`，测试用例通过。如果验证失败，`VerifyPSS` 返回一个错误，`t.Error(err)` 会记录这个错误。

**2. 测试与 OpenSSL 生成的 PSS 签名的互操作性 (`TestPSSOpenSSL`)**

*   **功能:** 该测试函数验证 `crypto/rsa` 包是否能够验证由 OpenSSL 生成的 PSS 签名。
*   **实现:** 它硬编码了一个由 OpenSSL 使用特定命令生成的 PSS 签名，然后使用 `VerifyPSS` 函数进行验证。
*   **代码示例:**

```go
func TestPSSOpenSSL(t *testing.T) {
    t.Setenv("GODEBUG", "rsa1024min=0")

    hash := crypto.SHA256
    h := hash.New()
    h.Write([]byte("testing"))
    hashed := h.Sum(nil)

    sig := []byte{
        0x95, 0x59, 0x6f, 0xd3, 0x10, 0xa2, 0xe7, 0xa2, 0x92, 0x9d,
        0x4a, 0x07, 0x2e, 0x2b, 0x27, 0xcc, 0x06, 0xc2, 0x87, 0x2c,
        0x52, 0xf0, 0x4a, 0xcc, 0x05, 0x94, 0xf2, 0xc3, 0x2e, 0x20,
        0xd7, 0x3e, 0x66, 0x62, 0xb5, 0x95, 0x2b, 0xa3, 0x93, 0x9a,
        0x66, 0x64, 0x25, 0xe0, 0x74, 0x66, 0x8c, 0x3e, 0x92, 0xeb,
        0xc6, 0xe6, 0xc0, 0x44, 0xf3, 0xb4, 0xb4, 0x2e, 0x8c, 0x66,
        0x0a, 0x37, 0x9c, 0x69,
    }

    if err := VerifyPSS(&test512Key.PublicKey, hash, hashed, sig, nil); err != nil {
        t.Error(err)
    }
}
```

*   **假设的输入与输出:**
    *   **输入:**  预定义的公钥 `test512Key.PublicKey`，消息 "testing" 的 SHA256 哈希值 `hashed`，以及硬编码的 OpenSSL 生成的签名 `sig`。`PSSOptions` 为 `nil`，表示使用默认选项。
    *   **处理:** `VerifyPSS` 函数会尝试使用提供的公钥和哈希值验证签名。
    *   **输出:** 如果 Go 的 `VerifyPSS` 能够成功验证 OpenSSL 生成的签名，则返回 `nil`，测试通过。否则返回错误。

**3. 测试使用 `nil` 的 PSS 选项 (`TestPSSNilOpts`)**

*   **功能:** 验证当 `PSSOptions` 为 `nil` 时，`SignPSS` 函数是否能够正常工作。这通常意味着使用默认的 PSS 参数。
*   **代码示例:**

```go
func TestPSSNilOpts(t *testing.T) {
    hash := crypto.SHA256
    h := hash.New()
    h.Write([]byte("testing"))
    hashed := h.Sum(nil)

    SignPSS(rand.Reader, rsaPrivateKey, hash, hashed, nil)
}
```

*   **假设的输入与输出:**
    *   **输入:** 随机数生成器 `rand.Reader`，私钥 `rsaPrivateKey`，SHA256 哈希算法，消息 "testing" 的哈希值 `hashed`，以及 `nil` 的 `PSSOptions`。
    *   **处理:** `SignPSS` 函数会使用默认的 PSS 参数生成签名。
    *   **输出:** 如果 `SignPSS` 没有返回错误，则测试通过。这个测试主要关注的是函数是否会因为 `nil` 的选项而崩溃。

**4. 测试不同的 PSS 签名和验证盐长度组合 (`TestPSSSigning`)**

*   **功能:**  测试 `SignPSS` 和 `VerifyPSS` 函数在不同的盐长度配置下的行为。包括 `PSSSaltLengthAuto`（自动选择）、`PSSSaltLengthEqualsHash`（盐长度等于哈希输出长度）以及指定的盐长度。
*   **实现:** 它定义了一个包含不同盐长度组合的结构体切片 `saltLengthCombinations`，然后遍历这些组合，分别用于签名和验证，并检查结果是否符合预期（成功或失败）。同时考虑了 FIPS 模式下的行为。
*   **代码示例:**

```go
func TestPSSSigning(t *testing.T) {
    var saltLengthCombinations = []struct {
        signSaltLength, verifySaltLength int
        good, fipsGood                   bool
    }{
        {PSSSaltLengthAuto, PSSSaltLengthAuto, true, true},
        // ... 其他组合 ...
    }

    hash := crypto.SHA1
    h := hash.New()
    h.Write([]byte("testing"))
    hashed := h.Sum(nil)
    var opts PSSOptions

    for i, test := range saltLengthCombinations {
        opts.SaltLength = test.signSaltLength
        sig, err := SignPSS(rand.Reader, rsaPrivateKey, hash, hashed, &opts)
        if err != nil {
            t.Errorf("#%d: error while signing: %s", i, err)
            continue
        }

        opts.SaltLength = test.verifySaltLength
        err = VerifyPSS(&rsaPrivateKey.PublicKey, hash, hashed, sig, &opts)
        good := test.good
        if fips140.Enabled {
            good = test.fipsGood
        }
        if (err == nil) != good {
            t.Errorf("#%d: bad result, wanted: %t, got: %s", i, test.good, err)
        }
    }
}
```

*   **假设的输入与输出:**  对于每种盐长度组合，`SignPSS` 会尝试生成签名，`VerifyPSS` 会尝试验证签名。预期的成功或失败取决于 `saltLengthCombinations` 中定义的 `good` 和 `fipsGood` 标志。

**5. 测试特定模数长度的 PSS 签名和验证 (`TestPSS513`)**

*   **功能:** 专门测试了使用 513 位模数的 RSA 密钥进行 PSS 签名和验证的情况，这与 RFC 8017 中关于编码长度的说明有关。
*   **代码示例:**

```go
func TestPSS513(t *testing.T) {
    t.Setenv("GODEBUG", "rsa1024min=0")
    key, err := GenerateKey(rand.Reader, 513)
    if err != nil {
        t.Fatal(err)
    }
    digest := sha256.Sum256([]byte("message"))
    signature, err := key.Sign(rand.Reader, digest[:], &PSSOptions{
        SaltLength: PSSSaltLengthAuto,
        Hash:       crypto.SHA256,
    })
    if err != nil {
        t.Fatal(err)
    }
    err = VerifyPSS(&key.PublicKey, crypto.SHA256, digest[:], signature, nil)
    if err != nil {
        t.Error(err)
    }
}
```

*   **假设的输入与输出:**  生成一个 513 位的 RSA 密钥，使用该密钥对消息 "message" 的 SHA256 哈希值进行 PSS 签名，然后使用对应的公钥进行验证。如果签名和验证都成功，则测试通过。

**6. 测试无效的 PSS 盐长度 (`TestInvalidPSSSaltLength`)**

*   **功能:** 确保当提供无效的盐长度时，`SignPSS` 和 `VerifyPSS` 函数能够正确地返回错误。
*   **代码示例:**

```go
func TestInvalidPSSSaltLength(t *testing.T) {
    t.Setenv("GODEBUG", "rsa1024min=0")
    key, err := GenerateKey(rand.Reader, 245)
    if err != nil {
        t.Fatal(err)
    }

    digest := sha256.Sum256([]byte("message"))
    if _, err := SignPSS(rand.Reader, key, crypto.SHA256, digest[:], &PSSOptions{
        SaltLength: -2,
        Hash:       crypto.SHA256,
    }); err.Error() != "crypto/rsa: invalid PSS salt length" {
        t.Fatalf("SignPSS unexpected error: got %v, want %v", err, "crypto/rsa: invalid PSS salt length")
    }

    if err := VerifyPSS(&key.PublicKey, crypto.SHA256, []byte{1, 2, 3}, make([]byte, 31), &PSSOptions{
        SaltLength: -2,
    }); err == nil {
        t.Fatal("VerifyPSS unexpected success")
    }
}
```

*   **假设的输入与输出:**  尝试使用负的盐长度值 (-2) 进行签名和验证。预期 `SignPSS` 会返回包含 "invalid PSS salt length" 的错误。`VerifyPSS` 也应该返回错误。

**7. 测试哈希覆盖行为 (`TestHashOverride`)**

*   **功能:** 验证在 `SignPSS` 函数中，`PSSOptions` 中的 `Hash` 字段会覆盖作为参数传递的 `hash` 算法。同时验证 `VerifyPSS` 中 `PSSOptions` 的 `Hash` 字段会被忽略。
*   **代码示例:**

```go
func TestHashOverride(t *testing.T) {
    digest := sha512.Sum512([]byte("message"))
    // opts.Hash overrides the passed hash argument.
    sig, err := SignPSS(rand.Reader, test2048Key, crypto.SHA256, digest[:], &PSSOptions{Hash: crypto.SHA512})
    if err != nil {
        t.Fatalf("SignPSS unexpected error: got %v, want nil", err)
    }

    // VerifyPSS has the inverse behavior, opts.Hash is always ignored, check this is true.
    if err := VerifyPSS(&test2048Key.PublicKey, crypto.SHA512, digest[:], sig, &PSSOptions{Hash: crypto.SHA256}); err != nil {
        t.Fatalf("VerifyPSS unexpected error: got %v, want nil", err)
    }
}
```

*   **假设的输入与输出:**  使用 SHA256 作为函数参数，但 `PSSOptions` 中指定 SHA512 进行签名。然后尝试使用 SHA512 和 SHA256 在 `PSSOptions` 中进行验证。预期的行为是签名使用 SHA512，而 `VerifyPSS` 始终以函数参数中指定的哈希算法为准。

**辅助函数:**

*   `bigFromHex(hex string) *big.Int`: 将十六进制字符串转换为 `big.Int`。
*   `intFromHex(hex string) int`: 将十六进制字符串转换为 `int`。
*   `fromHex(hexStr string) []byte`: 将十六进制字符串解码为字节切片。

**关于命令行参数的具体处理:**

在这个文件中，并没有直接处理命令行参数。但是，`t.Setenv("GODEBUG", "rsa1024min=0")` 这行代码会设置一个环境变量 `GODEBUG`，这个环境变量可以影响 `crypto/rsa` 包的行为。具体来说，`rsa1024min=0` 禁用了 RSA 密钥长度必须大于等于 1024 位的限制，这在测试一些较小密钥长度的场景时很有用。这不是一个典型的命令行参数处理，而是一种通过环境变量配置测试行为的方式。

**使用者易犯错的点:**

*   **盐长度的理解和配置:**  PSS 的安全性依赖于盐的随机性和长度。错误地配置盐长度（例如，使用过短的盐或不使用随机盐）会降低安全性。`TestPSSSigning` 旨在覆盖这些场景，确保不同盐长度配置下的正确性。
*   **哈希算法的选择:**  签名和验证时使用的哈希算法必须一致。`TestHashOverride` 展示了 `SignPSS` 和 `VerifyPSS` 在处理哈希算法时的行为，避免使用者在选项中指定错误的哈希算法导致验证失败。
*   **与外部库的互操作性问题:**  不同的 PSS 实现可能在细节上存在差异，例如默认的盐长度处理。`TestPSSOpenSSL` 旨在确保 Go 的实现能够与常见的 OpenSSL 实现互操作。

总而言之，`go/src/crypto/rsa/pss_test.go` 是一个全面的测试文件，用于验证 Go 语言 `crypto/rsa` 包中 PSS 签名和验证功能的正确性和健壮性，并覆盖了各种使用场景和潜在的错误配置。

### 提示词
```
这是路径为go/src/crypto/rsa/pss_test.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
请用中文回答。
```

### 源代码
```go
// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package rsa_test

import (
	"bufio"
	"compress/bzip2"
	"crypto"
	"crypto/internal/fips140"
	"crypto/rand"
	. "crypto/rsa"
	"crypto/sha256"
	"crypto/sha512"
	"encoding/hex"
	"math/big"
	"os"
	"strconv"
	"strings"
	"testing"
)

// TestPSSGolden tests all the test vectors in pss-vect.txt from
// ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-1/pkcs-1v2-1-vec.zip
func TestPSSGolden(t *testing.T) {
	inFile, err := os.Open("testdata/pss-vect.txt.bz2")
	if err != nil {
		t.Fatalf("Failed to open input file: %s", err)
	}
	defer inFile.Close()

	// The pss-vect.txt file contains RSA keys and then a series of
	// signatures. A goroutine is used to preprocess the input by merging
	// lines, removing spaces in hex values and identifying the start of
	// new keys and signature blocks.
	const newKeyMarker = "START NEW KEY"
	const newSignatureMarker = "START NEW SIGNATURE"

	values := make(chan string)

	go func() {
		defer close(values)
		scanner := bufio.NewScanner(bzip2.NewReader(inFile))
		var partialValue string
		lastWasValue := true

		for scanner.Scan() {
			line := scanner.Text()
			switch {
			case len(line) == 0:
				if len(partialValue) > 0 {
					values <- strings.ReplaceAll(partialValue, " ", "")
					partialValue = ""
					lastWasValue = true
				}
				continue
			case strings.HasPrefix(line, "# ======") && lastWasValue:
				values <- newKeyMarker
				lastWasValue = false
			case strings.HasPrefix(line, "# ------") && lastWasValue:
				values <- newSignatureMarker
				lastWasValue = false
			case strings.HasPrefix(line, "#"):
				continue
			default:
				partialValue += line
			}
		}
		if err := scanner.Err(); err != nil {
			panic(err)
		}
	}()

	var key *PublicKey
	var hashed []byte
	hash := crypto.SHA1
	h := hash.New()
	opts := &PSSOptions{
		SaltLength: PSSSaltLengthEqualsHash,
	}

	for marker := range values {
		switch marker {
		case newKeyMarker:
			key = new(PublicKey)
			nHex, ok := <-values
			if !ok {
				continue
			}
			key.N = bigFromHex(nHex)
			key.E = intFromHex(<-values)
			// We don't care for d, p, q, dP, dQ or qInv.
			for i := 0; i < 6; i++ {
				<-values
			}
		case newSignatureMarker:
			msg := fromHex(<-values)
			<-values // skip salt
			sig := fromHex(<-values)

			h.Reset()
			h.Write(msg)
			hashed = h.Sum(hashed[:0])

			if err := VerifyPSS(key, hash, hashed, sig, opts); err != nil {
				t.Error(err)
			}
		default:
			t.Fatalf("unknown marker: %s", marker)
		}
	}
}

// TestPSSOpenSSL ensures that we can verify a PSS signature from OpenSSL with
// the default options. OpenSSL sets the salt length to be maximal.
func TestPSSOpenSSL(t *testing.T) {
	t.Setenv("GODEBUG", "rsa1024min=0")

	hash := crypto.SHA256
	h := hash.New()
	h.Write([]byte("testing"))
	hashed := h.Sum(nil)

	// Generated with `echo -n testing | openssl dgst -sign key.pem -sigopt rsa_padding_mode:pss -sha256 > sig`
	sig := []byte{
		0x95, 0x59, 0x6f, 0xd3, 0x10, 0xa2, 0xe7, 0xa2, 0x92, 0x9d,
		0x4a, 0x07, 0x2e, 0x2b, 0x27, 0xcc, 0x06, 0xc2, 0x87, 0x2c,
		0x52, 0xf0, 0x4a, 0xcc, 0x05, 0x94, 0xf2, 0xc3, 0x2e, 0x20,
		0xd7, 0x3e, 0x66, 0x62, 0xb5, 0x95, 0x2b, 0xa3, 0x93, 0x9a,
		0x66, 0x64, 0x25, 0xe0, 0x74, 0x66, 0x8c, 0x3e, 0x92, 0xeb,
		0xc6, 0xe6, 0xc0, 0x44, 0xf3, 0xb4, 0xb4, 0x2e, 0x8c, 0x66,
		0x0a, 0x37, 0x9c, 0x69,
	}

	if err := VerifyPSS(&test512Key.PublicKey, hash, hashed, sig, nil); err != nil {
		t.Error(err)
	}
}

func TestPSSNilOpts(t *testing.T) {
	hash := crypto.SHA256
	h := hash.New()
	h.Write([]byte("testing"))
	hashed := h.Sum(nil)

	SignPSS(rand.Reader, rsaPrivateKey, hash, hashed, nil)
}

func TestPSSSigning(t *testing.T) {
	var saltLengthCombinations = []struct {
		signSaltLength, verifySaltLength int
		good, fipsGood                   bool
	}{
		{PSSSaltLengthAuto, PSSSaltLengthAuto, true, true},
		{PSSSaltLengthEqualsHash, PSSSaltLengthAuto, true, true},
		{PSSSaltLengthEqualsHash, PSSSaltLengthEqualsHash, true, true},
		{PSSSaltLengthEqualsHash, 8, false, false},
		{8, 8, true, true},
		{8, PSSSaltLengthAuto, true, true},
		{42, PSSSaltLengthAuto, true, true},
		// In FIPS mode, PSSSaltLengthAuto is capped at PSSSaltLengthEqualsHash.
		{PSSSaltLengthAuto, PSSSaltLengthEqualsHash, false, true},
		{PSSSaltLengthAuto, 106, true, false},
		{PSSSaltLengthAuto, 20, false, true},
		{PSSSaltLengthAuto, -2, false, false},
	}

	hash := crypto.SHA1
	h := hash.New()
	h.Write([]byte("testing"))
	hashed := h.Sum(nil)
	var opts PSSOptions

	for i, test := range saltLengthCombinations {
		opts.SaltLength = test.signSaltLength
		sig, err := SignPSS(rand.Reader, rsaPrivateKey, hash, hashed, &opts)
		if err != nil {
			t.Errorf("#%d: error while signing: %s", i, err)
			continue
		}

		opts.SaltLength = test.verifySaltLength
		err = VerifyPSS(&rsaPrivateKey.PublicKey, hash, hashed, sig, &opts)
		good := test.good
		if fips140.Enabled {
			good = test.fipsGood
		}
		if (err == nil) != good {
			t.Errorf("#%d: bad result, wanted: %t, got: %s", i, test.good, err)
		}
	}
}

func TestPSS513(t *testing.T) {
	// See Issue 42741, and separately, RFC 8017: "Note that the octet length of
	// EM will be one less than k if modBits - 1 is divisible by 8 and equal to
	// k otherwise, where k is the length in octets of the RSA modulus n."
	t.Setenv("GODEBUG", "rsa1024min=0")
	key, err := GenerateKey(rand.Reader, 513)
	if err != nil {
		t.Fatal(err)
	}
	digest := sha256.Sum256([]byte("message"))
	signature, err := key.Sign(rand.Reader, digest[:], &PSSOptions{
		SaltLength: PSSSaltLengthAuto,
		Hash:       crypto.SHA256,
	})
	if err != nil {
		t.Fatal(err)
	}
	err = VerifyPSS(&key.PublicKey, crypto.SHA256, digest[:], signature, nil)
	if err != nil {
		t.Error(err)
	}
}

func bigFromHex(hex string) *big.Int {
	n, ok := new(big.Int).SetString(hex, 16)
	if !ok {
		panic("bad hex: " + hex)
	}
	return n
}

func intFromHex(hex string) int {
	i, err := strconv.ParseInt(hex, 16, 32)
	if err != nil {
		panic(err)
	}
	return int(i)
}

func fromHex(hexStr string) []byte {
	s, err := hex.DecodeString(hexStr)
	if err != nil {
		panic(err)
	}
	return s
}

func TestInvalidPSSSaltLength(t *testing.T) {
	t.Setenv("GODEBUG", "rsa1024min=0")
	key, err := GenerateKey(rand.Reader, 245)
	if err != nil {
		t.Fatal(err)
	}

	digest := sha256.Sum256([]byte("message"))
	if _, err := SignPSS(rand.Reader, key, crypto.SHA256, digest[:], &PSSOptions{
		SaltLength: -2,
		Hash:       crypto.SHA256,
	}); err.Error() != "crypto/rsa: invalid PSS salt length" {
		t.Fatalf("SignPSS unexpected error: got %v, want %v", err, "crypto/rsa: invalid PSS salt length")
	}

	// We don't check the specific error here, because crypto/rsa and crypto/internal/boring
	// return different errors, so we just check that _an error_ was returned.
	if err := VerifyPSS(&key.PublicKey, crypto.SHA256, []byte{1, 2, 3}, make([]byte, 31), &PSSOptions{
		SaltLength: -2,
	}); err == nil {
		t.Fatal("VerifyPSS unexpected success")
	}
}

func TestHashOverride(t *testing.T) {
	digest := sha512.Sum512([]byte("message"))
	// opts.Hash overrides the passed hash argument.
	sig, err := SignPSS(rand.Reader, test2048Key, crypto.SHA256, digest[:], &PSSOptions{Hash: crypto.SHA512})
	if err != nil {
		t.Fatalf("SignPSS unexpected error: got %v, want nil", err)
	}

	// VerifyPSS has the inverse behavior, opts.Hash is always ignored, check this is true.
	if err := VerifyPSS(&test2048Key.PublicKey, crypto.SHA512, digest[:], sig, &PSSOptions{Hash: crypto.SHA256}); err != nil {
		t.Fatalf("VerifyPSS unexpected error: got %v, want nil", err)
	}
}
```
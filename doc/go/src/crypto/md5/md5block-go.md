Response:
Let's break down the thought process for analyzing the provided Go code snippet.

1. **Understanding the Context:** The first step is to recognize the file path: `go/src/crypto/md5/md5block.go`. This immediately tells us we're dealing with the MD5 hashing algorithm implementation within the Go standard library's `crypto` package. The filename `md5block.go` suggests this file specifically handles the core block processing logic of MD5. The `// Code generated by go run gen.go -output md5block.go; DO NOT EDIT.` comment reinforces that this file is likely automatically generated, emphasizing that direct manual modification is discouraged.

2. **Identifying the Core Function:** The code contains a single function, `blockGeneric(dig *digest, p []byte)`. This is the central piece of functionality we need to analyze. The function name `blockGeneric` further supports the idea that it's processing data in blocks. The parameters `dig *digest` and `p []byte` are also crucial:
    * `dig *digest`: This strongly suggests that `digest` is a struct (or a pointer to one) holding the intermediate state of the MD5 computation. It likely contains the accumulated hash values.
    * `p []byte`:  This is the input data being processed, a byte slice.

3. **Analyzing the Function's Logic:** Now, we dive into the `blockGeneric` function's body:

    * **Loading Initial State:** `a, b, c, d := dig.s[0], dig.s[1], dig.s[2], dig.s[3]` loads values from the `dig.s` array. This confirms our suspicion that `dig` holds the intermediate hash values. MD5 has four 32-bit words for its state.

    * **Iterating Through Blocks:** The `for` loop `for i := 0; i <= len(p)-BlockSize; i += BlockSize` clearly indicates that the function processes the input `p` in chunks of `BlockSize`. The condition `len(p)-BlockSize` ensures we only process complete blocks.

    * **Block Extraction and Bounds Check Elimination:** `q := p[i:]`, `q = q[:BlockSize:BlockSize]`. This is a common Go optimization to avoid repeated bounds checks within the loop. It creates a slice `q` that represents the current block.

    * **Saving and Loading Input:** `aa, bb, cc, dd := a, b, c, d` saves the current state before processing the block. The series of `x0 := byteorder.LEUint32(q[4*0x0:])` lines loads 32-bit words from the input block `q` using little-endian byte order. This is a core step in the MD5 algorithm.

    * **The Rounds:** The code contains four distinct sections labeled "round 1", "round 2", "round 3", and "round 4". Each round consists of 16 similar-looking operations involving bitwise operations (`^`, `&`), additions (`+`), and left rotations (`bits.RotateLeft32`). These operations are the heart of the MD5 transformation function. The magic constants (e.g., `0xd76aa478`) are also characteristic of the MD5 algorithm.

    * **Updating State:** `a = b + ...`, `d = a + ...`, etc. within each round show how the state variables `a`, `b`, `c`, and `d` are updated based on the input block and the previous state.

    * **Adding Saved State:** `a += aa`, `b += bb`, etc. after the rounds is the final step in processing a block, adding the initial state of the block processing to the transformed values.

    * **Saving Updated State:** `dig.s[0], dig.s[1], dig.s[2], dig.s[3] = a, b, c, d` writes the updated state back to the `dig` struct.

4. **Inferring the Functionality:** Based on the code's structure and the presence of the four rounds with specific bitwise operations and magic constants, it's highly likely that this function implements the core block processing logic of the MD5 hash algorithm. It takes a `digest` (which holds the current hash state) and a data block as input and updates the `digest`'s state according to the MD5 transformation.

5. **Constructing the Example:** To demonstrate the usage, we need to show how `blockGeneric` would be called within a larger MD5 calculation. This involves:
    * Initializing the `digest` state.
    * Providing an input byte slice.
    * Calling `blockGeneric` with the digest and a block of the input.
    * Potentially calling it multiple times for longer inputs.
    * The example should show the initial state and how it changes after processing a block.

6. **Considering Potential Errors:**  The main error users might make is related to providing input data that isn't a multiple of the block size. This snippet doesn't handle the padding of the last incomplete block. The calling code is responsible for that.

7. **Addressing Other Requirements:**
    * **Command-line arguments:** This specific code snippet doesn't handle command-line arguments. That would be in a separate part of the MD5 implementation, likely in a main function or a function that initializes the hashing process.
    * **Generated code:** It's important to note the "DO NOT EDIT" comment, as modifying generated code directly can lead to problems.

8. **Structuring the Answer:** Finally, organize the findings into a clear and structured answer, addressing each point of the prompt (functionality, inferred Go feature, example, command-line arguments, common errors). Use clear and concise language, and provide code examples where requested.
这个 `md5block.go` 文件是 Go 语言 `crypto/md5` 包中专门用于处理 MD5 算法中**数据块处理**的核心代码。由于文件头明确指出 `// Code generated by go run gen.go -output md5block.go; DO NOT EDIT.`, 这部分代码很可能是通过一个代码生成工具 `gen.go` 自动生成的，目的是为了提高性能，可能针对特定的 CPU 架构进行了优化。

**功能列举:**

1. **接收 MD5 算法的当前状态 (digest):**  `blockGeneric` 函数接收一个指向 `digest` 结构体的指针 `dig`。这个 `digest` 结构体很可能包含了 MD5 算法的四个 32 位状态值 (通常称为 A, B, C, D)。
2. **接收一个数据块 (block):** 函数的第二个参数 `p` 是一个 `[]byte` 类型的切片，代表要处理的数据块。根据代码中的 `BlockSize` 常量 (虽然未在代码片段中直接定义，但通常 MD5 的块大小是 64 字节)，这个函数会处理大小为 `BlockSize` 的数据块。
3. **加载和存储状态值:**  代码首先从 `dig` 中加载当前的四个状态值 `a`, `b`, `c`, `d`，并在处理完数据块后将更新后的状态值写回 `dig`。
4. **按块处理输入数据:** `for i := 0; i <= len(p)-BlockSize; i += BlockSize` 这个循环表明代码会以 `BlockSize` 为步长遍历输入数据 `p`，确保每次处理的都是一个完整的块。
5. **将数据块转换为 32 位字:**  代码使用 `byteorder.LEUint32` 将输入数据块的每 4 个字节转换为一个 32 位无符号整数，并存储在 `x0` 到 `xf` 变量中。 `byteorder.LEUint32` 表明 MD5 算法使用小端字节序。
6. **执行 MD5 的四轮变换 (rounds):** 代码中清晰地标注了 "round 1", "round 2", "round 3", "round 4" 这四个部分。每个 round 都包含 16 个类似的操作，这些操作是 MD5 算法的核心组成部分，包括：
    * **非线性函数:** 如 `(((c^d)&b)^d)`
    * **加法运算:** `+ a`, `+ x0` 等
    * **幻数 (Magic Constants):** 如 `0xd76aa478`
    * **循环左移 (Rotate Left):** `bits.RotateLeft32`
7. **更新状态值:**  在每个 round 中，状态值 `a`, `b`, `c`, `d` 会根据输入数据和幻数进行更新。
8. **将处理后的状态值加回:** 在处理完一个块后，会将处理前的状态值 `aa`, `bb`, `cc`, `dd` 加回到处理后的状态值 `a`, `b`, `c`, `d` 中。

**推断的 Go 语言功能实现: MD5 散列算法的核心块处理**

这段代码实现了 MD5 散列算法中的核心块处理逻辑。MD5 算法将输入数据分割成固定大小的块（512 位，即 64 字节），然后对每个块进行一系列复杂的运算来更新一个 128 位（16 字节）的散列值。 `blockGeneric` 函数就是负责处理其中一个数据块的步骤。

**Go 代码示例:**

假设我们有以下代码片段，演示如何使用 `blockGeneric` 函数（虽然在实际使用中，你通常会使用 `hash.Hash` 接口和 `md5.New()` 函数）：

```go
package main

import (
	"crypto/md5"
	"fmt"
	"internal/byteorder"
	"math/bits"
)

// 假设 digest 结构体定义如下 (实际可能在内部包中)
type digest struct {
	s [4]uint32
	// ... 其他字段
}

// 假设 BlockSize 定义如下 (实际在 crypto/md5 包中)
const BlockSize = 64

// blockGeneric 函数 (从提供代码复制)
func blockGeneric(dig *digest, p []byte) {
	// ... (提供的代码)
	a, b, c, d := dig.s[0], dig.s[1], dig.s[2], dig.s[3]

	for i := 0; i <= len(p)-BlockSize; i += BlockSize {
		// eliminate bounds checks on p
		q := p[i:]
		q = q[:BlockSize:BlockSize]

		// save current state
		aa, bb, cc, dd := a, b, c, d

		// load input block
		x0 := byteorder.LEUint32(q[4*0x0:])
		x1 := byteorder.LEUint32(q[4*0x1:])
		x2 := byteorder.LEUint32(q[4*0x2:])
		x3 := byteorder.LEUint32(q[4*0x3:])
		x4 := byteorder.LEUint32(q[4*0x4:])
		x5 := byteorder.LEUint32(q[4*0x5:])
		x6 := byteorder.LEUint32(q[4*0x6:])
		x7 := byteorder.LEUint32(q[4*0x7:])
		x8 := byteorder.LEUint32(q[4*0x8:])
		x9 := byteorder.LEUint32(q[4*0x9:])
		xa := byteorder.LEUint32(q[4*0xa:])
		xb := byteorder.LEUint32(q[4*0xb:])
		xc := byteorder.LEUint32(q[4*0xc:])
		xd := byteorder.LEUint32(q[4*0xd:])
		xe := byteorder.LEUint32(q[4*0xe:])
		xf := byteorder.LEUint32(q[4*0xf:])

		// round 1
		a = b + bits.RotateLeft32((((c^d)&b)^d)+a+x0+0xd76aa478, 7)
		d = a + bits.RotateLeft32((((b^c)&a)^c)+d+x1+0xe8c7b756, 12)
		c = d + bits.RotateLeft32((((a^b)&d)^b)+c+x2+0x242070db, 17)
		b = c + bits.RotateLeft32((((d^a)&c)^a)+b+x3+0xc1bdceee, 22)
		a = b + bits.RotateLeft32((((c^d)&b)^d)+a+x4+0xf57c0faf, 7)
		d = a + bits.RotateLeft32((((b^c)&a)^c)+d+x5+0x4787c62a, 12)
		c = d + bits.RotateLeft32((((a^b)&d)^b)+c+x6+0xa8304613, 17)
		b = c + bits.RotateLeft32((((d^a)&c)^a)+b+x7+0xfd469501, 22)
		a = b + bits.RotateLeft32((((c^d)&b)^d)+a+x8+0x698098d8, 7)
		d = a + bits.RotateLeft32((((b^c)&a)^c)+d+x9+0x8b44f7af, 12)
		c = d + bits.RotateLeft32((((a^b)&d)^b)+c+xa+0xffff5bb1, 17)
		b = c + bits.RotateLeft32((((d^a)&c)^a)+b+xb+0x895cd7be, 22)
		a = b + bits.RotateLeft32((((c^d)&b)^d)+a+xc+0x6b901122, 7)
		d = a + bits.RotateLeft32((((b^c)&a)^c)+d+xd+0xfd987193, 12)
		c = d + bits.RotateLeft32((((a^b)&d)^b)+c+xe+0xa679438e, 17)
		b = c + bits.RotateLeft32((((d^a)&c)^a)+b+xf+0x49b40821, 22)

		// round 2
		a = b + bits.RotateLeft32((((b^c)&d)^c)+a+x1+0xf61e2562, 5)
		d = a + bits.RotateLeft32((((a^b)&c)^b)+d+x6+0xc040b340, 9)
		c = d + bits.RotateLeft32((((d^a)&b)^a)+c+xb+0x265e5a51, 14)
		b = c + bits.RotateLeft32((((c^d)&a)^d)+b+x0+0xe9b6c7aa, 20)
		a = b + bits.RotateLeft32((((b^c)&d)^c)+a+x5+0xd62f105d, 5)
		d = a + bits.RotateLeft32((((a^b)&c)^b)+d+xa+0x02441453, 9)
		c = d + bits.RotateLeft32((((d^a)&b)^a)+c+xf+0xd8a1e681, 14)
		b = c + bits.RotateLeft32((((c^d)&a)^d)+b+x4+0xe7d3fbc8, 20)
		a = b + bits.RotateLeft32((((b^c)&d)^c)+a+x9+0x21e1cde6, 5)
		d = a + bits.RotateLeft32((((a^b)&c)^b)+d+xe+0xc33707d6, 9)
		c = d + bits.RotateLeft32((((d^a)&b)^a)+c+x3+0xf4d50d87, 14)
		b = c + bits.RotateLeft32((((c^d)&a)^d)+b+x8+0x455a14ed, 20)
		a = b + bits.RotateLeft32((((b^c)&d)^c)+a+xd+0xa9e3e905, 5)
		d = a + bits.RotateLeft32((((a^b)&c)^b)+d+x2+0xfcefa3f8, 9)
		c = d + bits.RotateLeft32((((d^a)&b)^a)+c+x7+0x676f02d9, 14)
		b = c + bits.RotateLeft32((((c^d)&a)^d)+b+xc+0x8d2a4c8a, 20)

		// round 3
		a = b + bits.RotateLeft32((b^c^d)+a+x5+0xfffa3942, 4)
		d = a + bits.RotateLeft32((a^b^c)+d+x8+0x8771f681, 11)
		c = d + bits.RotateLeft32((d^a^b)+c+xb+0x6d9d6122, 16)
		b = c + bits.RotateLeft32((c^d^a)+b+xe+0xfde5380c, 23)
		a = b + bits.RotateLeft32((b^c^d)+a+x1+0xa4beea44, 4)
		d = a + bits.RotateLeft32((a^b^c)+d+x4+0x4bdecfa9, 11)
		c = d + bits.RotateLeft32((d^a^b)+c+x7+0xf6bb4b60, 16)
		b = c + bits.RotateLeft32((c^d^a)+b+xa+0xbebfbc70, 23)
		a = b + bits.RotateLeft32((b^c^d)+a+xd+0x289b7ec6, 4)
		d = a + bits.RotateLeft32((a^b^c)+d+x0+0xeaa127fa, 11)
		c = d + bits.RotateLeft32((d^a^b)+c+x3+0xd4ef3085, 16)
		b = c + bits.RotateLeft32((c^d^a)+b+x6+0x04881d05, 23)
		a = b + bits.RotateLeft32((b^c^d)+a+x9+0xd9d4d039, 4)
		d = a + bits.RotateLeft32((a^b^c)+d+xc+0xe6db99e5, 11)
		c = d + bits.RotateLeft32((d^a^b)+c+xf+0x1fa27cf8, 16)
		b = c + bits.RotateLeft32((c^d^a)+b+x2+0xc4ac5665, 23)

		// round 4
		a = b + bits.RotateLeft32((c^(b|^d))+a+x0+0xf4292244, 6)
		d = a + bits.RotateLeft32((b^(a|^c))+d+x7+0x432aff97, 10)
		c = d + bits.RotateLeft32((a^(d|^b))+c+xe+0xab9423a7, 15)
		b = c + bits.RotateLeft32((d^(c|^a))+b+x5+0xfc93a039, 21)
		a = b + bits.RotateLeft32((c^(b|^d))+a+xc+0x655b59c3, 6)
		d = a + bits.RotateLeft32((b^(a|^c))+d+x3+0x8f0ccc92, 10)
		c = d + bits.RotateLeft32((a^(d|^b))+c+xa+0xffeff47d, 15)
		b = c + bits.RotateLeft32((d^(c|^a))+b+x1+0x85845dd1, 21)
		a = b + bits.RotateLeft32((c^(b|^d))+a+x8+0x6fa87e4f, 6)
		d = a + bits.RotateLeft32((b^(a|^c))+d+xf+0xfe2ce6e0, 10)
		c = d + bits.RotateLeft32((a^(d|^b))+c+x6+0xa3014314, 15)
		b = c + bits.RotateLeft32((d^(c|^a))+b+xd+0x4e0811a1, 21)
		a = b + bits.RotateLeft32((c^(b|^d))+a+x4+0xf7537e82, 6)
		d = a + bits.RotateLeft32((b^(a|^c))+d+xb+0xbd3af235, 10)
		c = d + bits.RotateLeft32((a^(d|^b))+c+x2+0x2ad7d2bb, 15)
		b = c + bits.RotateLeft32((d^(c|^a))+b+x9+0xeb86d391, 21)

		// add saved state
		a += aa
		b += bb
		c += cc
		d += dd
	}

	// save state
	dig.s[0], dig.s[1], dig.s[2], dig.s[3] = a, b, c, d
}

func main() {
	data := []byte("hello")
	block := make([]byte, BlockSize)
	copy(block, data) // 假设数据可以放入一个块中

	d := &digest{s: [4]uint32{0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476}} // 初始化 MD5 初始状态

	fmt.Printf("Initial State: %+v\n", d.s)

	blockGeneric(d, block)

	fmt.Printf("State after processing block: %+v\n", d.s)
}
```

**假设的输入与输出:**

假设输入数据 `data` 是 "hello"，并且我们将其填充到一个 64 字节的 `block` 中。初始的 `digest` 状态 `d.s` 是 MD5 算法的初始值。

**输出:**

```
Initial State: [67452301 3764006745 2573425150 271733878]
State after processing block: [3117393334 2175083192 2627842133 1687521347]
```

**注意:** 上述输出是基于对代码逻辑的理解进行推测的，实际运行结果会受到 `byteorder` 的影响以及 `digest` 结构体中其他可能存在的字段的影响。为了简化，示例中假设输入数据正好填满一个块。

**命令行参数的具体处理:**

这段代码本身并不直接处理命令行参数。命令行参数的处理通常在调用 MD5 功能的更上层代码中完成。例如，一个使用 `crypto/md5` 包计算文件 MD5 值的命令行工具可能会：

1. 使用 `os.Args` 获取命令行参数。
2. 检查参数数量和有效性（例如，是否提供了要计算 MD5 值的文件的路径）。
3. 打开指定的文件。
4. 创建一个 `md5.New()` 的哈希对象。
5. 使用 `io.Copy` 将文件内容写入哈希对象。
6. 使用 `hash.Sum(nil)` 获取最终的 MD5 散列值。
7. 将结果打印到终端。

**使用者易犯错的点:**

1. **误解 `blockGeneric` 的用途:**  普通使用者不太可能直接调用 `blockGeneric` 函数。它通常是被 `md5.digest.Write` 方法在内部调用的。使用者应该使用更高级别的 API，如 `md5.New()` 和 `hash.Hash` 接口。

2. **没有正确处理非完整块:**  `blockGeneric` 函数假定输入数据是 `BlockSize` 的整数倍。如果直接向其传递长度不是 `BlockSize` 倍数的数据，并且期望得到正确的 MD5 值，将会出错。MD5 算法需要对最后一个不完整的块进行填充。

   **示例 (错误用法):**

   ```go
   package main

   import (
       "crypto/md5"
       "fmt"
       "internal/byteorder"
       "math/bits"
   )

   // ... (digest 结构体和 BlockSize 定义同上)
   // ... (blockGeneric 函数同上)

   func main() {
       data := []byte("hel") // 数据长度不是 BlockSize
       d := &digest{s: [4]uint32{0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476}}

       blockGeneric(d, data) // 错误：data 长度小于 BlockSize，循环不会执行

       fmt.Printf("State after processing (incorrect): %+v\n", d.s)

       // 正确用法应该是使用 md5.New() 和 hash.Write()
       h := md5.New()
       h.Write(data)
       sum := h.Sum(nil)
       fmt.Printf("Correct MD5: %x\n", sum)
   }
   ```

   在这个错误的例子中，`blockGeneric` 函数的循环条件 `i <= len(p)-BlockSize` 不满足，因此循环体不会执行，`digest` 的状态不会被更新。这会导致计算出的 MD5 值不正确。

总而言之，`md5block.go` 文件中的 `blockGeneric` 函数是 Go 语言 `crypto/md5` 包中用于高效处理 MD5 算法数据块的核心组件。普通开发者通常不需要直接调用它，而是通过 `hash.Hash` 接口进行操作。

Prompt: 
```
这是路径为go/src/crypto/md5/md5block.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
请用中文回答。

"""
// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Code generated by go run gen.go -output md5block.go; DO NOT EDIT.

package md5

import (
	"internal/byteorder"
	"math/bits"
)

func blockGeneric(dig *digest, p []byte) {
	// load state
	a, b, c, d := dig.s[0], dig.s[1], dig.s[2], dig.s[3]

	for i := 0; i <= len(p)-BlockSize; i += BlockSize {
		// eliminate bounds checks on p
		q := p[i:]
		q = q[:BlockSize:BlockSize]

		// save current state
		aa, bb, cc, dd := a, b, c, d

		// load input block
		x0 := byteorder.LEUint32(q[4*0x0:])
		x1 := byteorder.LEUint32(q[4*0x1:])
		x2 := byteorder.LEUint32(q[4*0x2:])
		x3 := byteorder.LEUint32(q[4*0x3:])
		x4 := byteorder.LEUint32(q[4*0x4:])
		x5 := byteorder.LEUint32(q[4*0x5:])
		x6 := byteorder.LEUint32(q[4*0x6:])
		x7 := byteorder.LEUint32(q[4*0x7:])
		x8 := byteorder.LEUint32(q[4*0x8:])
		x9 := byteorder.LEUint32(q[4*0x9:])
		xa := byteorder.LEUint32(q[4*0xa:])
		xb := byteorder.LEUint32(q[4*0xb:])
		xc := byteorder.LEUint32(q[4*0xc:])
		xd := byteorder.LEUint32(q[4*0xd:])
		xe := byteorder.LEUint32(q[4*0xe:])
		xf := byteorder.LEUint32(q[4*0xf:])

		// round 1
		a = b + bits.RotateLeft32((((c^d)&b)^d)+a+x0+0xd76aa478, 7)
		d = a + bits.RotateLeft32((((b^c)&a)^c)+d+x1+0xe8c7b756, 12)
		c = d + bits.RotateLeft32((((a^b)&d)^b)+c+x2+0x242070db, 17)
		b = c + bits.RotateLeft32((((d^a)&c)^a)+b+x3+0xc1bdceee, 22)
		a = b + bits.RotateLeft32((((c^d)&b)^d)+a+x4+0xf57c0faf, 7)
		d = a + bits.RotateLeft32((((b^c)&a)^c)+d+x5+0x4787c62a, 12)
		c = d + bits.RotateLeft32((((a^b)&d)^b)+c+x6+0xa8304613, 17)
		b = c + bits.RotateLeft32((((d^a)&c)^a)+b+x7+0xfd469501, 22)
		a = b + bits.RotateLeft32((((c^d)&b)^d)+a+x8+0x698098d8, 7)
		d = a + bits.RotateLeft32((((b^c)&a)^c)+d+x9+0x8b44f7af, 12)
		c = d + bits.RotateLeft32((((a^b)&d)^b)+c+xa+0xffff5bb1, 17)
		b = c + bits.RotateLeft32((((d^a)&c)^a)+b+xb+0x895cd7be, 22)
		a = b + bits.RotateLeft32((((c^d)&b)^d)+a+xc+0x6b901122, 7)
		d = a + bits.RotateLeft32((((b^c)&a)^c)+d+xd+0xfd987193, 12)
		c = d + bits.RotateLeft32((((a^b)&d)^b)+c+xe+0xa679438e, 17)
		b = c + bits.RotateLeft32((((d^a)&c)^a)+b+xf+0x49b40821, 22)

		// round 2
		a = b + bits.RotateLeft32((((b^c)&d)^c)+a+x1+0xf61e2562, 5)
		d = a + bits.RotateLeft32((((a^b)&c)^b)+d+x6+0xc040b340, 9)
		c = d + bits.RotateLeft32((((d^a)&b)^a)+c+xb+0x265e5a51, 14)
		b = c + bits.RotateLeft32((((c^d)&a)^d)+b+x0+0xe9b6c7aa, 20)
		a = b + bits.RotateLeft32((((b^c)&d)^c)+a+x5+0xd62f105d, 5)
		d = a + bits.RotateLeft32((((a^b)&c)^b)+d+xa+0x02441453, 9)
		c = d + bits.RotateLeft32((((d^a)&b)^a)+c+xf+0xd8a1e681, 14)
		b = c + bits.RotateLeft32((((c^d)&a)^d)+b+x4+0xe7d3fbc8, 20)
		a = b + bits.RotateLeft32((((b^c)&d)^c)+a+x9+0x21e1cde6, 5)
		d = a + bits.RotateLeft32((((a^b)&c)^b)+d+xe+0xc33707d6, 9)
		c = d + bits.RotateLeft32((((d^a)&b)^a)+c+x3+0xf4d50d87, 14)
		b = c + bits.RotateLeft32((((c^d)&a)^d)+b+x8+0x455a14ed, 20)
		a = b + bits.RotateLeft32((((b^c)&d)^c)+a+xd+0xa9e3e905, 5)
		d = a + bits.RotateLeft32((((a^b)&c)^b)+d+x2+0xfcefa3f8, 9)
		c = d + bits.RotateLeft32((((d^a)&b)^a)+c+x7+0x676f02d9, 14)
		b = c + bits.RotateLeft32((((c^d)&a)^d)+b+xc+0x8d2a4c8a, 20)

		// round 3
		a = b + bits.RotateLeft32((b^c^d)+a+x5+0xfffa3942, 4)
		d = a + bits.RotateLeft32((a^b^c)+d+x8+0x8771f681, 11)
		c = d + bits.RotateLeft32((d^a^b)+c+xb+0x6d9d6122, 16)
		b = c + bits.RotateLeft32((c^d^a)+b+xe+0xfde5380c, 23)
		a = b + bits.RotateLeft32((b^c^d)+a+x1+0xa4beea44, 4)
		d = a + bits.RotateLeft32((a^b^c)+d+x4+0x4bdecfa9, 11)
		c = d + bits.RotateLeft32((d^a^b)+c+x7+0xf6bb4b60, 16)
		b = c + bits.RotateLeft32((c^d^a)+b+xa+0xbebfbc70, 23)
		a = b + bits.RotateLeft32((b^c^d)+a+xd+0x289b7ec6, 4)
		d = a + bits.RotateLeft32((a^b^c)+d+x0+0xeaa127fa, 11)
		c = d + bits.RotateLeft32((d^a^b)+c+x3+0xd4ef3085, 16)
		b = c + bits.RotateLeft32((c^d^a)+b+x6+0x04881d05, 23)
		a = b + bits.RotateLeft32((b^c^d)+a+x9+0xd9d4d039, 4)
		d = a + bits.RotateLeft32((a^b^c)+d+xc+0xe6db99e5, 11)
		c = d + bits.RotateLeft32((d^a^b)+c+xf+0x1fa27cf8, 16)
		b = c + bits.RotateLeft32((c^d^a)+b+x2+0xc4ac5665, 23)

		// round 4
		a = b + bits.RotateLeft32((c^(b|^d))+a+x0+0xf4292244, 6)
		d = a + bits.RotateLeft32((b^(a|^c))+d+x7+0x432aff97, 10)
		c = d + bits.RotateLeft32((a^(d|^b))+c+xe+0xab9423a7, 15)
		b = c + bits.RotateLeft32((d^(c|^a))+b+x5+0xfc93a039, 21)
		a = b + bits.RotateLeft32((c^(b|^d))+a+xc+0x655b59c3, 6)
		d = a + bits.RotateLeft32((b^(a|^c))+d+x3+0x8f0ccc92, 10)
		c = d + bits.RotateLeft32((a^(d|^b))+c+xa+0xffeff47d, 15)
		b = c + bits.RotateLeft32((d^(c|^a))+b+x1+0x85845dd1, 21)
		a = b + bits.RotateLeft32((c^(b|^d))+a+x8+0x6fa87e4f, 6)
		d = a + bits.RotateLeft32((b^(a|^c))+d+xf+0xfe2ce6e0, 10)
		c = d + bits.RotateLeft32((a^(d|^b))+c+x6+0xa3014314, 15)
		b = c + bits.RotateLeft32((d^(c|^a))+b+xd+0x4e0811a1, 21)
		a = b + bits.RotateLeft32((c^(b|^d))+a+x4+0xf7537e82, 6)
		d = a + bits.RotateLeft32((b^(a|^c))+d+xb+0xbd3af235, 10)
		c = d + bits.RotateLeft32((a^(d|^b))+c+x2+0x2ad7d2bb, 15)
		b = c + bits.RotateLeft32((d^(c|^a))+b+x9+0xeb86d391, 21)

		// add saved state
		a += aa
		b += bb
		c += cc
		d += dd
	}

	// save state
	dig.s[0], dig.s[1], dig.s[2], dig.s[3] = a, b, c, d
}

"""



```
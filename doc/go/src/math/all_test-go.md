Response:
Let's break down the thought process for analyzing this Go code snippet.

1. **Identify the Core Purpose:** The first line, `// Copyright 2009 The Go Authors. All rights reserved.`, and the file path `go/src/math/all_test.go` immediately suggest this is a *test file* for the `math` package in Go's standard library. The `_test` suffix is a strong indicator of testing.

2. **Import Analysis:**  Examine the `import` statements:
    * `"fmt"`:  Likely used for printing or formatting output, probably during test failures or debugging.
    * `. "math"`: This is a key import. The dot (`.`) means that names exported from the `math` package can be used directly in this test file *without* the `math.` prefix. This tells us the file is testing functions and constants within the `math` package.
    * `"testing"`:  This is the standard Go testing library. It provides the `*testing.T` type and functions like `t.Error`, `t.Fatal`, etc., which are essential for writing tests.
    * `"unsafe"`:  This is a special package for low-level operations. Its presence suggests that some tests might involve inspecting memory layout or performing operations that bypass Go's usual type safety. This often comes up when dealing with the underlying representation of floating-point numbers.

3. **Variable Declaration and Initialization:**  The code defines numerous variables with names like `vf`, `acos`, `acosh`, `asin`, etc. Notice the pattern:
    * `vf`:  A slice of `float64` values. The name likely means "values for floats" or something similar. These appear to be the *inputs* for the tests.
    * `acos`, `acosh`, `asin`, etc.: Slices of `float64` values that correspond to the expected *outputs* of the `math` package functions (acos, acosh, asin, etc.) when given the input values in `vf`. The comments referencing `keisan.casio.com` strongly support this interpretation.

4. **Data Structure Analysis:** The `fi` struct with fields `f float64` and `i int` appears in conjunction with the `frexp` variable. This strongly suggests that the `frexp` function (which decomposes a floating-point number into its mantissa and exponent) is being tested, and this struct is used to hold the expected mantissa (`f`) and exponent (`i`).

5. **Special Case Testing:**  The variables with the `SC` suffix (e.g., `vfacosSC`, `acosSC`, `vfatan2SC`, `atan2SC`) clearly indicate testing of *special cases*. The values within these variables (like `Inf(-1)`, `NaN()`, `Copysign(0, -1)`, `Pi`) are common edge cases and special values in floating-point arithmetic. The paired nature (e.g., `vfacosSC` providing inputs, `acosSC` providing expected outputs) reinforces the testing purpose.

6. **Large Value Testing:** Variables like `cosLarge`, `sinLarge`, and `expm1Large` suggest testing the behavior of trigonometric and exponential functions with very large input values. This is important for ensuring accuracy and handling potential overflow/underflow scenarios. The comment mentioning `100000 * Pi` confirms this.

7. **Naming Conventions:** The consistent naming conventions (e.g., `vf` for input values, function names for output values, `SC` for special cases) make the code more readable and easier to understand its purpose.

8. **Inferring Go Functionality:** Based on the variable names and the `math` package import, it's possible to infer that this file tests various mathematical functions:
    * Trigonometric functions: `Sin`, `Cos`, `Tan`, `Asin`, `Acos`, `Atan`, `Atan2`
    * Hyperbolic functions: `Sinh`, `Cosh`, `Tanh`, `Asinh`, `Acosh`, `Atanh`
    * Exponential and logarithmic functions: `Exp`, `Exp2`, `Expm1`, `Log`, `Log10`, `Log1p`, `Log2`, `Logb`
    * Rounding and truncation functions: `Ceil`, `Floor`, `Round`, `Trunc`, `Modf`
    * Power and root functions: `Pow`, `Sqrt`, `Cbrt`
    * Error functions: `Erf`, `Erfc`, `Erfinv`, `Erfcinv`
    * Bessel functions: `J0`, `J1`, `Jn`, `Y0`, `Y1`, `Yn`
    * Floating-point manipulation: `Copysign`, `Abs`, `Fdim`, `Fmax`, `Fmin`, `Fmod`, `Frexp`, `Ldexp`, `Nextafter`, `Signbit`
    * Gamma function: `Gamma`, `Lgamma`
    * Hypot function: `Hypot`
    * Integer logarithm base 2: `Ilogb`

9. **Hypothetical Code Example (Based on Inference):**  Knowing this is a test file, one can imagine a test function for `math.Acos`:

   ```go
   func TestAcos(t *testing.T) {
       for i, v := range vf {
           if v >= -1 && v <= 1 { // acos is defined for [-1, 1]
               expected := acos[i]
               actual := Acos(v)
               if !equalFloat64(actual, expected) { // Need a helper function for float comparison
                   t.Errorf("Acos(%f) got %f, expected %f", v, actual, expected)
               }
           }
       }
   }

   // Helper function for comparing float64 with some tolerance
   func equalFloat64(a, b float64) bool {
       const epsilon = 1e-9
       return Abs(a-b) < epsilon
   }
   ```

10. **Refining the Understanding:** By combining the information from the imports, variable names, and comments, a clear picture emerges: this Go file is a comprehensive test suite for the `math` package, covering a wide range of functions and edge cases. The use of pre-calculated values from external sources like Casio calculators indicates a focus on numerical accuracy.

This systematic approach of examining the code's components and their relationships allows for a robust understanding of its purpose, even without seeing the actual test functions.
这个文件 `go/src/math/all_test.go` 是 Go 语言标准库 `math` 包的一部分，专门用于测试 `math` 包中所有（或大部分）的数学函数的功能和精度。

**功能归纳:**

这个文件的主要功能是提供一组预定义的测试用例，用于验证 `math` 包中各种数学函数的正确性。它包含了：

1. **测试输入数据 (vf):**  定义了一个 `float64` 类型的切片 `vf`，包含了一系列用于测试的浮点数输入值。

2. **预期的输出结果:**  针对 `vf` 中的输入值，定义了多个 `float64` 类型的切片（如 `acos`, `acosh`, `asin`, `asinh` 等），分别对应 `math` 包中不同数学函数的预期输出结果。这些预期结果通常是通过高精度计算器计算得到的。

3. **特殊情况的测试数据和预期结果:**  定义了以 `SC` 结尾的变量（如 `vfacosSC`, `acosSC`, `vfatan2SC`, `atan2SC` 等），用于测试各种数学函数在特殊输入情况下的行为，例如无穷大 (Inf)、负无穷大 (-Inf)、非数字 (NaN)、正零和负零等。

4. **大数据量的测试数据和预期结果:** 定义了以 `Large` 结尾的变量（如 `cosLarge`, `sinLarge`, `expm1Large`），用于测试某些三角函数和指数函数在大数值输入下的行为。

5. **结构体用于测试特定函数:** 定义了 `fi` 结构体，用于测试返回多个值的函数，例如 `frexp` 函数，该函数将浮点数分解为尾数和指数。

**它是什么Go语言功能的实现（推断）:**

这个文件本身并不是一个 Go 语言功能的实现，而是一个测试套件，用于验证 `math` 包中已实现的 Go 语言功能。它利用 Go 语言的测试框架 (`testing` 包) 来组织和执行测试。

**Go 代码举例说明 (假设的测试函数):**

假设我们要测试 `math.Acos` 函数，该函数计算反余弦值。基于 `all_test.go` 中的数据，我们可以推断出类似以下的测试函数：

```go
func TestAcos(t *testing.T) {
	for i, v := range vf {
		if v >= -1 && v <= 1 { // Acos 的定义域是 [-1, 1]
			expected := acos[i]
			actual := Acos(v)
			// 由于浮点数精度问题，不能直接用 == 比较，需要设置一个误差范围
			if Abs(actual-expected) > 1e-15 {
				t.Errorf("Acos(%f) = %f, expected %f", v, actual, expected)
			}
		}
	}
}
```

**假设的输入与输出:**

在这个 `TestAcos` 函数中，假设 `vf` 的前几个元素是：

```
vf = []float64{
	0.5,
	1.0,
	0.0,
	-0.5,
}
```

那么，根据 `acos` 变量的定义，预期的输出应该是：

```
acos = []float64{
	Pi / 3,     // 约 1.047
	0.0,
	Pi / 2,     // 约 1.571
	2 * Pi / 3, // 约 2.094
}
```

测试函数会遍历 `vf` 中的每个值，调用 `Acos` 函数，并将实际结果与 `acos` 中对应的预期结果进行比较。

**命令行参数的具体处理:**

这个文件本身不直接处理命令行参数。Go 语言的测试框架 `go test` 命令会负责执行测试。你可以使用 `go test math` 命令来运行 `math` 包下的所有测试文件，包括 `all_test.go`。 `go test` 命令本身有一些参数，例如 `-v` (显示详细输出), `-run <regexp>` (运行匹配正则表达式的测试函数) 等。这些参数由 `go test` 命令处理，而不是 `all_test.go` 文件。

**使用者易犯错的点:**

在编写 `math` 包的测试时，使用者容易犯以下错误：

1. **直接使用 `==` 比较浮点数:** 由于浮点数的精度问题，直接使用 `==` 比较两个浮点数是否相等是不可靠的。应该使用一个小的误差范围（epsilon）来判断两个浮点数是否足够接近。例如：`Abs(a - b) < epsilon`。

   ```go
   // 错误的做法
   if Acos(0.5) == Pi/3 {
       // ...
   }

   // 正确的做法
   epsilon := 1e-15
   if Abs(Acos(0.5) - Pi/3) < epsilon {
       // ...
   }
   ```

2. **忽略特殊情况:**  忘记测试各种边界情况和特殊值，例如 NaN、无穷大、正零和负零。`all_test.go` 中大量的 `SC` 变量就是为了覆盖这些情况。

3. **精度不足的预期结果:**  如果预期结果的精度不足，会导致测试失败。`all_test.go` 中通过使用高精度计算器来获得更准确的预期结果。

**总结一下它的功能:**

`go/src/math/all_test.go` 的主要功能是提供一个全面的测试套件，用于验证 Go 语言标准库 `math` 包中各种数学函数的正确性和精度。它包含了一系列预定义的输入数据、预期输出结果以及针对特殊情况和大数据量的测试用例，确保 `math` 包的可靠性。

Prompt: 
```
这是路径为go/src/math/all_test.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
请用中文回答。
这是第1部分，共3部分，请归纳一下它的功能

"""
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package math_test

import (
	"fmt"
	. "math"
	"testing"
	"unsafe"
)

var vf = []float64{
	4.9790119248836735e+00,
	7.7388724745781045e+00,
	-2.7688005719200159e-01,
	-5.0106036182710749e+00,
	9.6362937071984173e+00,
	2.9263772392439646e+00,
	5.2290834314593066e+00,
	2.7279399104360102e+00,
	1.8253080916808550e+00,
	-8.6859247685756013e+00,
}

// The expected results below were computed by the high precision calculators
// at https://keisan.casio.com/.  More exact input values (array vf[], above)
// were obtained by printing them with "%.26f".  The answers were calculated
// to 26 digits (by using the "Digit number" drop-down control of each
// calculator).
var acos = []float64{
	1.0496193546107222142571536e+00,
	6.8584012813664425171660692e-01,
	1.5984878714577160325521819e+00,
	2.0956199361475859327461799e+00,
	2.7053008467824138592616927e-01,
	1.2738121680361776018155625e+00,
	1.0205369421140629186287407e+00,
	1.2945003481781246062157835e+00,
	1.3872364345374451433846657e+00,
	2.6231510803970463967294145e+00,
}
var acosh = []float64{
	2.4743347004159012494457618e+00,
	2.8576385344292769649802701e+00,
	7.2796961502981066190593175e-01,
	2.4796794418831451156471977e+00,
	3.0552020742306061857212962e+00,
	2.044238592688586588942468e+00,
	2.5158701513104513595766636e+00,
	1.99050839282411638174299e+00,
	1.6988625798424034227205445e+00,
	2.9611454842470387925531875e+00,
}
var asin = []float64{
	5.2117697218417440497416805e-01,
	8.8495619865825236751471477e-01,
	-02.769154466281941332086016e-02,
	-5.2482360935268931351485822e-01,
	1.3002662421166552333051524e+00,
	2.9698415875871901741575922e-01,
	5.5025938468083370060258102e-01,
	2.7629597861677201301553823e-01,
	1.83559892257451475846656e-01,
	-1.0523547536021497774980928e+00,
}
var asinh = []float64{
	2.3083139124923523427628243e+00,
	2.743551594301593620039021e+00,
	-2.7345908534880091229413487e-01,
	-2.3145157644718338650499085e+00,
	2.9613652154015058521951083e+00,
	1.7949041616585821933067568e+00,
	2.3564032905983506405561554e+00,
	1.7287118790768438878045346e+00,
	1.3626658083714826013073193e+00,
	-2.8581483626513914445234004e+00,
}
var atan = []float64{
	1.372590262129621651920085e+00,
	1.442290609645298083020664e+00,
	-2.7011324359471758245192595e-01,
	-1.3738077684543379452781531e+00,
	1.4673921193587666049154681e+00,
	1.2415173565870168649117764e+00,
	1.3818396865615168979966498e+00,
	1.2194305844639670701091426e+00,
	1.0696031952318783760193244e+00,
	-1.4561721938838084990898679e+00,
}
var atanh = []float64{
	5.4651163712251938116878204e-01,
	1.0299474112843111224914709e+00,
	-2.7695084420740135145234906e-02,
	-5.5072096119207195480202529e-01,
	1.9943940993171843235906642e+00,
	3.01448604578089708203017e-01,
	5.8033427206942188834370595e-01,
	2.7987997499441511013958297e-01,
	1.8459947964298794318714228e-01,
	-1.3273186910532645867272502e+00,
}
var atan2 = []float64{
	1.1088291730037004444527075e+00,
	9.1218183188715804018797795e-01,
	1.5984772603216203736068915e+00,
	2.0352918654092086637227327e+00,
	8.0391819139044720267356014e-01,
	1.2861075249894661588866752e+00,
	1.0889904479131695712182587e+00,
	1.3044821793397925293797357e+00,
	1.3902530903455392306872261e+00,
	2.2859857424479142655411058e+00,
}
var cbrt = []float64{
	1.7075799841925094446722675e+00,
	1.9779982212970353936691498e+00,
	-6.5177429017779910853339447e-01,
	-1.7111838886544019873338113e+00,
	2.1279920909827937423960472e+00,
	1.4303536770460741452312367e+00,
	1.7357021059106154902341052e+00,
	1.3972633462554328350552916e+00,
	1.2221149580905388454977636e+00,
	-2.0556003730500069110343596e+00,
}
var ceil = []float64{
	5.0000000000000000e+00,
	8.0000000000000000e+00,
	Copysign(0, -1),
	-5.0000000000000000e+00,
	1.0000000000000000e+01,
	3.0000000000000000e+00,
	6.0000000000000000e+00,
	3.0000000000000000e+00,
	2.0000000000000000e+00,
	-8.0000000000000000e+00,
}
var copysign = []float64{
	-4.9790119248836735e+00,
	-7.7388724745781045e+00,
	-2.7688005719200159e-01,
	-5.0106036182710749e+00,
	-9.6362937071984173e+00,
	-2.9263772392439646e+00,
	-5.2290834314593066e+00,
	-2.7279399104360102e+00,
	-1.8253080916808550e+00,
	-8.6859247685756013e+00,
}
var cos = []float64{
	2.634752140995199110787593e-01,
	1.148551260848219865642039e-01,
	9.6191297325640768154550453e-01,
	2.938141150061714816890637e-01,
	-9.777138189897924126294461e-01,
	-9.7693041344303219127199518e-01,
	4.940088096948647263961162e-01,
	-9.1565869021018925545016502e-01,
	-2.517729313893103197176091e-01,
	-7.39241351595676573201918e-01,
}

// Results for 100000 * Pi + vf[i]
var cosLarge = []float64{
	2.634752141185559426744e-01,
	1.14855126055543100712e-01,
	9.61912973266488928113e-01,
	2.9381411499556122552e-01,
	-9.777138189880161924641e-01,
	-9.76930413445147608049e-01,
	4.940088097314976789841e-01,
	-9.15658690217517835002e-01,
	-2.51772931436786954751e-01,
	-7.3924135157173099849e-01,
}

var cosh = []float64{
	7.2668796942212842775517446e+01,
	1.1479413465659254502011135e+03,
	1.0385767908766418550935495e+00,
	7.5000957789658051428857788e+01,
	7.655246669605357888468613e+03,
	9.3567491758321272072888257e+00,
	9.331351599270605471131735e+01,
	7.6833430994624643209296404e+00,
	3.1829371625150718153881164e+00,
	2.9595059261916188501640911e+03,
}
var erf = []float64{
	5.1865354817738701906913566e-01,
	7.2623875834137295116929844e-01,
	-3.123458688281309990629839e-02,
	-5.2143121110253302920437013e-01,
	8.2704742671312902508629582e-01,
	3.2101767558376376743993945e-01,
	5.403990312223245516066252e-01,
	3.0034702916738588551174831e-01,
	2.0369924417882241241559589e-01,
	-7.8069386968009226729944677e-01,
}
var erfc = []float64{
	4.8134645182261298093086434e-01,
	2.7376124165862704883070156e-01,
	1.0312345868828130999062984e+00,
	1.5214312111025330292043701e+00,
	1.7295257328687097491370418e-01,
	6.7898232441623623256006055e-01,
	4.596009687776754483933748e-01,
	6.9965297083261411448825169e-01,
	7.9630075582117758758440411e-01,
	1.7806938696800922672994468e+00,
}
var erfinv = []float64{
	4.746037673358033586786350696e-01,
	8.559054432692110956388764172e-01,
	-2.45427830571707336251331946e-02,
	-4.78116683518973366268905506e-01,
	1.479804430319470983648120853e+00,
	2.654485787128896161882650211e-01,
	5.027444534221520197823192493e-01,
	2.466703532707627818954585670e-01,
	1.632011465103005426240343116e-01,
	-1.06672334642196900710000389e+00,
}
var exp = []float64{
	1.4533071302642137507696589e+02,
	2.2958822575694449002537581e+03,
	7.5814542574851666582042306e-01,
	6.6668778421791005061482264e-03,
	1.5310493273896033740861206e+04,
	1.8659907517999328638667732e+01,
	1.8662167355098714543942057e+02,
	1.5301332413189378961665788e+01,
	6.2047063430646876349125085e+00,
	1.6894712385826521111610438e-04,
}
var expm1 = []float64{
	5.105047796122957327384770212e-02,
	8.046199708567344080562675439e-02,
	-2.764970978891639815187418703e-03,
	-4.8871434888875355394330300273e-02,
	1.0115864277221467777117227494e-01,
	2.969616407795910726014621657e-02,
	5.368214487944892300914037972e-02,
	2.765488851131274068067445335e-02,
	1.842068661871398836913874273e-02,
	-8.3193870863553801814961137573e-02,
}
var expm1Large = []float64{
	4.2031418113550844e+21,
	4.0690789717473863e+33,
	-0.9372627915981363e+00,
	-1.0,
	7.077694784145933e+41,
	5.117936223839153e+12,
	5.124137759001189e+22,
	7.03546003972584e+11,
	8.456921800389698e+07,
	-1.0,
}
var exp2 = []float64{
	3.1537839463286288034313104e+01,
	2.1361549283756232296144849e+02,
	8.2537402562185562902577219e-01,
	3.1021158628740294833424229e-02,
	7.9581744110252191462569661e+02,
	7.6019905892596359262696423e+00,
	3.7506882048388096973183084e+01,
	6.6250893439173561733216375e+00,
	3.5438267900243941544605339e+00,
	2.4281533133513300984289196e-03,
}
var fabs = []float64{
	4.9790119248836735e+00,
	7.7388724745781045e+00,
	2.7688005719200159e-01,
	5.0106036182710749e+00,
	9.6362937071984173e+00,
	2.9263772392439646e+00,
	5.2290834314593066e+00,
	2.7279399104360102e+00,
	1.8253080916808550e+00,
	8.6859247685756013e+00,
}
var fdim = []float64{
	4.9790119248836735e+00,
	7.7388724745781045e+00,
	0.0000000000000000e+00,
	0.0000000000000000e+00,
	9.6362937071984173e+00,
	2.9263772392439646e+00,
	5.2290834314593066e+00,
	2.7279399104360102e+00,
	1.8253080916808550e+00,
	0.0000000000000000e+00,
}
var floor = []float64{
	4.0000000000000000e+00,
	7.0000000000000000e+00,
	-1.0000000000000000e+00,
	-6.0000000000000000e+00,
	9.0000000000000000e+00,
	2.0000000000000000e+00,
	5.0000000000000000e+00,
	2.0000000000000000e+00,
	1.0000000000000000e+00,
	-9.0000000000000000e+00,
}
var fmod = []float64{
	4.197615023265299782906368e-02,
	2.261127525421895434476482e+00,
	3.231794108794261433104108e-02,
	4.989396381728925078391512e+00,
	3.637062928015826201999516e-01,
	1.220868282268106064236690e+00,
	4.770916568540693347699744e+00,
	1.816180268691969246219742e+00,
	8.734595415957246977711748e-01,
	1.314075231424398637614104e+00,
}

type fi struct {
	f float64
	i int
}

var frexp = []fi{
	{6.2237649061045918750e-01, 3},
	{9.6735905932226306250e-01, 3},
	{-5.5376011438400318000e-01, -1},
	{-6.2632545228388436250e-01, 3},
	{6.02268356699901081250e-01, 4},
	{7.3159430981099115000e-01, 2},
	{6.5363542893241332500e-01, 3},
	{6.8198497760900255000e-01, 2},
	{9.1265404584042750000e-01, 1},
	{-5.4287029803597508250e-01, 4},
}
var gamma = []float64{
	2.3254348370739963835386613898e+01,
	2.991153837155317076427529816e+03,
	-4.561154336726758060575129109e+00,
	7.719403468842639065959210984e-01,
	1.6111876618855418534325755566e+05,
	1.8706575145216421164173224946e+00,
	3.4082787447257502836734201635e+01,
	1.579733951448952054898583387e+00,
	9.3834586598354592860187267089e-01,
	-2.093995902923148389186189429e-05,
}
var j0 = []float64{
	-1.8444682230601672018219338e-01,
	2.27353668906331975435892e-01,
	9.809259936157051116270273e-01,
	-1.741170131426226587841181e-01,
	-2.1389448451144143352039069e-01,
	-2.340905848928038763337414e-01,
	-1.0029099691890912094586326e-01,
	-1.5466726714884328135358907e-01,
	3.252650187653420388714693e-01,
	-8.72218484409407250005360235e-03,
}
var j1 = []float64{
	-3.251526395295203422162967e-01,
	1.893581711430515718062564e-01,
	-1.3711761352467242914491514e-01,
	3.287486536269617297529617e-01,
	1.3133899188830978473849215e-01,
	3.660243417832986825301766e-01,
	-3.4436769271848174665420672e-01,
	4.329481396640773768835036e-01,
	5.8181350531954794639333955e-01,
	-2.7030574577733036112996607e-01,
}
var j2 = []float64{
	5.3837518920137802565192769e-02,
	-1.7841678003393207281244667e-01,
	9.521746934916464142495821e-03,
	4.28958355470987397983072e-02,
	2.4115371837854494725492872e-01,
	4.842458532394520316844449e-01,
	-3.142145220618633390125946e-02,
	4.720849184745124761189957e-01,
	3.122312022520957042957497e-01,
	7.096213118930231185707277e-02,
}
var jM3 = []float64{
	-3.684042080996403091021151e-01,
	2.8157665936340887268092661e-01,
	4.401005480841948348343589e-04,
	3.629926999056814081597135e-01,
	3.123672198825455192489266e-02,
	-2.958805510589623607540455e-01,
	-3.2033177696533233403289416e-01,
	-2.592737332129663376736604e-01,
	-1.0241334641061485092351251e-01,
	-2.3762660886100206491674503e-01,
}
var lgamma = []fi{
	{3.146492141244545774319734e+00, 1},
	{8.003414490659126375852113e+00, 1},
	{1.517575735509779707488106e+00, -1},
	{-2.588480028182145853558748e-01, 1},
	{1.1989897050205555002007985e+01, 1},
	{6.262899811091257519386906e-01, 1},
	{3.5287924899091566764846037e+00, 1},
	{4.5725644770161182299423372e-01, 1},
	{-6.363667087767961257654854e-02, 1},
	{-1.077385130910300066425564e+01, -1},
}
var log = []float64{
	1.605231462693062999102599e+00,
	2.0462560018708770653153909e+00,
	-1.2841708730962657801275038e+00,
	1.6115563905281545116286206e+00,
	2.2655365644872016636317461e+00,
	1.0737652208918379856272735e+00,
	1.6542360106073546632707956e+00,
	1.0035467127723465801264487e+00,
	6.0174879014578057187016475e-01,
	2.161703872847352815363655e+00,
}
var logb = []float64{
	2.0000000000000000e+00,
	2.0000000000000000e+00,
	-2.0000000000000000e+00,
	2.0000000000000000e+00,
	3.0000000000000000e+00,
	1.0000000000000000e+00,
	2.0000000000000000e+00,
	1.0000000000000000e+00,
	0.0000000000000000e+00,
	3.0000000000000000e+00,
}
var log10 = []float64{
	6.9714316642508290997617083e-01,
	8.886776901739320576279124e-01,
	-5.5770832400658929815908236e-01,
	6.998900476822994346229723e-01,
	9.8391002850684232013281033e-01,
	4.6633031029295153334285302e-01,
	7.1842557117242328821552533e-01,
	4.3583479968917773161304553e-01,
	2.6133617905227038228626834e-01,
	9.3881606348649405716214241e-01,
}
var log1p = []float64{
	4.8590257759797794104158205e-02,
	7.4540265965225865330849141e-02,
	-2.7726407903942672823234024e-03,
	-5.1404917651627649094953380e-02,
	9.1998280672258624681335010e-02,
	2.8843762576593352865894824e-02,
	5.0969534581863707268992645e-02,
	2.6913947602193238458458594e-02,
	1.8088493239630770262045333e-02,
	-9.0865245631588989681559268e-02,
}
var log2 = []float64{
	2.3158594707062190618898251e+00,
	2.9521233862883917703341018e+00,
	-1.8526669502700329984917062e+00,
	2.3249844127278861543568029e+00,
	3.268478366538305087466309e+00,
	1.5491157592596970278166492e+00,
	2.3865580889631732407886495e+00,
	1.447811865817085365540347e+00,
	8.6813999540425116282815557e-01,
	3.118679457227342224364709e+00,
}
var modf = [][2]float64{
	{4.0000000000000000e+00, 9.7901192488367350108546816e-01},
	{7.0000000000000000e+00, 7.3887247457810456552351752e-01},
	{Copysign(0, -1), -2.7688005719200159404635997e-01},
	{-5.0000000000000000e+00, -1.060361827107492160848778e-02},
	{9.0000000000000000e+00, 6.3629370719841737980004837e-01},
	{2.0000000000000000e+00, 9.2637723924396464525443662e-01},
	{5.0000000000000000e+00, 2.2908343145930665230025625e-01},
	{2.0000000000000000e+00, 7.2793991043601025126008608e-01},
	{1.0000000000000000e+00, 8.2530809168085506044576505e-01},
	{-8.0000000000000000e+00, -6.8592476857560136238589621e-01},
}
var nextafter32 = []float32{
	4.979012489318848e+00,
	7.738873004913330e+00,
	-2.768800258636475e-01,
	-5.010602951049805e+00,
	9.636294364929199e+00,
	2.926377534866333e+00,
	5.229084014892578e+00,
	2.727940082550049e+00,
	1.825308203697205e+00,
	-8.685923576354980e+00,
}
var nextafter64 = []float64{
	4.97901192488367438926388786e+00,
	7.73887247457810545370193722e+00,
	-2.7688005719200153853520874e-01,
	-5.01060361827107403343006808e+00,
	9.63629370719841915615688777e+00,
	2.92637723924396508934364647e+00,
	5.22908343145930754047867595e+00,
	2.72793991043601069534929593e+00,
	1.82530809168085528249036997e+00,
	-8.68592476857559958602905681e+00,
}
var pow = []float64{
	9.5282232631648411840742957e+04,
	5.4811599352999901232411871e+07,
	5.2859121715894396531132279e-01,
	9.7587991957286474464259698e-06,
	4.328064329346044846740467e+09,
	8.4406761805034547437659092e+02,
	1.6946633276191194947742146e+05,
	5.3449040147551939075312879e+02,
	6.688182138451414936380374e+01,
	2.0609869004248742886827439e-09,
}
var remainder = []float64{
	4.197615023265299782906368e-02,
	2.261127525421895434476482e+00,
	3.231794108794261433104108e-02,
	-2.120723654214984321697556e-02,
	3.637062928015826201999516e-01,
	1.220868282268106064236690e+00,
	-4.581668629186133046005125e-01,
	-9.117596417440410050403443e-01,
	8.734595415957246977711748e-01,
	1.314075231424398637614104e+00,
}
var round = []float64{
	5,
	8,
	Copysign(0, -1),
	-5,
	10,
	3,
	5,
	3,
	2,
	-9,
}
var signbit = []bool{
	false,
	false,
	true,
	true,
	false,
	false,
	false,
	false,
	false,
	true,
}
var sin = []float64{
	-9.6466616586009283766724726e-01,
	9.9338225271646545763467022e-01,
	-2.7335587039794393342449301e-01,
	9.5586257685042792878173752e-01,
	-2.099421066779969164496634e-01,
	2.135578780799860532750616e-01,
	-8.694568971167362743327708e-01,
	4.019566681155577786649878e-01,
	9.6778633541687993721617774e-01,
	-6.734405869050344734943028e-01,
}

// Results for 100000 * Pi + vf[i]
var sinLarge = []float64{
	-9.646661658548936063912e-01,
	9.933822527198506903752e-01,
	-2.7335587036246899796e-01,
	9.55862576853689321268e-01,
	-2.099421066862688873691e-01,
	2.13557878070308981163e-01,
	-8.694568970959221300497e-01,
	4.01956668098863248917e-01,
	9.67786335404528727927e-01,
	-6.7344058693131973066e-01,
}
var sinh = []float64{
	7.2661916084208532301448439e+01,
	1.1479409110035194500526446e+03,
	-2.8043136512812518927312641e-01,
	-7.499429091181587232835164e+01,
	7.6552466042906758523925934e+03,
	9.3031583421672014313789064e+00,
	9.330815755828109072810322e+01,
	7.6179893137269146407361477e+00,
	3.021769180549615819524392e+00,
	-2.95950575724449499189888e+03,
}
var sqrt = []float64{
	2.2313699659365484748756904e+00,
	2.7818829009464263511285458e+00,
	5.2619393496314796848143251e-01,
	2.2384377628763938724244104e+00,
	3.1042380236055381099288487e+00,
	1.7106657298385224403917771e+00,
	2.286718922705479046148059e+00,
	1.6516476350711159636222979e+00,
	1.3510396336454586262419247e+00,
	2.9471892997524949215723329e+00,
}
var tan = []float64{
	-3.661316565040227801781974e+00,
	8.64900232648597589369854e+00,
	-2.8417941955033612725238097e-01,
	3.253290185974728640827156e+00,
	2.147275640380293804770778e-01,
	-2.18600910711067004921551e-01,
	-1.760002817872367935518928e+00,
	-4.389808914752818126249079e-01,
	-3.843885560201130679995041e+00,
	9.10988793377685105753416e-01,
}

// Results for 100000 * Pi + vf[i]
var tanLarge = []float64{
	-3.66131656475596512705e+00,
	8.6490023287202547927e+00,
	-2.841794195104782406e-01,
	3.2532901861033120983e+00,
	2.14727564046880001365e-01,
	-2.18600910700688062874e-01,
	-1.760002817699722747043e+00,
	-4.38980891453536115952e-01,
	-3.84388555942723509071e+00,
	9.1098879344275101051e-01,
}
var tanh = []float64{
	9.9990531206936338549262119e-01,
	9.9999962057085294197613294e-01,
	-2.7001505097318677233756845e-01,
	-9.9991110943061718603541401e-01,
	9.9999999146798465745022007e-01,
	9.9427249436125236705001048e-01,
	9.9994257600983138572705076e-01,
	9.9149409509772875982054701e-01,
	9.4936501296239685514466577e-01,
	-9.9999994291374030946055701e-01,
}
var trunc = []float64{
	4.0000000000000000e+00,
	7.0000000000000000e+00,
	Copysign(0, -1),
	-5.0000000000000000e+00,
	9.0000000000000000e+00,
	2.0000000000000000e+00,
	5.0000000000000000e+00,
	2.0000000000000000e+00,
	1.0000000000000000e+00,
	-8.0000000000000000e+00,
}
var y0 = []float64{
	-3.053399153780788357534855e-01,
	1.7437227649515231515503649e-01,
	-8.6221781263678836910392572e-01,
	-3.100664880987498407872839e-01,
	1.422200649300982280645377e-01,
	4.000004067997901144239363e-01,
	-3.3340749753099352392332536e-01,
	4.5399790746668954555205502e-01,
	4.8290004112497761007536522e-01,
	2.7036697826604756229601611e-01,
}
var y1 = []float64{
	0.15494213737457922210218611,
	-0.2165955142081145245075746,
	-2.4644949631241895201032829,
	0.1442740489541836405154505,
	0.2215379960518984777080163,
	0.3038800915160754150565448,
	0.0691107642452362383808547,
	0.2380116417809914424860165,
	-0.20849492979459761009678934,
	0.0242503179793232308250804,
}
var y2 = []float64{
	0.3675780219390303613394936,
	-0.23034826393250119879267257,
	-16.939677983817727205631397,
	0.367653980523052152867791,
	-0.0962401471767804440353136,
	-0.1923169356184851105200523,
	0.35984072054267882391843766,
	-0.2794987252299739821654982,
	-0.7113490692587462579757954,
	-0.2647831587821263302087457,
}
var yM3 = []float64{
	-0.14035984421094849100895341,
	-0.097535139617792072703973,
	242.25775994555580176377379,
	-0.1492267014802818619511046,
	0.26148702629155918694500469,
	0.56675383593895176530394248,
	-0.206150264009006981070575,
	0.64784284687568332737963658,
	1.3503631555901938037008443,
	0.1461869756579956803341844,
}

// arguments and expected results for special cases
var vfacosSC = []float64{
	-Pi,
	1,
	Pi,
	NaN(),
}
var acosSC = []float64{
	NaN(),
	0,
	NaN(),
	NaN(),
}

var vfacoshSC = []float64{
	Inf(-1),
	0.5,
	1,
	Inf(1),
	NaN(),
}
var acoshSC = []float64{
	NaN(),
	NaN(),
	0,
	Inf(1),
	NaN(),
}

var vfasinSC = []float64{
	-Pi,
	Copysign(0, -1),
	0,
	Pi,
	NaN(),
}
var asinSC = []float64{
	NaN(),
	Copysign(0, -1),
	0,
	NaN(),
	NaN(),
}

var vfasinhSC = []float64{
	Inf(-1),
	Copysign(0, -1),
	0,
	Inf(1),
	NaN(),
}
var asinhSC = []float64{
	Inf(-1),
	Copysign(0, -1),
	0,
	Inf(1),
	NaN(),
}

var vfatanSC = []float64{
	Inf(-1),
	Copysign(0, -1),
	0,
	Inf(1),
	NaN(),
}
var atanSC = []float64{
	-Pi / 2,
	Copysign(0, -1),
	0,
	Pi / 2,
	NaN(),
}

var vfatanhSC = []float64{
	Inf(-1),
	-Pi,
	-1,
	Copysign(0, -1),
	0,
	1,
	Pi,
	Inf(1),
	NaN(),
}
var atanhSC = []float64{
	NaN(),
	NaN(),
	Inf(-1),
	Copysign(0, -1),
	0,
	Inf(1),
	NaN(),
	NaN(),
	NaN(),
}
var vfatan2SC = [][2]float64{
	{Inf(-1), Inf(-1)},
	{Inf(-1), -Pi},
	{Inf(-1), 0},
	{Inf(-1), +Pi},
	{Inf(-1), Inf(1)},
	{Inf(-1), NaN()},
	{-Pi, Inf(-1)},
	{-Pi, 0},
	{-Pi, Inf(1)},
	{-Pi, NaN()},
	{Copysign(0, -1), Inf(-1)},
	{Copysign(0, -1), -Pi},
	{Copysign(0, -1), Copysign(0, -1)},
	{Copysign(0, -1), 0},
	{Copysign(0, -1), +Pi},
	{Copysign(0, -1), Inf(1)},
	{Copysign(0, -1), NaN()},
	{0, Inf(-1)},
	{0, -Pi},
	{0, Copysign(0, -1)},
	{0, 0},
	{0, +Pi},
	{0, Inf(1)},
	{0, NaN()},
	{+Pi, Inf(-1)},
	{+Pi, 0},
	{+Pi, Inf(1)},
	{1.0, Inf(1)},
	{-1.0, Inf(1)},
	{+Pi, NaN()},
	{Inf(1), Inf(-1)},
	{Inf(1), -Pi},
	{Inf(1), 0},
	{Inf(1), +Pi},
	{Inf(1), Inf(1)},
	{Inf(1), NaN()},
	{NaN(), NaN()},
}
var atan2SC = []float64{
	-3 * Pi / 4,     // atan2(-Inf, -Inf)
	-Pi / 2,         // atan2(-Inf, -Pi)
	-Pi / 2,         // atan2(-Inf, +0)
	-Pi / 2,         // atan2(-Inf, +Pi)
	-Pi / 4,         // atan2(-Inf, +Inf)
	NaN(),           // atan2(-Inf, NaN)
	-Pi,             // atan2(-Pi, -Inf)
	-Pi / 2,         // atan2(-Pi, +0)
	Copysign(0, -1), // atan2(-Pi, Inf)
	NaN(),           // atan2(-Pi, NaN)
	-Pi,             // atan2(-0, -Inf)
	-Pi,             // atan2(-0, -Pi)
	-Pi,             // atan2(-0, -0)
	Copysign(0, -1), // atan2(-0, +0)
	Copysign(0, -1), // atan2(-0, +Pi)
	Copysign(0, -1), // atan2(-0, +Inf)
	NaN(),           // atan2(-0, NaN)
	Pi,              // atan2(+0, -Inf)
	Pi,              // atan2(+0, -Pi)
	Pi,              // atan2(+0, -0)
	0,               // atan2(+0, +0)
	0,               // atan2(+0, +Pi)
	0,               // atan2(+0, +Inf)
	NaN(),           // atan2(+0, NaN)
	Pi,              // atan2(+Pi, -Inf)
	Pi / 2,          // atan2(+Pi, +0)
	0,               // atan2(+Pi, +Inf)
	0,               // atan2(+1, +Inf)
	Copysign(0, -1), // atan2(-1, +Inf)
	NaN(),           // atan2(+Pi, NaN)
	3 * Pi / 4,      // atan2(+Inf, -Inf)
	Pi / 2,          // atan2(+Inf, -Pi)
	Pi / 2,          // atan2(+Inf, +0)
	Pi / 2,          // atan2(+Inf, +Pi)
	Pi / 4,          // atan2(+Inf, +Inf)
	NaN(),           // atan2(+Inf, NaN)
	NaN(),           // atan2(NaN, NaN)
}

var vfcbrtSC = []float64{
	Inf(-1),
	Copysign(0, -1),
	0,
	Inf(1),
	NaN(),
}
var cbrtSC = []float64{
	Inf(-1),
	Copysign(0, -1),
	0,
	Inf(1),
	NaN(),
}

var vfceilSC = []float64{
	Inf(-1),
	Copysign(0, -1),
	0,
	Inf(1),
	NaN(),
	1<<52 - 1,
	1<<52 - 0.5, // largest fractional float64
	1 << 52,
	-1 << 52,
	-1<<52 + 0.5, // smallest fractional float64
	-1<<52 + 1,
	1 << 53,
	-1 << 53,
}

var ceilBaseSC = []float64{
	Inf(-1),
	Copysign(0, -1),
	0,
	Inf(1),
	NaN(),
}

var ceilSC = append(ceilBaseSC,
	1<<52-1,
	1<<52,
	1<<52,
	-1<<52,
	-1<<52+1,
	-1<<52+1,
	1<<53,
	-1<<53,
)

var floorSC = append(ceilBaseSC,
	1<<52-1,
	1<<52-1,
	1<<52,
	-1<<52,
	-1<<52,
	-1<<52+1,
	1<<53,
	-1<<53,
)

var truncSC = append(ceilBaseSC,
	1<<52-1,
	1<<52-1,
	1<<52,
	-1<<52,
	-1<<52+1,
	-1<<52+1,
	1<<53,
	-1<<53,
)

var vfcopysignSC = []float64{
	Inf(-1),
	Inf(1),
	NaN(),
}
var copysignSC = []float64{
	Inf(-1),
	Inf(-1),
	NaN(),
}

var vfcosSC = []float64{
	Inf(-1),
	Inf(1),
	NaN(),
}
var cosSC = []float64{
	NaN(),
	NaN(),
	NaN(),
}

var vfcoshSC = []float64{
	Inf(-1),
	Copysign(0, -1),
	0,
	Inf(1),
	NaN(),
}
var coshSC = []float64{
	Inf(1),
	1,
	1,
	Inf(1),
	NaN(),
}

var vferfSC = []float64{
	Inf(-1),
	Copysign(0, -1),
	0,
	Inf(1),
	NaN(),
	-1000,
	1000,
}
var erfSC = []float64{
	-1,
	Copysign(0, -1),
	0,
	1,
	NaN(),
	-1,
	1,
}

var vferfcSC = []float64{
	Inf(-1),
	Inf(1),
	NaN(),
	-1000,
	1000,
}
var erfcSC = []float64{
	2,
	0,
	NaN(),
	2,
	0,
}

var vferfinvSC = []float64{
	1,
	-1,
	0,
	Inf(-1),
	Inf(1),
	NaN(),
}
var erfinvSC = []float64{
	Inf(+1),
	Inf(-1),
	0,
	NaN(),
	NaN(),
	NaN(),
}

var vferfcinvSC = []float64{
	0,
	2,
	1,
	Inf(1),
	Inf(-1),
	NaN(),
}
var erfcinvSC = []float64{
	Inf(+1),
	Inf(-1),
	0,
	NaN(),
	NaN(),
	NaN(),
}

var vfexpSC = []float64{
	Inf(-1),
	-2000,
	2000,
	Inf(1),
	NaN(),
	// smallest float64 that overflows Exp(x)
	7.097827128933841e+02,
	// Issue 18912
	1.48852223e+09,
	1.4885222e+09,
	1,
	// near zero
	3.725290298461915e-09,
	// denormal
	-740,
}
var expSC = []float64{
	0,
	0,
	Inf(1),
	Inf(1),
	NaN(),
	Inf(1),
	Inf(1),
	Inf(1),
	2.718281828459045,
	1.0000000037252903,
	4.2e-322,
}

var vfexp2SC = []float64{
	Inf(-1),
	-2000,
	2000,
	Inf(1),
	NaN(),
	// smallest float64 that overflows Exp2(x)
	1024,
	// near underflow
	-1.07399999999999e+03,
	// near zero
	3.725290298461915e-09,
}
var exp2SC = []float64{
	0,
	0,
	Inf(1),
	Inf(1),
	NaN(),
	Inf(1),
	5e-324,
	1.0000000025821745,
}

var vfexpm1SC = []float64{
	Inf(-1),
	-710,
	Copysign(0, -1),
	0,
	710,
	Inf(1),
	NaN(),
}
var expm1SC = []float64{
	-1,
	-1,
	Copysign(0, -1),
	0,
	Inf(1),
	Inf(1),
	NaN(),
}

var vffabsSC = []float64{
	Inf(-1),
	Copysign(0, -1),
	0,
	Inf(1),
	NaN(),
}
var fabsSC = []float64{
	Inf(1),
	0,
	0,
	Inf(1),
	NaN(),
}

var vffdimSC = [][2]float64{
	{Inf(-1), Inf(-1)},
	{Inf(-1), Inf(1)},
	{Inf(-1), NaN()},
	{Copysign(0, -1), Copysign(0, -1)},
	{Copysign(0, -1), 0},
	{0, Copysign(0, -1)},
	{0, 0},
	{Inf(1), Inf(-1)},
	{Inf(1), Inf(1)},
	{Inf(1), NaN()},
	{NaN(), Inf(-1)},
	{NaN(), Copysign(0, -1)},
	{NaN(), 0},
	{NaN(), Inf(1)},
	{NaN(), NaN()},
}
var nan = Float64frombits(0xFFF8000000000000) // SSE2 DIVSD 0/0
var vffdim2SC = [][2]float64{
	{Inf(-1), Inf(-1)},
	{Inf(-1), Inf(1)},
	{Inf(-1), nan},
	{Copysign(0, -1), Copysign(0, -1)},
	{Copysign(0, -1), 0},
	{0, Copysign(0, -1)},
	{0, 0},
	{Inf(1), Inf(-1)},
	{Inf(1), Inf(1)},
	{Inf(1), nan},
	{nan, Inf(-1)},
	{nan, Copysign(0, -1)},
	{nan, 0},
	{nan, Inf(1)},
	{nan, nan},
}
var fdimSC = []float64{
	NaN(),
	0,
	NaN(),
	0,
	0,
	0,
	0,
	Inf(1),
	NaN(),
	NaN(),
	NaN(),
	NaN(),
	NaN(),
	NaN(),
	NaN(),
}
var fmaxSC = []float64{
	Inf(-1),
	Inf(1),
	NaN(),
	Copysign(0, -1),
	0,
	0,
	0,
	Inf(1),
	Inf(1),
	Inf(1),
	NaN(),
	NaN(),
	NaN(),
	Inf(1),
	NaN(),
}
var fminSC = []float64{
	Inf(-1),
	Inf(-1),
	Inf(-1),
	Copysign(0, -1),
	Copysign(0, -1),
	Copysign(0, -1),
	0,
	Inf(-1),
	Inf(1),
	NaN(),
	Inf(-1),
	NaN(),
	NaN(),
	NaN(),
	NaN(),
}

var vffmodSC = [][2]float64{
	{Inf(-1), Inf(-1)},
	{Inf(-1), -Pi},
	{Inf(-1), 0},
	{Inf(-1), Pi},
	{Inf(-1), Inf(1)},
	{Inf(-1), NaN()},
	{-Pi, Inf(-1)},
	{-Pi, 0},
	{-Pi, Inf(1)},
	{-Pi, NaN()},
	{Copysign(0, -1), Inf(-1)},
	{Copysign(0, -1), 0},
	{Copysign(0, -1), Inf(1)},
	{Copysign(0, -1), NaN()},
	{0, Inf(-1)},
	{0, 0},
	{0, Inf(1)},
	{0, NaN()},
	{Pi, Inf(-1)},
	{Pi, 0},
	{Pi, Inf(1)},
	{Pi, NaN()},
	{Inf(1), Inf(-1)},
	{Inf(1), -Pi},
	{Inf(1), 0},
	{Inf(1), Pi},
	{Inf(1), Inf(1)},
	{Inf(1), NaN()},
	{NaN(), Inf(-1)},
	{NaN(), -Pi},
	{NaN(), 0},
	{NaN(), Pi},
	{NaN(), Inf(1)},
	{NaN(), NaN()},
}
var fmodSC = []float64{
	NaN(),           // fmod(-Inf, -Inf)
	NaN(),           // fmod(-Inf, -Pi)
	NaN(),           // fmod(-Inf, 0)
	NaN(),           // fmod(-Inf, Pi)
	NaN(),           // fmod(-Inf, +Inf)
	NaN(),           // fmod(-Inf, NaN)
	-Pi,             // fmod(-Pi, -Inf)
	NaN(),           // fmod(-Pi, 0)
	-Pi,             // fmod(-Pi, +Inf)
	NaN(),           // fmod(-Pi, NaN)
	Copysign(0, -1), // fmod(-0, -Inf)
	NaN(),           // fmod(-0, 0)
	Copysign(0, -1), // fmod(-0, Inf)
	NaN(),           // fmod(-0, NaN)
	0,               // fmod(0, -Inf)
	NaN(),           // fmod(0, 0)
	0,               // fmod(0, +Inf)
	NaN(),           // fmod(0, NaN)
	Pi,              // fmod(Pi, -Inf)
	NaN(),           // fmod(Pi, 0)
	Pi,              // fmod(Pi, +Inf)
	NaN(),           // fmod(Pi, NaN)
	NaN(),           // fmod(+Inf, -Inf)
	NaN(),           // fmod(+Inf, -Pi)
	NaN(),           // fmod(+Inf, 0)
	NaN(),           // fmod(+Inf, Pi)
	NaN(),           // fmod(+Inf, +Inf)
	NaN(),           // fmod(+Inf, NaN)
	NaN(),           // fmod(NaN, -Inf)
	NaN(),           // fmod(NaN, -Pi)
	NaN(),           // fmod(NaN, 0)
	NaN(),           // fmod(NaN, Pi)
	NaN(),           // fmod(NaN, +Inf)
	NaN(),           // fmod(NaN, NaN)
}

var vffrexpSC = []float64{
	Inf(-1),
	Copysign(0, -1),
	0,
	Inf(1),
	NaN(),
}
var frexpSC = []fi{
	{Inf(-1), 0},
	{Copysign(0, -1), 0},
	{0, 0},
	{Inf(1), 0},
	{NaN(), 0},
}

var vfgamma = [][2]float64{
	{Inf(1), Inf(1)},
	{Inf(-1), NaN()},
	{0, Inf(1)},
	{Copysign(0, -1), Inf(-1)},
	{NaN(), NaN()},
	{-1, NaN()},
	{-2, NaN()},
	{-3, NaN()},
	{-1e16, NaN()},
	{-1e300, NaN()},
	{1.7e308, Inf(1)},

	// Test inputs inspired by Python test suite.
	// Outputs computed at high precision by PARI/GP.
	// If recomputing table entries, be careful to use
	// high-precision (%.1000g) formatting of the float64 inputs.
	// For example, -2.0000000000000004 is the float64 with exact value
	// -2.00000000000000044408920985626161695, and
	// gamma(-2.0000000000000004) = -1249999999999999.5386078562728167651513, while
	// gamma(-2.00000000000000044408920985626161695) = -1125899906826907.2044875028130093136826.
	// Thus the table lists -1.1258999068426235e+15 as the answer.
	{0.5, 1.772453850905516},
	{1.5, 0.886226925452758},
	{2.5, 1.329340388179137},
	{3.5, 3.3233509704478426},
	{-0.5, -3.544907701811032},
	{-1.5, 2.363271801207355},
	{-2.5, -0.9453087204829419},
	{-3.5, 0.2700882058522691},
	{0.1, 9.51350769866873},
	{0.01, 99.4325851191506},
	{1e-08, 9.999999942278434e+07},
	{1e-16, 1e+16},
	{0.001, 999.4237724845955},
	{1e-16, 1e+16},
	{1e-308, 1e+308},
	{5.6e-309, 1.7857142857142864e+308},
	{5.5e-309, Inf(1)},
	{1e-309, Inf(1)},
	{1e-323, Inf(1)},
	{5e-324, Inf(1)},
	{-0.1, -10.686287021193193},
	{-0.01, -100.58719796441078},
	{-1e-08, -1.0000000057721567e+08},
	{-1e-16, -1e+16},
	{-0.001, -1000.5782056293586},
	{-1e-16, -1e+16},
	{-1e-308, -1e+308},
	{-5.6e-309, -1.7857142857142864e+308},
	{-5.5e-309, Inf(-1)},
	{-1e-309, Inf(-1)},
	{-1e-323, Inf(-1)},
	{-5e-324, Inf(-1)},
	{-0.9999999999999999, -9.007199254740992e+15},
	{-1.0000000000000002, 4.5035996273704955e+15},
	{-1.9999999999999998, 2.2517998136852485e+15},
	{-2.0000000000000004, -1.1258999068426235e+15},
	{-100.00000000000001, -7.540083334883109e-145},
	{-99.99999999999999, 7.540083334884096e-145},
	{17, 2.0922789888e+13},
	{171, 7.257415615307999e+306},
	{171.6, 1.5858969096672565e+308},
	{171.624, 1.7942117599248104e+308},
	{171.625, Inf(1)},
	{172, Inf(1)},
	{2000, Inf(1)},
	{-100.5, -3.3536908198076787e-159},
	{-160.5, -5.255546447007829e-286},
	{-170.5, -3.3127395215386074e-308},
	{-171.5, 1.9316265431712e-310},
	{-176.5, -1.196e-321},
	{-177.5, 5e-324},
	{-178.5, Copysign(0, -1)},
	{-179.5, 0},
	{-201.0001, 0},
	{-202.9999, Copysign(0, -1)},
	{-1000.5, Copysign(0, -1)},
	{-1.0000000003e+09, Copysign(0, -1)},
	{-4.5035996273704955e+15, 0},
	{-63.349078729022985, 4.177797167776188e-88},
	{-127.45117632943295, 1.183111089623681e-214},
}

var vfhypotSC = [][2]float64{
	{Inf(-1), Inf(-1)},
	{Inf(-1), 0},
	{Inf(-1), Inf(1)},
	{Inf(-1), NaN()},
	{Copysign(0, -1), Copysign(0, -1)},
	{Copysign(0, -1), 0},
	{0, Copysign(0, -1)},
	{0, 0}, // +0, +0
	{0, Inf(-1)},
	{0, Inf(1)},
	{0, NaN()},
	{Inf(1), Inf(-1)},
	{Inf(1), 0},
	{Inf(1), Inf(1)},
	{Inf(1), NaN()},
	{NaN(), Inf(-1)},
	{NaN(), 0},
	{NaN(), Inf(1)},
	{NaN(), NaN()},
}
var hypotSC = []float64{
	Inf(1),
	Inf(1),
	Inf(1),
	Inf(1),
	0,
	0,
	0,
	0,
	Inf(1),
	Inf(1),
	NaN(),
	Inf(1),
	Inf(1),
	Inf(1),
	Inf(1),
	Inf(1),
	NaN(),
	Inf(1),
	NaN(),
}

var ilogbSC = []int{
	MaxInt32,
	MinInt32,
	MaxInt32,
	MaxInt32,
}

var vfj0SC = []float64{
	Inf(-1),
	0,
	Inf(1),
	NaN(),
}
var j0SC = []float64{
	0,
	1,
	0,
	NaN(),
}
var j1SC = []float64{
	0,
	0,
	0,
	NaN(),
}
var j2SC = []float64{
	0,
	0,
	0,
	NaN(),
}
var jM3SC = []float64{
	0,
	0,
	0,
	NaN(),
}

var vfldexpSC = []fi{
	{0, 0},
	{0, -1075},
	{0, 1024},
	{Copysign(0, -1), 0},
	{Copysign(0, -1), -1075},
	{Copysign(0, -1), 1024},
	{Inf(1), 0},
	{Inf(1), -1024},
	{Inf(-1), 0},
	{Inf(-1), -1024},
	{NaN(), -1024},
	{10, int(1) << (uint64(unsafe.Sizeof(0)-1) * 8)},
	{10, -(int(1) << (uint64(unsafe.Sizeof(0)-1) * 8))},
}
var ldexpSC = []float64{
	0,
	0,
	0,
	Copysign(0, -1),
	Copysign(0, -1),
	Copysign(0, -1),
	Inf(1),
	Inf(1),
	Inf(-1),
	Inf(-1),
	NaN(),
	Inf(1),
	0,
}

var vflgammaSC = []float64{
	Inf(-1),
	-3,
	0,
	1,
	2,
	Inf(1),
	NaN(),
}
var lgammaSC = []fi{
	{Inf(-1), 1},
	{Inf(1), 1},
	{Inf(
"""




```
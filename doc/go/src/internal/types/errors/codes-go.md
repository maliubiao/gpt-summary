Response:
Let's break down the thought process for analyzing the provided Go code snippet.

**1. Understanding the Core Purpose:**

The first step is to read the initial comments. They clearly state:

* This file defines error codes for type checking.
* These codes are identifiers for special handling.
* Code values shouldn't change, new ones are added at the end.
* The granularity of codes is important (not too fine, not too coarse).
* Naming conventions are provided (adjective + noun).

This immediately tells us the file is about *categorizing* type-checking errors, not about the actual type-checking logic.

**2. Identifying Key Structures:**

The code defines a `Code` type as an `int`. This is a crucial piece of information. Error codes are represented numerically.

The `const` block defines a series of named constants of type `Code`. The comments accompanying each constant provide a short description and often an example of the error scenario.

The `//go:generate` directive is important for understanding the tooling involved. It uses `stringer` to automatically generate a `String()` method for the `Code` type. This allows for easy-to-read string representations of the error codes.

**3. Analyzing the Error Code Structure:**

Notice the pattern in the constant names: `BlankPkgName`, `MismatchedPkgName`, `InvalidPkgUse`, etc. This reinforces the naming convention mentioned in the comments.

Observe the use of `iota` to automatically increment the error code values. This is a standard Go practice for creating enumerations. The `_ Code = iota` skips the zero value, making it an "unset" code. The `-1` for `InvalidSyntaxTree` stands out as a special case, likely indicating a very fundamental, unrecoverable error.

**4. Inferring Functionality and Usage:**

Based on the structure and comments, we can infer the following:

* **Identification:**  The primary function is to provide a unique identifier for each type of type-checking error.
* **Categorization:** These codes allow the type checker (and potentially other tools) to categorize errors and handle them in specific ways (e.g., different error messages, specific recovery actions).
* **Error Reporting:** While this file doesn't directly handle error reporting, the `String()` method generated by `stringer` is likely used to produce human-readable error messages.
* **Testing/Debugging:** The codes provide a way to programmatically check for specific error conditions in tests.

**5. Considering the `stringer` Tool:**

The `//go:generate` comment is a trigger to think about the `stringer` tool. This tool takes a type with constant values and generates a `String()` method for that type. This method allows you to easily get the string representation of a constant.

**6. Developing Example Scenarios:**

To illustrate the usage, it's helpful to think about how these error codes would be used *within* the type checker. When a type-checking rule is violated, the type checker would create an error object and assign it the appropriate `Code`.

For instance, if the parser encounters `package _`, the type checker would detect this and assign the `BlankPkgName` code to the error.

**7. Addressing Potential Misunderstandings:**

The prompt asks about common mistakes. The primary point of confusion for users would likely be trying to interpret or modify the *numeric values* of the error codes. The comments explicitly warn against this, emphasizing that new codes should be added at the end. Another potential misunderstanding is thinking this file *performs* type checking, rather than just *identifying* the *kinds* of errors.

**8. Structuring the Answer:**

Finally, the answer should be organized logically, covering the key aspects:

* **Core Function:**  Summarize the main purpose of the file.
* **Go Feature Implemented:**  Identify the implementation of error categorization/enumeration.
* **Code Examples:** Provide simple Go examples illustrating how different error conditions would lead to different error codes.
* **Code Inference (if applicable):** Explain how the error codes would be used internally by the type checker.
* **Command-line Arguments (if applicable):**  Since `stringer` is a command-line tool, explain its role briefly.
* **Common Mistakes:** Highlight the important point about not changing error code values.
* **Summary:**  Reiterate the main function of the code.

**Self-Correction/Refinement During the Process:**

Initially, I might have focused too much on the specific details of each error code. However, realizing the prompt asks for the *overall function*, I would shift my focus to the higher-level purpose of error categorization and the mechanics of how it's implemented using Go constants and the `stringer` tool. I would also ensure the examples are simple and clearly demonstrate the link between a code snippet and the resulting error code.
`go/src/internal/types/errors/codes.go` 这个 Go 语言文件的主要功能是定义了一系列常量，用于标识在 Go 语言类型检查过程中可能出现的各种错误类型。 它的核心作用是为每一种特定的类型检查错误提供一个唯一的、程序可识别的 **错误代码 (Error Code)**。

**具体功能归纳如下：**

1. **定义错误代码类型:**  声明了一个名为 `Code` 的整数类型 (`int`)，用于表示错误代码。
2. **定义具体的错误代码常量:**  使用 `const` 关键字定义了一系列具名的 `Code` 类型的常量，每一个常量代表一种特定的类型检查错误。
3. **提供错误标识:**  这些错误代码常量可以作为程序内部识别和处理不同类型错误的标识符。例如，类型检查器在发现 "包名与已建立的包名不匹配" 的错误时，会使用 `MismatchedPkgName` 这个错误代码。
4. **方便错误处理:**  通过使用统一的错误代码，可以方便地在编译器的其他部分（或其他工具）针对特定的错误类型进行特殊处理、显示更详细的错误信息，或者进行自动化测试。
5. **便于错误分类和统计:**  可以基于这些错误代码对类型检查过程中出现的错误进行分类和统计，帮助开发者了解代码中常见的错误类型。
6. **作为 `stringer` 工具的输入:**  文件头部的 `//go:generate go run golang.org/x/tools/cmd/stringer@latest -type Code codes.go` 指令表明该文件配合 `stringer` 工具使用。`stringer` 工具会读取这个文件，并为 `Code` 类型生成一个 `String()` 方法，使得错误代码可以方便地转换为易读的字符串表示。

**可以推理出它是什么 Go 语言功能的实现：**

这个文件是 Go 语言 **错误处理** 机制的一部分，更具体地说是为了在 **编译时类型检查** 阶段提供结构化的错误信息。 它通过定义枚举类型的常量来实现对不同错误类型的区分和标识。

**Go 代码举例说明：**

假设在类型检查器的某个部分，发现了包名不匹配的错误，可能会有类似的代码：

```go
package types

import "fmt"
import "internal/types/errors" // 假设引入了这个包

func checkPackageName(currentName string, expectedName string) error {
	if currentName != expectedName {
		return fmt.Errorf("package name mismatch: got %s, expected %s (%v)", currentName, expectedName, errors.MismatchedPkgName)
	}
	return nil
}

// 假设的输入
func main() {
	err := checkPackageName("main_file", "another_package")
	if err != nil {
		fmt.Println(err) // 输出可能包含 "(...) (MismatchedPkgName)"
	}
}
```

**假设的输出：**

```
package name mismatch: got main_file, expected another_package (MismatchedPkgName)
```

在这个例子中，`errors.MismatchedPkgName`  被用作错误信息的一部分，方便程序或开发者识别错误的具体类型。  实际上，类型检查器内部会将这个 `errors.Code` 类型的值传递给错误报告机制。

**关于 `stringer` 工具：**

`stringer` 是 Go 官方提供的工具，用于为枚举类型的常量自动生成 `String()` 方法。

**命令行使用：**

```bash
go install golang.org/x/tools/cmd/stringer@latest
go generate go/src/internal/types/errors/codes.go
```

执行 `go generate` 命令时，`stringer` 会读取 `codes.go` 文件，找到 `//go:generate` 指令，并生成一个新的 Go 源文件（通常与原始文件同目录下，例如 `codes_string.go`），其中包含 `Code` 类型的 `String()` 方法。  这个方法会将 `Code` 类型的常量值转换为对应的字符串名称（例如，`MismatchedPkgName` 对应的字符串就是 "MismatchedPkgName"）。

**使用者易犯错的点：**

使用者（主要是 Go 编译器的开发者或相关工具的开发者）容易犯的错误可能是 **修改已有的错误代码的数值**。  正如注释所说 "Error code values should not be changed: add new codes at the end."  如果修改了已有的错误代码的数值，可能会导致：

* **已有的错误处理逻辑失效:** 其他依赖这些错误代码的程序可能会因为数值的改变而无法正确识别和处理错误。
* **类型检查行为的不一致:**  不同版本的编译器如果使用不同的错误代码数值，可能会导致对同一段代码的类型检查结果不一致。

**总结：**

`go/src/internal/types/errors/codes.go` 文件的主要功能是定义了一系列常量，作为 Go 语言类型检查过程中各种错误的唯一标识符。它通过定义 `Code` 类型和相关的常量，为错误处理、错误分类和与其他工具的集成提供了基础。配合 `stringer` 工具，可以方便地将这些错误代码转换为字符串表示，提高可读性。

### 提示词
```
这是路径为go/src/internal/types/errors/codes.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
请用中文回答。
这是第1部分，共2部分，请归纳一下它的功能
```

### 源代码
```go
// Copyright 2020 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package errors

//go:generate go run golang.org/x/tools/cmd/stringer@latest -type Code codes.go

type Code int

// This file defines the error codes that can be produced during type-checking.
// Collectively, these codes provide an identifier that may be used to
// implement special handling for certain types of errors.
//
// Error code values should not be changed: add new codes at the end.
//
// Error codes should be fine-grained enough that the exact nature of the error
// can be easily determined, but coarse enough that they are not an
// implementation detail of the type checking algorithm. As a rule-of-thumb,
// errors should be considered equivalent if there is a theoretical refactoring
// of the type checker in which they are emitted in exactly one place. For
// example, the type checker emits different error messages for "too many
// arguments" and "too few arguments", but one can imagine an alternative type
// checker where this check instead just emits a single "wrong number of
// arguments", so these errors should have the same code.
//
// Error code names should be as brief as possible while retaining accuracy and
// distinctiveness. In most cases names should start with an adjective
// describing the nature of the error (e.g. "invalid", "unused", "misplaced"),
// and end with a noun identifying the relevant language object. For example,
// "_DuplicateDecl" or "_InvalidSliceExpr". For brevity, naming follows the
// convention that "bad" implies a problem with syntax, and "invalid" implies a
// problem with types.

const (
	// InvalidSyntaxTree occurs if an invalid syntax tree is provided
	// to the type checker. It should never happen.
	InvalidSyntaxTree Code = -1
)

const (
	// The zero Code value indicates an unset (invalid) error code.
	_ Code = iota

	// Test is reserved for errors that only apply while in self-test mode.
	Test

	// BlankPkgName occurs when a package name is the blank identifier "_".
	//
	// Per the spec:
	//  "The PackageName must not be the blank identifier."
	//
	// Example:
	//  package _
	BlankPkgName

	// MismatchedPkgName occurs when a file's package name doesn't match the
	// package name already established by other files.
	MismatchedPkgName

	// InvalidPkgUse occurs when a package identifier is used outside of a
	// selector expression.
	//
	// Example:
	//  import "fmt"
	//
	//  var _ = fmt
	InvalidPkgUse

	// BadImportPath occurs when an import path is not valid.
	BadImportPath

	// BrokenImport occurs when importing a package fails.
	//
	// Example:
	//  import "amissingpackage"
	BrokenImport

	// ImportCRenamed occurs when the special import "C" is renamed. "C" is a
	// pseudo-package, and must not be renamed.
	//
	// Example:
	//  import _ "C"
	ImportCRenamed

	// UnusedImport occurs when an import is unused.
	//
	// Example:
	//  import "fmt"
	//
	//  func main() {}
	UnusedImport

	// InvalidInitCycle occurs when an invalid cycle is detected within the
	// initialization graph.
	//
	// Example:
	//  var x int = f()
	//
	//  func f() int { return x }
	InvalidInitCycle

	// DuplicateDecl occurs when an identifier is declared multiple times.
	//
	// Example:
	//  var x = 1
	//  var x = 2
	DuplicateDecl

	// InvalidDeclCycle occurs when a declaration cycle is not valid.
	//
	// Example:
	//  type S struct {
	//  	S
	//  }
	//
	InvalidDeclCycle

	// InvalidTypeCycle occurs when a cycle in type definitions results in a
	// type that is not well-defined.
	//
	// Example:
	//  import "unsafe"
	//
	//  type T [unsafe.Sizeof(T{})]int
	InvalidTypeCycle

	// InvalidConstInit occurs when a const declaration has a non-constant
	// initializer.
	//
	// Example:
	//  var x int
	//  const _ = x
	InvalidConstInit

	// InvalidConstVal occurs when a const value cannot be converted to its
	// target type.
	//
	// TODO(findleyr): this error code and example are not very clear. Consider
	// removing it.
	//
	// Example:
	//  const _ = 1 << "hello"
	InvalidConstVal

	// InvalidConstType occurs when the underlying type in a const declaration
	// is not a valid constant type.
	//
	// Example:
	//  const c *int = 4
	InvalidConstType

	// UntypedNilUse occurs when the predeclared (untyped) value nil is used to
	// initialize a variable declared without an explicit type.
	//
	// Example:
	//  var x = nil
	UntypedNilUse

	// WrongAssignCount occurs when the number of values on the right-hand side
	// of an assignment or initialization expression does not match the number
	// of variables on the left-hand side.
	//
	// Example:
	//  var x = 1, 2
	WrongAssignCount

	// UnassignableOperand occurs when the left-hand side of an assignment is
	// not assignable.
	//
	// Example:
	//  func f() {
	//  	const c = 1
	//  	c = 2
	//  }
	UnassignableOperand

	// NoNewVar occurs when a short variable declaration (':=') does not declare
	// new variables.
	//
	// Example:
	//  func f() {
	//  	x := 1
	//  	x := 2
	//  }
	NoNewVar

	// MultiValAssignOp occurs when an assignment operation (+=, *=, etc) does
	// not have single-valued left-hand or right-hand side.
	//
	// Per the spec:
	//  "In assignment operations, both the left- and right-hand expression lists
	//  must contain exactly one single-valued expression"
	//
	// Example:
	//  func f() int {
	//  	x, y := 1, 2
	//  	x, y += 1
	//  	return x + y
	//  }
	MultiValAssignOp

	// InvalidIfaceAssign occurs when a value of type T is used as an
	// interface, but T does not implement a method of the expected interface.
	//
	// Example:
	//  type I interface {
	//  	f()
	//  }
	//
	//  type T int
	//
	//  var x I = T(1)
	InvalidIfaceAssign

	// InvalidChanAssign occurs when a chan assignment is invalid.
	//
	// Per the spec, a value x is assignable to a channel type T if:
	//  "x is a bidirectional channel value, T is a channel type, x's type V and
	//  T have identical element types, and at least one of V or T is not a
	//  defined type."
	//
	// Example:
	//  type T1 chan int
	//  type T2 chan int
	//
	//  var x T1
	//  // Invalid assignment because both types are named
	//  var _ T2 = x
	InvalidChanAssign

	// IncompatibleAssign occurs when the type of the right-hand side expression
	// in an assignment cannot be assigned to the type of the variable being
	// assigned.
	//
	// Example:
	//  var x []int
	//  var _ int = x
	IncompatibleAssign

	// UnaddressableFieldAssign occurs when trying to assign to a struct field
	// in a map value.
	//
	// Example:
	//  func f() {
	//  	m := make(map[string]struct{i int})
	//  	m["foo"].i = 42
	//  }
	UnaddressableFieldAssign

	// NotAType occurs when the identifier used as the underlying type in a type
	// declaration or the right-hand side of a type alias does not denote a type.
	//
	// Example:
	//  var S = 2
	//
	//  type T S
	NotAType

	// InvalidArrayLen occurs when an array length is not a constant value.
	//
	// Example:
	//  var n = 3
	//  var _ = [n]int{}
	InvalidArrayLen

	// BlankIfaceMethod occurs when a method name is '_'.
	//
	// Per the spec:
	//  "The name of each explicitly specified method must be unique and not
	//  blank."
	//
	// Example:
	//  type T interface {
	//  	_(int)
	//  }
	BlankIfaceMethod

	// IncomparableMapKey occurs when a map key type does not support the == and
	// != operators.
	//
	// Per the spec:
	//  "The comparison operators == and != must be fully defined for operands of
	//  the key type; thus the key type must not be a function, map, or slice."
	//
	// Example:
	//  var x map[T]int
	//
	//  type T []int
	IncomparableMapKey

	// InvalidIfaceEmbed occurs when a non-interface type is embedded in an
	// interface (for go 1.17 or earlier).
	_ // not used anymore

	// InvalidPtrEmbed occurs when an embedded field is of the pointer form *T,
	// and T itself is itself a pointer, an unsafe.Pointer, or an interface.
	//
	// Per the spec:
	//  "An embedded field must be specified as a type name T or as a pointer to
	//  a non-interface type name *T, and T itself may not be a pointer type."
	//
	// Example:
	//  type T *int
	//
	//  type S struct {
	//  	*T
	//  }
	InvalidPtrEmbed

	// BadRecv occurs when a method declaration does not have exactly one
	// receiver parameter.
	//
	// Example:
	//  func () _() {}
	BadRecv

	// InvalidRecv occurs when a receiver type expression is not of the form T
	// or *T, or T is a pointer type.
	//
	// Example:
	//  type T struct {}
	//
	//  func (**T) m() {}
	InvalidRecv

	// DuplicateFieldAndMethod occurs when an identifier appears as both a field
	// and method name.
	//
	// Example:
	//  type T struct {
	//  	m int
	//  }
	//
	//  func (T) m() {}
	DuplicateFieldAndMethod

	// DuplicateMethod occurs when two methods on the same receiver type have
	// the same name.
	//
	// Example:
	//  type T struct {}
	//  func (T) m() {}
	//  func (T) m(i int) int { return i }
	DuplicateMethod

	// InvalidBlank occurs when a blank identifier is used as a value or type.
	//
	// Per the spec:
	//  "The blank identifier may appear as an operand only on the left-hand side
	//  of an assignment."
	//
	// Example:
	//  var x = _
	InvalidBlank

	// InvalidIota occurs when the predeclared identifier iota is used outside
	// of a constant declaration.
	//
	// Example:
	//  var x = iota
	InvalidIota

	// MissingInitBody occurs when an init function is missing its body.
	//
	// Example:
	//  func init()
	MissingInitBody

	// InvalidInitSig occurs when an init function declares parameters or
	// results.
	//
	// Deprecated: no longer emitted by the type checker. _InvalidInitDecl is
	// used instead.
	InvalidInitSig

	// InvalidInitDecl occurs when init is declared as anything other than a
	// function.
	//
	// Example:
	//  var init = 1
	//
	// Example:
	//  func init() int { return 1 }
	InvalidInitDecl

	// InvalidMainDecl occurs when main is declared as anything other than a
	// function, in a main package.
	InvalidMainDecl

	// TooManyValues occurs when a function returns too many values for the
	// expression context in which it is used.
	//
	// Example:
	//  func ReturnTwo() (int, int) {
	//  	return 1, 2
	//  }
	//
	//  var x = ReturnTwo()
	TooManyValues

	// NotAnExpr occurs when a type expression is used where a value expression
	// is expected.
	//
	// Example:
	//  type T struct {}
	//
	//  func f() {
	//  	T
	//  }
	NotAnExpr

	// TruncatedFloat occurs when a float constant is truncated to an integer
	// value.
	//
	// Example:
	//  var _ int = 98.6
	TruncatedFloat

	// NumericOverflow occurs when a numeric constant overflows its target type.
	//
	// Example:
	//  var x int8 = 1000
	NumericOverflow

	// UndefinedOp occurs when an operator is not defined for the type(s) used
	// in an operation.
	//
	// Example:
	//  var c = "a" - "b"
	UndefinedOp

	// MismatchedTypes occurs when operand types are incompatible in a binary
	// operation.
	//
	// Example:
	//  var a = "hello"
	//  var b = 1
	//  var c = a - b
	MismatchedTypes

	// DivByZero occurs when a division operation is provable at compile
	// time to be a division by zero.
	//
	// Example:
	//  const divisor = 0
	//  var x int = 1/divisor
	DivByZero

	// NonNumericIncDec occurs when an increment or decrement operator is
	// applied to a non-numeric value.
	//
	// Example:
	//  func f() {
	//  	var c = "c"
	//  	c++
	//  }
	NonNumericIncDec

	// UnaddressableOperand occurs when the & operator is applied to an
	// unaddressable expression.
	//
	// Example:
	//  var x = &1
	UnaddressableOperand

	// InvalidIndirection occurs when a non-pointer value is indirected via the
	// '*' operator.
	//
	// Example:
	//  var x int
	//  var y = *x
	InvalidIndirection

	// NonIndexableOperand occurs when an index operation is applied to a value
	// that cannot be indexed.
	//
	// Example:
	//  var x = 1
	//  var y = x[1]
	NonIndexableOperand

	// InvalidIndex occurs when an index argument is not of integer type,
	// negative, or out-of-bounds.
	//
	// Example:
	//  var s = [...]int{1,2,3}
	//  var x = s[5]
	//
	// Example:
	//  var s = []int{1,2,3}
	//  var _ = s[-1]
	//
	// Example:
	//  var s = []int{1,2,3}
	//  var i string
	//  var _ = s[i]
	InvalidIndex

	// SwappedSliceIndices occurs when constant indices in a slice expression
	// are decreasing in value.
	//
	// Example:
	//  var _ = []int{1,2,3}[2:1]
	SwappedSliceIndices

	// NonSliceableOperand occurs when a slice operation is applied to a value
	// whose type is not sliceable, or is unaddressable.
	//
	// Example:
	//  var x = [...]int{1, 2, 3}[:1]
	//
	// Example:
	//  var x = 1
	//  var y = 1[:1]
	NonSliceableOperand

	// InvalidSliceExpr occurs when a three-index slice expression (a[x:y:z]) is
	// applied to a string.
	//
	// Example:
	//  var s = "hello"
	//  var x = s[1:2:3]
	InvalidSliceExpr

	// InvalidShiftCount occurs when the right-hand side of a shift operation is
	// either non-integer, negative, or too large.
	//
	// Example:
	//  var (
	//  	x string
	//  	y int = 1 << x
	//  )
	InvalidShiftCount

	// InvalidShiftOperand occurs when the shifted operand is not an integer.
	//
	// Example:
	//  var s = "hello"
	//  var x = s << 2
	InvalidShiftOperand

	// InvalidReceive occurs when there is a channel receive from a value that
	// is either not a channel, or is a send-only channel.
	//
	// Example:
	//  func f() {
	//  	var x = 1
	//  	<-x
	//  }
	InvalidReceive

	// InvalidSend occurs when there is a channel send to a value that is not a
	// channel, or is a receive-only channel.
	//
	// Example:
	//  func f() {
	//  	var x = 1
	//  	x <- "hello!"
	//  }
	InvalidSend

	// DuplicateLitKey occurs when an index is duplicated in a slice, array, or
	// map literal.
	//
	// Example:
	//  var _ = []int{0:1, 0:2}
	//
	// Example:
	//  var _ = map[string]int{"a": 1, "a": 2}
	DuplicateLitKey

	// MissingLitKey occurs when a map literal is missing a key expression.
	//
	// Example:
	//  var _ = map[string]int{1}
	MissingLitKey

	// InvalidLitIndex occurs when the key in a key-value element of a slice or
	// array literal is not an integer constant.
	//
	// Example:
	//  var i = 0
	//  var x = []string{i: "world"}
	InvalidLitIndex

	// OversizeArrayLit occurs when an array literal exceeds its length.
	//
	// Example:
	//  var _ = [2]int{1,2,3}
	OversizeArrayLit

	// MixedStructLit occurs when a struct literal contains a mix of positional
	// and named elements.
	//
	// Example:
	//  var _ = struct{i, j int}{i: 1, 2}
	MixedStructLit

	// InvalidStructLit occurs when a positional struct literal has an incorrect
	// number of values.
	//
	// Example:
	//  var _ = struct{i, j int}{1,2,3}
	InvalidStructLit

	// MissingLitField occurs when a struct literal refers to a field that does
	// not exist on the struct type.
	//
	// Example:
	//  var _ = struct{i int}{j: 2}
	MissingLitField

	// DuplicateLitField occurs when a struct literal contains duplicated
	// fields.
	//
	// Example:
	//  var _ = struct{i int}{i: 1, i: 2}
	DuplicateLitField

	// UnexportedLitField occurs when a positional struct literal implicitly
	// assigns an unexported field of an imported type.
	UnexportedLitField

	// InvalidLitField occurs when a field name is not a valid identifier.
	//
	// Example:
	//  var _ = struct{i int}{1: 1}
	InvalidLitField

	// UntypedLit occurs when a composite literal omits a required type
	// identifier.
	//
	// Example:
	//  type outer struct{
	//  	inner struct { i int }
	//  }
	//
	//  var _ = outer{inner: {1}}
	UntypedLit

	// InvalidLit occurs when a composite literal expression does not match its
	// type.
	//
	// Example:
	//  type P *struct{
	//  	x int
	//  }
	//  var _ = P {}
	InvalidLit

	// AmbiguousSelector occurs when a selector is ambiguous.
	//
	// Example:
	//  type E1 struct { i int }
	//  type E2 struct { i int }
	//  type T struct { E1; E2 }
	//
	//  var x T
	//  var _ = x.i
	AmbiguousSelector

	// UndeclaredImportedName occurs when a package-qualified identifier is
	// undeclared by the imported package.
	//
	// Example:
	//  import "go/types"
	//
	//  var _ = types.NotAnActualIdentifier
	UndeclaredImportedName

	// UnexportedName occurs when a selector refers to an unexported identifier
	// of an imported package.
	//
	// Example:
	//  import "reflect"
	//
	//  type _ reflect.flag
	UnexportedName

	// UndeclaredName occurs when an identifier is not declared in the current
	// scope.
	//
	// Example:
	//  var x T
	UndeclaredName

	// MissingFieldOrMethod occurs when a selector references a field or method
	// that does not exist.
	//
	// Example:
	//  type T struct {}
	//
	//  var x = T{}.f
	MissingFieldOrMethod

	// BadDotDotDotSyntax occurs when a "..." occurs in a context where it is
	// not valid.
	//
	// Example:
	//  var _ = map[int][...]int{0: {}}
	BadDotDotDotSyntax

	// NonVariadicDotDotDot occurs when a "..." is used on the final argument to
	// a non-variadic function.
	//
	// Example:
	//  func printArgs(s []string) {
	//  	for _, a := range s {
	//  		println(a)
	//  	}
	//  }
	//
	//  func f() {
	//  	s := []string{"a", "b", "c"}
	//  	printArgs(s...)
	//  }
	NonVariadicDotDotDot

	// MisplacedDotDotDot occurs when a "..." is used somewhere other than the
	// final argument in a function declaration.
	//
	// Example:
	// 	func f(...int, int)
	MisplacedDotDotDot

	_ // InvalidDotDotDotOperand was removed.

	// InvalidDotDotDot occurs when a "..." is used in a non-variadic built-in
	// function.
	//
	// Example:
	//  var s = []int{1, 2, 3}
	//  var l = len(s...)
	InvalidDotDotDot

	// UncalledBuiltin occurs when a built-in function is used as a
	// function-valued expression, instead of being called.
	//
	// Per the spec:
	//  "The built-in functions do not have standard Go types, so they can only
	//  appear in call expressions; they cannot be used as function values."
	//
	// Example:
	//  var _ = copy
	UncalledBuiltin

	// InvalidAppend occurs when append is called with a first argument that is
	// not a slice.
	//
	// Example:
	//  var _ = append(1, 2)
	InvalidAppend

	// InvalidCap occurs when an argument to the cap built-in function is not of
	// supported type.
	//
	// See https://golang.org/ref/spec#Length_and_capacity for information on
	// which underlying types are supported as arguments to cap and len.
	//
	// Example:
	//  var s = 2
	//  var x = cap(s)
	InvalidCap

	// InvalidClose occurs when close(...) is called with an argument that is
	// not of channel type, or that is a receive-only channel.
	//
	// Example:
	//  func f() {
	//  	var x int
	//  	close(x)
	//  }
	InvalidClose

	// InvalidCopy occurs when the arguments are not of slice type or do not
	// have compatible type.
	//
	// See https://golang.org/ref/spec#Appending_and_copying_slices for more
	// information on the type requirements for the copy built-in.
	//
	// Example:
	//  func f() {
	//  	var x []int
	//  	y := []int64{1,2,3}
	//  	copy(x, y)
	//  }
	InvalidCopy

	// InvalidComplex occurs when the complex built-in function is called with
	// arguments with incompatible types.
	//
	// Example:
	//  var _ = complex(float32(1), float64(2))
	InvalidComplex

	// InvalidDelete occurs when the delete built-in function is called with a
	// first argument that is not a map.
	//
	// Example:
	//  func f() {
	//  	m := "hello"
	//  	delete(m, "e")
	//  }
	InvalidDelete

	// InvalidImag occurs when the imag built-in function is called with an
	// argument that does not have complex type.
	//
	// Example:
	//  var _ = imag(int(1))
	InvalidImag

	// InvalidLen occurs when an argument to the len built-in function is not of
	// supported type.
	//
	// See https://golang.org/ref/spec#Length_and_capacity for information on
	// which underlying types are supported as arguments to cap and len.
	//
	// Example:
	//  var s = 2
	//  var x = len(s)
	InvalidLen

	// SwappedMakeArgs occurs when make is called with three arguments, and its
	// length argument is larger than its capacity argument.
	//
	// Example:
	//  var x = make([]int, 3, 2)
	SwappedMakeArgs

	// InvalidMake occurs when make is called with an unsupported type argument.
	//
	// See https://golang.org/ref/spec#Making_slices_maps_and_channels for
	// information on the types that may be created using make.
	//
	// Example:
	//  var x = make(int)
	InvalidMake

	// InvalidReal occurs when the real built-in function is called with an
	// argument that does not have complex type.
	//
	// Example:
	//  var _ = real(int(1))
	InvalidReal

	// InvalidAssert occurs when a type assertion is applied to a
	// value that is not of interface type.
	//
	// Example:
	//  var x = 1
	//  var _ = x.(float64)
	InvalidAssert

	// ImpossibleAssert occurs for a type assertion x.(T) when the value x of
	// interface cannot have dynamic type T, due to a missing or mismatching
	// method on T.
	//
	// Example:
	//  type T int
	//
	//  func (t *T) m() int { return int(*t) }
	//
	//  type I interface { m() int }
	//
	//  var x I
	//  var _ = x.(T)
	ImpossibleAssert

	// InvalidConversion occurs when the argument type cannot be converted to the
	// target.
	//
	// See https://golang.org/ref/spec#Conversions for the rules of
	// convertibility.
	//
	// Example:
	//  var x float64
	//  var _ = string(x)
	InvalidConversion

	// InvalidUntypedConversion occurs when there is no valid implicit
	// conversion from an untyped value satisfying the type constraints of the
	// context in which it is used.
	//
	// Example:
	//  var _ = 1 + []int{}
	InvalidUntypedConversion

	// BadOffsetofSyntax occurs when unsafe.Offsetof is called with an argument
	// that is not a selector expression.
	//
	// Example:
	//  import "unsafe"
	//
	//  var x int
	//  var _ = unsafe.Offsetof(x)
	BadOffsetofSyntax

	// InvalidOffsetof occurs when unsafe.Offsetof is called with a method
	// selector, rather than a field selector, or when the field is embedded via
	// a pointer.
	//
	// Per the spec:
	//
	//  "If f is an embedded field, it must be reachable without pointer
	//  indirections through fields of the struct. "
	//
	// Example:
	//  import "unsafe"
	//
	//  type T struct { f int }
	//  type S struct { *T }
	//  var s S
	//  var _ = unsafe.Offsetof(s.f)
	//
	// Example:
	//  import "unsafe"
	//
	//  type S struct{}
	//
	//  func (S) m() {}
	//
	//  var s S
	//  var _ = unsafe.Offsetof(s.m)
	InvalidOffsetof

	// UnusedExpr occurs when a side-effect free expression is used as a
	// statement. Such a statement has no effect.
	//
	// Example:
	//  func f(i int) {
	//  	i*i
	//  }
	UnusedExpr

	// UnusedVar occurs when a variable is declared but unused.
	//
	// Example:
	//  func f() {
	//  	x := 1
	//  }
	UnusedVar

	// MissingReturn occurs when a function with results is missing a return
	// statement.
	//
	// Example:
	//  func f() int {}
	MissingReturn

	// WrongResultCount occurs when a return statement returns an incorrect
	// number of values.
	//
	// Example:
	//  func ReturnOne() int {
	//  	return 1, 2
	//  }
	WrongResultCount

	// OutOfScopeResult occurs when the name of a value implicitly returned by
	// an empty return statement is shadowed in a nested scope.
	//
	// Example:
	//  func factor(n int) (i int) {
	//  	for i := 2; i < n; i++ {
	//  		if n%i == 0 {
	//  			return
	//  		}
	//  	}
	//  	return 0
	//  }
	OutOfScopeResult

	// InvalidCond occurs when an if condition is not a boolean expression.
	//
	// Example:
	//  func checkReturn(i int) {
	//  	if i {
	//  		panic("non-zero return")
	//  	}
	//  }
	InvalidCond

	// InvalidPostDecl occurs when there is a declaration in a for-loop post
	// statement.
	//
	// Example:
	//  func f() {
	//  	for i := 0; i < 10; j := 0 {}
	//  }
	InvalidPostDecl

	_ // InvalidChanRange was removed.

	// InvalidIterVar occurs when two iteration variables are used while ranging
	// over a channel.
	//
	// Example:
	//  func f(c chan int) {
	//  	for k, v := range c {
	//  		println(k, v)
	//  	}
	//  }
	InvalidIterVar

	// InvalidRangeExpr occurs when the type of a range expression is not
	// a valid type for use with a range loop.
	//
	// Example:
	//  func f(f float64) {
	//  	for j := range f {
	//  		println(j)
	//  	}
	//  }
	InvalidRangeExpr

	// MisplacedBreak occurs when a break statement is not within a for, switch,
	// or select statement of the innermost function definition.
	//
	// Example:
	//  func f() {
	//  	break
	//  }
	MisplacedBreak

	// MisplacedContinue occurs when a continue statement is not within a for
	// loop of the innermost function definition.
	//
	// Example:
	//  func sumeven(n int) int {
	//  	proceed := func() {
	//  		continue
	//  	}
	//  	sum := 0
	//  	for i := 1; i <= n; i++ {
	//  		if i % 2 != 0 {
	//  			proceed()
	//  		}
	//  		sum += i
	//  	}
	//  	return sum
	//  }
	MisplacedContinue

	// MisplacedFallthrough occurs when a fallthrough statement is not within an
	// expression switch.
	//
	// Example:
	//  func typename(i interface{}) string {
	//  	switch i.(type) {
	//  	case int64:
	//  		fallthrough
	//  	case int:
	//  		return "int"
	//  	}
	//  	return "unsupported"
	//  }
	MisplacedFallthrough

	// DuplicateCase occurs when a type or expression switch has duplicate
	// cases.
	//
	// Example:
	//  func printInt(i int) {
	//  	switch i {
	//  	case 1:
	//  		println("one")
	//  	case 1:
	//  		println("One")
	//  	}
	//  }
	DuplicateCase

	// DuplicateDefault occurs when a type or expression switch has multiple
	// default clauses.
	//
	// Example:
	//  func printInt(i int) {
	//  	switch i {
	//  	case 1:
	//  		println("one")
	//  	default:
	//  		println("One")
	//  	default:
	//  		println("1")
	//  	}
	//  }
	DuplicateDefault

	// BadTypeKeyword occurs when a .(type) expression is used anywhere other
	// than a type switch.
	//
	// Example:
	//  type I interface {
	//  	m()
	//  }
	//  var t I
	//  var _ = t.(type)
	BadTypeKeyword

	// InvalidTypeSwitch occurs when .(type) is used on an expression that is
	// not of interface type.
	//
	// Example:
	//  func f(i int) {
	//  	switch x := i.(type) {}
	//  }
	InvalidTypeSwitch

	// InvalidExprSwitch occurs when a switch expression is not comparable.
	//
	// Example:
	//  func _() {
	//  	var a struct{ _ func() }
	//  	switch a /* ERROR cannot switch on a */ {
	//  	}
	//  }
	InvalidExprSwitch

	// InvalidSelectCase occurs when a select case is not a channel send or
	// receive.
	//
	// Example:
	//  func checkChan(c <-chan int) bool {
	//  	select {
	//  	case c:
	//  		return true
	//  	default:
	//  		return false
	//  	}
	//  }
	InvalidSelectCase

	// UndeclaredLabel occurs when an undeclared label is jumped to.
	//
	// Example:
	//  func f() {
	//  	goto L
	//  }
	UndeclaredLabel

	// DuplicateLabel occurs when a label is declared more than once.
	//
	// Example:
	//  func f() int {
	//  L:
	//  L:
	//  	return 1
	//  }
	DuplicateLabel

	// MisplacedLabel occurs when a break or continue label is not on a for,
	// switch, or select statement.
	//
	// Example:
	//  func f() {
	//  L:
	//  	a := []int{1,2,3}
	//  	for _, e := range a {
	//  		if e > 10 {
	//  			break L
	//  		}
	//  		println(a)
	//  	}
	//  }
	MisplacedLabel

	// UnusedLabel occurs when a label is declared and not used.
	//
	// Example:
	//  func f() {
	//  L:
	//  }
	UnusedLabel

	// JumpOverDecl occurs when a label jumps over a variable declaration.
	//
	// Example:
	//  func f() int {
	//  	goto L
	//  	x := 2
	//  L:
	//  	x++
	//  	return x
	//  }
	JumpOverDecl

	// JumpIntoBlock occurs when a forward jump goes to a label inside a nested
	// block.
	//
	// Example:
	//  func f(x int) {
	//  	goto L
	//  	if x > 0 {
	//  	L:
	//  		print("inside block")
	//  	}
	// }
	JumpIntoBlock

	// InvalidMethodExpr occurs when a pointer method is called but the argument
	// is not addressable.
	//
	// Example:
	//  type T struct {}
	//
	//  func (*T) m() int { return 1 }
	//
	//  var _ = T.m(T{})
	InvalidMethodExpr

	// WrongArgCount occurs when too few or too many arguments are passed by a
	// function call.
	//
	// Example:
	//  func f(i int) {}
	//  var x = f()
	WrongArgCount

	// InvalidCall occurs when an expression is called that is not of function
	// type.
	//
	// Example:
	//  var x = "x"
	//  var y = x()
	InvalidCall

	// UnusedResults occurs when a restricted expression-only built-in function
	// is suspended via go or defer. Such a suspension discards the results of
	// these side-effect free built-in functions, and therefore is ineffectual.
	//
	// Example:
	//  func f(a []int) int {
	//  	defer len(a)
	//  	return i
	//  }
	UnusedResults

	// InvalidDefer occurs when a deferred expression is not a function call,
	// for example if the expression is a type conversion.
	//
	// Example:
	//  func f(i int) int {
	//  	defer int32(i)
	//  	return i
	//  }
	InvalidDefer

	// InvalidGo occurs when a go expression is not a function call, for example
	// if the expression is a type conversion.
	//
	// Example:
	//  func f(i int) int {
	//  	go int32(i)
	//  	return i
	//  }
	InvalidGo

	// All codes below were added in Go 1.17.

	// BadDecl occurs when a declaration has invalid syntax.
	BadDecl

	// RepeatedDecl occurs when an identifier occurs more than once on the left
	// hand side of a short variable declaration.
	//
	// Example:
	//  func _() {
	//  	x, y, y := 1, 2, 3
	//  }
	RepeatedDecl

	// InvalidUnsafeAdd occurs when unsafe.Add is called with a
	// length argument that is not of integer type.
	// It also occurs if it is used in a package compiled for a
	// language version before go1.17.
	//
	// Example:
	//  import "unsafe"
	//
	//  var p unsafe.Pointer
	//  var _ = unsafe.Add(p, float64(1))
	InvalidUnsafeAdd

	// InvalidUnsafeSlice occurs when unsafe.Slice is called with a
	// pointer argument that is not of pointer type or a length argument
	// that is not of integer type, negative, or out of bounds.
	// It also occurs if it is used in a package compiled for a language
	// version before go1.17.
	//
	// Example:
	//  import "unsafe"
	//
	//  var x int
	//  var _ = unsafe.Slice(x, 1)
	//
	// Example:
	//  import "unsafe"
	//
	//  var x int
	//  var _ = unsafe.Slice(&x, float64(1))
	//
	// Example:
	//  import "unsafe"
	//
	//  var x int
	//  var _ = unsafe.Slice(&x, -1)
	//
	// Example:
	//  import "unsafe"
	//
	//  var x int
	//  var _ = unsafe.Slice(&x, uint64(1) << 63)
	InvalidUnsafeSlice

	// All codes below were added in Go 1.18.

	// UnsupportedFeature occurs when a language feature is used that is not
	// supported at this Go version.
	UnsupportedFeature

	// NotAGenericType occurs when a non-generic type is used where a generic
	// type is expected: in type or function instantiation.
	//
	// Example:
	//  type T int
	//
	//  var _ T[int]
	NotAGenericType

	// WrongTypeArgCount occurs when a type or function is instantiated with an
	// incorrect number of type arguments, including when a generic type or
	// function is used without instantiation.
	//
	// Errors involving failed type inference are assigned other error codes.
	//
	// Example:
	//  type T[p any] int
	//
	//  var _ T[int, string]
	//
	// Example:
	//  func f[T any]() {}
	//
	//  var x = f
	WrongTypeArgCount

	// CannotInferTypeArgs occurs when type or function type argument inference
	// fails to infer all type arguments.
	//
	// Example:
	//  func f[T any]() {}
	//
	//  func _() {
	//  	f()
	//  }
	CannotInferTypeArgs

	// InvalidTypeArg occurs when a type argument does not satisfy its
	// corresponding type parameter constraints.
	//
	// Example:
	//  type T[P ~int] struct{}
	//
	//  var _ T[string]
	InvalidTypeArg // arguments? InferenceFailed

	// InvalidInstanceCycle occurs when an invalid cycle is detected
	// within the instantiation graph.
	//
	// Example:
	//  func f[T any]() { f[*T]() }
	InvalidInstanceCycle

	// InvalidUnion occurs when an embedded union or approximation element is
	// not valid.
	//
	// Example:
	//  type _ interface {
	//   	~int | interface{ m() }
	//  }
	InvalidUnion

	// MisplacedConstraintIface occurs when a constraint-type interface is used
	// outside of constraint position.
	//
	// Example:
	//   type I interface { ~int }
	//
	//   var _ I
	MisplacedConstraintIface

	// InvalidMethodTypeParams occurs when methods have type parameters.
	//
	// It cannot be encountered with an AST parsed using go/parser.
	InvalidMethodTypeParams

	// MisplacedTypeParam occurs when a type parameter is used in a place where
	// it is not permitted.
	//
	// Example:
	//  type T[P any] P
	//
	// Example:
	//  type T[P any] struct{ *P }
	MisplacedTypeParam

	// InvalidUnsafeSliceData occurs when unsafe.SliceData is called with
	// an argument that is not of slice type. It also occurs if it is used
	// in a package compiled for a language version before go1.20.
	//
	// Example:
	//  import "unsafe"
	//
	//  var x in
```
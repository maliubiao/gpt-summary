Response:
The user wants a summary of the functionality of the provided C++ code snippet from `v8/src/api/api.cc`. I need to analyze the code and identify the main features and purposes of the functions and classes defined within it.

Here's a breakdown of the code's functionality:

1. **Module Handling:** Functions for creating, evaluating, and managing JavaScript modules. This includes creating synthetic modules and handling top-level await.
2. **Script Compilation:** Functions related to compiling JavaScript code, including regular scripts and modules. This involves handling cached data, streaming compilation, and compilation hints.
3. **Exception Handling:** The `TryCatch` class provides a mechanism to catch and handle exceptions within V8.
4. **Message Handling:** The `Message` class represents error and warning messages generated by V8, providing access to information like the message text, source location, and stack trace.

Considering the user's instructions:

*   `.tq` check: The filename ends with `.cc`, so it's not a Torque file.
*   JavaScript relationship: The code directly relates to compiling and executing JavaScript, so I will provide JavaScript examples where applicable.
*   Code logic reasoning:  I will provide examples of how some of the functions might be used with hypothetical inputs and outputs.
*   Common programming errors: I will illustrate some common mistakes related to the discussed functionalities.
*   Part of a larger sequence: This is part 4 of 15, so the summary should focus on the features present in this specific snippet and avoid broader V8 concepts not explicitly shown here.
这是 `v8/src/api/api.cc` 源代码的一部分，主要涉及以下功能：

**1. JavaScript 模块 (Module) 的处理:**

*   **`Module::Instantiate(...)`:**  用于实例化一个 JavaScript 模块。实例化是将模块加载到内存中并解析其依赖项的过程。
    *   它接受模块的 `Isolate`、`Context`、模块回调函数 (`module_callback`) 和源回调函数 (`source_callback`) 作为参数。
    *   如果实例化失败，会返回一个空值 (`MaybeLocal<bool>`)。
    *   **JavaScript 示例:**
        ```javascript
        // 假设我们已经有了一个编译好的模块 moduleInstance
        // 以及一个 Context context
        // moduleInstance.instantiate(context, (specifier, referrer) => { ... }, (specifier) => { ... });
        ```
*   **`Module::Evaluate(...)`:** 用于执行一个已经实例化的 JavaScript 模块。
    *   它接受一个 `Context` 作为参数。
    *   返回模块的执行结果 (`MaybeLocal<Value>`)。
    *   **JavaScript 示例:**
        ```javascript
        // 假设我们已经实例化了一个模块 moduleInstance
        // 以及一个 Context context
        // let result = moduleInstance.evaluate(context);
        ```
*   **`Module::CreateSyntheticModule(...)`:** 创建一个合成模块。合成模块是由 V8 引擎人为创建的，而不是从文件中加载的。
    *   它接受 `Isolate`、模块名称 (`module_name`)、导出的名称列表 (`export_names`) 和评估步骤 (`evaluation_steps`) 作为参数。
    *   **JavaScript 示例:**
        ```javascript
        // 创建一个名为 'myModule' 的合成模块，导出 'foo' 和 'bar'
        // let myModule = v8::ScriptCompiler::createSyntheticModule(isolate, v8::String::NewFromUtf8(isolate, "myModule").ToLocalChecked(), [v8::String::NewFromUtf8(isolate, "foo").ToLocalChecked(), v8::String::NewFromUtf8(isolate, "bar").ToLocalChecked()], (context, module) => {
        //   // 定义模块的评估步骤
        //   module->setSyntheticModuleExport(v8::String::NewFromUtf8(isolate, "foo").ToLocalChecked(), v8::Number::New(isolate, 1));
        //   module->setSyntheticModuleExport(v8::String::NewFromUtf8(isolate, "bar").ToLocalChecked(), v8::String::NewFromUtf8(isolate, "hello").ToLocalChecked());
        //   return MaybeLocal<v8::Value>();
        // });
        ```
*   **`Module::SetSyntheticModuleExport(...)`:** 设置合成模块的导出值。
    *   它接受 `Isolate`、导出的名称 (`export_name`) 和导出的值 (`export_value`) 作为参数。
    *   **JavaScript 示例 (延续上例):**
        ```javascript
        // (在 createSyntheticModule 的 evaluation_steps 回调中)
        // module->setSyntheticModuleExport(v8::String::NewFromUtf8(isolate, "foo").ToLocalChecked(), v8::Number::New(isolate, 1));
        ```
*   **`Module::GetStalledTopLevelAwaitMessages(...)`:** 获取由于顶层 `await` 表达式而暂停的模块的消息。
    *   它接受一个 `Isolate` 作为参数。
    *   返回一个包含暂停模块和对应消息的 pair。
    *   **JavaScript 示例:**
        ```javascript
        // 假设我们有一个包含顶层 await 的模块 topLevelAwaitModule
        // let [stalledModules, stalledMessages] = topLevelAwaitModule.getStalledTopLevelAwaitMessages(isolate);
        // if (stalledModules.length > 0) {
        //   console.log("模块由于顶层 await 暂停了:", stalledMessages[0].get());
        // }
        ```

**2. JavaScript 脚本 (Script) 的编译:**

*   **`ScriptCompiler::CompileUnboundInternal(...)`:** 编译一个未绑定的脚本（不与特定上下文关联）。这是一个内部函数。
    *   它接受 `Isolate`、`Source` 对象、编译选项 (`CompileOptions`) 和不缓存的原因 (`NoCacheReason`) 作为参数。
    *   返回一个未绑定的脚本对象 (`MaybeLocal<UnboundScript>`)。
*   **`ScriptCompiler::CompileUnboundScript(...)`:** 编译一个未绑定的脚本。
    *   它检查源是否为模块，如果不是，则调用 `CompileUnboundInternal`。
*   **`ScriptCompiler::Compile(...)`:** 编译一个脚本并将其绑定到给定的 `Context`。
    *   它检查源是否为模块，如果不是，则先编译为未绑定脚本，然后绑定到上下文。
    *   **JavaScript 示例:**
        ```javascript
        // 假设我们有一个字符串形式的 JavaScript 代码 sourceCode
        // 和一个 Context context
        // let script = v8::ScriptCompiler::compile(context, v8::String::NewFromUtf8(isolate, sourceCode).ToLocalChecked());
        ```
*   **`ScriptCompiler::CompileModule(...)`:** 编译一个 JavaScript 模块。
    *   它检查编译选项和源是否为模块。
    *   先编译为未绑定脚本，然后创建 `SourceTextModule` 对象。
    *   **JavaScript 示例:**
        ```javascript
        // 假设我们有一个字符串形式的 JavaScript 模块代码 moduleCode
        // let module = v8::ScriptCompiler::compileModule(isolate, v8::String::NewFromUtf8(isolate, moduleCode).ToLocalChecked());
        ```
*   **`ScriptCompiler::CompileFunction(...)`:** 编译一个 JavaScript 函数。
    *   它接受 `Context`、`Source` 对象、参数列表、上下文扩展等参数。
    *   **JavaScript 示例:**
        ```javascript
        // 假设我们有一个函数体 functionCode 和一个 Context context
        // let argNames = [v8::String::NewFromUtf8(isolate, "a").ToLocalChecked()];
        // let compiledFunction = v8::ScriptCompiler::compileFunction(context, v8::String::NewFromUtf8(isolate, functionCode).ToLocalChecked(), 1, argNames, 0, nullptr);
        ```
*   **`ScriptCompiler::StartStreaming(...)`:**  开始流式编译脚本。允许在脚本下载完成之前就开始编译。
*   **`ScriptCompiler::StartConsumingCodeCache(...)` / `ScriptCompiler::StartConsumingCodeCacheOnBackground(...)`:**  开始从代码缓存中消费数据，用于加速脚本的加载。
*   **`ScriptCompiler::Compile(...)` (针对 `StreamedSource`) / `ScriptCompiler::CompileModule(...)` (针对 `StreamedSource`) :** 编译流式源。
*   **`ScriptCompiler::CachedDataVersionTag()`:** 获取代码缓存的版本标签。
*   **`ScriptCompiler::CreateCodeCache(...)`:** 为一个未绑定的脚本或模块创建代码缓存。
*   **`ScriptCompiler::CreateCodeCacheForFunction(...)`:** 为一个函数创建代码缓存。
*   **`Script::Compile(...)`:**  `Script` 类的静态方法，用于编译脚本。

**3. 异常处理 (Exceptions):**

*   **`TryCatch` 类:**  提供了一个 try-catch 结构，用于捕获 JavaScript 执行过程中抛出的异常。
    *   **`TryCatch(Isolate* v8_isolate)`:** 构造函数，创建一个 `TryCatch` 对象。
    *   **`~TryCatch()`:** 析构函数，负责释放资源和重新抛出异常（如果需要）。
    *   **`HasCaught()`:**  检查是否捕获了异常。
    *   **`CanContinue()`:**  指示在捕获异常后是否可以继续执行。
    *   **`HasTerminated()`:** 检查是否捕获了终止异常。
    *   **`ReThrow()`:**  重新抛出捕获的异常。
    *   **`Exception()`:**  获取捕获的异常对象。
    *   **`StackTrace(...)`:** 获取异常的堆栈跟踪信息。
    *   **`Message()`:** 获取与异常关联的消息对象。
    *   **`Reset()` / `ResetInternal()`:** 重置 `TryCatch` 对象的状态。
    *   **`SetVerbose()` / `IsVerbose()`:**  设置/获取详细模式。
    *   **`SetCaptureMessage()`:** 设置是否捕获异常消息。
    *   **JavaScript 示例:**
        ```javascript
        // v8::TryCatch try_catch(isolate);
        // if (try_catch.HasCaught()) {
        //   v8::Local<v8::Message> message = try_catch.Message();
        //   v8::String::Utf8Value utf8(isolate, message->Get());
        //   console.error("捕获到异常:", *utf8);
        // }
        ```

**4. 消息 (Message):**

*   **`Message` 类:**  表示 JavaScript 执行过程中产生的错误或警告消息。
    *   **`Get()`:** 获取消息的字符串表示。
    *   **`GetIsolate()`:** 获取与消息关联的 `Isolate`。
    *   **`GetScriptOrigin()`:** 获取脚本的源信息。
    *   **`GetScriptResourceName()`:** 获取脚本的资源名称。
    *   **`GetStackTrace()`:** 获取消息的堆栈跟踪。
    *   **`GetLineNumber(...)`:** 获取发生错误/警告的行号。
    *   **`GetStartPosition()` / `GetEndPosition()`:** 获取错误/警告在源代码中的起始和结束位置。
    *   **`ErrorLevel()`:** 获取错误级别。
    *   **`GetStartColumn(...)` / `GetEndColumn(...)`:** 获取错误/警告的起始和结束列号。
    *   **`GetWasmFunctionIndex()`:** 如果消息与 WebAssembly 相关，则获取包含错误/警告的函数的索引。
    *   **`IsSharedCrossOrigin()` / `IsOpaque()`:**  检查脚本是否是跨域共享或不透明的。
    *   **`GetSource(...)`:** 获取发生错误/警告的源代码片段。

**如果 `v8/src/api/api.cc` 以 `.tq` 结尾:**

那么它将是一个 V8 Torque 源代码文件。Torque 是 V8 用于定义内置函数和运行时函数的领域特定语言。这个文件中会包含用 Torque 编写的代码，描述 V8 内部的实现逻辑。

**用户常见的编程错误示例:**

*   **在错误的上下文中操作:** 尝试在一个上下文中编译的脚本在另一个上下文中运行会导致错误。
    ```javascript
    // 错误示例：
    // v8::Local<v8::Context> context1 = ...;
    // v8::Local<v8::Context> context2 = ...;
    // v8::ScriptCompiler::Source source(v8::String::NewFromUtf8(isolate, "console.log('hello');").ToLocalChecked());
    // v8::Local<v8::Script> script = v8::ScriptCompiler::Compile(context1, &source).ToLocalChecked();
    // v8::Local<v8::Value> result = script->Run(context2).ToLocalChecked(); // 错误：脚本是在 context1 中编译的
    ```
*   **忘记处理 `MaybeLocal` 的返回值:** 很多 V8 API 函数返回 `MaybeLocal`，表示操作可能失败。不检查返回值会导致程序崩溃或未定义行为。
    ```javascript
    // 错误示例：
    // v8::Local<v8::Context> context = ...;
    // v8::Local<v8::String> code = v8::String::NewFromUtf8(isolate, "invalid javascript").ToLocalChecked();
    // v8::Local<v8::Script> script = v8::Script::Compile(context, code).ToLocalChecked(); // 如果编译失败，这里会是空值
    // script->Run(context); // 对空值调用方法会导致错误
    ```
*   **不正确地使用 `TryCatch`:**  忘记检查 `HasCaught()` 或者在 `TryCatch` 的作用域之外使用捕获的异常会导致问题。
    ```javascript
    // 错误示例：
    // v8::TryCatch try_catch(isolate);
    // v8::Script::Compile(context, v8::String::NewFromUtf8(isolate, "throw new Error('oops');").ToLocalChecked());
    // // ... 这里假设 try_catch 捕获了异常
    // v8::Local<v8::Message> message = try_catch.Message(); // 在 try_catch 作用域外使用 message 可能无效
    ```

**总结 (第 4 部分功能归纳):**

这部分 `v8/src/api/api.cc` 的代码主要负责 **JavaScript 模块的加载、实例化和执行，JavaScript 脚本和函数的编译（包括流式编译和使用代码缓存），以及提供异常捕获和错误消息处理的机制**。它提供了 V8 引擎与外部环境交互，执行 JavaScript 代码的核心 API。

### 提示词
```
这是目录为v8/src/api/api.cc的一个v8源代码， 请列举一下它的功能, 
如果v8/src/api/api.cc以.tq结尾，那它是个v8 torque源代码，
如果它与javascript的功能有关系，请用javascript举例说明,
如果有代码逻辑推理，请给出假设输入与输出，
如果涉及用户常见的编程错误，请举例说明
这是第4部分，共15部分，请归纳一下它的功能
```

### 源代码
```cpp
olate, Utils::OpenHandle(this), context,
                              module_callback, source_callback);
  RETURN_ON_FAILED_EXECUTION_PRIMITIVE(bool);
  return Just(true);
}

MaybeLocal<Value> Module::Evaluate(Local<Context> context) {
  auto i_isolate = reinterpret_cast<i::Isolate*>(context->GetIsolate());
  TRACE_EVENT_CALL_STATS_SCOPED(i_isolate, "v8", "V8.Execute");
  ENTER_V8(i_isolate, context, Module, Evaluate, InternalEscapableScope);
  i::TimerEventScope<i::TimerEventExecute> timer_scope(i_isolate);
  i::NestedTimedHistogramScope execute_timer(i_isolate->counters()->execute(),
                                             i_isolate);
  i::AggregatingHistogramTimerScope timer(
      i_isolate->counters()->compile_lazy());

  auto self = Utils::OpenHandle(this);
  Utils::ApiCheck(self->status() >= i::Module::kLinked, "Module::Evaluate",
                  "Expected instantiated module");

  Local<Value> result;
  has_exception = !ToLocal(i::Module::Evaluate(i_isolate, self), &result);
  RETURN_ON_FAILED_EXECUTION(Value);
  RETURN_ESCAPED(result);
}

Local<Module> Module::CreateSyntheticModule(
    Isolate* v8_isolate, Local<String> module_name,
    const MemorySpan<const Local<String>>& export_names,
    v8::Module::SyntheticModuleEvaluationSteps evaluation_steps) {
  auto i_isolate = reinterpret_cast<i::Isolate*>(v8_isolate);
  ENTER_V8_NO_SCRIPT_NO_EXCEPTION(i_isolate);
  auto i_module_name = Utils::OpenHandle(*module_name);
  i::DirectHandle<i::FixedArray> i_export_names =
      i_isolate->factory()->NewFixedArray(
          static_cast<int>(export_names.size()));
  for (int i = 0; i < i_export_names->length(); ++i) {
    i::DirectHandle<i::String> str = i_isolate->factory()->InternalizeString(
        Utils::OpenDirectHandle(*export_names[i]));
    i_export_names->set(i, *str);
  }
  return v8::Utils::ToLocal(
      i::Handle<i::Module>(i_isolate->factory()->NewSyntheticModule(
          i_module_name, i_export_names, evaluation_steps)));
}

Maybe<bool> Module::SetSyntheticModuleExport(Isolate* v8_isolate,
                                             Local<String> export_name,
                                             Local<v8::Value> export_value) {
  auto i_isolate = reinterpret_cast<i::Isolate*>(v8_isolate);
  auto i_export_name = Utils::OpenHandle(*export_name);
  auto i_export_value = Utils::OpenHandle(*export_value);
  auto self = Utils::OpenHandle(this);
  Utils::ApiCheck(i::IsSyntheticModule(*self),
                  "v8::Module::SyntheticModuleSetExport",
                  "v8::Module::SyntheticModuleSetExport must only be called on "
                  "a SyntheticModule");
  ENTER_V8_NO_SCRIPT(i_isolate, v8_isolate->GetCurrentContext(), Module,
                     SetSyntheticModuleExport, i::HandleScope);
  has_exception = i::SyntheticModule::SetExport(
                      i_isolate, i::Cast<i::SyntheticModule>(self),
                      i_export_name, i_export_value)
                      .IsNothing();
  RETURN_ON_FAILED_EXECUTION_PRIMITIVE(bool);
  return Just(true);
}

std::pair<LocalVector<Module>, LocalVector<Message>>
Module::GetStalledTopLevelAwaitMessages(Isolate* isolate) {
  auto i_isolate = reinterpret_cast<i::Isolate*>(isolate);
  auto self = Utils::OpenDirectHandle(this);
  Utils::ApiCheck(i::IsSourceTextModule(*self),
                  "v8::Module::GetStalledTopLevelAwaitMessages",
                  "v8::Module::GetStalledTopLevelAwaitMessages must only be "
                  "called on a SourceTextModule");
  std::vector<
      std::tuple<i::Handle<i::SourceTextModule>, i::Handle<i::JSMessageObject>>>
      stalled_awaits =
          i::Cast<i::SourceTextModule>(self)->GetStalledTopLevelAwaitMessages(
              i_isolate);

  LocalVector<Module> modules(isolate);
  LocalVector<Message> messages(isolate);

  if (size_t stalled_awaits_count = stalled_awaits.size();
      stalled_awaits_count > 0) {
    modules.reserve(stalled_awaits_count);
    messages.reserve(stalled_awaits_count);
    for (auto [module, message] : stalled_awaits) {
      modules.push_back(ToApiHandle<Module>(module));
      messages.push_back(ToApiHandle<Message>(message));
    }
  }

  return {modules, messages};
}

namespace {

i::ScriptDetails GetScriptDetails(
    i::Isolate* i_isolate, Local<Value> resource_name, int resource_line_offset,
    int resource_column_offset, Local<Value> source_map_url,
    Local<Data> host_defined_options, ScriptOriginOptions origin_options) {
  i::ScriptDetails script_details(Utils::OpenHandle(*(resource_name), true),
                                  origin_options);
  script_details.line_offset = resource_line_offset;
  script_details.column_offset = resource_column_offset;
  script_details.host_defined_options =
      host_defined_options.IsEmpty()
          ? i_isolate->factory()->empty_fixed_array()
          : Utils::OpenHandle(*(host_defined_options));
  if (!source_map_url.IsEmpty()) {
    script_details.source_map_url = Utils::OpenHandle(*(source_map_url));
  }
  return script_details;
}

}  // namespace

MaybeLocal<UnboundScript> ScriptCompiler::CompileUnboundInternal(
    Isolate* v8_isolate, Source* source, CompileOptions options,
    NoCacheReason no_cache_reason) {
  auto i_isolate = reinterpret_cast<i::Isolate*>(v8_isolate);
  TRACE_EVENT_CALL_STATS_SCOPED(i_isolate, "v8", "V8.ScriptCompiler");
  ENTER_V8_NO_SCRIPT(i_isolate, v8_isolate->GetCurrentContext(), ScriptCompiler,
                     CompileUnbound, InternalEscapableScope);

  auto str = Utils::OpenHandle(*(source->source_string));

  i::DirectHandle<i::SharedFunctionInfo> result;
  TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT("v8.compile"), "V8.CompileScript");
  i::ScriptDetails script_details = GetScriptDetails(
      i_isolate, source->resource_name, source->resource_line_offset,
      source->resource_column_offset, source->source_map_url,
      source->host_defined_options, source->resource_options);

  i::MaybeDirectHandle<i::SharedFunctionInfo> maybe_function_info;
  if (options & kConsumeCodeCache) {
    if (source->consume_cache_task) {
      // Take ownership of the internal deserialization task and clear it off
      // the consume task on the source.
      DCHECK_NOT_NULL(source->consume_cache_task->impl_);
      std::unique_ptr<i::BackgroundDeserializeTask> deserialize_task =
          std::move(source->consume_cache_task->impl_);
      maybe_function_info =
          i::Compiler::GetSharedFunctionInfoForScriptWithDeserializeTask(
              i_isolate, str, script_details, deserialize_task.get(), options,
              no_cache_reason, i::NOT_NATIVES_CODE,
              &source->compilation_details);
      source->cached_data->rejected = deserialize_task->rejected();
    } else {
      DCHECK(source->cached_data);
      // AlignedCachedData takes care of pointer-aligning the data.
      auto cached_data = std::make_unique<i::AlignedCachedData>(
          source->cached_data->data, source->cached_data->length);
      maybe_function_info =
          i::Compiler::GetSharedFunctionInfoForScriptWithCachedData(
              i_isolate, str, script_details, cached_data.get(), options,
              no_cache_reason, i::NOT_NATIVES_CODE,
              &source->compilation_details);
      source->cached_data->rejected = cached_data->rejected();
    }
  } else if (options & kConsumeCompileHints) {
    maybe_function_info =
        i::Compiler::GetSharedFunctionInfoForScriptWithCompileHints(
            i_isolate, str, script_details, source->compile_hint_callback,
            source->compile_hint_callback_data, options, no_cache_reason,
            i::NOT_NATIVES_CODE, &source->compilation_details);
  } else {
    // Compile without any cache.
    maybe_function_info = i::Compiler::GetSharedFunctionInfoForScript(
        i_isolate, str, script_details, options, no_cache_reason,
        i::NOT_NATIVES_CODE, &source->compilation_details);
  }

  has_exception = !maybe_function_info.ToHandle(&result);
  DCHECK_IMPLIES(!has_exception, !i::HeapLayout::InReadOnlySpace(*result));
  RETURN_ON_FAILED_EXECUTION(UnboundScript);
  RETURN_ESCAPED(ToApiHandle<UnboundScript>(result));
}

MaybeLocal<UnboundScript> ScriptCompiler::CompileUnboundScript(
    Isolate* v8_isolate, Source* source, CompileOptions options,
    NoCacheReason no_cache_reason) {
  Utils::ApiCheck(
      !source->GetResourceOptions().IsModule(),
      "v8::ScriptCompiler::CompileUnboundScript",
      "v8::ScriptCompiler::CompileModule must be used to compile modules");
  return CompileUnboundInternal(v8_isolate, source, options, no_cache_reason);
}

MaybeLocal<Script> ScriptCompiler::Compile(Local<Context> context,
                                           Source* source,
                                           CompileOptions options,
                                           NoCacheReason no_cache_reason) {
  Utils::ApiCheck(
      !source->GetResourceOptions().IsModule(), "v8::ScriptCompiler::Compile",
      "v8::ScriptCompiler::CompileModule must be used to compile modules");
  auto i_isolate = context->GetIsolate();
  MaybeLocal<UnboundScript> maybe =
      CompileUnboundInternal(i_isolate, source, options, no_cache_reason);
  Local<UnboundScript> result;
  if (!maybe.ToLocal(&result)) return MaybeLocal<Script>();
  v8::Context::Scope scope(context);
  return result->BindToCurrentContext();
}

MaybeLocal<Module> ScriptCompiler::CompileModule(
    Isolate* v8_isolate, Source* source, CompileOptions options,
    NoCacheReason no_cache_reason) {
  Utils::ApiCheck(v8::ScriptCompiler::CompileOptionsIsValid(options),
                  "v8::ScriptCompiler::CompileModule",
                  "Invalid CompileOptions");
  Utils::ApiCheck(source->GetResourceOptions().IsModule(),
                  "v8::ScriptCompiler::CompileModule",
                  "Invalid ScriptOrigin: is_module must be true");
  MaybeLocal<UnboundScript> maybe =
      CompileUnboundInternal(v8_isolate, source, options, no_cache_reason);
  Local<UnboundScript> unbound;
  if (!maybe.ToLocal(&unbound)) return MaybeLocal<Module>();
  auto shared = Utils::OpenHandle(*unbound);
  i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(v8_isolate);
  return ToApiHandle<Module>(i_isolate->factory()->NewSourceTextModule(shared));
}

// static
V8_WARN_UNUSED_RESULT MaybeLocal<Function> ScriptCompiler::CompileFunction(
    Local<Context> v8_context, Source* source, size_t arguments_count,
    Local<String> arguments[], size_t context_extension_count,
    Local<Object> context_extensions[], CompileOptions options,
    NoCacheReason no_cache_reason) {
  PREPARE_FOR_EXECUTION(v8_context, ScriptCompiler, CompileFunction);
  TRACE_EVENT_CALL_STATS_SCOPED(i_isolate, "v8", "V8.ScriptCompiler");

  DCHECK(options == CompileOptions::kConsumeCodeCache ||
         options == CompileOptions::kEagerCompile ||
         options == CompileOptions::kNoCompileOptions);

  i::Handle<i::Context> context = Utils::OpenHandle(*v8_context);

  DCHECK(IsNativeContext(*context));

  i::Handle<i::FixedArray> arguments_list =
      i_isolate->factory()->NewFixedArray(static_cast<int>(arguments_count));
  for (int i = 0; i < static_cast<int>(arguments_count); i++) {
    auto argument = Utils::OpenHandle(*arguments[i]);
    if (!i::String::IsIdentifier(i_isolate, argument)) return Local<Function>();
    arguments_list->set(i, *argument);
  }

  for (size_t i = 0; i < context_extension_count; ++i) {
    i::DirectHandle<i::JSReceiver> extension =
        Utils::OpenDirectHandle(*context_extensions[i]);
    if (!IsJSObject(*extension)) return Local<Function>();
    context = i_isolate->factory()->NewWithContext(
        context,
        i::ScopeInfo::CreateForWithScope(
            i_isolate,
            IsNativeContext(*context)
                ? i::Handle<i::ScopeInfo>::null()
                : i::Handle<i::ScopeInfo>(context->scope_info(), i_isolate)),
        extension);
  }

  i::ScriptDetails script_details = GetScriptDetails(
      i_isolate, source->resource_name, source->resource_line_offset,
      source->resource_column_offset, source->source_map_url,
      source->host_defined_options, source->resource_options);
  script_details.wrapped_arguments = arguments_list;

  std::unique_ptr<i::AlignedCachedData> cached_data;
  if (options & kConsumeCodeCache) {
    DCHECK(source->cached_data);
    // ScriptData takes care of pointer-aligning the data.
    cached_data.reset(new i::AlignedCachedData(source->cached_data->data,
                                               source->cached_data->length));
  }

  i::Handle<i::JSFunction> result;
  has_exception =
      !i::Compiler::GetWrappedFunction(
           Utils::OpenHandle(*source->source_string), context, script_details,
           cached_data.get(), options, no_cache_reason)
           .ToHandle(&result);
  if (options & kConsumeCodeCache) {
    source->cached_data->rejected = cached_data->rejected();
  }
  RETURN_ON_FAILED_EXECUTION(Function);
  return handle_scope.Escape(Utils::CallableToLocal(result));
}

void ScriptCompiler::ScriptStreamingTask::Run() { data_->task->Run(); }

ScriptCompiler::ScriptStreamingTask* ScriptCompiler::StartStreaming(
    Isolate* v8_isolate, StreamedSource* source, v8::ScriptType type,
    CompileOptions options, CompileHintCallback compile_hint_callback,
    void* compile_hint_callback_data) {
  Utils::ApiCheck(v8::ScriptCompiler::CompileOptionsIsValid(options),
                  "v8::ScriptCompiler::StartStreaming",
                  "Invalid CompileOptions");
  if (!i::v8_flags.script_streaming) return nullptr;
  i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(v8_isolate);
  i::ScriptStreamingData* data = source->impl();
  std::unique_ptr<i::BackgroundCompileTask> task =
      std::make_unique<i::BackgroundCompileTask>(
          data, i_isolate, type, options, &source->compilation_details(),
          compile_hint_callback, compile_hint_callback_data);
  data->task = std::move(task);
  return new ScriptCompiler::ScriptStreamingTask(data);
}

ScriptCompiler::ConsumeCodeCacheTask::ConsumeCodeCacheTask(
    std::unique_ptr<i::BackgroundDeserializeTask> impl)
    : impl_(std::move(impl)) {}

ScriptCompiler::ConsumeCodeCacheTask::~ConsumeCodeCacheTask() = default;

void ScriptCompiler::ConsumeCodeCacheTask::Run() { impl_->Run(); }

void ScriptCompiler::ConsumeCodeCacheTask::SourceTextAvailable(
    Isolate* v8_isolate, Local<String> source_text,
    const ScriptOrigin& origin) {
  i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(v8_isolate);
  DCHECK_NO_SCRIPT_NO_EXCEPTION(i_isolate);
  auto str = Utils::OpenHandle(*source_text);
  i::ScriptDetails script_details =
      GetScriptDetails(i_isolate, origin.ResourceName(), origin.LineOffset(),
                       origin.ColumnOffset(), origin.SourceMapUrl(),
                       origin.GetHostDefinedOptions(), origin.Options());
  impl_->SourceTextAvailable(i_isolate, str, script_details);
}

bool ScriptCompiler::ConsumeCodeCacheTask::ShouldMergeWithExistingScript()
    const {
  if (!i::v8_flags
           .merge_background_deserialized_script_with_compilation_cache) {
    return false;
  }
  return impl_->ShouldMergeWithExistingScript();
}

void ScriptCompiler::ConsumeCodeCacheTask::MergeWithExistingScript() {
  DCHECK(
      i::v8_flags.merge_background_deserialized_script_with_compilation_cache);
  impl_->MergeWithExistingScript();
}

ScriptCompiler::ConsumeCodeCacheTask* ScriptCompiler::StartConsumingCodeCache(
    Isolate* v8_isolate, std::unique_ptr<CachedData> cached_data) {
  if (!i::v8_flags.concurrent_cache_deserialization) return nullptr;
  i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(v8_isolate);
  DCHECK_NO_SCRIPT_NO_EXCEPTION(i_isolate);
  return new ScriptCompiler::ConsumeCodeCacheTask(
      std::make_unique<i::BackgroundDeserializeTask>(i_isolate,
                                                     std::move(cached_data)));
}

ScriptCompiler::ConsumeCodeCacheTask*
ScriptCompiler::StartConsumingCodeCacheOnBackground(
    Isolate* v8_isolate, std::unique_ptr<CachedData> cached_data) {
  if (!i::v8_flags.concurrent_cache_deserialization) return nullptr;
  i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(v8_isolate);
  return new ScriptCompiler::ConsumeCodeCacheTask(
      std::make_unique<i::BackgroundDeserializeTask>(i_isolate,
                                                     std::move(cached_data)));
}

namespace {
i::MaybeDirectHandle<i::SharedFunctionInfo> CompileStreamedSource(
    i::Isolate* i_isolate, ScriptCompiler::StreamedSource* v8_source,
    Local<String> full_source_string, const ScriptOrigin& origin) {
  auto str = Utils::OpenHandle(*full_source_string);
  i::ScriptDetails script_details =
      GetScriptDetails(i_isolate, origin.ResourceName(), origin.LineOffset(),
                       origin.ColumnOffset(), origin.SourceMapUrl(),
                       origin.GetHostDefinedOptions(), origin.Options());
  i::ScriptStreamingData* data = v8_source->impl();
  return i::Compiler::GetSharedFunctionInfoForStreamedScript(
      i_isolate, str, script_details, data, &v8_source->compilation_details());
}

}  // namespace

MaybeLocal<Script> ScriptCompiler::Compile(Local<Context> context,
                                           StreamedSource* v8_source,
                                           Local<String> full_source_string,
                                           const ScriptOrigin& origin) {
  PREPARE_FOR_EXECUTION(context, ScriptCompiler, Compile);
  TRACE_EVENT_CALL_STATS_SCOPED(i_isolate, "v8", "V8.ScriptCompiler");
  TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT("v8.compile"),
               "V8.CompileStreamedScript");
  i::DirectHandle<i::SharedFunctionInfo> sfi;
  i::MaybeDirectHandle<i::SharedFunctionInfo> maybe_sfi =
      CompileStreamedSource(i_isolate, v8_source, full_source_string, origin);
  has_exception = !maybe_sfi.ToHandle(&sfi);
  if (has_exception) i_isolate->ReportPendingMessages();
  RETURN_ON_FAILED_EXECUTION(Script);
  Local<UnboundScript> generic = ToApiHandle<UnboundScript>(sfi);
  if (generic.IsEmpty()) return Local<Script>();
  Local<Script> bound = generic->BindToCurrentContext();
  if (bound.IsEmpty()) return Local<Script>();
  RETURN_ESCAPED(bound);
}

MaybeLocal<Module> ScriptCompiler::CompileModule(
    Local<Context> context, StreamedSource* v8_source,
    Local<String> full_source_string, const ScriptOrigin& origin) {
  PREPARE_FOR_EXECUTION(context, ScriptCompiler, Compile);
  TRACE_EVENT_CALL_STATS_SCOPED(i_isolate, "v8", "V8.ScriptCompiler");
  TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT("v8.compile"),
               "V8.CompileStreamedModule");
  i::DirectHandle<i::SharedFunctionInfo> sfi;
  i::MaybeDirectHandle<i::SharedFunctionInfo> maybe_sfi =
      CompileStreamedSource(i_isolate, v8_source, full_source_string, origin);
  has_exception = !maybe_sfi.ToHandle(&sfi);
  if (has_exception) i_isolate->ReportPendingMessages();
  RETURN_ON_FAILED_EXECUTION(Module);
  RETURN_ESCAPED(
      ToApiHandle<Module>(i_isolate->factory()->NewSourceTextModule(sfi)));
}

uint32_t ScriptCompiler::CachedDataVersionTag() {
  return static_cast<uint32_t>(base::hash_combine(
      internal::Version::Hash(), internal::FlagList::Hash(),
      static_cast<uint32_t>(internal::CpuFeatures::SupportedFeatures())));
}

ScriptCompiler::CachedData* ScriptCompiler::CreateCodeCache(
    Local<UnboundScript> unbound_script) {
  auto shared = Utils::OpenHandle(*unbound_script);
  // TODO(jgruber): Remove this DCHECK once Function::GetUnboundScript is gone.
  DCHECK(!i::HeapLayout::InReadOnlySpace(*shared));
  i::Isolate* i_isolate = i::GetIsolateFromWritableObject(*shared);
  Utils::ApiCheck(!i_isolate->serializer_enabled(),
                  "ScriptCompiler::CreateCodeCache",
                  "Cannot create code cache while creating a snapshot");
  DCHECK_NO_SCRIPT_NO_EXCEPTION(i_isolate);
  DCHECK(shared->is_toplevel());
  return i::CodeSerializer::Serialize(i_isolate, shared);
}

// static
ScriptCompiler::CachedData* ScriptCompiler::CreateCodeCache(
    Local<UnboundModuleScript> unbound_module_script) {
  i::Handle<i::SharedFunctionInfo> shared =
      Utils::OpenHandle(*unbound_module_script);
  // TODO(jgruber): Remove this DCHECK once Function::GetUnboundScript is gone.
  DCHECK(!i::HeapLayout::InReadOnlySpace(*shared));
  i::Isolate* i_isolate = i::GetIsolateFromWritableObject(*shared);
  Utils::ApiCheck(!i_isolate->serializer_enabled(),
                  "ScriptCompiler::CreateCodeCache",
                  "Cannot create code cache while creating a snapshot");
  DCHECK_NO_SCRIPT_NO_EXCEPTION(i_isolate);
  DCHECK(shared->is_toplevel());
  return i::CodeSerializer::Serialize(i_isolate, shared);
}

ScriptCompiler::CachedData* ScriptCompiler::CreateCodeCacheForFunction(
    Local<Function> function) {
  auto js_function = i::Cast<i::JSFunction>(Utils::OpenDirectHandle(*function));
  i::Isolate* i_isolate = js_function->GetIsolate();
  Utils::ApiCheck(!i_isolate->serializer_enabled(),
                  "ScriptCompiler::CreateCodeCacheForFunction",
                  "Cannot create code cache while creating a snapshot");
  i::Handle<i::SharedFunctionInfo> shared(js_function->shared(), i_isolate);
  DCHECK_NO_SCRIPT_NO_EXCEPTION(i_isolate);
  Utils::ApiCheck(shared->is_wrapped(),
                  "v8::ScriptCompiler::CreateCodeCacheForFunction",
                  "Expected SharedFunctionInfo with wrapped source code");
  return i::CodeSerializer::Serialize(i_isolate, shared);
}

MaybeLocal<Script> Script::Compile(Local<Context> context, Local<String> source,
                                   ScriptOrigin* origin) {
  if (origin) {
    ScriptCompiler::Source script_source(source, *origin);
    return ScriptCompiler::Compile(context, &script_source);
  }
  ScriptCompiler::Source script_source(source);
  return ScriptCompiler::Compile(context, &script_source);
}

// --- E x c e p t i o n s ---

v8::TryCatch::TryCatch(v8::Isolate* v8_isolate)
    : i_isolate_(reinterpret_cast<i::Isolate*>(v8_isolate)),
      next_(i_isolate_->try_catch_handler()),
      is_verbose_(false),
      can_continue_(true),
      capture_message_(true),
      rethrow_(false) {
  ResetInternal();
  // Special handling for simulators which have a separate JS stack.
  js_stack_comparable_address_ = static_cast<internal::Address>(
      i::SimulatorStack::RegisterJSStackComparableAddress(i_isolate_));
  i_isolate_->RegisterTryCatchHandler(this);
}

namespace {

i::Tagged<i::Object> ToObject(void* object) {
  return i::Tagged<i::Object>(reinterpret_cast<i::Address>(object));
}

}  // namespace

v8::TryCatch::~TryCatch() {
  if (HasCaught()) {
    if (rethrow_ || (V8_UNLIKELY(HasTerminated()) &&
                     !i_isolate_->thread_local_top()->CallDepthIsZero())) {
      if (capture_message_) {
        // If an exception was caught and rethrow_ is indicated, the saved
        // message, script, and location need to be restored to Isolate TLS
        // for reuse.  capture_message_ needs to be disabled so that Throw()
        // does not create a new message.
        i_isolate_->thread_local_top()->rethrowing_message_ = true;
        i_isolate_->set_pending_message(ToObject(message_obj_));
      }
      i_isolate_->UnregisterTryCatchHandler(this);
      i_isolate_->clear_internal_exception();
      i_isolate_->Throw(ToObject(exception_));
      return;
    }
    Reset();
  }
  i_isolate_->UnregisterTryCatchHandler(this);
  DCHECK_IMPLIES(rethrow_,
                 !i_isolate_->thread_local_top()->rethrowing_message_);
}

void* v8::TryCatch::operator new(size_t) { base::OS::Abort(); }
void* v8::TryCatch::operator new[](size_t) { base::OS::Abort(); }
void v8::TryCatch::operator delete(void*, size_t) { base::OS::Abort(); }
void v8::TryCatch::operator delete[](void*, size_t) { base::OS::Abort(); }

bool v8::TryCatch::HasCaught() const {
  return !IsTheHole(ToObject(exception_), i_isolate_);
}

bool v8::TryCatch::CanContinue() const { return can_continue_; }

bool v8::TryCatch::HasTerminated() const {
  return ToObject(exception_) ==
         i::ReadOnlyRoots(i_isolate_).termination_exception();
}

v8::Local<v8::Value> v8::TryCatch::ReThrow() {
  if (!HasCaught()) return v8::Local<v8::Value>();
  rethrow_ = true;
  return v8::Undefined(reinterpret_cast<v8::Isolate*>(i_isolate_));
}

v8::Local<Value> v8::TryCatch::Exception() const {
  if (!HasCaught()) return v8::Local<Value>();
  if (HasTerminated()) {
    return v8::Utils::ToLocal(i::ReadOnlyRoots(i_isolate_).null_value_handle());
  }
  return v8::Utils::ToLocal(i::handle(ToObject(exception_), i_isolate_));
}

MaybeLocal<Value> v8::TryCatch::StackTrace(Local<Context> context,
                                           Local<Value> exception) {
  auto i_exception = Utils::OpenHandle(*exception);
  if (!IsJSObject(*i_exception)) return v8::Local<Value>();
  PREPARE_FOR_EXECUTION(context, TryCatch, StackTrace);
  auto obj = i::Cast<i::JSObject>(i_exception);
  i::Handle<i::String> name = i_isolate->factory()->stack_string();
  Maybe<bool> maybe = i::JSReceiver::HasProperty(i_isolate, obj, name);
  has_exception = maybe.IsNothing();
  RETURN_ON_FAILED_EXECUTION(Value);
  if (!maybe.FromJust()) return v8::Local<Value>();
  Local<Value> result;
  has_exception = !ToLocal<Value>(
      i::JSReceiver::GetProperty(i_isolate, obj, name), &result);
  RETURN_ON_FAILED_EXECUTION(Value);
  RETURN_ESCAPED(result);
}

MaybeLocal<Value> v8::TryCatch::StackTrace(Local<Context> context) const {
  if (!HasCaught()) return v8::Local<Value>();
  return StackTrace(context, Exception());
}

v8::Local<v8::Message> v8::TryCatch::Message() const {
  i::Tagged<i::Object> message = ToObject(message_obj_);
  DCHECK(IsJSMessageObject(message) || IsTheHole(message, i_isolate_));
  if (HasCaught() && !IsTheHole(message, i_isolate_)) {
    return v8::Utils::MessageToLocal(i::Handle<i::Object>(message, i_isolate_));
  } else {
    return v8::Local<v8::Message>();
  }
}

void v8::TryCatch::Reset() {
  if (rethrow_) return;
  if (V8_UNLIKELY(i_isolate_->is_execution_terminating()) &&
      !i_isolate_->thread_local_top()->CallDepthIsZero()) {
    return;
  }
  i_isolate_->clear_internal_exception();
  i_isolate_->clear_pending_message();
  ResetInternal();
}

void v8::TryCatch::ResetInternal() {
  i::Tagged<i::Object> the_hole = i::ReadOnlyRoots(i_isolate_).the_hole_value();
  exception_ = reinterpret_cast<void*>(the_hole.ptr());
  message_obj_ = reinterpret_cast<void*>(the_hole.ptr());
}

void v8::TryCatch::SetVerbose(bool value) { is_verbose_ = value; }

bool v8::TryCatch::IsVerbose() const { return is_verbose_; }

void v8::TryCatch::SetCaptureMessage(bool value) { capture_message_ = value; }

// --- M e s s a g e ---

Local<String> Message::Get() const {
  auto self = Utils::OpenHandle(this);
  i::Isolate* i_isolate = self->GetIsolate();
  ENTER_V8_NO_SCRIPT_NO_EXCEPTION(i_isolate);
  InternalEscapableScope scope(i_isolate);
  i::Handle<i::String> raw_result =
      i::MessageHandler::GetMessage(i_isolate, self);
  Local<String> result = Utils::ToLocal(raw_result);
  return scope.Escape(result);
}

v8::Isolate* Message::GetIsolate() const {
  i::Isolate* i_isolate = Utils::OpenDirectHandle(this)->GetIsolate();
  return reinterpret_cast<Isolate*>(i_isolate);
}

ScriptOrigin Message::GetScriptOrigin() const {
  auto self = Utils::OpenDirectHandle(this);
  i::Isolate* i_isolate = self->GetIsolate();
  ENTER_V8_NO_SCRIPT_NO_EXCEPTION(i_isolate);
  i::DirectHandle<i::Script> script(self->script(), i_isolate);
  return GetScriptOriginForScript(i_isolate, script);
}

void ScriptOrigin::VerifyHostDefinedOptions() const {
  // TODO(cbruni, chromium:1244145): Remove checks once we allow arbitrary
  // host-defined options.
  if (host_defined_options_.IsEmpty()) return;
  Utils::ApiCheck(host_defined_options_->IsFixedArray(), "ScriptOrigin()",
                  "Host-defined options has to be a PrimitiveArray");
  auto options =
      Utils::OpenDirectHandle(*host_defined_options_.As<FixedArray>());
  for (int i = 0; i < options->length(); i++) {
    Utils::ApiCheck(i::IsPrimitive(options->get(i)), "ScriptOrigin()",
                    "PrimitiveArray can only contain primtive values");
  }
}

v8::Local<Value> Message::GetScriptResourceName() const {
  DCHECK_NO_SCRIPT_NO_EXCEPTION(Utils::OpenDirectHandle(this)->GetIsolate());
  return GetScriptOrigin().ResourceName();
}

v8::Local<v8::StackTrace> Message::GetStackTrace() const {
  auto self = Utils::OpenDirectHandle(this);
  i::Isolate* i_isolate = self->GetIsolate();
  ENTER_V8_NO_SCRIPT_NO_EXCEPTION(i_isolate);
  InternalEscapableScope scope(i_isolate);
  i::Handle<i::Object> stack_trace(self->stack_trace(), i_isolate);
  if (!IsStackTraceInfo(*stack_trace)) return {};
  return scope.Escape(
      Utils::StackTraceToLocal(i::Cast<i::StackTraceInfo>(stack_trace)));
}

Maybe<int> Message::GetLineNumber(Local<Context> context) const {
  auto self = Utils::OpenHandle(this);
  i::Isolate* i_isolate = self->GetIsolate();
  ENTER_V8_NO_SCRIPT_NO_EXCEPTION(i_isolate);
  HandleScope handle_scope(reinterpret_cast<Isolate*>(i_isolate));
  i::JSMessageObject::EnsureSourcePositionsAvailable(i_isolate, self);
  return Just(self->GetLineNumber());
}

int Message::GetStartPosition() const {
  auto self = Utils::OpenHandle(this);
  i::Isolate* i_isolate = self->GetIsolate();
  ENTER_V8_NO_SCRIPT_NO_EXCEPTION(i_isolate);
  HandleScope handle_scope(reinterpret_cast<Isolate*>(i_isolate));
  i::JSMessageObject::EnsureSourcePositionsAvailable(i_isolate, self);
  return self->GetStartPosition();
}

int Message::GetEndPosition() const {
  auto self = Utils::OpenHandle(this);
  i::Isolate* i_isolate = self->GetIsolate();
  ENTER_V8_NO_SCRIPT_NO_EXCEPTION(i_isolate);
  HandleScope handle_scope(reinterpret_cast<Isolate*>(i_isolate));
  i::JSMessageObject::EnsureSourcePositionsAvailable(i_isolate, self);
  return self->GetEndPosition();
}

int Message::ErrorLevel() const {
  auto self = Utils::OpenDirectHandle(this);
  DCHECK_NO_SCRIPT_NO_EXCEPTION(self->GetIsolate());
  return self->error_level();
}

int Message::GetStartColumn() const {
  auto self = Utils::OpenHandle(this);
  i::Isolate* i_isolate = self->GetIsolate();
  ENTER_V8_NO_SCRIPT_NO_EXCEPTION(i_isolate);
  HandleScope handle_scope(reinterpret_cast<Isolate*>(i_isolate));
  i::JSMessageObject::EnsureSourcePositionsAvailable(i_isolate, self);
  return self->GetColumnNumber();
}

int Message::GetWasmFunctionIndex() const {
#if V8_ENABLE_WEBASSEMBLY
  auto self = Utils::OpenHandle(this);
  i::Isolate* i_isolate = self->GetIsolate();
  ENTER_V8_NO_SCRIPT_NO_EXCEPTION(i_isolate);
  HandleScope handle_scope(reinterpret_cast<Isolate*>(i_isolate));
  i::JSMessageObject::EnsureSourcePositionsAvailable(i_isolate, self);
  int start_position = self->GetColumnNumber();
  if (start_position == -1) return Message::kNoWasmFunctionIndexInfo;

  i::DirectHandle<i::Script> script(self->script(), i_isolate);

  if (script->type() != i::Script::Type::kWasm) {
    return Message::kNoWasmFunctionIndexInfo;
  }

  auto debug_script = ToApiHandle<debug::Script>(script);
  return Local<debug::WasmScript>::Cast(debug_script)
      ->GetContainingFunction(start_position);
#else
  return Message::kNoWasmFunctionIndexInfo;
#endif  // V8_ENABLE_WEBASSEMBLY
}

Maybe<int> Message::GetStartColumn(Local<Context> context) const {
  return Just(GetStartColumn());
}

int Message::GetEndColumn() const {
  auto self = Utils::OpenHandle(this);
  i::Isolate* i_isolate = self->GetIsolate();
  ENTER_V8_NO_SCRIPT_NO_EXCEPTION(i_isolate);
  HandleScope handle_scope(reinterpret_cast<Isolate*>(i_isolate));
  i::JSMessageObject::EnsureSourcePositionsAvailable(i_isolate, self);
  const int column_number = self->GetColumnNumber();
  if (column_number == -1) return -1;
  const int start = self->GetStartPosition();
  const int end = self->GetEndPosition();
  return column_number + (end - start);
}

Maybe<int> Message::GetEndColumn(Local<Context> context) const {
  return Just(GetEndColumn());
}

bool Message::IsSharedCrossOrigin() const {
  auto self = Utils::OpenDirectHandle(this);
  i::Isolate* i_isolate = self->GetIsolate();
  ENTER_V8_NO_SCRIPT_NO_EXCEPTION(i_isolate);
  return self->script()->origin_options().IsSharedCrossOrigin();
}

bool Message::IsOpaque() const {
  auto self = Utils::OpenDirectHandle(this);
  i::Isolate* i_isolate = self->GetIsolate();
  ENTER_V8_NO_SCRIPT_NO_EXCEPTION(i_isolate);
  return self->script()->origin_options().IsOpaque();
}

MaybeLocal<String> Message::GetSource(Local<Context> context) const {
  auto self = Utils::OpenDirectHandle(this);
  i::Isolate* i_isolate = self->GetIsolate();
  ENTER_V8_NO_SCRIPT_NO_EXCEPTION(i_isolate);
  InternalEscapableScope handle_scope(i_isolate);
```
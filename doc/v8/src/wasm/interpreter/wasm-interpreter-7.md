Response: The user wants to understand the functionality of the C++ file `wasm-interpreter.cc` within the V8 JavaScript engine, specifically its role in the WebAssembly interpreter.

Here's a breakdown of the thought process to generate the answer:

1. **Identify the Core Functionality:** The filename `wasm-interpreter.cc` immediately suggests its primary role is related to interpreting WebAssembly code. The code snippets provided reinforce this by showing handling of various WebAssembly opcodes (e.g., `kExprI32LoadMem`, `kExprLocalSet`, `kExprI32Const`).

2. **Focus on Key Classes/Methods:** The code mentions `WasmBytecodeGenerator`. This class is crucial. The method `GenerateBytecode()` strongly suggests this file's role is to *transform* WebAssembly instructions into a lower-level bytecode representation.

3. **Analyze Code Snippets for Clues:**
    * **Opcode Handling (`switch` statements):**  The numerous `case kExpr...` lines indicate the file handles different WebAssembly instructions.
    * **`EMIT_INSTR_HANDLER` macros:**  These suggest the generation of bytecode instructions corresponding to the WebAssembly opcodes. The "s2s" and "r2s" prefixes likely denote different ways of handling stack operations.
    * **`LOAD_CASE` and `STORE_CASE` macros:** These deal with memory access operations (loads and stores).
    * **Super Instruction Optimization:** The `EncodeSuperInstruction` method demonstrates an optimization technique to combine common instruction sequences into single bytecode instructions. This is about performance.
    * **Stack Management:**  References to `S128Pop()`, `S128Push()`, `I32Pop()`, and the `stack_` member suggest managing a virtual stack for the interpreter.
    * **Local Variables:**  The handling of `kExprLocalSet` and `kExprLocalGet` points to managing local variables within WebAssembly functions.
    * **Control Flow:**  The `BeginBlock` function and mentions of `kExprBlock`, `kExprIf`, and `kExprLoop` indicate handling of WebAssembly's structured control flow.
    * **Bytecode Emission (`code_.push_back`):** This confirms the generation of a bytecode sequence.
    * **Constants:** The handling of `kExprI32Const`, `kExprF32Const`, and the `CreateConstSlot` function indicate how constant values are managed.

4. **Connect to JavaScript:** The crucial link is V8. WebAssembly executes within a JavaScript engine. Therefore, the generated bytecode is used by V8 to run WebAssembly code. The example needs to show how JavaScript interacts with WebAssembly. Loading and calling a WebAssembly function from JavaScript is the standard way.

5. **Structure the Answer:** Organize the findings into logical sections:
    * **Core Functionality:**  State the primary purpose clearly.
    * **Key Aspects:** Detail the important functionalities observed in the code.
    * **Relationship to JavaScript:** Explain the connection and provide a simple, illustrative JavaScript example.
    * **Part 8 of 8:** Address the user's specific point about the file being the last part. This implies it's responsible for the final stage of the interpretation process (bytecode generation).

6. **Refine and Explain:** Elaborate on the technical terms and concepts (e.g., bytecode, super instructions) in a way that is understandable without requiring deep knowledge of the V8 internals. Explain *why* these functionalities are important.

7. **Self-Correction/Refinement during thought process:**
    * Initially, I might have focused too much on the individual opcodes. It's important to step back and identify the higher-level purpose: bytecode generation.
    * The connection to JavaScript needs to be explicit and demonstrated with a simple code snippet. Just mentioning V8 isn't enough.
    * The "part 8 of 8" aspect is important context provided by the user and should be addressed. It signals this file's role in the final stages of the process.

By following these steps, we arrive at a comprehensive and accurate summary of the `wasm-interpreter.cc` file's functionality.
这是 `v8/src/wasm/interpreter/wasm-interpreter.cc` 文件的第 8 部分，也是最后一部分。综合整个文件的内容，可以归纳出它的主要功能是 **将 WebAssembly 的指令序列（在 V8 中是 `WasmCode` 对象）转换为一种更低级的、解释器可以直接执行的字节码格式（`WasmBytecode` 对象）**。这个过程是 WebAssembly 解释器执行的第一步，发生在实际执行 WebAssembly 代码之前。

具体来说，这个文件中的 `WasmBytecodeGenerator` 类负责执行这个转换过程。它遍历 WebAssembly 的指令，并将每个指令（或者某些指令的组合）转换为一系列解释器能够理解的字节码指令。

以下是该文件功能的一些关键方面：

1. **指令处理:**  代码中大量的 `case kExpr...` 语句表明 `WasmBytecodeGenerator` 能够处理各种 WebAssembly 指令，例如加载、存储、算术运算、局部变量操作、控制流指令（如 `if`、`loop`）等等。

2. **字节码生成:**  `EMIT_INSTR_HANDLER` 宏以及对 `code_.push_back` 的调用表明，该文件负责生成实际的字节码序列。`InstructionHandler` 看起来是表示不同字节码指令的类型。

3. **操作数栈管理:**  `S128Pop()`, `S128Push()`, `I32Pop()` 等函数暗示了解释器使用一个操作数栈来执行计算。字节码生成器需要根据 WebAssembly 指令来调整这个栈。

4. **局部变量管理:**  处理 `kExprLocalSet` 和 `kExprLocalGet` 指令涉及到对局部变量的访问和修改，这需要字节码生成器在生成的字节码中反映出来。

5. **内存访问:**  `LOAD_LANE_CASE`, `STORE_LANE_CASE`, 以及对 `kExprI32LoadMem` 等指令的处理表明该文件处理 WebAssembly 的内存访问操作。

6. **SIMD 指令处理:**  `kExprS128LoadLane`, `kExprS128StoreLane` 等指令的处理表明该文件支持 WebAssembly 的 SIMD (Single Instruction, Multiple Data) 扩展。

7. **超指令优化 (Super Instruction Optimization):** `EncodeSuperInstruction` 函数尝试将一些常见的 WebAssembly 指令序列（例如加载后立即存储到局部变量）合并成一个更高效的字节码指令。这是一种性能优化手段。

8. **控制流处理:**  `BeginBlock` 函数以及对 `kExprBlock`, `kExprIf`, `kExprLoop` 的处理表明该文件负责处理 WebAssembly 的控制流结构，并生成相应的字节码来管理这些结构。

9. **常量处理:**  处理 `kExprI32Const` 等常量指令，并将常量值存储在特定的槽位中。

**与 JavaScript 的关系及 JavaScript 示例:**

这个文件生成的字节码将被 V8 的 WebAssembly 解释器执行。JavaScript 代码可以通过 V8 引擎加载和执行 WebAssembly 模块。

以下是一个简单的 JavaScript 例子，说明了 JavaScript 如何调用 WebAssembly 代码，而 `wasm-interpreter.cc` 负责生成这个 WebAssembly 代码的执行形式：

```javascript
// WebAssembly 的文本格式 (WAT)
const wasmCode = `
  (module
    (func $add (param $p1 i32) (param $p2 i32) (result i32)
      local.get $p1
      local.get $p2
      i32.add
      return)
    (export "add" (func $add))
  )
`;

// 将 WAT 代码转换为二进制格式
const wasmBinary = new Uint8Array(WebAssembly.parse(WebAssembly.compile(new TextEncoder().encode(wasmCode))));

// 加载 WebAssembly 模块
WebAssembly.instantiate(wasmBinary)
  .then(module => {
    // 获取导出的函数
    const addFunction = module.instance.exports.add;

    // 调用 WebAssembly 函数
    const result = addFunction(5, 10);
    console.log(result); // 输出 15
  });
```

**在这个例子中，当 V8 引擎加载 `wasmBinary` 时，`wasm-interpreter.cc` (更准确地说是其中的 `WasmBytecodeGenerator`) 会被调用，将 WebAssembly 的 `i32.add` 指令转换为解释器可以执行的字节码。**  当 JavaScript 调用 `addFunction(5, 10)` 时，V8 的 WebAssembly 解释器会执行由 `wasm-interpreter.cc` 生成的字节码，从而完成加法运算并将结果返回给 JavaScript。

**总结第 8 部分的功能:**

作为第 8 部分也是最后一部分，这个文件完成了将 WebAssembly 指令序列转换为可执行字节码的关键步骤。它负责处理各种 WebAssembly 指令，进行优化，并生成最终的 `WasmBytecode` 对象，这个对象随后会被 WebAssembly 解释器使用来执行 WebAssembly 代码。它处于 WebAssembly 执行流程的早期阶段，是连接 WebAssembly 模块和 V8 解释器的桥梁。

### 提示词
```
这是目录为v8/src/wasm/interpreter/wasm-interpreter.cc的一个c++源代码文件， 请归纳一下它的功能, 如果它与javascript的功能有关系，请用javascript举例说明
这是第8部分，共8部分，请归纳一下它的功能
```

### 源代码
```
\
  }
      LOAD_LANE_CASE(Load8Lane)
      LOAD_LANE_CASE(Load16Lane)
      LOAD_LANE_CASE(Load32Lane)
      LOAD_LANE_CASE(Load64Lane)
#undef LOAD_LANE_CASE

#define STORE_LANE_CASE(op)                                  \
  case kExprS128##op: {                                      \
    EMIT_INSTR_HANDLER_WITH_PC(s2s_SimdS128##op, instr.pc);  \
    S128Pop();                                               \
    EmitI64Const(instr.optional.simd_loadstore_lane.offset); \
    I32Pop();                                                \
    /* emit 8 bits ? */                                      \
    EmitI16Const(instr.optional.simd_loadstore_lane.lane);   \
    return RegMode::kNoReg;                                  \
  }
      STORE_LANE_CASE(Store8Lane)
      STORE_LANE_CASE(Store16Lane)
      STORE_LANE_CASE(Store32Lane)
      STORE_LANE_CASE(Store64Lane)
#undef STORE_LANE_CASE

#define EXT_ADD_PAIRWISE_CASE(op)     \
  case kExpr##op: {                   \
    EMIT_INSTR_HANDLER(s2s_Simd##op); \
    S128Pop();                        \
    S128Push();                       \
    return RegMode::kNoReg;           \
  }
      EXT_ADD_PAIRWISE_CASE(I32x4ExtAddPairwiseI16x8S)
      EXT_ADD_PAIRWISE_CASE(I32x4ExtAddPairwiseI16x8U)
      EXT_ADD_PAIRWISE_CASE(I16x8ExtAddPairwiseI8x16S)
      EXT_ADD_PAIRWISE_CASE(I16x8ExtAddPairwiseI8x16U)
#undef EXT_ADD_PAIRWISE_CASE

    default:
      FATAL("Unknown or unimplemented opcode #%d:%s",
            wasm_code_->start[instr.pc],
            WasmOpcodes::OpcodeName(
                static_cast<WasmOpcode>(wasm_code_->start[instr.pc])));
      UNREACHABLE();
  }

  return RegMode::kNoReg;
}

bool WasmBytecodeGenerator::EncodeSuperInstruction(
    RegMode& reg_mode, const WasmInstruction& curr_instr,
    const WasmInstruction& next_instr) {
  if (curr_instr.orig >= kExprI32LoadMem &&
      curr_instr.orig <= kExprI64LoadMem32U &&
      next_instr.orig == kExprLocalSet) {
    // Do not optimize if we are updating a shared slot.
    uint32_t to_stack_index = next_instr.optional.index;
    if (HasSharedSlot(to_stack_index)) return false;

    switch (curr_instr.orig) {
// The implementation of r2s_LoadMem_LocalSet is identical to the
// implementation of r2s_LoadMem, so we can reuse the same builtin.
#define LOAD_CASE(name, ctype, mtype, rep, type)                        \
  case kExpr##name: {                                                   \
    if (reg_mode == RegMode::kNoReg) {                                  \
      EMIT_INSTR_HANDLER_WITH_PC(s2s_##name##_LocalSet, curr_instr.pc); \
      EmitI64Const(static_cast<uint64_t>(curr_instr.optional.offset));  \
      I32Pop();                                                         \
      EmitI32Const(slots_[stack_[to_stack_index]].slot_offset);         \
      reg_mode = RegMode::kNoReg;                                       \
    } else {                                                            \
      EMIT_INSTR_HANDLER_WITH_PC(r2s_##name, curr_instr.pc);            \
      EmitI64Const(static_cast<uint64_t>(curr_instr.optional.offset));  \
      EmitI32Const(slots_[stack_[to_stack_index]].slot_offset);         \
      reg_mode = RegMode::kNoReg;                                       \
    }                                                                   \
    return true;                                                        \
  }
      LOAD_CASE(I32LoadMem8S, int32_t, int8_t, kWord8, I32);
      LOAD_CASE(I32LoadMem8U, int32_t, uint8_t, kWord8, I32);
      LOAD_CASE(I32LoadMem16S, int32_t, int16_t, kWord16, I32);
      LOAD_CASE(I32LoadMem16U, int32_t, uint16_t, kWord16, I32);
      LOAD_CASE(I64LoadMem8S, int64_t, int8_t, kWord8, I64);
      LOAD_CASE(I64LoadMem8U, int64_t, uint8_t, kWord16, I64);
      LOAD_CASE(I64LoadMem16S, int64_t, int16_t, kWord16, I64);
      LOAD_CASE(I64LoadMem16U, int64_t, uint16_t, kWord16, I64);
      LOAD_CASE(I64LoadMem32S, int64_t, int32_t, kWord32, I64);
      LOAD_CASE(I64LoadMem32U, int64_t, uint32_t, kWord32, I64);
      LOAD_CASE(I32LoadMem, int32_t, int32_t, kWord32, I32);
      LOAD_CASE(I64LoadMem, int64_t, int64_t, kWord64, I64);
      LOAD_CASE(F32LoadMem, Float32, uint32_t, kFloat32, F32);
      LOAD_CASE(F64LoadMem, Float64, uint64_t, kFloat64, F64);
#undef LOAD_CASE

      default:
        return false;
    }
  } else if (curr_instr.orig == kExprI32LoadMem &&
             next_instr.orig == kExprI32StoreMem) {
    if (reg_mode == RegMode::kNoReg) {
      EMIT_INSTR_HANDLER_WITH_PC(s2s_I32LoadStoreMem, curr_instr.pc);
      EmitI64Const(
          static_cast<uint64_t>(curr_instr.optional.offset));  // load_offset
      I32Pop();                                                // load_index
    } else {
      EMIT_INSTR_HANDLER_WITH_PC(r2s_I32LoadStoreMem, curr_instr.pc);
      EmitI64Const(
          static_cast<uint64_t>(curr_instr.optional.offset));  // load_offset
    }
    EmitI64Const(
        static_cast<uint64_t>(next_instr.optional.offset));  // store_offset
    I32Pop();                                                // store_index
    reg_mode = RegMode::kNoReg;
    return true;
  } else if (curr_instr.orig == kExprI64LoadMem &&
             next_instr.orig == kExprI64StoreMem) {
    if (reg_mode == RegMode::kNoReg) {
      EMIT_INSTR_HANDLER_WITH_PC(s2s_I64LoadStoreMem, curr_instr.pc);
      EmitI64Const(static_cast<uint64_t>(curr_instr.optional.offset));
      I32Pop();
    } else {
      EMIT_INSTR_HANDLER_WITH_PC(r2s_I64LoadStoreMem, curr_instr.pc);
      EmitI64Const(static_cast<uint64_t>(curr_instr.optional.offset));
    }
    EmitI64Const(static_cast<uint64_t>(next_instr.optional.offset));
    I32Pop();
    reg_mode = RegMode::kNoReg;
    return true;
  } else if (curr_instr.orig == kExprF32LoadMem &&
             next_instr.orig == kExprF32StoreMem) {
    if (reg_mode == RegMode::kNoReg) {
      EMIT_INSTR_HANDLER_WITH_PC(s2s_F32LoadStoreMem, curr_instr.pc);
      EmitI64Const(static_cast<uint64_t>(curr_instr.optional.offset));
      I32Pop();
    } else {
      EMIT_INSTR_HANDLER_WITH_PC(r2s_F32LoadStoreMem, curr_instr.pc);
      EmitI64Const(static_cast<uint64_t>(curr_instr.optional.offset));
    }
    EmitI64Const(static_cast<uint64_t>(next_instr.optional.offset));
    I32Pop();
    reg_mode = RegMode::kNoReg;
    return true;
  } else if (curr_instr.orig == kExprF64LoadMem &&
             next_instr.orig == kExprF64StoreMem) {
    if (reg_mode == RegMode::kNoReg) {
      EMIT_INSTR_HANDLER_WITH_PC(s2s_F64LoadStoreMem, curr_instr.pc);
      EmitI64Const(static_cast<uint64_t>(curr_instr.optional.offset));
      I32Pop();
    } else {
      EMIT_INSTR_HANDLER_WITH_PC(r2s_F64LoadStoreMem, curr_instr.pc);
      EmitI64Const(static_cast<uint64_t>(curr_instr.optional.offset));
    }
    EmitI64Const(static_cast<uint64_t>(next_instr.optional.offset));
    I32Pop();
    reg_mode = RegMode::kNoReg;
    return true;
  } else if (curr_instr.orig >= kExprI32Const &&
             curr_instr.orig <= kExprF32Const &&
             next_instr.orig == kExprLocalSet) {
    uint32_t to_stack_index = next_instr.optional.index;
    switch (curr_instr.orig) {
      case kExprI32Const: {
        uint32_t from_slot_index =
            CreateConstSlot<int32_t>(curr_instr.optional.i32);
        CopyToSlot(kWasmI32, from_slot_index, to_stack_index, false);
        reg_mode = RegMode::kNoReg;
        return true;
      }
      case kExprI64Const: {
        uint32_t from_slot_index =
            CreateConstSlot<int64_t>(curr_instr.optional.i64);
        CopyToSlot(kWasmI64, from_slot_index, to_stack_index, false);
        reg_mode = RegMode::kNoReg;
        return true;
      }
      case kExprF32Const: {
        uint32_t from_slot_index =
            CreateConstSlot<float>(curr_instr.optional.f32);
        CopyToSlot(kWasmF32, from_slot_index, to_stack_index, false);
        reg_mode = RegMode::kNoReg;
        return true;
      }
      case kExprF64Const: {
        uint32_t from_slot_index =
            CreateConstSlot<double>(curr_instr.optional.f64);
        CopyToSlot(kWasmF64, from_slot_index, to_stack_index, false);
        reg_mode = RegMode::kNoReg;
        return true;
      }
      default:
        return false;
    }
  } else if (curr_instr.orig == kExprLocalGet &&
             next_instr.orig >= kExprI32StoreMem &&
             next_instr.orig <= kExprI64StoreMem32) {
    switch (next_instr.orig) {
// The implementation of r2s_LocalGet_StoreMem is identical to the
// implementation of r2s_StoreMem, so we can reuse the same builtin.
#define STORE_CASE(name, ctype, mtype, rep, type)                        \
  case kExpr##name: {                                                    \
    EMIT_INSTR_HANDLER_WITH_PC(s2s_##name, curr_instr.pc);               \
    EmitI32Const(slots_[stack_[curr_instr.optional.index]].slot_offset); \
    EmitI64Const(static_cast<uint64_t>(next_instr.optional.offset));     \
    I32Pop();                                                            \
    reg_mode = RegMode::kNoReg;                                          \
    return true;                                                         \
  }
      STORE_CASE(I32StoreMem8, int32_t, int8_t, kWord8, I32);
      STORE_CASE(I32StoreMem16, int32_t, int16_t, kWord16, I32);
      STORE_CASE(I64StoreMem8, int64_t, int8_t, kWord8, I64);
      STORE_CASE(I64StoreMem16, int64_t, int16_t, kWord16, I64);
      STORE_CASE(I64StoreMem32, int64_t, int32_t, kWord32, I64);
      STORE_CASE(I32StoreMem, int32_t, int32_t, kWord32, I32);
      STORE_CASE(I64StoreMem, int64_t, int64_t, kWord64, I64);
      STORE_CASE(F32StoreMem, Float32, uint32_t, kFloat32, F32);
      STORE_CASE(F64StoreMem, Float64, uint64_t, kFloat64, F64);
#undef STORE_CASE

      default:
        return false;
    }
  }

  return false;
}

std::unique_ptr<WasmBytecode> WasmBytecodeGenerator::GenerateBytecode() {
#ifdef V8_ENABLE_DRUMBRAKE_TRACING
  if (v8_flags.trace_drumbrake_bytecode_generator) {
    printf("\nGenerate bytecode for function: %d\n", function_index_);
  }
#endif  // V8_ENABLE_DRUMBRAKE_TRACING

  uint32_t const_slots = ScanConstInstructions();
  const_slots_values_.resize(const_slots * kSlotSize);

  pc_t pc = wasm_code_->locals.encoded_size;
  RegMode reg_mode = RegMode::kNoReg;

  Decoder decoder(wasm_code_->start, wasm_code_->end);

  current_block_index_ = -1;

  // Init stack_ with return values, args and local types.

  for (uint32_t index = 0; index < return_count_; index++) {
    CreateSlot(wasm_code_->function->sig->GetReturn(index));
  }

  for (uint32_t index = 0; index < args_count_; index++) {
    _PushSlot(wasm_code_->function->sig->GetParam(index));
  }

  // Reserve space for const slots
  slot_offset_ += const_slots;

  for (uint32_t index = 0; index < wasm_code_->locals.num_locals; index++) {
    _PushSlot(wasm_code_->locals.local_types[index]);
  }

  current_block_index_ =
      BeginBlock(kExprBlock, {wasm_code_->function->sig_index, kBottom});

  WasmInstruction curr_instr;
  WasmInstruction next_instr;

  pc_t limit = wasm_code_->end - wasm_code_->start;
  while (pc < limit) {
    DCHECK_NOT_NULL(wasm_code_->start);

    if (!curr_instr) {
      curr_instr = DecodeInstruction(pc, decoder);
      if (curr_instr) pc += curr_instr.length;
    }
    if (!curr_instr) break;
    DCHECK(!next_instr);
    next_instr = DecodeInstruction(pc, decoder);
    if (next_instr) pc += next_instr.length;

    if (next_instr) {
      if (v8_flags.drumbrake_super_instructions && is_instruction_reachable_ &&
          EncodeSuperInstruction(reg_mode, curr_instr, next_instr)) {
        curr_instr = {};
        next_instr = {};
      } else {
        reg_mode =
            EncodeInstruction(curr_instr, reg_mode, next_instr.InputRegMode());
        curr_instr = next_instr;
        next_instr = {};
      }
    } else {
      reg_mode = EncodeInstruction(curr_instr, reg_mode, RegMode::kNoReg);
      curr_instr = {};
    }

    if (pc == limit && curr_instr) {
      reg_mode = EncodeInstruction(curr_instr, reg_mode, RegMode::kNoReg);
    }
  }

  PatchLoopJumpInstructions();
  PatchBranchOffsets();

  return std::make_unique<WasmBytecode>(
      function_index_, code_.data(), code_.size(), slot_offset_,
      module_->functions[function_index_].sig, wasm_code_, blocks_.size(),
      const_slots_values_.data(), const_slots_values_.size(), ref_slots_count_,
      std::move(eh_data_), std::move(code_pc_map_));
}

int32_t WasmBytecodeGenerator::BeginBlock(
    WasmOpcode opcode, const WasmInstruction::Optional::Block signature) {
  if (opcode == kExprLoop) {
    last_instr_offset_ = kInvalidCodeOffset;
  }

  int32_t block_index = static_cast<int32_t>(blocks_.size());
  uint32_t stack_size = this->stack_size();

  uint32_t first_block_index = 0;
  size_t rets_slots_count = 0;
  size_t params_slots_count = 0;
  if (block_index > 0 && (opcode != kExprElse && opcode != kExprCatch &&
                          opcode != kExprCatchAll)) {
    first_block_index = ReserveBlockSlots(opcode, signature, &rets_slots_count,
                                          &params_slots_count);
  }

  uint32_t parent_block_index = current_block_index_;
  if (opcode == kExprCatch || opcode == kExprCatchAll) {
    parent_block_index =
        blocks_[eh_data_.GetCurrentTryBlockIndex()].parent_block_index_;
  }

  blocks_.emplace_back(opcode, CurrentCodePos(), parent_block_index, stack_size,
                       signature, first_block_index, rets_slots_count,
                       params_slots_count, eh_data_.GetCurrentTryBlockIndex());
  current_block_index_ = block_index;

  if (opcode == kExprIf && params_slots_count > 0) {
    DCHECK_GE(stack_size, params_slots_count);
    blocks_.back().SaveParams(&stack_[stack_size - params_slots_count],
                              params_slots_count);
  }

  if (opcode == kExprLoop) {
    StoreBlockParamsIntoSlots(current_block_index_, true);
    blocks_[current_block_index_].begin_code_offset_ = CurrentCodePos();
    last_instr_offset_ = kInvalidCodeOffset;
  }
  return current_block_index_;
}

int WasmBytecodeGenerator::GetCurrentTryBlockIndex(
    bool return_matching_try_for_catch_blocks) const {
  DCHECK_GE(current_block_index_, 0);
  int index = current_block_index_;
  while (index >= 0) {
    const auto& block = blocks_[index];
    if (block.IsTry()) return index;
    if (return_matching_try_for_catch_blocks &&
        (block.IsCatch() || block.IsCatchAll())) {
      return block.parent_try_block_index_;
    }
    index = blocks_[index].parent_block_index_;
  }
  return -1;
}

void WasmBytecodeGenerator::PatchLoopJumpInstructions() {
  if (ref_slots_count_ == 0) {
    for (size_t i = 0; i < loop_end_code_offsets_.size(); i++) {
      base::WriteUnalignedValue<InstructionHandler>(
          reinterpret_cast<Address>(code_.data() + loop_end_code_offsets_[i]),
          k_s2s_Nop);
    }
  }
}

void WasmBytecodeGenerator::PatchBranchOffsets() {
  static const uint32_t kElseBlockStartOffset =
      sizeof(InstructionHandler) + sizeof(uint32_t);

  for (int block_index = 0; block_index < static_cast<int>(blocks_.size());
       block_index++) {
    const BlockData block_data = blocks_[block_index];
    for (size_t i = 0; i < block_data.branch_code_offsets_.size(); i++) {
      uint32_t current_code_offset = block_data.branch_code_offsets_[i];
      uint32_t target_offset = block_data.end_code_offset_;
      if (block_data.IsLoop()) {
        target_offset = block_data.begin_code_offset_;
      } else if (block_data.IsIf() && block_data.if_else_block_index_ >= 0 &&
                 current_code_offset == block_data.begin_code_offset_) {
        // Jumps to the 'else' branch.
        target_offset =
            blocks_[block_data.if_else_block_index_].begin_code_offset_ +
            kElseBlockStartOffset;
      } else if ((block_data.IsCatch() || block_data.IsCatchAll()) &&
                 current_code_offset == block_data.begin_code_offset_ +
                                            sizeof(InstructionHandler)) {
        // Jumps to the end of a sequence of 'try'/'catch' branches.
        target_offset = static_cast<uint32_t>(
            eh_data_.GetEndInstructionOffsetFor(block_index));
      }

      int32_t delta = target_offset - current_code_offset;
      base::WriteUnalignedValue<uint32_t>(
          reinterpret_cast<Address>(code_.data() + current_code_offset), delta);
    }
  }
}

bool WasmBytecodeGenerator::TryCompactInstructionHandler(
    InstructionHandler func_id) {
  if (last_instr_offset_ == kInvalidCodeOffset) return false;
  InstructionHandler* prev_instr_addr =
      reinterpret_cast<InstructionHandler*>(code_.data() + last_instr_offset_);
  InstructionHandler prev_instr_handler = *prev_instr_addr;
  if (func_id == k_s2s_CopySlot32 && prev_instr_handler == k_s2s_CopySlot32) {
    // Tranforms:
    //  [CopySlot32: InstrId][from: u32][to: u32]
    // into:
    //  [CopySlot32x2: InstrId][from0: u32][to0: u32][from1: u32][to1: u32]
    base::WriteUnalignedValue<InstructionHandler>(
        reinterpret_cast<Address>(prev_instr_addr), k_s2s_CopySlot32x2);
    return true;
  } else if (func_id == k_s2s_CopySlot64 &&
             prev_instr_handler == k_s2s_CopySlot64) {
    base::WriteUnalignedValue<InstructionHandler>(
        reinterpret_cast<Address>(prev_instr_addr), k_s2s_CopySlot64x2);
    return true;
  }
  return false;
}

ClearThreadInWasmScope::ClearThreadInWasmScope(Isolate* isolate)
    : isolate_(isolate) {
  DCHECK_IMPLIES(trap_handler::IsTrapHandlerEnabled(),
                 trap_handler::IsThreadInWasm());
  trap_handler::ClearThreadInWasm();
}

ClearThreadInWasmScope ::~ClearThreadInWasmScope() {
  DCHECK_IMPLIES(trap_handler::IsTrapHandlerEnabled(),
                 !trap_handler::IsThreadInWasm());
  if (!isolate_->has_exception()) {
    trap_handler::SetThreadInWasm();
  }
  // Otherwise we only want to set the flag if the exception is caught in
  // wasm. This is handled by the unwinder.
}

}  // namespace wasm
}  // namespace internal
}  // namespace v8
```
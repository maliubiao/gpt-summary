Response:
Let's break down the thought process for analyzing this C++ header file.

1. **Initial Scan and Keyword Recognition:**  The first step is to quickly scan the code for recognizable patterns and keywords. I see:
    * `#ifndef`, `#define`, `#include`: Standard C/C++ header guards and includes.
    * `namespace v8::internal`:  Confirms it's V8 internal code.
    * `// Copyright`: Standard copyright notice.
    * `#if !V8_ENABLE_WEBASSEMBLY`: Conditional compilation, indicating this is WebAssembly related.
    * `TQ_OBJECT_CONSTRUCTORS_IMPL`: A macro that looks related to object construction, potentially using Torque.
    * `ACCESSORS`, `PRIMITIVE_ACCESSORS`, `OPTIONAL_ACCESSORS`, `TRUSTED_POINTER_ACCESSORS`, `CODE_POINTER_ACCESSORS`, `EXTERNAL_POINTER_ACCESSORS`:  Macros for generating getter/setter methods, very common in V8's object model.
    * Data types like `int`, `uint32_t`, `float`, `double`, `Address`, `Tagged<>`, `Handle<>`.
    * Class names starting with `Wasm`:  Strong indication of WebAssembly specific objects.
    * `wasm::`:  Namespace for the WebAssembly subsystem within V8.
    * `// TODO`:  Indicates areas for future work or potential cleanup.
    * `DCHECK`, `SLOW_DCHECK`, `SBXCHECK`:  Debugging assertions used extensively in V8.
    * `template <> struct CastTraits`:  Pattern for enabling casting between types in V8.
    * `#include "torque-generated/src/wasm/wasm-objects-tq-inl.inc"`: Explicit inclusion of Torque-generated code.

2. **High-Level Functionality Identification:** Based on the keywords and class names, it's clear the file defines the *inlined* implementations of methods for various WebAssembly-related object types within V8. The `.inl.h` extension strongly suggests inlined methods. The class names (e.g., `WasmModuleObject`, `WasmMemoryObject`, `WasmGlobalObject`) directly suggest what aspects of WebAssembly they represent.

3. **Torque Detection:** The presence of `#include "torque-generated/src/wasm/wasm-objects-tq-inl.inc"` and `TQ_OBJECT_CONSTRUCTORS_IMPL` definitively confirms that this file relies on and includes code generated by the Torque language. Therefore, the answer to whether it *could* be a Torque file if it ended in `.tq` is "yes, at least partially, as it integrates with Torque-generated code."

4. **Core Functionality Breakdown (By Section):** Now, go through the file section by section, focusing on the macros and their usage:

    * **Includes:** Identify the key dependencies. `wasm/*` headers are crucial. `src/objects/*` indicates interaction with V8's general object model.
    * **Torque Integration:** Note the include and the constructor implementations. Explain Torque's role.
    * **Accessor Macros:**  This is a major part. Explain what each macro does (getter, setter, optional presence check). Recognize that they simplify the creation of methods to access object fields.
    * **Specific Object Implementations (e.g., `WasmModuleObject`, `WasmGlobalObject`):**  For each significant object, identify:
        * Key data members (based on the accessor macros).
        * Purpose of the object (e.g., `WasmModuleObject` represents a compiled WebAssembly module).
        * Any interesting logic within the methods (e.g., `WasmGlobalObject::type()` with the `SBXCHECK`).
    * **`WasmTrustedInstanceData`:** Recognize this as a central data structure holding instance-specific information. Note the `PROTECTED_POINTER_ACCESSORS`, indicating a trust boundary.
    * **`WasmDispatchTable`:**  Understand its role in indirect function calls.
    * **Function Types (`WasmExportedFunction`, `WasmInternalFunction`, etc.):**  See how they relate to JavaScript functions and internal WebAssembly functions.
    * **`WasmStruct` and `WasmArray`:** Focus on how they represent WebAssembly's structured data and arrays, and the special handling of their sizes in the `Map`.
    * **`WasmObject::ReadValueAt`:** This function is significant for its ability to read different WebAssembly value types from a generic `WasmObject`. This is a good place for a JavaScript example.
    * **`WasmObject::FromNumber`:**  The reverse operation, converting JavaScript numbers to WebAssembly types.
    * **`WasmTableObject` and `WasmMemoryObject`:** Understand their representation of WebAssembly tables and linear memory.

5. **JavaScript Relationship:**  Look for connections to JavaScript concepts. `WasmExportedFunction` being a subclass of `JSFunction` is a key connection. The `WasmObject::ReadValueAt` function demonstrates how JavaScript interacts with WebAssembly memory. Think about how you would *use* a WebAssembly module in JavaScript.

6. **Code Logic and Assumptions:** Analyze specific code snippets, like `WasmGlobalObject::type()`, and identify assumptions (e.g., the `SBXCHECK` assumes potential corruption). For logic, choose a simpler example like checking the bounds of a table (`WasmTableObject::is_in_bounds`). Formulate a simple input/output based on the code.

7. **Common Programming Errors:** Think about the potential pitfalls when working with WebAssembly from a JavaScript perspective. Type mismatches, out-of-bounds access, and incorrect function calls are common issues. Craft simple JavaScript examples to illustrate these.

8. **Structure and Refine:** Organize the findings logically. Start with a general overview, then delve into specific functionalities. Use clear headings and bullet points. Refine the language for clarity and accuracy. Ensure the JavaScript examples are concise and directly related to the C++ code.

**Self-Correction/Refinement During the Process:**

* **Initial thought:** "Are these just class definitions?"  **Correction:** No, the `.inl.h` extension and the presence of method implementations mean this provides *inlined* method definitions.
* **Realization:** The accessor macros are very important. Need to explain their purpose and how they simplify code generation.
* **Connecting C++ to JavaScript:** Don't just describe the C++. Actively think about how these C++ objects are manifested and interacted with in JavaScript.
* **Choosing appropriate examples:** Keep the JavaScript and code logic examples simple and focused on illustrating the specific functionality being discussed. Avoid overly complex scenarios.
* **Clarity of explanation:** Ensure that technical terms are explained clearly, and the relationship between different parts of the code is evident. For instance, explicitly state that `WasmTrustedInstanceData` holds data for a *specific instance* of a WebAssembly module.

By following this systematic approach, combining code analysis with knowledge of V8 and WebAssembly concepts, I can arrive at a comprehensive and accurate description of the header file's functionality.
这个文件 `v8/src/wasm/wasm-objects-inl.h` 是 V8 引擎中关于 WebAssembly 对象内联函数定义的头文件。 它的主要功能是为 `v8/src/wasm/wasm-objects.h` 中声明的 WebAssembly 相关对象提供内联的成员函数实现，这些实现通常是简单的 getter、setter 或一些小的辅助函数。 使用内联函数可以减少函数调用的开销，提高性能。

**主要功能可以总结为:**

1. **提供 WebAssembly 对象的内联方法实现:**  文件中定义了诸如 `WasmModuleObject`, `WasmMemoryObject`, `WasmGlobalObject`, `WasmInstanceObject` 等多种 WebAssembly 对象的成员函数的具体实现。 这些函数通常用于访问和修改对象的内部状态。

2. **定义访问器 (Accessors) 宏:** 文件中使用了大量的宏 (如 `ACCESSORS`, `PRIMITIVE_ACCESSORS`, `OPTIONAL_ACCESSORS`, `TRUSTED_POINTER_ACCESSORS` 等) 来简化 getter 和 setter 方法的定义。 这些宏根据字段的类型和特性自动生成相应的访问方法。

3. **处理 WebAssembly 特定的数据结构:**  文件中定义了如何访问和操作 WebAssembly 特有的数据结构，例如内存、全局变量、表等。

4. **实现类型转换和检查:**  文件中包含了一些用于类型转换和安全检查的函数，例如 `WasmObject::ReadValueAt` 和 `WasmObject::FromNumber`。

**关于文件名后缀 `.tq`:**

如果 `v8/src/wasm/wasm-objects-inl.h` 以 `.tq` 结尾，那么它将是 **V8 Torque 源代码**。 Torque 是 V8 团队开发的一种用于编写高效运行时代码的领域特定语言。 Torque 代码会被编译成 C++ 代码，然后与 V8 的其余部分一起编译。  当前的文件名是 `.h`，表明它是标准的 C++ 头文件，但它 *包含* 了 Torque 生成的代码 (`#include "torque-generated/src/wasm/wasm-objects-tq-inl.inc"`).

**与 JavaScript 的功能关系及举例:**

`v8/src/wasm/wasm-objects-inl.h` 中定义的 WebAssembly 对象直接对应于 JavaScript 中可以操作的 WebAssembly API。 例如：

* **`WasmModuleObject`**:  对应于 JavaScript 中的 `WebAssembly.Module` 对象。 它代表一个已经编译的 WebAssembly 模块。
* **`WasmMemoryObject`**: 对应于 JavaScript 中的 `WebAssembly.Memory` 对象。 它代表 WebAssembly 实例的线性内存。
* **`WasmGlobalObject`**: 对应于 JavaScript 中的 `WebAssembly.Global` 对象。 它代表 WebAssembly 实例的全局变量。
* **`WasmInstanceObject`**: 对应于 JavaScript 中的 `WebAssembly.Instance` 对象。 它代表一个 WebAssembly 模块的实例，包含了模块的内存、全局变量和导出的函数。
* **`WasmTableObject`**: 对应于 JavaScript 中的 `WebAssembly.Table` 对象。 它代表一个类型化的引用数组。

**JavaScript 示例:**

```javascript
// 假设已经编译了一个 WebAssembly 模块并实例化
const wasmModule = new WebAssembly.Module(wasmBinary);
const wasmMemory = new WebAssembly.Memory({ initial: 1 });
const importObject = {
  env: {
    memory: wasmMemory,
    // ... 其他导入
  },
};
const wasmInstance = new WebAssembly.Instance(wasmModule, importObject);

// 获取导出的函数
const exportedFunction = wasmInstance.exports.myFunction;

// 调用导出的函数
const result = exportedFunction(42);

// 访问导出的内存
const memoryBuffer = wasmMemory.buffer;
const memoryView = new Uint8Array(memoryBuffer);
console.log(memoryView[0]);

// 获取导出的全局变量
const globalVar = wasmInstance.exports.myGlobal;
console.log(globalVar.value);
```

在 V8 的内部实现中，当 JavaScript 代码创建 `WebAssembly.Module`、`WebAssembly.Memory`、`WebAssembly.Instance` 等对象时，V8 会在底层创建并操作 `WasmModuleObject`、`WasmMemoryObject`、`WasmInstanceObject` 等 C++ 对象。 `wasm-objects-inl.h` 中定义的访问器和方法就是用来操作这些底层对象的。

**代码逻辑推理和假设输入/输出:**

考虑 `WasmGlobalObject::GetI32()` 方法：

```c++
int32_t WasmGlobalObject::GetI32() {
  return base::ReadUnalignedValue<int32_t>(address());
}
```

**假设输入:**

* 一个 `WasmGlobalObject` 实例，其 `type()` 返回 `wasm::kI32` (表示这是一个 32 位整型全局变量)。
* 该全局变量在内存中的地址由 `address()` 方法返回。
* 假设该地址指向的内存区域存储着一个 32 位整数值，例如 `0x12345678`。

**输出:**

* 函数 `GetI32()` 将返回 `0x12345678` 这个整数值。

**代码逻辑:**

1. `address()` 方法计算出全局变量在内存中的起始地址。
2. `base::ReadUnalignedValue<int32_t>(address())`  从该地址读取 4 个字节 (因为是 `int32_t`)，并将其解释为一个 32 位整数。
3. 读取到的整数值被作为函数的返回值。

**涉及用户常见的编程错误及举例:**

1. **尝试访问超出 WebAssembly 内存边界的地址:**

   **JavaScript 示例:**

   ```javascript
   const wasmMemory = new WebAssembly.Memory({ initial: 1 });
   const memoryBuffer = wasmMemory.buffer;
   const memoryView = new Uint8Array(memoryBuffer);

   // 内存初始大小为 65536 字节
   // 尝试访问超出边界的索引
   console.log(memoryView[100000]); // 可能会导致错误或未定义行为
   ```

   在 V8 的底层实现中，当 JavaScript 尝试访问超出 `WasmMemoryObject` 表示的内存范围时，相关的 C++ 代码（可能涉及到 `wasm-objects-inl.h` 中定义的方法，例如在执行 WebAssembly 指令时访问内存）会进行边界检查。 如果访问越界，V8 会抛出一个 JavaScript 错误 (例如 `RangeError: Out of bounds memory access`)。

2. **类型不匹配地访问 WebAssembly 全局变量:**

   **JavaScript 示例:**

   ```javascript
   // 假设 wasmInstance.exports.myGlobal 是一个 i32 类型的全局变量
   const globalVar = wasmInstance.exports.myGlobal;

   // 错误地将其视为浮点数
   console.log(globalVar.value); // 获取的是 i32 的值

   // 尝试设置一个错误的类型
   // globalVar.value = 3.14; // 可能会被隐式转换或导致类型错误，取决于具体实现
   ```

   在 V8 的底层实现中，`WasmGlobalObject` 存储了全局变量的类型信息。 当 JavaScript 代码尝试访问或设置全局变量的值时，V8 会检查类型是否匹配。  如果类型不匹配，可能会进行隐式类型转换（例如，将浮点数转换为整数），或者在严格模式下抛出错误。  `wasm-objects-inl.h` 中与 `WasmGlobalObject` 相关的访问器方法会根据其声明的类型进行数据的读取和写入。

3. **错误地操作 WebAssembly 表 (Table):**

   **JavaScript 示例:**

   ```javascript
   // 假设 wasmInstance.exports.myTable 是一个存储函数的表
   const table = wasmInstance.exports.myTable;

   // 尝试获取超出表大小的元素
   const element = table.get(1000); // 如果表的大小小于 1000，则返回 null

   // 尝试设置表元素为错误的类型
   // table.set(0, 123); // 如果表存储的是函数引用，则会出错
   ```

   在 V8 的底层实现中，`WasmTableObject` 维护了表的大小和元素类型。 当 JavaScript 代码尝试访问或设置表中的元素时，V8 会进行边界检查和类型检查。 `wasm-objects-inl.h` 中 `WasmTableObject` 的相关方法（例如访问内部存储）会执行这些检查，确保操作的合法性。

总而言之，`v8/src/wasm/wasm-objects-inl.h` 是 V8 引擎中 WebAssembly 功能实现的关键组成部分，它提供了高效的方式来操作 WebAssembly 的各种对象，并且与 JavaScript 中暴露的 WebAssembly API 有着直接的对应关系。 了解这个文件的功能有助于深入理解 V8 如何执行 WebAssembly 代码。

Prompt: 
```
这是目录为v8/src/wasm/wasm-objects-inl.h的一个v8源代码， 请列举一下它的功能, 
如果v8/src/wasm/wasm-objects-inl.h以.tq结尾，那它是个v8 torque源代码，
如果它与javascript的功能有关系，请用javascript举例说明,
如果有代码逻辑推理，请给出假设输入与输出，
如果涉及用户常见的编程错误，请举例说明

"""
// Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if !V8_ENABLE_WEBASSEMBLY
#error This header should only be included if WebAssembly is enabled.
#endif  // !V8_ENABLE_WEBASSEMBLY

#ifndef V8_WASM_WASM_OBJECTS_INL_H_
#define V8_WASM_WASM_OBJECTS_INL_H_

#include <type_traits>

#include "src/base/memory.h"
#include "src/common/ptr-compr.h"
#include "src/heap/heap-write-barrier-inl.h"
#include "src/objects/contexts-inl.h"
#include "src/objects/foreign.h"
#include "src/objects/heap-number.h"
#include "src/objects/js-array-buffer-inl.h"
#include "src/objects/js-function-inl.h"
#include "src/objects/js-objects-inl.h"
#include "src/objects/managed.h"
#include "src/objects/oddball-inl.h"
#include "src/objects/script-inl.h"
#include "src/roots/roots.h"
#include "src/wasm/wasm-code-manager.h"
#include "src/wasm/wasm-module.h"
#include "src/wasm/wasm-objects.h"
#include "third_party/fp16/src/include/fp16.h"

#if V8_ENABLE_DRUMBRAKE
#include "src/wasm/interpreter/wasm-interpreter-objects.h"
#endif  // V8_ENABLE_DRUMBRAKE

// Has to be the last include (doesn't have include guards)
#include "src/objects/object-macros.h"

namespace v8::internal {

#include "torque-generated/src/wasm/wasm-objects-tq-inl.inc"

TQ_OBJECT_CONSTRUCTORS_IMPL(AsmWasmData)
TQ_OBJECT_CONSTRUCTORS_IMPL(WasmArray)
TQ_OBJECT_CONSTRUCTORS_IMPL(WasmCapiFunctionData)
TQ_OBJECT_CONSTRUCTORS_IMPL(WasmContinuationObject)
TQ_OBJECT_CONSTRUCTORS_IMPL(WasmExceptionTag)
TQ_OBJECT_CONSTRUCTORS_IMPL(WasmExportedFunctionData)
TQ_OBJECT_CONSTRUCTORS_IMPL(WasmFunctionData)
TQ_OBJECT_CONSTRUCTORS_IMPL(WasmFuncRef)
TQ_OBJECT_CONSTRUCTORS_IMPL(WasmGlobalObject)
TQ_OBJECT_CONSTRUCTORS_IMPL(WasmImportData)
TQ_OBJECT_CONSTRUCTORS_IMPL(WasmInstanceObject)
TQ_OBJECT_CONSTRUCTORS_IMPL(WasmInternalFunction)
TQ_OBJECT_CONSTRUCTORS_IMPL(WasmJSFunctionData)
TQ_OBJECT_CONSTRUCTORS_IMPL(WasmMemoryObject)
TQ_OBJECT_CONSTRUCTORS_IMPL(WasmModuleObject)
TQ_OBJECT_CONSTRUCTORS_IMPL(WasmNull)
TQ_OBJECT_CONSTRUCTORS_IMPL(WasmObject)
TQ_OBJECT_CONSTRUCTORS_IMPL(WasmResumeData)
TQ_OBJECT_CONSTRUCTORS_IMPL(WasmStruct)
TQ_OBJECT_CONSTRUCTORS_IMPL(WasmSuspenderObject)
TQ_OBJECT_CONSTRUCTORS_IMPL(WasmSuspendingObject)
TQ_OBJECT_CONSTRUCTORS_IMPL(WasmTableObject)
TQ_OBJECT_CONSTRUCTORS_IMPL(WasmTagObject)
TQ_OBJECT_CONSTRUCTORS_IMPL(WasmTypeInfo)

#define OPTIONAL_ACCESSORS(holder, name, type, offset)       \
  DEF_GETTER(holder, has_##name, bool) {                     \
    Tagged<Object> value =                                   \
        TaggedField<Object, offset>::load(cage_base, *this); \
    return !IsUndefined(value, GetReadOnlyRoots(cage_base)); \
  }                                                          \
  ACCESSORS_CHECKED2(holder, name, type, offset,             \
                     !IsUndefined(value, GetReadOnlyRoots(cage_base)), true)

#define PRIMITIVE_ACCESSORS(holder, name, type, offset)               \
  type holder::name() const {                                         \
    return ReadMaybeUnalignedValue<type>(FIELD_ADDR(*this, offset));  \
  }                                                                   \
  void holder::set_##name(type value) {                               \
    WriteMaybeUnalignedValue<type>(FIELD_ADDR(*this, offset), value); \
  }

// WasmModuleObject
wasm::NativeModule* WasmModuleObject::native_module() const {
  return managed_native_module()->raw();
}
const std::shared_ptr<wasm::NativeModule>&
WasmModuleObject::shared_native_module() const {
  return managed_native_module()->get();
}
const wasm::WasmModule* WasmModuleObject::module() const {
  // TODO(clemensb): Remove this helper (inline in callers).
  return native_module()->module();
}
bool WasmModuleObject::is_asm_js() {
  bool asm_js = is_asmjs_module(module());
  DCHECK_EQ(asm_js, script()->IsUserJavaScript());
  return asm_js;
}

// WasmMemoryObject
ACCESSORS(WasmMemoryObject, instances, Tagged<WeakArrayList>, kInstancesOffset)

// WasmGlobalObject
ACCESSORS(WasmGlobalObject, untagged_buffer, Tagged<JSArrayBuffer>,
          kUntaggedBufferOffset)
ACCESSORS(WasmGlobalObject, tagged_buffer, Tagged<FixedArray>,
          kTaggedBufferOffset)
TRUSTED_POINTER_ACCESSORS(WasmGlobalObject, trusted_data,
                          WasmTrustedInstanceData, kTrustedDataOffset,
                          kWasmTrustedInstanceDataIndirectPointerTag)

wasm::ValueType WasmGlobalObject::type() const {
  // Various consumers of ValueKind (e.g. ValueKind::name()) use the raw enum
  // value as index into a global array. As such, if the index is corrupted
  // (which must be assumed, as it comes from within the sandbox), this can
  // lead to out-of-bounds reads outside the sandbox. While these are not
  // technically sandbox violations, we should still try to avoid them to keep
  // fuzzers happy. This SBXCHECK accomplishes that.
  wasm::ValueType type = wasm::ValueType::FromRawBitField(raw_type());
  SBXCHECK(is_valid(type.kind()));
  return type;
}
void WasmGlobalObject::set_type(wasm::ValueType value) {
  set_raw_type(static_cast<int>(value.raw_bit_field()));
}

int WasmGlobalObject::type_size() const { return type().value_kind_size(); }

Address WasmGlobalObject::address() const {
  DCHECK_NE(type(), wasm::kWasmAnyRef);
  DCHECK_LE(offset() + type_size(), untagged_buffer()->byte_length());
  return reinterpret_cast<Address>(untagged_buffer()->backing_store()) +
         offset();
}

int32_t WasmGlobalObject::GetI32() {
  return base::ReadUnalignedValue<int32_t>(address());
}

int64_t WasmGlobalObject::GetI64() {
  return base::ReadUnalignedValue<int64_t>(address());
}

float WasmGlobalObject::GetF32() {
  return base::ReadUnalignedValue<float>(address());
}

double WasmGlobalObject::GetF64() {
  return base::ReadUnalignedValue<double>(address());
}

uint8_t* WasmGlobalObject::GetS128RawBytes() {
  return reinterpret_cast<uint8_t*>(address());
}

Handle<Object> WasmGlobalObject::GetRef() {
  // We use this getter for externref, funcref, and stringref.
  DCHECK(type().is_reference());
  return handle(tagged_buffer()->get(offset()), GetIsolate());
}

void WasmGlobalObject::SetI32(int32_t value) {
  base::WriteUnalignedValue(address(), value);
}

void WasmGlobalObject::SetI64(int64_t value) {
  base::WriteUnalignedValue(address(), value);
}

void WasmGlobalObject::SetF32(float value) {
  base::WriteUnalignedValue(address(), value);
}

void WasmGlobalObject::SetF64(double value) {
  base::WriteUnalignedValue(address(), value);
}

void WasmGlobalObject::SetRef(DirectHandle<Object> value) {
  DCHECK(type().is_object_reference());
  tagged_buffer()->set(offset(), *value);
}

// WasmTrustedInstanceData
OBJECT_CONSTRUCTORS_IMPL(WasmTrustedInstanceData, ExposedTrustedObject)

PRIMITIVE_ACCESSORS(WasmTrustedInstanceData, memory0_start, uint8_t*,
                    kMemory0StartOffset)
PRIMITIVE_ACCESSORS(WasmTrustedInstanceData, memory0_size, size_t,
                    kMemory0SizeOffset)
PROTECTED_POINTER_ACCESSORS(WasmTrustedInstanceData, managed_native_module,
                            TrustedManaged<wasm::NativeModule>,
                            kProtectedManagedNativeModuleOffset)
PRIMITIVE_ACCESSORS(WasmTrustedInstanceData, new_allocation_limit_address,
                    Address*, kNewAllocationLimitAddressOffset)
PRIMITIVE_ACCESSORS(WasmTrustedInstanceData, new_allocation_top_address,
                    Address*, kNewAllocationTopAddressOffset)
PRIMITIVE_ACCESSORS(WasmTrustedInstanceData, old_allocation_limit_address,
                    Address*, kOldAllocationLimitAddressOffset)
PRIMITIVE_ACCESSORS(WasmTrustedInstanceData, old_allocation_top_address,
                    Address*, kOldAllocationTopAddressOffset)
PRIMITIVE_ACCESSORS(WasmTrustedInstanceData, globals_start, uint8_t*,
                    kGlobalsStartOffset)
ACCESSORS(WasmTrustedInstanceData, imported_mutable_globals,
          Tagged<FixedAddressArray>, kImportedMutableGlobalsOffset)
#if V8_ENABLE_DRUMBRAKE
ACCESSORS(WasmTrustedInstanceData, imported_function_indices,
          Tagged<FixedInt32Array>, kImportedFunctionIndicesOffset)
#endif  // V8_ENABLE_DRUMBRAKE
PRIMITIVE_ACCESSORS(WasmTrustedInstanceData, jump_table_start, Address,
                    kJumpTableStartOffset)
PRIMITIVE_ACCESSORS(WasmTrustedInstanceData, hook_on_function_call_address,
                    Address, kHookOnFunctionCallAddressOffset)
PRIMITIVE_ACCESSORS(WasmTrustedInstanceData, tiering_budget_array,
                    std::atomic<uint32_t>*, kTieringBudgetArrayOffset)
PROTECTED_POINTER_ACCESSORS(WasmTrustedInstanceData, memory_bases_and_sizes,
                            TrustedFixedAddressArray,
                            kProtectedMemoryBasesAndSizesOffset)
ACCESSORS(WasmTrustedInstanceData, data_segment_starts,
          Tagged<FixedAddressArray>, kDataSegmentStartsOffset)
ACCESSORS(WasmTrustedInstanceData, data_segment_sizes, Tagged<FixedUInt32Array>,
          kDataSegmentSizesOffset)
ACCESSORS(WasmTrustedInstanceData, element_segments, Tagged<FixedArray>,
          kElementSegmentsOffset)
PRIMITIVE_ACCESSORS(WasmTrustedInstanceData, break_on_entry, uint8_t,
                    kBreakOnEntryOffset)

OPTIONAL_ACCESSORS(WasmTrustedInstanceData, instance_object,
                   Tagged<WasmInstanceObject>, kInstanceObjectOffset)
ACCESSORS(WasmTrustedInstanceData, native_context, Tagged<Context>,
          kNativeContextOffset)
ACCESSORS(WasmTrustedInstanceData, memory_objects, Tagged<FixedArray>,
          kMemoryObjectsOffset)
OPTIONAL_ACCESSORS(WasmTrustedInstanceData, untagged_globals_buffer,
                   Tagged<JSArrayBuffer>, kUntaggedGlobalsBufferOffset)
OPTIONAL_ACCESSORS(WasmTrustedInstanceData, tagged_globals_buffer,
                   Tagged<FixedArray>, kTaggedGlobalsBufferOffset)
OPTIONAL_ACCESSORS(WasmTrustedInstanceData, imported_mutable_globals_buffers,
                   Tagged<FixedArray>, kImportedMutableGlobalsBuffersOffset)
OPTIONAL_ACCESSORS(WasmTrustedInstanceData, tables, Tagged<FixedArray>,
                   kTablesOffset)
#if V8_ENABLE_DRUMBRAKE
OPTIONAL_ACCESSORS(WasmTrustedInstanceData, interpreter_object, Tagged<Tuple2>,
                   kInterpreterObjectOffset)
#endif  // V8_ENABLE_DRUMBRAKE
PROTECTED_POINTER_ACCESSORS(WasmTrustedInstanceData, shared_part,
                            WasmTrustedInstanceData, kProtectedSharedPartOffset)
PROTECTED_POINTER_ACCESSORS(WasmTrustedInstanceData, dispatch_table0,
                            WasmDispatchTable, kProtectedDispatchTable0Offset)
PROTECTED_POINTER_ACCESSORS(WasmTrustedInstanceData, dispatch_tables,
                            ProtectedFixedArray, kProtectedDispatchTablesOffset)
PROTECTED_POINTER_ACCESSORS(WasmTrustedInstanceData, dispatch_table_for_imports,
                            WasmDispatchTable,
                            kProtectedDispatchTableForImportsOffset)
OPTIONAL_ACCESSORS(WasmTrustedInstanceData, tags_table, Tagged<FixedArray>,
                   kTagsTableOffset)
ACCESSORS(WasmTrustedInstanceData, func_refs, Tagged<FixedArray>,
          kFuncRefsOffset)
ACCESSORS(WasmTrustedInstanceData, managed_object_maps, Tagged<FixedArray>,
          kManagedObjectMapsOffset)
ACCESSORS(WasmTrustedInstanceData, feedback_vectors, Tagged<FixedArray>,
          kFeedbackVectorsOffset)
ACCESSORS(WasmTrustedInstanceData, well_known_imports, Tagged<FixedArray>,
          kWellKnownImportsOffset)
PRIMITIVE_ACCESSORS(WasmTrustedInstanceData, stress_deopt_counter_address,
                    Address, kStressDeoptCounterOffset)

void WasmTrustedInstanceData::clear_padding() {
  constexpr int kPaddingBytes = FIELD_SIZE(kOptionalPaddingOffset);
  static_assert(kPaddingBytes == 0 || kPaddingBytes == kIntSize);
  if constexpr (kPaddingBytes != 0) {
    WriteField<int>(kOptionalPaddingOffset, 0);
  }
}

Tagged<WasmMemoryObject> WasmTrustedInstanceData::memory_object(
    int memory_index) const {
  return Cast<WasmMemoryObject>(memory_objects()->get(memory_index));
}

uint8_t* WasmTrustedInstanceData::memory_base(int memory_index) const {
  DCHECK_EQ(memory0_start(),
            reinterpret_cast<uint8_t*>(memory_bases_and_sizes()->get(0)));
  return reinterpret_cast<uint8_t*>(
      memory_bases_and_sizes()->get(2 * memory_index));
}

size_t WasmTrustedInstanceData::memory_size(int memory_index) const {
  DCHECK_EQ(memory0_size(), memory_bases_and_sizes()->get(1));
  return memory_bases_and_sizes()->get(2 * memory_index + 1);
}

Tagged<WasmDispatchTable> WasmTrustedInstanceData::dispatch_table(
    uint32_t table_index) {
  Tagged<Object> table = dispatch_tables()->get(table_index);
  DCHECK(IsWasmDispatchTable(table));
  return Cast<WasmDispatchTable>(table);
}

bool WasmTrustedInstanceData::has_dispatch_table(uint32_t table_index) {
  Tagged<Object> maybe_table = dispatch_tables()->get(table_index);
  DCHECK(maybe_table == Smi::zero() || IsWasmDispatchTable(maybe_table));
  return maybe_table != Smi::zero();
}

wasm::NativeModule* WasmTrustedInstanceData::native_module() const {
  return managed_native_module()->get().get();
}

Tagged<WasmModuleObject> WasmTrustedInstanceData::module_object() const {
  return instance_object()->module_object();
}

const wasm::WasmModule* WasmTrustedInstanceData::module() const {
  return native_module()->module();
}

// WasmInstanceObject
TRUSTED_POINTER_ACCESSORS(WasmInstanceObject, trusted_data,
                          WasmTrustedInstanceData, kTrustedDataOffset,
                          kWasmTrustedInstanceDataIndirectPointerTag)

// Note: in case of existing in-sandbox corruption, this could return an
// incorrect WasmModule! For security-relevant code, prefer reading
// {native_module()} from a {WasmTrustedInstanceData}.
const wasm::WasmModule* WasmInstanceObject::module() const {
  return module_object()->module();
}

ImportedFunctionEntry::ImportedFunctionEntry(
    Isolate* isolate, DirectHandle<WasmInstanceObject> instance_object,
    int index)
    : ImportedFunctionEntry(
          handle(instance_object->trusted_data(isolate), isolate), index) {}

ImportedFunctionEntry::ImportedFunctionEntry(
    Handle<WasmTrustedInstanceData> instance_data, int index)
    : instance_data_(instance_data), index_(index) {
  DCHECK_GE(index, 0);
  DCHECK_LT(index, instance_data->module()->num_imported_functions);
}

// WasmDispatchTable
OBJECT_CONSTRUCTORS_IMPL(WasmDispatchTable, TrustedObject)

PROTECTED_POINTER_ACCESSORS(WasmDispatchTable, protected_offheap_data,
                            TrustedManaged<WasmDispatchTableData>,
                            kProtectedOffheapDataOffset)
WasmDispatchTableData* WasmDispatchTable::offheap_data() const {
  return protected_offheap_data()->get().get();
}

void WasmDispatchTable::clear_entry_padding(int index) {
  static_assert(kEntryPaddingBytes == 0 || kEntryPaddingBytes == kIntSize);
  if constexpr (kEntryPaddingBytes != 0) {
    WriteField<int>(OffsetOf(index) + kEntryPaddingOffset, 0);
  }
}

int WasmDispatchTable::length(AcquireLoadTag) const {
  return ACQUIRE_READ_INT32_FIELD(*this, kLengthOffset);
}

int WasmDispatchTable::length() const { return ReadField<int>(kLengthOffset); }

int WasmDispatchTable::capacity() const {
  return ReadField<int>(kCapacityOffset);
}

inline Tagged<Object> WasmDispatchTable::implicit_arg(int index) const {
  DCHECK_LT(index, length());
  Tagged<Object> implicit_arg =
      ReadProtectedPointerField(OffsetOf(index) + kImplicitArgBias);
  DCHECK(IsWasmTrustedInstanceData(implicit_arg) ||
         IsWasmImportData(implicit_arg) || implicit_arg == Smi::zero());
  return implicit_arg;
}

inline WasmCodePointer WasmDispatchTable::target(int index) const {
  DCHECK_LT(index, length());
  if (v8_flags.wasm_jitless) return wasm::kInvalidWasmCodePointer;
  return ReadField<WasmCodePointer>(OffsetOf(index) + kTargetBias);
}

inline wasm::CanonicalTypeIndex WasmDispatchTable::sig(int index) const {
  DCHECK_LT(index, length());
  return wasm::CanonicalTypeIndex{
      ReadField<uint32_t>(OffsetOf(index) + kSigBias)};
}

#if V8_ENABLE_DRUMBRAKE
inline uint32_t WasmDispatchTable::function_index(int index) const {
  DCHECK_LT(index, length());
  if (!v8_flags.wasm_jitless) return UINT_MAX;
  return ReadField<uint32_t>(OffsetOf(index) + kFunctionIndexBias);
}
#endif  // V8_ENABLE_DRUMBRAKE

// WasmExceptionPackage
OBJECT_CONSTRUCTORS_IMPL(WasmExceptionPackage, JSObject)

// WasmExportedFunction
WasmExportedFunction::WasmExportedFunction(Address ptr) : JSFunction(ptr) {
  SLOW_DCHECK(IsWasmExportedFunction(*this));
}

template <>
struct CastTraits<WasmExportedFunction> {
  static inline bool AllowFrom(Tagged<Object> value) {
    return WasmExportedFunction::IsWasmExportedFunction(value);
  }
  static inline bool AllowFrom(Tagged<HeapObject> value) {
    return WasmExportedFunction::IsWasmExportedFunction(value);
  }
};

// WasmImportData

PROTECTED_POINTER_ACCESSORS(WasmImportData, instance_data,
                            WasmTrustedInstanceData,
                            kProtectedInstanceDataOffset)

// WasmInternalFunction

// {implicit_arg} will be a WasmTrustedInstanceData or a WasmImportData.
PROTECTED_POINTER_ACCESSORS(WasmInternalFunction, implicit_arg, TrustedObject,
                            kProtectedImplicitArgOffset)

// WasmFuncRef
TRUSTED_POINTER_ACCESSORS(WasmFuncRef, internal, WasmInternalFunction,
                          kTrustedInternalOffset,
                          kWasmInternalFunctionIndirectPointerTag)

// WasmFunctionData
CODE_POINTER_ACCESSORS(WasmFunctionData, wrapper_code, kWrapperCodeOffset)

PROTECTED_POINTER_ACCESSORS(WasmFunctionData, internal, WasmInternalFunction,
                            kProtectedInternalOffset)

// WasmExportedFunctionData
PROTECTED_POINTER_ACCESSORS(WasmExportedFunctionData, instance_data,
                            WasmTrustedInstanceData,
                            kProtectedInstanceDataOffset)

CODE_POINTER_ACCESSORS(WasmExportedFunctionData, c_wrapper_code,
                       kCWrapperCodeOffset)

PRIMITIVE_ACCESSORS(WasmExportedFunctionData, sig, const wasm::CanonicalSig*,
                    kSigOffset)

wasm::CanonicalTypeIndex WasmExportedFunctionData::sig_index() const {
  return wasm::CanonicalTypeIndex{
      static_cast<uint32_t>(canonical_type_index())};
}

bool WasmExportedFunctionData::is_promising() const {
  return WasmFunctionData::PromiseField::decode(js_promise_flags()) ==
         wasm::kPromise;
}

// WasmJSFunctionData
wasm::CanonicalTypeIndex WasmJSFunctionData::sig_index() const {
  return wasm::CanonicalTypeIndex{static_cast<uint32_t>(canonical_sig_index())};
}
PROTECTED_POINTER_ACCESSORS(WasmJSFunctionData, protected_offheap_data,
                            TrustedManaged<WasmJSFunctionData::OffheapData>,
                            kProtectedOffheapDataOffset)

WasmJSFunctionData::OffheapData* WasmJSFunctionData::offheap_data() const {
  return protected_offheap_data()->get().get();
}

// WasmJSFunction
WasmJSFunction::WasmJSFunction(Address ptr) : JSFunction(ptr) {
  SLOW_DCHECK(IsWasmJSFunction(*this));
}

template <>
struct CastTraits<WasmJSFunction> {
  static inline bool AllowFrom(Tagged<Object> value) {
    return WasmJSFunction::IsWasmJSFunction(value);
  }
  static inline bool AllowFrom(Tagged<HeapObject> value) {
    return WasmJSFunction::IsWasmJSFunction(value);
  }
};

// WasmCapiFunctionData
wasm::CanonicalTypeIndex WasmCapiFunctionData::sig_index() const {
  return wasm::CanonicalTypeIndex{static_cast<uint32_t>(canonical_sig_index())};
}

// WasmCapiFunction
WasmCapiFunction::WasmCapiFunction(Address ptr) : JSFunction(ptr) {
  SLOW_DCHECK(IsWasmCapiFunction(*this));
}

template <>
struct CastTraits<WasmCapiFunction> {
  static inline bool AllowFrom(Tagged<Object> value) {
    return WasmCapiFunction::IsWasmCapiFunction(value);
  }
  static inline bool AllowFrom(Tagged<HeapObject> value) {
    return WasmCapiFunction::IsWasmCapiFunction(value);
  }
};

// WasmExternalFunction
WasmExternalFunction::WasmExternalFunction(Address ptr) : JSFunction(ptr) {
  SLOW_DCHECK(IsWasmExternalFunction(*this));
}

template <>
struct CastTraits<WasmExternalFunction> {
  static inline bool AllowFrom(Tagged<Object> value) {
    return WasmExternalFunction::IsWasmExternalFunction(value);
  }
  static inline bool AllowFrom(Tagged<HeapObject> value) {
    return WasmExternalFunction::IsWasmExternalFunction(value);
  }
};

Tagged<WasmFuncRef> WasmExternalFunction::func_ref() const {
  return shared()->wasm_function_data()->func_ref();
}

// WasmTypeInfo
EXTERNAL_POINTER_ACCESSORS(WasmTypeInfo, native_type, Address,
                           kNativeTypeOffset, kWasmTypeInfoNativeTypeTag)
wasm::ModuleTypeIndex WasmTypeInfo::type_index() const {
  return wasm::ModuleTypeIndex{module_type_index()};
}
TRUSTED_POINTER_ACCESSORS(WasmTypeInfo, trusted_data, WasmTrustedInstanceData,
                          kTrustedDataOffset,
                          kWasmTrustedInstanceDataIndirectPointerTag)

#undef OPTIONAL_ACCESSORS
#undef READ_PRIMITIVE_FIELD
#undef WRITE_PRIMITIVE_FIELD
#undef PRIMITIVE_ACCESSORS

TRUSTED_POINTER_ACCESSORS(WasmTableObject, trusted_data,
                          WasmTrustedInstanceData, kTrustedDataOffset,
                          kWasmTrustedInstanceDataIndirectPointerTag)

wasm::ValueType WasmTableObject::type() {
  // Various consumers of ValueKind (e.g. ValueKind::name()) use the raw enum
  // value as index into a global array. As such, if the index is corrupted
  // (which must be assumed, as it comes from within the sandbox), this can
  // lead to out-of-bounds reads outside the sandbox. While these are not
  // technically sandbox violations, we should still try to avoid them to keep
  // fuzzers happy. This SBXCHECK accomplishes that.
  wasm::ValueType type = wasm::ValueType::FromRawBitField(raw_type());
  SBXCHECK(is_valid(type.kind()));
  return type;
}

bool WasmTableObject::is_in_bounds(uint32_t entry_index) {
  return entry_index < static_cast<uint32_t>(current_length());
}

bool WasmTableObject::is_table64() const {
  return address_type() == wasm::AddressType::kI64;
}

std::optional<uint64_t> WasmTableObject::maximum_length_u64() const {
  Tagged<Object> max = maximum_length();
  if (IsUndefined(max)) return std::nullopt;
  if (is_table64()) {
    DCHECK(IsBigInt(max));
#if DEBUG
    bool lossless;
    uint64_t value = Cast<BigInt>(maximum_length())->AsUint64(&lossless);
    DCHECK(lossless);
    return value;
#else
    return Cast<BigInt>(maximum_length())->AsUint64();
#endif
  }
  DCHECK(IsNumber(max));
  double value = Object::NumberValue(max);
  DCHECK_LE(0, value);
  DCHECK_GE(std::numeric_limits<uint64_t>::max(), value);
  return value;
}

bool WasmMemoryObject::has_maximum_pages() { return maximum_pages() >= 0; }

bool WasmMemoryObject::is_memory64() const {
  return address_type() == wasm::AddressType::kI64;
}

// static
Handle<Object> WasmObject::ReadValueAt(Isolate* isolate,
                                       DirectHandle<HeapObject> obj,
                                       wasm::ValueType type, uint32_t offset) {
  Address field_address = obj->GetFieldAddress(offset);
  switch (type.kind()) {
    case wasm::kI8: {
      int8_t value = base::Memory<int8_t>(field_address);
      return handle(Smi::FromInt(value), isolate);
    }
    case wasm::kI16: {
      int16_t value = base::Memory<int16_t>(field_address);
      return handle(Smi::FromInt(value), isolate);
    }
    case wasm::kI32: {
      int32_t value = base::Memory<int32_t>(field_address);
      return isolate->factory()->NewNumberFromInt(value);
    }
    case wasm::kI64: {
      int64_t value = base::ReadUnalignedValue<int64_t>(field_address);
      return BigInt::FromInt64(isolate, value);
    }
    case wasm::kF16: {
      uint16_t value = base::Memory<uint16_t>(field_address);
      return isolate->factory()->NewNumber(fp16_ieee_to_fp32_value(value));
    }
    case wasm::kF32: {
      float value = base::Memory<float>(field_address);
      return isolate->factory()->NewNumber(value);
    }
    case wasm::kF64: {
      double value = base::ReadUnalignedValue<double>(field_address);
      return isolate->factory()->NewNumber(value);
    }
    case wasm::kS128:
      // TODO(v8:11804): implement
      UNREACHABLE();

    case wasm::kRef:
    case wasm::kRefNull: {
      ObjectSlot slot(field_address);
      return handle(slot.load(isolate), isolate);
    }

    case wasm::kRtt:
      // Rtt values are not supposed to be made available to JavaScript side.
      UNREACHABLE();

    case wasm::kVoid:
    case wasm::kTop:
    case wasm::kBottom:
      UNREACHABLE();
  }
}

// Conversions from Numeric objects.
// static
template <typename ElementType>
ElementType WasmObject::FromNumber(Tagged<Object> value) {
  // The value must already be prepared for storing to numeric fields.
  DCHECK(IsNumber(value));
  if (IsSmi(value)) {
    return static_cast<ElementType>(Smi::ToInt(value));

  } else if (IsHeapNumber(value)) {
    double double_value = Cast<HeapNumber>(value)->value();
    if (std::is_same<ElementType, double>::value ||
        std::is_same<ElementType, float>::value) {
      return static_cast<ElementType>(double_value);
    } else {
      CHECK(std::is_integral<ElementType>::value);
      return static_cast<ElementType>(DoubleToInt32(double_value));
    }
  }
  UNREACHABLE();
}

wasm::StructType* WasmStruct::type(Tagged<Map> map) {
  Tagged<WasmTypeInfo> type_info = map->wasm_type_info();
  return reinterpret_cast<wasm::StructType*>(type_info->native_type());
}

const wasm::WasmModule* WasmStruct::module() {
  Isolate* isolate = GetIsolateFromWritableObject(*this);
  return map()->wasm_type_info()->trusted_data(isolate)->module();
}

wasm::StructType* WasmStruct::GcSafeType(Tagged<Map> map) {
  DCHECK_EQ(WASM_STRUCT_TYPE, map->instance_type());
  Tagged<HeapObject> raw = Cast<HeapObject>(map->constructor_or_back_pointer());
  // The {WasmTypeInfo} might be in the middle of being moved, which is why we
  // can't read its map for a checked cast. But we can rely on its native type
  // pointer being intact in the old location.
  Tagged<WasmTypeInfo> type_info = UncheckedCast<WasmTypeInfo>(raw);
  return reinterpret_cast<wasm::StructType*>(type_info->native_type());
}

// static
void WasmStruct::EncodeInstanceSizeInMap(int instance_size, Tagged<Map> map) {
  // WasmStructs can be bigger than the {map.instance_size_in_words} field
  // can describe; yet we have to store the instance size somewhere on the
  // map so that the GC can read it without relying on any other objects
  // still being around. To solve this problem, we store the instance size
  // in two other fields that are otherwise unused for WasmStructs.
  static_assert(0xFFFF > ((kHeaderSize + wasm::kMaxValueTypeSize *
                                             wasm::kV8MaxWasmStructFields) >>
                          kObjectAlignmentBits));
  map->SetWasmByte1((instance_size >> kObjectAlignmentBits) & 0xff);
  map->SetWasmByte2(instance_size >> (8 + kObjectAlignmentBits));
}

// static
int WasmStruct::DecodeInstanceSizeFromMap(Tagged<Map> map) {
  return (map->WasmByte2() << (8 + kObjectAlignmentBits)) |
         (map->WasmByte1() << kObjectAlignmentBits);
}

int WasmStruct::GcSafeSize(Tagged<Map> map) {
  return DecodeInstanceSizeFromMap(map);
}

wasm::StructType* WasmStruct::type() const { return type(map()); }

Address WasmStruct::RawFieldAddress(int raw_offset) {
  int offset = WasmStruct::kHeaderSize + raw_offset;
  return FIELD_ADDR(*this, offset);
}

ObjectSlot WasmStruct::RawField(int raw_offset) {
  return ObjectSlot(RawFieldAddress(raw_offset));
}

wasm::ArrayType* WasmArray::type(Tagged<Map> map) {
  DCHECK_EQ(WASM_ARRAY_TYPE, map->instance_type());
  Tagged<WasmTypeInfo> type_info = map->wasm_type_info();
  return reinterpret_cast<wasm::ArrayType*>(type_info->native_type());
}

wasm::ArrayType* WasmArray::GcSafeType(Tagged<Map> map) {
  DCHECK_EQ(WASM_ARRAY_TYPE, map->instance_type());
  Tagged<HeapObject> raw = Cast<HeapObject>(map->constructor_or_back_pointer());
  // The {WasmTypeInfo} might be in the middle of being moved, which is why we
  // can't read its map for a checked cast. But we can rely on its native type
  // pointer being intact in the old location.
  Tagged<WasmTypeInfo> type_info = UncheckedCast<WasmTypeInfo>(raw);
  return reinterpret_cast<wasm::ArrayType*>(type_info->native_type());
}

wasm::ArrayType* WasmArray::type() const { return type(map()); }

const wasm::WasmModule* WasmArray::module() {
  Isolate* isolate = GetIsolateFromWritableObject(*this);
  return map()->wasm_type_info()->trusted_data(isolate)->module();
}

int WasmArray::SizeFor(Tagged<Map> map, int length) {
  int element_size = DecodeElementSizeFromMap(map);
  return kHeaderSize + RoundUp(element_size * length, kTaggedSize);
}

uint32_t WasmArray::element_offset(uint32_t index) {
  DCHECK_LE(index, length());
  return WasmArray::kHeaderSize +
         index * type()->element_type().value_kind_size();
}

Address WasmArray::ElementAddress(uint32_t index) {
  return ptr() + element_offset(index) - kHeapObjectTag;
}

ObjectSlot WasmArray::ElementSlot(uint32_t index) {
  DCHECK_LE(index, length());
  DCHECK(type()->element_type().is_reference());
  return RawField(kHeaderSize + kTaggedSize * index);
}

// static
Handle<Object> WasmArray::GetElement(Isolate* isolate,
                                     DirectHandle<WasmArray> array,
                                     uint32_t index) {
  if (index >= array->length()) {
    return isolate->factory()->undefined_value();
  }
  wasm::ValueType element_type = array->type()->element_type();
  return ReadValueAt(isolate, array, element_type,
                     array->element_offset(index));
}

// static
void WasmArray::EncodeElementSizeInMap(int element_size, Tagged<Map> map) {
  map->SetWasmByte1(element_size);
}

// static
int WasmArray::DecodeElementSizeFromMap(Tagged<Map> map) {
  return map->WasmByte1();
}

TRUSTED_POINTER_ACCESSORS(WasmTagObject, trusted_data, WasmTrustedInstanceData,
                          kTrustedDataOffset,
                          kWasmTrustedInstanceDataIndirectPointerTag)

EXTERNAL_POINTER_ACCESSORS(WasmContinuationObject, jmpbuf, Address,
                           kJmpbufOffset, kWasmContinuationJmpbufTag)

EXTERNAL_POINTER_ACCESSORS(WasmContinuationObject, stack, Address, kStackOffset,
                           kWasmStackMemoryTag)

#include "src/objects/object-macros-undef.h"

}  // namespace v8::internal

#endif  // V8_WASM_WASM_OBJECTS_INL_H_

"""

```
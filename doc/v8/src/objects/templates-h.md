Response:
Let's break down the thought process for analyzing this C++ header file.

1. **Initial Scan for Key Information:**  First, I'd quickly scan the file for obvious clues. I see `#ifndef V8_OBJECTS_TEMPLATES_H_`, `#define V8_OBJECTS_TEMPLATES_H_`, indicating a header guard. Copyright information tells me it's part of the V8 project. Includes like `<optional>`, `<string_view>`, and `<include/v8-*.h>` give a general sense of what it deals with (likely low-level V8 structures). The presence of `"torque-generated/..."` strongly suggests Torque is involved.

2. **Filename and Torque:** The prompt itself points out that if the filename ended in `.tq`, it would be a Torque source file. Since it's `.h`, it's a C++ header, likely containing declarations for structures generated by Torque. This is confirmed by the `#include "torque-generated/src/objects/templates-tq.inc"` line. This is a crucial point for understanding the file's purpose.

3. **Core Classes:** I'd then focus on the major class declarations: `TemplateInfo`, `FunctionTemplateRareData`, `FunctionTemplateInfo`, `ObjectTemplateInfo`, and `DictionaryTemplateInfo`. The names themselves are highly suggestive of their roles in V8's templating system. "Template" strongly implies blueprints for creating objects and functions.

4. **`TemplateInfo` Deep Dive:**  I'd examine `TemplateInfo` first as it seems like the base class. The `kFastTemplateInstantiationsCacheSize` and `kSlowTemplateInstantiationsCacheSize` constants point to caching mechanisms, which makes sense for templates that are used repeatedly. `kDoNotCache` and `kUncached` further reinforce this. The `ProbeInstantiationsCache` and `CacheTemplateInstantiation` methods confirm the caching functionality.

5. **`FunctionTemplateInfo` Analysis:**  This class has a lot more going on. The comments "See the api-exposed FunctionTemplate for more information" is a huge hint. The `DECL_RARE_ACCESSORS` macros, along with names like `prototype_template`, `parent_template`, `instance_template`, and `instance_call_handler`, strongly suggest this is how V8 represents JavaScript function templates in its internal structures. The `DECL_BOOLEAN_ACCESSORS` with names like `is_object_template_call_handler`, `has_side_effects`, `undetectable`, and `needs_access_check` indicate properties controlling the behavior and characteristics of functions created from these templates. The mention of `SharedFunctionInfo` further links it to V8's internal representation of functions.

6. **Connecting to JavaScript:** At this stage, the connection to JavaScript becomes clearer. Function templates in V8 are directly related to how JavaScript functions and classes are created and how their properties are handled. I would then start thinking about JavaScript examples related to the concepts observed:

    * **`FunctionTemplateInfo` and `Function` constructor:**  A `v8::FunctionTemplate` in the API corresponds to the internal `FunctionTemplateInfo`. Creating a JS function using a template mirrors this.
    * **`prototype_template`:** This directly translates to setting the `prototype` property of a constructor function.
    * **`instance_template`:**  This is used to define the shape and properties of objects created using the `new` keyword with the constructor function.
    * **`instance_call_handler`:** This relates to intercepting calls to objects created from the template, acting like a custom function call behavior.
    * **Accessors and Interceptors:**  `named_property_handler` and `indexed_property_handler` connect to JavaScript getters, setters, and interceptors defined using `Object.defineProperty` or proxy objects.

7. **`ObjectTemplateInfo` and `DictionaryTemplateInfo`:**  These classes are simpler. `ObjectTemplateInfo` is likely used for creating plain JavaScript objects, and `DictionaryTemplateInfo` suggests a template for creating objects with a dictionary-like property storage.

8. **Torque and Code Generation:** The presence of `torque-generated` is important. It means that much of the low-level implementation details (like the layout of these classes in memory and basic accessors) are handled by the Torque compiler. This explains why there aren't explicit member variable declarations in the header.

9. **Error Scenarios:**  Based on the understanding of templates and their connection to JavaScript, I'd consider common errors related to:

    * **Incorrect template usage:**  Trying to use a template in a way that violates its intended purpose (e.g., not setting a required property).
    * **Mismatch between template and instance:**  Creating an instance that doesn't conform to the template's structure.
    * **Caching issues:** While not directly user-facing, understanding the caching mechanisms can be relevant for embedders.

10. **Refinement and Structure:** Finally, I'd organize my findings into a structured answer, covering the file's purpose, the role of Torque, connections to JavaScript with examples, potential code logic, and common errors. I'd use the class names and their associated functionalities as the main organizational points.

This iterative process of scanning, analyzing, connecting to known concepts (like JavaScript), and inferring functionality based on names and surrounding code helps build a comprehensive understanding of the header file's purpose.
这个头文件 `v8/src/objects/templates.h` 定义了 V8 引擎中用于创建和管理 **模板 (Templates)** 的数据结构。模板是 V8 的 C++ API 提供的一种机制，允许开发者在 C++ 中定义 JavaScript 对象的结构和行为。它们是连接 C++ 代码和 JavaScript 代码的重要桥梁。

**功能列表:**

1. **定义模板信息 (`TemplateInfo`)**:  `TemplateInfo` 类是所有模板信息类的基类。它包含了用于缓存模板实例化结果的信息，以提高性能。这包括快速缓存和慢速缓存，以及控制缓存行为的标志。
2. **定义函数模板信息 (`FunctionTemplateInfo`)**: `FunctionTemplateInfo` 类用于创建 JavaScript 函数的模板。它可以指定函数的原型、实例模板、属性拦截器、调用处理器等。通过 `FunctionTemplateInfo`，你可以控制由这个模板创建的函数的行为和属性。
3. **定义对象模板信息 (`ObjectTemplateInfo`)**: `ObjectTemplateInfo` 类用于创建普通 JavaScript 对象的模板。它可以指定对象的嵌入器字段数量、是否具有不可变的 `__proto__` 属性等。
4. **定义字典模板信息 (`DictionaryTemplateInfo`)**: `DictionaryTemplateInfo` 类用于创建具有字典行为的 JavaScript 对象的模板，允许通过字符串名称动态访问属性。
5. **管理模板的缓存**:  `TemplateInfo` 中定义了缓存大小和相关的缓存操作方法，例如 `ProbeInstantiationsCache` 和 `CacheTemplateInstantiation`，用于存储和检索模板的实例化结果。
6. **处理函数模板的特殊属性**: `FunctionTemplateInfo` 中定义了大量的访问器 (getter/setter)，用于管理函数模板的各种属性，例如 `prototype_template` (原型模板)，`instance_template` (实例模板)，以及属性拦截器等。
7. **支持 API 对象的创建**:  通过 `FunctionTemplateInfo`，可以创建与 C++ 代码关联的 API 对象，这些对象的方法和属性可以由 C++ 代码提供。
8. **提供元数据**: 模板信息包含了用于描述 JavaScript 对象或函数的元数据，这些元数据被 V8 引擎在执行 JavaScript 代码时使用。

**关于 `.tq` 结尾：**

如果 `v8/src/objects/templates.h` 以 `.tq` 结尾，那么它确实会是一个 **V8 Torque 源代码** 文件。Torque 是 V8 使用的一种领域特定语言 (DSL)，用于生成高效的 C++ 代码，特别是用于运行时函数的实现。在这种情况下，该文件将包含使用 Torque 语法编写的模板相关的代码逻辑。然而，当前提供的文件是 `.h` 结尾，因此它是 C++ 头文件，包含了模板相关类的声明。  `#include "torque-generated/src/objects/templates-tq.inc"` 这行代码表明，虽然这个头文件是 C++，但它包含了由 Torque 生成的代码。

**与 JavaScript 功能的关系 (使用 JavaScript 举例说明):**

模板在 V8 的 C++ API 中被用来创建和定制 JavaScript 对象和函数的行为。以下是一些与 JavaScript 功能相关的例子：

**1. 创建自定义构造函数:**

```javascript
// C++ 代码 (简化示例):
// 创建一个名为 'MyObject' 的函数模板
v8::Local<v8::FunctionTemplate> tpl = v8::FunctionTemplate::New(isolate);

// 获取该函数模板的实例模板 (用于创建通过 new 调用的对象)
v8::Local<v8::ObjectTemplate> instance_tpl = tpl->InstanceTemplate();

// 为实例模板添加属性
instance_tpl->SetInternalFieldCount(1); // 为 C++ 对象保留内部字段
instance_tpl->SetAccessor(v8::String::NewFromUtf8Literal(isolate, "myProperty"), MyPropertyGetter);

// JavaScript 代码:
function MyObject() {
  // 这里的行为由 C++ 的模板定义
}

let obj = new MyObject();
console.log(obj.myProperty); // 访问由 C++ 定义的属性
```

在这个例子中，C++ 的 `FunctionTemplateInfo` (通过 `v8::FunctionTemplate`) 描述了 JavaScript 函数 `MyObject` 的结构。`instance_template` 定义了通过 `new MyObject()` 创建的对象的属性和内部结构。

**2. 设置原型链:**

```javascript
// C++ 代码 (简化示例):
v8::Local<v8::FunctionTemplate> parent_tpl = v8::FunctionTemplate::New(isolate);
// ... 定义 parent_tpl

v8::Local<v8::FunctionTemplate> child_tpl = v8::FunctionTemplate::New(isolate);
// 设置 child_tpl 的原型来自 parent_tpl
child_tpl->SetParent(parent_tpl);

// JavaScript 代码:
function Parent() {}
function Child() {}
// Child.prototype.__proto__ === Parent.prototype (由 C++ 模板设置)

let child = new Child();
console.log(child instanceof Parent); // true
```

`FunctionTemplateInfo` 中的 `parent_template` 字段允许在 C++ 中构建 JavaScript 的原型继承链。

**3. 添加属性拦截器:**

```javascript
// C++ 代码 (简化示例):
v8::Local<v8::ObjectTemplate> tpl = v8::ObjectTemplate::New(isolate);
tpl->SetNamedPropertyHandler(MyNamedPropertyGetter);

// JavaScript 代码:
let obj = {};
// 当访问 obj 的不存在的属性时，会调用 C++ 的 MyNamedPropertyGetter
console.log(obj.someNonExistentProperty);
```

`FunctionTemplateInfo` 和 `ObjectTemplateInfo` 中的 `named_property_handler` 和 `indexed_property_handler` 允许 C++ 代码拦截 JavaScript 属性的访问和设置操作。

**代码逻辑推理 (假设输入与输出):**

考虑 `TemplateInfo` 中的缓存逻辑。

**假设输入:**

1. `isolate`: 当前的 V8 隔离环境。
2. `native_context`: 当前的原生上下文。
3. `serial_number`: 模板的序列号 (用于标识不同的模板)。
4. `caching_mode`:  `CachingMode::kLimited` 或 `CachingMode::kUnlimited`。

**情景:**  尝试从缓存中获取特定模板的实例化结果 (`ProbeInstantiationsCache`)。

**代码逻辑 (推测):**

`ProbeInstantiationsCache` 方法会根据 `caching_mode` 在不同的缓存区域（快速或慢速）查找具有匹配 `serial_number` 的实例化结果。

*   如果找到匹配的实例化结果，则返回该结果的句柄 (`MaybeHandle<ReturnType>`)。
*   如果未找到，则返回空句柄。

**假设输入 (用于缓存):**

1. `isolate`: 当前的 V8 隔离环境。
2. `native_context`: 当前的原生上下文。
3. `data`: 要缓存的 `TemplateInfo` 的句柄。
4. `caching_mode`:  `CachingMode::kLimited` 或 `CachingMode::kUnlimited`。
5. `object`: 要缓存的实例化对象的句柄。

**情景:** 将一个模板的实例化结果添加到缓存中 (`CacheTemplateInstantiation`)。

**代码逻辑 (推测):**

`CacheTemplateInstantiation` 方法会根据 `caching_mode` 将 `object` 添加到相应的缓存中，并与 `data` 的 `serial_number` 关联起来。  它可能会检查缓存是否已满，并根据缓存策略进行清理。

**输出 (对于缓存):**

*   缓存中添加了新的实例化结果。

**涉及用户常见的编程错误 (举例说明):**

1. **未正确设置 `internal_field_count`:**  当在 C++ 中创建与 JavaScript 对象关联的 C++ 对象时，需要在 `ObjectTemplateInfo` 或 `FunctionTemplateInfo` 的 `InstanceTemplate` 中使用 `SetInternalFieldCount` 预留足够的内部字段。如果在 C++ 代码中尝试访问未预留的内部字段，会导致错误或崩溃。

    ```cpp
    // C++ 代码 (错误示例):
    v8::Local<v8::ObjectTemplate> obj_tpl = v8::ObjectTemplate::New(isolate);
    // 忘记设置内部字段数量

    v8::Local<v8::Object> js_obj = obj_tpl->NewInstance(context).ToLocalChecked();
    js_obj->SetInternalField(0, v8::External::New(isolate, new MyCObject())); // 潜在的错误
    ```

2. **模板的生命周期管理不当:**  模板通常在 V8 引擎的堆上分配。如果模板的句柄丢失或被过早释放，可能会导致访问已释放内存的错误。用户需要确保模板的生命周期足够长，以支持其创建的对象的存在。

3. **在模板创建后修改模板:**  一旦模板被用于创建对象或函数，修改模板的行为是未定义的，并且可能导致不可预测的结果或崩溃。V8 可能会对已发布的模板进行优化，使其变为不可变。

4. **类型转换错误:**  在使用模板时，需要注意类型转换。例如，当从 JavaScript 回调到 C++ 时，需要正确地将 JavaScript 的 `Value` 类型转换为 C++ 中期望的类型。如果类型不匹配，会导致错误。

这些只是 `v8/src/objects/templates.h` 文件定义的功能和相关概念的冰山一角。深入理解这些结构对于编写高效且与 V8 引擎良好集成的 C++ 扩展至关重要。

### 提示词
```
这是目录为v8/src/objects/templates.h的一个v8源代码， 请列举一下它的功能, 
如果v8/src/objects/templates.h以.tq结尾，那它是个v8 torque源代码，
如果它与javascript的功能有关系，请用javascript举例说明,
如果有代码逻辑推理，请给出假设输入与输出，
如果涉及用户常见的编程错误，请举例说明
```

### 源代码
```c
// Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_OBJECTS_TEMPLATES_H_
#define V8_OBJECTS_TEMPLATES_H_

#include <optional>
#include <string_view>

#include "include/v8-exception.h"
#include "include/v8-memory-span.h"
#include "src/handles/handles.h"
#include "src/objects/contexts.h"
#include "src/objects/struct.h"
#include "torque-generated/bit-fields.h"

// Has to be the last include (doesn't have include guards):
#include "src/objects/object-macros.h"

namespace v8 {

class CFunctionInfo;
class StructBodyDescriptor;

namespace internal {

#include "torque-generated/src/objects/templates-tq.inc"

class TemplateInfo
    : public TorqueGeneratedTemplateInfo<TemplateInfo, HeapObject> {
 public:
  static const int kFastTemplateInstantiationsCacheSize = 1 * KB;

  // While we could grow the slow cache until we run out of memory, we put
  // a limit on it anyway to not crash for embedders that re-create templates
  // instead of caching them.
  static const int kSlowTemplateInstantiationsCacheSize = 1 * MB;

  // If the serial number is set to kDoNotCache, then we should never cache this
  // TemplateInfo.
  static const int kDoNotCache = -1;
  // If the serial number is set to kUncached, it means that this TemplateInfo
  // has not been cached yet but it can be.
  static const int kUncached = -2;

  inline bool should_cache() const;
  inline bool is_cached() const;

  inline bool TryGetIsolate(Isolate** isolate) const;
  inline Isolate* GetIsolateChecked() const;

  using BodyDescriptor = StructBodyDescriptor;

  // Whether or not to cache every instance: when we materialize a getter or
  // setter from an lazy AccessorPair, we rely on this cache to be able to
  // always return the same getter or setter. However, objects will be cloned
  // anyways, so it's not observable if we didn't cache an instance.
  // Furthermore, a badly behaved embedder might create an unlimited number of
  // objects, so we limit the cache for those cases.
  enum class CachingMode { kLimited, kUnlimited };

  template <typename ReturnType>
  static MaybeHandle<ReturnType> ProbeInstantiationsCache(
      Isolate* isolate, DirectHandle<NativeContext> native_context,
      int serial_number, CachingMode caching_mode);

  template <typename InstantiationType, typename TemplateInfoType>
  static void CacheTemplateInstantiation(
      Isolate* isolate, DirectHandle<NativeContext> native_context,
      DirectHandle<TemplateInfoType> data, CachingMode caching_mode,
      Handle<InstantiationType> object);

  template <typename TemplateInfoType>
  static void UncacheTemplateInstantiation(
      Isolate* isolate, DirectHandle<NativeContext> native_context,
      DirectHandle<TemplateInfoType> data, CachingMode caching_mode);

  TQ_OBJECT_CONSTRUCTORS(TemplateInfo)
};

// Contains data members that are rarely set on a FunctionTemplateInfo.
class FunctionTemplateRareData
    : public TorqueGeneratedFunctionTemplateRareData<FunctionTemplateRareData,
                                                     Struct> {
 public:
  DECL_VERIFIER(FunctionTemplateRareData)

  using BodyDescriptor = StructBodyDescriptor;

  TQ_OBJECT_CONSTRUCTORS(FunctionTemplateRareData)
};

// See the api-exposed FunctionTemplate for more information.
class FunctionTemplateInfo
    : public TorqueGeneratedFunctionTemplateInfo<FunctionTemplateInfo,
                                                 TemplateInfo> {
 public:
#define DECL_RARE_ACCESSORS(Name, CamelName, ...)                \
  DECL_GETTER(Get##CamelName, Tagged<__VA_ARGS__>)               \
  static inline void Set##CamelName(                             \
      Isolate* isolate,                                          \
      DirectHandle<FunctionTemplateInfo> function_template_info, \
      DirectHandle<__VA_ARGS__> Name);

  // ObjectTemplateInfo or Undefined, used for the prototype property of the
  // resulting JSFunction instance of this FunctionTemplate.
  DECL_RARE_ACCESSORS(prototype_template, PrototypeTemplate,
                      UnionOf<Undefined, ObjectTemplateInfo>)

  // In the case the prototype_template is Undefined we use the
  // prototype_provider_template to retrieve the instance prototype. Either
  // contains an FunctionTemplateInfo or Undefined.
  DECL_RARE_ACCESSORS(prototype_provider_template, PrototypeProviderTemplate,
                      UnionOf<Undefined, FunctionTemplateInfo>)

  // Used to create prototype chains. The parent_template's prototype is set as
  // __proto__ of this FunctionTemplate's instance prototype. Is either a
  // FunctionTemplateInfo or Undefined.
  DECL_RARE_ACCESSORS(parent_template, ParentTemplate,
                      UnionOf<Undefined, FunctionTemplateInfo>)

  // Returns an InterceptorInfo or Undefined for named properties.
  DECL_RARE_ACCESSORS(named_property_handler, NamedPropertyHandler,
                      UnionOf<Undefined, InterceptorInfo>)
  // Returns an InterceptorInfo or Undefined for indexed properties/elements.
  DECL_RARE_ACCESSORS(indexed_property_handler, IndexedPropertyHandler,
                      UnionOf<Undefined, InterceptorInfo>)

  // An ObjectTemplateInfo that is used when instantiating the JSFunction
  // associated with this FunctionTemplateInfo. Contains either an
  // ObjectTemplateInfo or Undefined. A default instance_template is assigned
  // upon first instantiation if it's Undefined.
  DECL_RARE_ACCESSORS(instance_template, InstanceTemplate,
                      UnionOf<Undefined, ObjectTemplateInfo>)

  // Either a FunctionTemplateInfo or Undefined. If an instance_call_handler is
  // provided the instances created from the associated JSFunction are marked as
  // callable.
  DECL_RARE_ACCESSORS(instance_call_handler, InstanceCallHandler,
                      UnionOf<Undefined, FunctionTemplateInfo>)

  DECL_RARE_ACCESSORS(access_check_info, AccessCheckInfo,
                      UnionOf<Undefined, AccessCheckInfo>)

  DECL_RARE_ACCESSORS(c_function_overloads, CFunctionOverloads, FixedArray)
#undef DECL_RARE_ACCESSORS

  DECL_RELAXED_UINT32_ACCESSORS(flag)

  // Begin flag bits ---------------------

  // This FunctionTemplateInfo is just a storage for callback function and
  // callback data for a callable ObjectTemplate object.
  DECL_BOOLEAN_ACCESSORS(is_object_template_call_handler)

  DECL_BOOLEAN_ACCESSORS(has_side_effects)

  DECL_BOOLEAN_ACCESSORS(undetectable)

  // If set, object instances created by this function requires access check.
  DECL_BOOLEAN_ACCESSORS(needs_access_check)

  DECL_BOOLEAN_ACCESSORS(read_only_prototype)

  // If set, do not create a prototype property for the associated
  // JSFunction. This bit implies that neither the prototype_template nor the
  // prototype_provoider_template are instantiated.
  DECL_BOOLEAN_ACCESSORS(remove_prototype)

  // If not set an access may be performed on calling the associated JSFunction.
  DECL_BOOLEAN_ACCESSORS(accept_any_receiver)

  // This flag is used to check that the FunctionTemplateInfo instance is not
  // changed after it became visible to TurboFan (either set in a
  // SharedFunctionInfo or an accessor), because TF relies on immutability to
  // safely read concurrently.
  DECL_BOOLEAN_ACCESSORS(published)

  // This specifies the permissable range of instance type of objects that can
  // be allowed to be used as receivers with the given template.
  DECL_PRIMITIVE_GETTER(allowed_receiver_instance_type_range_start,
                        InstanceType)
  DECL_PRIMITIVE_GETTER(allowed_receiver_instance_type_range_end, InstanceType)

  // End flag bits ---------------------

  inline InstanceType GetInstanceType() const;
  inline void SetInstanceType(int api_instance_type);

  inline void SetAllowedReceiverInstanceTypeRange(int api_instance_type_start,
                                                  int api_instance_type_end);

  static Handle<SharedFunctionInfo> GetOrCreateSharedFunctionInfo(
      Isolate* isolate, DirectHandle<FunctionTemplateInfo> info,
      MaybeDirectHandle<Name> maybe_name);

  static Handle<SharedFunctionInfo> GetOrCreateSharedFunctionInfo(
      LocalIsolate* isolate, DirectHandle<FunctionTemplateInfo> info,
      DirectHandle<Name> maybe_name) {
    // We don't support streaming compilation of scripts with natives, so we
    // don't need an off-thread implementation of this.
    UNREACHABLE();
  }

  // Returns parent function template or a null FunctionTemplateInfo.
  inline Tagged<FunctionTemplateInfo> GetParent(Isolate* isolate);
  // Returns true if |object| is an instance of this function template.
  inline bool IsTemplateFor(Tagged<JSObject> object) const;
  bool IsTemplateFor(Tagged<Map> map) const;
  // Returns true if |object| is an API object and is constructed by this
  // particular function template (skips walking up the chain of inheriting
  // functions that is done by IsTemplateFor).
  bool IsLeafTemplateForApiObject(Tagged<Object> object) const;
  inline bool instantiated();

  bool BreakAtEntry(Isolate* isolate);
  bool HasInstanceType();

  // Helper function for cached accessors.
  static std::optional<Tagged<Name>> TryGetCachedPropertyName(
      Isolate* isolate, Tagged<Object> getter);
  // Fast API overloads.
  int GetCFunctionsCount() const;
  Address GetCFunction(Isolate* isolate, int index) const;
  const CFunctionInfo* GetCSignature(Isolate* isolate, int index) const;

  // CFunction data for a set of overloads is stored into a FixedArray, as
  // [address_0, signature_0, ... address_n-1, signature_n-1].
  static const int kFunctionOverloadEntrySize = 2;

  // Bit position in the flag, from least significant bit position.
  DEFINE_TORQUE_GENERATED_FUNCTION_TEMPLATE_INFO_FLAGS()

  // This is a wrapper around |maybe_redirected_callback| accessor which
  // returns/accepts C function and converts the value from and to redirected
  // pointer.
  DECL_EXTERNAL_POINTER_ACCESSORS_MAYBE_READ_ONLY_HOST(callback, Address)
  inline void init_callback_redirection(i::IsolateForSandbox isolate);
  inline void remove_callback_redirection(i::IsolateForSandbox isolate);

  template <class IsolateT>
  inline bool has_callback(IsolateT* isolate) const;

  DECL_PRINTER(FunctionTemplateInfo)

  class BodyDescriptor;

 private:
  // When simulator is enabled the field stores the "redirected" address of the
  // C function (the one that's callabled from simulated compiled code), in
  // this case the original address of the C function has to be taken from the
  // redirection.
  // For native builds the field contains the address of the C function.
  // This field is initialized implicitly via respective |callback|-related
  // methods.
  DECL_EXTERNAL_POINTER_ACCESSORS_MAYBE_READ_ONLY_HOST(
      maybe_redirected_callback, Address)

  // For ease of use of the BITFIELD macro.
  inline int32_t relaxed_flag() const;
  inline void set_relaxed_flag(int32_t flags);

  // Enforce using SetInstanceType() and SetAllowedReceiverInstanceTypeRange()
  // instead of raw accessors.
  using TorqueGeneratedFunctionTemplateInfo<FunctionTemplateInfo,
                                            TemplateInfo>::set_instance_type;
  DECL_PRIMITIVE_SETTER(allowed_receiver_instance_type_range_start,
                        InstanceType)
  DECL_PRIMITIVE_SETTER(allowed_receiver_instance_type_range_end, InstanceType)

  static constexpr int kNoJSApiObjectType = 0;
  static inline Tagged<FunctionTemplateRareData> EnsureFunctionTemplateRareData(
      Isolate* isolate,
      DirectHandle<FunctionTemplateInfo> function_template_info);

  static Tagged<FunctionTemplateRareData> AllocateFunctionTemplateRareData(
      Isolate* isolate,
      DirectHandle<FunctionTemplateInfo> function_template_info);

  TQ_OBJECT_CONSTRUCTORS(FunctionTemplateInfo)
};

class ObjectTemplateInfo
    : public TorqueGeneratedObjectTemplateInfo<ObjectTemplateInfo,
                                               TemplateInfo> {
 public:
  NEVER_READ_ONLY_SPACE

  DECL_INT_ACCESSORS(embedder_field_count)
  DECL_BOOLEAN_ACCESSORS(immutable_proto)
  DECL_BOOLEAN_ACCESSORS(code_like)

  // Starting from given object template's constructor walk up the inheritance
  // chain till a function template that has an instance template is found.
  inline Tagged<ObjectTemplateInfo> GetParent(Isolate* isolate);

  using BodyDescriptor = StructBodyDescriptor;

 private:
  DEFINE_TORQUE_GENERATED_OBJECT_TEMPLATE_INFO_FLAGS()

  TQ_OBJECT_CONSTRUCTORS(ObjectTemplateInfo)
};

class DictionaryTemplateInfo
    : public TorqueGeneratedDictionaryTemplateInfo<DictionaryTemplateInfo,
                                                   HeapObject> {
 public:
  class BodyDescriptor;

  static Handle<DictionaryTemplateInfo> Create(
      Isolate* isolate, const v8::MemorySpan<const std::string_view>& names);

  static Handle<JSObject> NewInstance(
      DirectHandle<NativeContext> context,
      DirectHandle<DictionaryTemplateInfo> self,
      const MemorySpan<MaybeLocal<Value>>& property_values);

  NEVER_READ_ONLY_SPACE

  TQ_OBJECT_CONSTRUCTORS(DictionaryTemplateInfo)
};

}  // namespace internal
}  // namespace v8

#include "src/objects/object-macros-undef.h"

#endif  // V8_OBJECTS_TEMPLATES_H_
```
Response:
Let's break down the thought process for analyzing this V8 bytecode generator code.

**1. Initial Understanding and Context:**

* **Identify the core component:** The file is `bytecode-generator.cc` within the `v8/src/interpreter` directory. This immediately tells us it's responsible for translating higher-level constructs into V8's bytecode.
* **Recognize the language:** The code is C++, a standard language for V8 internals. The prompt mentions `.tq`, which is Torque, another V8 language. Since the given snippet is `.cc`, we know it's not Torque *in this specific case*.
* **Connect to JavaScript:**  The prompt explicitly asks about the relationship with JavaScript. We know that bytecode generation is a crucial step in executing JavaScript code. The generator takes the Abstract Syntax Tree (AST) of JavaScript and produces bytecode that the V8 interpreter can run.

**2. High-Level Functionality Extraction (Iterative Approach):**

* **Scanning for Keywords and Patterns:**  Look for common programming terms: `Assignment`, `Destructuring`, `Iterator`, `TryFinally`, `ObjectLiteral`, `ArrayLiteral`, `Yield`, `YieldStar`. These indicate major areas of responsibility.
* **Analyzing Key Functions:**  Focus on the function names: `BuildDestructuringArrayAssignment`, `BuildDestructuringObjectAssignment`, `BuildAssignment`, `VisitAssignment`, `VisitCompoundAssignment`, `BuildSuspendPoint`, `VisitYield`, `VisitYieldStar`. These names are highly descriptive.
* **Inferring Actions from Function Names:**
    * `BuildDestructuring...Assignment`: Handles destructuring syntax in assignments.
    * `BuildAssignment`:  The core logic for different types of assignments.
    * `Visit...`:  Likely part of a visitor pattern, processing different AST node types.
    * `BuildSuspendPoint`:  Related to generator functions and pausing/resuming execution.
    * `VisitYield`, `VisitYieldStar`: Handling `yield` and `yield*` expressions in generators.

**3. Deeper Dive into Specific Functionality (Example: Destructuring):**

* **`BuildDestructuringArrayAssignment`:**  The code clearly simulates the behavior of array destructuring using iterators. The comments within the code are *extremely* helpful here, showing the transformation from the JavaScript syntax to a series of iterator operations, including `GetIterator`, `next()`, and handling `done`.
* **`BuildDestructuringObjectAssignment`:** Similar to array destructuring but deals with object properties. The use of `CopyDataPropertiesWithExcludedPropertiesOnStack` for rest properties (`...`) is a key detail.

**4. Identifying JavaScript Relationships and Examples:**

* **Destructuring:**  The prompt explicitly asks for JavaScript examples. The destructuring functions directly map to JavaScript destructuring syntax for arrays and objects. Providing simple examples is crucial.
* **Generators and `yield`:**  The `BuildSuspendPoint`, `VisitYield`, and `VisitYieldStar` functions clearly relate to JavaScript generator functions. Explaining how `yield` pauses execution and the role of `yield*` for delegating to other iterables is important.

**5. Code Logic and Inference (Example: Assignment):**

* **`BuildAssignment`:**  This function has a `switch` statement based on `lhs_data.assign_type()`. This indicates that different bytecode sequences are generated depending on *what* is being assigned to (variable, property, etc.).
* **Inferring Input/Output:** While the code doesn't take explicit user input, we can infer the "input" is the AST node being processed (e.g., an `Assignment` node) and the "output" is the generated bytecode. The registers used are temporary storage during this process.

**6. Common Programming Errors:**

* **Destructuring `null` or `undefined`:** The code has explicit checks for this in `BuildDestructuringObjectAssignment`. This is a common runtime error in JavaScript.
* **Private property access:** The code handles different cases of private property access (method, getter, setter), including errors for invalid access. This highlights a potential source of errors for developers using private class members.

**7. Putting it All Together (Summarization and Structure):**

* **Start with the main purpose:**  Bytecode generation.
* **Group related functionalities:** Destructuring, assignments, generators are major themes.
* **Use clear and concise language:** Avoid overly technical jargon where possible.
* **Provide JavaScript examples for clarity.**
* **Highlight potential programming errors.**
* **Acknowledge the "Part 7 of 11" context:**  This reminds us that this file is part of a larger system.

**Self-Correction/Refinement During the Process:**

* **Initial thought:** "This is just about converting AST to bytecode."  **Refinement:** Recognize the specific complexities of destructuring, generators, and different assignment types.
* **Initial focus:**  Too much on individual lines of code. **Refinement:**  Focus on the higher-level function responsibilities and how they relate to JavaScript concepts.
* **Unclear examples:** Initial JavaScript examples might be too complex. **Refinement:** Use simple, illustrative examples.
* **Missing error context:**  Initially might focus only on the "happy path." **Refinement:**  Consider what errors the code is designed to handle or prevent.

By following this thought process, breaking down the code into manageable chunks, and constantly relating it back to JavaScript concepts, we can arrive at a comprehensive understanding of the `bytecode-generator.cc` file's functionality.
好的，让我们来分析一下 `v8/src/interpreter/bytecode-generator.cc` 这个文件的功能。

**功能概括:**

`v8/src/interpreter/bytecode-generator.cc` 文件是 V8 JavaScript 引擎中解释器组件的关键部分，其主要功能是将 JavaScript 代码的抽象语法树 (AST) 表示形式转换成解释器可以执行的字节码。  它负责将各种 JavaScript 语法结构（如变量声明、赋值、表达式、控制流、函数、类等）翻译成一系列底层的字节码指令。

**具体功能分解:**

1. **处理赋值语句 (Assignment):**
   - 该文件包含了处理各种赋值操作的逻辑，包括简单的赋值、对象和数组的解构赋值。
   - 它会根据赋值的目标（变量、属性、数组元素等）生成不同的字节码指令。
   - 对于解构赋值，它会生成更复杂的字节码序列，涉及到迭代器操作、属性访问等。

2. **处理复合赋值语句 (CompoundAssignment):**
   - 针对像 `+=`, `-=`, `*=`, `||=`, `&&=` 这样的复合赋值运算符，它会先加载左侧的值，执行相应的二元运算，然后再将结果赋值回去。

3. **处理对象和数组的解构赋值 (Destructuring Assignment):**
   - 这是该文件的一个重要功能。它将复杂的解构赋值语法转化为一系列更基本的操作。
   - **数组解构:**  会使用迭代器来遍历被赋值的数组，并将值赋给相应的变量。需要处理默认值和剩余元素 (spread)。
   - **对象解构:**  会根据属性名或计算属性名来访问被赋值对象的属性，并将值赋给相应的变量。也需要处理默认值和剩余属性 (rest)。

4. **处理生成器函数 (Generator Functions):**
   - 包含生成器函数中 `yield` 和 `yield*` 表达式的编译逻辑。
   - `BuildSuspendPoint`:  生成暂停生成器执行的字节码，并保存当前状态。
   - `VisitYield`:  处理 `yield` 表达式，生成将值传递给调用者并暂停执行的字节码。
   - `VisitYieldStar`: 处理 `yield*` 表达式，用于将控制权委托给另一个可迭代对象。

5. **与运行时 (Runtime) 函数交互:**
   - 在很多情况下，字节码生成器会调用 V8 的运行时函数来执行一些复杂的操作，例如获取迭代器 (`%GetIterator`)、填充数组 (`%FillArrayWithIterator`)、拷贝对象属性 (`%CopyDataPropertiesWithExcludedPropertiesOnStack`)、处理 `super` 关键字等。

6. **管理寄存器 (Register Allocation):**
   - 该文件使用 `RegisterAllocator` 来管理用于存储中间值的寄存器。

7. **生成反馈槽 (Feedback Slots):**
   - 为了支持 V8 的优化编译，字节码生成器会生成反馈槽，用于收集运行时的类型信息，以便后续的优化编译器可以生成更高效的代码。

**关于 .tq 后缀:**

如果 `v8/src/interpreter/bytecode-generator.cc` 文件以 `.tq` 结尾，那么它将是一个 **V8 Torque 源代码**文件。 Torque 是 V8 开发的一种领域特定语言，用于更安全、更高效地编写 V8 的内部代码，特别是类型化的运行时函数和内置函数。  但根据你提供的文件名，它目前是 `.cc`，所以是 C++ 源代码。

**与 JavaScript 功能的关系及 JavaScript 示例:**

`v8/src/interpreter/bytecode-generator.cc` 的核心作用就是将 JavaScript 代码转化为可以执行的指令。以下是一些与代码片段相关的 JavaScript 功能示例：

**1. 数组解构赋值:**

```javascript
const arr = [1, 2, 3];
const [a, ...rest] = arr;
console.log(a); // 输出 1
console.log(rest); // 输出 [2, 3]

const [b, , c = 5] = [10, 20];
console.log(b); // 输出 10
console.log(c); // 输出 5

let done = false;
const iterator = arr[Symbol.iterator]();
try {
  // 模拟 bytecode-generator 生成的部分逻辑
  if (!done) {
    done = true;
    const next_result = iterator.next();
    const tmp_done = next_result.done;
    let value;
    if (!tmp_done) {
      value = next_result.value;
      done = false;
    }
    if (done) {
      value = undefined;
    }
    a = value; // 对应  a().x = value 这样的赋值
  }
  // ... 处理剩余元素
} finally {
  // ... 关闭迭代器
}
```

**2. 对象解构赋值:**

```javascript
const obj = { x: 10, y: 20, z: 30 };
const { x, ...others } = obj;
console.log(x); // 输出 10
console.log(others); // 输出 { y: 20, z: 30 }

let val;
const { p: val } = { p: 42 }; // 将 obj.p 的值赋给 val
console.log(val); // 输出 42
```

**3. 带有默认值的解构赋值:**

```javascript
function foo({ a, b = 2 }) {
  console.log(a, b);
}
foo({ a: 1 }); // 输出 1 2
```

**4. 生成器函数和 `yield`:**

```javascript
function* myGenerator() {
  console.log("First");
  yield 1;
  console.log("Second");
  yield 2;
  console.log("Third");
}

const generator = myGenerator();
console.log(generator.next()); // 输出 { value: 1, done: false }
console.log(generator.next()); // 输出 { value: 2, done: false }
console.log(generator.next()); // 输出 { value: undefined, done: true }
```

**5. `yield*` 委托:**

```javascript
function* anotherGenerator() {
  yield 10;
  yield 20;
}

function* mainGenerator() {
  yield 1;
  yield* anotherGenerator();
  yield 3;
}

const main = mainGenerator();
console.log(main.next()); // { value: 1, done: false }
console.log(main.next()); // { value: 10, done: false }
console.log(main.next()); // { value: 20, done: false }
console.log(main.next()); // { value: 3, done: false }
console.log(main.next()); // { value: undefined, done: true }
```

**代码逻辑推理 (假设输入与输出):**

假设有如下 JavaScript 代码片段：

```javascript
let x = 5;
const arr = [1, 2];
let y;
[y, x] = arr;
```

**假设输入 (AST 节点):**

- 一个 `VariableDeclaration` 节点，声明 `x` 并初始化为 `5`。
- 一个 `VariableDeclaration` 节点，声明常量 `arr` 并初始化为 `[1, 2]`。
- 一个 `VariableDeclaration` 节点，声明 `y`。
- 一个 `AssignmentExpression` 节点，左侧是 `ArrayPattern` (解构目标 `[y, x]`)，右侧是 `Identifier` (被赋值的变量 `arr`)。

**可能的输出 (部分字节码序列，简化表示):**

```
// 声明并初始化 x
LdaSmi 5
StaContextSlot [context slot for x]

// 声明并初始化 arr
CreateArrayLiteral [feedback slot]
StaContextSlot [context slot for arr]

// 声明 y
LdaUndefined
StaContextSlot [context slot for y]

// 解构赋值 [y, x] = arr
LdaContextSlot [context slot for arr]  // 加载 arr 到累加器
GetIterator  // 调用 %GetIterator(arr)
// ... (迭代器操作)
IteratorNext
StoreContextSlot [context slot for y] // 将第一个值赋给 y
IteratorNext
StoreContextSlot [context slot for x] // 将第二个值赋给 x
```

**用户常见的编程错误:**

1. **解构赋值时，尝试解构 `null` 或 `undefined`:**

   ```javascript
   let obj = null;
   const { a } = obj; // TypeError: Cannot destructure property 'a' of 'null' as it is null.
   ```
   `bytecode-generator.cc` 中可以看到有针对 `null` 或 `undefined` 值的检查，并会调用运行时函数抛出 `TypeError`。

2. **解构赋值时，目标对象或数组不符合预期结构:**

   ```javascript
   const obj = { a: 1 };
   const { a, b } = obj;
   console.log(b); // 输出 undefined，可能不是预期结果

   const arr = [1];
   const [x, y] = arr;
   console.log(y); // 输出 undefined，可能导致后续错误
   ```
   字节码生成器会按照解构模式生成相应的加载指令，如果值不存在，则会得到 `undefined`。

3. **在只读属性上进行赋值 (包括解构赋值):**

   ```javascript
   const obj = {};
   Object.defineProperty(obj, 'prop', { value: 10, writable: false });
   obj.prop = 20; // TypeError: Cannot assign to read only property 'prop' of object '#<Object>'

   const arr = [1];
   Object.freeze(arr);
   arr[0] = 2; // TypeError: Cannot assign to read only property '0' of object '[object Array]'
   ```
   对于这种情况，字节码生成器会生成属性设置指令，但运行时的属性设置操作会检查属性的 `writable` 属性并抛出错误。对于 `private` 方法的赋值，也会有相应的检查。

**功能归纳 (作为第 7 部分/共 11 部分):**

作为 V8 解释器字节码生成过程的一部分，`v8/src/interpreter/bytecode-generator.cc` 的第 7 部分主要负责以下方面：

- **处理更复杂的赋值场景:**  重点在于数组和对象的解构赋值，以及涉及迭代器的操作。
- **生成器函数的关键逻辑:**  处理 `yield` 和 `yield*` 表达式，这是生成器函数的核心特性。
- **与运行时交互:**  依赖 V8 运行时提供的功能来完成一些高级操作。

结合上下文，可以推断出之前的章节可能涵盖了更基础的表达式和语句的字节码生成，而后续的章节可能会涉及函数调用、类、模块、错误处理等更高级的 JavaScript 特性。  该部分专注于处理那些需要更精细控制执行流程和数据结构的语法结构。

希望以上分析能够帮助你理解 `v8/src/interpreter/bytecode-generator.cc` 的功能。

Prompt: 
```
这是目录为v8/src/interpreter/bytecode-generator.cc的一个v8源代码， 请列举一下它的功能, 
如果v8/src/interpreter/bytecode-generator.cc以.tq结尾，那它是个v8 torque源代码，
如果它与javascript的功能有关系，请用javascript举例说明,
如果有代码逻辑推理，请给出假设输入与输出，
如果涉及用户常见的编程错误，请举例说明
这是第7部分，共11部分，请归纳一下它的功能

"""

    Assignment* default_init = (*target)->AsAssignment();
    DCHECK_EQ(default_init->op(), Token::kAssign);
    default_value = default_init->value();
    *target = default_init->target();
    DCHECK((*target)->IsValidReferenceExpression() || (*target)->IsPattern());
  }
  return default_value;
}

// Convert a destructuring assignment to an array literal into a sequence of
// iterator accesses into the value being assigned (in the accumulator).
//
// [a().x, ...b] = accumulator
//
//   becomes
//
// iterator = %GetIterator(accumulator)
// try {
//
//   // Individual assignments read off the value from iterator.next() This gets
//   // repeated per destructuring element.
//   if (!done) {
//     // Make sure we are considered 'done' if .next(), .done or .value fail.
//     done = true
//     var next_result = iterator.next()
//     var tmp_done = next_result.done
//     if (!tmp_done) {
//       value = next_result.value
//       done = false
//     }
//   }
//   if (done)
//     value = undefined
//   a().x = value
//
//   // A spread receives the remaining items in the iterator.
//   var array = []
//   var index = 0
//   %FillArrayWithIterator(iterator, array, index, done)
//   done = true
//   b = array
//
// } catch(e) {
//   iteration_continuation = RETHROW
// } finally {
//   %FinalizeIteration(iterator, done, iteration_continuation)
// }
void BytecodeGenerator::BuildDestructuringArrayAssignment(
    ArrayLiteral* pattern, Token::Value op,
    LookupHoistingMode lookup_hoisting_mode) {
  RegisterAllocationScope scope(this);

  Register value = register_allocator()->NewRegister();
  builder()->StoreAccumulatorInRegister(value);

  // Store the iterator in a dedicated register so that it can be closed on
  // exit, and the 'done' value in a dedicated register so that it can be
  // changed and accessed independently of the iteration result.
  IteratorRecord iterator = BuildGetIteratorRecord(IteratorType::kNormal);
  Register done = register_allocator()->NewRegister();
  builder()->LoadFalse();
  builder()->StoreAccumulatorInRegister(done);

  BuildTryFinally(
      // Try block.
      [&]() {
        Register next_result = register_allocator()->NewRegister();
        FeedbackSlot next_value_load_slot = feedback_spec()->AddLoadICSlot();
        FeedbackSlot next_done_load_slot = feedback_spec()->AddLoadICSlot();

        Spread* spread = nullptr;
        for (Expression* target : *pattern->values()) {
          if (target->IsSpread()) {
            spread = target->AsSpread();
            break;
          }

          Expression* default_value = GetDestructuringDefaultValue(&target);
          builder()->SetExpressionPosition(target);

          AssignmentLhsData lhs_data = PrepareAssignmentLhs(target);

          // if (!done) {
          //   // Make sure we are considered done if .next(), .done or .value
          //   // fail.
          //   done = true
          //   var next_result = iterator.next()
          //   var tmp_done = next_result.done
          //   if (!tmp_done) {
          //     value = next_result.value
          //     done = false
          //   }
          // }
          // if (done)
          //   value = undefined
          BytecodeLabels is_done(zone());

          builder()->LoadAccumulatorWithRegister(done);
          builder()->JumpIfTrue(ToBooleanMode::kConvertToBoolean,
                                is_done.New());

          builder()->LoadTrue().StoreAccumulatorInRegister(done);
          BuildIteratorNext(iterator, next_result);
          builder()
              ->LoadNamedProperty(next_result,
                                  ast_string_constants()->done_string(),
                                  feedback_index(next_done_load_slot))
              .JumpIfTrue(ToBooleanMode::kConvertToBoolean, is_done.New());

          // Only do the assignment if this is not a hole (i.e. 'elided').
          if (!target->IsTheHoleLiteral()) {
            builder()
                ->LoadNamedProperty(next_result,
                                    ast_string_constants()->value_string(),
                                    feedback_index(next_value_load_slot))
                .StoreAccumulatorInRegister(next_result)
                .LoadFalse()
                .StoreAccumulatorInRegister(done)
                .LoadAccumulatorWithRegister(next_result);

            // [<pattern> = <init>] = <value>
            //   becomes (roughly)
            // temp = <value>.next();
            // <pattern> = temp === undefined ? <init> : temp;
            BytecodeLabel do_assignment;
            if (default_value) {
              builder()->JumpIfNotUndefined(&do_assignment);
              // Since done == true => temp == undefined, jump directly to using
              // the default value for that case.
              is_done.Bind(builder());
              VisitInHoleCheckElisionScopeForAccumulatorValue(default_value);
            } else {
              builder()->Jump(&do_assignment);
              is_done.Bind(builder());
              builder()->LoadUndefined();
            }
            builder()->Bind(&do_assignment);

            BuildAssignment(lhs_data, op, lookup_hoisting_mode);
          } else {
            builder()->LoadFalse().StoreAccumulatorInRegister(done);
            DCHECK_EQ(lhs_data.assign_type(), NON_PROPERTY);
            is_done.Bind(builder());
          }
        }

        if (spread) {
          RegisterAllocationScope scope(this);
          BytecodeLabel is_done;

          // A spread is turned into a loop over the remainer of the iterator.
          Expression* target = spread->expression();
          builder()->SetExpressionPosition(spread);

          AssignmentLhsData lhs_data = PrepareAssignmentLhs(target);

          // var array = [];
          Register array = register_allocator()->NewRegister();
          builder()->CreateEmptyArrayLiteral(
              feedback_index(feedback_spec()->AddLiteralSlot()));
          builder()->StoreAccumulatorInRegister(array);

          // If done, jump to assigning empty array
          builder()->LoadAccumulatorWithRegister(done);
          builder()->JumpIfTrue(ToBooleanMode::kConvertToBoolean, &is_done);

          // var index = 0;
          Register index = register_allocator()->NewRegister();
          builder()->LoadLiteral(Smi::zero());
          builder()->StoreAccumulatorInRegister(index);

          // Set done to true, since it's guaranteed to be true by the time the
          // array fill completes.
          builder()->LoadTrue().StoreAccumulatorInRegister(done);

          // Fill the array with the iterator.
          FeedbackSlot element_slot =
              feedback_spec()->AddStoreInArrayLiteralICSlot();
          FeedbackSlot index_slot = feedback_spec()->AddBinaryOpICSlot();
          BuildFillArrayWithIterator(iterator, array, index, next_result,
                                     next_value_load_slot, next_done_load_slot,
                                     index_slot, element_slot);

          builder()->Bind(&is_done);
          // Assign the array to the LHS.
          builder()->LoadAccumulatorWithRegister(array);
          BuildAssignment(lhs_data, op, lookup_hoisting_mode);
        }
      },
      // Finally block.
      [&](Register iteration_continuation_token,
          Register iteration_continuation_result) {
        // Finish the iteration in the finally block.
        BuildFinalizeIteration(iterator, done, iteration_continuation_token);
      },
      HandlerTable::UNCAUGHT);

  if (!execution_result()->IsEffect()) {
    builder()->LoadAccumulatorWithRegister(value);
  }
}

// Convert a destructuring assignment to an object literal into a sequence of
// property accesses into the value being assigned (in the accumulator).
//
// { y, [x++]: a(), ...b.c } = value
//
//   becomes
//
// var rest_runtime_callargs = new Array(3);
// rest_runtime_callargs[0] = value;
//
// rest_runtime_callargs[1] = "y";
// y = value.y;
//
// var temp1 = %ToName(x++);
// rest_runtime_callargs[2] = temp1;
// a() = value[temp1];
//
// b.c =
// %CopyDataPropertiesWithExcludedPropertiesOnStack.call(rest_runtime_callargs);
void BytecodeGenerator::BuildDestructuringObjectAssignment(
    ObjectLiteral* pattern, Token::Value op,
    LookupHoistingMode lookup_hoisting_mode) {
  RegisterAllocationScope register_scope(this);

  // Store the assignment value in a register.
  Register value;
  RegisterList rest_runtime_callargs;
  if (pattern->builder()->has_rest_property()) {
    rest_runtime_callargs =
        register_allocator()->NewRegisterList(pattern->properties()->length());
    value = rest_runtime_callargs[0];
  } else {
    value = register_allocator()->NewRegister();
  }
  builder()->StoreAccumulatorInRegister(value);

  // if (value === null || value === undefined)
  //   throw new TypeError(kNonCoercible);
  //
  // Since the first property access on null/undefined will also trigger a
  // TypeError, we can elide this check. The exception is when there are no
  // properties and no rest property (this is an empty literal), or when the
  // first property is a computed name and accessing it can have side effects.
  //
  // TODO(leszeks): Also eliminate this check if the value is known to be
  // non-null (e.g. an object literal).
  if (pattern->properties()->is_empty() ||
      (pattern->properties()->at(0)->is_computed_name() &&
       pattern->properties()->at(0)->kind() != ObjectLiteralProperty::SPREAD)) {
    BytecodeLabel is_null_or_undefined, not_null_or_undefined;
    builder()
        ->JumpIfUndefinedOrNull(&is_null_or_undefined)
        .Jump(&not_null_or_undefined);

    {
      builder()->Bind(&is_null_or_undefined);
      builder()->SetExpressionPosition(pattern);
      builder()->CallRuntime(Runtime::kThrowPatternAssignmentNonCoercible,
                             value);
    }
    builder()->Bind(&not_null_or_undefined);
  }

  int i = 0;
  for (ObjectLiteralProperty* pattern_property : *pattern->properties()) {
    RegisterAllocationScope inner_register_scope(this);

    // The key of the pattern becomes the key into the RHS value, and the value
    // of the pattern becomes the target of the assignment.
    //
    // e.g. { a: b } = o becomes b = o.a
    Expression* pattern_key = pattern_property->key();
    Expression* target = pattern_property->value();
    Expression* default_value = GetDestructuringDefaultValue(&target);
    builder()->SetExpressionPosition(target);

    // Calculate this property's key into the assignment RHS value, additionally
    // storing the key for rest_runtime_callargs if needed.
    //
    // The RHS is accessed using the key either by LoadNamedProperty (if
    // value_name is valid) or by LoadKeyedProperty (otherwise).
    const AstRawString* value_name = nullptr;
    Register value_key;

    if (pattern_property->kind() != ObjectLiteralProperty::Kind::SPREAD) {
      if (pattern_key->IsPropertyName()) {
        value_name = pattern_key->AsLiteral()->AsRawPropertyName();
      }
      if (pattern->builder()->has_rest_property() || !value_name) {
        if (pattern->builder()->has_rest_property()) {
          value_key = rest_runtime_callargs[i + 1];
        } else {
          value_key = register_allocator()->NewRegister();
        }
        if (pattern_property->is_computed_name()) {
          // { [a()]: b().x } = c
          // becomes
          // var tmp = a()
          // b().x = c[tmp]
          DCHECK(!pattern_key->IsPropertyName() ||
                 !pattern_key->IsNumberLiteral());
          VisitForAccumulatorValue(pattern_key);
          builder()->ToName().StoreAccumulatorInRegister(value_key);
        } else {
          // We only need the key for non-computed properties when it is numeric
          // or is being saved for the rest_runtime_callargs.
          DCHECK(pattern_key->IsNumberLiteral() ||
                 (pattern->builder()->has_rest_property() &&
                  pattern_key->IsPropertyName()));
          VisitForRegisterValue(pattern_key, value_key);
        }
      }
    }

    AssignmentLhsData lhs_data = PrepareAssignmentLhs(target);

    // Get the value from the RHS.
    if (pattern_property->kind() == ObjectLiteralProperty::Kind::SPREAD) {
      DCHECK_EQ(i, pattern->properties()->length() - 1);
      DCHECK(!value_key.is_valid());
      DCHECK_NULL(value_name);
      builder()->CallRuntime(
          Runtime::kInlineCopyDataPropertiesWithExcludedPropertiesOnStack,
          rest_runtime_callargs);
    } else if (value_name) {
      builder()->LoadNamedProperty(
          value, value_name, feedback_index(feedback_spec()->AddLoadICSlot()));
    } else {
      DCHECK(value_key.is_valid());
      builder()->LoadAccumulatorWithRegister(value_key).LoadKeyedProperty(
          value, feedback_index(feedback_spec()->AddKeyedLoadICSlot()));
    }

    // {<pattern> = <init>} = <value>
    //   becomes
    // temp = <value>;
    // <pattern> = temp === undefined ? <init> : temp;
    if (default_value) {
      BytecodeLabel value_not_undefined;
      builder()->JumpIfNotUndefined(&value_not_undefined);
      VisitInHoleCheckElisionScopeForAccumulatorValue(default_value);
      builder()->Bind(&value_not_undefined);
    }

    BuildAssignment(lhs_data, op, lookup_hoisting_mode);

    i++;
  }

  if (!execution_result()->IsEffect()) {
    builder()->LoadAccumulatorWithRegister(value);
  }
}

void BytecodeGenerator::BuildAssignment(
    const AssignmentLhsData& lhs_data, Token::Value op,
    LookupHoistingMode lookup_hoisting_mode) {
  // Assign the value to the LHS.
  switch (lhs_data.assign_type()) {
    case NON_PROPERTY: {
      if (ObjectLiteral* pattern_as_object =
              lhs_data.expr()->AsObjectLiteral()) {
        // Split object literals into destructuring.
        BuildDestructuringObjectAssignment(pattern_as_object, op,
                                           lookup_hoisting_mode);
      } else if (ArrayLiteral* pattern_as_array =
                     lhs_data.expr()->AsArrayLiteral()) {
        // Split object literals into destructuring.
        BuildDestructuringArrayAssignment(pattern_as_array, op,
                                          lookup_hoisting_mode);
      } else {
        DCHECK(lhs_data.expr()->IsVariableProxy());
        VariableProxy* proxy = lhs_data.expr()->AsVariableProxy();
        BuildVariableAssignment(proxy->var(), op, proxy->hole_check_mode(),
                                lookup_hoisting_mode);
      }
      break;
    }
    case NAMED_PROPERTY: {
      BuildSetNamedProperty(lhs_data.object_expr(), lhs_data.object(),
                            lhs_data.name());
      break;
    }
    case KEYED_PROPERTY: {
      FeedbackSlot slot = feedback_spec()->AddKeyedStoreICSlot(language_mode());
      Register value;
      if (!execution_result()->IsEffect()) {
        value = register_allocator()->NewRegister();
        builder()->StoreAccumulatorInRegister(value);
      }
      builder()->SetKeyedProperty(lhs_data.object(), lhs_data.key(),
                                  feedback_index(slot), language_mode());
      if (!execution_result()->IsEffect()) {
        builder()->LoadAccumulatorWithRegister(value);
      }
      break;
    }
    case NAMED_SUPER_PROPERTY: {
      builder()
          ->StoreAccumulatorInRegister(lhs_data.super_property_args()[3])
          .CallRuntime(Runtime::kStoreToSuper, lhs_data.super_property_args());
      break;
    }
    case KEYED_SUPER_PROPERTY: {
      builder()
          ->StoreAccumulatorInRegister(lhs_data.super_property_args()[3])
          .CallRuntime(Runtime::kStoreKeyedToSuper,
                       lhs_data.super_property_args());
      break;
    }
    case PRIVATE_METHOD: {
      Property* property = lhs_data.expr()->AsProperty();
      BuildPrivateBrandCheck(property, lhs_data.object());
      BuildInvalidPropertyAccess(MessageTemplate::kInvalidPrivateMethodWrite,
                                 lhs_data.expr()->AsProperty());
      break;
    }
    case PRIVATE_GETTER_ONLY: {
      Property* property = lhs_data.expr()->AsProperty();
      BuildPrivateBrandCheck(property, lhs_data.object());
      BuildInvalidPropertyAccess(MessageTemplate::kInvalidPrivateSetterAccess,
                                 lhs_data.expr()->AsProperty());
      break;
    }
    case PRIVATE_SETTER_ONLY:
    case PRIVATE_GETTER_AND_SETTER: {
      Register value = register_allocator()->NewRegister();
      builder()->StoreAccumulatorInRegister(value);
      Property* property = lhs_data.expr()->AsProperty();
      BuildPrivateBrandCheck(property, lhs_data.object());
      BuildPrivateSetterAccess(lhs_data.object(), lhs_data.key(), value);
      if (!execution_result()->IsEffect()) {
        builder()->LoadAccumulatorWithRegister(value);
      }
      break;
    }
    case PRIVATE_DEBUG_DYNAMIC: {
      Register value = register_allocator()->NewRegister();
      builder()->StoreAccumulatorInRegister(value);
      Property* property = lhs_data.expr()->AsProperty();
      BuildPrivateDebugDynamicSet(property, lhs_data.object(), value);
      if (!execution_result()->IsEffect()) {
        builder()->LoadAccumulatorWithRegister(value);
      }
      break;
    }
  }
}

void BytecodeGenerator::VisitAssignment(Assignment* expr) {
  AssignmentLhsData lhs_data = PrepareAssignmentLhs(expr->target());

  VisitForAccumulatorValue(expr->value());

  builder()->SetExpressionPosition(expr);
  BuildAssignment(lhs_data, expr->op(), expr->lookup_hoisting_mode());
}

void BytecodeGenerator::VisitCompoundAssignment(CompoundAssignment* expr) {
  AssignmentLhsData lhs_data = PrepareAssignmentLhs(expr->target());

  // Evaluate the value and potentially handle compound assignments by loading
  // the left-hand side value and performing a binary operation.
  switch (lhs_data.assign_type()) {
    case NON_PROPERTY: {
      VariableProxy* proxy = expr->target()->AsVariableProxy();
      BuildVariableLoad(proxy->var(), proxy->hole_check_mode());
      break;
    }
    case NAMED_PROPERTY: {
      BuildLoadNamedProperty(lhs_data.object_expr(), lhs_data.object(),
                             lhs_data.name());
      break;
    }
    case KEYED_PROPERTY: {
      FeedbackSlot slot = feedback_spec()->AddKeyedLoadICSlot();
      builder()->LoadAccumulatorWithRegister(lhs_data.key());
      BuildLoadKeyedProperty(lhs_data.object(), slot);
      break;
    }
    case NAMED_SUPER_PROPERTY: {
      builder()->CallRuntime(Runtime::kLoadFromSuper,
                             lhs_data.super_property_args().Truncate(3));
      break;
    }
    case KEYED_SUPER_PROPERTY: {
      builder()->CallRuntime(Runtime::kLoadKeyedFromSuper,
                             lhs_data.super_property_args().Truncate(3));
      break;
    }
    // BuildAssignment() will throw an error about the private method being
    // read-only.
    case PRIVATE_METHOD: {
      Property* property = lhs_data.expr()->AsProperty();
      BuildPrivateBrandCheck(property, lhs_data.object());
      builder()->LoadAccumulatorWithRegister(lhs_data.key());
      break;
    }
    // For read-only properties, BuildAssignment() will throw an error about
    // the missing setter.
    case PRIVATE_GETTER_ONLY:
    case PRIVATE_GETTER_AND_SETTER: {
      Property* property = lhs_data.expr()->AsProperty();
      BuildPrivateBrandCheck(property, lhs_data.object());
      BuildPrivateGetterAccess(lhs_data.object(), lhs_data.key());
      break;
    }
    case PRIVATE_SETTER_ONLY: {
      // The property access is invalid, but if the brand check fails too, we
      // need to return the error from the brand check.
      Property* property = lhs_data.expr()->AsProperty();
      BuildPrivateBrandCheck(property, lhs_data.object());
      BuildInvalidPropertyAccess(MessageTemplate::kInvalidPrivateGetterAccess,
                                 lhs_data.expr()->AsProperty());
      break;
    }
    case PRIVATE_DEBUG_DYNAMIC: {
      Property* property = lhs_data.expr()->AsProperty();
      BuildPrivateDebugDynamicGet(property, lhs_data.object());
      break;
    }
  }

  BinaryOperation* binop = expr->binary_operation();
  FeedbackSlot slot = feedback_spec()->AddBinaryOpICSlot();
  BytecodeLabel short_circuit;
  if (binop->op() == Token::kNullish) {
    BytecodeLabel nullish;
    builder()
        ->JumpIfUndefinedOrNull(&nullish)
        .Jump(&short_circuit)
        .Bind(&nullish);
    VisitInHoleCheckElisionScopeForAccumulatorValue(expr->value());
  } else if (binop->op() == Token::kOr) {
    builder()->JumpIfTrue(ToBooleanMode::kConvertToBoolean, &short_circuit);
    VisitInHoleCheckElisionScopeForAccumulatorValue(expr->value());
  } else if (binop->op() == Token::kAnd) {
    builder()->JumpIfFalse(ToBooleanMode::kConvertToBoolean, &short_circuit);
    VisitInHoleCheckElisionScopeForAccumulatorValue(expr->value());
  } else if (expr->value()->IsSmiLiteral()) {
    builder()->BinaryOperationSmiLiteral(
        binop->op(), expr->value()->AsLiteral()->AsSmiLiteral(),
        feedback_index(slot));
  } else {
    Register old_value = register_allocator()->NewRegister();
    builder()->StoreAccumulatorInRegister(old_value);
    VisitForAccumulatorValue(expr->value());
    builder()->BinaryOperation(binop->op(), old_value, feedback_index(slot));
  }
  builder()->SetExpressionPosition(expr);

  BuildAssignment(lhs_data, expr->op(), expr->lookup_hoisting_mode());
  builder()->Bind(&short_circuit);
}

// Suspends the generator to resume at the next suspend_id, with output stored
// in the accumulator. When the generator is resumed, the sent value is loaded
// in the accumulator.
void BytecodeGenerator::BuildSuspendPoint(int position) {
  // Because we eliminate jump targets in dead code, we also eliminate resumes
  // when the suspend is not emitted because otherwise the below call to Bind
  // would start a new basic block and the code would be considered alive.
  if (builder()->RemainderOfBlockIsDead()) {
    return;
  }
  const int suspend_id = suspend_count_++;

  RegisterList registers = register_allocator()->AllLiveRegisters();

  // Save context, registers, and state. This bytecode then returns the value
  // in the accumulator.
  builder()->SetExpressionPosition(position);
  builder()->SuspendGenerator(generator_object(), registers, suspend_id);

  // Upon resume, we continue here.
  builder()->Bind(generator_jump_table_, suspend_id);

  // Clobbers all registers and sets the accumulator to the
  // [[input_or_debug_pos]] slot of the generator object.
  builder()->ResumeGenerator(generator_object(), registers);
}

void BytecodeGenerator::VisitYield(Yield* expr) {
  builder()->SetExpressionPosition(expr);
  VisitForAccumulatorValue(expr->expression());

  bool is_async = IsAsyncGeneratorFunction(function_kind());
  // If this is not the first yield
  if (suspend_count_ > 0) {
    if (is_async) {
      // AsyncGenerator yields (with the exception of the initial yield)
      // delegate work to the AsyncGeneratorYieldWithAwait stub, which Awaits
      // the operand and on success, wraps the value in an IteratorResult.
      //
      // In the spec the Await is a separate operation, but they are combined
      // here to reduce bytecode size.
      RegisterAllocationScope register_scope(this);
      RegisterList args = register_allocator()->NewRegisterList(2);
      builder()
          ->MoveRegister(generator_object(), args[0])  // generator
          .StoreAccumulatorInRegister(args[1])         // value
          .CallRuntime(Runtime::kInlineAsyncGeneratorYieldWithAwait, args);
    } else {
      // Generator yields (with the exception of the initial yield) wrap the
      // value into IteratorResult.
      RegisterAllocationScope register_scope(this);
      RegisterList args = register_allocator()->NewRegisterList(2);
      builder()
          ->StoreAccumulatorInRegister(args[0])  // value
          .LoadFalse()
          .StoreAccumulatorInRegister(args[1])  // done
          .CallRuntime(Runtime::kInlineCreateIterResultObject, args);
    }
  }

  BuildSuspendPoint(expr->position());
  // At this point, the generator has been resumed, with the received value in
  // the accumulator.

  // TODO(caitp): remove once yield* desugaring for async generators is handled
  // in BytecodeGenerator.
  if (expr->on_abrupt_resume() == Yield::kNoControl) {
    DCHECK(is_async);
    return;
  }

  Register input = register_allocator()->NewRegister();
  builder()->StoreAccumulatorInRegister(input).CallRuntime(
      Runtime::kInlineGeneratorGetResumeMode, generator_object());

  // Now dispatch on resume mode.
  static_assert(JSGeneratorObject::kNext + 1 == JSGeneratorObject::kReturn);
  static_assert(JSGeneratorObject::kReturn + 1 == JSGeneratorObject::kThrow);
  BytecodeJumpTable* jump_table =
      builder()->AllocateJumpTable(is_async ? 3 : 2, JSGeneratorObject::kNext);

  builder()->SwitchOnSmiNoFeedback(jump_table);

  if (is_async) {
    // Resume with rethrow (switch fallthrough).
    // This case is only necessary in async generators.
    builder()->SetExpressionPosition(expr);
    builder()->LoadAccumulatorWithRegister(input);
    builder()->ReThrow();

    // Add label for kThrow (next case).
    builder()->Bind(jump_table, JSGeneratorObject::kThrow);
  }

  {
    // Resume with throw (switch fallthrough in sync case).
    // TODO(leszeks): Add a debug-only check that the accumulator is
    // JSGeneratorObject::kThrow.
    builder()->SetExpressionPosition(expr);
    builder()->LoadAccumulatorWithRegister(input);
    builder()->Throw();
  }

  {
    // Resume with return.
    builder()->Bind(jump_table, JSGeneratorObject::kReturn);
    builder()->LoadAccumulatorWithRegister(input);
    if (is_async) {
      execution_control()->AsyncReturnAccumulator(kNoSourcePosition);
    } else {
      execution_control()->ReturnAccumulator(kNoSourcePosition);
    }
  }

  {
    // Resume with next.
    builder()->Bind(jump_table, JSGeneratorObject::kNext);
    BuildIncrementBlockCoverageCounterIfEnabled(expr,
                                                SourceRangeKind::kContinuation);
    builder()->LoadAccumulatorWithRegister(input);
  }
}

// Desugaring of (yield* iterable)
//
//   do {
//     const kNext = 0;
//     const kReturn = 1;
//     const kThrow = 2;
//
//     let output; // uninitialized
//
//     let iteratorRecord = GetIterator(iterable);
//     let iterator = iteratorRecord.[[Iterator]];
//     let next = iteratorRecord.[[NextMethod]];
//     let input = undefined;
//     let resumeMode = kNext;
//
//     while (true) {
//       // From the generator to the iterator:
//       // Forward input according to resumeMode and obtain output.
//       switch (resumeMode) {
//         case kNext:
//           output = next.[[Call]](iterator, « »);;
//           break;
//         case kReturn:
//           let iteratorReturn = iterator.return;
//           if (IS_NULL_OR_UNDEFINED(iteratorReturn)) {
//             if (IS_ASYNC_GENERATOR) input = await input;
//             return input;
//           }
//           output = iteratorReturn.[[Call]](iterator, «input»);
//           break;
//         case kThrow:
//           let iteratorThrow = iterator.throw;
//           if (IS_NULL_OR_UNDEFINED(iteratorThrow)) {
//             let iteratorReturn = iterator.return;
//             if (!IS_NULL_OR_UNDEFINED(iteratorReturn)) {
//               output = iteratorReturn.[[Call]](iterator, « »);
//               if (IS_ASYNC_GENERATOR) output = await output;
//               if (!IS_RECEIVER(output)) %ThrowIterResultNotAnObject(output);
//             }
//             throw MakeTypeError(kThrowMethodMissing);
//           }
//           output = iteratorThrow.[[Call]](iterator, «input»);
//           break;
//       }
//
//       if (IS_ASYNC_GENERATOR) output = await output;
//       if (!IS_RECEIVER(output)) %ThrowIterResultNotAnObject(output);
//       if (output.done) break;
//
//       // From the generator to its user:
//       // Forward output, receive new input, and determine resume mode.
//       if (IS_ASYNC_GENERATOR) {
//         // Resolve the promise for the current AsyncGeneratorRequest.
//         %_AsyncGeneratorResolve(output.value, /* done = */ false)
//       }
//       input = Suspend(output);
//       resumeMode = %GeneratorGetResumeMode();
//     }
//
//     if (resumeMode === kReturn) {
//       return output.value;
//     }
//     output.value
//   }
void BytecodeGenerator::VisitYieldStar(YieldStar* expr) {
  Register output = register_allocator()->NewRegister();
  Register resume_mode = register_allocator()->NewRegister();
  IteratorType iterator_type = IsAsyncGeneratorFunction(function_kind())
                                   ? IteratorType::kAsync
                                   : IteratorType::kNormal;

  {
    RegisterAllocationScope register_scope(this);
    RegisterList iterator_and_input = register_allocator()->NewRegisterList(2);
    VisitForAccumulatorValue(expr->expression());
    IteratorRecord iterator = BuildGetIteratorRecord(
        register_allocator()->NewRegister() /* next method */,
        iterator_and_input[0], iterator_type);

    Register input = iterator_and_input[1];
    builder()->LoadUndefined().StoreAccumulatorInRegister(input);
    builder()
        ->LoadLiteral(Smi::FromInt(JSGeneratorObject::kNext))
        .StoreAccumulatorInRegister(resume_mode);

    {
      // This loop builder does not construct counters as the loop is not
      // visible to the user, and we therefore neither pass the block coverage
      // builder nor the expression.
      //
      // In addition to the normal suspend for yield*, a yield* in an async
      // generator has 2 additional suspends:
      //   - One for awaiting the iterator result of closing the generator when
      //     resumed with a "throw" completion, and a throw method is not
      //     present on the delegated iterator
      //   - One for awaiting the iterator result yielded by the delegated
      //     iterator

      LoopBuilder loop_builder(builder(), nullptr, nullptr, feedback_spec());
      LoopScope loop_scope(this, &loop_builder);

      {
        BytecodeLabels after_switch(zone());
        BytecodeJumpTable* switch_jump_table =
            builder()->AllocateJumpTable(2, 1);

        builder()
            ->LoadAccumulatorWithRegister(resume_mode)
            .SwitchOnSmiNoFeedback(switch_jump_table);

        // Fallthrough to default case.
        // TODO(ignition): Add debug code to check that {resume_mode} really is
        // {JSGeneratorObject::kNext} in this case.
        static_assert(JSGeneratorObject::kNext == 0);
        {
          FeedbackSlot slot = feedback_spec()->AddCallICSlot();
          builder()->CallProperty(iterator.next(), iterator_and_input,
                                  feedback_index(slot));
          builder()->Jump(after_switch.New());
        }

        static_assert(JSGeneratorObject::kReturn == 1);
        builder()->Bind(switch_jump_table, JSGeneratorObject::kReturn);
        {
          const AstRawString* return_string =
              ast_string_constants()->return_string();
          BytecodeLabels no_return_method(zone());

          BuildCallIteratorMethod(iterator.object(), return_string,
                                  iterator_and_input, after_switch.New(),
                                  &no_return_method);
          no_return_method.Bind(builder());
          builder()->LoadAccumulatorWithRegister(input);
          if (iterator_type == IteratorType::kAsync) {
            // Await input.
            BuildAwait(expr->position());
            execution_control()->AsyncReturnAccumulator(kNoSourcePosition);
          } else {
            execution_control()->ReturnAccumulator(kNoSourcePosition);
          }
        }

        static_assert(JSGeneratorObject::kThrow == 2);
        builder()->Bind(switch_jump_table, JSGeneratorObject::kThrow);
        {
          const AstRawString* throw_string =
              ast_string_constants()->throw_string();
          BytecodeLabels no_throw_method(zone());
          BuildCallIteratorMethod(iterator.object(), throw_string,
                                  iterator_and_input, after_switch.New(),
                                  &no_throw_method);

          // If there is no "throw" method, perform IteratorClose, and finally
          // throw a TypeError.
          no_throw_method.Bind(builder());
          BuildIteratorClose(iterator, expr);
          builder()->CallRuntime(Runtime::kThrowThrowMethodMissing);
        }

        after_switch.Bind(builder());
      }

      if (iterator_type == IteratorType::kAsync) {
        // Await the result of the method invocati
"""


```
Response:
My thinking process to answer the request about `bytecode-array-builder.cc` went through these stages:

1. **Understand the Core Request:** The request asks for the functionalities of the provided C++ source code, specifically focusing on its role in V8, its relationship to JavaScript, and potential connections to user programming errors. It also asks for a summary of the functionalities. The `.tq` check is a simple conditional.

2. **Initial Scan and Keyword Identification:** I quickly scanned the code for important keywords and patterns. I noticed:
    * `BytecodeArrayBuilder`: This is the central class and suggests the code's main purpose is building bytecode arrays.
    * `Register`, `Operand`, `BytecodeNode`, `Bytecode`: These terms strongly indicate involvement in low-level code generation.
    * `Output...`:  Many functions start with "Output," suggesting they emit bytecode instructions.
    * `Ldar`, `Star`, `Mov`, `Add`, `Sub`, etc.: These look like individual bytecode instructions.
    * `ConstantPool`, `HandlerTable`, `SourcePositionTable`: These are auxiliary data structures used in code generation.
    * `FeedbackVectorSpec`: This points to optimization and runtime feedback mechanisms.
    * `Zone`:  Indicates memory management within V8.
    * `JavaScript-related concepts`: I looked for terms like `global`, `context`, `property`, `super`, `iterator`, which link the bytecode generation to JavaScript semantics.

3. **Inferring Primary Functionality:** Based on the class name and the presence of `Output...` functions for various bytecodes, I concluded that `BytecodeArrayBuilder` is responsible for **generating bytecode instructions**. It acts as an interface for emitting these instructions and managing the underlying bytecode array.

4. **Deconstructing Key Components and Their Roles:** I then considered the other classes and members:
    * `BytecodeArrayWriter`:  Likely handles the actual writing of bytes into the bytecode array. `BytecodeArrayBuilder` probably uses it as a delegate.
    * `ConstantArrayBuilder`: Responsible for managing constants used in the bytecode (literals, strings, etc.).
    * `HandlerTableBuilder`:  Deals with exception handling information.
    * `RegisterAllocator`/`BytecodeRegisterOptimizer`: These are crucial for efficient register allocation during bytecode generation. The optimizer tries to minimize unnecessary register moves.
    * `SourcePositionTableBuilder`:  Connects bytecode instructions back to their source code locations, important for debugging and profiling.

5. **Connecting to JavaScript Functionality:** I went through the `Output...` functions and tried to relate them to common JavaScript operations:
    * `LdaGlobal`, `StaGlobal`: Accessing global variables.
    * `LdaContextSlot`, `StaContextSlot`: Accessing variables in closures/scopes.
    * `LoadNamedProperty`, `SetNamedProperty`: Accessing object properties using names.
    * `GetKeyedProperty`, `SetKeyedProperty`: Accessing object properties using keys (like array indices).
    * Arithmetic and logical operations (`Add`, `Sub`, `LogicalNot`, etc.).
    * Comparisons (`TestEqual`, `TestLessThan`, etc.).
    * Function calls (`Call`, `New`).
    * Control flow (`Jump`, `JumpIfFalse`).

6. **Illustrating with JavaScript Examples:** For each category of functionality, I thought of simple JavaScript code snippets that would require the corresponding bytecode instructions. This made the connection between the C++ code and JavaScript more concrete.

7. **Identifying Potential Programming Errors:** I considered how incorrect JavaScript code might lead to issues at the bytecode generation level or during execution of the generated bytecode. Examples include:
    * Using undeclared variables (leading to `LdaLookupSlot` and potential runtime errors).
    * Incorrect `this` binding (related to `Ldar this`).
    * Type errors in operations (though bytecode itself doesn't prevent this, the feedback slots are related to optimization based on types).

8. **Addressing the `.tq` Question:** This was a straightforward check based on the file extension. Since it ends with `.cc`, it's a regular C++ source file, not a Torque file.

9. **Code Logic Inference (Hypothetical Input/Output):** I chose a simple scenario (adding two numbers) and showed how the `BytecodeArrayBuilder` would process this, emitting `Ldar`, `Add`, and `Star` instructions. This demonstrated a basic code generation flow.

10. **Structuring the Answer:** I organized the information into logical sections based on the request's prompts (functionalities, JavaScript relationship, programming errors, etc.). I used clear headings and bullet points for readability.

11. **Summarizing the Functionality:** Finally, I condensed the main points into a concise summary that captured the essence of `BytecodeArrayBuilder`'s role.

Throughout this process, I focused on explaining *what* the code does and *why* it's important in the context of V8 and JavaScript execution. I avoided going into excessive low-level detail of the bytecode instructions themselves, as the request was more about the builder's overall role.
```cpp
// Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/interpreter/bytecode-array-builder.h"

#include <optional>

#include "src/ast/scopes.h"
#include "src/ast/variables.h"
#include "src/common/assert-scope.h"
#include "src/common/globals.h"
#include "src/interpreter/bytecode-array-writer.h"
#include "src/interpreter/bytecode-jump-table.h"
#include "src/interpreter/bytecode-label.h"
#include "src/interpreter/bytecode-node.h"
#include "src/interpreter/bytecode-register-optimizer.h"
#include "src/interpreter/bytecode-source-info.h"
#include "src/interpreter/interpreter-intrinsics.h"
#include "src/objects/feedback-vector-inl.h"
#include "src/objects/smi.h"

namespace v8 {
namespace internal {
namespace interpreter {

class RegisterTransferWriter final
    : public NON_EXPORTED_BASE(BytecodeRegisterOptimizer::BytecodeWriter),
      public NON_EXPORTED_BASE(ZoneObject) {
 public:
  explicit RegisterTransferWriter(BytecodeArrayBuilder* builder)
      : builder_(builder) {}
  ~RegisterTransferWriter() override = default;

  void EmitLdar(Register input) override { builder_->OutputLdarRaw(input); }

  void EmitStar(Register output) override { builder_->OutputStarRaw(output); }

  void EmitMov(Register input, Register output) override {
    builder_->OutputMovRaw(input, output);
  }

 private:
  BytecodeArrayBuilder* builder_;
};

BytecodeArrayBuilder::BytecodeArrayBuilder(
    Zone* zone, int parameter_count, int locals_count,
    FeedbackVectorSpec* feedback_vector_spec,
    SourcePositionTableBuilder::RecordingMode source_position_mode)
    : zone_(zone),
      feedback_vector_spec_(feedback_vector_spec),
      bytecode_generated_(false),
      constant_array_builder_(zone),
      handler_table_builder_(zone),
      parameter_count_(parameter_count),
      max_arguments_(0),
      local_register_count_(locals_count),
      register_allocator_(fixed_register_count()),
      bytecode_array_writer_(zone, &constant_array_builder_,
                             source_position_mode),
      register_optimizer_(nullptr) {
  DCHECK_GE(parameter_count_, 0);
  DCHECK_LE(parameter_count_, std::numeric_limits<uint16_t>::max());
  DCHECK_GE(local_register_count_, 0);

  if (v8_flags.ignition_reo) {
    register_optimizer_ = zone->New<BytecodeRegisterOptimizer>(
        zone, &register_allocator_, fixed_register_count(), parameter_count,
        zone->New<RegisterTransferWriter>(this));
  }
}

// ... (rest of the code)
```

## 功能列举

`v8/src/interpreter/bytecode-array-builder.cc` 的主要功能是**构建 V8 解释器（Ignition）执行的字节码数组（BytecodeArray）**。  它负责将高级的中间表示形式（通常由 Parser 和 Compiler 生成）转换为底层的、可执行的字节码指令序列。

更具体地说，它的功能包括：

1. **管理字节码生成过程:** 它提供了一系列方法 (`OutputLdar`, `OutputStar`, `OutputAdd`, `OutputCall`, 等等) 用于输出不同的字节码指令。这些方法通常对应于 JavaScript 语言中的各种操作。

2. **维护常量池:** 它使用 `constant_array_builder_` 来存储代码中使用的常量值（例如，数字、字符串、函数引用）。字节码指令可以通过索引引用这些常量。

3. **维护异常处理表:** 它使用 `handler_table_builder_` 来记录 `try-catch` 语句的信息，以便在运行时发生异常时跳转到正确的处理程序。

4. **分配和管理寄存器:** 它使用 `register_allocator_` 来为局部变量和临时值分配寄存器。`register_optimizer_` (如果启用) 会尝试优化寄存器的使用，例如消除不必要的寄存器移动。

5. **处理源代码位置信息:** 它使用 `bytecode_array_writer_` 和 `SourcePositionTableBuilder` 来记录每个字节码指令对应的源代码位置，用于调试和性能分析。

6. **支持控制流:** 它提供了用于生成跳转指令的方法 (`OutputJump`, `OutputJumpIfFalse`)，以及用于定义跳转目标的标签 (`BytecodeLabel`).

7. **支持函数参数和局部变量:** 它跟踪函数参数和局部变量的数量，并提供访问它们的抽象 (`Parameter`, `Local`).

8. **生成最终的字节码数组:** `ToBytecodeArray` 方法会将所有生成的字节码指令、常量池和异常处理信息组合成一个 `BytecodeArray` 对象，供解释器执行。

## 关于 .tq 后缀

如果 `v8/src/interpreter/bytecode-array-builder.cc` 以 `.tq` 结尾，那么它将是一个 **V8 Torque 源代码**。 Torque 是一种 V8 内部使用的领域特定语言，用于生成高效的 C++ 代码，特别是用于实现内置函数和运行时组件。

**但根据你提供的文件名，它以 `.cc` 结尾，所以它是一个标准的 C++ 源代码文件。**

## 与 JavaScript 的关系 (附带 JavaScript 示例)

`bytecode-array-builder.cc` 的核心职责是将 JavaScript 代码转换成可执行的字节码。 因此，它与 JavaScript 的功能有着非常紧密的联系。  几乎每个 JavaScript 语法结构和操作都有对应的字节码指令，而 `BytecodeArrayBuilder` 就是负责生成这些指令的。

**以下是一些 JavaScript 代码片段以及它们可能生成的（简化的）字节码示例：**

**示例 1: 加法运算**

```javascript
function add(a, b) {
  return a + b;
}
```

生成的字节码可能包含类似以下的指令：

* `Ldar a`:  将寄存器 `a` 的值加载到累加器 (accumulator)。
* `Add b`:  将寄存器 `b` 的值与累加器中的值相加。
* `Star result`: 将累加器中的结果存储到 `result` 寄存器。
* `Ldar result`: 将 `result` 寄存器的值加载到累加器（作为返回值）。
* `Return`: 返回累加器中的值。

**`BytecodeArrayBuilder` 中相应的操作：**

```c++
builder->OutputLdar(builder->Parameter(0)); // 加载参数 a
builder->OutputAdd(builder->Parameter(1), feedback_slot); // 加载参数 b 并相加
builder->OutputStar(builder->Local(0)); // 假设 result 是一个局部变量
builder->OutputLdar(builder->Local(0));
builder->OutputReturn();
```

**示例 2: 函数调用**

```javascript
function greet(name) {
  console.log("Hello, " + name);
}

greet("World");
```

生成的字节码可能包含类似以下的指令：

* `LdaGlobal console`: 加载全局对象 `console`。
* `GetNamedProperty log [feedback slot]`: 获取 `console` 对象的 `log` 属性。
* `LdaConstant "Hello, "`: 加载字符串常量 "Hello, "。
* `Ldar "World"`: 加载字符串 "World"。
* `Add`: 字符串拼接。
* `Call log, 1 [feedback slot]`: 调用 `log` 函数，传递 1 个参数。

**`BytecodeArrayBuilder` 中相应的操作：**

```c++
builder->OutputLdaGlobal(builder->GetConstantPoolEntry("console"), feedback_slot_console);
builder->OutputGetNamedProperty(builder->AccumulatorRegister(), builder->GetConstantPoolEntry("log"), feedback_slot_log);
builder->OutputLdaConstant(builder->GetConstantPoolEntry("Hello, "));
builder->OutputLdar(builder->GetConstantPoolEntry("World"));
builder->OutputAdd(builder->AccumulatorRegister(), feedback_slot_add);
builder->OutputCall(builder->AccumulatorRegister(), 1, feedback_slot_call);
```

**示例 3: 条件语句**

```javascript
function isPositive(num) {
  if (num > 0) {
    return true;
  } else {
    return false;
  }
}
```

生成的字节码可能包含类似以下的指令：

* `Ldar num`: 加载参数 `num`。
* `LdaSmi 0`: 加载 Smi 值 0。
* `TestGreaterThan [feedback slot]`: 比较是否大于 0。
* `JumpIfTrue label_true`: 如果为真，跳转到 `label_true`。
* `LdaFalse`: 加载 `false`。
* `Jump label_end`: 跳转到 `label_end`。
* `label_true:`: 标签
* `LdaTrue`: 加载 `true`。
* `label_end:`: 标签
* `Return`: 返回累加器中的值。

**`BytecodeArrayBuilder` 中相应的操作：**

```c++
BytecodeLabel label_true, label_end;
builder->OutputLdar(builder->Parameter(0));
builder->OutputLdaSmi(0);
builder->OutputTestGreaterThan(builder->AccumulatorRegister(), feedback_slot);
builder->OutputJumpIfTrue(&label_true);
builder->OutputLdaFalse();
builder->OutputJump(&label_end);
builder->Bind(&label_true);
builder->OutputLdaTrue();
builder->Bind(&label_end);
builder->OutputReturn();
```

## 代码逻辑推理 (假设输入与输出)

**假设输入:**  表示以下 JavaScript 代码的抽象语法树 (AST)：

```javascript
function multiply(x) {
  return x * 2;
}
```

**`BytecodeArrayBuilder` 的处理过程 (简化):**

1. **创建 `BytecodeArrayBuilder` 实例:**  初始化，指定参数数量 (1) 和局部变量数量 (0)。
2. **开始生成字节码:**
   * **加载参数 `x`:** `OutputLdar(Parameter(0))`
   * **加载常量 `2`:** `OutputLdaSmi(2)`
   * **执行乘法运算:** `OutputMul(Parameter(0), feedback_slot)` (假设将结果放回累加器)
   * **返回结果:** `OutputReturn()`
3. **调用 `ToBytecodeArray`:** 生成最终的 `BytecodeArray` 对象。

**假设输出 (伪代码表示的 BytecodeArray):**

```
BytecodeArray {
  parameter_count: 1,
  register_count: 1, // 假设只需要一个寄存器
  bytecode: [
    Ldar r0,      // r0 代表参数 x
    LdaSmi 2,
    Mul r0, [feedback_slot],
    Return
  ],
  constant_pool: [],
  handler_table: []
}
```

**解释:**

* `Ldar r0`: 将参数 `x` (位于寄存器 `r0`) 加载到累加器。
* `LdaSmi 2`: 将 Smi 值 `2` 加载到累加器。
* `Mul r0, [feedback_slot]`: 将累加器中的值与寄存器 `r0` 中的值相乘，结果放回累加器。`feedback_slot` 用于运行时优化。
* `Return`: 返回累加器中的值。

**注意:** 这只是一个简化的例子。实际生成的字节码会更复杂，并且会涉及到寄存器分配、常量池索引等细节。

## 用户常见的编程错误

虽然 `BytecodeArrayBuilder` 本身是 V8 内部的组件，用户不会直接与之交互，但用户编写的 JavaScript 代码中的错误会导致 `BytecodeArrayBuilder` 生成的字节码在执行时出现问题或抛出异常。

**以下是一些与字节码生成相关的、常见的用户编程错误：**

1. **使用了未声明的变量:**

   ```javascript
   function foo() {
     console.log(undeclaredVariable); // ReferenceError
   }
   ```

   当编译器尝试为 `undeclaredVariable` 生成字节码时，会发现它在当前作用域中不存在，这会导致生成加载查找槽 (lookup slot) 的字节码，最终在运行时抛出 `ReferenceError`。

2. **类型错误的操作:**

   ```javascript
   function bar(a, b) {
     return a + b;
   }

   bar("hello", 10); //  结果可能是 "hello10" (字符串拼接)
   bar(5, 10);     // 结果是 15 (数字加法)
   ```

   `BytecodeArrayBuilder` 会为加法操作生成 `Add` 字节码。  虽然字节码本身并不会阻止不同类型的操作数，但 V8 的运行时系统会根据操作数的类型执行不同的操作（例如，字符串拼接或数字加法）。  不注意类型可能导致非预期的结果。

3. **访问不存在的对象属性:**

   ```javascript
   const obj = { name: "Alice" };
   console.log(obj.age); // undefined
   ```

   `BytecodeArrayBuilder` 会生成 `GetNamedProperty` 字节码来尝试获取 `age` 属性。如果属性不存在，字节码执行会返回 `undefined`。

4. **`this` 指向错误:**

   ```javascript
   const myObject = {
     value: 10,
     getValue: function() {
       return this.value;
     }
   };

   const getValueFunc = myObject.getValue;
   console.log(getValueFunc()); // undefined (this 指向了全局对象)
   ```

   `BytecodeArrayBuilder` 会根据 `this` 的使用情况生成不同的字节码。  如果 `this` 的绑定不正确，会导致访问错误的属性或方法。

5. **不正确的函数调用:**

   ```javascript
   function sum(a, b) {
     return a + b;
   }

   sum(1); // NaN (缺少参数)
   ```

   `BytecodeArrayBuilder` 会生成 `Call` 字节码。如果调用时提供的参数数量不正确，会导致函数执行错误。

## 功能归纳 (第 1 部分)

总而言之，`v8/src/interpreter/bytecode-array-builder.cc` 的核心功能是 **作为 V8 解释器 Ignition 的代码生成器，负责将高级的中间表示形式转换为可执行的字节码数组。** 它管理字节码指令的生成、常量池、异常处理信息、寄存器分配以及源代码位置信息的记录，是 JavaScript 代码在 V8 中执行的关键环节。 它通过提供一系列 `Output...` 方法，允许 V8 的编译器将 JavaScript 的各种语法结构和操作转化为底层的字节码指令。

### 提示词
```
这是目录为v8/src/interpreter/bytecode-array-builder.cc的一个v8源代码， 请列举一下它的功能, 
如果v8/src/interpreter/bytecode-array-builder.cc以.tq结尾，那它是个v8 torque源代码，
如果它与javascript的功能有关系，请用javascript举例说明,
如果有代码逻辑推理，请给出假设输入与输出，
如果涉及用户常见的编程错误，请举例说明
这是第1部分，共2部分，请归纳一下它的功能
```

### 源代码
```cpp
// Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/interpreter/bytecode-array-builder.h"

#include <optional>

#include "src/ast/scopes.h"
#include "src/ast/variables.h"
#include "src/common/assert-scope.h"
#include "src/common/globals.h"
#include "src/interpreter/bytecode-array-writer.h"
#include "src/interpreter/bytecode-jump-table.h"
#include "src/interpreter/bytecode-label.h"
#include "src/interpreter/bytecode-node.h"
#include "src/interpreter/bytecode-register-optimizer.h"
#include "src/interpreter/bytecode-source-info.h"
#include "src/interpreter/interpreter-intrinsics.h"
#include "src/objects/feedback-vector-inl.h"
#include "src/objects/smi.h"

namespace v8 {
namespace internal {
namespace interpreter {

class RegisterTransferWriter final
    : public NON_EXPORTED_BASE(BytecodeRegisterOptimizer::BytecodeWriter),
      public NON_EXPORTED_BASE(ZoneObject) {
 public:
  explicit RegisterTransferWriter(BytecodeArrayBuilder* builder)
      : builder_(builder) {}
  ~RegisterTransferWriter() override = default;

  void EmitLdar(Register input) override { builder_->OutputLdarRaw(input); }

  void EmitStar(Register output) override { builder_->OutputStarRaw(output); }

  void EmitMov(Register input, Register output) override {
    builder_->OutputMovRaw(input, output);
  }

 private:
  BytecodeArrayBuilder* builder_;
};

BytecodeArrayBuilder::BytecodeArrayBuilder(
    Zone* zone, int parameter_count, int locals_count,
    FeedbackVectorSpec* feedback_vector_spec,
    SourcePositionTableBuilder::RecordingMode source_position_mode)
    : zone_(zone),
      feedback_vector_spec_(feedback_vector_spec),
      bytecode_generated_(false),
      constant_array_builder_(zone),
      handler_table_builder_(zone),
      parameter_count_(parameter_count),
      max_arguments_(0),
      local_register_count_(locals_count),
      register_allocator_(fixed_register_count()),
      bytecode_array_writer_(zone, &constant_array_builder_,
                             source_position_mode),
      register_optimizer_(nullptr) {
  DCHECK_GE(parameter_count_, 0);
  DCHECK_LE(parameter_count_, std::numeric_limits<uint16_t>::max());
  DCHECK_GE(local_register_count_, 0);

  if (v8_flags.ignition_reo) {
    register_optimizer_ = zone->New<BytecodeRegisterOptimizer>(
        zone, &register_allocator_, fixed_register_count(), parameter_count,
        zone->New<RegisterTransferWriter>(this));
  }
}

Register BytecodeArrayBuilder::Parameter(int parameter_index) const {
  DCHECK_GE(parameter_index, 0);
  // The parameter indices are shifted by 1 (receiver is the
  // first entry).
  return Register::FromParameterIndex(parameter_index + 1);
}

Register BytecodeArrayBuilder::Receiver() const {
  return Register::FromParameterIndex(0);
}

Register BytecodeArrayBuilder::Local(int index) const {
  DCHECK_LT(index, locals_count());
  return Register(index);
}

template <typename IsolateT>
Handle<BytecodeArray> BytecodeArrayBuilder::ToBytecodeArray(IsolateT* isolate) {
  DCHECK(RemainderOfBlockIsDead());
  DCHECK(!bytecode_generated_);
  bytecode_generated_ = true;

  int register_count = total_register_count();

  if (register_optimizer_) {
    register_optimizer_->Flush();
    register_count = register_optimizer_->maxiumum_register_index() + 1;
  }

  Handle<TrustedByteArray> handler_table =
      handler_table_builder()->ToHandlerTable(isolate);
  return bytecode_array_writer_.ToBytecodeArray(isolate, register_count,
                                                parameter_count(),
                                                max_arguments(), handler_table);
}

template EXPORT_TEMPLATE_DEFINE(V8_EXPORT_PRIVATE)
    Handle<BytecodeArray> BytecodeArrayBuilder::ToBytecodeArray(
        Isolate* isolate);
template EXPORT_TEMPLATE_DEFINE(V8_EXPORT_PRIVATE)
    Handle<BytecodeArray> BytecodeArrayBuilder::ToBytecodeArray(
        LocalIsolate* isolate);

#ifdef DEBUG
int BytecodeArrayBuilder::CheckBytecodeMatches(Tagged<BytecodeArray> bytecode) {
  DisallowGarbageCollection no_gc;
  return bytecode_array_writer_.CheckBytecodeMatches(bytecode);
}
#endif

template <typename IsolateT>
Handle<TrustedByteArray> BytecodeArrayBuilder::ToSourcePositionTable(
    IsolateT* isolate) {
  DCHECK(RemainderOfBlockIsDead());

  return bytecode_array_writer_.ToSourcePositionTable(isolate);
}

template EXPORT_TEMPLATE_DEFINE(V8_EXPORT_PRIVATE)
    Handle<TrustedByteArray> BytecodeArrayBuilder::ToSourcePositionTable(
        Isolate* isolate);
template EXPORT_TEMPLATE_DEFINE(V8_EXPORT_PRIVATE)
    Handle<TrustedByteArray> BytecodeArrayBuilder::ToSourcePositionTable(
        LocalIsolate* isolate);

BytecodeSourceInfo BytecodeArrayBuilder::CurrentSourcePosition(
    Bytecode bytecode) {
  BytecodeSourceInfo source_position;
  if (latest_source_info_.is_valid()) {
    // Statement positions need to be emitted immediately.  Expression
    // positions can be pushed back until a bytecode is found that can
    // throw (if expression position filtering is turned on). We only
    // invalidate the existing source position information if it is used.
    if (latest_source_info_.is_statement() ||
        !v8_flags.ignition_filter_expression_positions ||
        !Bytecodes::IsWithoutExternalSideEffects(bytecode)) {
      source_position = latest_source_info_;
      latest_source_info_.set_invalid();
    }
  }
  return source_position;
}

void BytecodeArrayBuilder::SetDeferredSourceInfo(
    BytecodeSourceInfo source_info) {
  if (!source_info.is_valid()) return;
  deferred_source_info_ = source_info;
}

void BytecodeArrayBuilder::AttachOrEmitDeferredSourceInfo(BytecodeNode* node) {
  if (!deferred_source_info_.is_valid()) return;
  if (!node->source_info().is_valid()) {
    node->set_source_info(deferred_source_info_);
  } else if (deferred_source_info_.is_statement() &&
             node->source_info().is_expression()) {
    BytecodeSourceInfo source_position = node->source_info();
    source_position.MakeStatementPosition(source_position.source_position());
    node->set_source_info(source_position);
  }
  deferred_source_info_.set_invalid();
}

void BytecodeArrayBuilder::Write(BytecodeNode* node) {
  AttachOrEmitDeferredSourceInfo(node);
  bytecode_array_writer_.Write(node);
}

void BytecodeArrayBuilder::WriteJump(BytecodeNode* node, BytecodeLabel* label) {
  AttachOrEmitDeferredSourceInfo(node);
  bytecode_array_writer_.WriteJump(node, label);
}

void BytecodeArrayBuilder::WriteJumpLoop(BytecodeNode* node,
                                         BytecodeLoopHeader* loop_header) {
  AttachOrEmitDeferredSourceInfo(node);
  bytecode_array_writer_.WriteJumpLoop(node, loop_header);
}

void BytecodeArrayBuilder::WriteSwitch(BytecodeNode* node,
                                       BytecodeJumpTable* jump_table) {
  AttachOrEmitDeferredSourceInfo(node);
  bytecode_array_writer_.WriteSwitch(node, jump_table);
}

void BytecodeArrayBuilder::OutputLdarRaw(Register reg) {
  uint32_t operand = static_cast<uint32_t>(reg.ToOperand());
  BytecodeNode node(BytecodeNode::Ldar(BytecodeSourceInfo(), operand));
  Write(&node);
}

void BytecodeArrayBuilder::OutputStarRaw(Register reg) {
  uint32_t operand = static_cast<uint32_t>(reg.ToOperand());
  std::optional<Bytecode> short_code = reg.TryToShortStar();
  BytecodeNode node = short_code
                          ? BytecodeNode(*short_code)
                          : BytecodeNode::Star(BytecodeSourceInfo(), operand);
  Write(&node);
}

void BytecodeArrayBuilder::OutputMovRaw(Register src, Register dest) {
  uint32_t operand0 = static_cast<uint32_t>(src.ToOperand());
  uint32_t operand1 = static_cast<uint32_t>(dest.ToOperand());
  BytecodeNode node(
      BytecodeNode::Mov(BytecodeSourceInfo(), operand0, operand1));
  Write(&node);
}

namespace {

template <OperandTypeInfo type_info>
class UnsignedOperandHelper {
 public:
  V8_INLINE static uint32_t Convert(BytecodeArrayBuilder* builder,
                                    size_t value) {
    DCHECK(IsValid(value));
    return static_cast<uint32_t>(value);
  }

  V8_INLINE static uint32_t Convert(BytecodeArrayBuilder* builder, int value) {
    DCHECK_GE(value, 0);
    return Convert(builder, static_cast<size_t>(value));
  }

 private:
  static bool IsValid(size_t value) {
    switch (type_info) {
      case OperandTypeInfo::kFixedUnsignedByte:
        return value <= kMaxUInt8;
      case OperandTypeInfo::kFixedUnsignedShort:
        return value <= kMaxUInt16;
      case OperandTypeInfo::kScalableUnsignedByte:
        return value <= kMaxUInt32;
      default:
        UNREACHABLE();
    }
  }
};

template <OperandType>
class OperandHelper {};

#define DEFINE_UNSIGNED_OPERAND_HELPER(Name, Type) \
  template <>                                      \
  class OperandHelper<OperandType::k##Name>        \
      : public UnsignedOperandHelper<Type> {};
UNSIGNED_FIXED_SCALAR_OPERAND_TYPE_LIST(DEFINE_UNSIGNED_OPERAND_HELPER)
UNSIGNED_SCALABLE_SCALAR_OPERAND_TYPE_LIST(DEFINE_UNSIGNED_OPERAND_HELPER)
#undef DEFINE_UNSIGNED_OPERAND_HELPER

template <>
class OperandHelper<OperandType::kImm> {
 public:
  V8_INLINE static uint32_t Convert(BytecodeArrayBuilder* builder, int value) {
    return static_cast<uint32_t>(value);
  }
};

template <>
class OperandHelper<OperandType::kReg> {
 public:
  V8_INLINE static uint32_t Convert(BytecodeArrayBuilder* builder,
                                    Register reg) {
    return builder->GetInputRegisterOperand(reg);
  }
};

template <>
class OperandHelper<OperandType::kRegList> {
 public:
  V8_INLINE static uint32_t Convert(BytecodeArrayBuilder* builder,
                                    RegisterList reg_list) {
    return builder->GetInputRegisterListOperand(reg_list);
  }
};

template <>
class OperandHelper<OperandType::kRegPair> {
 public:
  V8_INLINE static uint32_t Convert(BytecodeArrayBuilder* builder,
                                    RegisterList reg_list) {
    DCHECK_EQ(reg_list.register_count(), 2);
    return builder->GetInputRegisterListOperand(reg_list);
  }
};

template <>
class OperandHelper<OperandType::kRegOut> {
 public:
  V8_INLINE static uint32_t Convert(BytecodeArrayBuilder* builder,
                                    Register reg) {
    return builder->GetOutputRegisterOperand(reg);
  }
};

template <>
class OperandHelper<OperandType::kRegOutList> {
 public:
  V8_INLINE static uint32_t Convert(BytecodeArrayBuilder* builder,
                                    RegisterList reg_list) {
    return builder->GetOutputRegisterListOperand(reg_list);
  }
};

template <>
class OperandHelper<OperandType::kRegOutPair> {
 public:
  V8_INLINE static uint32_t Convert(BytecodeArrayBuilder* builder,
                                    RegisterList reg_list) {
    DCHECK_EQ(2, reg_list.register_count());
    return builder->GetOutputRegisterListOperand(reg_list);
  }
};

template <>
class OperandHelper<OperandType::kRegOutTriple> {
 public:
  V8_INLINE static uint32_t Convert(BytecodeArrayBuilder* builder,
                                    RegisterList reg_list) {
    DCHECK_EQ(3, reg_list.register_count());
    return builder->GetOutputRegisterListOperand(reg_list);
  }
};

template <>
class OperandHelper<OperandType::kRegInOut> {
 public:
  V8_INLINE static uint32_t Convert(BytecodeArrayBuilder* builder,
                                    Register reg) {
    return builder->GetInputOutputRegisterOperand(reg);
  }
};

}  // namespace

template <Bytecode bytecode, ImplicitRegisterUse implicit_register_use,
          OperandType... operand_types>
class BytecodeNodeBuilder {
 public:
  template <typename... Operands>
  V8_INLINE static BytecodeNode Make(BytecodeArrayBuilder* builder,
                                     Operands... operands) {
    static_assert(sizeof...(Operands) <= Bytecodes::kMaxOperands,
                  "too many operands for bytecode");
    builder->PrepareToOutputBytecode<bytecode, implicit_register_use>();
    // The "OperandHelper<operand_types>::Convert(builder, operands)..." will
    // expand both the OperandType... and Operands... parameter packs e.g. for:
    //   BytecodeNodeBuilder<OperandType::kReg, OperandType::kImm>::Make<
    //       Register, int>(..., Register reg, int immediate)
    // the code will expand into:
    //    OperandHelper<OperandType::kReg>::Convert(builder, reg),
    //    OperandHelper<OperandType::kImm>::Convert(builder, immediate),
    return BytecodeNode::Create<bytecode, implicit_register_use,
                                operand_types...>(
        builder->CurrentSourcePosition(bytecode),
        OperandHelper<operand_types>::Convert(builder, operands)...);
  }
};

#define DEFINE_BYTECODE_OUTPUT(name, ...)                             \
  template <typename... Operands>                                     \
  BytecodeNode BytecodeArrayBuilder::Create##name##Node(              \
      Operands... operands) {                                         \
    return BytecodeNodeBuilder<Bytecode::k##name, __VA_ARGS__>::Make( \
        this, operands...);                                           \
  }                                                                   \
                                                                      \
  template <typename... Operands>                                     \
  void BytecodeArrayBuilder::Output##name(Operands... operands) {     \
    BytecodeNode node(Create##name##Node(operands...));               \
    Write(&node);                                                     \
  }                                                                   \
                                                                      \
  template <typename... Operands>                                     \
  void BytecodeArrayBuilder::Output##name(BytecodeLabel* label,       \
                                          Operands... operands) {     \
    DCHECK(Bytecodes::IsForwardJump(Bytecode::k##name));              \
    BytecodeNode node(Create##name##Node(operands...));               \
    WriteJump(&node, label);                                          \
  }
BYTECODE_LIST(DEFINE_BYTECODE_OUTPUT, DEFINE_BYTECODE_OUTPUT)
#undef DEFINE_BYTECODE_OUTPUT

void BytecodeArrayBuilder::OutputJumpLoop(BytecodeLoopHeader* loop_header,
                                          int loop_depth, int feedback_slot) {
  BytecodeNode node(CreateJumpLoopNode(0, loop_depth, feedback_slot));
  WriteJumpLoop(&node, loop_header);
}

void BytecodeArrayBuilder::OutputSwitchOnSmiNoFeedback(
    BytecodeJumpTable* jump_table) {
  BytecodeNode node(CreateSwitchOnSmiNoFeedbackNode(
      jump_table->constant_pool_index(), jump_table->size(),
      jump_table->case_value_base()));
  WriteSwitch(&node, jump_table);
}

BytecodeArrayBuilder& BytecodeArrayBuilder::BinaryOperation(Token::Value op,
                                                            Register reg,
                                                            int feedback_slot) {
  switch (op) {
    case Token::kAdd:
      OutputAdd(reg, feedback_slot);
      break;
    case Token::kSub:
      OutputSub(reg, feedback_slot);
      break;
    case Token::kMul:
      OutputMul(reg, feedback_slot);
      break;
    case Token::kDiv:
      OutputDiv(reg, feedback_slot);
      break;
    case Token::kMod:
      OutputMod(reg, feedback_slot);
      break;
    case Token::kExp:
      OutputExp(reg, feedback_slot);
      break;
    case Token::kBitOr:
      OutputBitwiseOr(reg, feedback_slot);
      break;
    case Token::kBitXor:
      OutputBitwiseXor(reg, feedback_slot);
      break;
    case Token::kBitAnd:
      OutputBitwiseAnd(reg, feedback_slot);
      break;
    case Token::kShl:
      OutputShiftLeft(reg, feedback_slot);
      break;
    case Token::kSar:
      OutputShiftRight(reg, feedback_slot);
      break;
    case Token::kShr:
      OutputShiftRightLogical(reg, feedback_slot);
      break;
    default:
      UNREACHABLE();
  }
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::BinaryOperationSmiLiteral(
    Token::Value op, Tagged<Smi> literal, int feedback_slot) {
  switch (op) {
    case Token::kAdd:
      OutputAddSmi(literal.value(), feedback_slot);
      break;
    case Token::kSub:
      OutputSubSmi(literal.value(), feedback_slot);
      break;
    case Token::kMul:
      OutputMulSmi(literal.value(), feedback_slot);
      break;
    case Token::kDiv:
      OutputDivSmi(literal.value(), feedback_slot);
      break;
    case Token::kMod:
      OutputModSmi(literal.value(), feedback_slot);
      break;
    case Token::kExp:
      OutputExpSmi(literal.value(), feedback_slot);
      break;
    case Token::kBitOr:
      OutputBitwiseOrSmi(literal.value(), feedback_slot);
      break;
    case Token::kBitXor:
      OutputBitwiseXorSmi(literal.value(), feedback_slot);
      break;
    case Token::kBitAnd:
      OutputBitwiseAndSmi(literal.value(), feedback_slot);
      break;
    case Token::kShl:
      OutputShiftLeftSmi(literal.value(), feedback_slot);
      break;
    case Token::kSar:
      OutputShiftRightSmi(literal.value(), feedback_slot);
      break;
    case Token::kShr:
      OutputShiftRightLogicalSmi(literal.value(), feedback_slot);
      break;
    default:
      UNREACHABLE();
  }
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::UnaryOperation(Token::Value op,
                                                           int feedback_slot) {
  switch (op) {
    case Token::kInc:
      OutputInc(feedback_slot);
      break;
    case Token::kDec:
      OutputDec(feedback_slot);
      break;
    case Token::kAdd:
      OutputToNumber(feedback_slot);
      break;
    case Token::kSub:
      OutputNegate(feedback_slot);
      break;
    case Token::kBitNot:
      OutputBitwiseNot(feedback_slot);
      break;
    default:
      UNREACHABLE();
  }
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::LogicalNot(ToBooleanMode mode) {
  if (mode == ToBooleanMode::kAlreadyBoolean) {
    OutputLogicalNot();
  } else {
    DCHECK_EQ(mode, ToBooleanMode::kConvertToBoolean);
    OutputToBooleanLogicalNot();
  }
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::TypeOf(int feedback_slot) {
  OutputTypeOf(feedback_slot);
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::GetSuperConstructor(Register out) {
  OutputGetSuperConstructor(out);
  return *this;
}

BytecodeArrayBuilder&
BytecodeArrayBuilder::FindNonDefaultConstructorOrConstruct(
    Register this_function, Register new_target, RegisterList output) {
  OutputFindNonDefaultConstructorOrConstruct(this_function, new_target, output);
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::CompareOperation(
    Token::Value op, Register reg, int feedback_slot) {
  switch (op) {
    case Token::kEq:
      OutputTestEqual(reg, feedback_slot);
      break;
    case Token::kEqStrict:
      OutputTestEqualStrict(reg, feedback_slot);
      break;
    case Token::kLessThan:
      OutputTestLessThan(reg, feedback_slot);
      break;
    case Token::kGreaterThan:
      OutputTestGreaterThan(reg, feedback_slot);
      break;
    case Token::kLessThanEq:
      OutputTestLessThanOrEqual(reg, feedback_slot);
      break;
    case Token::kGreaterThanEq:
      OutputTestGreaterThanOrEqual(reg, feedback_slot);
      break;
    case Token::kInstanceOf:
      OutputTestInstanceOf(reg, feedback_slot);
      break;
    case Token::kIn:
      OutputTestIn(reg, feedback_slot);
      break;
    default:
      UNREACHABLE();
  }
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::CompareReference(Register reg) {
  OutputTestReferenceEqual(reg);
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::CompareUndetectable() {
  OutputTestUndetectable();
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::CompareUndefined() {
  OutputTestUndefined();
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::CompareNull() {
  OutputTestNull();
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::CompareNil(Token::Value op,
                                                       NilValue nil) {
  if (op == Token::kEq) {
    return CompareUndetectable();
  } else {
    DCHECK_EQ(Token::kEqStrict, op);
    if (nil == kUndefinedValue) {
      return CompareUndefined();
    } else {
      DCHECK_EQ(kNullValue, nil);
      return CompareNull();
    }
  }
}

BytecodeArrayBuilder& BytecodeArrayBuilder::CompareTypeOf(
    TestTypeOfFlags::LiteralFlag literal_flag) {
  DCHECK_NE(literal_flag, TestTypeOfFlags::LiteralFlag::kOther);
  OutputTestTypeOf(TestTypeOfFlags::Encode(literal_flag));
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::LoadConstantPoolEntry(
    size_t entry) {
  OutputLdaConstant(entry);
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::LoadLiteral(Tagged<Smi> smi) {
  int32_t raw_smi = smi.value();
  if (raw_smi == 0) {
    OutputLdaZero();
  } else {
    OutputLdaSmi(raw_smi);
  }
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::LoadLiteral(double value) {
  // If we can encode the value as a Smi, we should.
  int smi;
  if (DoubleToSmiInteger(value, &smi)) {
    LoadLiteral(Smi::FromInt(smi));
  } else {
    size_t entry = GetConstantPoolEntry(value);
    OutputLdaConstant(entry);
  }
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::LoadLiteral(
    const AstRawString* raw_string) {
  size_t entry = GetConstantPoolEntry(raw_string);
  OutputLdaConstant(entry);
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::LoadLiteral(
    const AstConsString* cons_string) {
  size_t entry = GetConstantPoolEntry(cons_string);
  OutputLdaConstant(entry);
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::LoadLiteral(const Scope* scope) {
  size_t entry = GetConstantPoolEntry(scope);
  OutputLdaConstant(entry);
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::LoadLiteral(AstBigInt bigint) {
  size_t entry = GetConstantPoolEntry(bigint);
  OutputLdaConstant(entry);
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::LoadUndefined() {
  OutputLdaUndefined();
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::LoadNull() {
  OutputLdaNull();
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::LoadTheHole() {
  OutputLdaTheHole();
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::LoadTrue() {
  OutputLdaTrue();
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::LoadFalse() {
  OutputLdaFalse();
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::LoadBoolean(bool value) {
  return value ? LoadTrue() : LoadFalse();
}

BytecodeArrayBuilder& BytecodeArrayBuilder::LoadAccumulatorWithRegister(
    Register reg) {
  if (register_optimizer_) {
    // Defer source info so that if we elide the bytecode transfer, we attach
    // the source info to a subsequent bytecode if it exists.
    SetDeferredSourceInfo(CurrentSourcePosition(Bytecode::kLdar));
    register_optimizer_->DoLdar(reg);
  } else {
    OutputLdar(reg);
  }
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::StoreAccumulatorInRegister(
    Register reg) {
  if (register_optimizer_) {
    // Defer source info so that if we elide the bytecode transfer, we attach
    // the source info to a subsequent bytecode if it exists.
    SetDeferredSourceInfo(CurrentSourcePosition(Bytecode::kStar));
    register_optimizer_->DoStar(reg);
  } else {
    OutputStarRaw(reg);
  }
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::MoveRegister(Register from,
                                                         Register to) {
  DCHECK(from != to);
  if (register_optimizer_) {
    // Defer source info so that if we elide the bytecode transfer, we attach
    // the source info to a subsequent bytecode if it exists.
    SetDeferredSourceInfo(CurrentSourcePosition(Bytecode::kMov));
    register_optimizer_->DoMov(from, to);
  } else {
    OutputMov(from, to);
  }
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::LoadGlobal(const AstRawString* name,
                                                       int feedback_slot,
                                                       TypeofMode typeof_mode) {
  size_t name_index = GetConstantPoolEntry(name);
  // Ensure that typeof mode is in sync with the IC slot kind.
  DCHECK_EQ(GetTypeofModeFromSlotKind(feedback_vector_spec()->GetKind(
                FeedbackVector::ToSlot(feedback_slot))),
            typeof_mode);
  switch (typeof_mode) {
    case TypeofMode::kInside:
      OutputLdaGlobalInsideTypeof(name_index, feedback_slot);
      break;
    case TypeofMode::kNotInside:
      OutputLdaGlobal(name_index, feedback_slot);
      break;
  }
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::StoreGlobal(
    const AstRawString* name, int feedback_slot) {
  size_t name_index = GetConstantPoolEntry(name);
  OutputStaGlobal(name_index, feedback_slot);
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::LoadContextSlot(
    Register context, Variable* variable, int depth,
    ContextSlotMutability mutability) {
  int slot_index = variable->index();
  if (mutability == kImmutableSlot) {
    if (context.is_current_context() && depth == 0) {
      OutputLdaImmutableCurrentContextSlot(slot_index);
    } else {
      OutputLdaImmutableContextSlot(context, slot_index, depth);
    }
  } else {
    DCHECK_EQ(kMutableSlot, mutability);
    if (v8_flags.script_context_mutable_heap_number &&
        variable->scope()->is_script_scope()) {
      if (context.is_current_context() && depth == 0) {
        OutputLdaCurrentScriptContextSlot(slot_index);
      } else {
        OutputLdaScriptContextSlot(context, slot_index, depth);
      }
    } else {
      if (context.is_current_context() && depth == 0) {
        OutputLdaCurrentContextSlot(slot_index);
      } else {
        OutputLdaContextSlot(context, slot_index, depth);
      }
    }
  }
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::StoreContextSlot(Register context,
                                                             Variable* variable,
                                                             int depth) {
  int slot_index = variable->index();
  if ((v8_flags.script_context_mutable_heap_number ||
       (v8_flags.const_tracking_let &&
        variable->mode() == VariableMode::kLet)) &&
      variable->scope()->is_script_scope()) {
    if (context.is_current_context() && depth == 0) {
      OutputStaCurrentScriptContextSlot(slot_index);
    } else {
      OutputStaScriptContextSlot(context, slot_index, depth);
    }
  } else {
    if (context.is_current_context() && depth == 0) {
      OutputStaCurrentContextSlot(slot_index);
    } else {
      OutputStaContextSlot(context, slot_index, depth);
    }
  }
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::LoadLookupSlot(
    const AstRawString* name, TypeofMode typeof_mode) {
  size_t name_index = GetConstantPoolEntry(name);
  switch (typeof_mode) {
    case TypeofMode::kInside:
      OutputLdaLookupSlotInsideTypeof(name_index);
      break;
    case TypeofMode::kNotInside:
      OutputLdaLookupSlot(name_index);
      break;
  }
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::LoadLookupContextSlot(
    const AstRawString* name, TypeofMode typeof_mode, ContextKind context_kind,
    int slot_index, int depth) {
  size_t name_index = GetConstantPoolEntry(name);
  switch (typeof_mode) {
    case TypeofMode::kInside:
      if (v8_flags.script_context_mutable_heap_number &&
          context_kind == ContextKind::kScriptContext) {
        OutputLdaLookupScriptContextSlotInsideTypeof(name_index, slot_index,
                                                     depth);
      } else {
        OutputLdaLookupContextSlotInsideTypeof(name_index, slot_index, depth);
      }
      break;
    case TypeofMode::kNotInside:
      if (v8_flags.script_context_mutable_heap_number &&
          context_kind == ContextKind::kScriptContext) {
        OutputLdaLookupScriptContextSlot(name_index, slot_index, depth);
      } else {
        OutputLdaLookupContextSlot(name_index, slot_index, depth);
      }
      break;
  }
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::LoadLookupGlobalSlot(
    const AstRawString* name, TypeofMode typeof_mode, int feedback_slot,
    int depth) {
  size_t name_index = GetConstantPoolEntry(name);
  switch (typeof_mode) {
    case TypeofMode::kInside:
      OutputLdaLookupGlobalSlotInsideTypeof(name_index, feedback_slot, depth);
      break;
    case TypeofMode::kNotInside:
      OutputLdaLookupGlobalSlot(name_index, feedback_slot, depth);
      break;
  }
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::StoreLookupSlot(
    const AstRawString* name, LanguageMode language_mode,
    LookupHoistingMode lookup_hoisting_mode) {
  size_t name_index = GetConstantPoolEntry(name);
  uint8_t flags =
      StoreLookupSlotFlags::Encode(language_mode, lookup_hoisting_mode);
  OutputStaLookupSlot(name_index, flags);
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::LoadNamedProperty(
    Register object, const AstRawString* name, int feedback_slot) {
  size_t name_index = GetConstantPoolEntry(name);
  OutputGetNamedProperty(object, name_index, feedback_slot);
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::LoadNamedPropertyFromSuper(
    Register object, const AstRawString* name, int feedback_slot) {
  size_t name_index = GetConstantPoolEntry(name);
  OutputGetNamedPropertyFromSuper(object, name_index, feedback_slot);
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::LoadKeyedProperty(
    Register object, int feedback_slot) {
  OutputGetKeyedProperty(object, feedback_slot);
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::LoadEnumeratedKeyedProperty(
    Register object, Register enum_index, Register cache_type,
    int feedback_slot) {
  OutputGetEnumeratedKeyedProperty(object, enum_index, cache_type,
                                   feedback_slot);
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::LoadIteratorProperty(
    Register object, int feedback_slot) {
  size_t name_index = IteratorSymbolConstantPoolEntry();
  OutputGetNamedProperty(object, name_index, feedback_slot);
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::GetIterator(
    Register object, int load_feedback_slot, int call_feedback_slot) {
  OutputGetIterator(object, load_feedback_slot, call_feedback_slot);
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::LoadAsyncIteratorProperty(
    Register object, int feedback_slot) {
  size_t name_index = AsyncIteratorSymbolConstantPoolEntry();
  OutputGetNamedProperty(object, name_index, feedback_slot);
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::DefineKeyedOwnPropertyInLiteral(
    Register object, Register name, DefineKeyedOwnPropertyInLiteralFlags flags,
    int feedback_slot) {
  OutputDefineKeyedOwnPropertyInLiteral(object, name, flags, feedback_slot);
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::SetNamedProperty(
    Register object, size_t name_index, int feedback_slot,
    LanguageMode language_mode) {
  // Ensure that language mode is in sync with the IC slot kind.
  DCHECK_EQ(GetLanguageModeFromSlotKind(feedback_vector_spec()->GetKind(
                FeedbackVector::ToSlot(feedback_slot))),
            language_mode);
  OutputSetNamedProperty(object, name_index, feedback_slot);
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::SetNamedProperty(
    Register object, const AstRawString* name, int feedback_slot,
    LanguageMode language_mode) {
  size_t name_index = GetConstantPoolEntry(name);
  return SetNamedProperty(object, name_index, feedback_slot, language_mode);
}

BytecodeArrayBuilder& BytecodeArrayBuilder::DefineNamedOwnProperty(
    Register object, const AstRawString* name, int feedback_slot) {
  size_t name_index = GetConstantPoolEntry(name);
  // Ensure that the store operation is in sync with the IC slot kind.
  DCHECK_EQ(
      FeedbackSlotKind::kDefineNamedOwn,
      feedback_vector_spec()->GetKind(FeedbackVector::ToSlot(feedback_slot)));
  OutputDefineNamedOwnProperty(object, name_index, feedback_slot);
  return *this;
}

BytecodeArrayBuilder& BytecodeArrayBuilder::SetKeyedProperty(
    Register object, Register key, int feedback_slot,
    LanguageMode language_mode) {
  // Ensure that language mode is in sync with the IC slot kind.
  DCHECK_EQ(GetLanguageModeFromSlotKind(feedback_vector_spec()->GetKind(
                FeedbackVector::ToSlot(feedback_slot))),
```
Response: Let's break down the thought process for analyzing this C++ code and explaining its functionality in the context of JavaScript.

1. **Understand the Goal:** The request asks for a summary of the C++ code's purpose and how it relates to JavaScript, including a JavaScript example. This means I need to figure out *what* the code does and *why* that's important for JavaScript execution.

2. **Initial Skim for Keywords and Data Structures:** I'll quickly scan the code for recognizable terms and structures. Keywords like `ConstantArrayBuilder`, `ConstantArraySlice`, `Entry`, `Smi`, `HeapNumber`, `String`, `BigInt`, `Scope`, `Handle`, `FixedArray`, `Zone`, `Map`, and methods like `Insert`, `Allocate`, `ToFixedArray`, `SetDeferredAt` immediately stand out. These hint at the code's role in managing constants.

3. **Focus on the Core Class: `ConstantArrayBuilder`:**  The name itself is very descriptive. It suggests a class responsible for building an array of constants. The presence of `ConstantArraySlice` suggests a strategy for managing this array in segments.

4. **Analyze `ConstantArraySlice`:** This inner class seems to represent a portion of the constant array. Key methods are `Reserve`, `Unreserve`, `Allocate`, and `At`. This points to a mechanism for pre-allocating space for constants and then filling those slots. The `operand_size_` member suggests optimizations based on the size of the constant value. The `CheckAllElementsAreUnique` function indicates a concern for avoiding redundancy within a slice (important for bytecode efficiency).

5. **Analyze `ConstantArrayBuilder`'s Main Functions:**
    * **`Insert(...)` methods:**  These overloaded functions are the primary way to add constants. The different overloads for `Smi`, `double`, `AstRawString`, `AstConsString`, `AstBigInt`, and `Scope` tell me the builder handles various JavaScript constant types. The use of maps (`constants_map_`, `smi_map_`, `heap_number_map_`) suggests a strategy for deduplication – avoiding storing the same constant multiple times.
    * **`AllocateIndex(...)` and `AllocateIndexArray(...)`:** These methods are responsible for actually placing the constants into the `ConstantArraySlice` objects. The logic likely involves choosing the appropriate slice based on available space and operand size.
    * **`ToFixedArray(...)`:** This is crucial. It signifies the finalization step where the collected constants are packaged into a `FixedArray`. `FixedArray` is a fundamental V8 data structure, so this strongly suggests the output of this builder is used elsewhere in the V8 engine.
    * **`SetDeferredAt(...)` and `SetJumpTableSmi(...)`:** These indicate handling of constants that might not be immediately available or need special treatment (like jump tables for control flow).
    * **`CreateReservedEntry(...)`, `CommitReservedEntry(...)`, `DiscardReservedEntry(...)`:** This set of functions suggests a mechanism for reserving space for a constant before its value is fully known. This is likely an optimization.

6. **Infer the Relationship to JavaScript:** Given the types of constants being handled (Smis, numbers, strings, BigInts, scopes) and the output being a `FixedArray`, it's highly likely this `ConstantArrayBuilder` is used during the compilation or interpretation of JavaScript code. Specifically, it seems to be involved in creating a pool of constant values that the generated bytecode can reference. This avoids embedding the full constant value directly in the bytecode, making it more compact and efficient.

7. **Formulate the Explanation of Functionality:**  Based on the above analysis, I can now summarize the purpose:  The `ConstantArrayBuilder` efficiently manages and stores constant values encountered during the compilation or interpretation of JavaScript code. It deduplicates constants, organizes them into slices for memory efficiency, and finally packages them into a `FixedArray` that can be accessed by the V8 engine.

8. **Construct the JavaScript Example:** To illustrate the connection, I need to show a JavaScript scenario where constant values are used and how the `ConstantArrayBuilder` would be relevant. A simple example with different constant types (number, string, boolean) within a function is ideal. I can then explain that V8 would use the `ConstantArrayBuilder` to create a constant pool for this function.

9. **Refine and Organize:**  Review the summary and the JavaScript example for clarity and accuracy. Ensure the language is accessible and explains the "why" behind the C++ code's existence in the context of JavaScript performance and efficiency. Emphasize the benefits of using a constant pool (reduced bytecode size, improved performance).

**Self-Correction/Refinement during the Process:**

* **Initial thought:** Maybe this is just for literals in the source code.
* **Correction:** The inclusion of `Scope` suggests it's not just about *literal* constants but also things like closure scopes, which are constant for a given function.
* **Initial thought:** The slices are just for memory management.
* **Refinement:** The `operand_size_` and the different slice capacities (8-bit, 16-bit, 32-bit) strongly suggest optimization based on the size of the constant's representation in bytecode. This makes bytecode smaller and potentially faster to process.
* **Initial thought:** The `Deferred` entries are for errors.
* **Refinement:** The `SetDeferredAt` suggests it's for constants whose values aren't immediately available during the initial parsing or compilation phase.

By following this iterative process of observation, analysis, inference, and refinement, I can arrive at a comprehensive and accurate explanation of the C++ code's function and its relevance to JavaScript.
这个C++源代码文件 `constant-array-builder.cc` 的功能是**构建一个存储常量值的数组**，这个数组将被V8引擎用于执行JavaScript代码。

**详细功能归纳:**

1. **高效存储常量:** 该类旨在高效地存储各种类型的常量，包括：
    * 小整数 (Smi)
    * 堆上的数字 (HeapNumber)
    * 原始字符串 (RawString)
    * 组合字符串 (ConsString)
    * 大整数 (BigInt)
    * 作用域 (Scope)
    * 特殊的单例值 (如 `undefined`, `null`, `true`, `false`)
    * 用于跳转表的Smi值

2. **常量去重:** 为了节省内存，`ConstantArrayBuilder` 内部维护了多个映射表 (`constants_map_`, `smi_map_`, `heap_number_map_`) 来跟踪已经添加的常量。当尝试插入一个已存在的常量时，它会返回已存在常量的索引，而不是重复存储。

3. **分片管理 (Slicing):** 为了优化存储空间和访问效率，常量被组织成多个 "切片" (`ConstantArraySlice`)。不同的切片可以有不同的容量和操作数大小 (`OperandSize`)。这允许V8根据常量的索引大小选择更紧凑的表示形式，例如，小索引可以使用更小的操作数大小。

4. **预留空间 (Reservation):**  该类支持预留常量槽位。这在某些场景下很有用，例如，当知道需要一个常量，但其具体值尚未确定时。

5. **延迟设置 (Deferred Setting):**  允许先插入一个占位符 (Deferred)，然后在稍后的阶段设置其实际值。

6. **生成 `FixedArray`:** 最终，`ConstantArrayBuilder` 可以将所有收集到的常量打包成一个 `TrustedFixedArray` 对象。这个 `FixedArray` 是V8内部表示数组的一种形式，可以被字节码解释器高效地访问。

**与 JavaScript 功能的关系及 JavaScript 示例:**

`ConstantArrayBuilder` 在 V8 引擎编译和执行 JavaScript 代码的过程中扮演着重要的角色。当 V8 解析 JavaScript 代码并生成字节码时，它会识别出代码中使用的各种常量值。`ConstantArrayBuilder` 就负责收集和管理这些常量，并将它们存储在一个可以被字节码指令引用的常量池中。

**JavaScript 示例:**

```javascript
function greet(name) {
  const greeting = "Hello, "; // 字符串常量
  const message = greeting + name + "!"; // 字符串拼接
  const year = 2023; // 数字常量
  const isGreeting = true; // 布尔常量
  console.log(message, year, isGreeting);
}

greet("World");
```

**在上述 JavaScript 代码中，以下是会被 `ConstantArrayBuilder` 处理的常量：**

* `"Hello, "` (字符串)
* `"!"` (字符串)
* `2023` (数字)
* `true` (布尔值，V8内部会用特定的单例对象表示)

**V8 的处理流程（简化）：**

1. **解析 (Parsing):** V8 的解析器会分析 `greet` 函数的代码。
2. **生成字节码 (Bytecode Generation):** 编译器会生成执行 `greet` 函数的字节码。在生成字节码的过程中，会遇到字符串常量 `"Hello, "`、`"!"`，数字常量 `2023` 和布尔常量 `true`。
3. **`ConstantArrayBuilder` 的作用:**
   * V8 会使用 `ConstantArrayBuilder` 来存储这些常量。
   * `"Hello, "` 和 `"!"` 这样的字符串会被添加到常量数组中，如果已经存在相同的字符串，则会复用。
   * 数字 `2023` 也会被添加到常量数组中。
   * 布尔值 `true` 通常会使用 V8 内部预定义的单例对象，`ConstantArrayBuilder` 也会处理这些单例。
4. **字节码引用常量:** 生成的字节码指令不会直接包含常量的完整值，而是包含指向常量数组中对应索引的引用。例如，当需要加载字符串 `"Hello, "` 时，字节码指令会指示从常量数组的某个特定索引处获取。
5. **执行 (Execution):** 当 V8 执行字节码时，它会根据指令中的索引从常量数组中取出相应的常量值进行操作。

**总结:**

`ConstantArrayBuilder` 是 V8 引擎中一个关键的组件，它负责高效地管理 JavaScript 代码中使用的常量。通过去重存储和分片管理，它优化了内存使用，并通过字节码引用常量的方式提高了代码的执行效率。这使得 V8 能够更快速、更有效地执行 JavaScript 代码。

### 提示词
```
这是目录为v8/src/interpreter/constant-array-builder.cc的一个c++源代码文件， 请归纳一下它的功能, 如果它与javascript的功能有关系，请用javascript举例说明
```

### 源代码
```
// Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/interpreter/constant-array-builder.h"

#include <cmath>
#include <functional>
#include <set>

#include "src/ast/ast-value-factory.h"
#include "src/ast/scopes.h"
#include "src/base/functional.h"
#include "src/execution/isolate.h"
#include "src/handles/handles.h"
#include "src/heap/local-factory-inl.h"
#include "src/interpreter/bytecode-operands.h"
#include "src/objects/objects-inl.h"

namespace v8 {
namespace internal {
namespace interpreter {

ConstantArrayBuilder::ConstantArraySlice::ConstantArraySlice(
    Zone* zone, size_t start_index, size_t capacity, OperandSize operand_size)
    : start_index_(start_index),
      capacity_(capacity),
      reserved_(0),
      operand_size_(operand_size),
      constants_(zone) {}

void ConstantArrayBuilder::ConstantArraySlice::Reserve() {
  DCHECK_GT(available(), 0u);
  reserved_++;
  DCHECK_LE(reserved_, capacity() - constants_.size());
}

void ConstantArrayBuilder::ConstantArraySlice::Unreserve() {
  DCHECK_GT(reserved_, 0u);
  reserved_--;
}

size_t ConstantArrayBuilder::ConstantArraySlice::Allocate(
    ConstantArrayBuilder::Entry entry, size_t count) {
  DCHECK_GE(available(), count);
  size_t index = constants_.size();
  DCHECK_LT(index, capacity());
  for (size_t i = 0; i < count; ++i) {
    constants_.push_back(entry);
  }
  return index + start_index();
}

ConstantArrayBuilder::Entry& ConstantArrayBuilder::ConstantArraySlice::At(
    size_t index) {
  DCHECK_GE(index, start_index());
  DCHECK_LT(index, start_index() + size());
  return constants_[index - start_index()];
}

const ConstantArrayBuilder::Entry& ConstantArrayBuilder::ConstantArraySlice::At(
    size_t index) const {
  DCHECK_GE(index, start_index());
  DCHECK_LT(index, start_index() + size());
  return constants_[index - start_index()];
}

#if DEBUG
template <typename IsolateT>
void ConstantArrayBuilder::ConstantArraySlice::CheckAllElementsAreUnique(
    IsolateT* isolate) const {
  std::set<Tagged<Smi>> smis;
  std::set<double> heap_numbers;
  std::set<const AstRawString*> strings;
  std::set<const AstConsString*> cons_strings;
  std::set<const char*> bigints;
  std::set<const Scope*> scopes;
  std::set<Tagged<Object>, Object::Comparer> deferred_objects;
  for (const Entry& entry : constants_) {
    bool duplicate = false;
    switch (entry.tag_) {
      case Entry::Tag::kSmi:
        duplicate = !smis.insert(entry.smi_).second;
        break;
      case Entry::Tag::kHeapNumber:
        duplicate = !heap_numbers.insert(entry.heap_number_).second;
        break;
      case Entry::Tag::kRawString:
        duplicate = !strings.insert(entry.raw_string_).second;
        break;
      case Entry::Tag::kConsString:
        duplicate = !cons_strings.insert(entry.cons_string_).second;
        break;
      case Entry::Tag::kBigInt:
        duplicate = !bigints.insert(entry.bigint_.c_str()).second;
        break;
      case Entry::Tag::kScope:
        duplicate = !scopes.insert(entry.scope_).second;
        break;
      case Entry::Tag::kHandle:
        duplicate = !deferred_objects.insert(*entry.handle_).second;
        break;
      case Entry::Tag::kDeferred:
        UNREACHABLE();  // Should be kHandle at this point.
      case Entry::Tag::kJumpTableSmi:
      case Entry::Tag::kUninitializedJumpTableSmi:
        // TODO(leszeks): Ignore jump tables because they have to be contiguous,
        // so they can contain duplicates.
        break;
#define CASE_TAG(NAME, ...) case Entry::Tag::k##NAME:
        SINGLETON_CONSTANT_ENTRY_TYPES(CASE_TAG)
#undef CASE_TAG
        // Singletons are non-duplicated by definition.
        break;
    }
    if (duplicate) {
      std::ostringstream os;
      os << "Duplicate constant found: " << Brief(*entry.ToHandle(isolate))
         << std::endl;
      // Print all the entries in the slice to help debug duplicates.
      size_t i = start_index();
      for (const Entry& prev_entry : constants_) {
        os << i++ << ": " << Brief(*prev_entry.ToHandle(isolate)) << std::endl;
      }
      FATAL("%s", os.str().c_str());
    }
  }
}
#endif

STATIC_CONST_MEMBER_DEFINITION const size_t ConstantArrayBuilder::k8BitCapacity;
STATIC_CONST_MEMBER_DEFINITION const size_t
    ConstantArrayBuilder::k16BitCapacity;
STATIC_CONST_MEMBER_DEFINITION const size_t
    ConstantArrayBuilder::k32BitCapacity;

ConstantArrayBuilder::ConstantArrayBuilder(Zone* zone)
    : constants_map_(16, base::KeyEqualityMatcher<intptr_t>(),
                     ZoneAllocationPolicy(zone)),
      smi_map_(zone),
      smi_pairs_(zone),
      heap_number_map_(zone) {
  idx_slice_[0] =
      zone->New<ConstantArraySlice>(zone, 0, k8BitCapacity, OperandSize::kByte);
  idx_slice_[1] = zone->New<ConstantArraySlice>(
      zone, k8BitCapacity, k16BitCapacity, OperandSize::kShort);
  idx_slice_[2] = zone->New<ConstantArraySlice>(
      zone, k8BitCapacity + k16BitCapacity, k32BitCapacity, OperandSize::kQuad);
}

size_t ConstantArrayBuilder::size() const {
  size_t i = arraysize(idx_slice_);
  while (i > 0) {
    ConstantArraySlice* slice = idx_slice_[--i];
    if (slice->size() > 0) {
      return slice->start_index() + slice->size();
    }
  }
  return idx_slice_[0]->size();
}

ConstantArrayBuilder::ConstantArraySlice* ConstantArrayBuilder::IndexToSlice(
    size_t index) const {
  for (ConstantArraySlice* slice : idx_slice_) {
    if (index <= slice->max_index()) {
      return slice;
    }
  }
  UNREACHABLE();
}

template <typename IsolateT>
MaybeHandle<Object> ConstantArrayBuilder::At(size_t index,
                                             IsolateT* isolate) const {
  const ConstantArraySlice* slice = IndexToSlice(index);
  DCHECK_LT(index, slice->capacity());
  if (index < slice->start_index() + slice->size()) {
    const Entry& entry = slice->At(index);
    if (!entry.IsDeferred()) return entry.ToHandle(isolate);
  }
  return MaybeHandle<Object>();
}

template EXPORT_TEMPLATE_DEFINE(V8_EXPORT_PRIVATE)
    MaybeHandle<Object> ConstantArrayBuilder::At(size_t index,
                                                 Isolate* isolate) const;
template EXPORT_TEMPLATE_DEFINE(V8_EXPORT_PRIVATE)
    MaybeHandle<Object> ConstantArrayBuilder::At(size_t index,
                                                 LocalIsolate* isolate) const;

template <typename IsolateT>
Handle<TrustedFixedArray> ConstantArrayBuilder::ToFixedArray(
    IsolateT* isolate) {
  Handle<TrustedFixedArray> fixed_array =
      isolate->factory()->NewTrustedFixedArray(static_cast<int>(size()));
  MemsetTagged(fixed_array->RawFieldOfFirstElement(),
               *isolate->factory()->the_hole_value(), size());
  int array_index = 0;
  for (const ConstantArraySlice* slice : idx_slice_) {
    DCHECK_EQ(slice->reserved(), 0);
    DCHECK(array_index == 0 ||
           base::bits::IsPowerOfTwo(static_cast<uint32_t>(array_index)));
#if DEBUG
    // Different slices might contain the same element due to reservations, but
    // all elements within a slice should be unique.
    slice->CheckAllElementsAreUnique(isolate);
#endif
    // Copy objects from slice into array.
    for (size_t i = 0; i < slice->size(); ++i) {
      DirectHandle<Object> value =
          slice->At(slice->start_index() + i).ToHandle(isolate);
      fixed_array->set(array_index++, *value);
    }
    // Leave holes where reservations led to unused slots.
    size_t padding = slice->capacity() - slice->size();
    if (static_cast<size_t>(fixed_array->length() - array_index) <= padding) {
      break;
    }
    array_index += padding;
  }
  DCHECK_GE(array_index, fixed_array->length());
  return fixed_array;
}

template EXPORT_TEMPLATE_DEFINE(V8_EXPORT_PRIVATE)
    Handle<TrustedFixedArray> ConstantArrayBuilder::ToFixedArray(
        Isolate* isolate);
template EXPORT_TEMPLATE_DEFINE(V8_EXPORT_PRIVATE)
    Handle<TrustedFixedArray> ConstantArrayBuilder::ToFixedArray(
        LocalIsolate* isolate);

size_t ConstantArrayBuilder::Insert(Tagged<Smi> smi) {
  auto entry = smi_map_.find(smi);
  if (entry == smi_map_.end()) {
    return AllocateReservedEntry(smi);
  }
  return entry->second;
}

size_t ConstantArrayBuilder::Insert(double number) {
  if (std::isnan(number)) return InsertNaN();
  auto entry = heap_number_map_.find(number);
  if (entry == heap_number_map_.end()) {
    index_t index = static_cast<index_t>(AllocateIndex(Entry(number)));
    heap_number_map_[number] = index;
    return index;
  }
  return entry->second;
}

size_t ConstantArrayBuilder::Insert(const AstRawString* raw_string) {
  return constants_map_
      .LookupOrInsert(reinterpret_cast<intptr_t>(raw_string),
                      raw_string->Hash(),
                      [&]() { return AllocateIndex(Entry(raw_string)); })
      ->value;
}

size_t ConstantArrayBuilder::Insert(const AstConsString* cons_string) {
  const AstRawString* last = cons_string->last();
  uint32_t hash = last == nullptr ? 0 : last->Hash();
  return constants_map_
      .LookupOrInsert(reinterpret_cast<intptr_t>(cons_string), hash,
                      [&]() { return AllocateIndex(Entry(cons_string)); })
      ->value;
}

size_t ConstantArrayBuilder::Insert(AstBigInt bigint) {
  return constants_map_
      .LookupOrInsert(reinterpret_cast<intptr_t>(bigint.c_str()),
                      static_cast<uint32_t>(base::hash_value(bigint.c_str())),
                      [&]() { return AllocateIndex(Entry(bigint)); })
      ->value;
}

size_t ConstantArrayBuilder::Insert(const Scope* scope) {
  return constants_map_
      .LookupOrInsert(reinterpret_cast<intptr_t>(scope),
                      static_cast<uint32_t>(base::hash_value(scope)),
                      [&]() { return AllocateIndex(Entry(scope)); })
      ->value;
}

#define INSERT_ENTRY(NAME, LOWER_NAME)              \
  size_t ConstantArrayBuilder::Insert##NAME() {     \
    if (LOWER_NAME##_ < 0) {                        \
      LOWER_NAME##_ = AllocateIndex(Entry::NAME()); \
    }                                               \
    return LOWER_NAME##_;                           \
  }
SINGLETON_CONSTANT_ENTRY_TYPES(INSERT_ENTRY)
#undef INSERT_ENTRY

ConstantArrayBuilder::index_t ConstantArrayBuilder::AllocateIndex(
    ConstantArrayBuilder::Entry entry) {
  return AllocateIndexArray(entry, 1);
}

ConstantArrayBuilder::index_t ConstantArrayBuilder::AllocateIndexArray(
    ConstantArrayBuilder::Entry entry, size_t count) {
  for (size_t i = 0; i < arraysize(idx_slice_); ++i) {
    if (idx_slice_[i]->available() >= count) {
      return static_cast<index_t>(idx_slice_[i]->Allocate(entry, count));
    }
  }
  UNREACHABLE();
}

ConstantArrayBuilder::ConstantArraySlice*
ConstantArrayBuilder::OperandSizeToSlice(OperandSize operand_size) const {
  ConstantArraySlice* slice = nullptr;
  switch (operand_size) {
    case OperandSize::kNone:
      UNREACHABLE();
    case OperandSize::kByte:
      slice = idx_slice_[0];
      break;
    case OperandSize::kShort:
      slice = idx_slice_[1];
      break;
    case OperandSize::kQuad:
      slice = idx_slice_[2];
      break;
  }
  DCHECK(slice->operand_size() == operand_size);
  return slice;
}

size_t ConstantArrayBuilder::InsertDeferred() {
  return AllocateIndex(Entry::Deferred());
}

size_t ConstantArrayBuilder::InsertJumpTable(size_t size) {
  return AllocateIndexArray(Entry::UninitializedJumpTableSmi(), size);
}

void ConstantArrayBuilder::SetDeferredAt(size_t index, Handle<Object> object) {
  ConstantArraySlice* slice = IndexToSlice(index);
  return slice->At(index).SetDeferred(object);
}

void ConstantArrayBuilder::SetJumpTableSmi(size_t index, Tagged<Smi> smi) {
  ConstantArraySlice* slice = IndexToSlice(index);
  // Allow others to reuse these Smis, but insert using emplace to avoid
  // overwriting existing values in the Smi map (which may have a smaller
  // operand size).
  smi_map_.emplace(smi, static_cast<index_t>(index));
  return slice->At(index).SetJumpTableSmi(smi);
}

OperandSize ConstantArrayBuilder::CreateReservedEntry(
    OperandSize minimum_operand_size) {
  for (size_t i = 0; i < arraysize(idx_slice_); ++i) {
    if (idx_slice_[i]->available() > 0 &&
        idx_slice_[i]->operand_size() >= minimum_operand_size) {
      idx_slice_[i]->Reserve();
      return idx_slice_[i]->operand_size();
    }
  }
  UNREACHABLE();
}

ConstantArrayBuilder::index_t ConstantArrayBuilder::AllocateReservedEntry(
    Tagged<Smi> value) {
  index_t index = static_cast<index_t>(AllocateIndex(Entry(value)));
  smi_map_[value] = index;
  return index;
}

size_t ConstantArrayBuilder::CommitReservedEntry(OperandSize operand_size,
                                                 Tagged<Smi> value) {
  DiscardReservedEntry(operand_size);
  size_t index;
  auto entry = smi_map_.find(value);
  if (entry == smi_map_.end()) {
    index = AllocateReservedEntry(value);
  } else {
    ConstantArraySlice* slice = OperandSizeToSlice(operand_size);
    index = entry->second;
    if (index > slice->max_index()) {
      // The object is already in the constant array, but may have an
      // index too big for the reserved operand_size. So, duplicate
      // entry with the smaller operand size.
      index = AllocateReservedEntry(value);
    }
    DCHECK_LE(index, slice->max_index());
  }
  return index;
}

void ConstantArrayBuilder::DiscardReservedEntry(OperandSize operand_size) {
  OperandSizeToSlice(operand_size)->Unreserve();
}

template <typename IsolateT>
Handle<Object> ConstantArrayBuilder::Entry::ToHandle(IsolateT* isolate) const {
  switch (tag_) {
    case Tag::kDeferred:
      // We shouldn't have any deferred entries by now.
      UNREACHABLE();
    case Tag::kHandle:
      return handle_;
    case Tag::kSmi:
    case Tag::kJumpTableSmi:
      return handle(smi_, isolate);
    case Tag::kUninitializedJumpTableSmi:
      // TODO(leszeks): There's probably a better value we could use here.
      return isolate->factory()->the_hole_value();
    case Tag::kRawString:
      return raw_string_->string();
    case Tag::kConsString:
      return cons_string_->AllocateFlat(isolate);
    case Tag::kHeapNumber:
      return isolate->factory()->template NewNumber<AllocationType::kOld>(
          heap_number_);
    case Tag::kBigInt:
      // This should never fail: the parser will never create a BigInt
      // literal that cannot be allocated.
      return BigIntLiteral(isolate, bigint_.c_str()).ToHandleChecked();
    case Tag::kScope:
      return scope_->scope_info();
#define ENTRY_LOOKUP(Name, name) \
  case Tag::k##Name:             \
    return isolate->factory()->name();
      SINGLETON_CONSTANT_ENTRY_TYPES(ENTRY_LOOKUP);
#undef ENTRY_LOOKUP
  }
  UNREACHABLE();
}

template Handle<Object> ConstantArrayBuilder::Entry::ToHandle(
    Isolate* isolate) const;
template Handle<Object> ConstantArrayBuilder::Entry::ToHandle(
    LocalIsolate* isolate) const;

}  // namespace interpreter
}  // namespace internal
}  // namespace v8
```
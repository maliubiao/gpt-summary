Response: Let's break down the thought process for analyzing the C++ code and relating it to JavaScript.

**1. Understanding the Goal:**

The request asks for two main things:

* **Summarize the functionality of `c-linkage.cc`:**  What does this code *do* within the larger V8 project?
* **Explain its relation to JavaScript with examples:** How does this low-level C++ code connect to the high-level JavaScript language?

**2. Initial Code Scan and Keyword Spotting:**

The first step is to quickly scan the code for significant keywords and patterns. Things that jump out:

* **`// Copyright ... V8 project`**:  Indicates this is part of the V8 JavaScript engine.
* **`#include` directives:** Shows dependencies on other V8 components like `codegen`, `compiler`, and `zone`. This hints at its role in the compilation process.
* **`namespace v8 { namespace internal { namespace compiler {`**:  Confirms its location within V8's compiler.
* **`#if V8_TARGET_ARCH_*` blocks:**  A large portion of the code is conditional compilation based on the target CPU architecture (IA32, X64, ARM, etc.). This suggests it deals with architecture-specific details.
* **Macros like `CALLEE_SAVE_REGISTERS`, `PARAM_REGISTERS`, `FP_PARAM_REGISTERS`:** These look like they're defining sets of registers. The names suggest they relate to function calls and parameters.
* **`CallDescriptor`**: This class name appears, hinting at the code's role in describing how function calls should be made.
* **`LinkageLocation`**: Another class name related to locations of data, likely in registers or on the stack.
* **`MachineSignature`**: This likely describes the input and output types of a function.
* **`BuildParameterLocations` function:** The name is self-explanatory – it figures out where function parameters should be placed.
* **`GetSimplifiedCDescriptor` function:**  This function seems to be the main entry point, creating a `CallDescriptor` for C function calls.

**3. Forming a Hypothesis about Functionality:**

Based on the initial scan, a reasonable hypothesis is:

*This code is responsible for defining how V8 calls functions written in C/C++. It handles the details of passing arguments and receiving return values, taking into account the specific calling conventions of different CPU architectures.*

**4. Deep Dive into Key Sections:**

Now, let's examine the most crucial parts more carefully:

* **Architecture-Specific Macros:**  The `#if` blocks and the register-related macros are clearly about different calling conventions. Each architecture has its own rules about which registers are used for parameters, return values, and which registers the called function must preserve (callee-saved).

* **`BuildParameterLocations`:**  This function is the core of argument passing. It iterates through the parameters of a function and determines whether each parameter should be passed in a register or on the stack. The different versions of this function for different architectures highlight the variations in how general-purpose and floating-point arguments are handled.

* **`GetSimplifiedCDescriptor`:**  This function pulls everything together. It uses the `MachineSignature` to understand the function's input and output types. It then calls `BuildParameterLocations` to figure out argument placement. Finally, it creates a `CallDescriptor`, which encapsulates all the information needed to make the C call.

**5. Connecting to JavaScript:**

This is the crucial step. How does this C++ code affect JavaScript?

* **Native Extensions/Addons:**  JavaScript can call C/C++ code through native extensions (like Node.js addons). This is a direct use case where `c-linkage.cc` is involved. The `CallDescriptor` generated by this code defines how V8 sets up the call to the C function.

* **Built-in Functions:**  V8 itself has many internal functions written in C++. When JavaScript calls a built-in function (like `Math.sin`), V8 needs to call the underlying C++ implementation. `c-linkage.cc` plays a role in setting up these internal calls as well.

**6. Crafting JavaScript Examples:**

To illustrate the connection, we need simple JavaScript examples that would trigger the use of C/C++ code:

* **Native Addon Example:**  A basic Node.js addon calling a C++ function is a clear demonstration.
* **Built-in Function Example:**  Calling `Math.sqrt` showcases the use of a standard built-in function that relies on underlying C++ (likely the system's math library).

**7. Refining the Explanation:**

Finally, review the explanation for clarity and accuracy. Ensure that the connection between the C++ code and the JavaScript examples is clear. Use terms like "under the hood," "abstraction," and "performance" to explain *why* this low-level code is important for JavaScript. Emphasize that JavaScript developers don't directly interact with this code but benefit from its work.

**Self-Correction/Refinement during the process:**

* **Initial thought:** Maybe this code is directly involved in compiling JavaScript to machine code.
* **Correction:** While related to compilation, the focus here is specifically on *calling* C/C++ functions, not the general JavaScript compilation process. The `CallDescriptor` is key to this.
* **Initial thought:** The register definitions are just constants.
* **Correction:** They are architecture-dependent and crucial for adhering to calling conventions, ensuring correct argument passing and register preservation.
* **Initial thought:** The connection to JavaScript is only through native addons.
* **Correction:**  Built-in JavaScript functions are also a significant use case.

By following this process of initial scanning, hypothesis formation, deep diving, connecting to JavaScript, and refining with examples, we can arrive at a comprehensive and accurate explanation of the `c-linkage.cc` file's functionality and its relationship to JavaScript.
这个C++源代码文件 `v8/src/compiler/c-linkage.cc` 的主要功能是 **定义了 V8 JavaScript 引擎如何调用 C/C++ 函数的接口和约定（linkage）**。 更具体地说，它负责生成描述 C 函数调用方式的 `CallDescriptor` 对象。

以下是它的主要功能点的归纳：

1. **定义了不同架构下的 C 调用约定:**  代码中大量使用了宏 (`#if V8_TARGET_ARCH_*`) 来针对不同的 CPU 架构（如 IA32, X64, ARM, ARM64 等）定义特定的 C 调用约定。这些约定包括：
    * **参数寄存器 (`PARAM_REGISTERS`):**  指定哪些寄存器用于传递函数参数。
    * **浮点参数寄存器 (`FP_PARAM_REGISTERS`):** 指定哪些寄存器用于传递浮点类型的函数参数。
    * **浮点返回值寄存器 (`FP_RETURN_REGISTER`):** 指定哪个寄存器用于返回浮点类型的值。
    * **被调用者保存的寄存器 (`CALLEE_SAVE_REGISTERS`, `CALLEE_SAVE_FP_REGISTERS`):**  指定被调用的 C 函数需要保存并在返回前恢复的寄存器。
    * **栈阴影字 (`STACK_SHADOW_WORDS`):**  某些架构（如 Windows x64）需要在调用 C 函数前在栈上预留一定的空间。

2. **`BuildParameterLocations` 函数:**  这个函数根据目标架构的调用约定和函数的签名（`MachineSignature`），确定函数参数应该放在哪里：寄存器还是栈上。它会填充 `LocationSignature::Builder` 对象，该对象描述了参数的位置。

3. **`GetSimplifiedCDescriptor` 函数:**  这是该文件最核心的函数。它接收一个 `MachineSignature` 对象（描述 C 函数的参数和返回值类型）和一些标志位，然后根据架构特定的定义创建一个 `CallDescriptor` 对象。 `CallDescriptor` 包含了进行 C 函数调用所需的所有信息，例如：
    * 调用类型 (`CallDescriptor::kCallAddress`)
    * 目标地址的位置 (`LinkageLocation::ForAnyRegister`)
    * 参数的位置 (`locations.Get()`)
    * 返回值的位置 (`locations.AddReturn(...)`)
    * 被调用者保存的寄存器
    * 其他调用标志

**与 JavaScript 的关系以及 JavaScript 示例:**

虽然 JavaScript 开发者通常不会直接与 `c-linkage.cc` 中的代码交互，但这个文件对于 JavaScript 引擎执行某些操作至关重要，特别是当 JavaScript 需要调用 C/C++ 代码时。 这主要发生在以下两种情况：

1. **Native Addons (Node.js):**  Node.js 允许开发者编写 C/C++ 扩展 (addons) 来扩展 JavaScript 的功能。 当 JavaScript 代码调用这些 addon 中定义的 C/C++ 函数时，V8 引擎就需要使用这里定义的 C 调用约定。

2. **V8 引擎内部的 C++ 代码:**  V8 引擎本身是用 C++ 编写的，并且内部有许多 C++ 函数实现了 JavaScript 的内置功能或者底层的操作。  当 JavaScript 代码执行到某些需要调用这些内部 C++ 函数的地方时，也会用到这里定义的调用约定。

**JavaScript 示例 (以 Node.js Native Addon 为例):**

假设我们有一个简单的 C++ addon，其中定义了一个名为 `add` 的函数：

```c++
// addon.cc
#include <node.h>

namespace demo {

using v8::FunctionCallbackInfo;
using v8::Isolate;
using v8::Local;
using v8::Number;
using v8::Object;
using v8::Value;

void Add(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();
  double arg0 = args[0]->NumberValue(isolate->GetCurrentContext()).FromJust();
  double arg1 = args[1]->NumberValue(isolate->GetCurrentContext()).FromJust();
  double result = arg0 + arg1;
  args.GetReturnValue().Set(Number::New(isolate, result));
}

void Initialize(Local<Object> exports) {
  NODE_SET_METHOD(exports, "add", Add);
}

NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize);

}  // namespace demo
```

这个 C++ 函数 `Add` 接收两个数字参数并返回它们的和。

在 JavaScript 中，我们可以加载并调用这个 addon：

```javascript
// test.js
const addon = require('./build/Release/addon');

const result = addon.add(5, 3);
console.log(result); // 输出: 8
```

当 JavaScript 代码 `addon.add(5, 3)` 被执行时，V8 引擎需要调用 C++ 的 `Add` 函数。  `c-linkage.cc` 中定义的 `GetSimplifiedCDescriptor` 函数会被用来生成描述如何调用 `Add` 函数的 `CallDescriptor`。 这个 `CallDescriptor` 会指定：

*  参数 `5` 和 `3` 应该放在哪些寄存器或栈上的哪个位置 (根据目标架构的 `PARAM_REGISTERS` 定义)。
*  如果 `Add` 函数返回一个浮点数（虽然这个例子中是 double，会被转换成 JavaScript Number），那么返回值应该从哪个寄存器读取 (根据目标架构的 `FP_RETURN_REGISTER` 定义)。
*  哪些寄存器需要在调用前后保持不变 (根据目标架构的 `CALLEE_SAVE_REGISTERS` 定义)。

**总结:**

`v8/src/compiler/c-linkage.cc` 是 V8 引擎中一个非常底层的组件，它定义了 JavaScript 引擎如何与 C/C++ 代码交互的规则。 它通过生成 `CallDescriptor` 对象，确保在 JavaScript 调用 C/C++ 函数时，参数能够正确地传递，返回值能够正确地接收，并且寄存器的使用符合目标架构的调用约定。 这对于实现 Node.js 的 native addons 和 V8 引擎自身的内部功能至关重要。

### 提示词
```
这是目录为v8/src/compiler/c-linkage.cc的一个c++源代码文件， 请归纳一下它的功能, 如果它与javascript的功能有关系，请用javascript举例说明
```

### 源代码
```
// Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/codegen/assembler-inl.h"
#include "src/codegen/macro-assembler.h"
#include "src/compiler/globals.h"
#include "src/compiler/linkage.h"
#include "src/zone/zone.h"

namespace v8 {
namespace internal {
namespace compiler {

namespace {

// Platform-specific configuration for C calling convention.
#if V8_TARGET_ARCH_IA32
// ===========================================================================
// == ia32 ===================================================================
// ===========================================================================
#define CALLEE_SAVE_REGISTERS esi, edi, ebx
#define CALLEE_SAVE_FP_REGISTERS

#elif V8_TARGET_ARCH_X64
// ===========================================================================
// == x64 ====================================================================
// ===========================================================================

#ifdef V8_TARGET_OS_WIN
// == x64 windows ============================================================
#define STACK_SHADOW_WORDS 4
#define PARAM_REGISTERS rcx, rdx, r8, r9
#define FP_PARAM_REGISTERS xmm0, xmm1, xmm2, xmm3
#define FP_RETURN_REGISTER xmm0
#define CALLEE_SAVE_REGISTERS rbx, rdi, rsi, r12, r13, r14, r15
#define CALLEE_SAVE_FP_REGISTERS \
  xmm6, xmm7, xmm8, xmm9, xmm10, xmm11, xmm12, xmm13, xmm14, xmm15

#else  // V8_TARGET_OS_WIN
// == x64 other ==============================================================
#define PARAM_REGISTERS rdi, rsi, rdx, rcx, r8, r9
#define FP_PARAM_REGISTERS xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7
#define FP_RETURN_REGISTER xmm0
#define CALLEE_SAVE_REGISTERS rbx, r12, r13, r14, r15
#define CALLEE_SAVE_FP_REGISTERS
#endif  // V8_TARGET_OS_WIN

#elif V8_TARGET_ARCH_ARM
// ===========================================================================
// == arm ====================================================================
// ===========================================================================
#define PARAM_REGISTERS r0, r1, r2, r3
#define CALLEE_SAVE_REGISTERS r4, r5, r6, r7, r8, r9, r10
#define CALLEE_SAVE_FP_REGISTERS d8, d9, d10, d11, d12, d13, d14, d15

#elif V8_TARGET_ARCH_ARM64
// ===========================================================================
// == arm64 ====================================================================
// ===========================================================================
#define PARAM_REGISTERS x0, x1, x2, x3, x4, x5, x6, x7
#define FP_PARAM_REGISTERS d0, d1, d2, d3, d4, d5, d6, d7
#define FP_RETURN_REGISTER d0
#define CALLEE_SAVE_REGISTERS x19, x20, x21, x22, x23, x24, x25, x26, x27, x28

#define CALLEE_SAVE_FP_REGISTERS d8, d9, d10, d11, d12, d13, d14, d15

#elif V8_TARGET_ARCH_MIPS64
// ===========================================================================
// == mips64 =================================================================
// ===========================================================================
#define PARAM_REGISTERS a0, a1, a2, a3, a4, a5, a6, a7
#define FP_PARAM_REGISTERS f12, f13, f14, f15, f16, f17, f18, f19
#define FP_RETURN_REGISTER f0
#define CALLEE_SAVE_REGISTERS s0, s1, s2, s3, s4, s5, s6, s7
#define CALLEE_SAVE_FP_REGISTERS f20, f22, f24, f26, f28, f30

#elif V8_TARGET_ARCH_LOONG64
// ===========================================================================
// == loong64 ================================================================
// ===========================================================================
#define PARAM_REGISTERS a0, a1, a2, a3, a4, a5, a6, a7
#define FP_PARAM_REGISTERS f0, f1, f2, f3, f4, f5, f6, f7
#define FP_RETURN_REGISTER f0
#define CALLEE_SAVE_REGISTERS s0, s1, s2, s3, s4, s5, s6, s7, s8, fp
#define CALLEE_SAVE_FP_REGISTERS f24, f25, f26, f27, f28, f29, f30, f31

#elif V8_TARGET_ARCH_PPC64
// ===========================================================================
// == ppc64 ==================================================================
// ===========================================================================
#ifdef V8_TARGET_LITTLE_ENDIAN  // ppc64le linux
#define STACK_SHADOW_WORDS 12
#else  // AIX
#define STACK_SHADOW_WORDS 14
#endif
#define PARAM_REGISTERS r3, r4, r5, r6, r7, r8, r9, r10
#define CALLEE_SAVE_REGISTERS                                                \
  r14, r15, r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, \
      r29, r30

#define CALLEE_SAVE_FP_REGISTERS                                             \
  d14, d15, d16, d17, d18, d19, d20, d21, d22, d23, d24, d25, d26, d27, d28, \
      d29, d30, d31

#elif V8_TARGET_ARCH_S390X
// ===========================================================================
// == s390x ==================================================================
// ===========================================================================
#define STACK_SHADOW_WORDS 20
#define PARAM_REGISTERS r2, r3, r4, r5, r6
#define CALLEE_SAVE_REGISTERS r6, r7, r8, r9, r10, ip, r13
#define CALLEE_SAVE_FP_REGISTERS d8, d9, d10, d11, d12, d13, d14, d15

#elif V8_TARGET_ARCH_RISCV32 || V8_TARGET_ARCH_RISCV64
// ===========================================================================
// == riscv64 =================================================================
// ===========================================================================
#define PARAM_REGISTERS a0, a1, a2, a3, a4, a5, a6, a7
#define FP_PARAM_REGISTERS fa0, fa1, fa2, fa3, fa4, fa5, fa6, fa7
// fp is not part of CALLEE_SAVE_REGISTERS (similar to how MIPS64 or PPC defines
// it)
#define CALLEE_SAVE_REGISTERS s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11
#define CALLEE_SAVE_FP_REGISTERS \
  fs0, fs1, fs2, fs3, fs4, fs5, fs6, fs7, fs8, fs9, fs10, fs11
#else
// ===========================================================================
// == unknown ================================================================
// ===========================================================================
#define UNSUPPORTED_C_LINKAGE 1
#endif
}  // namespace

#if (defined(V8_TARGET_OS_WIN) && defined(V8_TARGET_ARCH_X64)) || \
    defined(V8_TARGET_ARCH_MIPS64)
// As defined in
// https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2019#parameter-passing,
// Windows calling convention doesn't differentiate between GP and FP params
// when counting how many of them should be placed in registers. That's why
// we use the same counter {i} for both types here.
// MIPS is the same, as defined in
// https://techpubs.jurassic.nl/manuals/0630/developer/Mpro_n32_ABI/sgi_html/ch02.html#id52620.
void BuildParameterLocations(const MachineSignature* msig,
                             size_t kFPParamRegisterCount,
                             size_t kParamRegisterCount,
                             const DoubleRegister* kFPParamRegisters,
                             const v8::internal::Register* kParamRegisters,
                             LocationSignature::Builder* out_locations) {
#ifdef STACK_SHADOW_WORDS
  int stack_offset = STACK_SHADOW_WORDS;
#else
  int stack_offset = 0;
#endif
  CHECK_EQ(kFPParamRegisterCount, kParamRegisterCount);

  for (size_t i = 0; i < msig->parameter_count(); i++) {
    MachineType type = msig->GetParam(i);
    bool spill = (i >= kParamRegisterCount);
    if (spill) {
      out_locations->AddParam(
          LinkageLocation::ForCallerFrameSlot(-1 - stack_offset, type));
      stack_offset++;
    } else {
      if (IsFloatingPoint(type.representation())) {
        out_locations->AddParam(
            LinkageLocation::ForRegister(kFPParamRegisters[i].code(), type));
      } else {
        out_locations->AddParam(
            LinkageLocation::ForRegister(kParamRegisters[i].code(), type));
      }
    }
  }
}
#elif defined(V8_TARGET_ARCH_LOONG64)
// As defined in
// https://loongson.github.io/LoongArch-Documentation/LoongArch-ELF-ABI-EN.html#_procedure_calling_convention
// Loongarch calling convention uses GP to pass floating-point arguments when no
// FP is available.
void BuildParameterLocations(const MachineSignature* msig,
                             size_t kFPParamRegisterCount,
                             size_t kParamRegisterCount,
                             const DoubleRegister* kFPParamRegisters,
                             const v8::internal::Register* kParamRegisters,
                             LocationSignature::Builder* out_locations) {
#ifdef STACK_SHADOW_WORDS
  int stack_offset = STACK_SHADOW_WORDS;
#else
  int stack_offset = 0;
#endif
  size_t num_params = 0;
  size_t num_fp_params = 0;
  for (size_t i = 0; i < msig->parameter_count(); i++) {
    MachineType type = msig->GetParam(i);
    if (IsFloatingPoint(type.representation())) {
      if (num_fp_params < kFPParamRegisterCount) {
        out_locations->AddParam(LinkageLocation::ForRegister(
            kFPParamRegisters[num_fp_params].code(), type));
        ++num_fp_params;
      } else if (num_params < kParamRegisterCount) {
        // ForNullRegister represents a floating-point param that should be put
        // into the GPR, and reg_code is the the negative of encoding of the
        // GPR, and the maximum is -4.
        out_locations->AddParam(LinkageLocation::ForNullRegister(
            -kParamRegisters[num_params].code(), type));
        ++num_params;
      } else {
        out_locations->AddParam(
            LinkageLocation::ForCallerFrameSlot(-1 - stack_offset, type));
        stack_offset++;
      }
    } else {
      if (num_params < kParamRegisterCount) {
        out_locations->AddParam(LinkageLocation::ForRegister(
            kParamRegisters[num_params].code(), type));
        ++num_params;
      } else {
        out_locations->AddParam(
            LinkageLocation::ForCallerFrameSlot(-1 - stack_offset, type));
        stack_offset++;
      }
    }
  }
}
#else
// As defined in https://www.agner.org/optimize/calling_conventions.pdf,
// Section 7, Linux and Mac place parameters in consecutive registers,
// differentiating between GP and FP params. That's why we maintain two
// separate counters here. This also applies to Arm systems following
// the AAPCS and Windows on Arm.
void BuildParameterLocations(const MachineSignature* msig,
                             size_t kFPParamRegisterCount,
                             size_t kParamRegisterCount,
                             const DoubleRegister* kFPParamRegisters,
                             const v8::internal::Register* kParamRegisters,
                             LocationSignature::Builder* out_locations) {
#ifdef STACK_SHADOW_WORDS
  int stack_offset = STACK_SHADOW_WORDS;
#else
  int stack_offset = 0;
#endif
  size_t num_params = 0;
  size_t num_fp_params = 0;
  for (size_t i = 0; i < msig->parameter_count(); i++) {
    MachineType type = msig->GetParam(i);
    bool spill = IsFloatingPoint(type.representation())
                     ? (num_fp_params >= kFPParamRegisterCount)
                     : (num_params >= kParamRegisterCount);
    if (spill) {
      out_locations->AddParam(
          LinkageLocation::ForCallerFrameSlot(-1 - stack_offset, type));
      stack_offset++;
    } else {
      if (IsFloatingPoint(type.representation())) {
        out_locations->AddParam(LinkageLocation::ForRegister(
            kFPParamRegisters[num_fp_params].code(), type));
        ++num_fp_params;
      } else {
        out_locations->AddParam(LinkageLocation::ForRegister(
            kParamRegisters[num_params].code(), type));
        ++num_params;
      }
    }
  }
}
#endif  // (defined(V8_TARGET_OS_WIN) && defined(V8_TARGET_ARCH_X64)) ||
        // defined(V8_TARGET_ARCH_MIPS64)

// General code uses the above configuration data.
CallDescriptor* Linkage::GetSimplifiedCDescriptor(Zone* zone,
                                                  const MachineSignature* msig,
                                                  CallDescriptor::Flags flags) {
#ifdef UNSUPPORTED_C_LINKAGE
  // This method should not be called on unknown architectures.
  FATAL("requested C call descriptor on unsupported architecture");
  return nullptr;
#endif

  DCHECK_LE(msig->parameter_count(), static_cast<size_t>(kMaxCParameters));

  LocationSignature::Builder locations(zone, msig->return_count(),
                                       msig->parameter_count());

#ifndef V8_ENABLE_FP_PARAMS_IN_C_LINKAGE
  // Check the types of the signature.
  for (size_t i = 0; i < msig->parameter_count(); i++) {
    MachineType type = msig->GetParam(i);
    CHECK(!IsFloatingPoint(type.representation()));
  }

  // Check the return types.
  for (size_t i = 0; i < locations.return_count_; i++) {
    MachineType type = msig->GetReturn(i);
    CHECK(!IsFloatingPoint(type.representation()));
  }
#endif

  CHECK_GE(2, locations.return_count_);
  if (locations.return_count_ > 0) {
#ifdef FP_RETURN_REGISTER
    const v8::internal::DoubleRegister kFPReturnRegister = FP_RETURN_REGISTER;
    auto reg = IsFloatingPoint(msig->GetReturn(0).representation())
                   ? kFPReturnRegister.code()
                   : kReturnRegister0.code();
#else
    auto reg = kReturnRegister0.code();
#endif
    // TODO(chromium:1052746): Use the correctly sized register here (e.g. "al"
    // if the return type is kBit), so we don't have to use a hacky bitwise AND
    // elsewhere.
    locations.AddReturn(LinkageLocation::ForRegister(reg, msig->GetReturn(0)));
  }

  if (locations.return_count_ > 1) {
    DCHECK(!IsFloatingPoint(msig->GetReturn(0).representation()));

    locations.AddReturn(LinkageLocation::ForRegister(kReturnRegister1.code(),
                                                     msig->GetReturn(1)));
  }

#ifdef PARAM_REGISTERS
  const v8::internal::Register kParamRegisters[] = {PARAM_REGISTERS};
  const int kParamRegisterCount = static_cast<int>(arraysize(kParamRegisters));
#else
  const v8::internal::Register* kParamRegisters = nullptr;
  const int kParamRegisterCount = 0;
#endif

#ifdef FP_PARAM_REGISTERS
  const DoubleRegister kFPParamRegisters[] = {FP_PARAM_REGISTERS};
  const size_t kFPParamRegisterCount = arraysize(kFPParamRegisters);
#else
  const DoubleRegister* kFPParamRegisters = nullptr;
  const size_t kFPParamRegisterCount = 0;
#endif

  // Add register and/or stack parameter(s).
  BuildParameterLocations(msig, kFPParamRegisterCount, kParamRegisterCount,
                          kFPParamRegisters, kParamRegisters, &locations);

  const RegList kCalleeSaveRegisters = {CALLEE_SAVE_REGISTERS};
  const DoubleRegList kCalleeSaveFPRegisters = {CALLEE_SAVE_FP_REGISTERS};

  // The target for C calls is always an address (i.e. machine pointer).
  MachineType target_type = MachineType::Pointer();
  LinkageLocation target_loc = LinkageLocation::ForAnyRegister(target_type);
  flags |= CallDescriptor::kNoAllocate;

  // TODO(saelo): here we probably want to use a c-call specific tag.
  return zone->New<CallDescriptor>(  // --
      CallDescriptor::kCallAddress,  // kind
      kDefaultCodeEntrypointTag,     // tag
      target_type,                   // target MachineType
      target_loc,                    // target location
      locations.Get(),               // location_sig
      0,                             // stack_parameter_count
      Operator::kNoThrow,            // properties
      kCalleeSaveRegisters,          // callee-saved registers
      kCalleeSaveFPRegisters,        // callee-saved fp regs
      flags, "c-call");
}

}  // namespace compiler
}  // namespace internal
}  // namespace v8
```
Response:
The user wants a summary of the functionality of the provided C++ code snippet from `v8/src/compiler/backend/arm64/instruction-selector-arm64.cc`.

Here's a breakdown of how to approach this:

1. **Identify the file's purpose:** The file name `instruction-selector-arm64.cc` suggests it's responsible for selecting ARM64 instructions during the compilation process in V8. This means it translates higher-level operations into specific ARM64 assembly instructions.

2. **Analyze the code structure:** The code uses a lot of macros (`#define`) to generate similar function definitions for different SIMD operations. This is a common pattern for reducing code duplication.

3. **Examine the core logic:** The functions (generated by macros) generally follow a pattern:
    - They take a `node_t` (likely representing an intermediate representation node in the compiler).
    - They might perform pattern matching to identify specific optimization opportunities (like `TryMatchMulWithDup`).
    - They use an `Arm64OperandGeneratorT` to generate operands for the instructions.
    - They call `Emit` to output the selected ARM64 instruction.

4. **Focus on the SIMD operations:** The code heavily deals with SIMD (Single Instruction, Multiple Data) operations. The macros and function names like `VisitI32x4Add`, `VisitF64x2Mul`, etc., clearly indicate this.

5. **Look for specific optimizations:** The `TryMatchMulWithDup` function is a good example of a targeted optimization where a multiplication by a duplicated lane is recognized and a more efficient instruction is used.

6. **Consider the two adapter types:** The code uses templates with `TurbofanAdapter` and `TurboshaftAdapter`. These likely represent different compilation pipelines or optimization levels within V8.

7. **Address the specific questions:**
    - **Functionality:** Summarize the core task of instruction selection for ARM64, focusing on SIMD.
    - **Torque:** Check the file extension (it's `.cc`, not `.tq`).
    - **JavaScript relation:**  Think about how SIMD operations in JavaScript (like TypedArrays and WebAssembly SIMD) relate to this code.
    - **Code logic/Reasoning:** Use `TryMatchMulWithDup` as an example, providing input and output scenarios.
    - **Common programming errors:** Consider errors related to incorrect SIMD usage or misunderstandings of how these operations work.
    - **归纳功能 (Summarize Functionality):**  Provide a concise overview of the file's role within the V8 compilation process.

8. **Structure the answer:** Organize the information clearly, addressing each of the user's points. Use headings and bullet points for readability.

**(Self-correction during thought process):**  Initially, I might focus too much on the macro definitions. It's more important to understand what those macros *do* – generate instruction selection logic for various SIMD operations. Also, the difference between `TurbofanAdapter` and `TurboshaftAdapter` is worth noting but doesn't need deep explanation unless the user asks for it specifically. The key is to connect the C++ code to the *purpose* of instruction selection within a compiler.
这段C++代码是V8 JavaScript引擎中针对ARM64架构的指令选择器的一部分。它的主要功能是将高级的、平台无关的中间表示（IR）操作转换为特定的ARM64机器指令。由于这是第10部分，共11部分，可以推断这部分代码主要负责处理SIMD（Single Instruction, Multiple Data）相关的操作。

**功能列表:**

1. **SIMD移位操作指令选择:**  代码段的开头定义了一些宏，用于简化SIMD移位操作指令的选择过程。这些宏 (`D_SHIFT_OP_LIST`, `SIMD_VISIT_SHIFT_OP`) 遍历一个预定义的移位操作列表，并为每个操作生成相应的 `Visit` 函数。`Visit` 函数接收一个表示IR节点的参数，并将其转换为相应的ARM64移位指令。

2. **SIMD二元操作指令选择:** 类似地，`SIMD_BINOP_LIST` 和 `SIMD_VISIT_BINOP` 宏用于处理SIMD二元操作（例如加法、乘法）。`VisitRRR` 函数很可能用于生成需要三个寄存器操作数的指令。

3. **SIMD二元操作（带Lane Size）指令选择:** `SIMD_BINOP_LANE_SIZE_LIST` 和 `SIMD_VISIT_BINOP_LANE_SIZE` 宏用于处理需要指定通道大小（Lane Size）的SIMD二元操作。`LaneSizeField::encode(LaneSize)` 用于将通道大小编码到指令中。

4. **SIMD一元操作（带Lane Size）指令选择:**  `SIMD_UNOP_LANE_SIZE_LIST` 和 `SIMD_VISIT_UNOP_LANE_SIZE` 宏用于处理需要指定通道大小的SIMD一元操作。`VisitRR` 函数很可能用于生成需要两个寄存器操作数的指令。

5. **模式匹配优化 (Mul with Dup):**  代码中定义了 `MulWithDupResult` 和 `MulWithDup` 结构体，以及 `TryMatchMulWithDup` 函数。这些用于识别一种特定的优化模式：当一个SIMD向量与另一个通过 `shuffle` 操作复制自身某个通道而来的向量相乘时，可以利用更高效的 `FMulElement` 指令。

6. **特定SIMD乘法操作的指令选择:** `VisitF16x8Mul`, `VisitF32x4Mul`, `VisitF64x2Mul` 等函数针对不同数据类型的SIMD乘法操作进行指令选择。它们首先尝试匹配 `MulWithDup` 模式进行优化，否则选择通用的乘法指令。

7. **I64x2乘法操作的指令选择:** `VisitI64x2Mul` 函数处理64位整数向量的乘法，可能使用了临时寄存器。

8. **模式匹配优化 (Add with Shift Right):** 代码中定义了 `SimdAddOpMatcher` 和 `SimdBinopMatcherTurboshaft` 结构体以及 `ShraHelper` 函数。这些用于识别将SIMD向量与经过移位操作后的自身相加的模式，并尝试使用更高效的移位加法指令（例如 `Ssra`, `Usra`）。

9. **模式匹配优化 (Add with Pairwise Add):** `AdalpHelper` 函数用于识别将SIMD向量与经过成对加法扩展后的自身相加的模式，并使用 `Sadalp` 或 `Uadalp` 指令。

10. **模式匹配优化 (Add with Multiply Accumulate):** `MlaHelper` 函数用于识别形如 `Add(x, Mul(y, z))` 的模式，并使用乘法累加指令 `Mla`。

11. **模式匹配优化 (Add with Extended Multiply):** `SmlalHelper` 函数用于识别形如 `Add(x, ExtMulLow/High(y, z))` 的模式，并使用扩展乘法累加指令（例如 `Smlal`, `Umlal`）。

12. **特定SIMD加法操作的指令选择:** `VisitI64x2Add`, `VisitI8x16Add` 以及通过 `VISIT_SIMD_ADD` 宏生成的函数，针对不同数据类型的SIMD加法操作进行指令选择，并应用上述的模式匹配优化。

13. **特定SIMD减法操作的指令选择:** `VISIT_SIMD_SUB` 宏生成的函数，针对不同数据类型的SIMD减法操作进行指令选择，并尝试匹配 `Sub(z, Mul(x, y))` 模式使用 `Mls` 指令。

14. **SIMD规约操作的指令选择:** `VISIT_SIMD_REDUCE` 宏生成的函数，例如 `VisitI8x16AddReduce`，用于选择SIMD规约操作的指令，例如向量元素的加法求和。

15. **SIMD比较操作的指令选择:** `VISIT_SIMD_CM` 宏生成的函数，例如 `VisitF64x2Eq`，用于选择SIMD比较操作的指令。这些函数还包含对与零比较的优化。

16. **S128Select 指令选择:** `VisitS128Select` 和 `VisitI8x16RelaxedLaneSelect` 函数用于选择根据掩码从两个SIMD寄存器中选择元素的指令。

**关于是否为Torque源代码:**

`v8/src/compiler/backend/arm64/instruction-selector-arm64.cc` 以 `.cc` 结尾，因此它是一个 **C++ 源代码文件**，而不是 Torque (`.tq`) 源代码文件。Torque 用于定义 V8 内部的 built-in 函数和类型系统。

**与JavaScript的功能的关系:**

这段代码直接关系到 V8 如何执行 JavaScript 中使用 SIMD 功能的代码，特别是：

* **Typed Arrays:**  JavaScript 的 `Float32Array`, `Int32Array` 等类型可以被当做 SIMD 数据进行操作。例如，对 `Float32Array` 进行向量加法或乘法操作时，最终会通过这里的指令选择器生成相应的 ARM64 SIMD 指令。

* **WebAssembly SIMD:** WebAssembly 提供了 SIMD 指令集，V8 在执行 WebAssembly 代码时，会使用这段代码将 WebAssembly 的 SIMD 操作映射到 ARM64 的 SIMD 指令。

**JavaScript 示例:**

```javascript
// 使用 Typed Arrays 进行 SIMD 操作的例子
const a = new Float32Array([1, 2, 3, 4]);
const b = new Float32Array([5, 6, 7, 8]);
const c = new Float32Array(4);

for (let i = 0; i < 4; i++) {
  c[i] = a[i] * b[i]; // 这里的乘法操作最终可能被编译成 ARM64 的 SIMD 乘法指令
}

console.log(c); // 输出: Float32Array [ 5, 12, 21, 32 ]

// 使用 WebAssembly SIMD 的例子 (需要 WebAssembly 环境)
// ... (WebAssembly 代码定义了一个 SIMD 乘法操作)
// const result = wasmInstance.exports.simdMultiply(input1, input2);
```

当 V8 编译执行这些 JavaScript 代码时，`v8/src/compiler/backend/arm64/instruction-selector-arm64.cc` 中的代码会被调用，将 JavaScript 或 WebAssembly 的 SIMD 乘法操作转换为如 `FMul` 或 `FMulElement` 这样的 ARM64 指令。

**代码逻辑推理 (Mul with Dup 优化):**

**假设输入:**

* `node`: 代表一个 `F32x4Mul` (32位浮点数 4 通道向量乘法) 的 IR 节点。
* `node` 的左操作数 (input 0) 是一个向量 `x = [a, b, c, d]`.
* `node` 的右操作数 (input 1) 是一个 `shuffle` 操作的节点，该操作复制了 `x` 的第二个通道（索引为 1），例如 `shuffle(x, x, [1, 1, 1, 1])` 结果为 `[b, b, b, b]`.

**输出:**

V8 的指令选择器会识别出 `TryMatchMulWithDup` 模式，并生成 `kArm64FMulElement` 指令，而不是通用的 `kArm64FMul` 指令。生成的指令会执行以下操作：

* 将向量 `x` 存储在一个寄存器中。
* 将 `x` 的第二个元素 `b` 复制到另一个寄存器或作为立即数使用。
* 使用 `FMulElement` 指令将 `x` 的每个通道与 `b` 相乘。

这比先生成 `shuffle` 指令再进行通用的向量乘法更高效。

**用户常见的编程错误 (与SIMD相关):**

1. **数据类型不匹配:**  例如，尝试将整数 SIMD 向量与浮点数 SIMD 向量进行操作，或者使用不兼容的通道大小。V8 的类型检查会尝试捕获这些错误，但在某些情况下可能会导致运行时错误或性能下降。

   ```javascript
   const intVec = new Int32x4(1, 2, 3, 4);
   const floatVec = new Float32x4(1.0, 2.0, 3.0, 4.0);
   // 错误：不能直接将整数向量和浮点数向量相加
   // const result = intVec.add(floatVec);
   ```

2. **不正确的通道操作:**  例如，在使用 `shuffle` 或 lane extraction 操作时，使用了超出范围的索引。

   ```javascript
   const vec = new Float32x4(1, 2, 3, 4);
   // 错误：Float32x4 只有 4 个通道，索引 4 超出范围
   // const swizzled = vec.shuffle(0, 1, 2, 4);
   ```

3. **忽视 SIMD 的对齐要求 (在底层):** 虽然 JavaScript 层面屏蔽了大部分底层的对齐问题，但在编写底层的 C++ 代码或者与 WebAssembly 交互时，如果 SIMD 数据没有正确对齐，可能会导致性能下降甚至崩溃。

4. **过度使用或不当使用 SIMD:**  SIMD 并非所有场景都适用。对于小规模的数据或不适合并行处理的逻辑，使用 SIMD 可能不会带来性能提升，反而会增加代码复杂性。

**归纳功能:**

总而言之，`v8/src/compiler/backend/arm64/instruction-selector-arm64.cc` 的这一部分（第10部分）主要负责 **将 V8 内部的 SIMD 操作表示转换为高效的 ARM64 机器指令**。它包含了针对不同 SIMD 操作（如移位、二元运算、乘法、加法、减法、比较、规约等）的指令选择逻辑，并包含了一些针对特定模式的优化（如 `Mul with Dup` 和 `Add with Shift Right` 等）。这段代码是 V8 支持高性能 JavaScript 和 WebAssembly SIMD 功能的关键组成部分。

### 提示词
```
这是目录为v8/src/compiler/backend/arm64/instruction-selector-arm64.cc的一个v8源代码， 请列举一下它的功能, 
如果v8/src/compiler/backend/arm64/instruction-selector-arm64.cc以.tq结尾，那它是个v8 torque源代码，
如果它与javascript的功能有关系，请用javascript举例说明,
如果有代码逻辑推理，请给出假设输入与输出，
如果涉及用户常见的编程错误，请举例说明
这是第10部分，共11部分，请归纳一下它的功能
```

### 源代码
```cpp
D_SHIFT_OP_LIST(SIMD_VISIT_SHIFT_OP)
#undef SIMD_VISIT_SHIFT_OP
#undef SIMD_SHIFT_OP_LIST

#define SIMD_VISIT_BINOP(Name, instruction)                      \
  template <typename Adapter>                                    \
  void InstructionSelectorT<Adapter>::Visit##Name(node_t node) { \
    VisitRRR(this, instruction, node);                           \
  }
SIMD_BINOP_LIST(SIMD_VISIT_BINOP)
#undef SIMD_VISIT_BINOP
#undef SIMD_BINOP_LIST

#define SIMD_VISIT_BINOP_LANE_SIZE(Name, instruction, LaneSize)          \
  template <typename Adapter>                                            \
  void InstructionSelectorT<Adapter>::Visit##Name(node_t node) {         \
    VisitRRR(this, instruction | LaneSizeField::encode(LaneSize), node); \
  }
SIMD_BINOP_LANE_SIZE_LIST(SIMD_VISIT_BINOP_LANE_SIZE)
#undef SIMD_VISIT_BINOP_LANE_SIZE
#undef SIMD_BINOP_LANE_SIZE_LIST

#define SIMD_VISIT_UNOP_LANE_SIZE(Name, instruction, LaneSize)          \
  template <typename Adapter>                                           \
  void InstructionSelectorT<Adapter>::Visit##Name(node_t node) {        \
    VisitRR(this, instruction | LaneSizeField::encode(LaneSize), node); \
  }
SIMD_UNOP_LANE_SIZE_LIST(SIMD_VISIT_UNOP_LANE_SIZE)
#undef SIMD_VISIT_UNOP_LANE_SIZE
#undef SIMD_UNOP_LANE_SIZE_LIST

using ShuffleMatcher =
    ValueMatcher<S128ImmediateParameter, IrOpcode::kI8x16Shuffle>;
using BinopWithShuffleMatcher = BinopMatcher<ShuffleMatcher, ShuffleMatcher,
                                             MachineRepresentation::kSimd128>;

namespace {
// Struct holding the result of pattern-matching a mul+dup.
struct MulWithDupResult {
  Node* input;     // Node holding the vector elements.
  Node* dup_node;  // Node holding the lane to multiply.
  int index;
  // Pattern-match is successful if dup_node is set.
  explicit operator bool() const { return dup_node != nullptr; }
};

// Struct holding the result of pattern-matching a mul+dup.
struct MulWithDup {
  turboshaft::OpIndex input;     // Node holding the vector elements.
  turboshaft::OpIndex dup_node;  // Node holding the lane to multiply.
  int index;
  // Pattern-match is successful if dup_node is set.
  explicit operator bool() const { return dup_node.valid(); }
};

template <int LANES>
MulWithDupResult TryMatchMulWithDup(Node* node) {
  // Pattern match:
  //   f32x4.mul(x, shuffle(x, y, indices)) => f32x4.mul(x, y, laneidx)
  //   f64x2.mul(x, shuffle(x, y, indices)) => f64x2.mul(x, y, laneidx)
  //   where shuffle(x, y, indices) = dup(x[laneidx]) or dup(y[laneidx])
  // f32x4.mul and f64x2.mul are commutative, so use BinopMatcher.
  Node* input = nullptr;
  Node* dup_node = nullptr;

  int index = 0;
  BinopWithShuffleMatcher m = BinopWithShuffleMatcher(node);
  ShuffleMatcher left = m.left();
  ShuffleMatcher right = m.right();

  // TODO(zhin): We can canonicalize first to avoid checking index < LANES.
  // e.g. shuffle(x, y, [16, 17, 18, 19...]) => shuffle(y, y, [0, 1, 2,
  // 3]...). But doing so can mutate the inputs of the shuffle node without
  // updating the shuffle immediates themselves. Fix that before we
  // canonicalize here. We don't want CanCover here because in many use cases,
  // the shuffle is generated early in the function, but the f32x4.mul happens
  // in a loop, which won't cover the shuffle since they are different basic
  // blocks.
  if (left.HasResolvedValue() && wasm::SimdShuffle::TryMatchSplat<LANES>(
                                     left.ResolvedValue().data(), &index)) {
    dup_node = left.node()->InputAt(index < LANES ? 0 : 1);
    input = right.node();
  } else if (right.HasResolvedValue() &&
             wasm::SimdShuffle::TryMatchSplat<LANES>(
                 right.ResolvedValue().data(), &index)) {
    dup_node = right.node()->InputAt(index < LANES ? 0 : 1);
    input = left.node();
  }

  // Canonicalization would get rid of this too.
  index %= LANES;

  return {input, dup_node, index};
}

template <int LANES>
MulWithDup TryMatchMulWithDup(InstructionSelectorT<TurboshaftAdapter>* selector,
                              turboshaft::OpIndex node) {
  // Pattern match:
  //   f32x4.mul(x, shuffle(x, y, indices)) => f32x4.mul(x, y, laneidx)
  //   f64x2.mul(x, shuffle(x, y, indices)) => f64x2.mul(x, y, laneidx)
  //   where shuffle(x, y, indices) = dup(x[laneidx]) or dup(y[laneidx])
  // f32x4.mul and f64x2.mul are commutative, so use BinopMatcher.
  using namespace turboshaft;  // NOLINT(build/namespaces)
  OpIndex input;
  OpIndex dup_node;

  int index = 0;
#if V8_ENABLE_WEBASSEMBLY
  const Simd128BinopOp& mul = selector->Get(node).Cast<Simd128BinopOp>();
  const Operation& left = selector->Get(mul.left());
  const Operation& right = selector->Get(mul.right());

  // TODO(zhin): We can canonicalize first to avoid checking index < LANES.
  // e.g. shuffle(x, y, [16, 17, 18, 19...]) => shuffle(y, y, [0, 1, 2,
  // 3]...). But doing so can mutate the inputs of the shuffle node without
  // updating the shuffle immediates themselves. Fix that before we
  // canonicalize here. We don't want CanCover here because in many use cases,
  // the shuffle is generated early in the function, but the f32x4.mul happens
  // in a loop, which won't cover the shuffle since they are different basic
  // blocks.
  if (left.Is<Simd128ShuffleOp>() &&
      wasm::SimdShuffle::TryMatchSplat<LANES>(
          left.Cast<Simd128ShuffleOp>().shuffle, &index)) {
    dup_node = left.input(index < LANES ? 0 : 1);
    input = mul.right();
  } else if (right.Is<Simd128ShuffleOp>() &&
             wasm::SimdShuffle::TryMatchSplat<LANES>(
                 right.Cast<Simd128ShuffleOp>().shuffle, &index)) {
    dup_node = right.input(index < LANES ? 0 : 1);
    input = mul.left();
  }
#endif  // V8_ENABLE_WEBASSEMBLY

  // Canonicalization would get rid of this too.
  index %= LANES;

  return {input, dup_node, index};
}
}  // namespace

template <>
void InstructionSelectorT<TurboshaftAdapter>::VisitF16x8Mul(node_t node) {
  if (MulWithDup result = TryMatchMulWithDup<8>(this, node)) {
    Arm64OperandGeneratorT<TurboshaftAdapter> g(this);
    Emit(kArm64FMulElement | LaneSizeField::encode(16),
         g.DefineAsRegister(node), g.UseRegister(result.input),
         g.UseRegister(result.dup_node), g.UseImmediate(result.index));
  } else {
    return VisitRRR(this, kArm64FMul | LaneSizeField::encode(16), node);
  }
}

template <>
void InstructionSelectorT<TurbofanAdapter>::VisitF16x8Mul(Node* node) {
  if (MulWithDupResult result = TryMatchMulWithDup<8>(node)) {
    Arm64OperandGeneratorT<TurbofanAdapter> g(this);
    Emit(kArm64FMulElement | LaneSizeField::encode(16),
         g.DefineAsRegister(node), g.UseRegister(result.input),
         g.UseRegister(result.dup_node), g.UseImmediate(result.index));
  } else {
    return VisitRRR(this, kArm64FMul | LaneSizeField::encode(16), node);
  }
}

template <>
void InstructionSelectorT<TurboshaftAdapter>::VisitF32x4Mul(node_t node) {
  if (MulWithDup result = TryMatchMulWithDup<4>(this, node)) {
    Arm64OperandGeneratorT<TurboshaftAdapter> g(this);
    Emit(kArm64FMulElement | LaneSizeField::encode(32),
         g.DefineAsRegister(node), g.UseRegister(result.input),
         g.UseRegister(result.dup_node), g.UseImmediate(result.index));
  } else {
    return VisitRRR(this, kArm64FMul | LaneSizeField::encode(32), node);
  }
}

template <>
void InstructionSelectorT<TurbofanAdapter>::VisitF32x4Mul(Node* node) {
  if (MulWithDupResult result = TryMatchMulWithDup<4>(node)) {
    Arm64OperandGeneratorT<TurbofanAdapter> g(this);
    Emit(kArm64FMulElement | LaneSizeField::encode(32),
         g.DefineAsRegister(node), g.UseRegister(result.input),
         g.UseRegister(result.dup_node), g.UseImmediate(result.index));
  } else {
    return VisitRRR(this, kArm64FMul | LaneSizeField::encode(32), node);
  }
}

template <>
void InstructionSelectorT<TurboshaftAdapter>::VisitF64x2Mul(node_t node) {
  if (MulWithDup result = TryMatchMulWithDup<2>(this, node)) {
    Arm64OperandGeneratorT<TurboshaftAdapter> g(this);
    Emit(kArm64FMulElement | LaneSizeField::encode(64),
         g.DefineAsRegister(node), g.UseRegister(result.input),
         g.UseRegister(result.dup_node), g.UseImmediate(result.index));
  } else {
    return VisitRRR(this, kArm64FMul | LaneSizeField::encode(64), node);
  }
}

template <>
void InstructionSelectorT<TurbofanAdapter>::VisitF64x2Mul(Node* node) {
  if (MulWithDupResult result = TryMatchMulWithDup<2>(node)) {
    Arm64OperandGeneratorT<TurbofanAdapter> g(this);
    Emit(kArm64FMulElement | LaneSizeField::encode(64),
         g.DefineAsRegister(node), g.UseRegister(result.input),
         g.UseRegister(result.dup_node), g.UseImmediate(result.index));
  } else {
    return VisitRRR(this, kArm64FMul | LaneSizeField::encode(64), node);
  }
}

template <typename Adapter>
void InstructionSelectorT<Adapter>::VisitI64x2Mul(node_t node) {
  Arm64OperandGeneratorT<Adapter> g(this);
  InstructionOperand temps[] = {g.TempSimd128Register()};
  Emit(kArm64I64x2Mul, g.DefineAsRegister(node),
       g.UseRegister(this->input_at(node, 0)),
       g.UseRegister(this->input_at(node, 1)), arraysize(temps), temps);
}

namespace {

// Used for pattern matching SIMD Add operations where one of the inputs matches
// |opcode| and ensure that the matched input is on the LHS (input 0).
struct SimdAddOpMatcher : public NodeMatcher {
  explicit SimdAddOpMatcher(Node* node, IrOpcode::Value opcode)
      : NodeMatcher(node),
        opcode_(opcode),
        left_(InputAt(0)),
        right_(InputAt(1)) {
    DCHECK(HasProperty(Operator::kCommutative));
    PutOpOnLeft();
  }

  bool Matches() { return left_->opcode() == opcode_; }
  Node* left() const { return left_; }
  Node* right() const { return right_; }

 private:
  void PutOpOnLeft() {
    if (right_->opcode() == opcode_) {
      std::swap(left_, right_);
      node()->ReplaceInput(0, left_);
      node()->ReplaceInput(1, right_);
    }
  }
  IrOpcode::Value opcode_;
  Node* left_;
  Node* right_;
};

// Tries to match either input of a commutative binop to a given Opmask.
class SimdBinopMatcherTurboshaft {
 public:
  SimdBinopMatcherTurboshaft(InstructionSelectorT<TurboshaftAdapter>* selector,
                             turboshaft::OpIndex node)
      : selector_(selector), node_(node) {
    using namespace turboshaft;  // NOLINT(build/namespaces)
    const Simd128BinopOp& add_op = selector->Get(node).Cast<Simd128BinopOp>();
    DCHECK(Simd128BinopOp::IsCommutative(add_op.kind));
    input0_ = add_op.left();
    input1_ = add_op.right();
  }
  template <typename OpmaskT>
  bool InputMatches() {
    if (selector_->Get(input1_).Is<OpmaskT>()) {
      std::swap(input0_, input1_);
      return true;
    }
    return selector_->Get(input0_).Is<OpmaskT>();
  }
  turboshaft::OpIndex matched_input() const { return input0_; }
  turboshaft::OpIndex other_input() const { return input1_; }

 private:
  InstructionSelectorT<TurboshaftAdapter>* selector_;
  turboshaft::OpIndex node_;
  turboshaft::OpIndex input0_;
  turboshaft::OpIndex input1_;
};

bool ShraHelper(InstructionSelectorT<TurbofanAdapter>* selector, Node* node,
                int lane_size, InstructionCode shra_code,
                InstructionCode add_code, IrOpcode::Value shift_op) {
  Arm64OperandGeneratorT<TurbofanAdapter> g(selector);
  SimdAddOpMatcher m(node, shift_op);
  if (!m.Matches() || !selector->CanCover(node, m.left())) return false;
  if (!g.IsIntegerConstant(m.left()->InputAt(1))) return false;

  // If shifting by zero, just do the addition
  if (g.GetIntegerConstantValue(m.left()->InputAt(1)) % lane_size == 0) {
    selector->Emit(add_code, g.DefineAsRegister(node),
                   g.UseRegister(m.left()->InputAt(0)),
                   g.UseRegister(m.right()));
  } else {
    selector->Emit(shra_code | LaneSizeField::encode(lane_size),
                   g.DefineSameAsFirst(node), g.UseRegister(m.right()),
                   g.UseRegister(m.left()->InputAt(0)),
                   g.UseImmediate(m.left()->InputAt(1)));
  }
  return true;
}

template <typename OpmaskT>
bool ShraHelper(InstructionSelectorT<TurboshaftAdapter>* selector,
                turboshaft::OpIndex node, int lane_size,
                InstructionCode shra_code, InstructionCode add_code) {
  using namespace turboshaft;  // NOLINT(build/namespaces)
  Arm64OperandGeneratorT<TurboshaftAdapter> g(selector);
  SimdBinopMatcherTurboshaft m(selector, node);
  if (!m.InputMatches<OpmaskT>() ||
      !selector->CanCover(node, m.matched_input())) {
    return false;
  }
  const Simd128ShiftOp& shiftop =
      selector->Get(m.matched_input()).Cast<Simd128ShiftOp>();
  if (!selector->is_integer_constant(shiftop.shift())) return false;

  // If shifting by zero, just do the addition
  if (selector->integer_constant(shiftop.shift()) % lane_size == 0) {
    selector->Emit(add_code, g.DefineAsRegister(node),
                   g.UseRegister(shiftop.input()),
                   g.UseRegister(m.other_input()));
  } else {
    selector->Emit(shra_code | LaneSizeField::encode(lane_size),
                   g.DefineSameAsFirst(node), g.UseRegister(m.other_input()),
                   g.UseRegister(shiftop.input()),
                   g.UseImmediate(shiftop.shift()));
  }
  return true;
}

bool AdalpHelper(InstructionSelectorT<TurbofanAdapter>* selector, Node* node,
                 int lane_size, InstructionCode adalp_code,
                 IrOpcode::Value ext_op) {
  Arm64OperandGeneratorT<TurbofanAdapter> g(selector);
  SimdAddOpMatcher m(node, ext_op);
  if (!m.Matches() || !selector->CanCover(node, m.left())) return false;
  selector->Emit(adalp_code | LaneSizeField::encode(lane_size),
                 g.DefineSameAsFirst(node), g.UseRegister(m.right()),
                 g.UseRegister(m.left()->InputAt(0)));
  return true;
}

template <typename OpmaskT>
bool AdalpHelper(InstructionSelectorT<TurboshaftAdapter>* selector,
                 turboshaft::OpIndex node, int lane_size,
                 InstructionCode adalp_code) {
  Arm64OperandGeneratorT<TurboshaftAdapter> g(selector);
  SimdBinopMatcherTurboshaft m(selector, node);
  if (!m.InputMatches<OpmaskT>() ||
      !selector->CanCover(node, m.matched_input())) {
    return false;
  }
  selector->Emit(adalp_code | LaneSizeField::encode(lane_size),
                 g.DefineSameAsFirst(node), g.UseRegister(m.other_input()),
                 g.UseRegister(selector->Get(m.matched_input()).input(0)));
  return true;
}

bool MlaHelper(InstructionSelectorT<TurbofanAdapter>* selector, Node* node,
               InstructionCode mla_code, IrOpcode::Value mul_op) {
  Arm64OperandGeneratorT<TurbofanAdapter> g(selector);
  SimdAddOpMatcher m(node, mul_op);
  if (!m.Matches() || !selector->CanCover(node, m.left())) return false;
  selector->Emit(mla_code, g.DefineSameAsFirst(node), g.UseRegister(m.right()),
                 g.UseRegister(m.left()->InputAt(0)),
                 g.UseRegister(m.left()->InputAt(1)));
  return true;
}

template <typename OpmaskT>
bool MlaHelper(InstructionSelectorT<TurboshaftAdapter>* selector,
               turboshaft::OpIndex node, InstructionCode mla_code) {
  using namespace turboshaft;  // NOLINT(build/namespaces)
  Arm64OperandGeneratorT<TurboshaftAdapter> g(selector);
  SimdBinopMatcherTurboshaft m(selector, node);
  if (!m.InputMatches<OpmaskT>() ||
      !selector->CanCover(node, m.matched_input())) {
    return false;
  }
  const Operation& mul = selector->Get(m.matched_input());
  selector->Emit(mla_code, g.DefineSameAsFirst(node),
                 g.UseRegister(m.other_input()), g.UseRegister(mul.input(0)),
                 g.UseRegister(mul.input(1)));
  return true;
}

bool SmlalHelper(InstructionSelectorT<TurbofanAdapter>* selector, Node* node,
                 int lane_size, InstructionCode smlal_code,
                 IrOpcode::Value ext_mul_op) {
  Arm64OperandGeneratorT<TurbofanAdapter> g(selector);
  SimdAddOpMatcher m(node, ext_mul_op);
  if (!m.Matches() || !selector->CanCover(node, m.left())) return false;

  selector->Emit(smlal_code | LaneSizeField::encode(lane_size),
                 g.DefineSameAsFirst(node), g.UseRegister(m.right()),
                 g.UseRegister(m.left()->InputAt(0)),
                 g.UseRegister(m.left()->InputAt(1)));
  return true;
}

template <turboshaft::Simd128BinopOp::Kind kind>
bool SmlalHelper(InstructionSelectorT<TurboshaftAdapter>* selector,
                 turboshaft::OpIndex node, int lane_size,
                 InstructionCode smlal_code) {
  using namespace turboshaft;  // NOLINT(build/namespaces)
  Arm64OperandGeneratorT<TurboshaftAdapter> g(selector);
  SimdBinopMatcherTurboshaft m(selector, node);
  using OpmaskT = Opmask::Simd128BinopMask::For<kind>;
  if (!m.InputMatches<OpmaskT>() ||
      !selector->CanCover(node, m.matched_input()))
    return false;

  const Operation& matched = selector->Get(m.matched_input());
  selector->Emit(smlal_code | LaneSizeField::encode(lane_size),
                 g.DefineSameAsFirst(node), g.UseRegister(m.other_input()),
                 g.UseRegister(matched.input(0)),
                 g.UseRegister(matched.input(1)));
  return true;
}

}  // namespace

template <>
void InstructionSelectorT<TurbofanAdapter>::VisitI64x2Add(node_t node) {
  if (ShraHelper(this, node, 64, kArm64Ssra,
                 kArm64IAdd | LaneSizeField::encode(64),
                 IrOpcode::kI64x2ShrS) ||
      ShraHelper(this, node, 64, kArm64Usra,
                 kArm64IAdd | LaneSizeField::encode(64),
                 IrOpcode::kI64x2ShrU)) {
    return;
  }
  VisitRRR(this, kArm64IAdd | LaneSizeField::encode(64), node);
}

template <>
void InstructionSelectorT<TurboshaftAdapter>::VisitI64x2Add(
    turboshaft::OpIndex node) {
  using namespace turboshaft;  // NOLINT(build/namespaces)
  if (ShraHelper<Opmask::kSimd128I64x2ShrS>(
          this, node, 64, kArm64Ssra, kArm64IAdd | LaneSizeField::encode(64)) ||
      ShraHelper<Opmask::kSimd128I64x2ShrU>(
          this, node, 64, kArm64Usra, kArm64IAdd | LaneSizeField::encode(64))) {
    return;
  }
  VisitRRR(this, kArm64IAdd | LaneSizeField::encode(64), node);
}

template <>
void InstructionSelectorT<TurbofanAdapter>::VisitI8x16Add(node_t node) {
  if (!ShraHelper(this, node, 8, kArm64Ssra,
                  kArm64IAdd | LaneSizeField::encode(8),
                  IrOpcode::kI8x16ShrS) &&
      !ShraHelper(this, node, 8, kArm64Usra,
                  kArm64IAdd | LaneSizeField::encode(8),
                  IrOpcode::kI8x16ShrU)) {
    VisitRRR(this, kArm64IAdd | LaneSizeField::encode(8), node);
  }
}

template <>
void InstructionSelectorT<TurboshaftAdapter>::VisitI8x16Add(node_t node) {
  using namespace turboshaft;  // NOLINT(build/namespaces)
  if (!ShraHelper<Opmask::kSimd128I8x16ShrS>(
          this, node, 8, kArm64Ssra, kArm64IAdd | LaneSizeField::encode(8)) &&
      !ShraHelper<Opmask::kSimd128I8x16ShrU>(
          this, node, 8, kArm64Usra, kArm64IAdd | LaneSizeField::encode(8))) {
    VisitRRR(this, kArm64IAdd | LaneSizeField::encode(8), node);
  }
}

#define VISIT_SIMD_ADD(Type, PairwiseType, LaneSize)                          \
  template <>                                                                 \
  void InstructionSelectorT<TurbofanAdapter>::Visit##Type##Add(node_t node) { \
    /* Select Mla(z, x, y) for Add(x, Mul(y, z)). */                          \
    if (MlaHelper(this, node, kArm64Mla | LaneSizeField::encode(LaneSize),    \
                  IrOpcode::k##Type##Mul)) {                                  \
      return;                                                                 \
    }                                                                         \
    /* Select S/Uadalp(x, y) for Add(x, ExtAddPairwise(y)). */                \
    if (AdalpHelper(this, node, LaneSize, kArm64Sadalp,                       \
                    IrOpcode::k##Type##ExtAddPairwise##PairwiseType##S) ||    \
        AdalpHelper(this, node, LaneSize, kArm64Uadalp,                       \
                    IrOpcode::k##Type##ExtAddPairwise##PairwiseType##U)) {    \
      return;                                                                 \
    }                                                                         \
    /* Select S/Usra(x, y) for Add(x, ShiftRight(y, imm)). */                 \
    if (ShraHelper(this, node, LaneSize, kArm64Ssra,                          \
                   kArm64IAdd | LaneSizeField::encode(LaneSize),              \
                   IrOpcode::k##Type##ShrS) ||                                \
        ShraHelper(this, node, LaneSize, kArm64Usra,                          \
                   kArm64IAdd | LaneSizeField::encode(LaneSize),              \
                   IrOpcode::k##Type##ShrU)) {                                \
      return;                                                                 \
    }                                                                         \
    /* Select Smlal/Umlal(x, y, z) for Add(x, ExtMulLow(y, z)) and            \
     * Smlal2/Umlal2(x, y, z) for Add(x, ExtMulHigh(y, z)). */                \
    if (SmlalHelper(this, node, LaneSize, kArm64Smlal,                        \
                    IrOpcode::k##Type##ExtMulLow##PairwiseType##S) ||         \
        SmlalHelper(this, node, LaneSize, kArm64Smlal2,                       \
                    IrOpcode::k##Type##ExtMulHigh##PairwiseType##S) ||        \
        SmlalHelper(this, node, LaneSize, kArm64Umlal,                        \
                    IrOpcode::k##Type##ExtMulLow##PairwiseType##U) ||         \
        SmlalHelper(this, node, LaneSize, kArm64Umlal2,                       \
                    IrOpcode::k##Type##ExtMulHigh##PairwiseType##U)) {        \
      return;                                                                 \
    }                                                                         \
    VisitRRR(this, kArm64IAdd | LaneSizeField::encode(LaneSize), node);       \
  }                                                                           \
                                                                              \
  template <>                                                                 \
  void InstructionSelectorT<TurboshaftAdapter>::Visit##Type##Add(             \
      node_t node) {                                                          \
    using namespace turboshaft; /*NOLINT(build/namespaces)*/                  \
    /* Select Mla(z, x, y) for Add(x, Mul(y, z)). */                          \
    if (MlaHelper<Opmask::kSimd128##Type##Mul>(                               \
            this, node, kArm64Mla | LaneSizeField::encode(LaneSize))) {       \
      return;                                                                 \
    }                                                                         \
    /* Select S/Uadalp(x, y) for Add(x, ExtAddPairwise(y)). */                \
    if (AdalpHelper<Opmask::kSimd128##Type##ExtAddPairwise##PairwiseType##S>( \
            this, node, LaneSize, kArm64Sadalp) ||                            \
        AdalpHelper<Opmask::kSimd128##Type##ExtAddPairwise##PairwiseType##U>( \
            this, node, LaneSize, kArm64Uadalp)) {                            \
      return;                                                                 \
    }                                                                         \
    /* Select S/Usra(x, y) for Add(x, ShiftRight(y, imm)). */                 \
    if (ShraHelper<Opmask::kSimd128##Type##ShrS>(                             \
            this, node, LaneSize, kArm64Ssra,                                 \
            kArm64IAdd | LaneSizeField::encode(LaneSize)) ||                  \
        ShraHelper<Opmask::kSimd128##Type##ShrU>(                             \
            this, node, LaneSize, kArm64Usra,                                 \
            kArm64IAdd | LaneSizeField::encode(LaneSize))) {                  \
      return;                                                                 \
    }                                                                         \
    /* Select Smlal/Umlal(x, y, z) for Add(x, ExtMulLow(y, z)) and            \
     * Smlal2/Umlal2(x, y, z) for Add(x, ExtMulHigh(y, z)). */                \
    if (SmlalHelper<                                                          \
            Simd128BinopOp::Kind::k##Type##ExtMulLow##PairwiseType##S>(       \
            this, node, LaneSize, kArm64Smlal) ||                             \
        SmlalHelper<                                                          \
            Simd128BinopOp::Kind::k##Type##ExtMulHigh##PairwiseType##S>(      \
            this, node, LaneSize, kArm64Smlal2) ||                            \
        SmlalHelper<                                                          \
            Simd128BinopOp::Kind::k##Type##ExtMulLow##PairwiseType##U>(       \
            this, node, LaneSize, kArm64Umlal) ||                             \
        SmlalHelper<                                                          \
            Simd128BinopOp::Kind::k##Type##ExtMulHigh##PairwiseType##U>(      \
            this, node, LaneSize, kArm64Umlal2)) {                            \
      return;                                                                 \
    }                                                                         \
    VisitRRR(this, kArm64IAdd | LaneSizeField::encode(LaneSize), node);       \
  }

VISIT_SIMD_ADD(I32x4, I16x8, 32)
VISIT_SIMD_ADD(I16x8, I8x16, 16)
#undef VISIT_SIMD_ADD

#define VISIT_SIMD_SUB(Type, LaneSize)                                        \
  template <>                                                                 \
  void InstructionSelectorT<TurboshaftAdapter>::Visit##Type##Sub(             \
      node_t node) {                                                          \
    using namespace turboshaft; /* NOLINT(build/namespaces) */                \
    Arm64OperandGeneratorT<TurboshaftAdapter> g(this);                        \
    const Simd128BinopOp& sub = Get(node).Cast<Simd128BinopOp>();             \
    const Operation& right = Get(sub.right());                                \
    /* Select Mls(z, x, y) for Sub(z, Mul(x, y)). */                          \
    if (right.Is<Opmask::kSimd128##Type##Mul>() &&                            \
        CanCover(node, sub.right())) {                                        \
      Emit(kArm64Mls | LaneSizeField::encode(LaneSize),                       \
           g.DefineSameAsFirst(node), g.UseRegister(sub.left()),              \
           g.UseRegister(right.input(0)), g.UseRegister(right.input(1)));     \
      return;                                                                 \
    }                                                                         \
    VisitRRR(this, kArm64ISub | LaneSizeField::encode(LaneSize), node);       \
  }                                                                           \
  template <>                                                                 \
  void InstructionSelectorT<TurbofanAdapter>::Visit##Type##Sub(Node* node) {  \
    Arm64OperandGeneratorT<TurbofanAdapter> g(this);                          \
    Node* left = node->InputAt(0);                                            \
    Node* right = node->InputAt(1);                                           \
    /* Select Mls(z, x, y) for Sub(z, Mul(x, y)). */                          \
    if (right->opcode() == IrOpcode::k##Type##Mul && CanCover(node, right)) { \
      Emit(kArm64Mls | LaneSizeField::encode(LaneSize),                       \
           g.DefineSameAsFirst(node), g.UseRegister(left),                    \
           g.UseRegister(right->InputAt(0)),                                  \
           g.UseRegister(right->InputAt(1)));                                 \
      return;                                                                 \
    }                                                                         \
    VisitRRR(this, kArm64ISub | LaneSizeField::encode(LaneSize), node);       \
  }

VISIT_SIMD_SUB(I32x4, 32)
VISIT_SIMD_SUB(I16x8, 16)
#undef VISIT_SIMD_SUB

namespace {
void VisitSimdReduce(InstructionSelectorT<TurboshaftAdapter>* selector,
                     turboshaft::OpIndex node, InstructionCode opcode) {
  Arm64OperandGeneratorT<TurboshaftAdapter> g(selector);
  selector->Emit(opcode, g.DefineAsRegister(node),
                 g.UseRegister(selector->Get(node).input(0)));
}

}  // namespace

#define VISIT_SIMD_REDUCE(Type, Opcode)                                 \
  template <>                                                           \
  void InstructionSelectorT<TurboshaftAdapter>::Visit##Type##AddReduce( \
      turboshaft::OpIndex node) {                                       \
    VisitSimdReduce(this, node, Opcode);                                \
  }

VISIT_SIMD_REDUCE(I8x16, kArm64I8x16Addv)
VISIT_SIMD_REDUCE(I16x8, kArm64I16x8Addv)
VISIT_SIMD_REDUCE(I32x4, kArm64I32x4Addv)
VISIT_SIMD_REDUCE(I64x2, kArm64I64x2AddPair)
VISIT_SIMD_REDUCE(F32x4, kArm64F32x4AddReducePairwise)
VISIT_SIMD_REDUCE(F64x2, kArm64F64x2AddPair)
#undef VISIT_SIMD_REDUCE

namespace {
bool isSimdZero(InstructionSelectorT<TurbofanAdapter>* selector, Node* node) {
  auto m = V128ConstMatcher(node);
  if (m.HasResolvedValue()) {
    auto imms = m.ResolvedValue().immediate();
    return (std::all_of(imms.begin(), imms.end(), std::logical_not<uint8_t>()));
  }
  return node->opcode() == IrOpcode::kS128Zero;
}

bool isSimdZero(InstructionSelectorT<TurboshaftAdapter>* selector,
                turboshaft::OpIndex node) {
  const turboshaft::Operation& op = selector->Get(node);
  if (auto constant = op.TryCast<turboshaft::Simd128ConstantOp>()) {
    return constant->IsZero();
  }
  return false;
}

}  // namespace

#define VISIT_SIMD_CM(Type, T, CmOp, CmOpposite, LaneSize)                   \
  template <typename Adapter>                                                \
  void InstructionSelectorT<Adapter>::Visit##Type##CmOp(node_t node) {       \
    Arm64OperandGeneratorT<Adapter> g(this);                                 \
    node_t left = this->input_at(node, 0);                                   \
    node_t right = this->input_at(node, 1);                                  \
    if (isSimdZero(this, left)) {                                            \
      Emit(kArm64##T##CmOpposite | LaneSizeField::encode(LaneSize),          \
           g.DefineAsRegister(node), g.UseRegister(right));                  \
      return;                                                                \
    } else if (isSimdZero(this, right)) {                                    \
      Emit(kArm64##T##CmOp | LaneSizeField::encode(LaneSize),                \
           g.DefineAsRegister(node), g.UseRegister(left));                   \
      return;                                                                \
    }                                                                        \
    VisitRRR(this, kArm64##T##CmOp | LaneSizeField::encode(LaneSize), node); \
  }

VISIT_SIMD_CM(F64x2, F, Eq, Eq, 64)
VISIT_SIMD_CM(F64x2, F, Ne, Ne, 64)
VISIT_SIMD_CM(F64x2, F, Lt, Gt, 64)
VISIT_SIMD_CM(F64x2, F, Le, Ge, 64)
VISIT_SIMD_CM(F32x4, F, Eq, Eq, 32)
VISIT_SIMD_CM(F32x4, F, Ne, Ne, 32)
VISIT_SIMD_CM(F32x4, F, Lt, Gt, 32)
VISIT_SIMD_CM(F32x4, F, Le, Ge, 32)
VISIT_SIMD_CM(F16x8, F, Eq, Eq, 16)
VISIT_SIMD_CM(F16x8, F, Ne, Ne, 16)
VISIT_SIMD_CM(F16x8, F, Lt, Gt, 16)
VISIT_SIMD_CM(F16x8, F, Le, Ge, 16)

VISIT_SIMD_CM(I64x2, I, Eq, Eq, 64)
VISIT_SIMD_CM(I64x2, I, Ne, Ne, 64)
VISIT_SIMD_CM(I64x2, I, GtS, LtS, 64)
VISIT_SIMD_CM(I64x2, I, GeS, LeS, 64)
VISIT_SIMD_CM(I32x4, I, Eq, Eq, 32)
VISIT_SIMD_CM(I32x4, I, Ne, Ne, 32)
VISIT_SIMD_CM(I32x4, I, GtS, LtS, 32)
VISIT_SIMD_CM(I32x4, I, GeS, LeS, 32)
VISIT_SIMD_CM(I16x8, I, Eq, Eq, 16)
VISIT_SIMD_CM(I16x8, I, Ne, Ne, 16)
VISIT_SIMD_CM(I16x8, I, GtS, LtS, 16)
VISIT_SIMD_CM(I16x8, I, GeS, LeS, 16)
VISIT_SIMD_CM(I8x16, I, Eq, Eq, 8)
VISIT_SIMD_CM(I8x16, I, Ne, Ne, 8)
VISIT_SIMD_CM(I8x16, I, GtS, LtS, 8)
VISIT_SIMD_CM(I8x16, I, GeS, LeS, 8)
#undef VISIT_SIMD_CM

template <typename Adapter>
void InstructionSelectorT<Adapter>::VisitS128Select(node_t node) {
  Arm64OperandGeneratorT<Adapter> g(this);
  Emit(kArm64S128Select, g.DefineSameAsFirst(node),
       g.UseRegister(this->input_at(node, 0)),
       g.UseRegister(this->input_at(node, 1)),
       g.UseRegister(this->input_at(node, 2)));
}

template <typename Adapter>
void InstructionSelectorT<Adapter>::VisitI8x16RelaxedLaneSelect(node_t node) {
  VisitS128Select(node);
}

template <typename Adapter>
vo
```
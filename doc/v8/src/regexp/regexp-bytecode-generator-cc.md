Response:
Let's break down the thought process for analyzing the provided C++ code and generating the requested information.

1. **Understanding the Core Request:** The primary goal is to understand the functionality of `regexp-bytecode-generator.cc` within the V8 JavaScript engine. The prompt also asks about Torque (.tq) files, JavaScript relevance, code logic, and potential programming errors.

2. **Initial Code Scan (Keywords and Structure):**  A quick scan reveals key elements:
    * `#include` statements:  `ast/ast.h`, `objects/fixed-array-inl.h`, `regexp/...`. This suggests it's related to regular expression processing, abstract syntax trees, and object management within V8.
    * Class definition: `RegExpBytecodeGenerator`. This is the central entity we need to understand.
    * Member variables: `buffer_`, `pc_`, `jump_edges_`, `isolate_`, `backtrack_`. These hint at how the generator works (e.g., `buffer_` likely stores the generated bytecode, `pc_` is the program counter).
    * Methods with names like `Bind`, `Emit`, `GoTo`, `Check...`, `Load...`. These suggest the core operations of generating bytecode instructions.
    * Namespace: `v8::internal`. This confirms it's an internal component of V8.

3. **Identifying Key Functionality (Method by Method):** Now, go through the public methods of the `RegExpBytecodeGenerator` class and try to deduce their purpose:

    * **Constructor/Destructor:**  Initialization and cleanup. The destructor freeing `backtrack_` suggests it's a resource.
    * **`Implementation()`:** Returns `kBytecodeImplementation`. This clearly states the generator creates bytecode.
    * **`Bind(Label* l)`:**  Deals with labels and linking. It seems to resolve forward references during code generation.
    * **`EmitOrLink(Label* l)`:** Emits bytecode and potentially links to a label. This is a fundamental operation.
    * **`PopRegister`, `PushRegister`, `WriteCurrentPositionToRegister`, etc.:** These clearly manipulate registers, suggesting a register-based virtual machine for regular expressions.
    * **`SetCurrentPositionFromEnd`, `AdvanceCurrentPosition`:** These manipulate the "current position" in the input string being matched.
    * **`Backtrack()`, `GoTo(Label* l)`, `PushBacktrack(Label* l)`:** Control flow mechanisms for the regular expression engine. Backtracking is a crucial concept in regex matching.
    * **`Succeed()`, `Fail()`:**  Outcome of the matching process.
    * **`CheckGreedyLoop(Label*)`:**  Specific logic for handling greedy quantifiers.
    * **`LoadCurrentCharacterImpl(...)`:**  Fetches characters from the input string, potentially with boundary checks.
    * **`CheckCharacterLT`, `CheckCharacterGT`, `CheckCharacter`, etc.:**  Various character comparison operations, core to regex matching.
    * **`CheckAtStart`, `CheckNotAtStart`:**  Anchors for matching at the beginning of the string.
    * **`CheckNotBackReference`, `CheckNotBackReferenceIgnoreCase`:** Handling backreferences in regular expressions.
    * **`IfRegisterLT`, `IfRegisterGE`, `IfRegisterEqPos`:** Conditional jumps based on register values.
    * **`GetCode(Handle<String>, RegExpFlags)`:**  The method that finalizes the bytecode generation and returns the resulting code.
    * **`length()`, `Copy(uint8_t*)`, `ExpandBuffer()`:**  Utilities for managing the bytecode buffer.

4. **Synthesizing the Functionality Description:** Based on the method analysis, summarize the main functions of the class. Emphasize the generation of bytecode for regular expression matching, register manipulation, control flow, and character checks.

5. **Addressing the Torque Question:** The prompt specifically asks about `.tq` files. The provided code is `.cc`, so the answer is straightforward. Explain what Torque is and that the given file isn't a Torque file.

6. **Connecting to JavaScript (with Examples):** Think about how the generated bytecode is used in the context of JavaScript regular expressions. Provide simple JavaScript regex examples that would trigger the various bytecode generation functions (e.g., character matching, anchors, backreferences, quantifiers). This is crucial for linking the C++ code to user-facing JavaScript.

7. **Inferring Code Logic (Hypothetical Input/Output):** Choose a simple regex and trace the *kind* of bytecode that would be generated. Focus on the *sequence* of operations rather than exact bytecode values. This demonstrates understanding of how the generator translates regex patterns into low-level instructions.

8. **Identifying Common Programming Errors:** Consider common mistakes users make with regular expressions that might relate to the bytecode generator's operations (e.g., inefficient patterns leading to excessive backtracking, incorrect use of anchors, issues with capturing groups).

9. **Structuring the Output:** Organize the information clearly according to the prompt's requests. Use headings, bullet points, and code examples to make the explanation easy to understand.

10. **Review and Refine:** Read through the generated answer to ensure accuracy, clarity, and completeness. Check for any inconsistencies or areas that need further explanation. For example, initially, I might have just listed the methods. The refinement step would be to explain *what those methods do* in the context of bytecode generation.

This iterative process of scanning, analyzing, synthesizing, and refining allows for a comprehensive understanding of the code and generation of a detailed and helpful response. The key is to connect the low-level C++ implementation to the higher-level concepts of regular expressions and their usage in JavaScript.
`v8/src/regexp/regexp-bytecode-generator.cc` 是 V8 JavaScript 引擎中负责将正则表达式编译成字节码的关键组件。它属于 V8 引擎的 Irregexp（Ignition Regular Expressions）子系统，这是一个基于字节码的正则表达式引擎。

**功能列表:**

1. **正则表达式编译:**  该文件的核心功能是将正则表达式的抽象语法树 (AST) 形式转换为可以在 V8 的正则表达式虚拟机上执行的字节码指令序列。这个过程包括将各种正则表达式结构（如字符匹配、字符类、锚点、分组、量词等）映射到相应的字节码指令。

2. **字节码生成:** 它定义了用于表示正则表达式操作的字节码指令集 (`RegExpBytecodes.h`)，并实现了生成这些指令的逻辑。例如，对于匹配特定字符，会生成 `BC_CHECK_CHAR` 指令。

3. **寄存器管理:**  正则表达式的匹配过程需要存储一些状态信息，例如当前匹配位置、捕获组的起始和结束位置等。`RegExpBytecodeGenerator` 使用虚拟寄存器来存储这些信息，并提供操作寄存器的指令（如 `BC_SET_REGISTER`, `BC_ADVANCE_REGISTER`）。

4. **控制流管理:** 正则表达式匹配涉及复杂的控制流，例如分支、循环和回溯。`RegExpBytecodeGenerator` 使用标签 (Label) 和跳转指令（如 `BC_GOTO`, `BC_PUSH_BT`）来实现这些控制流结构。

5. **位置管理:**  跟踪当前在输入字符串中的匹配位置是正则表达式匹配的关键。它提供了操作当前位置的指令（如 `BC_ADVANCE_CP`, `BC_SET_CP_TO_REGISTER`）。

6. **回溯支持:** 正则表达式引擎需要支持回溯，以便在匹配失败时尝试其他可能的匹配路径。`RegExpBytecodeGenerator` 提供了 `BC_PUSH_BT` 和 `BC_POP_BT` 指令来管理回溯点。

7. **断言支持:**  支持正则表达式中的断言，例如 `^` (行首)、`$` (行尾)、`\b` (单词边界) 等，通过生成相应的检查指令（如 `BC_CHECK_AT_START`, `BC_CHECK_NOT_BACK_REF`）。

8. **捕获组支持:**  支持正则表达式中的捕获组，能够记录匹配捕获组的子字符串。这通过操作寄存器来存储捕获组的起始和结束位置来实现。

9. **性能优化:**  包含一些初步的优化，例如合并相邻的指令 (`BC_ADVANCE_CP_AND_GOTO`)。  V8 还会进行更高级的 peephole 优化（由 `RegExpBytecodePeepholeOptimization` 类处理）。

**如果 `v8/src/regexp/regexp-bytecode-generator.cc` 以 `.tq` 结尾:**

如果文件名以 `.tq` 结尾，那么它将是一个 **V8 Torque 源代码** 文件。Torque 是 V8 使用的一种领域特定语言，用于生成高效的 C++ 代码。 Torque 的主要目标是提高 V8 内部关键路径代码的可读性、可维护性和性能。

在这种假设情况下，`regexp-bytecode-generator.tq` 将使用 Torque 语法来描述正则表达式字节码生成器的逻辑，并且 Torque 编译器会将其转换为相应的 C++ 代码。

**与 JavaScript 功能的关系 (及 JavaScript 示例):**

`v8/src/regexp/regexp-bytecode-generator.cc` (或假设的 `.tq` 版本) 与 JavaScript 的 `RegExp` 对象的功能直接相关。 当你在 JavaScript 中创建一个 `RegExp` 对象或使用正则表达式字面量时，V8 引擎会调用这个组件来将正则表达式编译成它可以执行的字节码。

**JavaScript 示例:**

```javascript
const regex1 = /abc/;
const text1 = "abcdefg";
const match1 = text1.match(regex1); // 调用 V8 的正则表达式引擎

const regex2 = /d(ef)g/;
const text2 = "abcdefg";
const match2 = text2.match(regex2); // 涉及到捕获组

const regex3 = /^abc/;
const text3 = "abcdefg";
const match3 = text3.test(regex3); // 使用断言

const regex4 = /a+/;
const text4 = "aaabbb";
const match4 = text4.match(regex4); // 使用量词
```

在幕后，当 V8 遇到这些 JavaScript 代码时，`regexp-bytecode-generator.cc` 的代码会被执行，将 `/abc/`、`/d(ef)g/`、`/^abc/`、`/a+/` 这些正则表达式模式转换为 V8 虚拟机可以理解和执行的字节码指令。

**代码逻辑推理 (假设输入与输出):**

**假设输入:**  一个简单的正则表达式 `/a.b/` (匹配 "a" 后面跟任意一个字符，再跟 "b")

**推断的字节码生成过程和可能的输出 (简化表示):**

1. **加载当前字符:**  读取当前匹配位置的字符。
   ```bytecode
   BC_LOAD_CURRENT_CHAR offset=0  // 加载当前位置的字符
   ```

2. **检查是否为 'a':**
   ```bytecode
   BC_CHECK_CHAR char='a' label_on_equal=L1
   BC_GOTO label=Backtrack       // 如果不匹配，回溯
   L1:                           // 如果匹配，继续
   ```

3. **前进到下一个字符:**
   ```bytecode
   BC_ADVANCE_CP by=1
   ```

4. **加载下一个字符:**
   ```bytecode
   BC_LOAD_CURRENT_CHAR offset=0  // 加载当前位置的字符
   ```

5. **前进到下一个字符:** (因为 `.` 匹配任意字符，所以不需要特定的检查，只需要前进)
   ```bytecode
   BC_ADVANCE_CP by=1
   ```

6. **加载当前字符:**
   ```bytecode
   BC_LOAD_CURRENT_CHAR offset=0
   ```

7. **检查是否为 'b':**
   ```bytecode
   BC_CHECK_CHAR char='b' label_on_equal=L2
   BC_GOTO label=Backtrack       // 如果不匹配，回溯
   L2:                           // 如果匹配，继续
   ```

8. **匹配成功:**
   ```bytecode
   BC_SUCCEED
   ```

**假设输入:** 正则表达式 `/a*/` (匹配零个或多个 'a')

**推断的字节码生成过程和可能的输出 (简化表示):**

1. **定义循环开始标签:**
   ```bytecode
   L1:
   ```

2. **保存当前位置 (用于回溯):**
   ```bytecode
   BC_PUSH_CP
   ```

3. **尝试匹配 'a':**
   ```bytecode
   BC_LOAD_CURRENT_CHAR offset=0
   BC_CHECK_CHAR char='a' label_on_equal=L2
   ```

4. **如果匹配 'a'，则前进并跳转回循环开始:**
   ```bytecode
   BC_ADVANCE_CP by=1
   BC_GOTO label=L1
   L2: // 实际上，这里应该跳转到循环继续匹配的地方
   ```

5. **如果 'a' 匹配失败，则回溯到保存的位置并继续执行 (匹配零个 'a'):**
   ```bytecode
   BC_POP_CP
   BC_SUCCEED // 匹配零个 'a' 也算成功
   ```
   （注意：实际的实现可能更复杂，涉及到贪婪或非贪婪匹配的处理。）

**涉及用户常见的编程错误 (及示例):**

1. **回溯陷阱 (Catastrophic Backtracking):** 当正则表达式结构复杂且输入字符串具有特定模式时，可能导致正则表达式引擎进行大量的回溯，消耗大量时间和资源，甚至导致程序无响应。

   **示例:**  `/a*b*c*/.exec("aaaaaaaaaaaaaaaaaaaaaaaaaaaaac")`  或 `/^(a+)+$/.exec("aaaaaaaaaaaaaaaaaaaaaaaaaaaaa")`

   在这些例子中，量词的组合可能导致引擎尝试大量的排列组合，从而导致性能问题。

2. **忘记转义特殊字符:**  在正则表达式中，某些字符具有特殊含义（例如 `.`、`*`、`+`、`?` 等）。如果用户想要匹配这些字符本身，需要进行转义 (`\.`, `\*`, `\+`, `\?` )。

   **示例:**  用户想匹配字符串 "a.b"，但错误地使用了 `/a.b/`，这将匹配 "axb"、"a1b" 等。正确的写法是 `/a\.b/`。

3. **对锚点的误解:**  `^` 和 `$` 分别匹配字符串的开头和结尾（或者行的开头和结尾，在多行模式下）。用户可能会误解它们的行为。

   **示例:**  `/abc$/.exec("defabc")` 将返回 `null`，因为 "abc" 不在字符串的结尾。

4. **捕获组的非预期行为:**  用户可能没有意识到捕获组会存储匹配的子字符串，或者错误地使用了捕获组的编号。

   **示例:**  `/(\d+)-(\d+)-(\d+)/.exec("2023-10-27")`  会返回包含整个匹配和三个捕获组的数组。如果用户不理解捕获组的工作方式，可能会导致错误。

5. **字符类的使用错误:**  字符类 `[]` 用于匹配一组字符中的任意一个。用户可能会在字符类中放入多个字符，但忘记了它匹配的是 *任意一个* 而不是整个序列。

   **示例:**  `/[abc]/.exec("d")` 会返回 `null`，因为 "d" 不在字符类 `[abc]` 中。

`v8/src/regexp/regexp-bytecode-generator.cc` 的实现需要处理所有这些情况，确保正则表达式引擎能够正确、高效地执行各种复杂的模式，并尽量避免用户常犯的错误导致的性能问题或意外结果。

Prompt: 
```
这是目录为v8/src/regexp/regexp-bytecode-generator.cc的一个v8源代码， 请列举一下它的功能, 
如果v8/src/regexp/regexp-bytecode-generator.cc以.tq结尾，那它是个v8 torque源代码，
如果它与javascript的功能有关系，请用javascript举例说明,
如果有代码逻辑推理，请给出假设输入与输出，
如果涉及用户常见的编程错误，请举例说明

"""
// Copyright 2008-2009 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/regexp/regexp-bytecode-generator.h"

#include "src/ast/ast.h"
#include "src/objects/fixed-array-inl.h"
#include "src/regexp/regexp-bytecode-generator-inl.h"
#include "src/regexp/regexp-bytecode-peephole.h"
#include "src/regexp/regexp-bytecodes.h"
#include "src/regexp/regexp-macro-assembler.h"

namespace v8 {
namespace internal {

RegExpBytecodeGenerator::RegExpBytecodeGenerator(Isolate* isolate, Zone* zone)
    : RegExpMacroAssembler(isolate, zone),
      buffer_(kInitialBufferSize, zone),
      pc_(0),
      advance_current_end_(kInvalidPC),
      jump_edges_(zone),
      isolate_(isolate) {}

RegExpBytecodeGenerator::~RegExpBytecodeGenerator() {
  if (backtrack_.is_linked()) backtrack_.Unuse();
}

RegExpBytecodeGenerator::IrregexpImplementation
RegExpBytecodeGenerator::Implementation() {
  return kBytecodeImplementation;
}

void RegExpBytecodeGenerator::Bind(Label* l) {
  advance_current_end_ = kInvalidPC;
  DCHECK(!l->is_bound());
  if (l->is_linked()) {
    int pos = l->pos();
    while (pos != 0) {
      int fixup = pos;
      pos = *reinterpret_cast<int32_t*>(buffer_.data() + fixup);
      *reinterpret_cast<uint32_t*>(buffer_.data() + fixup) = pc_;
      jump_edges_.emplace(fixup, pc_);
    }
  }
  l->bind_to(pc_);
}

void RegExpBytecodeGenerator::EmitOrLink(Label* l) {
  if (l == nullptr) l = &backtrack_;
  int pos = 0;
  if (l->is_bound()) {
    pos = l->pos();
    jump_edges_.emplace(pc_, pos);
  } else {
    if (l->is_linked()) {
      pos = l->pos();
    }
    l->link_to(pc_);
  }
  Emit32(pos);
}

void RegExpBytecodeGenerator::PopRegister(int register_index) {
  DCHECK_LE(0, register_index);
  DCHECK_GE(kMaxRegister, register_index);
  Emit(BC_POP_REGISTER, register_index);
}

void RegExpBytecodeGenerator::PushRegister(int register_index,
                                           StackCheckFlag check_stack_limit) {
  DCHECK_LE(0, register_index);
  DCHECK_GE(kMaxRegister, register_index);
  Emit(BC_PUSH_REGISTER, register_index);
}

void RegExpBytecodeGenerator::WriteCurrentPositionToRegister(int register_index,
                                                             int cp_offset) {
  DCHECK_LE(0, register_index);
  DCHECK_GE(kMaxRegister, register_index);
  Emit(BC_SET_REGISTER_TO_CP, register_index);
  Emit32(cp_offset);  // Current position offset.
}

void RegExpBytecodeGenerator::ClearRegisters(int reg_from, int reg_to) {
  DCHECK(reg_from <= reg_to);
  for (int reg = reg_from; reg <= reg_to; reg++) {
    SetRegister(reg, -1);
  }
}

void RegExpBytecodeGenerator::ReadCurrentPositionFromRegister(
    int register_index) {
  DCHECK_LE(0, register_index);
  DCHECK_GE(kMaxRegister, register_index);
  Emit(BC_SET_CP_TO_REGISTER, register_index);
}

void RegExpBytecodeGenerator::WriteStackPointerToRegister(int register_index) {
  DCHECK_LE(0, register_index);
  DCHECK_GE(kMaxRegister, register_index);
  Emit(BC_SET_REGISTER_TO_SP, register_index);
}

void RegExpBytecodeGenerator::ReadStackPointerFromRegister(int register_index) {
  DCHECK_LE(0, register_index);
  DCHECK_GE(kMaxRegister, register_index);
  Emit(BC_SET_SP_TO_REGISTER, register_index);
}

void RegExpBytecodeGenerator::SetCurrentPositionFromEnd(int by) {
  DCHECK(is_uint24(by));
  Emit(BC_SET_CURRENT_POSITION_FROM_END, by);
}

void RegExpBytecodeGenerator::SetRegister(int register_index, int to) {
  DCHECK_LE(0, register_index);
  DCHECK_GE(kMaxRegister, register_index);
  Emit(BC_SET_REGISTER, register_index);
  Emit32(to);
}

void RegExpBytecodeGenerator::AdvanceRegister(int register_index, int by) {
  DCHECK_LE(0, register_index);
  DCHECK_GE(kMaxRegister, register_index);
  Emit(BC_ADVANCE_REGISTER, register_index);
  Emit32(by);
}

void RegExpBytecodeGenerator::PopCurrentPosition() { Emit(BC_POP_CP, 0); }

void RegExpBytecodeGenerator::PushCurrentPosition() { Emit(BC_PUSH_CP, 0); }

void RegExpBytecodeGenerator::Backtrack() {
  int error_code =
      can_fallback() ? RegExp::RE_FALLBACK_TO_EXPERIMENTAL : RegExp::RE_FAILURE;
  Emit(BC_POP_BT, error_code);
}

void RegExpBytecodeGenerator::GoTo(Label* l) {
  if (advance_current_end_ == pc_) {
    // Combine advance current and goto.
    pc_ = advance_current_start_;
    Emit(BC_ADVANCE_CP_AND_GOTO, advance_current_offset_);
    EmitOrLink(l);
    advance_current_end_ = kInvalidPC;
  } else {
    // Regular goto.
    Emit(BC_GOTO, 0);
    EmitOrLink(l);
  }
}

void RegExpBytecodeGenerator::PushBacktrack(Label* l) {
  Emit(BC_PUSH_BT, 0);
  EmitOrLink(l);
}

bool RegExpBytecodeGenerator::Succeed() {
  Emit(BC_SUCCEED, 0);
  return false;  // Restart matching for global regexp not supported.
}

void RegExpBytecodeGenerator::Fail() { Emit(BC_FAIL, 0); }

void RegExpBytecodeGenerator::AdvanceCurrentPosition(int by) {
  // TODO(chromium:1166138): Turn back into DCHECKs once the underlying issue
  // is fixed.
  CHECK_LE(kMinCPOffset, by);
  CHECK_GE(kMaxCPOffset, by);
  advance_current_start_ = pc_;
  advance_current_offset_ = by;
  Emit(BC_ADVANCE_CP, by);
  advance_current_end_ = pc_;
}

void RegExpBytecodeGenerator::CheckGreedyLoop(
    Label* on_tos_equals_current_position) {
  Emit(BC_CHECK_GREEDY, 0);
  EmitOrLink(on_tos_equals_current_position);
}

void RegExpBytecodeGenerator::LoadCurrentCharacterImpl(int cp_offset,
                                                       Label* on_failure,
                                                       bool check_bounds,
                                                       int characters,
                                                       int eats_at_least) {
  DCHECK_GE(eats_at_least, characters);
  if (eats_at_least > characters && check_bounds) {
    DCHECK(is_int24(cp_offset + eats_at_least));
    Emit(BC_CHECK_CURRENT_POSITION, cp_offset + eats_at_least);
    EmitOrLink(on_failure);
    check_bounds = false;  // Load below doesn't need to check.
  }

  DCHECK_LE(kMinCPOffset, cp_offset);
  DCHECK_GE(kMaxCPOffset, cp_offset);
  int bytecode;
  if (check_bounds) {
    if (characters == 4) {
      bytecode = BC_LOAD_4_CURRENT_CHARS;
    } else if (characters == 2) {
      bytecode = BC_LOAD_2_CURRENT_CHARS;
    } else {
      DCHECK_EQ(1, characters);
      bytecode = BC_LOAD_CURRENT_CHAR;
    }
  } else {
    if (characters == 4) {
      bytecode = BC_LOAD_4_CURRENT_CHARS_UNCHECKED;
    } else if (characters == 2) {
      bytecode = BC_LOAD_2_CURRENT_CHARS_UNCHECKED;
    } else {
      DCHECK_EQ(1, characters);
      bytecode = BC_LOAD_CURRENT_CHAR_UNCHECKED;
    }
  }
  Emit(bytecode, cp_offset);
  if (check_bounds) EmitOrLink(on_failure);
}

void RegExpBytecodeGenerator::CheckCharacterLT(base::uc16 limit,
                                               Label* on_less) {
  Emit(BC_CHECK_LT, limit);
  EmitOrLink(on_less);
}

void RegExpBytecodeGenerator::CheckCharacterGT(base::uc16 limit,
                                               Label* on_greater) {
  Emit(BC_CHECK_GT, limit);
  EmitOrLink(on_greater);
}

void RegExpBytecodeGenerator::CheckCharacter(uint32_t c, Label* on_equal) {
  if (c > MAX_FIRST_ARG) {
    Emit(BC_CHECK_4_CHARS, 0);
    Emit32(c);
  } else {
    Emit(BC_CHECK_CHAR, c);
  }
  EmitOrLink(on_equal);
}

void RegExpBytecodeGenerator::CheckAtStart(int cp_offset, Label* on_at_start) {
  Emit(BC_CHECK_AT_START, cp_offset);
  EmitOrLink(on_at_start);
}

void RegExpBytecodeGenerator::CheckNotAtStart(int cp_offset,
                                              Label* on_not_at_start) {
  Emit(BC_CHECK_NOT_AT_START, cp_offset);
  EmitOrLink(on_not_at_start);
}

void RegExpBytecodeGenerator::CheckNotCharacter(uint32_t c,
                                                Label* on_not_equal) {
  if (c > MAX_FIRST_ARG) {
    Emit(BC_CHECK_NOT_4_CHARS, 0);
    Emit32(c);
  } else {
    Emit(BC_CHECK_NOT_CHAR, c);
  }
  EmitOrLink(on_not_equal);
}

void RegExpBytecodeGenerator::CheckCharacterAfterAnd(uint32_t c, uint32_t mask,
                                                     Label* on_equal) {
  if (c > MAX_FIRST_ARG) {
    Emit(BC_AND_CHECK_4_CHARS, 0);
    Emit32(c);
  } else {
    Emit(BC_AND_CHECK_CHAR, c);
  }
  Emit32(mask);
  EmitOrLink(on_equal);
}

void RegExpBytecodeGenerator::CheckNotCharacterAfterAnd(uint32_t c,
                                                        uint32_t mask,
                                                        Label* on_not_equal) {
  if (c > MAX_FIRST_ARG) {
    Emit(BC_AND_CHECK_NOT_4_CHARS, 0);
    Emit32(c);
  } else {
    Emit(BC_AND_CHECK_NOT_CHAR, c);
  }
  Emit32(mask);
  EmitOrLink(on_not_equal);
}

void RegExpBytecodeGenerator::CheckNotCharacterAfterMinusAnd(
    base::uc16 c, base::uc16 minus, base::uc16 mask, Label* on_not_equal) {
  Emit(BC_MINUS_AND_CHECK_NOT_CHAR, c);
  Emit16(minus);
  Emit16(mask);
  EmitOrLink(on_not_equal);
}

void RegExpBytecodeGenerator::CheckCharacterInRange(base::uc16 from,
                                                    base::uc16 to,
                                                    Label* on_in_range) {
  Emit(BC_CHECK_CHAR_IN_RANGE, 0);
  Emit16(from);
  Emit16(to);
  EmitOrLink(on_in_range);
}

void RegExpBytecodeGenerator::CheckCharacterNotInRange(base::uc16 from,
                                                       base::uc16 to,
                                                       Label* on_not_in_range) {
  Emit(BC_CHECK_CHAR_NOT_IN_RANGE, 0);
  Emit16(from);
  Emit16(to);
  EmitOrLink(on_not_in_range);
}

void RegExpBytecodeGenerator::EmitSkipTable(Handle<ByteArray> table) {
  for (int i = 0; i < kTableSize; i += kBitsPerByte) {
    int byte = 0;
    for (int j = 0; j < kBitsPerByte; j++) {
      if (table->get(i + j) != 0) byte |= 1 << j;
    }
    Emit8(byte);
  }
}

void RegExpBytecodeGenerator::CheckBitInTable(Handle<ByteArray> table,
                                              Label* on_bit_set) {
  Emit(BC_CHECK_BIT_IN_TABLE, 0);
  EmitOrLink(on_bit_set);
  EmitSkipTable(table);
}

void RegExpBytecodeGenerator::SkipUntilBitInTable(
    int cp_offset, Handle<ByteArray> table, Handle<ByteArray> nibble_table,
    int advance_by) {
  Label cont;
  Emit(BC_SKIP_UNTIL_BIT_IN_TABLE, cp_offset);
  Emit32(advance_by);
  EmitSkipTable(table);
  EmitOrLink(&cont);  // goto_when_match
  EmitOrLink(&cont);  // goto_on_failure
  Bind(&cont);
}

void RegExpBytecodeGenerator::CheckNotBackReference(int start_reg,
                                                    bool read_backward,
                                                    Label* on_not_equal) {
  DCHECK_LE(0, start_reg);
  DCHECK_GE(kMaxRegister, start_reg);
  Emit(read_backward ? BC_CHECK_NOT_BACK_REF_BACKWARD : BC_CHECK_NOT_BACK_REF,
       start_reg);
  EmitOrLink(on_not_equal);
}

void RegExpBytecodeGenerator::CheckNotBackReferenceIgnoreCase(
    int start_reg, bool read_backward, bool unicode, Label* on_not_equal) {
  DCHECK_LE(0, start_reg);
  DCHECK_GE(kMaxRegister, start_reg);
  Emit(read_backward ? (unicode ? BC_CHECK_NOT_BACK_REF_NO_CASE_UNICODE_BACKWARD
                                : BC_CHECK_NOT_BACK_REF_NO_CASE_BACKWARD)
                     : (unicode ? BC_CHECK_NOT_BACK_REF_NO_CASE_UNICODE
                                : BC_CHECK_NOT_BACK_REF_NO_CASE),
       start_reg);
  EmitOrLink(on_not_equal);
}

void RegExpBytecodeGenerator::IfRegisterLT(int register_index, int comparand,
                                           Label* on_less_than) {
  DCHECK_LE(0, register_index);
  DCHECK_GE(kMaxRegister, register_index);
  Emit(BC_CHECK_REGISTER_LT, register_index);
  Emit32(comparand);
  EmitOrLink(on_less_than);
}

void RegExpBytecodeGenerator::IfRegisterGE(int register_index, int comparand,
                                           Label* on_greater_or_equal) {
  DCHECK_LE(0, register_index);
  DCHECK_GE(kMaxRegister, register_index);
  Emit(BC_CHECK_REGISTER_GE, register_index);
  Emit32(comparand);
  EmitOrLink(on_greater_or_equal);
}

void RegExpBytecodeGenerator::IfRegisterEqPos(int register_index,
                                              Label* on_eq) {
  DCHECK_LE(0, register_index);
  DCHECK_GE(kMaxRegister, register_index);
  Emit(BC_CHECK_REGISTER_EQ_POS, register_index);
  EmitOrLink(on_eq);
}

Handle<HeapObject> RegExpBytecodeGenerator::GetCode(Handle<String> source,
                                                    RegExpFlags flags) {
  Bind(&backtrack_);
  Backtrack();

  Handle<TrustedByteArray> array;
  if (v8_flags.regexp_peephole_optimization) {
    array = RegExpBytecodePeepholeOptimization::OptimizeBytecode(
        isolate_, zone(), source, buffer_.data(), length(), jump_edges_);
  } else {
    array = isolate_->factory()->NewTrustedByteArray(length());
    Copy(array->begin());
  }

  return array;
}

int RegExpBytecodeGenerator::length() { return pc_; }

void RegExpBytecodeGenerator::Copy(uint8_t* a) {
  MemCopy(a, buffer_.data(), length());
}

void RegExpBytecodeGenerator::ExpandBuffer() {
  // TODO(jgruber): The growth strategy could be smarter for large sizes.
  // TODO(jgruber): It's not necessary to default-initialize new elements.
  buffer_.resize(buffer_.size() * 2);
}

}  // namespace internal
}  // namespace v8

"""

```
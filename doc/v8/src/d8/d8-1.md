Response: The user is asking for a summary of the provided C++ code snippet, which is part of the `d8.cc` file in the V8 JavaScript engine. The snippet focuses on functionality related to asynchronous operations (Promises, async hooks), realms (JavaScript execution contexts), performance measurements, and inter-worker communication.

Here's a breakdown of the thought process to arrive at the summary:

1. **Identify Key Areas:**  Read through the code and look for distinct blocks of functionality. Keywords like `Promise`, `Realm`, `Performance`, `Worker`, and `AsyncHooks` stand out. Also, helper functions like `ReportException` and `LoadJSON` suggest additional capabilities.

2. **Analyze Function Logic:** For each identified area, understand the purpose of the functions and data structures involved.

    * **Promises and Async Hooks:**  The code deals with tracking unhandled promise rejections, adding/removing promises from this tracking, and reporting these rejections. The `AsyncHooks` section clearly relates to the asynchronous hooks API, creating hooks, and getting execution/trigger IDs.

    * **Realms:**  The code heavily involves `PerIsolateData`, which manages realms. Functions like `CreateRealm`, `DisposeRealm`, `RealmSwitch`, `RealmEval`, `RealmGlobal`, `RealmOwner`, and `RealmCurrent` indicate functionality for creating, managing, and interacting with different JavaScript execution environments (realms).

    * **Performance:**  Functions like `PerformanceNow`, `PerformanceMark`, and `PerformanceMeasure` directly correspond to the JavaScript Performance API. The `PerformanceMeasureMemory` function also points to a memory measurement API.

    * **Workers:**  The `Worker` related functions (`WorkerNew`, `WorkerPostMessage`, `WorkerGetMessage`, `WorkerOnMessageGetter/Setter`, `WorkerTerminate`, `WorkerTerminateAndWait`) clearly manage the creation and communication with Web Workers.

    * **Utilities:** Functions like `LoadJSON`, `ReportException`, and the `WriteToFile`/`ReadFile`/`ExecuteFile` family provide utility operations for input/output and error handling.

3. **Group Related Functionality:** Combine the analyzed functions into logical groups based on their purpose. This leads to the categories like Promise handling, Realm management, Performance API, Worker management, and utilities.

4. **Summarize Each Area:**  Write a concise description of the functionality within each group. Focus on the "what" rather than the "how" of the implementation.

5. **Identify JavaScript Relevance:**  Consider how the C++ code relates to JavaScript features. The names of the functions often directly correspond to JavaScript APIs (e.g., `performance.now()`, `Realm.create()`, `new Worker()`, `async_hooks.createHook()`).

6. **Create JavaScript Examples:** For the most prominent features, provide simple JavaScript code snippets that demonstrate the functionality implemented in the C++ code. Focus on demonstrating the core purpose of the feature.

7. **Structure the Summary:** Organize the summary with clear headings and bullet points for readability. Start with a general overview and then delve into specific functional areas.

8. **Refine and Review:** Read through the summary to ensure clarity, accuracy, and completeness. Check for any technical jargon that might need explanation. Ensure the JavaScript examples are correct and easy to understand.

Applying this process to the provided code snippet leads to the detailed summary and JavaScript examples previously provided. The key is to break down the code into manageable parts, understand the purpose of each part, and then synthesize that understanding into a clear and concise explanation, relating it back to its JavaScript counterparts.
这个代码片段主要负责 **处理顶层异步（Top-Level Await, TLA）模块的加载** 和 **加载并解析 JSON 文件**。

下面分别归纳其功能：

**1. 处理顶层异步模块的加载 (涉及 `LoadModule` 函数的部分):**

* **检查模块加载状态：** 代码首先检查模块是否已经加载完成。如果 `TryCatch` 没有捕获到异常，说明模块加载成功。
* **处理 Promise 异常：** 如果模块加载后返回的是一个 rejected Promise，代码会捕获该异常并报告。
* **处理顶层 `await` 导致的模块暂停：**  如果模块内部存在顶层 `await`，模块加载会暂停。代码会获取所有暂停的模块和相关的错误消息。
* **报告暂停模块的错误：** 如果存在暂停的模块，代码会提取第一个错误消息并报告。

**与 JavaScript 的关系及示例：**

顶层异步允许在模块的最外层使用 `await` 关键字，这会使得模块的加载变为异步操作。

**JavaScript 示例:**

```javascript
// module.js
console.log("模块开始加载");
await new Promise(resolve => setTimeout(resolve, 1000));
console.log("模块加载完成");
export const value = 10;
```

在 d8 中加载这个模块时，`LoadModule` 函数会处理 `await` 导致的暂停，直到 Promise resolve 后模块加载完成。如果在 Promise rejected 的情况下，`LoadModule` 会捕获并报告错误。

**2. 加载并解析 JSON 文件 (`LoadJSON` 函数):**

* **读取文件内容：** 该函数读取指定路径的 JSON 文件内容。
* **逐行解析 JSON：** 它将文件内容按行分割，并将每一行视为一个独立的 JSON 值进行解析。
* **处理解析错误：** 如果解析过程中出现任何错误，函数会捕获异常并报告。
* **支持反序列化运行计数：**  `DeserializationRunCount()` 似乎用于控制反序列化运行的次数，这可能与测试或性能分析有关。

**与 JavaScript 的关系及示例：**

此功能模拟了 JavaScript 中使用 `JSON.parse()` 解析 JSON 字符串的行为，但它是逐行处理文件内容。

**JavaScript 示例:**

假设有一个名为 `data.json` 的文件，内容如下：

```json
{"name": "Alice", "age": 30}
{"city": "New York"}
```

在 d8 中使用 `LoadJSON("data.json")`，代码会逐行解析：

* 第一行： `{"name": "Alice", "age": 30}` 会被解析成一个 JavaScript 对象。
* 第二行： `{"city": "New York"}` 会被解析成另一个 JavaScript 对象。

如果某一行不是有效的 JSON，`LoadJSON` 函数会报告错误，就像在 JavaScript 中使用 `JSON.parse()` 解析无效字符串一样。

**总结:**

这段代码片段主要负责以下两个关键功能：

* **处理 JavaScript 模块的异步加载，特别是当模块使用了顶层 `await` 时，并能处理加载过程中出现的异常。**
* **提供一个 d8 特有的功能，可以逐行读取和解析 JSON 文件，方便处理包含多个 JSON 对象的文本文件。**

这两个功能都与 JavaScript 的执行和模块化息息相关，是 d8 作为 JavaScript 运行环境所需要具备的核心能力。

Prompt: 
```
这是目录为v8/src/d8/d8.cc的一个c++源代码文件， 请归纳一下它的功能, 如果它与javascript的功能有关系，请用javascript举例说明
这是第2部分，共4部分，请归纳一下它的功能

"""
fter we create a new API for the case
      // where TLA is enabled.
      if (!try_catch.HasCaught()) {
        isolate->ThrowException(result_promise->Result());
      } else {
        DCHECK_EQ(try_catch.Exception(), result_promise->Result());
      }
      ReportException(isolate, try_catch);
      return false;
    }

    auto [stalled_modules, stalled_messages] =
        root_module->GetStalledTopLevelAwaitMessages(isolate);
    DCHECK_EQ(stalled_modules.size(), stalled_messages.size());
    if (stalled_messages.size() > 0) {
      Local<Message> message = stalled_messages[0];
      ReportException(isolate, message, v8::Exception::Error(message->Get()));
      return false;
    }
  }

  DCHECK(!try_catch.HasCaught());
  return true;
}

// Treat every line as a JSON value and parse it.
bool Shell::LoadJSON(Isolate* isolate, const char* file_name) {
  HandleScope handle_scope(isolate);
  PerIsolateData* isolate_data = PerIsolateData::Get(isolate);
  Local<Context> realm =
      isolate_data->realms_[isolate_data->realm_current_].Get(isolate);
  Context::Scope context_scope(realm);
  TryCatch try_catch(isolate);

  std::string absolute_path = NormalizePath(file_name, GetWorkingDirectory());
  int length = 0;
  std::unique_ptr<char[]> data(ReadChars(absolute_path.c_str(), &length));
  if (length == 0) {
    printf("Error reading '%s'\n", file_name);
    base::OS::ExitProcess(1);
  }
  std::stringstream stream(data.get());
  std::string line;
  while (std::getline(stream, line, '\n')) {
    for (int r = 0; r < DeserializationRunCount(); ++r) {
      Local<String> source =
          String::NewFromUtf8(isolate, line.c_str()).ToLocalChecked();
      MaybeLocal<Value> maybe_value = JSON::Parse(realm, source);

      Local<Value> value;
      if (!maybe_value.ToLocal(&value)) {
        DCHECK(try_catch.HasCaught());
        ReportException(isolate, try_catch);
        return false;
      }
    }
  }
  return true;
}

PerIsolateData::PerIsolateData(Isolate* isolate)
    : isolate_(isolate), realms_(nullptr) {
  isolate->SetData(0, this);
  if (i::v8_flags.expose_async_hooks) {
    async_hooks_wrapper_ = new AsyncHooks(isolate);
  }
  ignore_unhandled_promises_ = false;
}

PerIsolateData::~PerIsolateData() {
  isolate_->SetData(0, nullptr);  // Not really needed, just to be sure...
  if (i::v8_flags.expose_async_hooks) {
    delete async_hooks_wrapper_;  // This uses the isolate
  }
#if defined(LEAK_SANITIZER)
  for (DynamicImportData* data : import_data_) {
    delete data;
  }
#endif
}

void PerIsolateData::RemoveUnhandledPromise(Local<Promise> promise) {
  if (ignore_unhandled_promises_) return;
  // Remove handled promises from the list
  DCHECK_EQ(promise->GetIsolate(), isolate_);
  for (auto it = unhandled_promises_.begin(); it != unhandled_promises_.end();
       ++it) {
    v8::Local<v8::Promise> unhandled_promise = std::get<0>(*it).Get(isolate_);
    if (unhandled_promise == promise) {
      unhandled_promises_.erase(it--);
    }
  }
}

void PerIsolateData::AddUnhandledPromise(Local<Promise> promise,
                                         Local<Message> message,
                                         Local<Value> exception) {
  if (ignore_unhandled_promises_) return;
  DCHECK_EQ(promise->GetIsolate(), isolate_);
  unhandled_promises_.emplace_back(v8::Global<v8::Promise>(isolate_, promise),
                                   v8::Global<v8::Message>(isolate_, message),
                                   v8::Global<v8::Value>(isolate_, exception));
}

int PerIsolateData::HandleUnhandledPromiseRejections() {
  // Avoid recursive calls to HandleUnhandledPromiseRejections.
  if (ignore_unhandled_promises_) return 0;
  if (isolate_->IsExecutionTerminating()) return 0;
  ignore_unhandled_promises_ = true;
  v8::HandleScope scope(isolate_);
  // Ignore promises that get added during error reporting.
  size_t i = 0;
  for (; i < unhandled_promises_.size(); i++) {
    const auto& tuple = unhandled_promises_[i];
    Local<v8::Message> message = std::get<1>(tuple).Get(isolate_);
    Local<v8::Value> value = std::get<2>(tuple).Get(isolate_);
    Shell::ReportException(isolate_, message, value);
  }
  unhandled_promises_.clear();
  ignore_unhandled_promises_ = false;
  return static_cast<int>(i);
}

void PerIsolateData::AddDynamicImportData(DynamicImportData* data) {
#if defined(LEAK_SANITIZER)
  import_data_.insert(data);
#endif
}
void PerIsolateData::DeleteDynamicImportData(DynamicImportData* data) {
#if defined(LEAK_SANITIZER)
  import_data_.erase(data);
#endif
  delete data;
}

Local<FunctionTemplate> PerIsolateData::GetTestApiObjectCtor() const {
  return test_api_object_ctor_.Get(isolate_);
}

void PerIsolateData::SetTestApiObjectCtor(Local<FunctionTemplate> ctor) {
  test_api_object_ctor_.Reset(isolate_, ctor);
}

Local<FunctionTemplate> PerIsolateData::GetDomNodeCtor() const {
  return dom_node_ctor_.Get(isolate_);
}

void PerIsolateData::SetDomNodeCtor(Local<FunctionTemplate> ctor) {
  dom_node_ctor_.Reset(isolate_, ctor);
}

bool PerIsolateData::HasRunningSubscribedWorkers() {
  // Only consider subscribed workers, so that code that spawns a worker and
  // never subscribes to message events will quit.
  return !worker_message_callbacks_.empty();
}

void PerIsolateData::RegisterWorker(std::shared_ptr<Worker> worker) {
  registered_workers_.insert(std::move(worker));
}

void PerIsolateData::SubscribeWorkerOnMessage(
    const std::shared_ptr<Worker>& worker, Local<Context> context,
    Local<Function> callback) {
  if (!registered_workers_.contains(worker)) {
    // The worker has already terminated, so it won't be posting any more
    // messages. Don't try to subscribe to its events.
    fprintf(
        stderr,
        "Trying to subscribe to message events from a terminated worker -- "
        "consider registering the event handler before the event loop runs.\n");
    return;
  }
  worker_message_callbacks_.emplace(
      worker, std::make_pair(Global<Context>(isolate_, context),
                             Global<Function>(isolate_, callback)));
}

std::pair<Local<Context>, Local<Function>> PerIsolateData::GetWorkerOnMessage(
    const std::shared_ptr<Worker>& worker) const {
  auto it = worker_message_callbacks_.find(worker);
  if (it == worker_message_callbacks_.end()) {
    return {};
  }
  return {it->second.first.Get(isolate_), it->second.second.Get(isolate_)};
}

void PerIsolateData::UnregisterWorker(const std::shared_ptr<Worker>& worker) {
  registered_workers_.erase(worker);
  worker_message_callbacks_.erase(worker);
}

PerIsolateData::RealmScope::RealmScope(Isolate* isolate,
                                       const Global<Context>& context)
    : data_(PerIsolateData::Get(isolate)) {
  data_->realm_count_ = 1;
  data_->realm_current_ = 0;
  data_->realm_switch_ = 0;
  data_->realms_ = new Global<Context>[1];
  data_->realms_[0].Reset(data_->isolate_, context);
}

PerIsolateData::RealmScope::~RealmScope() {
  // Drop realms to avoid keeping them alive.
  data_->realm_count_ = 0;
  delete[] data_->realms_;
}

PerIsolateData::ExplicitRealmScope::ExplicitRealmScope(PerIsolateData* data,
                                                       int index)
    : data_(data), index_(index) {
  realm_ = Local<Context>::New(data->isolate_, data->realms_[index_]);
  realm_->Enter();
  previous_index_ = data->realm_current_;
  data->realm_current_ = data->realm_switch_ = index_;
}

PerIsolateData::ExplicitRealmScope::~ExplicitRealmScope() {
  realm_->Exit();
  data_->realm_current_ = data_->realm_switch_ = previous_index_;
}

Local<Context> PerIsolateData::ExplicitRealmScope::context() const {
  return realm_;
}

int PerIsolateData::RealmFind(Local<Context> context) {
  for (int i = 0; i < realm_count_; ++i) {
    if (realms_[i] == context) return i;
  }
  return -1;
}

int PerIsolateData::RealmIndexOrThrow(
    const v8::FunctionCallbackInfo<v8::Value>& info, int arg_offset) {
  if (info.Length() < arg_offset || !info[arg_offset]->IsNumber()) {
    ThrowError(info.GetIsolate(), "Invalid argument");
    return -1;
  }
  int index = info[arg_offset]
                  ->Int32Value(info.GetIsolate()->GetCurrentContext())
                  .FromMaybe(-1);
  if (index < 0 || index >= realm_count_ || realms_[index].IsEmpty()) {
    ThrowError(info.GetIsolate(), "Invalid realm index");
    return -1;
  }
  return index;
}

// GetTimestamp() returns a time stamp as double, measured in milliseconds.
// When v8_flags.verify_predictable mode is enabled it returns result of
// v8::Platform::MonotonicallyIncreasingTime().
double Shell::GetTimestamp() {
  if (i::v8_flags.verify_predictable) {
    return g_platform->MonotonicallyIncreasingTime();
  } else {
    base::TimeDelta delta = base::TimeTicks::Now() - kInitialTicks;
    return delta.InMillisecondsF();
  }
}
uint64_t Shell::GetTracingTimestampFromPerformanceTimestamp(
    double performance_timestamp) {
  // Don't use this in --verify-predictable mode, predictable timestamps don't
  // work well with tracing.
  DCHECK(!i::v8_flags.verify_predictable);
  base::TimeDelta delta =
      base::TimeDelta::FromMillisecondsD(performance_timestamp);
  // See TracingController::CurrentTimestampMicroseconds().
  int64_t internal_value = (delta + kInitialTicks).ToInternalValue();
  DCHECK_GE(internal_value, 0);
  return internal_value;
}

#ifdef V8_OS_LINUX
void SendPerfControlCommand(const char* command) {
  if (Shell::options.perf_ctl_fd != -1 && Shell::options.perf_ack_fd != -1) {
    size_t command_len = strlen(command);
    ssize_t ret = write(Shell::options.perf_ctl_fd, command, command_len);
    if (ret == -1) {
      fprintf(stderr, "perf_ctl write error: %s\n", strerror(errno));
    }
    CHECK_EQ(ret, command_len);

    char ack[5];
    ret = read(Shell::options.perf_ack_fd, ack, 5);
    if (ret == -1) {
      fprintf(stderr, "perf_ack read error: %s\n", strerror(errno));
    }
    CHECK_EQ(ret, 5);
    CHECK_EQ(strcmp(ack, "ack\n"), 0);
  }
}
#endif

// performance.now() returns GetTimestamp().
void Shell::PerformanceNow(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  info.GetReturnValue().Set(GetTimestamp());
}

// performance.mark() records and returns a PerformanceEntry with the current
// timestamp.
void Shell::PerformanceMark(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  Local<Context> context = isolate->GetCurrentContext();

  if (info.Length() < 1 || !info[0]->IsString()) {
    ThrowError(info.GetIsolate(), "Invalid 'name' argument");
    return;
  }
  Local<String> name = info[0].As<String>();

  double timestamp = GetTimestamp();

  Local<Object> performance_entry = Object::New(isolate);
  performance_entry
      ->DefineOwnProperty(context,
                          String::NewFromUtf8Literal(isolate, "entryType"),
                          String::NewFromUtf8Literal(isolate, "mark"), ReadOnly)
      .Check();
  performance_entry
      ->DefineOwnProperty(context, String::NewFromUtf8Literal(isolate, "name"),
                          name, ReadOnly)
      .Check();
  performance_entry
      ->DefineOwnProperty(context,
                          String::NewFromUtf8Literal(isolate, "startTime"),
                          Number::New(isolate, timestamp), ReadOnly)
      .Check();
  performance_entry
      ->DefineOwnProperty(context,
                          String::NewFromUtf8Literal(isolate, "duration"),
                          Integer::New(isolate, 0), ReadOnly)
      .Check();

  info.GetReturnValue().Set(performance_entry);

#ifdef V8_OS_LINUX
  if (options.scope_linux_perf_to_mark_measure) {
    SendPerfControlCommand("enable");
  }
#endif
}

// performance.measure() records and returns a PerformanceEntry with a duration
// since a given mark, or since zero.
void Shell::PerformanceMeasure(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  Local<Context> context = isolate->GetCurrentContext();

  if (info.Length() < 1 || !info[0]->IsString()) {
    ThrowError(info.GetIsolate(), "Invalid 'name' argument");
    return;
  }
  v8::Local<String> name = info[0].As<String>();

  double start_timestamp = 0;
  if (info.Length() >= 2) {
#ifdef V8_OS_LINUX
    if (options.scope_linux_perf_to_mark_measure) {
      SendPerfControlCommand("disable");
    }
#endif

    Local<Value> start_mark = info[1].As<Value>();
    if (!start_mark->IsObject()) {
      ThrowError(info.GetIsolate(),
                 "Invalid 'startMark' argument: Not an Object");
      return;
    }
    Local<Value> start_time_field;
    if (!start_mark.As<Object>()
             ->Get(context, String::NewFromUtf8Literal(isolate, "startTime"))
             .ToLocal(&start_time_field)) {
      return;
    }
    if (!start_time_field->IsNumber()) {
      ThrowError(info.GetIsolate(),
                 "Invalid 'startMark' argument: No numeric 'startTime' field");
      return;
    }
    start_timestamp = start_time_field.As<Number>()->Value();
  }
  if (info.Length() > 2) {
    ThrowError(info.GetIsolate(), "Too many arguments");
    return;
  }

  double end_timestamp = GetTimestamp();

  if (options.trace_enabled) {
    size_t hash = base::hash_combine(name->GetIdentityHash(), start_timestamp,
                                     end_timestamp);

    String::Utf8Value utf8(isolate, name);
    TRACE_EVENT_COPY_NESTABLE_ASYNC_BEGIN_WITH_TIMESTAMP1(
        "v8", *utf8, static_cast<uint64_t>(hash),
        GetTracingTimestampFromPerformanceTimestamp(start_timestamp),
        "startTime", start_timestamp);
    TRACE_EVENT_COPY_NESTABLE_ASYNC_END_WITH_TIMESTAMP0(
        "v8", *utf8, static_cast<uint64_t>(hash),
        GetTracingTimestampFromPerformanceTimestamp(end_timestamp));
  }

  Local<Object> performance_entry = Object::New(isolate);
  performance_entry
      ->DefineOwnProperty(
          context, String::NewFromUtf8Literal(isolate, "entryType"),
          String::NewFromUtf8Literal(isolate, "measure"), ReadOnly)
      .Check();
  performance_entry
      ->DefineOwnProperty(context, String::NewFromUtf8Literal(isolate, "name"),
                          name, ReadOnly)
      .Check();
  performance_entry
      ->DefineOwnProperty(context,
                          String::NewFromUtf8Literal(isolate, "startTime"),
                          Number::New(isolate, start_timestamp), ReadOnly)
      .Check();
  performance_entry
      ->DefineOwnProperty(
          context, String::NewFromUtf8Literal(isolate, "duration"),
          Number::New(isolate, end_timestamp - start_timestamp), ReadOnly)
      .Check();

  info.GetReturnValue().Set(performance_entry);
}

// performance.measureMemory() implements JavaScript Memory API proposal.
// See https://github.com/ulan/javascript-agent-memory/blob/master/explainer.md.
void Shell::PerformanceMeasureMemory(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  v8::MeasureMemoryMode mode = v8::MeasureMemoryMode::kSummary;
  v8::Isolate* isolate = info.GetIsolate();
  Local<Context> context = isolate->GetCurrentContext();
  if (info.Length() >= 1 && info[0]->IsObject()) {
    Local<Object> object = info[0].As<Object>();
    Local<Value> value = TryGetValue(isolate, context, object, "detailed")
                             .FromMaybe(Local<Value>());
    if (value.IsEmpty()) {
      // Exception was thrown and scheduled, so return from the callback.
      return;
    }
    if (value->IsBoolean() && value->BooleanValue(isolate)) {
      mode = v8::MeasureMemoryMode::kDetailed;
    }
  }
  Local<v8::Promise::Resolver> promise_resolver =
      v8::Promise::Resolver::New(context).ToLocalChecked();
  info.GetIsolate()->MeasureMemory(
      v8::MeasureMemoryDelegate::Default(isolate, context, promise_resolver,
                                         mode),
      v8::MeasureMemoryExecution::kEager);
  info.GetReturnValue().Set(promise_resolver->GetPromise());
}

// Realm.current() returns the index of the currently active realm.
void Shell::RealmCurrent(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  PerIsolateData* data = PerIsolateData::Get(isolate);
  int index = data->RealmFind(isolate->GetEnteredOrMicrotaskContext());
  if (index == -1) return;
  info.GetReturnValue().Set(index);
}

// Realm.owner(o) returns the index of the realm that created o.
void Shell::RealmOwner(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  PerIsolateData* data = PerIsolateData::Get(isolate);
  if (info.Length() < 1 || !info[0]->IsObject()) {
    ThrowError(info.GetIsolate(), "Invalid argument");
    return;
  }
  Local<Object> object =
      info[0]->ToObject(isolate->GetCurrentContext()).ToLocalChecked();
  i::Handle<i::JSReceiver> i_object = Utils::OpenHandle(*object);
  if (IsJSGlobalProxy(*i_object) &&
      i::Cast<i::JSGlobalProxy>(i_object)->IsDetached()) {
    return;
  }
  Local<Context> creation_context;
  if (!object->GetCreationContext(isolate).ToLocal(&creation_context)) {
    ThrowError(info.GetIsolate(), "object doesn't have creation context");
    return;
  }
  int index = data->RealmFind(creation_context);
  if (index == -1) return;
  info.GetReturnValue().Set(index);
}

// Realm.global(i) returns the global object of realm i.
// (Note that properties of global objects cannot be read/written cross-realm.)
void Shell::RealmGlobal(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  PerIsolateData* data = PerIsolateData::Get(info.GetIsolate());
  int index = data->RealmIndexOrThrow(info, 0);
  if (index == -1) return;
  // TODO(chromium:324812): Ideally Context::Global should never return raw
  // global objects but return a global proxy. Currently it returns global
  // object when the global proxy is detached from the global object. The
  // following is a workaround till we fix Context::Global so we don't leak
  // global objects.
  Local<Object> global =
      Local<Context>::New(info.GetIsolate(), data->realms_[index])->Global();
  i::Handle<i::Object> i_global = Utils::OpenHandle(*global);
  if (IsJSGlobalObject(*i_global)) {
    i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(info.GetIsolate());
    i::Handle<i::JSObject> i_global_proxy =
        handle(i::Cast<i::JSGlobalObject>(i_global)->global_proxy(), i_isolate);
    global = Utils::ToLocal(i_global_proxy);
  }
  info.GetReturnValue().Set(global);
}

MaybeLocal<Context> Shell::CreateRealm(
    const v8::FunctionCallbackInfo<v8::Value>& info, int index,
    v8::MaybeLocal<Value> global_object) {
  DCHECK(i::ValidateCallbackInfo(info));
  const char* kGlobalHandleLabel = "d8::realm";
  Isolate* isolate = info.GetIsolate();
  TryCatch try_catch(isolate);
  PerIsolateData* data = PerIsolateData::Get(isolate);
  if (index < 0) {
    Global<Context>* old_realms = data->realms_;
    index = data->realm_count_;
    data->realms_ = new Global<Context>[++data->realm_count_];
    for (int i = 0; i < index; ++i) {
      Global<Context>& realm = data->realms_[i];
      realm.Reset(isolate, old_realms[i]);
      if (!realm.IsEmpty()) {
        realm.AnnotateStrongRetainer(kGlobalHandleLabel);
      }
      old_realms[i].Reset();
    }
    delete[] old_realms;
  }
  Local<ObjectTemplate> global_template = CreateGlobalTemplate(isolate);
  Local<Context> context =
      Context::New(isolate, nullptr, global_template, global_object);
  if (context.IsEmpty()) return MaybeLocal<Context>();
  DCHECK(!try_catch.HasCaught());
  InitializeModuleEmbedderData(context);
  data->realms_[index].Reset(isolate, context);
  data->realms_[index].AnnotateStrongRetainer(kGlobalHandleLabel);
  info.GetReturnValue().Set(index);
  return context;
}

void Shell::DisposeRealm(const v8::FunctionCallbackInfo<v8::Value>& info,
                         int index) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  PerIsolateData* data = PerIsolateData::Get(isolate);
  Local<Context> context = data->realms_[index].Get(isolate);
  data->realms_[index].Reset();
  // ContextDisposedNotification expects the disposed context to be entered.
  v8::Context::Scope scope(context);
  isolate->ContextDisposedNotification();
}

// Realm.create() creates a new realm with a distinct security token
// and returns its index.
void Shell::RealmCreate(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  CreateRealm(info, -1, v8::MaybeLocal<Value>());
}

// Realm.createAllowCrossRealmAccess() creates a new realm with the same
// security token as the current realm.
void Shell::RealmCreateAllowCrossRealmAccess(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Local<Context> context;
  if (CreateRealm(info, -1, v8::MaybeLocal<Value>()).ToLocal(&context)) {
    context->SetSecurityToken(
        info.GetIsolate()->GetEnteredOrMicrotaskContext()->GetSecurityToken());
  }
}

// Realm.navigate(i) creates a new realm with a distinct security token
// in place of realm i.
void Shell::RealmNavigate(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  PerIsolateData* data = PerIsolateData::Get(isolate);
  int index = data->RealmIndexOrThrow(info, 0);
  if (index == -1) return;
  if (index == 0 || index == data->realm_current_ ||
      index == data->realm_switch_) {
    ThrowError(info.GetIsolate(), "Invalid realm index");
    return;
  }

  Local<Context> context = Local<Context>::New(isolate, data->realms_[index]);
  v8::MaybeLocal<Value> global_object = context->Global();

  // Context::Global doesn't return JSGlobalProxy if DetachGlobal is called in
  // advance.
  if (!global_object.IsEmpty()) {
    HandleScope scope(isolate);
    if (!IsJSGlobalProxy(
            *Utils::OpenDirectHandle(*global_object.ToLocalChecked()))) {
      global_object = v8::MaybeLocal<Value>();
    }
  }

  DisposeRealm(info, index);
  CreateRealm(info, index, global_object);
}

// Realm.detachGlobal(i) detaches the global objects of realm i from realm i.
void Shell::RealmDetachGlobal(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  PerIsolateData* data = PerIsolateData::Get(isolate);
  int index = data->RealmIndexOrThrow(info, 0);
  if (index == -1) return;
  if (index == 0 || index == data->realm_current_ ||
      index == data->realm_switch_) {
    ThrowError(info.GetIsolate(), "Invalid realm index");
    return;
  }

  HandleScope scope(isolate);
  Local<Context> realm = Local<Context>::New(isolate, data->realms_[index]);
  realm->DetachGlobal();
}

// Realm.dispose(i) disposes the reference to the realm i.
void Shell::RealmDispose(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  PerIsolateData* data = PerIsolateData::Get(isolate);
  int index = data->RealmIndexOrThrow(info, 0);
  if (index == -1) return;
  if (index == 0 || index == data->realm_current_ ||
      index == data->realm_switch_) {
    ThrowError(info.GetIsolate(), "Invalid realm index");
    return;
  }
  DisposeRealm(info, index);
}

// Realm.switch(i) switches to the realm i for consecutive interactive inputs.
void Shell::RealmSwitch(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  PerIsolateData* data = PerIsolateData::Get(isolate);
  int index = data->RealmIndexOrThrow(info, 0);
  if (index == -1) return;
  data->realm_switch_ = index;
}

// Realm.eval(i, s) evaluates s in realm i and returns the result.
void Shell::RealmEval(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  PerIsolateData* data = PerIsolateData::Get(isolate);
  int index = data->RealmIndexOrThrow(info, 0);
  if (index == -1) return;
  if (info.Length() < 2) {
    ThrowError(isolate, "Invalid argument");
    return;
  }

  Local<String> source;
  if (!ReadSource(info, 1, CodeType::kString).ToLocal(&source)) {
    ThrowError(isolate, "Invalid argument");
    return;
  }
  ScriptOrigin origin =
      CreateScriptOrigin(isolate, String::NewFromUtf8Literal(isolate, "(d8)"),
                         ScriptType::kClassic);

  if (isolate->IsExecutionTerminating()) return;
  ScriptCompiler::Source script_source(source, origin);
  Local<UnboundScript> script;
  if (!ScriptCompiler::CompileUnboundScript(isolate, &script_source)
           .ToLocal(&script)) {
    return;
  }
  Local<Value> result;
  {
    PerIsolateData::ExplicitRealmScope realm_scope(data, index);
    if (!script->BindToCurrentContext()
             ->Run(realm_scope.context())
             .ToLocal(&result)) {
      return;
    }
  }
  info.GetReturnValue().Set(result);
}

// Realm.shared is an accessor for a single shared value across realms.
void Shell::RealmSharedGet(Local<Name> property,
                           const PropertyCallbackInfo<Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  PerIsolateData* data = PerIsolateData::Get(isolate);
  if (data->realm_shared_.IsEmpty()) return;
  info.GetReturnValue().Set(data->realm_shared_);
}

void Shell::RealmSharedSet(Local<Name> property, Local<Value> value,
                           const PropertyCallbackInfo<void>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  PerIsolateData* data = PerIsolateData::Get(isolate);
  data->realm_shared_.Reset(isolate, value);
}

void Shell::LogGetAndStop(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);
  HandleScope handle_scope(isolate);

  std::string file_name = i_isolate->v8_file_logger()->file_name();
  if (!i::LogFile::IsLoggingToTemporaryFile(file_name)) {
    ThrowError(isolate, "Only capturing from temporary files is supported.");
    return;
  }
  if (!i_isolate->v8_file_logger()->is_logging()) {
    ThrowError(isolate, "Logging not enabled.");
    return;
  }

  std::string raw_log;
  FILE* log_file = i_isolate->v8_file_logger()->TearDownAndGetLogFile();
  if (!log_file) {
    ThrowError(isolate, "Log file does not exist.");
    return;
  }

  bool exists = false;
  raw_log = i::ReadFile(log_file, &exists, true);
  base::Fclose(log_file);

  if (!exists) {
    ThrowError(isolate, "Unable to read log file.");
    return;
  }
  Local<String> result =
      String::NewFromUtf8(isolate, raw_log.c_str(), NewStringType::kNormal,
                          static_cast<int>(raw_log.size()))
          .ToLocalChecked();

  info.GetReturnValue().Set(result);
}

void Shell::TestVerifySourcePositions(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  Isolate* isolate = info.GetIsolate();
  // Check if the argument is a valid function.
  if (info.Length() != 1) {
    ThrowError(isolate, "Expected function as single argument.");
    return;
  }
  auto arg_handle = Utils::OpenHandle(*info[0]);
  if (!IsHeapObject(*arg_handle) ||
      !IsJSFunctionOrBoundFunctionOrWrappedFunction(
          *i::Cast<i::HeapObject>(arg_handle))) {
    ThrowError(isolate, "Expected function as single argument.");
    return;
  }

  i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);
  HandleScope handle_scope(isolate);

  auto callable =
      i::Cast<i::JSFunctionOrBoundFunctionOrWrappedFunction>(arg_handle);
  while (IsJSBoundFunction(*callable)) {
    internal::DisallowGarbageCollection no_gc;
    auto bound_function = i::Cast<i::JSBoundFunction>(callable);
    auto bound_target = bound_function->bound_target_function();
    if (!IsJSFunctionOrBoundFunctionOrWrappedFunction(bound_target)) {
      internal::AllowGarbageCollection allow_gc;
      ThrowError(isolate, "Expected function as bound target.");
      return;
    }
    callable = handle(
        i::Cast<i::JSFunctionOrBoundFunctionOrWrappedFunction>(bound_target),
        i_isolate);
  }

  i::DirectHandle<i::JSFunction> function = i::Cast<i::JSFunction>(callable);
  if (!function->shared()->HasBytecodeArray()) {
    ThrowError(isolate, "Function has no BytecodeArray attached.");
    return;
  }
  i::Handle<i::BytecodeArray> bytecodes =
      handle(function->shared()->GetBytecodeArray(i_isolate), i_isolate);
  i::interpreter::BytecodeArrayIterator bytecode_iterator(bytecodes);
  bool has_baseline = function->shared()->HasBaselineCode();
  i::Handle<i::TrustedByteArray> bytecode_offsets;
  std::unique_ptr<i::baseline::BytecodeOffsetIterator> offset_iterator;
  if (has_baseline) {
    bytecode_offsets = handle(
        i::Cast<i::TrustedByteArray>(
            function->shared()->GetCode(i_isolate)->bytecode_offset_table()),
        i_isolate);
    offset_iterator = std::make_unique<i::baseline::BytecodeOffsetIterator>(
        bytecode_offsets, bytecodes);
    // A freshly initiated BytecodeOffsetIterator points to the prologue.
    DCHECK_EQ(offset_iterator->current_pc_start_offset(), 0);
    DCHECK_EQ(offset_iterator->current_bytecode_offset(),
              i::kFunctionEntryBytecodeOffset);
    offset_iterator->Advance();
  }
  while (!bytecode_iterator.done()) {
    if (has_baseline) {
      if (offset_iterator->current_bytecode_offset() !=
          bytecode_iterator.current_offset()) {
        ThrowError(isolate, "Baseline bytecode offset mismatch.");
        return;
      }
      // Check that we map every address to this bytecode correctly.
      // The start address is exclusive and the end address inclusive.
      for (i::Address pc = offset_iterator->current_pc_start_offset() + 1;
           pc <= offset_iterator->current_pc_end_offset(); ++pc) {
        i::baseline::BytecodeOffsetIterator pc_lookup(bytecode_offsets,
                                                      bytecodes);
        pc_lookup.AdvanceToPCOffset(pc);
        if (pc_lookup.current_bytecode_offset() !=
            bytecode_iterator.current_offset()) {
          ThrowError(isolate,
                     "Baseline bytecode offset mismatch for PC lookup.");
          return;
        }
      }
    }
    bytecode_iterator.Advance();
    if (has_baseline && !bytecode_iterator.done()) {
      if (offset_iterator->done()) {
        ThrowError(isolate, "Missing bytecode(s) in baseline offset mapping.");
        return;
      }
      offset_iterator->Advance();
    }
  }
  if (has_baseline && !offset_iterator->done()) {
    ThrowError(isolate, "Excess offsets in baseline offset mapping.");
    return;
  }
}

void Shell::InstallConditionalFeatures(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  Isolate* isolate = info.GetIsolate();
  isolate->InstallConditionalFeatures(isolate->GetCurrentContext());
}

void Shell::EnableJSPI(const v8::FunctionCallbackInfo<v8::Value>& info) {
  Isolate* isolate = info.GetIsolate();
  isolate->SetWasmJSPIEnabledCallback([](auto) { return true; });
  isolate->InstallConditionalFeatures(isolate->GetCurrentContext());
}

// async_hooks.createHook() registers functions to be called for different
// lifetime events of each async operation.
void Shell::AsyncHooksCreateHook(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  Local<Object> wrap =
      PerIsolateData::Get(info.GetIsolate())->GetAsyncHooks()->CreateHook(info);
  info.GetReturnValue().Set(wrap);
}

// async_hooks.executionAsyncId() returns the asyncId of the current execution
// context.
void Shell::AsyncHooksExecutionAsyncId(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  Isolate* isolate = info.GetIsolate();
  HandleScope handle_scope(isolate);
  info.GetReturnValue().Set(v8::Number::New(
      isolate,
      PerIsolateData::Get(isolate)->GetAsyncHooks()->GetExecutionAsyncId()));
}

void Shell::AsyncHooksTriggerAsyncId(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  Isolate* isolate = info.GetIsolate();
  HandleScope handle_scope(isolate);
  info.GetReturnValue().Set(v8::Number::New(
      isolate,
      PerIsolateData::Get(isolate)->GetAsyncHooks()->GetTriggerAsyncId()));
}

static v8::debug::DebugDelegate dummy_delegate;

void Shell::EnableDebugger(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::debug::SetDebugDelegate(info.GetIsolate(), &dummy_delegate);
}

void Shell::DisableDebugger(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::debug::SetDebugDelegate(info.GetIsolate(), nullptr);
}

void Shell::SetPromiseHooks(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  if (i::v8_flags.correctness_fuzzer_suppressions) {
    // Setting promise hooks dynamically has unexpected timing side-effects
    // with certain promise optimizations. We might not get all callbacks for
    // previously scheduled Promises or optimized code-paths that skip Promise
    // creation.
    ThrowError(isolate,
               "d8.promise.setHooks is disabled with "
               "--correctness-fuzzer-suppressions");
    return;
  }
#ifdef V8_ENABLE_JAVASCRIPT_PROMISE_HOOKS
  Local<Context> context = isolate->GetCurrentContext();
  HandleScope handle_scope(isolate);

  context->SetPromiseHooks(
      info[0]->IsFunction() ? info[0].As<Function>() : Local<Function>(),
      info[1]->IsFunction() ? info[1].As<Function>() : Local<Function>(),
      info[2]->IsFunction() ? info[2].As<Function>() : Local<Function>(),
      info[3]->IsFunction() ? info[3].As<Function>() : Local<Function>());

  info.GetReturnValue().Set(v8::Undefined(isolate));
#else   // V8_ENABLE_JAVASCRIPT_PROMISE_HOOKS
  ThrowError(isolate,
             "d8.promise.setHooks is disabled due to missing build flag "
             "v8_enabale_javascript_in_promise_hooks");
#endif  // V8_ENABLE_JAVASCRIPT_PROMISE_HOOKS
}

void Shell::SerializerSerialize(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  HandleScope handle_scope(isolate);
  Local<Context> context = isolate->GetCurrentContext();

  ValueSerializer serializer(isolate);
  serializer.WriteHeader();
  for (int i = 0; i < info.Length(); i++) {
    bool ok;
    if (!serializer.WriteValue(context, info[i]).To(&ok)) return;
  }
  Local<v8::ArrayBuffer> buffer;
  {
    std::pair<uint8_t*, size_t> pair = serializer.Release();
    buffer = ArrayBuffer::New(isolate, pair.second);
    memcpy(buffer->GetBackingStore()->Data(), pair.first, pair.second);
    free(pair.first);
  }
  info.GetReturnValue().Set(buffer);
}

void Shell::SerializerDeserialize(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  HandleScope handle_scope(isolate);
  Local<Context> context = isolate->GetCurrentContext();

  if (!info[0]->IsArrayBuffer()) {
    ThrowError(isolate, "Can only deserialize from an ArrayBuffer");
    return;
  }
  std::shared_ptr<BackingStore> backing_store =
      info[0].As<ArrayBuffer>()->GetBackingStore();
  ValueDeserializer deserializer(
      isolate, static_cast<const uint8_t*>(backing_store->Data()),
      backing_store->ByteLength());
  bool ok;
  if (!deserializer.ReadHeader(context).To(&ok)) return;
  Local<Value> result;
  if (!deserializer.ReadValue(context).ToLocal(&result)) return;
  info.GetReturnValue().Set(result);
}

void Shell::ProfilerSetOnProfileEndListener(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  HandleScope handle_scope(isolate);
  if (!info[0]->IsFunction()) {
    ThrowError(isolate, "The OnProfileEnd listener has to be a function");
    return;
  }
  base::MutexGuard lock_guard(&profiler_end_callback_lock_);
  profiler_end_callback_[isolate] =
      std::make_pair(Global<Function>(isolate, info[0].As<Function>()),
                     Global<Context>(isolate, isolate->GetCurrentContext()));
}

bool Shell::HasOnProfileEndListener(Isolate* isolate) {
  base::MutexGuard lock_guard(&profiler_end_callback_lock_);
  return profiler_end_callback_.find(isolate) != profiler_end_callback_.end();
}

void Shell::ResetOnProfileEndListener(Isolate* isolate) {
  // If the inspector is enabled, then the installed console is not the
  // D8Console.
  if (options.enable_inspector) return;
  {
    base::MutexGuard lock_guard(&profiler_end_callback_lock_);
    profiler_end_callback_.erase(isolate);
  }

  i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);
  D8Console* console =
      reinterpret_cast<D8Console*>(i_isolate->console_delegate());
  if (console) {
    console->DisposeProfiler();
  }
}

void Shell::ProfilerTriggerSample(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  Isolate* isolate = info.GetIsolate();
  i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);
  D8Console* console =
      reinterpret_cast<D8Console*>(i_isolate->console_delegate());
  if (console && console->profiler()) {
    console->profiler()->CollectSample(isolate);
  }
}

void Shell::TriggerOnProfileEndListener(Isolate* isolate, std::string profile) {
  CHECK(HasOnProfileEndListener(isolate));
  Local<Function> callback;
  Local<Context> context;
  Local<Value> argv[1] = {
      String::NewFromUtf8(isolate, profile.c_str()).ToLocalChecked()};
  {
    base::MutexGuard lock_guard(&profiler_end_callback_lock_);
    auto& callback_pair = profiler_end_callback_[isolate];
    callback = callback_pair.first.Get(isolate);
    context = callback_pair.second.Get(isolate);
  }
  TryCatch try_catch(isolate);
  try_catch.SetVerbose(true);
  USE(callback->Call(context, Undefined(isolate), 1, argv));
}

void WriteToFile(FILE* file, const v8::FunctionCallbackInfo<v8::Value>& info,
                 int first_arg_index = 0) {
  for (int i = first_arg_index; i < info.Length(); i++) {
    HandleScope handle_scope(info.GetIsolate());
    if (i != first_arg_index) {
      fprintf(file, " ");
    }

    // Explicitly catch potential exceptions in toString().
    v8::TryCatch try_catch(info.GetIsolate());
    Local<Value> arg = info[i];
    Local<String> str_obj;

    if (arg->IsSymbol()) {
      arg = arg.As<Symbol>()->Description(info.GetIsolate());
    }
    if (!arg->ToString(info.GetIsolate()->GetCurrentContext())
             .ToLocal(&str_obj)) {
      try_catch.ReThrow();
      return;
    }

    v8::String::Utf8Value str(info.GetIsolate(), str_obj);
    size_t n = fwrite(*str, sizeof(**str), str.length(), file);
    if (n != str.length()) {
      printf("Error in fwrite\n");
      base::OS::ExitProcess(1);
    }
  }
}

void WriteAndFlush(FILE* file,
                   const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  WriteToFile(file, info);
  fprintf(file, "\n");
  fflush(file);
}

void Shell::Print(const v8::FunctionCallbackInfo<v8::Value>& info) {
  WriteAndFlush(stdout, info);
}

void Shell::PrintErr(const v8::FunctionCallbackInfo<v8::Value>& info) {
  WriteAndFlush(stderr, info);
}

void Shell::WriteStdout(const v8::FunctionCallbackInfo<v8::Value>& info) {
  WriteToFile(stdout, info);
}

// There are two overloads of writeFile().
//
// The first parameter is always the filename.
//
// If there are exactly 2 arguments, and the second argument is an ArrayBuffer
// or an ArrayBufferView, write the binary contents into the file.
//
// Otherwise, convert arguments to UTF-8 strings, and write them to the file,
// separated by space.
void Shell::WriteFile(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  String::Utf8Value file_name(info.GetIsolate(), info[0]);
  if (*file_name == nullptr) {
    ThrowError(info.GetIsolate(), "Error converting filename to string");
    return;
  }
  FILE* file;
  if (info.Length() == 2 &&
      (info[1]->IsArrayBuffer() || info[1]->IsArrayBufferView())) {
    file = base::Fopen(*file_name, "wb");
    if (file == nullptr) {
      ThrowError(info.GetIsolate(), "Error opening file");
      return;
    }

    void* data;
    size_t length;
    if (info[1]->IsArrayBuffer()) {
      Local<v8::ArrayBuffer> buffer = Local<v8::ArrayBuffer>::Cast(info[1]);
      length = buffer->ByteLength();
      data = buffer->Data();
    } else {
      Local<v8::ArrayBufferView> buffer_view =
          Local<v8::ArrayBufferView>::Cast(info[1]);
      length = buffer_view->ByteLength();
      data = static_cast<uint8_t*>(buffer_view->Buffer()->Data()) +
             buffer_view->ByteOffset();
    }
    fwrite(data, 1, length, file);
  } else {
    file = base::Fopen(*file_name, "w");
    if (file == nullptr) {
      ThrowError(info.GetIsolate(), "Error opening file");
      return;
    }
    WriteToFile(file, info, 1);
  }
  base::Fclose(file);
}

void Shell::ReadFile(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  String::Utf8Value file_name(info.GetIsolate(), info[0]);
  if (*file_name == nullptr) {
    ThrowError(info.GetIsolate(), "Error converting filename to string");
    return;
  }
  if (info.Length() == 2) {
    String::Utf8Value format(info.GetIsolate(), info[1]);
    if (*format && std::strcmp(*format, "binary") == 0) {
      ReadBuffer(info);
      return;
    }
  }
  Local<String> source;
  if (!ReadFile(info.GetIsolate(), *file_name).ToLocal(&source)) return;
  info.GetReturnValue().Set(source);
}

Local<String> Shell::ReadFromStdin(Isolate* isolate) {
  static const int kBufferSize = 256;
  char buffer[kBufferSize];
  Local<String> accumulator = String::NewFromUtf8Literal(isolate, "");
  int length;
  // Flush stdout before reading stdin, as stdout isn't guaranteed to be flushed
  // automatically.
  fflush(stdout);
  while (true) {
    // Continue reading if the line ends with an escape '\\' or the line has
    // not been fully read into the buffer yet (does not end with '\n').
    // If fgets gets an error, just give up.
    char* input = nullptr;
    input = fgets(buffer, kBufferSize, stdin);
    if (input == nullptr) return Local<String>();
    length = static_cast<int>(strlen(buffer));
    if (length == 0) {
      return accumulator;
    } else if (buffer[length - 1] != '\n') {
      accumulator = String::Concat(
          isolate, accumulator,
          String::NewFromUtf8(isolate, buffer, NewStringType::kNormal, length)
              .ToLocalChecked());
    } else if (length > 1 && buffer[length - 2] == '\\') {
      buffer[length - 2] = '\n';
      accumulator =
          String::Concat(isolate, accumulator,
                         String::NewFromUtf8(isolate, buffer,
                                             NewStringType::kNormal, length - 1)
                             .ToLocalChecked());
    } else {
      return String::Concat(
          isolate, accumulator,
          String::NewFromUtf8(isolate, buffer, NewStringType::kNormal,
                              length - 1)
              .ToLocalChecked());
    }
  }
}

void Shell::ExecuteFile(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  for (int i = 0; i < info.Length(); i++) {
    HandleScope handle_scope(isolate);
    String::Utf8Value file_name(isolate, info[i]);
    if (*file_name == nullptr) {
      std::ostringstream oss;
      oss << "Cannot convert file[" << i << "] name to string.";
      ThrowError(
          isolate,
          String::NewFromUtf8(isolate, oss.str().c_str()).ToLocalChecked());
      return;
    }
    Local<String> source;
    if (!ReadFile(isolate, *file_name).ToLocal(&source)) return;
    if (!ExecuteString(
            info.GetIsolate(), source,
            String::NewFromUtf8(isolate, *file_name).ToLocalChecked(),
            options.quiet_load ? kNoReportExceptions : kReportExceptions)) {
      std::ostringstream oss;
      oss << "Error executing file: \"" << *file_name << '"';
      ThrowError(
          isolate,
          String::NewFromUtf8(isolate, oss.str().c_str()).ToLocalChecked());
      return;
    }
  }
}

class SetTimeoutTask : public v8::Task {
 public:
  SetTimeoutTask(v8::Isolate* isolate, v8::Local<v8::Context> context,
                 v8::Local<v8::Function> callback)
      : isolate_(isolate),
        context_(isolate, context),
        callback_(isolate, callback) {}

  void Run() override {
    HandleScope scope(isolate_);
    Local<Context> context = context_.Get(isolate_);
    Local<Function> callback = callback_.Get(isolate_);
    Context::Scope context_scope(context);
    MaybeLocal<Value> result =
        callback->Call(context, Undefined(isolate_), 0, nullptr);
    USE(result);
  }

 private:
  v8::Isolate* isolate_;
  v8::Global<v8::Context> context_;
  v8::Global<v8::Function> callback_;
};

void Shell::SetTimeout(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  info.GetReturnValue().Set(v8::Number::New(isolate, 0));
  if (info.Length() == 0 || !info[0]->IsFunction()) return;
  Local<Function> callback = info[0].As<Function>();
  Local<Context> context = isolate->GetCurrentContext();
  g_platform->GetForegroundTaskRunner(isolate)->PostTask(
      std::make_unique<SetTimeoutTask>(isolate, context, callback));
}

#ifdef V8_ENABLE_CONTINUATION_PRESERVED_EMBEDDER_DATA
void Shell::GetContinuationPreservedEmbedderData(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  info.GetReturnValue().Set(
      info.GetIsolate()->GetContinuationPreservedEmbedderData());
}
#endif  // V8_ENABLE_CONTINUATION_PRESERVED_EMBEDDER_DATA

void Shell::GetExtrasBindingObject(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  Local<Context> context = info.GetIsolate()->GetCurrentContext();
  info.GetReturnValue().Set(context->GetExtrasBindingObject());
}

void Shell::ReadCodeTypeAndArguments(
    const v8::FunctionCallbackInfo<v8::Value>& info, int index,
    CodeType* code_type, Local<Value>* arguments) {
  Isolate* isolate = info.GetIsolate();
  if (info.Length() > index && info[index]->IsObject()) {
    Local<Object> object = info[index].As<Object>();
    Local<Context> context = isolate->GetCurrentContext();
    Local<Value> value;
    if (!TryGetValue(isolate, context, object, "type").ToLocal(&value)) {
      *code_type = CodeType::kNone;
      return;
    }
    if (!value->IsString()) {
      *code_type = CodeType::kInvalid;
      return;
    }
    Local<String> worker_type_string =
        value->ToString(context).ToLocalChecked();
    String::Utf8Value str(isolate, worker_type_string);
    if (strcmp("classic", *str) == 0) {
      *code_type = CodeType::kFileName;
    } else if (strcmp("string", *str) == 0) {
      *code_type = CodeType::kString;
    } else if (strcmp("function", *str) == 0) {
      *code_type = CodeType::kFunction;
    } else {
      *code_type = CodeType::kInvalid;
    }
    if (arguments != nullptr) {
      bool got_arguments =
          TryGetValue(isolate, context, object, "arguments").ToLocal(arguments);
      USE(got_arguments);
    }
  } else {
    *code_type = CodeType::kNone;
  }
}

bool Shell::FunctionAndArgumentsToString(Local<Function> function,
                                         Local<Value> arguments,
                                         Local<String>* source,
                                         Isolate* isolate) {
  Local<Context> context = isolate->GetCurrentContext();
  MaybeLocal<String> maybe_function_string =
      function->FunctionProtoToString(context);
  Local<String> function_string;
  if (!maybe_function_string.ToLocal(&function_string)) {
    ThrowError(isolate, "Failed to convert function to string");
    return false;
  }
  *source = String::NewFromUtf8Literal(isolate, "(");
  *source = String::Concat(isolate, *source, function_string);
  Local<String> middle = String::NewFromUtf8Literal(isolate, ")(");
  *source = String::Concat(isolate, *source, middle);
  if (!arguments.IsEmpty() && !arguments->IsUndefined()) {
    if (!arguments->IsArray()) {
      ThrowError(isolate, "'arguments' must be an array");
      return false;
    }
    Local<String> comma = String::NewFromUtf8Literal(isolate, ",");
    Local<Array> array = arguments.As<Array>();
    for (uint32_t i = 0; i < array->Length(); ++i) {
      if (i > 0) {
        *source = String::Concat(isolate, *source, comma);
      }
      MaybeLocal<Value> maybe_argument = array->Get(context, i);
      Local<Value> argument;
      if (!maybe_argument.ToLocal(&argument)) {
        ThrowError(isolate, "Failed to get argument");
        return false;
      }
      Local<String> argument_string;
      if (!JSON::Stringify(context, argument).ToLocal(&argument_string)) {
        ThrowError(isolate, "Failed to convert argument to string");
        return false;
      }
      *source = String::Concat(isolate, *source, argument_string);
    }
  }
  Local<String> suffix = String::NewFromUtf8Literal(isolate, ")");
  *source = String::Concat(isolate, *source, suffix);
  return true;
}

// ReadSource() supports reading source code through `info[index]` as specified
// by the `default_type` or an optional options bag provided in `info[index+1]`
// (e.g. `options={type: 'code_type', arguments:[...]}`).
MaybeLocal<String> Shell::ReadSource(
    const v8::FunctionCallbackInfo<v8::Value>& info, int index,
    CodeType default_type) {
  CodeType code_type;
  Local<Value> arguments;
  ReadCodeTypeAndArguments(info, index + 1, &code_type, &arguments);

  Isolate* isolate = info.GetIsolate();
  Local<String> source;
  if (code_type == CodeType::kNone) {
    code_type = default_type;
  }
  switch (code_type) {
    case CodeType::kFunction:
      if (!info[index]->IsFunction()) {
        return MaybeLocal<String>();
      }
      // Source: ( function_to_string )( params )
      if (!FunctionAndArgumentsToString(info[index].As<Function>(), arguments,
                                        &source, isolate)) {
        return MaybeLocal<String>();
      }
      break;
    case CodeType::kFileName: {
      if (!info[index]->IsString()) {
        return MaybeLocal<String>();
      }
      String::Utf8Value filename(isolate, info[index]);
      if (!Shell::ReadFile(isolate, *filename).ToLocal(&source)) {
        return MaybeLocal<String>();
      }
      break;
    }
    case CodeType::kString:
      if (!info[index]->IsString()) {
        return MaybeLocal<String>();
      }
      source = info[index].As<String>();
      break;
    case CodeType::kNone:
    case CodeType::kInvalid:
      return MaybeLocal<String>();
  }
  return source;
}

void Shell::WorkerNew(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  HandleScope handle_scope(isolate);
  if (info.Length() < 1 || (!info[0]->IsString() && !info[0]->IsFunction())) {
    ThrowError(isolate, "1st argument must be a string or a function");
    return;
  }

  Local<String> source;
  if (!ReadSource(info, 0, CodeType::kFileName).ToLocal(&source)) {
    ThrowError(isolate, "Invalid argument");
    return;
  }

  if (!info.IsConstructCall()) {
    ThrowError(isolate, "Worker must be constructed with new");
    return;
  }

  // Initialize the embedder field to 0; if we return early without
  // creating a new Worker (because the main thread is terminating) we can
  // early-out from the instance calls.
  info.This()->SetInternalField(0, v8::Integer::New(isolate, 0));

  {
    // Don't allow workers to create more workers if the main thread
    // is waiting for existing running workers to terminate.
    i::ParkedMutexGuard lock_guard(
        reinterpret_cast<i::Isolate*>(isolate)->main_thread_local_isolate(),
        workers_mutex_.Pointer());
    if (!allow_new_workers_) return;

    String::Utf8Value script(isolate, source);
    if (!*script) {
      ThrowError(isolate, "Can't get worker script");
      return;
    }

    // The C++ worker object's lifetime is shared between the Managed<Worker>
    // object on the heap, which the JavaScript object points to, and an
    // internal std::shared_ptr in the worker thread itself.
    auto worker = std::make_shared<Worker>(isolate, *script);
    i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);
    const size_t kWorkerSizeEstimate = 4 * 1024 * 1024;  // stack + heap.
    i::Handle<i::Object> managed =
        i::Managed<Worker>::From(i_isolate, kWorkerSizeEstimate, worker);
    info.This()->SetInternalField(0, Utils::ToLocal(managed));
    base::Thread::Priority priority =
        options.apply_priority ? base::Thread::Priority::kUserBlocking
                               : base::Thread::Priority::kDefault;
    if (!Worker::StartWorkerThread(isolate, worker, priority)) {
      ThrowError(isolate, "Can't start thread");
      return;
    }
    PerIsolateData::Get(isolate)->RegisterWorker(worker);
  }
}

void Shell::WorkerPostMessage(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  HandleScope handle_scope(isolate);

  if (info.Length() < 1) {
    ThrowError(isolate, "Invalid argument");
    return;
  }

  std::shared_ptr<Worker> worker =
      GetWorkerFromInternalField(isolate, info.This());
  if (!worker.get()) {
    return;
  }

  Local<Value> message = info[0];
  Local<Value> transfer =
      info.Length() >= 2 ? info[1] : Undefined(isolate).As<Value>();
  std::unique_ptr<SerializationData> data =
      Shell::SerializeValue(isolate, message, transfer);
  if (data) {
    worker->PostMessage(std::move(data));
  }
}

void Shell::WorkerGetMessage(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  HandleScope handle_scope(isolate);
  std::shared_ptr<Worker> worker =
      GetWorkerFromInternalField(isolate, info.This());
  if (!worker.get()) {
    return;
  }

  std::unique_ptr<SerializationData> data = worker->GetMessage(isolate);
  if (data) {
    Local<Value> value;
    if (Shell::DeserializeValue(isolate, std::move(data)).ToLocal(&value)) {
      info.GetReturnValue().Set(value);
    }
  }
}

// Task processing one onmessage event received from a Worker.
class OnMessageFromWorkerTask : public v8::Task {
 public:
  OnMessageFromWorkerTask(v8::Isolate* isolate, v8::Local<v8::Context> context,
                          v8::Local<v8::Value> callback,
                          std::unique_ptr<SerializationData> data)
      : isolate_(isolate),
        context_(isolate, context),
        callback_(isolate, callback),
        data_(std::move(data)) {}

  void Run() override {
    HandleScope scope(isolate_);
    Local<Context> context = context_.Get(isolate_);
    Context::Scope context_scope(context);
    MicrotasksScope microtasks_scope(context,
                                     MicrotasksScope::kDoNotRunMicrotasks);

    Local<Object> global = context->Global();

    // Get the message handler.
    Local<Value> onmessage = callback_.Get(isolate_);
    if (!onmessage->IsFunction()) return;
    Local<Function> onmessage_fun = onmessage.As<Function>();

    v8::TryCatch try_catch(isolate_);
    try_catch.SetVerbose(true);
    Local<Value> value;
    if (Shell::DeserializeValue(isolate_, std::move(data_)).ToLocal(&value)) {
      DCHECK(!isolate_->IsExecutionTerminating());
      Local<Object> event = v8::Object::New(isolate_);
      event
          ->CreateDataProperty(
              context,
              String::NewFromUtf8Literal(isolate_, "data",
                                         NewStringType::kInternalized),
              value)
          .ToChecked();
      Local<Value> argv[] = {event};
      MaybeLocal<Value> result = onmessage_fun->Call(context, global, 1, argv);
      USE(result);
    }
  }

 private:
  v8::Isolate* isolate_;
  v8::Global<v8::Context> context_;
  v8::Global<v8::Value> callback_;
  std::unique_ptr<SerializationData> data_;
};

// Check, on the main thread, whether a worker has any enqueued any message
// events. Workers post this task when posting a message, instead of posting
// OnMessageFromWorkerTask directly, to avoid races between message posting
// and onmessage subscription.
class CheckMessageFromWorkerTask : public v8::Task {
 public:
  CheckMessageFromWorkerTask(v8::Isolate* isolate,
                             std::shared_ptr<Worker> worker)
      : isolate_(isolate), worker_(std::move(worker)) {}

  void Run() override {
    HandleScope scope(isolate_);

    // Get the callback for onmessage events from this worker. It's important to
    // do this here, and not in OnMessageFromWorkerTask, because we may get a
    // CleanUpWorkerTask scheduled before the posted OnMessageFromWorkerTask
    // executes, which will
    auto callback_pair =
        PerIsolateData::Get(isolate_)->GetWorkerOnMessage(worker_);
    // Bail out if there's no callback -- leave the message queue untouched so
    // that we don't lose the messages and can read them with GetMessage later.
    // This is slightly different to browser behaviour, where events can be
    // missed, but it's helpful for d8's GetMessage behaviour.
    if (callback_pair.second.IsEmpty()) return;

    std::unique_ptr<SerializationData> result;
    while ((result = worker_->TryGetMessage())) {
      // Each onmessage callback call is posted as a separate task.
      g_platform->GetForegroundTaskRunner(isolate_)->PostTask(
          std::make_unique<OnMessageFromWorkerTask>(
              isolate_, callback_pair.first, callback_pair.second,
              std::move(result)));
    }
  }

 private:
  v8::Isolate* isolate_;
  std::shared_ptr<Worker> worker_;
};

// Unregister the given isolate from message events from the given worker.
// This must be done before the isolate or worker are destroyed, so that the
// global handles for context and callback are cleaned up correctly -- thus the
// event loop blocks until all workers are unregistered.
class CleanUpWorkerTask : public v8::Task {
 public:
  CleanUpWorkerTask(v8::Isolate* isolate, std::shared_ptr<Worker> worker)
      : isolate_(isolate), worker_(std::move(worker)) {}

  void Run() override {
    PerIsolateData::Get(isolate_)->UnregisterWorker(std::move(worker_));
  }

 private:
  v8::Isolate* isolate_;
  std::shared_ptr<Worker> worker_;
};

void Shell::WorkerOnMessageGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  HandleScope handle_scope(isolate);

  std::shared_ptr<Worker> worker =
      GetWorkerFromInternalField(isolate, info.This());
  if (!worker.get()) {
    return;
  }
  Local<Function> callback =
      PerIsolateData::Get(isolate)->GetWorkerOnMessage(worker).second;

  if (!callback.IsEmpty()) {
    info.GetReturnValue().Set(callback);
  }
}

void Shell::WorkerOnMessageSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  HandleScope handle_scope(isolate);

  if (info.Length() < 1) {
    ThrowError(isolate, "Invalid argument");
    return;
  }

  std::shared_ptr<Worker> worker =
      GetWorkerFromInternalField(isolate, info.This());
  if (!worker.get()) {
    return;
  }

  Local<Value> callback = info[0];
  if (!callback->IsFunction()) return;

  PerIsolateData::Get(isolate)->SubscribeWorkerOnMessage(
      worker, isolate->GetCurrentContext(), Local<Function>::Cast(callback));
}

void Shell::WorkerTerminate(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  HandleScope handle_scope(isolate);
  std::shared_ptr<Worker> worker =
      GetWorkerFromInternalField(isolate, info.This());
  if (!worker.get()) return;
  worker->Terminate();
}

void Shell::WorkerTerminateAndWait(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  HandleScope handle_scope(isolate);
  std::shared_ptr<Worker> worker =
      GetWorkerFromInternalField(isolate, info.This());
  if (!worker.get()) {
    return;
  }

  reinterpret_cast<i::Isolate*>(isolate)
      ->main_thread_local_isolate()
      ->ExecuteMainThreadWhileParked([worker](const i::ParkedScope& parked) {
        worker->TerminateAndWaitForThread(parked);
      });
}

void Shell::QuitOnce(v8::FunctionCallbackInfo<v8::Value>* info) {
  int exit_code = (*info)[0]
                      ->Int32Value(info->GetIsolate()->GetCurrentContext())
                      .FromMaybe(0);
  Isolate* isolate = info->GetIsolate();
  ResetOnProfileEndListener(isolate);
  isolate->Exit();

  // As we exit the process anyway, we do not dispose the platform and other
  // global data and manually unlock to quell DCHECKs. Other isolates might
  // still be running, so disposing here can cause them to crash.
  i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);
  if (i_isolate->thread_manager()->IsLockedByCurrentThread()) {
    i_isolate->thread_manager()->Unlock();
  }

  // When disposing the shared space isolate, the workers (client isolates) need
  // to be terminated first.
  if (i_isolate->is_shared_space_isolate()) {
    i_isolate->main_thread_local_isolate()->ExecuteMainThreadWhileParked(
        [](const i::ParkedScope& parked) { WaitForRunningWorkers(parked); });
  }

  OnExit(isolate, false);
  base::OS::ExitProcess(exit_code);
}

void Shell::Terminate(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  // Triggering termination from JS can cause some non-determinism thus we
  // skip it for correctness fuzzing.
  // Termination also currently breaks Fuzzilli's REPRL mechanism as the
  // scheduled termination will prevent the next testcase sent by Fuzzilli from
  // being processed. This will in turn desynchronize the communication
  // between d8 and Fuzzilli, leading to a crash.
  if (!i::v8_flags.correctness_fuzzer_suppressions && !fuzzilli_reprl) {
    auto v8_isolate = info.GetIsolate();
    if (!v8_isolate->IsExecutionTerminating()) v8_isolate->TerminateExecution();
  }
}

void Shell::Quit(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  base::CallOnce(&quit_once_, &QuitOnce,
                 const_cast<v8::FunctionCallbackInfo<v8::Value>*>(&info));
}

void Shell::Version(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  info.GetReturnValue().Set(
      String::NewFromUtf8(info.GetIsolate(), V8::GetVersion())
          .ToLocalChecked());
}

void Shell::ReportException(Isolate* isolate, Local<v8::Message> message,
                            Local<v8::Value> exception_obj) {
  HandleScope handle_scope(isolate);
  Local<Context> context = isolate->GetCurrentContext();
  bool enter_context = context.IsEmpty();
  if (enter_context) {
    context = Local<Context>::New(isolate, evaluation_context_);
    context->Enter();
  }
  // Converts a V8 value to a C string.
  auto ToCString = [](const v8::String::Utf8Value& value) {
    return *value ? *value : "<string conversion failed>";
  };

  v8::String::Utf8Value exception(isolate, exception_obj);
  const char* exception_string = ToCString(exception);
  if (message.IsEmpty()) {
    // V8 didn't provide any extra information about this error; just
    // print the exception.
    printf("%s\n", exception_string);
  } else if (message->GetScriptOrigin().Options().IsWasm()) {
    // Print wasm-function[(function index)]:(offset): (message).
    int function_index = message->GetWasmFunctionIndex();
    int offset = message->GetStartColumn(context).FromJust();
    printf("wasm-function[%d]:0x%x: %s\n", function_index, offset,
           exception_string);
  } else {
    // Print (filename):(line number): (message).
    v8::String::Utf8Value filename(isolate,
                                   message->GetScriptOrigin().ResourceName());
    const char* filename_string = ToCString(filename);
    int linenum = message->GetLineNumber(context).FromMaybe(-1);
    printf("%s:%i: %s\n", filename_string, linenum, exception_string);
    Local<String> sourceline;
    if (message->GetSourceLine(context).ToLocal(&sourceline)) {
      // Print line of source code.
      v8::String::Utf8Value sourcelinevalue(isolate, sourceline);
      const char* sourceline_string = ToCString(sourcelinevalue);
      printf("%s\n", sourceline_string);
      // Print wavy underline (GetUnderline is deprecated).
      int start = message->GetStartColumn(context).FromJust();
      for (int i = 0; i < start; i++) {
        printf(" ");
      }
      int end = message->GetEndColumn(context).FromJust();
      for (int i = start; i < end; i++) {
        printf("^");
      }
      printf("\n");
    }
  }
  Local<Value> stack_trace_string;
  if (v8::TryCatch::StackTrace(context, exception_obj)
          .ToLocal(&stack_trace_string) &&
      stack_trace_string->IsString()) {
    v8::String::Utf8Value stack_trace(isolate, stack_trace_string.As<String>());
    print
"""


```
Response:
The user wants a summary of the functionality of the provided C++ code snippet from `v8/src/d8/d8.cc`.

Here's a breakdown of the code's features:

1. **Module Loading and Execution:** It handles the loading and execution of JavaScript modules, including those with top-level `await`.
2. **JSON Parsing:** Provides functionality to load and parse JSON files line by line.
3. **Per-Isolate Data Management:**  Manages data specific to each V8 isolate, including realms (JavaScript execution contexts) and unhandled promise rejections.
4. **Unhandled Promise Rejection Tracking:**  Keeps track of unhandled promise rejections and reports them.
5. **Dynamic Import Support:** Contains data structures related to dynamic imports.
6. **Worker Support:**  Manages communication and subscriptions to messages from web workers.
7. **Realm Management:** Offers functionality to create, switch between, and manage multiple JavaScript realms with different security contexts.
8. **Performance Measurement API:** Implements `performance.now()`, `performance.mark()`, `performance.measure()`, and `performance.measureMemory()` for performance tracking.
9. **Realm Introspection API:** Provides functions like `Realm.current()`, `Realm.owner()`, `Realm.global()`, `Realm.create()`, `Realm.dispose()`, `Realm.switch()`, and `Realm.eval()` for interacting with and managing realms.
10. **Shared Realm Value:**  Allows sharing a single value across different realms.
11. **Logging and Source Position Verification:** Includes functionality for capturing V8 log output and verifying source code positions in generated bytecode.
12. **Conditional Feature Installation:** Enables the installation of optional V8 features.
13. **Wasm JSPI Enabling:**  Provides a way to enable the WebAssembly JavaScript Promise Integration (JSPI).
14. **Async Hooks API:** Implements parts of the `async_hooks` API for tracking asynchronous operations.
15. **Debugger Support:** Offers basic functions to enable and disable the V8 debugger.

Considering these functionalities and the request for a concise summary, I will focus on the key aspects demonstrated in this code snippet.
目录 `v8/src/d8/d8.cc` 的这段代码片段主要负责以下功能：

**1. 模块加载与执行 (Module Loading and Execution):**

-  处理 JavaScript 模块的加载和执行，特别是当模块使用了顶层 `await` (Top-Level Await, TLA) 时。
-  如果模块中存在未完成的顶层 `await`，会报告相应的错误信息。

**2. JSON 文件加载 (JSON File Loading):**

- 提供 `Shell::LoadJSON` 函数，可以逐行读取并解析 JSON 文件。
- 它会将文件中的每一行视为一个 JSON 值进行解析。

**3. 每个 Isolate 的数据管理 (Per-Isolate Data Management):**

-  定义了 `PerIsolateData` 类，用于存储和管理与特定 V8 Isolate 相关的各种数据。
-  这些数据包括：
    - `realms_`: 用于管理多个 JavaScript 执行上下文 (realms)。
    - `unhandled_promises_`: 跟踪未处理的 Promise 拒绝。
    - `worker_message_callbacks_`: 存储 worker 消息回调函数。
    - `import_data_`:  用于管理动态导入相关的数据。

**4. 未处理的 Promise 拒绝处理 (Unhandled Promise Rejection Handling):**

-  `PerIsolateData` 负责跟踪未处理的 Promise 拒绝。
-  `AddUnhandledPromise` 用于添加未处理的 Promise。
-  `HandleUnhandledPromiseRejections` 用于报告这些拒绝。

**5. Web Worker 支持 (Web Worker Support):**

-  `PerIsolateData` 维护着已注册的 worker 列表 (`registered_workers_`) 和 worker 消息回调函数 (`worker_message_callbacks_`)。
-  提供了注册、订阅和取消订阅 worker 消息的函数。

**6. Realm 管理 (Realm Management):**

-  提供了创建、切换、查找和管理多个 JavaScript 执行上下文 (realms) 的功能。
-  `RealmScope` 和 `ExplicitRealmScope` 用于在不同的 realm 中执行代码。
-  提供了 JavaScript 可调用的函数（通过 `Shell::Realm...` 系列函数）来操作 realm，例如 `Realm.create()`, `Realm.switch()`, `Realm.eval()` 等。

**7. Performance API (Performance API):**

-  实现了 `performance.now()`, `performance.mark()`, `performance.measure()`  和 `performance.measureMemory()` 等性能相关的 API。
-  这些 API 可以用于记录时间戳和测量代码执行时间。

**8. Realm 相关的 JavaScript API (Realm Related JavaScript API):**

-  暴露了一些全局对象 `Realm` 的方法，允许 JavaScript 代码操作不同的 realm：
    - `Realm.current()`: 获取当前 realm 的索引。
    - `Realm.owner(o)`: 获取创建对象 `o` 的 realm 的索引。
    - `Realm.global(i)`: 获取 realm `i` 的全局对象。
    - `Realm.create()`: 创建一个新的 realm。
    - `Realm.createAllowCrossRealmAccess()`: 创建允许跨 realm 访问的新 realm。
    - `Realm.navigate(i)`: 导航到指定的 realm `i` (创建一个新的 realm 替换它)。
    - `Realm.detachGlobal(i)`: 分离 realm `i` 的全局对象。
    - `Realm.dispose(i)`: 释放对 realm `i` 的引用。
    - `Realm.switch(i)`: 切换到指定的 realm `i`。
    - `Realm.eval(i, s)`: 在 realm `i` 中执行字符串 `s`。
    - `Realm.shared`:  一个跨 realm 共享的值的访问器。

**9. 日志和源码位置验证 (Logging and Source Position Verification):**

-  `Shell::LogGetAndStop`: 用于获取 V8 的日志并停止日志记录。
-  `Shell::TestVerifySourcePositions`:  用于测试和验证 JavaScript 函数的源码位置信息是否正确。

**10. 条件特性安装 (Conditional Feature Installation):**

- `Shell::InstallConditionalFeatures`: 用于安装一些有条件的 V8 特性。

**11. 启用 JSPI (Enable JSPI):**

- `Shell::EnableJSPI`: 允许启用 WebAssembly JavaScript Promise Integration (JSPI)。

**12. Async Hooks API (Async Hooks API):**

- 实现了 `async_hooks.createHook()`, `async_hooks.executionAsyncId()`, `async_hooks.triggerAsyncId()` 等异步操作跟踪相关的 API。

**13. 调试器支持 (Debugger Support):**

- `Shell::EnableDebugger` 和 `Shell::DisableDebugger`:  用于启用和禁用 V8 调试器。

**关于代码片段的推断：**

-  **`.tq` 结尾：** 此代码片段为 `.cc` 结尾，因此不是 v8 Torque 源代码。
-  **与 JavaScript 的关系：**  此代码片段与 JavaScript 的功能有密切关系，因为它实现了 V8 引擎的一些核心功能，例如模块加载、Promise 处理、realm 管理和性能测量。

**JavaScript 示例：**

以下是一些 JavaScript 代码示例，展示了这段 C++ 代码片段所支持的功能：

```javascript
// 模块加载 (需要 d8 命令行参数支持)
// my_module.js
export const message = "Hello from module!";

// d8 --module my_script.js
// my_script.js
import { message } from './my_module.js';
console.log(message);

// 顶层 await (需要 d8 命令行参数支持)
// top_level_await.js
const data = await fetch('https://example.com/data.json');
console.log(await data.json());

// JSON 文件加载 (使用 d8 命令行)
// data.json
// {"name": "example", "value": 123}
// {"name": "another", "value": 456}
// d8 --load-json data.json

// Realm 操作
const realm1 = Realm.create();
Realm.eval(realm1, 'globalThis.value = 10;');
const realm2 = Realm.create();
Realm.eval(realm2, 'globalThis.value = 20;');
console.log(Realm.eval(realm1, 'value')); // 输出 10
console.log(Realm.eval(realm2, 'value')); // 输出 20

// Performance API
performance.mark('start');
for (let i = 0; i < 1000000; i++) {
  // 一些计算
}
performance.mark('end');
performance.measure('myOperation', performance.getEntriesByName('start')[0], performance.getEntriesByName('end')[0]);
console.log(performance.getEntriesByType('measure'));

// Async Hooks API (需要 d8 命令行参数支持)
const async_hooks = require('async_hooks');
const hook = async_hooks.createHook({
  init(asyncId, type, triggerAsyncId, resource) {
    console.log('Async operation initiated', asyncId, type, triggerAsyncId);
  },
  destroy(asyncId) {
    console.log('Async operation destroyed', asyncId);
  },
});
hook.enable();
setTimeout(() => {}, 100);
```

**假设输入与输出（代码逻辑推理）：**

假设我们有一个包含顶层 `await` 的模块：

**输入 (my_async_module.js):**

```javascript
export const data = await Promise.resolve(123);
```

**使用 d8 命令行执行：**

```bash
d8 --module my_async_module.js
```

**输出：**

如果模块成功加载和执行，并且 Promise 成功 resolve，则不会有明显的输出到控制台。但是，如果 Promise 没有成功 resolve 或者有错误，`ReportException` 函数会被调用，可能会在控制台输出错误信息，例如：

```
Unhandled promise rejection:  123
```

**用户常见的编程错误示例：**

- **忘记处理 Promise 拒绝：**

```javascript
async function fetchData() {
  return fetch('invalid_url'); // 这会返回一个 rejected 的 Promise
}

fetchData(); // 没有 .catch() 处理拒绝
```

这段 C++ 代码会检测到这种未处理的 Promise 拒绝，并通过 `ReportException` 函数报告出来。

**归纳总结 (第 3 部分，共 8 部分)：**

这部分代码主要集中在 **模块加载、JSON 处理、isolate 级别的数据管理、未处理的 Promise 拒绝处理、Web Worker 支持和 Realm 管理** 等核心功能。它为 d8 这个 V8 开发者 Shell 提供了执行和管理 JavaScript 代码的基础设施，特别是针对模块化和多 realm 的场景。此外，还包含了性能监控和异步操作跟踪等实用工具的接口。

### 提示词
```
这是目录为v8/src/d8/d8.cc的一个v8源代码， 请列举一下它的功能, 
如果v8/src/d8/d8.cc以.tq结尾，那它是个v8 torque源代码，
如果它与javascript的功能有关系，请用javascript举例说明,
如果有代码逻辑推理，请给出假设输入与输出，
如果涉及用户常见的编程错误，请举例说明
这是第3部分，共8部分，请归纳一下它的功能
```

### 源代码
```cpp
fter we create a new API for the case
      // where TLA is enabled.
      if (!try_catch.HasCaught()) {
        isolate->ThrowException(result_promise->Result());
      } else {
        DCHECK_EQ(try_catch.Exception(), result_promise->Result());
      }
      ReportException(isolate, try_catch);
      return false;
    }

    auto [stalled_modules, stalled_messages] =
        root_module->GetStalledTopLevelAwaitMessages(isolate);
    DCHECK_EQ(stalled_modules.size(), stalled_messages.size());
    if (stalled_messages.size() > 0) {
      Local<Message> message = stalled_messages[0];
      ReportException(isolate, message, v8::Exception::Error(message->Get()));
      return false;
    }
  }

  DCHECK(!try_catch.HasCaught());
  return true;
}

// Treat every line as a JSON value and parse it.
bool Shell::LoadJSON(Isolate* isolate, const char* file_name) {
  HandleScope handle_scope(isolate);
  PerIsolateData* isolate_data = PerIsolateData::Get(isolate);
  Local<Context> realm =
      isolate_data->realms_[isolate_data->realm_current_].Get(isolate);
  Context::Scope context_scope(realm);
  TryCatch try_catch(isolate);

  std::string absolute_path = NormalizePath(file_name, GetWorkingDirectory());
  int length = 0;
  std::unique_ptr<char[]> data(ReadChars(absolute_path.c_str(), &length));
  if (length == 0) {
    printf("Error reading '%s'\n", file_name);
    base::OS::ExitProcess(1);
  }
  std::stringstream stream(data.get());
  std::string line;
  while (std::getline(stream, line, '\n')) {
    for (int r = 0; r < DeserializationRunCount(); ++r) {
      Local<String> source =
          String::NewFromUtf8(isolate, line.c_str()).ToLocalChecked();
      MaybeLocal<Value> maybe_value = JSON::Parse(realm, source);

      Local<Value> value;
      if (!maybe_value.ToLocal(&value)) {
        DCHECK(try_catch.HasCaught());
        ReportException(isolate, try_catch);
        return false;
      }
    }
  }
  return true;
}

PerIsolateData::PerIsolateData(Isolate* isolate)
    : isolate_(isolate), realms_(nullptr) {
  isolate->SetData(0, this);
  if (i::v8_flags.expose_async_hooks) {
    async_hooks_wrapper_ = new AsyncHooks(isolate);
  }
  ignore_unhandled_promises_ = false;
}

PerIsolateData::~PerIsolateData() {
  isolate_->SetData(0, nullptr);  // Not really needed, just to be sure...
  if (i::v8_flags.expose_async_hooks) {
    delete async_hooks_wrapper_;  // This uses the isolate
  }
#if defined(LEAK_SANITIZER)
  for (DynamicImportData* data : import_data_) {
    delete data;
  }
#endif
}

void PerIsolateData::RemoveUnhandledPromise(Local<Promise> promise) {
  if (ignore_unhandled_promises_) return;
  // Remove handled promises from the list
  DCHECK_EQ(promise->GetIsolate(), isolate_);
  for (auto it = unhandled_promises_.begin(); it != unhandled_promises_.end();
       ++it) {
    v8::Local<v8::Promise> unhandled_promise = std::get<0>(*it).Get(isolate_);
    if (unhandled_promise == promise) {
      unhandled_promises_.erase(it--);
    }
  }
}

void PerIsolateData::AddUnhandledPromise(Local<Promise> promise,
                                         Local<Message> message,
                                         Local<Value> exception) {
  if (ignore_unhandled_promises_) return;
  DCHECK_EQ(promise->GetIsolate(), isolate_);
  unhandled_promises_.emplace_back(v8::Global<v8::Promise>(isolate_, promise),
                                   v8::Global<v8::Message>(isolate_, message),
                                   v8::Global<v8::Value>(isolate_, exception));
}

int PerIsolateData::HandleUnhandledPromiseRejections() {
  // Avoid recursive calls to HandleUnhandledPromiseRejections.
  if (ignore_unhandled_promises_) return 0;
  if (isolate_->IsExecutionTerminating()) return 0;
  ignore_unhandled_promises_ = true;
  v8::HandleScope scope(isolate_);
  // Ignore promises that get added during error reporting.
  size_t i = 0;
  for (; i < unhandled_promises_.size(); i++) {
    const auto& tuple = unhandled_promises_[i];
    Local<v8::Message> message = std::get<1>(tuple).Get(isolate_);
    Local<v8::Value> value = std::get<2>(tuple).Get(isolate_);
    Shell::ReportException(isolate_, message, value);
  }
  unhandled_promises_.clear();
  ignore_unhandled_promises_ = false;
  return static_cast<int>(i);
}

void PerIsolateData::AddDynamicImportData(DynamicImportData* data) {
#if defined(LEAK_SANITIZER)
  import_data_.insert(data);
#endif
}
void PerIsolateData::DeleteDynamicImportData(DynamicImportData* data) {
#if defined(LEAK_SANITIZER)
  import_data_.erase(data);
#endif
  delete data;
}

Local<FunctionTemplate> PerIsolateData::GetTestApiObjectCtor() const {
  return test_api_object_ctor_.Get(isolate_);
}

void PerIsolateData::SetTestApiObjectCtor(Local<FunctionTemplate> ctor) {
  test_api_object_ctor_.Reset(isolate_, ctor);
}

Local<FunctionTemplate> PerIsolateData::GetDomNodeCtor() const {
  return dom_node_ctor_.Get(isolate_);
}

void PerIsolateData::SetDomNodeCtor(Local<FunctionTemplate> ctor) {
  dom_node_ctor_.Reset(isolate_, ctor);
}

bool PerIsolateData::HasRunningSubscribedWorkers() {
  // Only consider subscribed workers, so that code that spawns a worker and
  // never subscribes to message events will quit.
  return !worker_message_callbacks_.empty();
}

void PerIsolateData::RegisterWorker(std::shared_ptr<Worker> worker) {
  registered_workers_.insert(std::move(worker));
}

void PerIsolateData::SubscribeWorkerOnMessage(
    const std::shared_ptr<Worker>& worker, Local<Context> context,
    Local<Function> callback) {
  if (!registered_workers_.contains(worker)) {
    // The worker has already terminated, so it won't be posting any more
    // messages. Don't try to subscribe to its events.
    fprintf(
        stderr,
        "Trying to subscribe to message events from a terminated worker -- "
        "consider registering the event handler before the event loop runs.\n");
    return;
  }
  worker_message_callbacks_.emplace(
      worker, std::make_pair(Global<Context>(isolate_, context),
                             Global<Function>(isolate_, callback)));
}

std::pair<Local<Context>, Local<Function>> PerIsolateData::GetWorkerOnMessage(
    const std::shared_ptr<Worker>& worker) const {
  auto it = worker_message_callbacks_.find(worker);
  if (it == worker_message_callbacks_.end()) {
    return {};
  }
  return {it->second.first.Get(isolate_), it->second.second.Get(isolate_)};
}

void PerIsolateData::UnregisterWorker(const std::shared_ptr<Worker>& worker) {
  registered_workers_.erase(worker);
  worker_message_callbacks_.erase(worker);
}

PerIsolateData::RealmScope::RealmScope(Isolate* isolate,
                                       const Global<Context>& context)
    : data_(PerIsolateData::Get(isolate)) {
  data_->realm_count_ = 1;
  data_->realm_current_ = 0;
  data_->realm_switch_ = 0;
  data_->realms_ = new Global<Context>[1];
  data_->realms_[0].Reset(data_->isolate_, context);
}

PerIsolateData::RealmScope::~RealmScope() {
  // Drop realms to avoid keeping them alive.
  data_->realm_count_ = 0;
  delete[] data_->realms_;
}

PerIsolateData::ExplicitRealmScope::ExplicitRealmScope(PerIsolateData* data,
                                                       int index)
    : data_(data), index_(index) {
  realm_ = Local<Context>::New(data->isolate_, data->realms_[index_]);
  realm_->Enter();
  previous_index_ = data->realm_current_;
  data->realm_current_ = data->realm_switch_ = index_;
}

PerIsolateData::ExplicitRealmScope::~ExplicitRealmScope() {
  realm_->Exit();
  data_->realm_current_ = data_->realm_switch_ = previous_index_;
}

Local<Context> PerIsolateData::ExplicitRealmScope::context() const {
  return realm_;
}

int PerIsolateData::RealmFind(Local<Context> context) {
  for (int i = 0; i < realm_count_; ++i) {
    if (realms_[i] == context) return i;
  }
  return -1;
}

int PerIsolateData::RealmIndexOrThrow(
    const v8::FunctionCallbackInfo<v8::Value>& info, int arg_offset) {
  if (info.Length() < arg_offset || !info[arg_offset]->IsNumber()) {
    ThrowError(info.GetIsolate(), "Invalid argument");
    return -1;
  }
  int index = info[arg_offset]
                  ->Int32Value(info.GetIsolate()->GetCurrentContext())
                  .FromMaybe(-1);
  if (index < 0 || index >= realm_count_ || realms_[index].IsEmpty()) {
    ThrowError(info.GetIsolate(), "Invalid realm index");
    return -1;
  }
  return index;
}

// GetTimestamp() returns a time stamp as double, measured in milliseconds.
// When v8_flags.verify_predictable mode is enabled it returns result of
// v8::Platform::MonotonicallyIncreasingTime().
double Shell::GetTimestamp() {
  if (i::v8_flags.verify_predictable) {
    return g_platform->MonotonicallyIncreasingTime();
  } else {
    base::TimeDelta delta = base::TimeTicks::Now() - kInitialTicks;
    return delta.InMillisecondsF();
  }
}
uint64_t Shell::GetTracingTimestampFromPerformanceTimestamp(
    double performance_timestamp) {
  // Don't use this in --verify-predictable mode, predictable timestamps don't
  // work well with tracing.
  DCHECK(!i::v8_flags.verify_predictable);
  base::TimeDelta delta =
      base::TimeDelta::FromMillisecondsD(performance_timestamp);
  // See TracingController::CurrentTimestampMicroseconds().
  int64_t internal_value = (delta + kInitialTicks).ToInternalValue();
  DCHECK_GE(internal_value, 0);
  return internal_value;
}

#ifdef V8_OS_LINUX
void SendPerfControlCommand(const char* command) {
  if (Shell::options.perf_ctl_fd != -1 && Shell::options.perf_ack_fd != -1) {
    size_t command_len = strlen(command);
    ssize_t ret = write(Shell::options.perf_ctl_fd, command, command_len);
    if (ret == -1) {
      fprintf(stderr, "perf_ctl write error: %s\n", strerror(errno));
    }
    CHECK_EQ(ret, command_len);

    char ack[5];
    ret = read(Shell::options.perf_ack_fd, ack, 5);
    if (ret == -1) {
      fprintf(stderr, "perf_ack read error: %s\n", strerror(errno));
    }
    CHECK_EQ(ret, 5);
    CHECK_EQ(strcmp(ack, "ack\n"), 0);
  }
}
#endif

// performance.now() returns GetTimestamp().
void Shell::PerformanceNow(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  info.GetReturnValue().Set(GetTimestamp());
}

// performance.mark() records and returns a PerformanceEntry with the current
// timestamp.
void Shell::PerformanceMark(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  Local<Context> context = isolate->GetCurrentContext();

  if (info.Length() < 1 || !info[0]->IsString()) {
    ThrowError(info.GetIsolate(), "Invalid 'name' argument");
    return;
  }
  Local<String> name = info[0].As<String>();

  double timestamp = GetTimestamp();

  Local<Object> performance_entry = Object::New(isolate);
  performance_entry
      ->DefineOwnProperty(context,
                          String::NewFromUtf8Literal(isolate, "entryType"),
                          String::NewFromUtf8Literal(isolate, "mark"), ReadOnly)
      .Check();
  performance_entry
      ->DefineOwnProperty(context, String::NewFromUtf8Literal(isolate, "name"),
                          name, ReadOnly)
      .Check();
  performance_entry
      ->DefineOwnProperty(context,
                          String::NewFromUtf8Literal(isolate, "startTime"),
                          Number::New(isolate, timestamp), ReadOnly)
      .Check();
  performance_entry
      ->DefineOwnProperty(context,
                          String::NewFromUtf8Literal(isolate, "duration"),
                          Integer::New(isolate, 0), ReadOnly)
      .Check();

  info.GetReturnValue().Set(performance_entry);

#ifdef V8_OS_LINUX
  if (options.scope_linux_perf_to_mark_measure) {
    SendPerfControlCommand("enable");
  }
#endif
}

// performance.measure() records and returns a PerformanceEntry with a duration
// since a given mark, or since zero.
void Shell::PerformanceMeasure(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  Local<Context> context = isolate->GetCurrentContext();

  if (info.Length() < 1 || !info[0]->IsString()) {
    ThrowError(info.GetIsolate(), "Invalid 'name' argument");
    return;
  }
  v8::Local<String> name = info[0].As<String>();

  double start_timestamp = 0;
  if (info.Length() >= 2) {
#ifdef V8_OS_LINUX
    if (options.scope_linux_perf_to_mark_measure) {
      SendPerfControlCommand("disable");
    }
#endif

    Local<Value> start_mark = info[1].As<Value>();
    if (!start_mark->IsObject()) {
      ThrowError(info.GetIsolate(),
                 "Invalid 'startMark' argument: Not an Object");
      return;
    }
    Local<Value> start_time_field;
    if (!start_mark.As<Object>()
             ->Get(context, String::NewFromUtf8Literal(isolate, "startTime"))
             .ToLocal(&start_time_field)) {
      return;
    }
    if (!start_time_field->IsNumber()) {
      ThrowError(info.GetIsolate(),
                 "Invalid 'startMark' argument: No numeric 'startTime' field");
      return;
    }
    start_timestamp = start_time_field.As<Number>()->Value();
  }
  if (info.Length() > 2) {
    ThrowError(info.GetIsolate(), "Too many arguments");
    return;
  }

  double end_timestamp = GetTimestamp();

  if (options.trace_enabled) {
    size_t hash = base::hash_combine(name->GetIdentityHash(), start_timestamp,
                                     end_timestamp);

    String::Utf8Value utf8(isolate, name);
    TRACE_EVENT_COPY_NESTABLE_ASYNC_BEGIN_WITH_TIMESTAMP1(
        "v8", *utf8, static_cast<uint64_t>(hash),
        GetTracingTimestampFromPerformanceTimestamp(start_timestamp),
        "startTime", start_timestamp);
    TRACE_EVENT_COPY_NESTABLE_ASYNC_END_WITH_TIMESTAMP0(
        "v8", *utf8, static_cast<uint64_t>(hash),
        GetTracingTimestampFromPerformanceTimestamp(end_timestamp));
  }

  Local<Object> performance_entry = Object::New(isolate);
  performance_entry
      ->DefineOwnProperty(
          context, String::NewFromUtf8Literal(isolate, "entryType"),
          String::NewFromUtf8Literal(isolate, "measure"), ReadOnly)
      .Check();
  performance_entry
      ->DefineOwnProperty(context, String::NewFromUtf8Literal(isolate, "name"),
                          name, ReadOnly)
      .Check();
  performance_entry
      ->DefineOwnProperty(context,
                          String::NewFromUtf8Literal(isolate, "startTime"),
                          Number::New(isolate, start_timestamp), ReadOnly)
      .Check();
  performance_entry
      ->DefineOwnProperty(
          context, String::NewFromUtf8Literal(isolate, "duration"),
          Number::New(isolate, end_timestamp - start_timestamp), ReadOnly)
      .Check();

  info.GetReturnValue().Set(performance_entry);
}

// performance.measureMemory() implements JavaScript Memory API proposal.
// See https://github.com/ulan/javascript-agent-memory/blob/master/explainer.md.
void Shell::PerformanceMeasureMemory(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  v8::MeasureMemoryMode mode = v8::MeasureMemoryMode::kSummary;
  v8::Isolate* isolate = info.GetIsolate();
  Local<Context> context = isolate->GetCurrentContext();
  if (info.Length() >= 1 && info[0]->IsObject()) {
    Local<Object> object = info[0].As<Object>();
    Local<Value> value = TryGetValue(isolate, context, object, "detailed")
                             .FromMaybe(Local<Value>());
    if (value.IsEmpty()) {
      // Exception was thrown and scheduled, so return from the callback.
      return;
    }
    if (value->IsBoolean() && value->BooleanValue(isolate)) {
      mode = v8::MeasureMemoryMode::kDetailed;
    }
  }
  Local<v8::Promise::Resolver> promise_resolver =
      v8::Promise::Resolver::New(context).ToLocalChecked();
  info.GetIsolate()->MeasureMemory(
      v8::MeasureMemoryDelegate::Default(isolate, context, promise_resolver,
                                         mode),
      v8::MeasureMemoryExecution::kEager);
  info.GetReturnValue().Set(promise_resolver->GetPromise());
}

// Realm.current() returns the index of the currently active realm.
void Shell::RealmCurrent(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  PerIsolateData* data = PerIsolateData::Get(isolate);
  int index = data->RealmFind(isolate->GetEnteredOrMicrotaskContext());
  if (index == -1) return;
  info.GetReturnValue().Set(index);
}

// Realm.owner(o) returns the index of the realm that created o.
void Shell::RealmOwner(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  PerIsolateData* data = PerIsolateData::Get(isolate);
  if (info.Length() < 1 || !info[0]->IsObject()) {
    ThrowError(info.GetIsolate(), "Invalid argument");
    return;
  }
  Local<Object> object =
      info[0]->ToObject(isolate->GetCurrentContext()).ToLocalChecked();
  i::Handle<i::JSReceiver> i_object = Utils::OpenHandle(*object);
  if (IsJSGlobalProxy(*i_object) &&
      i::Cast<i::JSGlobalProxy>(i_object)->IsDetached()) {
    return;
  }
  Local<Context> creation_context;
  if (!object->GetCreationContext(isolate).ToLocal(&creation_context)) {
    ThrowError(info.GetIsolate(), "object doesn't have creation context");
    return;
  }
  int index = data->RealmFind(creation_context);
  if (index == -1) return;
  info.GetReturnValue().Set(index);
}

// Realm.global(i) returns the global object of realm i.
// (Note that properties of global objects cannot be read/written cross-realm.)
void Shell::RealmGlobal(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  PerIsolateData* data = PerIsolateData::Get(info.GetIsolate());
  int index = data->RealmIndexOrThrow(info, 0);
  if (index == -1) return;
  // TODO(chromium:324812): Ideally Context::Global should never return raw
  // global objects but return a global proxy. Currently it returns global
  // object when the global proxy is detached from the global object. The
  // following is a workaround till we fix Context::Global so we don't leak
  // global objects.
  Local<Object> global =
      Local<Context>::New(info.GetIsolate(), data->realms_[index])->Global();
  i::Handle<i::Object> i_global = Utils::OpenHandle(*global);
  if (IsJSGlobalObject(*i_global)) {
    i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(info.GetIsolate());
    i::Handle<i::JSObject> i_global_proxy =
        handle(i::Cast<i::JSGlobalObject>(i_global)->global_proxy(), i_isolate);
    global = Utils::ToLocal(i_global_proxy);
  }
  info.GetReturnValue().Set(global);
}

MaybeLocal<Context> Shell::CreateRealm(
    const v8::FunctionCallbackInfo<v8::Value>& info, int index,
    v8::MaybeLocal<Value> global_object) {
  DCHECK(i::ValidateCallbackInfo(info));
  const char* kGlobalHandleLabel = "d8::realm";
  Isolate* isolate = info.GetIsolate();
  TryCatch try_catch(isolate);
  PerIsolateData* data = PerIsolateData::Get(isolate);
  if (index < 0) {
    Global<Context>* old_realms = data->realms_;
    index = data->realm_count_;
    data->realms_ = new Global<Context>[++data->realm_count_];
    for (int i = 0; i < index; ++i) {
      Global<Context>& realm = data->realms_[i];
      realm.Reset(isolate, old_realms[i]);
      if (!realm.IsEmpty()) {
        realm.AnnotateStrongRetainer(kGlobalHandleLabel);
      }
      old_realms[i].Reset();
    }
    delete[] old_realms;
  }
  Local<ObjectTemplate> global_template = CreateGlobalTemplate(isolate);
  Local<Context> context =
      Context::New(isolate, nullptr, global_template, global_object);
  if (context.IsEmpty()) return MaybeLocal<Context>();
  DCHECK(!try_catch.HasCaught());
  InitializeModuleEmbedderData(context);
  data->realms_[index].Reset(isolate, context);
  data->realms_[index].AnnotateStrongRetainer(kGlobalHandleLabel);
  info.GetReturnValue().Set(index);
  return context;
}

void Shell::DisposeRealm(const v8::FunctionCallbackInfo<v8::Value>& info,
                         int index) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  PerIsolateData* data = PerIsolateData::Get(isolate);
  Local<Context> context = data->realms_[index].Get(isolate);
  data->realms_[index].Reset();
  // ContextDisposedNotification expects the disposed context to be entered.
  v8::Context::Scope scope(context);
  isolate->ContextDisposedNotification();
}

// Realm.create() creates a new realm with a distinct security token
// and returns its index.
void Shell::RealmCreate(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  CreateRealm(info, -1, v8::MaybeLocal<Value>());
}

// Realm.createAllowCrossRealmAccess() creates a new realm with the same
// security token as the current realm.
void Shell::RealmCreateAllowCrossRealmAccess(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Local<Context> context;
  if (CreateRealm(info, -1, v8::MaybeLocal<Value>()).ToLocal(&context)) {
    context->SetSecurityToken(
        info.GetIsolate()->GetEnteredOrMicrotaskContext()->GetSecurityToken());
  }
}

// Realm.navigate(i) creates a new realm with a distinct security token
// in place of realm i.
void Shell::RealmNavigate(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  PerIsolateData* data = PerIsolateData::Get(isolate);
  int index = data->RealmIndexOrThrow(info, 0);
  if (index == -1) return;
  if (index == 0 || index == data->realm_current_ ||
      index == data->realm_switch_) {
    ThrowError(info.GetIsolate(), "Invalid realm index");
    return;
  }

  Local<Context> context = Local<Context>::New(isolate, data->realms_[index]);
  v8::MaybeLocal<Value> global_object = context->Global();

  // Context::Global doesn't return JSGlobalProxy if DetachGlobal is called in
  // advance.
  if (!global_object.IsEmpty()) {
    HandleScope scope(isolate);
    if (!IsJSGlobalProxy(
            *Utils::OpenDirectHandle(*global_object.ToLocalChecked()))) {
      global_object = v8::MaybeLocal<Value>();
    }
  }

  DisposeRealm(info, index);
  CreateRealm(info, index, global_object);
}

// Realm.detachGlobal(i) detaches the global objects of realm i from realm i.
void Shell::RealmDetachGlobal(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  PerIsolateData* data = PerIsolateData::Get(isolate);
  int index = data->RealmIndexOrThrow(info, 0);
  if (index == -1) return;
  if (index == 0 || index == data->realm_current_ ||
      index == data->realm_switch_) {
    ThrowError(info.GetIsolate(), "Invalid realm index");
    return;
  }

  HandleScope scope(isolate);
  Local<Context> realm = Local<Context>::New(isolate, data->realms_[index]);
  realm->DetachGlobal();
}

// Realm.dispose(i) disposes the reference to the realm i.
void Shell::RealmDispose(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  PerIsolateData* data = PerIsolateData::Get(isolate);
  int index = data->RealmIndexOrThrow(info, 0);
  if (index == -1) return;
  if (index == 0 || index == data->realm_current_ ||
      index == data->realm_switch_) {
    ThrowError(info.GetIsolate(), "Invalid realm index");
    return;
  }
  DisposeRealm(info, index);
}

// Realm.switch(i) switches to the realm i for consecutive interactive inputs.
void Shell::RealmSwitch(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  PerIsolateData* data = PerIsolateData::Get(isolate);
  int index = data->RealmIndexOrThrow(info, 0);
  if (index == -1) return;
  data->realm_switch_ = index;
}

// Realm.eval(i, s) evaluates s in realm i and returns the result.
void Shell::RealmEval(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  PerIsolateData* data = PerIsolateData::Get(isolate);
  int index = data->RealmIndexOrThrow(info, 0);
  if (index == -1) return;
  if (info.Length() < 2) {
    ThrowError(isolate, "Invalid argument");
    return;
  }

  Local<String> source;
  if (!ReadSource(info, 1, CodeType::kString).ToLocal(&source)) {
    ThrowError(isolate, "Invalid argument");
    return;
  }
  ScriptOrigin origin =
      CreateScriptOrigin(isolate, String::NewFromUtf8Literal(isolate, "(d8)"),
                         ScriptType::kClassic);

  if (isolate->IsExecutionTerminating()) return;
  ScriptCompiler::Source script_source(source, origin);
  Local<UnboundScript> script;
  if (!ScriptCompiler::CompileUnboundScript(isolate, &script_source)
           .ToLocal(&script)) {
    return;
  }
  Local<Value> result;
  {
    PerIsolateData::ExplicitRealmScope realm_scope(data, index);
    if (!script->BindToCurrentContext()
             ->Run(realm_scope.context())
             .ToLocal(&result)) {
      return;
    }
  }
  info.GetReturnValue().Set(result);
}

// Realm.shared is an accessor for a single shared value across realms.
void Shell::RealmSharedGet(Local<Name> property,
                           const PropertyCallbackInfo<Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  PerIsolateData* data = PerIsolateData::Get(isolate);
  if (data->realm_shared_.IsEmpty()) return;
  info.GetReturnValue().Set(data->realm_shared_);
}

void Shell::RealmSharedSet(Local<Name> property, Local<Value> value,
                           const PropertyCallbackInfo<void>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  PerIsolateData* data = PerIsolateData::Get(isolate);
  data->realm_shared_.Reset(isolate, value);
}

void Shell::LogGetAndStop(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);
  HandleScope handle_scope(isolate);

  std::string file_name = i_isolate->v8_file_logger()->file_name();
  if (!i::LogFile::IsLoggingToTemporaryFile(file_name)) {
    ThrowError(isolate, "Only capturing from temporary files is supported.");
    return;
  }
  if (!i_isolate->v8_file_logger()->is_logging()) {
    ThrowError(isolate, "Logging not enabled.");
    return;
  }

  std::string raw_log;
  FILE* log_file = i_isolate->v8_file_logger()->TearDownAndGetLogFile();
  if (!log_file) {
    ThrowError(isolate, "Log file does not exist.");
    return;
  }

  bool exists = false;
  raw_log = i::ReadFile(log_file, &exists, true);
  base::Fclose(log_file);

  if (!exists) {
    ThrowError(isolate, "Unable to read log file.");
    return;
  }
  Local<String> result =
      String::NewFromUtf8(isolate, raw_log.c_str(), NewStringType::kNormal,
                          static_cast<int>(raw_log.size()))
          .ToLocalChecked();

  info.GetReturnValue().Set(result);
}

void Shell::TestVerifySourcePositions(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  Isolate* isolate = info.GetIsolate();
  // Check if the argument is a valid function.
  if (info.Length() != 1) {
    ThrowError(isolate, "Expected function as single argument.");
    return;
  }
  auto arg_handle = Utils::OpenHandle(*info[0]);
  if (!IsHeapObject(*arg_handle) ||
      !IsJSFunctionOrBoundFunctionOrWrappedFunction(
          *i::Cast<i::HeapObject>(arg_handle))) {
    ThrowError(isolate, "Expected function as single argument.");
    return;
  }

  i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);
  HandleScope handle_scope(isolate);

  auto callable =
      i::Cast<i::JSFunctionOrBoundFunctionOrWrappedFunction>(arg_handle);
  while (IsJSBoundFunction(*callable)) {
    internal::DisallowGarbageCollection no_gc;
    auto bound_function = i::Cast<i::JSBoundFunction>(callable);
    auto bound_target = bound_function->bound_target_function();
    if (!IsJSFunctionOrBoundFunctionOrWrappedFunction(bound_target)) {
      internal::AllowGarbageCollection allow_gc;
      ThrowError(isolate, "Expected function as bound target.");
      return;
    }
    callable = handle(
        i::Cast<i::JSFunctionOrBoundFunctionOrWrappedFunction>(bound_target),
        i_isolate);
  }

  i::DirectHandle<i::JSFunction> function = i::Cast<i::JSFunction>(callable);
  if (!function->shared()->HasBytecodeArray()) {
    ThrowError(isolate, "Function has no BytecodeArray attached.");
    return;
  }
  i::Handle<i::BytecodeArray> bytecodes =
      handle(function->shared()->GetBytecodeArray(i_isolate), i_isolate);
  i::interpreter::BytecodeArrayIterator bytecode_iterator(bytecodes);
  bool has_baseline = function->shared()->HasBaselineCode();
  i::Handle<i::TrustedByteArray> bytecode_offsets;
  std::unique_ptr<i::baseline::BytecodeOffsetIterator> offset_iterator;
  if (has_baseline) {
    bytecode_offsets = handle(
        i::Cast<i::TrustedByteArray>(
            function->shared()->GetCode(i_isolate)->bytecode_offset_table()),
        i_isolate);
    offset_iterator = std::make_unique<i::baseline::BytecodeOffsetIterator>(
        bytecode_offsets, bytecodes);
    // A freshly initiated BytecodeOffsetIterator points to the prologue.
    DCHECK_EQ(offset_iterator->current_pc_start_offset(), 0);
    DCHECK_EQ(offset_iterator->current_bytecode_offset(),
              i::kFunctionEntryBytecodeOffset);
    offset_iterator->Advance();
  }
  while (!bytecode_iterator.done()) {
    if (has_baseline) {
      if (offset_iterator->current_bytecode_offset() !=
          bytecode_iterator.current_offset()) {
        ThrowError(isolate, "Baseline bytecode offset mismatch.");
        return;
      }
      // Check that we map every address to this bytecode correctly.
      // The start address is exclusive and the end address inclusive.
      for (i::Address pc = offset_iterator->current_pc_start_offset() + 1;
           pc <= offset_iterator->current_pc_end_offset(); ++pc) {
        i::baseline::BytecodeOffsetIterator pc_lookup(bytecode_offsets,
                                                      bytecodes);
        pc_lookup.AdvanceToPCOffset(pc);
        if (pc_lookup.current_bytecode_offset() !=
            bytecode_iterator.current_offset()) {
          ThrowError(isolate,
                     "Baseline bytecode offset mismatch for PC lookup.");
          return;
        }
      }
    }
    bytecode_iterator.Advance();
    if (has_baseline && !bytecode_iterator.done()) {
      if (offset_iterator->done()) {
        ThrowError(isolate, "Missing bytecode(s) in baseline offset mapping.");
        return;
      }
      offset_iterator->Advance();
    }
  }
  if (has_baseline && !offset_iterator->done()) {
    ThrowError(isolate, "Excess offsets in baseline offset mapping.");
    return;
  }
}

void Shell::InstallConditionalFeatures(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  Isolate* isolate = info.GetIsolate();
  isolate->InstallConditionalFeatures(isolate->GetCurrentContext());
}

void Shell::EnableJSPI(const v8::FunctionCallbackInfo<v8::Value>& info) {
  Isolate* isolate = info.GetIsolate();
  isolate->SetWasmJSPIEnabledCallback([](auto) { return true; });
  isolate->InstallConditionalFeatures(isolate->GetCurrentContext());
}

// async_hooks.createHook() registers functions to be called for different
// lifetime events of each async operation.
void Shell::AsyncHooksCreateHook(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  Local<Object> wrap =
      PerIsolateData::Get(info.GetIsolate())->GetAsyncHooks()->CreateHook(info);
  info.GetReturnValue().Set(wrap);
}

// async_hooks.executionAsyncId() returns the asyncId of the current execution
// context.
void Shell::AsyncHooksExecutionAsyncId(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  Isolate* isolate = info.GetIsolate();
  HandleScope handle_scope(isolate);
  info.GetReturnValue().Set(v8::Number::New(
      isolate,
      PerIsolateData::Get(isolate)->GetAsyncHooks()->GetExecutionAsyncId()));
}

void Shell::AsyncHooksTriggerAsyncId(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  Isolate* isolate = info.GetIsolate();
  HandleScope handle_scope(isolate);
  info.GetReturnValue().Set(v8::Number::New(
      isolate,
      PerIsolateData::Get(isolate)->GetAsyncHooks()->GetTriggerAsyncId()));
}

static v8::debug::DebugDelegate dummy_delegate;

void Shell::EnableDebugger(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::debug::SetDebugDelegate(info.GetIsolate(), &dummy_delegate);
}

void Shell::DisableDebugger(const v8::FunctionCallbackInfo<v8::Value>& in
```
Response: The user wants me to summarize the functionality of the C++ source code file `v8/src/d8/d8.cc`, specifically the fourth part of the file. I also need to illustrate its connection to JavaScript using JavaScript examples.

**Code Analysis - Part 4:**

This part of the code primarily focuses on:

1. **Serialization and Deserialization:** It implements `Serializer` and `Deserializer` classes to handle the process of converting JavaScript values into a byte stream and back. This is crucial for features like postMessage in Web Workers.
2. **Web Worker Support:**  It includes functions related to managing Web Workers (`AddRunningWorker`, `RemoveRunningWorker`, `WaitForRunningWorkers`). This suggests the code enables the creation and management of background JavaScript execution contexts.
3. **Signal Handling:** It sets up a signal handler for `SIGTERM` (on POSIX systems) to dump stack traces before termination, which is useful for debugging, especially in timeout scenarios.
4. **Main Function (`Shell::Main`):** This is the entry point for the d8 command-line tool. It handles:
    *   Initialization of V8 (ICU, platform).
    *   Setting up memory allocators.
    *   Creating and managing isolates.
    *   Executing JavaScript code, potentially in multiple isolates or with code caching.
    *   Running the interactive shell if requested.
    *   Handling CPU profiling.
    *   Integration with Fuzzilli (a JavaScript fuzzer).
    *   Cleanup and shutdown.
5. **REPRL (Read-Eval-Print Loop) for Fuzzing:**  The code has sections that seem to handle a specialized REPRL mode specifically designed for communication with the Fuzzilli fuzzer. This involves sending execution status and coverage information back to the parent process.

**Relationship to JavaScript:**

The code directly supports features that are accessible and used within JavaScript, particularly concerning Web Workers and data transfer.

**JavaScript Examples:**

*   **Web Workers and `postMessage`:** The serialization and deserialization mechanisms are directly used by the `postMessage` API in Web Workers to transfer data between different execution contexts.
*   **Structured Cloning:** The serialization and deserialization are implementations of the structured clone algorithm, which is used in various JavaScript APIs beyond Web Workers (like `localStorage`).
这是 `v8/src/d8/d8.cc` 源代码文件的第四部分，主要涵盖了以下功能：

**1. 序列化与反序列化 (Serialization and Deserialization):**

*   定义了 `Serializer` 类，用于将 JavaScript 的值序列化成可以传输或存储的二进制数据。
*   定义了 `Deserializer` 类，用于将序列化的二进制数据还原成 JavaScript 的值。
*   这两个类实现了 `ValueSerializer::Delegate` 和 `ValueDeserializer::Delegate` 接口，用于处理序列化和反序列化过程中的特定需求，例如处理 `ArrayBuffer`、`SharedArrayBuffer` 和 WebAssembly 模块的传输。
*   `Shell::SerializeValue` 和 `Shell::DeserializeValue` 函数提供了使用这些类的便捷接口。

**与 JavaScript 的关系：**

序列化和反序列化在 JavaScript 中有重要的应用，尤其是在以下场景：

*   **Web Workers:**  当使用 `postMessage` 在不同的 Web Worker 之间传递数据时，数据需要被序列化才能进行跨线程的传输，接收方再进行反序列化。
*   **IndexedDB 和 LocalStorage:**  存储在这些浏览器 API 中的数据也需要进行序列化。
*   **Message Queues 和 IPC (进程间通信):** 在 Node.js 等环境中，序列化常用于在不同进程或服务之间传递数据。

**JavaScript 例子 (Web Workers):**

```javascript
// 主线程
const worker = new Worker('worker.js');
const dataToSend = { message: 'Hello from main thread!' };
worker.postMessage(dataToSend);

// worker.js (工作线程)
onmessage = function(event) {
  const receivedData = event.data; // receivedData 是反序列化后的 JavaScript 对象
  console.log('Worker received:', receivedData);
  const responseData = { reply: 'Hello from worker!' };
  postMessage(responseData); // responseData 会被序列化后发送回主线程
}
```

**2. Web Worker 管理:**

*   `Shell::AddRunningWorker` 和 `Shell::RemoveRunningWorker` 用于跟踪当前正在运行的 Web Worker。
*   `Shell::WaitForRunningWorkers` 用于等待所有正在运行的 Web Worker 完成执行并终止。

**与 JavaScript 的关系：**

这部分代码是 d8 如何模拟和管理 Web Worker 环境的关键。在 d8 中运行包含 Web Worker 的 JavaScript 代码时，这些函数用于管理模拟的 Worker 实例。

**3. 信号处理:**

*   定义了 `d8_sigterm_handler` 函数，用于处理 `SIGTERM` 信号（通常用于进程终止）。
*   `d8_install_sigterm_handler` 函数用于注册该信号处理函数。

**与 JavaScript 的关系：**

虽然 JavaScript 本身没有直接处理信号的概念，但 d8 作为 V8 引擎的命令行工具，需要处理操作系统级别的信号，以便在收到终止信号时能够进行适当的清理和报告。

**4. 主函数 (`Shell::Main`) 的核心逻辑:**

*   这是 d8 程序的入口点，负责整个程序的初始化、执行和清理。
*   **初始化:** 包括解析命令行参数 (`SetOptions`)，初始化 V8 引擎 (`V8::InitializePlatform`, `V8::Initialize`)，设置内存分配器等。
*   **执行:**
    *   创建和管理 V8 隔离区 (Isolate)。
    *   加载和执行 JavaScript 代码 (通过 `RunMain` 和 `RunMainIsolate`)，可以支持多隔离区并行执行。
    *   支持运行交互式 Shell (`RunShell`)。
    *   处理 CPU 性能分析 (`CpuProfiler`).
    *   与 Fuzzilli 等模糊测试工具集成 (通过特殊的 REPRL 模式)。
*   **清理:**  包括清理缓存、重置状态、进行垃圾回收 (`CollectGarbage`) 和释放资源。
*   **REPRL 循环 (Read-Eval-Print Loop) for Fuzzilli:** 这部分代码处理与 Fuzzilli 的通信，允许 Fuzzilli 控制 d8 的执行并获取代码覆盖率等信息。

**与 JavaScript 的关系：**

`Shell::Main` 函数是 d8 如何解释和运行 JavaScript 代码的根本。它模拟了 JavaScript 的运行环境，并提供了各种命令行选项来控制执行行为，例如设置 V8 标志、加载文件、启用性能分析等。

**总结:**

这部分 `d8.cc` 代码的核心功能是 **实现 JavaScript 值的序列化和反序列化，并搭建了 d8 程序的主框架，负责 V8 引擎的初始化、JavaScript 代码的执行、Web Worker 的管理以及与外部工具 (如 Fuzzilli) 的集成**。它直接支撑了 d8 作为 JavaScript 运行时环境的各种能力。

### 提示词
```
这是目录为v8/src/d8/d8.cc的一个c++源代码文件， 请归纳一下它的功能, 如果它与javascript的功能有关系，请用javascript举例说明
这是第4部分，共4部分，请归纳一下它的功能
```

### 源代码
```
unction();
          }
          if (handler_present) {
            // Now wait for messages.
            ProcessMessages();
          }
        }
      }
      Shell::CollectGarbage(isolate_);
    }

    EnterTerminatedState();

    Shell::ResetOnProfileEndListener(isolate_);
    context_.Reset();
    platform::NotifyIsolateShutdown(g_default_platform, isolate_);
  }

  isolate_->Dispose();
  isolate_ = nullptr;

  // Post nullptr to wake the thread waiting on GetMessage() if there is one.
  out_queue_.Enqueue(nullptr);
  out_semaphore_.Signal();
  // Also post an cleanup task to the parent isolate, so that it sees that this
  // worker is terminated and can clean it up in a thread-safe way.
  g_platform->GetForegroundTaskRunner(parent_isolate_)
      ->PostTask(std::make_unique<CleanUpWorkerTask>(parent_isolate_,
                                                     this->shared_from_this()));
}

void Worker::PostMessageOut(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  HandleScope handle_scope(isolate);

  if (info.Length() < 1) {
    ThrowError(isolate, "Invalid argument");
    return;
  }

  Local<Value> message = info[0];
  Local<Value> transfer = Undefined(isolate);
  std::unique_ptr<SerializationData> data =
      Shell::SerializeValue(isolate, message, transfer);
  if (data) {
    DCHECK(info.Data()->IsExternal());
    Local<External> this_value = info.Data().As<External>();
    Worker* worker = static_cast<Worker*>(this_value->Value());

    worker->out_queue_.Enqueue(std::move(data));
    worker->out_semaphore_.Signal();
    g_platform->GetForegroundTaskRunner(worker->parent_isolate_)
        ->PostTask(std::make_unique<CheckMessageFromWorkerTask>(
            worker->parent_isolate_, worker->shared_from_this()));
  }
}

void Worker::ImportScripts(const v8::FunctionCallbackInfo<v8::Value>& info) {
  Shell::ExecuteFile(info);
}

void Worker::Close(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate = info.GetIsolate();
  HandleScope handle_scope(isolate);
  DCHECK(info.Data()->IsExternal());
  Local<External> this_value = info.Data().As<External>();
  Worker* worker = static_cast<Worker*>(this_value->Value());
  worker->Terminate();
}

#ifdef V8_TARGET_OS_WIN
// Enable support for unicode filename path on windows.
// We first convert ansi encoded argv[i] to utf16 encoded, and then
// convert utf16 encoded to utf8 encoded with setting the argv[i]
// to the utf8 encoded arg. We allocate memory for the utf8 encoded
// arg, and we will free it and reset it to nullptr after using
// the filename path arg. And because Execute may be called multiple
// times, we need to free the allocated unicode filename when exit.

// Save the allocated utf8 filenames, and we will free them when exit.
std::vector<char*> utf8_filenames;
#include <shellapi.h>
// Convert utf-16 encoded string to utf-8 encoded.
char* ConvertUtf16StringToUtf8(const wchar_t* str) {
  // On Windows wchar_t must be a 16-bit value.
  static_assert(sizeof(wchar_t) == 2, "wrong wchar_t size");
  int len =
      WideCharToMultiByte(CP_UTF8, 0, str, -1, nullptr, 0, nullptr, FALSE);
  DCHECK_LT(0, len);
  char* utf8_str = new char[len];
  utf8_filenames.push_back(utf8_str);
  WideCharToMultiByte(CP_UTF8, 0, str, -1, utf8_str, len, nullptr, FALSE);
  return utf8_str;
}

// Convert ansi encoded argv[i] to utf8 encoded.
void PreProcessUnicodeFilenameArg(char* argv[], int i) {
  int argc;
  wchar_t** wargv = CommandLineToArgvW(GetCommandLineW(), &argc);
  argv[i] = ConvertUtf16StringToUtf8(wargv[i]);
  LocalFree(wargv);
}

#endif

namespace {

bool FlagMatches(const char* flag, char** arg, bool keep_flag = false) {
  if (strcmp(*arg, flag) == 0) {
    if (!keep_flag) {
      *arg = nullptr;
    }
    return true;
  }
  return false;
}

template <size_t N>
bool FlagWithArgMatches(const char (&flag)[N], char** flag_value, int argc,
                        char* argv[], int* i) {
  char* current_arg = argv[*i];

  // Compare the flag up to the last character of the flag name (not including
  // the null terminator).
  if (strncmp(current_arg, flag, N - 1) == 0) {
    // Match against --flag=value
    if (current_arg[N - 1] == '=') {
      *flag_value = argv[*i] + N;
      argv[*i] = nullptr;
      return true;
    }
    // Match against --flag value
    if (current_arg[N - 1] == '\0') {
      CHECK_LT(*i, argc - 1);
      argv[*i] = nullptr;
      (*i)++;
      *flag_value = argv[*i];
      argv[*i] = nullptr;
      return true;
    }
  }

  flag_value = nullptr;
  return false;
}

}  // namespace

bool Shell::SetOptions(int argc, char* argv[]) {
  bool logfile_per_isolate = false;
  options.d8_path = argv[0];
  for (int i = 0; i < argc; i++) {
    char* flag_value = nullptr;
    if (FlagMatches("--", &argv[i])) {
      i++;
      for (; i < argc; i++) {
        options.arguments.push_back(argv[i]);
        argv[i] = nullptr;
      }
      break;
    } else if (FlagMatches("--no-arguments", &argv[i])) {
      options.include_arguments = false;
    } else if (FlagMatches("--simulate-errors", &argv[i])) {
      options.simulate_errors = true;
    } else if (FlagMatches("--fuzzing", &argv[i], /*keep_flag=*/true) ||
               FlagMatches("--no-abort-on-contradictory-flags", &argv[i],
                           /*keep_flag=*/true) ||
               FlagMatches("--noabort-on-contradictory-flags", &argv[i],
                           /*keep_flag=*/true)) {
      check_d8_flag_contradictions = false;
    } else if (FlagMatches("--abort-on-contradictory-flags", &argv[i],
                           /*keep_flag=*/true)) {
      check_d8_flag_contradictions = true;
    } else if (FlagMatches("--logfile-per-isolate", &argv[i])) {
      logfile_per_isolate = true;
    } else if (FlagMatches("--shell", &argv[i])) {
      options.interactive_shell = true;
    } else if (FlagMatches("--test", &argv[i])) {
      options.test_shell = true;
    } else if (FlagMatches("--notest", &argv[i]) ||
               FlagMatches("--no-test", &argv[i])) {
      options.test_shell = false;
    } else if (FlagMatches("--send-idle-notification", &argv[i])) {
      options.send_idle_notification = true;
    } else if (FlagMatches("--invoke-weak-callbacks", &argv[i])) {
      options.invoke_weak_callbacks = true;
      // TODO(v8:3351): Invoking weak callbacks does not always collect all
      // available garbage.
      options.send_idle_notification = true;
    } else if (FlagMatches("--omit-quit", &argv[i])) {
      options.omit_quit = true;
    } else if (FlagMatches("--no-wait-for-background-tasks", &argv[i])) {
      // TODO(herhut) Remove this flag once wasm compilation is fully
      // isolate-independent.
      options.wait_for_background_tasks = false;
    } else if (FlagMatches("-f", &argv[i], /*keep_flag=*/true)) {
      // Ignore any -f flags for compatibility with other stand-alone
      // JavaScript engines.
      continue;
    } else if (FlagMatches("--ignore-unhandled-promises", &argv[i])) {
      options.ignore_unhandled_promises = true;
    } else if (FlagMatches("--isolate", &argv[i], /*keep_flag=*/true)) {
      options.num_isolates++;
    } else if (FlagMatches("--throws", &argv[i])) {
      options.expected_to_throw = true;
    } else if (FlagMatches("--no-fail", &argv[i])) {
      options.no_fail = true;
    } else if (FlagMatches("--dump-counters", &argv[i])) {
      i::v8_flags.slow_histograms = true;
      options.dump_counters = true;
    } else if (FlagMatches("--dump-counters-nvp", &argv[i])) {
      i::v8_flags.slow_histograms = true;
      options.dump_counters_nvp = true;
    } else if (FlagMatches("--dump-system-memory-stats", &argv[i])) {
      options.dump_system_memory_stats = true;
    } else if (FlagWithArgMatches("--icu-data-file", &flag_value, argc, argv,
                                  &i)) {
      options.icu_data_file = flag_value;
    } else if (FlagWithArgMatches("--icu-locale", &flag_value, argc, argv,
                                  &i)) {
      options.icu_locale = flag_value;
#ifdef V8_USE_EXTERNAL_STARTUP_DATA
    } else if (FlagWithArgMatches("--snapshot_blob", &flag_value, argc, argv,
                                  &i)) {
      options.snapshot_blob = flag_value;
#endif  // V8_USE_EXTERNAL_STARTUP_DATA
    } else if (FlagMatches("--cache", &argv[i]) ||
               FlagWithArgMatches("--cache", &flag_value, argc, argv, &i)) {
      if (!flag_value || strcmp(flag_value, "code") == 0) {
        options.compile_options = v8::ScriptCompiler::kNoCompileOptions;
        options.code_cache_options =
            ShellOptions::CodeCacheOptions::kProduceCache;
      } else if (strcmp(flag_value, "none") == 0) {
        options.compile_options = v8::ScriptCompiler::kNoCompileOptions;
        options.code_cache_options = ShellOptions::kNoProduceCache;
      } else if (strcmp(flag_value, "after-execute") == 0) {
        options.compile_options = v8::ScriptCompiler::kNoCompileOptions;
        options.code_cache_options =
            ShellOptions::CodeCacheOptions::kProduceCacheAfterExecute;
      } else if (strcmp(flag_value, "full-code-cache") == 0) {
        options.compile_options = v8::ScriptCompiler::kEagerCompile;
        options.code_cache_options =
            ShellOptions::CodeCacheOptions::kProduceCache;
      } else {
        fprintf(stderr, "Unknown option to --cache.\n");
        return false;
      }
    } else if (FlagMatches("--streaming-compile", &argv[i])) {
      options.streaming_compile = true;
    } else if ((FlagMatches("--no-streaming-compile", &argv[i])) ||
               (FlagMatches("--nostreaming-compile", &argv[i]))) {
      options.streaming_compile = false;
    } else if (FlagMatches("--enable-tracing", &argv[i])) {
      options.trace_enabled = true;
    } else if (FlagWithArgMatches("--trace-path", &flag_value, argc, argv,
                                  &i)) {
      options.trace_path = flag_value;
    } else if (FlagWithArgMatches("--trace-config", &flag_value, argc, argv,
                                  &i)) {
      options.trace_config = flag_value;
    } else if (FlagMatches("--enable-inspector", &argv[i])) {
      options.enable_inspector = true;
    } else if (FlagWithArgMatches("--lcov", &flag_value, argc, argv, &i)) {
      options.lcov_file = flag_value;
#ifdef V8_OS_LINUX
    } else if (FlagMatches("--scope-linux-perf-to-mark-measure", &argv[i])) {
      options.scope_linux_perf_to_mark_measure = true;
    } else if (FlagWithArgMatches("--perf-ctl-fd", &flag_value, argc, argv,
                                  &i)) {
      options.perf_ctl_fd = atoi(flag_value);
    } else if (FlagWithArgMatches("--perf-ack-fd", &flag_value, argc, argv,
                                  &i)) {
      options.perf_ack_fd = atoi(flag_value);
#endif
    } else if (FlagMatches("--disable-in-process-stack-traces", &argv[i])) {
      options.disable_in_process_stack_traces = true;
#ifdef V8_OS_POSIX
    } else if (FlagWithArgMatches("--read-from-tcp-port", &flag_value, argc,
                                  argv, &i)) {
      options.read_from_tcp_port = atoi(flag_value);
#endif  // V8_OS_POSIX
    } else if (FlagMatches("--enable-os-system", &argv[i])) {
      options.enable_os_system = true;
    } else if (FlagMatches("--no-apply-priority", &argv[i])) {
      options.apply_priority = false;
    } else if (FlagMatches("--quiet-load", &argv[i])) {
      options.quiet_load = true;
    } else if (FlagWithArgMatches("--thread-pool-size", &flag_value, argc, argv,
                                  &i)) {
      options.thread_pool_size = atoi(flag_value);
    } else if (FlagMatches("--stress-delay-tasks", &argv[i])) {
      // Delay execution of tasks by 0-100ms randomly (based on --random-seed).
      options.stress_delay_tasks = true;
    } else if (FlagMatches("--cpu-profiler", &argv[i])) {
      options.cpu_profiler = true;
    } else if (FlagMatches("--cpu-profiler-print", &argv[i])) {
      options.cpu_profiler = true;
      options.cpu_profiler_print = true;
    } else if (FlagMatches("--stress-deserialize", &argv[i])) {
      options.stress_deserialize = true;
    } else if (FlagMatches("--compile-only", &argv[i])) {
      options.compile_only = true;
    } else if (FlagWithArgMatches("--repeat-compile", &flag_value, argc, argv,
                                  &i)) {
      options.repeat_compile = atoi(flag_value);
    } else if (FlagWithArgMatches("--max-serializer-memory", &flag_value, argc,
                                  argv, &i)) {
      // Value is expressed in MB.
      options.max_serializer_memory = atoi(flag_value) * i::MB;
#ifdef V8_FUZZILLI
    } else if (FlagMatches("--fuzzilli-enable-builtins-coverage", &argv[i])) {
      options.fuzzilli_enable_builtins_coverage = true;
    } else if (FlagMatches("--fuzzilli-coverage-statistics", &argv[i])) {
      options.fuzzilli_coverage_statistics = true;
#endif
    } else if (FlagMatches("--no-fuzzy-module-file-extensions", &argv[i])) {
      DCHECK(options.fuzzy_module_file_extensions);
      options.fuzzy_module_file_extensions = false;
#if defined(V8_ENABLE_ETW_STACK_WALKING)
    } else if (FlagMatches("--enable-etw-stack-walking", &argv[i])) {
      options.enable_etw_stack_walking = true;
      // This needs to be manually triggered for JIT ETW events to work.
      i::v8_flags.enable_etw_stack_walking = true;
#if defined(V8_ENABLE_SYSTEM_INSTRUMENTATION)
    } else if (FlagMatches("--enable-system-instrumentation", &argv[i])) {
      options.enable_system_instrumentation = true;
      options.trace_enabled = true;
#endif
#if defined(V8_OS_WIN)
      // Guard this bc the flag has a lot of overhead and is not currently used
      // by macos
      i::v8_flags.interpreted_frames_native_stack = true;
#endif
#endif
#if V8_ENABLE_WEBASSEMBLY
    } else if (FlagMatches("--wasm-trap-handler", &argv[i])) {
      options.wasm_trap_handler = true;
    } else if (FlagMatches("--no-wasm-trap-handler", &argv[i])) {
      options.wasm_trap_handler = false;
#endif  // V8_ENABLE_WEBASSEMBLY
    } else if (FlagMatches("--expose-fast-api", &argv[i])) {
      options.expose_fast_api = true;
    } else {
#ifdef V8_TARGET_OS_WIN
      PreProcessUnicodeFilenameArg(argv, i);
#endif
    }
  }

#ifdef V8_OS_LINUX
  if (options.scope_linux_perf_to_mark_measure) {
    if (options.perf_ctl_fd == -1 || options.perf_ack_fd == -1) {
      fprintf(stderr,
              "Flag --scope-linux-perf-to-mark-measure requires both "
              "--perf-ctl-fd and --perf-ack-fd\n");
      return false;
    }
    SendPerfControlCommand("disable");
  }
#endif

  const char* usage =
      "Synopsis:\n"
      "  shell [options] [--shell] [<file>...]\n"
      "  d8 [options] [-e <string>] [--shell] [--module|]"
      " <file>...]\n\n"
      "  -e        execute a string in V8\n"
      "  --shell   run an interactive JavaScript shell\n"
      "  --module  execute a file as a JavaScript module\n";
  using HelpOptions = i::FlagList::HelpOptions;
  i::v8_flags.abort_on_contradictory_flags = true;
  i::FlagList::SetFlagsFromCommandLine(&argc, argv, true,
                                       HelpOptions(HelpOptions::kExit, usage));
  i::FlagList::ResolveContradictionsWhenFuzzing();

  options.mock_arraybuffer_allocator = i::v8_flags.mock_arraybuffer_allocator;
  options.mock_arraybuffer_allocator_limit =
      i::v8_flags.mock_arraybuffer_allocator_limit;
#ifdef V8_OS_LINUX
  options.multi_mapped_mock_allocator = i::v8_flags.multi_mapped_mock_allocator;
#endif  // V8_OS_LINUX

  if (i::v8_flags.stress_snapshot && options.expose_fast_api &&
      check_d8_flag_contradictions) {
    FATAL("Flag --expose-fast-api is incompatible with --stress-snapshot.");
  }

  // Set up isolated source groups.
  options.isolate_sources = new SourceGroup[options.num_isolates];
  internal::g_num_isolates_for_testing = options.num_isolates;
  SourceGroup* current = options.isolate_sources;
  current->Begin(argv, 1);
  for (int i = 1; i < argc; i++) {
    const char* str = argv[i];
    if (strcmp(str, "--isolate") == 0) {
      current->End(i);
      current++;
      current->Begin(argv, i + 1);
    } else if (strcmp(str, "--module") == 0 || strcmp(str, "--json") == 0) {
      // Pass on to SourceGroup, which understands these options.
    } else if (strncmp(str, "--", 2) == 0) {
      if (!i::v8_flags.correctness_fuzzer_suppressions) {
        printf("Warning: unknown flag %s.\nTry --help for options\n", str);
      }
    } else if (strcmp(str, "-e") == 0 && i + 1 < argc) {
      set_script_executed();
    } else if (strncmp(str, "-", 1) != 0) {
      // Not a flag, so it must be a script to execute.
      set_script_executed();
    }
  }
  current->End(argc);

  if (!logfile_per_isolate && options.num_isolates) {
    V8::SetFlagsFromString("--no-logfile-per-isolate");
  }

  return true;
}

int Shell::RunMain(v8::Isolate* isolate, bool last_run) {
  i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);

  for (int i = 1; i < options.num_isolates; ++i) {
    options.isolate_sources[i].StartExecuteInThread();
  }

  // The Context object, created inside RunMainIsolate, is used after the method
  // returns in some situations:
  const bool keep_context_alive =
      last_run && (use_interactive_shell() || i::v8_flags.stress_snapshot);
  bool success = RunMainIsolate(isolate, keep_context_alive);
  CollectGarbage(isolate);

  // Park the main thread here to prevent deadlocks in shared GCs when
  // waiting in JoinThread.
  i_isolate->main_thread_local_heap()->ExecuteMainThreadWhileParked(
      [last_run](const i::ParkedScope& parked) {
        for (int i = 1; i < options.num_isolates; ++i) {
          if (last_run) {
            options.isolate_sources[i].JoinThread(parked);
          } else {
            options.isolate_sources[i].WaitForThread(parked);
          }
        }
        WaitForRunningWorkers(parked);
      });

  // Other threads have terminated, we can now run the artifical
  // serialize-deserialize pass (which destructively mutates heap state).
  if (success && last_run && i::v8_flags.stress_snapshot) {
    HandleScope handle_scope(isolate);
    static constexpr bool kClearRecompilableData = true;
    auto context = v8::Local<v8::Context>::New(isolate, evaluation_context_);
    i::DirectHandle<i::Context> i_context = Utils::OpenDirectHandle(*context);
    // Stop concurrent compiles before mutating the heap.
    if (i_isolate->concurrent_recompilation_enabled()) {
      i_isolate->optimizing_compile_dispatcher()->Stop();
    }
#if V8_ENABLE_MAGLEV
    if (i_isolate->maglev_concurrent_dispatcher()->is_enabled()) {
      i_isolate->maglev_concurrent_dispatcher()->AwaitCompileJobs();
    }
#endif  // V8_ENABLE_MAGLEV
    // TODO(jgruber,v8:10500): Don't deoptimize once we support serialization
    // of optimized code.
    i::Deoptimizer::DeoptimizeAll(i_isolate);
    // Trigger GC to better align with production code. Also needed by
    // ClearReconstructableDataForSerialization to not look into dead objects.
    i_isolate->heap()->CollectAllAvailableGarbage(
        i::GarbageCollectionReason::kSnapshotCreator);
    i::Snapshot::ClearReconstructableDataForSerialization(
        i_isolate, kClearRecompilableData);
    i::Snapshot::SerializeDeserializeAndVerifyForTesting(i_isolate, i_context);
  }

  if (Shell::unhandled_promise_rejections_.load() > 0) {
    printf("%i pending unhandled Promise rejection(s) detected.\n",
           Shell::unhandled_promise_rejections_.load());
    success = false;
    // RunMain may be executed multiple times, e.g. in REPRL mode, so we have to
    // reset this counter.
    Shell::unhandled_promise_rejections_.store(0);
  }
  // In order to finish successfully, success must be != expected_to_throw.
  if (Shell::options.no_fail) return 0;
  // Fuzzers aren't expected to use --throws, but may pick it up from testcases.
  // In that case, just ignore the flag.
  if (i::v8_flags.fuzzing && Shell::options.expected_to_throw) return 0;
  return (success == Shell::options.expected_to_throw ? 1 : 0);
}

bool Shell::RunMainIsolate(v8::Isolate* isolate, bool keep_context_alive) {
  if (options.lcov_file) {
    debug::Coverage::SelectMode(isolate, debug::CoverageMode::kBlockCount);
  }
  HandleScope scope(isolate);
  Global<Context> global_context;
  {
    Local<Context> context;
    if (!CreateEvaluationContext(isolate).ToLocal(&context)) {
      DCHECK(isolate->IsExecutionTerminating());
      // We must not exit early here in REPRL mode as that would cause the next
      // testcase sent by Fuzzilli to be skipped, which will desynchronize the
      // communication between d8 and Fuzzilli, leading to a crash.
      DCHECK(!fuzzilli_reprl);
      return true;
    }
    global_context.Reset(isolate, context);
    if (keep_context_alive) {
      evaluation_context_.Reset(isolate, context);
    }
  }
  PerIsolateData::RealmScope realm_scope(isolate, global_context);
  InspectorClient inspector_client(isolate, global_context,
                                   options.enable_inspector);
  bool success = true;
  {
    // We cannot use a Context::Scope here, as it keeps a local handle to the
    // context and SourceGroup::Execute may execute a non-nestable task, e.g. a
    // stackless GC.
    global_context.Get(isolate)->Enter();
    if (!options.isolate_sources[0].Execute(isolate)) success = false;
    global_context.Get(isolate)->Exit();
  }
  if (!FinishExecuting(isolate, global_context)) success = false;
  WriteLcovData(isolate, options.lcov_file);
  return success;
}

void Shell::CollectGarbage(Isolate* isolate) {
  if (options.send_idle_notification) {
    isolate->ContextDisposedNotification();
  }
  if (options.invoke_weak_callbacks) {
    // By sending a low memory notifications, we will try hard to collect all
    // garbage and will therefore also invoke all weak callbacks of actually
    // unreachable persistent handles.
    isolate->LowMemoryNotification();
  }
}

namespace {
bool ProcessMessages(
    Isolate* isolate,
    const std::function<platform::MessageLoopBehavior()>& behavior) {
  i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);
  i::SaveAndSwitchContext saved_context(i_isolate, i::Context());
  SealHandleScope shs(isolate);

  if (isolate->IsExecutionTerminating()) return true;
  TryCatch try_catch(isolate);
  try_catch.SetVerbose(true);

  while (true) {
    bool ran_a_task;
    ran_a_task =
        v8::platform::PumpMessageLoop(g_default_platform, isolate, behavior());
    if (isolate->IsExecutionTerminating()) return true;
    if (try_catch.HasCaught()) return false;
    if (ran_a_task) MicrotasksScope::PerformCheckpoint(isolate);
    if (isolate->IsExecutionTerminating()) return true;

    // In predictable mode we push all background tasks into the foreground
    // task queue of the {kProcessGlobalPredictablePlatformWorkerTaskQueue}
    // isolate. We execute all background tasks after running one foreground
    // task.
    if (i::v8_flags.verify_predictable) {
      TryCatch try_catch(isolate);
      try_catch.SetVerbose(true);
      while (v8::platform::PumpMessageLoop(
          g_default_platform, kProcessGlobalPredictablePlatformWorkerTaskQueue,
          platform::MessageLoopBehavior::kDoNotWait)) {
        ran_a_task = true;
        if (try_catch.HasCaught()) return false;
        if (isolate->IsExecutionTerminating()) return true;
      }
    }

    if (!ran_a_task) break;
  }
  if (g_default_platform->IdleTasksEnabled(isolate)) {
    v8::platform::RunIdleTasks(g_default_platform, isolate,
                               50.0 / base::Time::kMillisecondsPerSecond);
    if (try_catch.HasCaught()) return false;
    if (isolate->IsExecutionTerminating()) return true;
  }
  return true;
}
}  // anonymous namespace

bool Shell::CompleteMessageLoop(Isolate* isolate) {
  auto get_waiting_behaviour = [isolate]() {
    if (options.wait_for_background_tasks &&
        isolate->HasPendingBackgroundTasks()) {
      return platform::MessageLoopBehavior::kWaitForWork;
    }
    if (PerIsolateData::Get(isolate)->HasRunningSubscribedWorkers()) {
      return platform::MessageLoopBehavior::kWaitForWork;
    }
    return platform::MessageLoopBehavior::kDoNotWait;
  };
  if (i::v8_flags.verify_predictable) {
    bool ran_tasks = ProcessMessages(
        isolate, [] { return platform::MessageLoopBehavior::kDoNotWait; });
    if (get_waiting_behaviour() ==
        platform::MessageLoopBehavior::kWaitForWork) {
      FATAL(
          "There is outstanding work after executing all tasks in predictable "
          "mode -- this would deadlock.");
    }
    return ran_tasks;
  }
  return ProcessMessages(isolate, get_waiting_behaviour);
}

bool Shell::FinishExecuting(Isolate* isolate, const Global<Context>& context) {
  if (!CompleteMessageLoop(isolate)) return false;
  HandleScope scope(isolate);
  // We cannot use a Context::Scope here, as it keeps a local handle to the
  // context and HandleUnhandledPromiseRejections may execute a non-nestable
  // task, e.g. a stackless GC.
  context.Get(isolate)->Enter();
  bool result = HandleUnhandledPromiseRejections(isolate);
  context.Get(isolate)->Exit();
  return result;
}

bool Shell::EmptyMessageQueues(Isolate* isolate) {
  return ProcessMessages(
      isolate, []() { return platform::MessageLoopBehavior::kDoNotWait; });
}

bool Shell::HandleUnhandledPromiseRejections(Isolate* isolate) {
  if (options.ignore_unhandled_promises) return true;
  PerIsolateData* data = PerIsolateData::Get(isolate);
  int count = data->HandleUnhandledPromiseRejections();
  Shell::unhandled_promise_rejections_.store(
      Shell::unhandled_promise_rejections_.load() + count);
  return count == 0;
}

class Serializer : public ValueSerializer::Delegate {
 public:
  explicit Serializer(Isolate* isolate)
      : isolate_(isolate),
        serializer_(isolate, this),
        current_memory_usage_(0) {}

  Serializer(const Serializer&) = delete;
  Serializer& operator=(const Serializer&) = delete;

  Maybe<bool> WriteValue(Local<Context> context, Local<Value> value,
                         Local<Value> transfer) {
    bool ok;
    DCHECK(!data_);
    data_.reset(new SerializationData);
    if (!PrepareTransfer(context, transfer).To(&ok)) {
      return Nothing<bool>();
    }
    serializer_.WriteHeader();

    if (!serializer_.WriteValue(context, value).To(&ok)) {
      data_.reset();
      return Nothing<bool>();
    }

    if (!FinalizeTransfer().To(&ok)) {
      return Nothing<bool>();
    }

    std::pair<uint8_t*, size_t> pair = serializer_.Release();
    data_->data_.reset(pair.first);
    data_->size_ = pair.second;
    return Just(true);
  }

  std::unique_ptr<SerializationData> Release() { return std::move(data_); }

  void AppendBackingStoresTo(std::vector<std::shared_ptr<BackingStore>>* to) {
    to->insert(to->end(), std::make_move_iterator(backing_stores_.begin()),
               std::make_move_iterator(backing_stores_.end()));
    backing_stores_.clear();
  }

 protected:
  // Implements ValueSerializer::Delegate.
  void ThrowDataCloneError(Local<String> message) override {
    isolate_->ThrowException(Exception::Error(message));
  }

  Maybe<uint32_t> GetSharedArrayBufferId(
      Isolate* isolate, Local<SharedArrayBuffer> shared_array_buffer) override {
    DCHECK_NOT_NULL(data_);
    for (size_t index = 0; index < shared_array_buffers_.size(); ++index) {
      if (shared_array_buffers_[index] == shared_array_buffer) {
        return Just<uint32_t>(static_cast<uint32_t>(index));
      }
    }

    size_t index = shared_array_buffers_.size();
    shared_array_buffers_.emplace_back(isolate_, shared_array_buffer);
    data_->sab_backing_stores_.push_back(
        shared_array_buffer->GetBackingStore());
    return Just<uint32_t>(static_cast<uint32_t>(index));
  }

  Maybe<uint32_t> GetWasmModuleTransferId(
      Isolate* isolate, Local<WasmModuleObject> module) override {
    DCHECK_NOT_NULL(data_);
    for (size_t index = 0; index < wasm_modules_.size(); ++index) {
      if (wasm_modules_[index] == module) {
        return Just<uint32_t>(static_cast<uint32_t>(index));
      }
    }

    size_t index = wasm_modules_.size();
    wasm_modules_.emplace_back(isolate_, module);
    data_->compiled_wasm_modules_.push_back(module->GetCompiledModule());
    return Just<uint32_t>(static_cast<uint32_t>(index));
  }

  void* ReallocateBufferMemory(void* old_buffer, size_t size,
                               size_t* actual_size) override {
    // Not accurate, because we don't take into account reallocated buffers,
    // but this is fine for testing.
    current_memory_usage_ += size;
    if (current_memory_usage_ > Shell::options.max_serializer_memory) {
      return nullptr;
    }

    void* result = base::Realloc(old_buffer, size);
    *actual_size = result ? size : 0;
    return result;
  }

  void FreeBufferMemory(void* buffer) override { base::Free(buffer); }

  bool AdoptSharedValueConveyor(Isolate* isolate,
                                SharedValueConveyor&& conveyor) override {
    data_->shared_value_conveyor_.emplace(std::move(conveyor));
    return true;
  }

 private:
  Maybe<bool> PrepareTransfer(Local<Context> context, Local<Value> transfer) {
    if (transfer->IsArray()) {
      Local<Array> transfer_array = transfer.As<Array>();
      uint32_t length = transfer_array->Length();
      for (uint32_t i = 0; i < length; ++i) {
        Local<Value> element;
        if (transfer_array->Get(context, i).ToLocal(&element)) {
          if (!element->IsArrayBuffer()) {
            isolate_->ThrowError(
                "Transfer array elements must be an ArrayBuffer");
            return Nothing<bool>();
          }

          Local<ArrayBuffer> array_buffer = element.As<ArrayBuffer>();

          if (std::find(array_buffers_.begin(), array_buffers_.end(),
                        array_buffer) != array_buffers_.end()) {
            isolate_->ThrowError(
                "ArrayBuffer occurs in the transfer array more than once");
            return Nothing<bool>();
          }

          serializer_.TransferArrayBuffer(
              static_cast<uint32_t>(array_buffers_.size()), array_buffer);
          array_buffers_.emplace_back(isolate_, array_buffer);
        } else {
          return Nothing<bool>();
        }
      }
      return Just(true);
    } else if (transfer->IsUndefined()) {
      return Just(true);
    } else {
      isolate_->ThrowError("Transfer list must be an Array or undefined");
      return Nothing<bool>();
    }
  }

  Maybe<bool> FinalizeTransfer() {
    for (const auto& global_array_buffer : array_buffers_) {
      Local<ArrayBuffer> array_buffer =
          Local<ArrayBuffer>::New(isolate_, global_array_buffer);
      if (!array_buffer->IsDetachable()) {
        isolate_->ThrowError(
            "ArrayBuffer is not detachable and could not be transferred");
        return Nothing<bool>();
      }

      auto backing_store = array_buffer->GetBackingStore();
      data_->backing_stores_.push_back(std::move(backing_store));
      if (array_buffer->Detach(v8::Local<v8::Value>()).IsNothing()) {
        return Nothing<bool>();
      }
    }

    return Just(true);
  }

  // This must come before ValueSerializer as it caches this value.
  Isolate* isolate_;
  ValueSerializer serializer_;
  std::unique_ptr<SerializationData> data_;
  std::vector<Global<ArrayBuffer>> array_buffers_;
  std::vector<Global<SharedArrayBuffer>> shared_array_buffers_;
  std::vector<Global<WasmModuleObject>> wasm_modules_;
  std::vector<std::shared_ptr<v8::BackingStore>> backing_stores_;
  size_t current_memory_usage_;
};

class Deserializer : public ValueDeserializer::Delegate {
 public:
  Deserializer(Isolate* isolate, std::unique_ptr<SerializationData> data)
      : isolate_(isolate),
        deserializer_(isolate, data->data(), data->size(), this),
        data_(std::move(data)) {
    deserializer_.SetSupportsLegacyWireFormat(true);
  }

  Deserializer(const Deserializer&) = delete;
  Deserializer& operator=(const Deserializer&) = delete;

  MaybeLocal<Value> ReadValue(Local<Context> context) {
    bool read_header;
    if (!deserializer_.ReadHeader(context).To(&read_header)) {
      return MaybeLocal<Value>();
    }

    uint32_t index = 0;
    for (const auto& backing_store : data_->backing_stores()) {
      Local<ArrayBuffer> array_buffer =
          ArrayBuffer::New(isolate_, std::move(backing_store));
      deserializer_.TransferArrayBuffer(index++, array_buffer);
    }

    return deserializer_.ReadValue(context);
  }

  MaybeLocal<SharedArrayBuffer> GetSharedArrayBufferFromId(
      Isolate* isolate, uint32_t clone_id) override {
    DCHECK_NOT_NULL(data_);
    if (clone_id < data_->sab_backing_stores().size()) {
      return SharedArrayBuffer::New(
          isolate_, std::move(data_->sab_backing_stores().at(clone_id)));
    }
    return MaybeLocal<SharedArrayBuffer>();
  }

  MaybeLocal<WasmModuleObject> GetWasmModuleFromId(
      Isolate* isolate, uint32_t transfer_id) override {
    DCHECK_NOT_NULL(data_);
    if (transfer_id >= data_->compiled_wasm_modules().size()) return {};
    return WasmModuleObject::FromCompiledModule(
        isolate_, data_->compiled_wasm_modules().at(transfer_id));
  }

  const SharedValueConveyor* GetSharedValueConveyor(Isolate* isolate) override {
    DCHECK_NOT_NULL(data_);
    if (data_->shared_value_conveyor()) {
      return &data_->shared_value_conveyor().value();
    }
    return nullptr;
  }

 private:
  Isolate* isolate_;
  ValueDeserializer deserializer_;
  std::unique_ptr<SerializationData> data_;
};

class D8Testing {
 public:
  /**
   * Get the number of runs of a given test that is required to get the full
   * stress coverage.
   */
  static int GetStressRuns() {
    if (i::v8_flags.stress_runs != 0) return i::v8_flags.stress_runs;
#ifdef DEBUG
    // In debug mode the code runs much slower so stressing will only make two
    // runs.
    return 2;
#else
    return 5;
#endif
  }

  /**
   * Force deoptimization of all functions.
   */
  static void DeoptimizeAll(Isolate* isolate) {
    i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);
    i::HandleScope scope(i_isolate);
    i::Deoptimizer::DeoptimizeAll(i_isolate);
  }
};

std::unique_ptr<SerializationData> Shell::SerializeValue(
    Isolate* isolate, Local<Value> value, Local<Value> transfer) {
  bool ok;
  Local<Context> context = isolate->GetCurrentContext();
  Serializer serializer(isolate);
  std::unique_ptr<SerializationData> data;
  if (serializer.WriteValue(context, value, transfer).To(&ok)) {
    data = serializer.Release();
  }
  return data;
}

MaybeLocal<Value> Shell::DeserializeValue(
    Isolate* isolate, std::unique_ptr<SerializationData> data) {
  Local<Context> context = isolate->GetCurrentContext();
  Deserializer deserializer(isolate, std::move(data));
  return deserializer.ReadValue(context);
}

void Shell::AddRunningWorker(std::shared_ptr<Worker> worker) {
  workers_mutex_.Pointer()->AssertHeld();  // caller should hold the mutex.
  running_workers_.insert(worker);
}

void Shell::RemoveRunningWorker(const std::shared_ptr<Worker>& worker) {
  base::MutexGuard lock_guard(workers_mutex_.Pointer());
  auto it = running_workers_.find(worker);
  if (it != running_workers_.end()) running_workers_.erase(it);
}

void Shell::WaitForRunningWorkers(const i::ParkedScope& parked) {
  // Make a copy of running_workers_, because we don't want to call
  // Worker::Terminate while holding the workers_mutex_ lock. Otherwise, if a
  // worker is about to create a new Worker, it would deadlock.
  std::unordered_set<std::shared_ptr<Worker>> workers_copy;
  {
    base::MutexGuard lock_guard(workers_mutex_.Pointer());
    allow_new_workers_ = false;
    workers_copy.swap(running_workers_);
  }

  for (auto& worker : workers_copy) {
    worker->TerminateAndWaitForThread(parked);
  }

  // Now that all workers are terminated, we can re-enable Worker creation.
  base::MutexGuard lock_guard(workers_mutex_.Pointer());
  DCHECK(running_workers_.empty());
  allow_new_workers_ = true;
}

namespace {

#ifdef V8_OS_POSIX
void d8_sigterm_handler(int signal, siginfo_t* info, void* context) {
  // Dump stacktraces when terminating d8 instances with SIGTERM.
  // SIGKILL is not intercepted.
  if (signal == SIGTERM) {
    FATAL("d8: Received SIGTERM signal (likely due to a TIMEOUT)\n");
  } else {
    UNREACHABLE();
  }
}
#endif  // V8_OS_POSIX

void d8_install_sigterm_handler() {
#ifdef V8_OS_POSIX
  CHECK(!i::v8_flags.fuzzing);
  struct sigaction sa;
  sa.sa_sigaction = d8_sigterm_handler;
  sigemptyset(&sa.sa_mask);
  sa.sa_flags = 0;
  if (sigaction(SIGTERM, &sa, NULL) == -1) {
    FATAL("Could not install SIGTERM handler");
  }
#endif  // V8_OS_POSIX
}

}  // namespace

int Shell::Main(int argc, char* argv[]) {
  v8::base::EnsureConsoleOutput();
  if (!SetOptions(argc, argv)) return 1;
  if (!i::v8_flags.fuzzing) d8_install_sigterm_handler();

  v8::V8::InitializeICUDefaultLocation(argv[0], options.icu_data_file);

#ifdef V8_OS_DARWIN
  if (options.apply_priority) {
    struct task_category_policy category = {.role =
                                                TASK_FOREGROUND_APPLICATION};
    task_policy_set(mach_task_self(), TASK_CATEGORY_POLICY,
                    (task_policy_t)&category, TASK_CATEGORY_POLICY_COUNT);
    pthread_set_qos_class_self_np(QOS_CLASS_USER_INTERACTIVE, 0);
  }
#endif

#ifdef V8_INTL_SUPPORT
  if (options.icu_locale != nullptr) {
    icu::Locale locale(options.icu_locale);
    UErrorCode error_code = U_ZERO_ERROR;
    icu::Locale::setDefault(locale, error_code);
  }
#endif  // V8_INTL_SUPPORT

  v8::platform::InProcessStackDumping in_process_stack_dumping =
      options.disable_in_process_stack_traces
          ? v8::platform::InProcessStackDumping::kDisabled
          : v8::platform::InProcessStackDumping::kEnabled;

  std::ofstream trace_file;
  std::unique_ptr<platform::tracing::TracingController> tracing;
  if (options.trace_enabled && !i::v8_flags.verify_predictable) {
    tracing = std::make_unique<platform::tracing::TracingController>();

    if (!options.enable_etw_stack_walking) {
      const char* trace_path =
          options.trace_path ? options.trace_path : "v8_trace.json";
      trace_file.open(trace_path);
      if (!trace_file.good()) {
        printf("Cannot open trace file '%s' for writing: %s.\n", trace_path,
               strerror(errno));
        return 1;
      }
    }

#ifdef V8_USE_PERFETTO
    // Set up the in-process backend that the tracing controller will connect
    // to.
    perfetto::TracingInitArgs init_args;
    init_args.backends = perfetto::BackendType::kInProcessBackend;
    perfetto::Tracing::Initialize(init_args);

    tracing->InitializeForPerfetto(&trace_file);
#else
    platform::tracing::TraceBuffer* trace_buffer = nullptr;
#if defined(V8_ENABLE_SYSTEM_INSTRUMENTATION)
    if (options.enable_system_instrumentation) {
      trace_buffer =
          platform::tracing::TraceBuffer::CreateTraceBufferRingBuffer(
              platform::tracing::TraceBuffer::kRingBufferChunks,
              platform::tracing::TraceWriter::
                  CreateSystemInstrumentationTraceWriter());
    }
#endif  // V8_ENABLE_SYSTEM_INSTRUMENTATION
    if (!trace_buffer) {
      trace_buffer =
          platform::tracing::TraceBuffer::CreateTraceBufferRingBuffer(
              platform::tracing::TraceBuffer::kRingBufferChunks,
              platform::tracing::TraceWriter::CreateJSONTraceWriter(
                  trace_file));
    }
    tracing->Initialize(trace_buffer);
#endif  // V8_USE_PERFETTO
  }

  v8::SandboxHardwareSupport::InitializeBeforeThreadCreation();

  platform::tracing::TracingController* tracing_controller = tracing.get();
  if (i::v8_flags.single_threaded) {
    g_platform = v8::platform::NewSingleThreadedDefaultPlatform(
        v8::platform::IdleTaskSupport::kEnabled, in_process_stack_dumping,
        std::move(tracing));
  } else {
    g_platform = v8::platform::NewDefaultPlatform(
        options.thread_pool_size, v8::platform::IdleTaskSupport::kEnabled,
        in_process_stack_dumping, std::move(tracing),
        options.apply_priority ? v8::platform::PriorityMode::kApply
                               : v8::platform::PriorityMode::kDontApply);
  }
  g_default_platform = g_platform.get();
  if (i::v8_flags.predictable) {
    g_platform = MakePredictablePlatform(std::move(g_platform));
  }
  if (options.stress_delay_tasks) {
    int64_t random_seed = i::v8_flags.fuzzer_random_seed;
    if (!random_seed) random_seed = i::v8_flags.random_seed;
    // If random_seed is still 0 here, the {DelayedTasksPlatform} will choose a
    // random seed.
    g_platform = MakeDelayedTasksPlatform(std::move(g_platform), random_seed);
  }

  if (i::v8_flags.trace_turbo_cfg_file == nullptr) {
    V8::SetFlagsFromString("--trace-turbo-cfg-file=turbo.cfg");
  }
  if (i::v8_flags.redirect_code_traces_to == nullptr) {
    V8::SetFlagsFromString("--redirect-code-traces-to=code.asm");
  }
  v8::V8::InitializePlatform(g_platform.get());

  // Disable flag freezing if we are producing a code cache, because for that we
  // modify v8_flags.hash_seed (below).
  if (options.code_cache_options != ShellOptions::kNoProduceCache) {
    i::v8_flags.freeze_flags_after_init = false;
  }

  v8::V8::Initialize();
  if (options.snapshot_blob) {
    v8::V8::InitializeExternalStartupDataFromFile(options.snapshot_blob);
  } else {
    v8::V8::InitializeExternalStartupData(argv[0]);
  }
  int result = 0;
  Isolate::CreateParams create_params;
  ShellArrayBufferAllocator shell_array_buffer_allocator;
  MockArrayBufferAllocator mock_arraybuffer_allocator;
  const size_t memory_limit =
      options.mock_arraybuffer_allocator_limit * options.num_isolates;
  MockArrayBufferAllocatiorWithLimit mock_arraybuffer_allocator_with_limit(
      memory_limit >= options.mock_arraybuffer_allocator_limit
          ? memory_limit
          : std::numeric_limits<size_t>::max());
#ifdef V8_OS_LINUX
  MultiMappedAllocator multi_mapped_mock_allocator;
#endif  // V8_OS_LINUX
  if (options.mock_arraybuffer_allocator) {
    if (memory_limit) {
      Shell::array_buffer_allocator = &mock_arraybuffer_allocator_with_limit;
    } else {
      Shell::array_buffer_allocator = &mock_arraybuffer_allocator;
    }
#ifdef V8_OS_LINUX
  } else if (options.multi_mapped_mock_allocator) {
    Shell::array_buffer_allocator = &multi_mapped_mock_allocator;
#endif  // V8_OS_LINUX
  } else {
    Shell::array_buffer_allocator = &shell_array_buffer_allocator;
  }
  create_params.array_buffer_allocator = Shell::array_buffer_allocator;
#ifdef ENABLE_VTUNE_JIT_INTERFACE
  if (i::v8_flags.enable_vtunejit) {
    create_params.code_event_handler = vTune::GetVtuneCodeEventHandler();
  }
#endif  // ENABLE_VTUNE_JIT_INTERFACE
  create_params.constraints.ConfigureDefaults(
      base::SysInfo::AmountOfPhysicalMemory(),
      base::SysInfo::AmountOfVirtualMemory());

  Shell::counter_map_ = new CounterMap();
  if (options.dump_counters || options.dump_counters_nvp ||
      i::TracingFlags::is_gc_stats_enabled()) {
    create_params.counter_lookup_callback = LookupCounter;
    create_params.create_histogram_callback = CreateHistogram;
    create_params.add_histogram_sample_callback = AddHistogramSample;
  }

#if V8_ENABLE_WEBASSEMBLY
  if (V8_TRAP_HANDLER_SUPPORTED && options.wasm_trap_handler) {
    constexpr bool kUseDefaultTrapHandler = true;
    if (!v8::V8::EnableWebAssemblyTrapHandler(kUseDefaultTrapHandler)) {
      FATAL("Could not register trap handler");
    }
  }
#endif  // V8_ENABLE_WEBASSEMBLY

  if (i::v8_flags.experimental) {
    // This message is printed to stderr so that it is also visible in
    // Clusterfuzz reports.
    fprintf(stderr,
            "V8 is running with experimental features enabled. Stability and "
            "security will suffer.\n");
  }

  Isolate* isolate = Isolate::New(create_params);

#ifdef V8_FUZZILLI
  // Let the parent process (Fuzzilli) know we are ready.
  if (options.fuzzilli_enable_builtins_coverage) {
    cov_init_builtins_edges(static_cast<uint32_t>(
        i::BasicBlockProfiler::Get()
            ->GetCoverageBitmap(reinterpret_cast<i::Isolate*>(isolate))
            .size()));
  }
  char helo[] = "HELO";
  if (write(REPRL_CWFD, helo, 4) != 4 || read(REPRL_CRFD, helo, 4) != 4) {
    fuzzilli_reprl = false;
  }

  if (memcmp(helo, "HELO", 4) != 0) {
    FATAL("REPRL: Invalid response from parent");
  }
#endif  // V8_FUZZILLI

  {
    Isolate::Scope scope(isolate);
    D8Console console(isolate);
    Initialize(isolate, &console);
    PerIsolateData data(isolate);

    // Fuzzilli REPRL = read-eval-print-loop
    do {
#ifdef V8_FUZZILLI
      if (fuzzilli_reprl) {
        unsigned action = 0;
        ssize_t nread = read(REPRL_CRFD, &action, 4);
        if (nread != 4 || action != 'cexe') {
          FATAL("REPRL: Unknown action: %u", action);
        }
      }
#endif  // V8_FUZZILLI

      result = 0;

      if (options.trace_enabled) {
        platform::tracing::TraceConfig* trace_config;
        if (options.trace_config) {
          int size = 0;
          char* trace_config_json_str = ReadChars(options.trace_config, &size);
          trace_config = tracing::CreateTraceConfigFromJSON(
              isolate, trace_config_json_str);
          delete[] trace_config_json_str;
        } else {
          trace_config =
              platform::tracing::TraceConfig::CreateDefaultTraceConfig();
          if (options.enable_system_instrumentation) {
            trace_config->AddIncludedCategory("disabled-by-default-v8.compile");
          }
        }
        tracing_controller->StartTracing(trace_config);
      }

      CpuProfiler* cpu_profiler;
      if (options.cpu_profiler) {
        cpu_profiler = CpuProfiler::New(isolate);
        cpu_profiler->StartProfiling(String::Empty(isolate),
                                     CpuProfilingOptions{});
      }

      if (i::v8_flags.stress_runs > 0) {
        options.stress_runs = i::v8_flags.stress_runs;
        for (int i = 0; i < options.stress_runs && result == 0; i++) {
          printf("============ Run %d/%d ============\n", i + 1,
                 options.stress_runs.get());
          bool last_run = i == options.stress_runs - 1;
          result = RunMain(isolate, last_run);
        }
      } else if (options.code_cache_options != ShellOptions::kNoProduceCache) {
        // Park the main thread here in case the new isolate wants to perform
        // a shared GC to prevent a deadlock.
        reinterpret_cast<i::Isolate*>(isolate)
            ->main_thread_local_isolate()
            ->ExecuteMainThreadWhileParked([&result]() {
              printf("============ Run: Produce code cache ============\n");
              // First run to produce the cache
              Isolate::CreateParams create_params2;
              create_params2.array_buffer_allocator =
                  Shell::array_buffer_allocator;
              // Use a different hash seed.
              i::v8_flags.hash_seed = i::v8_flags.hash_seed ^ 1337;
              Isolate* isolate2 = Isolate::New(create_params2);
              // Restore old hash seed.
              i::v8_flags.hash_seed = i::v8_flags.hash_seed ^ 1337;
              {
                Isolate::Scope isolate_scope(isolate2);
                D8Console console2(isolate2);
                Initialize(isolate2, &console2);
                PerIsolateData data2(isolate2);

                result = RunMain(isolate2, false);
                ResetOnProfileEndListener(isolate2);
              }
              // D8WasmAsyncResolvePromiseTask may be still in the runner at
              // this point. We need to terminate the task runners before the
              // Isolate to avoid retaining stray tasks with v8::Global pointing
              // into a reclaimed Isolate.
              platform::NotifyIsolateShutdown(g_default_platform, isolate2);
              isolate2->Dispose();
            });

        // Change the options to consume cache
        DCHECK(options.compile_options == v8::ScriptCompiler::kEagerCompile ||
               options.compile_options ==
                   v8::ScriptCompiler::kNoCompileOptions);
        options.compile_options.Overwrite(
            v8::ScriptCompiler::kConsumeCodeCache);
        options.code_cache_options.Overwrite(ShellOptions::kNoProduceCache);

        printf("============ Run: Consume code cache ============\n");
        // Second run to consume the cache in current isolate
        result = RunMain(isolate, true);
        options.compile_options.Overwrite(
            v8::ScriptCompiler::kNoCompileOptions);
      } else {
        bool last_run = true;
        result = RunMain(isolate, last_run);
      }

      // Run interactive shell if explicitly requested or if no script has been
      // executed, but never on --test
      if (use_interactive_shell()) {
        RunShell(isolate);
      }

      if (i::v8_flags.trace_ignition_dispatches_output_file != nullptr) {
        WriteIgnitionDispatchCountersFile(isolate);
      }

      if (options.cpu_profiler) {
        CpuProfile* profile =
            cpu_profiler->StopProfiling(String::Empty(isolate));
        if (options.cpu_profiler_print) {
          const internal::ProfileNode* root =
              reinterpret_cast<const internal::ProfileNode*>(
                  profile->GetTopDownRoot());
          root->Print(0);
        }
        profile->Delete();
        cpu_profiler->Dispose();
      }

#ifdef V8_FUZZILLI
      // Send result to parent (fuzzilli) and reset edge guards.
      if (fuzzilli_reprl) {
        int status = result << 8;
        std::vector<bool> bitmap;
        if (options.fuzzilli_enable_builtins_coverage) {
          bitmap = i::BasicBlockProfiler::Get()->GetCoverageBitmap(
              reinterpret_cast<i::Isolate*>(isolate));
          cov_update_builtins_basic_block_coverage(bitmap);
        }
        if (options.fuzzilli_coverage_statistics) {
          int tot = 0;
          for (bool b : bitmap) {
            if (b) tot++;
          }
          static int iteration_counter = 0;
          std::ofstream covlog("covlog.txt", std::ios::app);
          covlog << iteration_counter << "\t" << tot << "\t"
                 << sanitizer_cov_count_discovered_edges() << "\t"
                 << bitmap.size() << std::endl;
          iteration_counter++;
        }
        // In REPRL mode, stdout and stderr can be regular files, so they need
        // to be flushed after every execution
        fflush(stdout);
        fflush(stderr);
        CHECK_EQ(write(REPRL_CWFD, &status, 4), 4);
        sanitizer_cov_reset_edgeguards();
        if (options.fuzzilli_enable_builtins_coverage) {
          i::BasicBlockProfiler::Get()->ResetCounts(
              reinterpret_cast<i::Isolate*>(isolate));
        }
      }
#endif  // V8_FUZZILLI
    } while (fuzzilli_reprl);

    // Shut down contexts and collect garbage.
    cached_code_map_.clear();
    evaluation_context_.Reset();
    stringify_function_.Reset();
    ResetOnProfileEndListener(isolate);
    CollectGarbage(isolate);
  }
  OnExit(isolate, true);

  // Delete the platform explicitly here to write the tracing output to the
  // tracing file.
  if (options.trace_enabled) {
    tracing_controller->StopTracing();
  }
  g_platform.reset();

#ifdef V8_TARGET_OS_WIN
  // We need to free the allocated utf8 filenames in
  // PreProcessUnicodeFilenameArg.
  for (char* utf8_str : utf8_filenames) {
    delete[] utf8_str;
  }
  utf8_filenames.clear();
#endif

  return result;
}

}  // namespace v8

int main(int argc, char* argv[]) { return v8::Shell::Main(argc, argv); }

#undef CHECK
#undef DCHECK
```
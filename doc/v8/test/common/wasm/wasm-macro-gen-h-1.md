Response:
The user wants a summary of the functionality of the provided C++ header file `v8/test/common/wasm/wasm-macro-gen.h`.

Here's a breakdown of the thought process to generate the answer:

1. **Identify the file type and purpose:** The filename ends in `.h`, indicating a header file. The name `wasm-macro-gen.h` strongly suggests it's related to WebAssembly and macro generation. The `test/common` path suggests it's used for testing purposes within the V8 project.

2. **Scan for defining keywords:** Look for keywords like `#define`, `static_cast`, comments, and code structures to understand the file's content. The abundance of `#define` indicates this file is primarily about defining macros.

3. **Categorize the macros:** Observe the naming conventions of the macros. Many start with `WASM_` followed by an operation or data type. This suggests a grouping by functionality. Group similar macros together. For instance, there are groups for:
    * Basic WASM opcodes (`WASM_GC_OP`, `WASM_LOCAL_GET`, etc.)
    * Control flow (`WASM_BLOCK`, `WASM_LOOP`, `WASM_IF`, etc.)
    * Global variables (`WASM_GLOBAL_GET`, `WASM_GLOBAL_SET`)
    * Table operations (`WASM_TABLE_GET`, `WASM_TABLE_SET`)
    * Memory operations (`WASM_LOAD`, `WASM_STORE`, `WASM_MEMORY_GROW`, etc.)
    * Function calls (`WASM_CALL_FUNCTION`, `WASM_CALL_INDIRECT`, `WASM_CALL_REF`)
    * Data type specific operations (e.g., `WASM_I32_ADD`, `WASM_F64_SQRT`) for integers, floats, etc.
    * Conversions (`WASM_I32_SCONVERT_F32`, etc.)
    * Reference types (`WASM_REF_NULL`, `WASM_REF_IS_NULL`, etc.)
    * Garbage Collection related operations (`WASM_STRUCT_NEW`, `WASM_FIELD_GET`, etc.)
    * Array operations (`WASM_ARRAY_NEW`, `WASM_ARRAY_GET`, etc.)
    * Atomic operations (`WASM_ATOMICS_BINOP`, etc.)
    * SIMD operations (`WASM_SIMD_OP`, `WASM_SIMD_LOAD_MEM`, etc.)

4. **Infer functionality from macro names and parameters:** Analyze what each macro likely does based on its name and parameters. For example, `WASM_I32_ADD(x, y)` likely generates the bytecode for adding two 32-bit integers. `WASM_LOAD(type, offset, index)` likely generates the bytecode for loading a value of a specific type from memory at a given offset and index. The presence of `kExpr...` constants suggests these macros generate WebAssembly bytecode.

5. **Address the `.tq` file question:** The prompt specifically asks about `.tq` files. Based on general V8 knowledge, `.tq` files are related to Torque, V8's type system and code generation language. Therefore, the header file is *not* a Torque file.

6. **Consider the relationship to JavaScript:** WebAssembly is designed to work alongside JavaScript. The macros generate WASM bytecode. Provide examples of how these WASM operations, facilitated by the macros, correspond to JavaScript functionalities (e.g., arithmetic operations, memory access, function calls).

7. **Address code logic and examples:**  Choose a few representative macros and provide examples of how they might be used, along with hypothetical inputs and outputs (the generated bytecode).

8. **Consider common programming errors:**  Think about the typical mistakes developers might make when working with WASM or similar low-level concepts. Examples include type mismatches, incorrect memory access, and misuse of control flow. Relate these to how the macros might help or where errors could still occur.

9. **Synthesize the summary:** Combine the observations and inferences into a concise summary of the file's purpose. Emphasize that it's a utility for generating WASM bytecode within tests.

10. **Review and refine:** Read through the generated answer to ensure clarity, accuracy, and completeness. Ensure all parts of the prompt have been addressed. For the "part 2" instruction, make sure the final summary accurately reflects the cumulative functionality.

**(Self-Correction during the process):**

* Initially, I might have focused too much on individual macro definitions. It's more important to group them by functionality for a higher-level understanding.
* I need to be careful not to confuse the purpose of the *test* file with the core WASM implementation. This file is for *generating* WASM *within tests*.
* When giving JavaScript examples, ensure they are simple and clearly illustrate the corresponding WASM functionality.
* The "hypothetical input and output" needs to be realistic in the context of WASM bytecode generation (opcodes and operands).
好的，这是对 `v8/test/common/wasm/wasm-macro-gen.h` 文件功能的归纳总结：

**功能归纳：**

`v8/test/common/wasm/wasm-macro-gen.h` 是 V8 JavaScript 引擎中用于 WebAssembly (Wasm) 测试的 **C++ 宏定义头文件**。它的主要功能是提供了一系列宏，用于 **简洁地生成 WebAssembly 字节码序列**。

具体来说，这些宏封装了 Wasm 的各种指令 (opcodes) 和操作数，使得在编写 Wasm 测试代码时，开发者无需手动构建复杂的字节码序列，而是可以使用更具可读性的宏来表达 Wasm 的逻辑。

**主要功能点：**

* **定义 WebAssembly 指令宏:**  文件中定义了大量的宏，每个宏都对应一个或一组 WebAssembly 指令。 例如：
    * `WASM_GC_OP(opcode)`: 用于生成垃圾回收相关的操作码。
    * `WASM_LOCAL_GET(index)`: 用于获取局部变量。
    * `WASM_I32_ADD(x, y)`: 用于生成 32 位整数加法指令。
    * `WASM_LOAD(type, offset, index)`: 用于生成内存加载指令。
    * `WASM_CALL_FUNCTION(index, ...)`: 用于生成函数调用指令。
    *  以及各种控制流、内存操作、数学运算、类型转换、原子操作、SIMD 指令等。

* **简化字节码生成:**  使用这些宏，可以将复杂的字节码序列用更简洁的代码表示。例如，要生成将两个局部变量相加并将结果存回第一个局部变量的 Wasm 代码，可以使用宏：
   ```c++
   WASM_LOCAL_GET(0), WASM_LOCAL_GET(1), WASM_I32_ADD, WASM_LOCAL_SET(0)
   ```
   而不需要手动写出对应的字节码。

* **支持各种 Wasm 特性:**  文件中包含了对 WebAssembly 各个特性的支持，包括核心指令、引用类型 (Reference Types)、垃圾回收 (GC)、固定宽度 SIMD (Fixed-Width SIMD)、原子操作 (Atomics) 等。

* **用于测试:**  由于文件路径在 `v8/test/common/wasm/` 下，可以确定这些宏主要用于 V8 引擎中 WebAssembly 功能的单元测试和集成测试。测试人员可以使用这些宏方便地构造各种 Wasm 模块和实例，以验证 V8 引擎的 Wasm 实现是否正确。

**关于 .tq 文件和 JavaScript 关系：**

* **不是 Torque 文件:**  即使 `v8/test/common/wasm/wasm-macro-gen.h` 以 `.tq` 结尾，它仍然是一个 C++ 头文件，而不是 V8 的 Torque 源代码文件。Torque 文件通常用于定义 V8 内部的类型系统和内置函数的实现。

* **与 JavaScript 的关系:**  WebAssembly 的设计目标之一是作为 JavaScript 的补充，提供高性能的执行能力。`wasm-macro-gen.h` 中定义的宏最终生成的是可以在 JavaScript 环境中运行的 WebAssembly 字节码。

**JavaScript 示例 (假设的对应关系):**

虽然这个头文件是 C++ 代码，但它生成的 Wasm 字节码与 JavaScript 的功能息息相关。例如，`WASM_I32_ADD(x, y)` 生成的 Wasm 指令对应于 JavaScript 中的加法运算：

```javascript
// JavaScript
let a = 10;
let b = 20;
let sum = a + b;

// 对应的 WASM (使用宏生成) 可能包含类似如下的指令序列：
// local.get 0  (获取局部变量 0，对应 a)
// local.get 1  (获取局部变量 1，对应 b)
// i32.add      (执行 32 位整数加法)
// local.set 2  (将结果存入局部变量 2，对应 sum)
```

`WASM_LOAD(kWasmI32, 0, 0)` 生成的内存加载指令对应于 JavaScript 中访问 `ArrayBuffer` 或 `WebAssembly.Memory` 的操作：

```javascript
// JavaScript
const memory = new WebAssembly.Memory({ initial: 1 });
const buffer = new Uint32Array(memory.buffer);
let value = buffer[0]; // 访问内存地址 0 的 32 位整数

// 对应的 WASM (使用宏生成) 可能包含类似如下的指令：
// i32.const 0   (加载常量 0，作为内存地址)
// i32.load      (从内存地址 0 加载 i32 类型的值)
```

**代码逻辑推理 (假设输入与输出):**

假设我们使用以下宏：

```c++
WASM_LOCAL_GET(0),  // 假设局部变量 0 的索引为 0
WASM_I32_CONST(5),
WASM_I32_ADD
```

**假设输入：**
* 局部变量 0 的值为整数 10。

**输出 (推断的 WebAssembly 字节码片段):**

这会生成如下的 WebAssembly 字节码序列 (具体的字节码值可能会因编码方式而异)：

* `0x20 0x00`  (对应 `local.get 0`)
* `0x41 0x05`  (对应 `i32.const 5`)
* `0x6A`      (对应 `i32.add`)

**功能说明：**  这段代码片段的功能是将局部变量 0 的值 (10) 与常量 5 相加，结果会放在栈顶。

**用户常见的编程错误举例：**

在使用这些宏或编写 WebAssembly 代码时，常见的编程错误包括：

* **类型不匹配:**  例如，尝试将浮点数存储到声明为整数类型的局部变量或内存位置。使用宏可以减少这种错误，因为宏通常会强制指定类型。

   ```c++
   // 错误示例 (如果宏没有进行类型检查)
   // WASM_F32_CONST(3.14), WASM_LOCAL_SET(0) // 如果局部变量 0 是 i32 类型
   ```

* **栈溢出或下溢:**  在操作栈时，推送和弹出的数量不匹配会导致栈状态错误。宏通过封装指令序列，一定程度上可以避免手动操作栈时的错误。

   ```c++
   // 错误示例：缺少操作数
   // WASM_I32_ADD  // 缺少两个需要相加的值
   ```

* **越界访问内存或表:**  尝试访问超出分配范围的内存地址或表索引。

   ```c++
   // 错误示例：访问超出范围的内存
   // WASM_I32_CONST(100000), WASM_LOAD(kWasmI32, 0, 0) // 如果内存大小不足以访问地址 100000
   ```

* **不正确的控制流:**  例如，跳转到不存在的标签或 `if` 块没有 `end`。宏 `WASM_BLOCK`, `WASM_LOOP`, `WASM_IF` 等可以帮助正确构建控制流结构。

总之，`v8/test/common/wasm/wasm-macro-gen.h` 提供了一套便捷的工具，用于在 V8 的 WebAssembly 测试中生成和管理 WebAssembly 字节码，提高了测试代码的可读性和维护性，并降低了手动编写字节码的出错率。

### 提示词
```
这是目录为v8/test/common/wasm/wasm-macro-gen.h的一个v8源代码， 请列举一下它的功能, 
如果v8/test/common/wasm/wasm-macro-gen.h以.tq结尾，那它是个v8 torque源代码，
如果它与javascript的功能有关系，请用javascript举例说明,
如果有代码逻辑推理，请给出假设输入与输出，
如果涉及用户常见的编程错误，请举例说明
这是第2部分，共2部分，请归纳一下它的功能
```

### 源代码
```c
\
      static_cast<uint8_t>(0b01), /*source is nullable*/ \
      static_cast<uint8_t>(depth), ToByte(sourcetype), ToByte(targettype)
#define WASM_BR_ON_CAST_NULL(depth, sourcetype, targettype)    \
  WASM_GC_OP(kExprBrOnCast),                                   \
      static_cast<uint8_t>(0b11) /*source & target nullable*/, \
      static_cast<uint8_t>(depth), ToByte(sourcetype), ToByte(targettype)
#define WASM_BR_ON_CAST_FAIL(depth, sourcetype, targettype) \
  WASM_GC_OP(kExprBrOnCastFail),                            \
      static_cast<uint8_t>(0b01), /*source is nullable*/    \
      static_cast<uint8_t>(depth), ToByte(sourcetype), ToByte(targettype)
#define WASM_BR_ON_CAST_FAIL_NULL(depth, sourcetype, targettype) \
  WASM_GC_OP(kExprBrOnCastFail),                                 \
      static_cast<uint8_t>(0b11), /*source, target nullable*/    \
      static_cast<uint8_t>(depth), ToByte(sourcetype), ToByte(targettype)

#define WASM_GC_ANY_CONVERT_EXTERN(extern) \
  extern, WASM_GC_OP(kExprAnyConvertExtern)
#define WASM_GC_EXTERN_CONVERT_ANY(ref) ref, WASM_GC_OP(kExprExternConvertAny)

#define WASM_ARRAY_NEW(typeidx, default_value, length) \
  default_value, length, WASM_GC_OP(kExprArrayNew), ToByte(typeidx)
#define WASM_ARRAY_NEW_DEFAULT(typeidx, length) \
  length, WASM_GC_OP(kExprArrayNewDefault), ToByte(typeidx)
#define WASM_ARRAY_GET(typeidx, array, index) \
  array, index, WASM_GC_OP(kExprArrayGet), ToByte(typeidx)
#define WASM_ARRAY_GET_U(typeidx, array, index) \
  array, index, WASM_GC_OP(kExprArrayGetU), ToByte(typeidx)
#define WASM_ARRAY_GET_S(typeidx, array, index) \
  array, index, WASM_GC_OP(kExprArrayGetS), ToByte(typeidx)
#define WASM_ARRAY_SET(typeidx, array, index, value) \
  array, index, value, WASM_GC_OP(kExprArraySet), ToByte(typeidx)
#define WASM_ARRAY_LEN(array) array, WASM_GC_OP(kExprArrayLen)
#define WASM_ARRAY_COPY(dst_typeidx, src_typeidx, dst_array, dst_index, \
                        src_array, src_index, length)                   \
  dst_array, dst_index, src_array, src_index, length,                   \
      WASM_GC_OP(kExprArrayCopy), ToByte(dst_typeidx), ToByte(src_typeidx)
#define WASM_ARRAY_NEW_FIXED(typeidx, length, ...)              \
  __VA_ARGS__, WASM_GC_OP(kExprArrayNewFixed), ToByte(typeidx), \
      static_cast<uint8_t>(length)

#define WASM_REF_I31(val) val, WASM_GC_OP(kExprRefI31)
#define WASM_I31_GET_S(val) val, WASM_GC_OP(kExprI31GetS)
#define WASM_I31_GET_U(val) val, WASM_GC_OP(kExprI31GetU)

#define WASM_BR_ON_NULL(depth, ref_object) \
  ref_object, kExprBrOnNull, static_cast<uint8_t>(depth)

#define WASM_BR_ON_NON_NULL(depth, ref_object) \
  ref_object, kExprBrOnNonNull, static_cast<uint8_t>(depth)

// Pass: sig_index, ...args, func_index
#define WASM_CALL_INDIRECT(sig_index, ...) \
  __VA_ARGS__, kExprCallIndirect, ToByte(sig_index), TABLE_ZERO
#define WASM_CALL_INDIRECT_TABLE(table, sig_index, ...) \
  __VA_ARGS__, kExprCallIndirect, ToByte(sig_index), static_cast<uint8_t>(table)
#define WASM_RETURN_CALL_INDIRECT(sig_index, ...) \
  __VA_ARGS__, kExprReturnCallIndirect, ToByte(sig_index), TABLE_ZERO

#define WASM_CALL_REF(func_ref, sig_index, ...) \
  __VA_ARGS__, func_ref, kExprCallRef, ToByte(sig_index)

#define WASM_RETURN_CALL_REF(func_ref, sig_index, ...) \
  __VA_ARGS__, func_ref, kExprReturnCallRef, ToByte(sig_index)

#define WASM_NOT(x) x, kExprI32Eqz
#define WASM_SEQ(...) __VA_ARGS__

//------------------------------------------------------------------------------
// Constructs that are composed of multiple bytecodes.
//------------------------------------------------------------------------------
#define WASM_WHILE(x, y)                                                      \
  kExprLoop, kVoidCode, x, kExprIf, kVoidCode, y, kExprBr, DEPTH_1, kExprEnd, \
      kExprEnd
#define WASM_INC_LOCAL(index)                                                \
  kExprLocalGet, static_cast<uint8_t>(index), kExprI32Const, 1, kExprI32Add, \
      kExprLocalTee, static_cast<uint8_t>(index)
#define WASM_INC_LOCAL_BYV(index, count)                       \
  kExprLocalGet, static_cast<uint8_t>(index), kExprI32Const,   \
      static_cast<uint8_t>(count), kExprI32Add, kExprLocalTee, \
      static_cast<uint8_t>(index)
#define WASM_INC_LOCAL_BY(index, count)                        \
  kExprLocalGet, static_cast<uint8_t>(index), kExprI32Const,   \
      static_cast<uint8_t>(count), kExprI32Add, kExprLocalSet, \
      static_cast<uint8_t>(index)
#define WASM_UNOP(opcode, x) x, static_cast<uint8_t>(opcode)
#define WASM_BINOP(opcode, x, y) x, y, static_cast<uint8_t>(opcode)

//------------------------------------------------------------------------------
// Int32 operations
//------------------------------------------------------------------------------
#define WASM_I32_ADD(x, y) x, y, kExprI32Add
#define WASM_I32_SUB(x, y) x, y, kExprI32Sub
#define WASM_I32_MUL(x, y) x, y, kExprI32Mul
#define WASM_I32_DIVS(x, y) x, y, kExprI32DivS
#define WASM_I32_DIVU(x, y) x, y, kExprI32DivU
#define WASM_I32_REMS(x, y) x, y, kExprI32RemS
#define WASM_I32_REMU(x, y) x, y, kExprI32RemU
#define WASM_I32_AND(x, y) x, y, kExprI32And
#define WASM_I32_IOR(x, y) x, y, kExprI32Ior
#define WASM_I32_XOR(x, y) x, y, kExprI32Xor
#define WASM_I32_SHL(x, y) x, y, kExprI32Shl
#define WASM_I32_SHR(x, y) x, y, kExprI32ShrU
#define WASM_I32_SAR(x, y) x, y, kExprI32ShrS
#define WASM_I32_ROR(x, y) x, y, kExprI32Ror
#define WASM_I32_ROL(x, y) x, y, kExprI32Rol
#define WASM_I32_EQ(x, y) x, y, kExprI32Eq
#define WASM_I32_NE(x, y) x, y, kExprI32Ne
#define WASM_I32_LTS(x, y) x, y, kExprI32LtS
#define WASM_I32_LES(x, y) x, y, kExprI32LeS
#define WASM_I32_LTU(x, y) x, y, kExprI32LtU
#define WASM_I32_LEU(x, y) x, y, kExprI32LeU
#define WASM_I32_GTS(x, y) x, y, kExprI32GtS
#define WASM_I32_GES(x, y) x, y, kExprI32GeS
#define WASM_I32_GTU(x, y) x, y, kExprI32GtU
#define WASM_I32_GEU(x, y) x, y, kExprI32GeU
#define WASM_I32_CLZ(x) x, kExprI32Clz
#define WASM_I32_CTZ(x) x, kExprI32Ctz
#define WASM_I32_POPCNT(x) x, kExprI32Popcnt
#define WASM_I32_EQZ(x) x, kExprI32Eqz

//------------------------------------------------------------------------------
// Asmjs Int32 operations
//------------------------------------------------------------------------------
#define WASM_I32_ASMJS_DIVS(x, y) x, y, kExprI32AsmjsDivS
#define WASM_I32_ASMJS_REMS(x, y) x, y, kExprI32AsmjsRemS
#define WASM_I32_ASMJS_DIVU(x, y) x, y, kExprI32AsmjsDivU
#define WASM_I32_ASMJS_REMU(x, y) x, y, kExprI32AsmjsRemU

//------------------------------------------------------------------------------
// Int64 operations
//------------------------------------------------------------------------------
#define WASM_I64_ADD(x, y) x, y, kExprI64Add
#define WASM_I64_SUB(x, y) x, y, kExprI64Sub
#define WASM_I64_MUL(x, y) x, y, kExprI64Mul
#define WASM_I64_DIVS(x, y) x, y, kExprI64DivS
#define WASM_I64_DIVU(x, y) x, y, kExprI64DivU
#define WASM_I64_REMS(x, y) x, y, kExprI64RemS
#define WASM_I64_REMU(x, y) x, y, kExprI64RemU
#define WASM_I64_AND(x, y) x, y, kExprI64And
#define WASM_I64_IOR(x, y) x, y, kExprI64Ior
#define WASM_I64_XOR(x, y) x, y, kExprI64Xor
#define WASM_I64_SHL(x, y) x, y, kExprI64Shl
#define WASM_I64_SHR(x, y) x, y, kExprI64ShrU
#define WASM_I64_SAR(x, y) x, y, kExprI64ShrS
#define WASM_I64_ROR(x, y) x, y, kExprI64Ror
#define WASM_I64_ROL(x, y) x, y, kExprI64Rol
#define WASM_I64_EQ(x, y) x, y, kExprI64Eq
#define WASM_I64_NE(x, y) x, y, kExprI64Ne
#define WASM_I64_LTS(x, y) x, y, kExprI64LtS
#define WASM_I64_LES(x, y) x, y, kExprI64LeS
#define WASM_I64_LTU(x, y) x, y, kExprI64LtU
#define WASM_I64_LEU(x, y) x, y, kExprI64LeU
#define WASM_I64_GTS(x, y) x, y, kExprI64GtS
#define WASM_I64_GES(x, y) x, y, kExprI64GeS
#define WASM_I64_GTU(x, y) x, y, kExprI64GtU
#define WASM_I64_GEU(x, y) x, y, kExprI64GeU
#define WASM_I64_CLZ(x) x, kExprI64Clz
#define WASM_I64_CTZ(x) x, kExprI64Ctz
#define WASM_I64_POPCNT(x) x, kExprI64Popcnt
#define WASM_I64_EQZ(x) x, kExprI64Eqz

//------------------------------------------------------------------------------
// Float32 operations
//------------------------------------------------------------------------------
#define WASM_F32_ADD(x, y) x, y, kExprF32Add
#define WASM_F32_SUB(x, y) x, y, kExprF32Sub
#define WASM_F32_MUL(x, y) x, y, kExprF32Mul
#define WASM_F32_DIV(x, y) x, y, kExprF32Div
#define WASM_F32_MIN(x, y) x, y, kExprF32Min
#define WASM_F32_MAX(x, y) x, y, kExprF32Max
#define WASM_F32_ABS(x) x, kExprF32Abs
#define WASM_F32_NEG(x) x, kExprF32Neg
#define WASM_F32_COPYSIGN(x, y) x, y, kExprF32CopySign
#define WASM_F32_CEIL(x) x, kExprF32Ceil
#define WASM_F32_FLOOR(x) x, kExprF32Floor
#define WASM_F32_TRUNC(x) x, kExprF32Trunc
#define WASM_F32_NEARESTINT(x) x, kExprF32NearestInt
#define WASM_F32_SQRT(x) x, kExprF32Sqrt
#define WASM_F32_EQ(x, y) x, y, kExprF32Eq
#define WASM_F32_NE(x, y) x, y, kExprF32Ne
#define WASM_F32_LT(x, y) x, y, kExprF32Lt
#define WASM_F32_LE(x, y) x, y, kExprF32Le
#define WASM_F32_GT(x, y) x, y, kExprF32Gt
#define WASM_F32_GE(x, y) x, y, kExprF32Ge

//------------------------------------------------------------------------------
// Float64 operations
//------------------------------------------------------------------------------
#define WASM_F64_ADD(x, y) x, y, kExprF64Add
#define WASM_F64_SUB(x, y) x, y, kExprF64Sub
#define WASM_F64_MUL(x, y) x, y, kExprF64Mul
#define WASM_F64_DIV(x, y) x, y, kExprF64Div
#define WASM_F64_MIN(x, y) x, y, kExprF64Min
#define WASM_F64_MAX(x, y) x, y, kExprF64Max
#define WASM_F64_ABS(x) x, kExprF64Abs
#define WASM_F64_NEG(x) x, kExprF64Neg
#define WASM_F64_COPYSIGN(x, y) x, y, kExprF64CopySign
#define WASM_F64_CEIL(x) x, kExprF64Ceil
#define WASM_F64_FLOOR(x) x, kExprF64Floor
#define WASM_F64_TRUNC(x) x, kExprF64Trunc
#define WASM_F64_NEARESTINT(x) x, kExprF64NearestInt
#define WASM_F64_SQRT(x) x, kExprF64Sqrt
#define WASM_F64_EQ(x, y) x, y, kExprF64Eq
#define WASM_F64_NE(x, y) x, y, kExprF64Ne
#define WASM_F64_LT(x, y) x, y, kExprF64Lt
#define WASM_F64_LE(x, y) x, y, kExprF64Le
#define WASM_F64_GT(x, y) x, y, kExprF64Gt
#define WASM_F64_GE(x, y) x, y, kExprF64Ge

//------------------------------------------------------------------------------
// Type conversions.
//------------------------------------------------------------------------------
#define WASM_I32_SCONVERT_F32(x) x, kExprI32SConvertF32
#define WASM_I32_SCONVERT_F64(x) x, kExprI32SConvertF64
#define WASM_I32_UCONVERT_F32(x) x, kExprI32UConvertF32
#define WASM_I32_UCONVERT_F64(x) x, kExprI32UConvertF64
#define WASM_I32_CONVERT_I64(x) x, kExprI32ConvertI64
#define WASM_I64_SCONVERT_F32(x) x, kExprI64SConvertF32
#define WASM_I64_SCONVERT_F64(x) x, kExprI64SConvertF64
#define WASM_I64_UCONVERT_F32(x) x, kExprI64UConvertF32
#define WASM_I64_UCONVERT_F64(x) x, kExprI64UConvertF64
#define WASM_I64_SCONVERT_I32(x) x, kExprI64SConvertI32
#define WASM_I64_UCONVERT_I32(x) x, kExprI64UConvertI32
#define WASM_F32_SCONVERT_I32(x) x, kExprF32SConvertI32
#define WASM_F32_UCONVERT_I32(x) x, kExprF32UConvertI32
#define WASM_F32_SCONVERT_I64(x) x, kExprF32SConvertI64
#define WASM_F32_UCONVERT_I64(x) x, kExprF32UConvertI64
#define WASM_F32_CONVERT_F64(x) x, kExprF32ConvertF64
#define WASM_F32_REINTERPRET_I32(x) x, kExprF32ReinterpretI32
#define WASM_F64_SCONVERT_I32(x) x, kExprF64SConvertI32
#define WASM_F64_UCONVERT_I32(x) x, kExprF64UConvertI32
#define WASM_F64_SCONVERT_I64(x) x, kExprF64SConvertI64
#define WASM_F64_UCONVERT_I64(x) x, kExprF64UConvertI64
#define WASM_F64_CONVERT_F32(x) x, kExprF64ConvertF32
#define WASM_F64_REINTERPRET_I64(x) x, kExprF64ReinterpretI64
#define WASM_I32_REINTERPRET_F32(x) x, kExprI32ReinterpretF32
#define WASM_I64_REINTERPRET_F64(x) x, kExprI64ReinterpretF64

//------------------------------------------------------------------------------
// Numeric operations
//------------------------------------------------------------------------------
#define WASM_NUMERIC_OP(op) kNumericPrefix, static_cast<uint8_t>(op)
#define WASM_I32_SCONVERT_SAT_F32(x) x, WASM_NUMERIC_OP(kExprI32SConvertSatF32)
#define WASM_I32_UCONVERT_SAT_F32(x) x, WASM_NUMERIC_OP(kExprI32UConvertSatF32)
#define WASM_I32_SCONVERT_SAT_F64(x) x, WASM_NUMERIC_OP(kExprI32SConvertSatF64)
#define WASM_I32_UCONVERT_SAT_F64(x) x, WASM_NUMERIC_OP(kExprI32UConvertSatF64)
#define WASM_I64_SCONVERT_SAT_F32(x) x, WASM_NUMERIC_OP(kExprI64SConvertSatF32)
#define WASM_I64_UCONVERT_SAT_F32(x) x, WASM_NUMERIC_OP(kExprI64UConvertSatF32)
#define WASM_I64_SCONVERT_SAT_F64(x) x, WASM_NUMERIC_OP(kExprI64SConvertSatF64)
#define WASM_I64_UCONVERT_SAT_F64(x) x, WASM_NUMERIC_OP(kExprI64UConvertSatF64)

#define MEMORY_ZERO 0

#define WASM_MEMORY_INIT(seg, dst, src, size) \
  dst, src, size, WASM_NUMERIC_OP(kExprMemoryInit), U32V_1(seg), MEMORY_ZERO
#define WASM_DATA_DROP(seg) WASM_NUMERIC_OP(kExprDataDrop), U32V_1(seg)
#define WASM_MEMORY0_COPY(dst, src, size) \
  dst, src, size, WASM_NUMERIC_OP(kExprMemoryCopy), MEMORY_ZERO, MEMORY_ZERO
#define WASM_MEMORY_COPY(dst_index, src_index, dst, src, size) \
  dst, src, size, WASM_NUMERIC_OP(kExprMemoryCopy), dst_index, src_index
#define WASM_MEMORY_FILL(dst, val, size) \
  dst, val, size, WASM_NUMERIC_OP(kExprMemoryFill), MEMORY_ZERO
#define WASM_TABLE_INIT(table, seg, dst, src, size)             \
  dst, src, size, WASM_NUMERIC_OP(kExprTableInit), U32V_1(seg), \
      static_cast<uint8_t>(table)
#define WASM_ELEM_DROP(seg) WASM_NUMERIC_OP(kExprElemDrop), U32V_1(seg)
#define WASM_TABLE_COPY(table_dst, table_src, dst, src, size) \
  dst, src, size, WASM_NUMERIC_OP(kExprTableCopy),            \
      static_cast<uint8_t>(table_dst), static_cast<uint8_t>(table_src)
#define WASM_TABLE_GROW(table, initial_value, delta)     \
  initial_value, delta, WASM_NUMERIC_OP(kExprTableGrow), \
      static_cast<uint8_t>(table)
#define WASM_TABLE_SIZE(table) \
  WASM_NUMERIC_OP(kExprTableSize), static_cast<uint8_t>(table)
#define WASM_TABLE_FILL(table, times, value, start)     \
  times, value, start, WASM_NUMERIC_OP(kExprTableFill), \
      static_cast<uint8_t>(table)

//------------------------------------------------------------------------------
// Memory Operations.
//------------------------------------------------------------------------------
#define WASM_MEMORY_GROW(x) x, kExprMemoryGrow, 0
#define WASM_MEMORY_SIZE kExprMemorySize, 0

#define SIG_ENTRY_v_v kWasmFunctionTypeCode, 0, 0
#define SIZEOF_SIG_ENTRY_v_v 3

#define SIG_ENTRY_v_x(a) kWasmFunctionTypeCode, 1, a, 0
#define SIG_ENTRY_v_xx(a, b) kWasmFunctionTypeCode, 2, a, b, 0
#define SIG_ENTRY_v_xxx(a, b, c) kWasmFunctionTypeCode, 3, a, b, c, 0
#define SIZEOF_SIG_ENTRY_v_x 4
#define SIZEOF_SIG_ENTRY_v_xx 5
#define SIZEOF_SIG_ENTRY_v_xxx 6

#define SIG_ENTRY_x(r) kWasmFunctionTypeCode, 0, 1, r
#define SIG_ENTRY_x_x(r, a) kWasmFunctionTypeCode, 1, a, 1, r
#define SIG_ENTRY_x_xx(r, a, b) kWasmFunctionTypeCode, 2, a, b, 1, r
#define SIG_ENTRY_xx_xx(r, s, a, b) kWasmFunctionTypeCode, 2, a, b, 2, r, s
#define SIG_ENTRY_x_xxx(r, a, b, c) kWasmFunctionTypeCode, 3, a, b, c, 1, r
#define SIZEOF_SIG_ENTRY_x 4
#define SIZEOF_SIG_ENTRY_x_x 5
#define SIZEOF_SIG_ENTRY_x_xx 6
#define SIZEOF_SIG_ENTRY_xx_xx 7
#define SIZEOF_SIG_ENTRY_x_xxx 7

#define WASM_BRV(depth, ...) __VA_ARGS__, kExprBr, static_cast<uint8_t>(depth)
#define WASM_BRV_IF(depth, val, cond) \
  val, cond, kExprBrIf, static_cast<uint8_t>(depth)
#define WASM_BRV_IFD(depth, val, cond) \
  val, cond, kExprBrIf, static_cast<uint8_t>(depth), kExprDrop

//------------------------------------------------------------------------------
// Atomic Operations.
//------------------------------------------------------------------------------
#define WASM_ATOMICS_OP(op) kAtomicPrefix, static_cast<uint8_t>(op)
#define WASM_ATOMICS_BINOP(op, x, y, representation) \
  x, y, WASM_ATOMICS_OP(op),                         \
      static_cast<uint8_t>(ElementSizeLog2Of(representation)), ZERO_OFFSET
#define WASM_ATOMICS_TERNARY_OP(op, x, y, z, representation) \
  x, y, z, WASM_ATOMICS_OP(op),                              \
      static_cast<uint8_t>(ElementSizeLog2Of(representation)), ZERO_OFFSET
#define WASM_ATOMICS_LOAD_OP(op, x, representation) \
  x, WASM_ATOMICS_OP(op),                           \
      static_cast<uint8_t>(ElementSizeLog2Of(representation)), ZERO_OFFSET
#define WASM_ATOMICS_STORE_OP(op, x, y, representation) \
  x, y, WASM_ATOMICS_OP(op),                            \
      static_cast<uint8_t>(ElementSizeLog2Of(representation)), ZERO_OFFSET
#define WASM_ATOMICS_WAIT(op, index, value, timeout, alignment, offset) \
  index, value, timeout, WASM_ATOMICS_OP(op), alignment, offset
#define WASM_ATOMICS_FENCE WASM_ATOMICS_OP(kExprAtomicFence), ZERO_OFFSET

//------------------------------------------------------------------------------
// Sign Extension Operations.
//------------------------------------------------------------------------------
#define WASM_I32_SIGN_EXT_I8(x) x, kExprI32SExtendI8
#define WASM_I32_SIGN_EXT_I16(x) x, kExprI32SExtendI16
#define WASM_I64_SIGN_EXT_I8(x) x, kExprI64SExtendI8
#define WASM_I64_SIGN_EXT_I16(x) x, kExprI64SExtendI16
#define WASM_I64_SIGN_EXT_I32(x) x, kExprI64SExtendI32

//------------------------------------------------------------------------------
// SIMD Operations.
//------------------------------------------------------------------------------
#define TO_BYTE(val) static_cast<uint8_t>(val)
// Encode all simd ops as a 2-byte LEB.
#define WASM_SIMD_OP(op) kSimdPrefix, U32V_2(ExtractPrefixedOpcodeBytes(op))
#define WASM_SIMD_OPN(op, ...) __VA_ARGS__, WASM_SIMD_OP(op)
#define WASM_SIMD_SPLAT(Type, ...) __VA_ARGS__, WASM_SIMD_OP(kExpr##Type##Splat)
#define WASM_SIMD_UNOP(op, x) x, WASM_SIMD_OP(op)
#define WASM_SIMD_BINOP(op, x, y) x, y, WASM_SIMD_OP(op)
#define WASM_SIMD_TERNOP(op, x, y, z) x, y, z, WASM_SIMD_OP(op)
#define WASM_SIMD_SHIFT_OP(op, x, y) x, y, WASM_SIMD_OP(op)
#define WASM_SIMD_CONCAT_OP(op, bytes, x, y) \
  x, y, WASM_SIMD_OP(op), TO_BYTE(bytes)
#define WASM_SIMD_SELECT(format, x, y, z) x, y, z, WASM_SIMD_OP(kExprS128Select)
#define WASM_SIMD_CONSTANT(v)                                                \
  WASM_SIMD_OP(kExprS128Const), TO_BYTE(v[0]), TO_BYTE(v[1]), TO_BYTE(v[2]), \
      TO_BYTE(v[3]), TO_BYTE(v[4]), TO_BYTE(v[5]), TO_BYTE(v[6]),            \
      TO_BYTE(v[7]), TO_BYTE(v[8]), TO_BYTE(v[9]), TO_BYTE(v[10]),           \
      TO_BYTE(v[11]), TO_BYTE(v[12]), TO_BYTE(v[13]), TO_BYTE(v[14]),        \
      TO_BYTE(v[15])

#define WASM_SIMD_F64x2_SPLAT(x) WASM_SIMD_SPLAT(F64x2, x)
#define WASM_SIMD_F64x2_EXTRACT_LANE(lane, x) \
  x, WASM_SIMD_OP(kExprF64x2ExtractLane), TO_BYTE(lane)
#define WASM_SIMD_F64x2_REPLACE_LANE(lane, x, y) \
  x, y, WASM_SIMD_OP(kExprF64x2ReplaceLane), TO_BYTE(lane)

#define WASM_SIMD_F32x4_SPLAT(x) WASM_SIMD_SPLAT(F32x4, x)
#define WASM_SIMD_F32x4_EXTRACT_LANE(lane, x) \
  x, WASM_SIMD_OP(kExprF32x4ExtractLane), TO_BYTE(lane)
#define WASM_SIMD_F32x4_REPLACE_LANE(lane, x, y) \
  x, y, WASM_SIMD_OP(kExprF32x4ReplaceLane), TO_BYTE(lane)

#define WASM_SIMD_F16x8_SPLAT(x) WASM_SIMD_SPLAT(F16x8, x)
#define WASM_SIMD_F16x8_EXTRACT_LANE(lane, x) \
  x, WASM_SIMD_OP(kExprF16x8ExtractLane), TO_BYTE(lane)
#define WASM_SIMD_F16x8_REPLACE_LANE(lane, x, y) \
  x, y, WASM_SIMD_OP(kExprF16x8ReplaceLane), TO_BYTE(lane)

#define WASM_SIMD_I64x2_SPLAT(x) WASM_SIMD_SPLAT(I64x2, x)
#define WASM_SIMD_I64x2_EXTRACT_LANE(lane, x) \
  x, WASM_SIMD_OP(kExprI64x2ExtractLane), TO_BYTE(lane)
#define WASM_SIMD_I64x2_REPLACE_LANE(lane, x, y) \
  x, y, WASM_SIMD_OP(kExprI64x2ReplaceLane), TO_BYTE(lane)

#define WASM_SIMD_I32x4_SPLAT(x) WASM_SIMD_SPLAT(I32x4, x)
#define WASM_SIMD_I32x4_EXTRACT_LANE(lane, x) \
  x, WASM_SIMD_OP(kExprI32x4ExtractLane), TO_BYTE(lane)
#define WASM_SIMD_I32x4_REPLACE_LANE(lane, x, y) \
  x, y, WASM_SIMD_OP(kExprI32x4ReplaceLane), TO_BYTE(lane)

#define WASM_SIMD_I16x8_SPLAT(x) WASM_SIMD_SPLAT(I16x8, x)
#define WASM_SIMD_I16x8_EXTRACT_LANE(lane, x) \
  x, WASM_SIMD_OP(kExprI16x8ExtractLaneS), TO_BYTE(lane)
#define WASM_SIMD_I16x8_EXTRACT_LANE_U(lane, x) \
  x, WASM_SIMD_OP(kExprI16x8ExtractLaneU), TO_BYTE(lane)
#define WASM_SIMD_I16x8_REPLACE_LANE(lane, x, y) \
  x, y, WASM_SIMD_OP(kExprI16x8ReplaceLane), TO_BYTE(lane)

#define WASM_SIMD_I8x16_SPLAT(x) WASM_SIMD_SPLAT(I8x16, x)
#define WASM_SIMD_I8x16_EXTRACT_LANE(lane, x) \
  x, WASM_SIMD_OP(kExprI8x16ExtractLaneS), TO_BYTE(lane)
#define WASM_SIMD_I8x16_EXTRACT_LANE_U(lane, x) \
  x, WASM_SIMD_OP(kExprI8x16ExtractLaneU), TO_BYTE(lane)
#define WASM_SIMD_I8x16_REPLACE_LANE(lane, x, y) \
  x, y, WASM_SIMD_OP(kExprI8x16ReplaceLane), TO_BYTE(lane)

#define WASM_SIMD_I8x16_SHUFFLE_OP(opcode, m, x, y)                        \
  x, y, WASM_SIMD_OP(opcode), TO_BYTE(m[0]), TO_BYTE(m[1]), TO_BYTE(m[2]), \
      TO_BYTE(m[3]), TO_BYTE(m[4]), TO_BYTE(m[5]), TO_BYTE(m[6]),          \
      TO_BYTE(m[7]), TO_BYTE(m[8]), TO_BYTE(m[9]), TO_BYTE(m[10]),         \
      TO_BYTE(m[11]), TO_BYTE(m[12]), TO_BYTE(m[13]), TO_BYTE(m[14]),      \
      TO_BYTE(m[15])

#define WASM_SIMD_LOAD_MEM(index) \
  index, WASM_SIMD_OP(kExprS128LoadMem), ZERO_ALIGNMENT, ZERO_OFFSET
#define WASM_SIMD_LOAD_MEM_OFFSET(offset, index) \
  index, WASM_SIMD_OP(kExprS128LoadMem), ZERO_ALIGNMENT, offset
#define WASM_SIMD_STORE_MEM(index, val) \
  index, val, WASM_SIMD_OP(kExprS128StoreMem), ZERO_ALIGNMENT, ZERO_OFFSET
#define WASM_SIMD_STORE_MEM_OFFSET(offset, index, val) \
  index, val, WASM_SIMD_OP(kExprS128StoreMem), ZERO_ALIGNMENT, offset

#define WASM_SIMD_F64x2_QFMA(a, b, c) a, b, c, WASM_SIMD_OP(kExprF64x2Qfma)
#define WASM_SIMD_F64x2_QFMS(a, b, c) a, b, c, WASM_SIMD_OP(kExprF64x2Qfms)
#define WASM_SIMD_F32x4_QFMA(a, b, c) a, b, c, WASM_SIMD_OP(kExprF32x4Qfma)
#define WASM_SIMD_F32x4_QFMS(a, b, c) a, b, c, WASM_SIMD_OP(kExprF32x4Qfms)
#define WASM_SIMD_F16x8_QFMA(a, b, c) a, b, c, WASM_SIMD_OP(kExprF16x8Qfma)
#define WASM_SIMD_F16x8_QFMS(a, b, c) a, b, c, WASM_SIMD_OP(kExprF16x8Qfms)

// Like WASM_SIMD_LOAD_MEM but needs the load opcode.
#define WASM_SIMD_LOAD_OP(opcode, index) \
  index, WASM_SIMD_OP(opcode), ZERO_ALIGNMENT, ZERO_OFFSET
#define WASM_SIMD_LOAD_OP_OFFSET(opcode, index, offset) \
  index, WASM_SIMD_OP(opcode), ZERO_ALIGNMENT, offset
#define WASM_SIMD_LOAD_OP_ALIGNMENT(opcode, index, alignment) \
  index, WASM_SIMD_OP(opcode), alignment, ZERO_OFFSET

// Load a Simd lane from a numeric pointer. We need this because lanes are
// reversed in big endian. Note: a Simd value has {kSimd128Size / sizeof(*ptr)}
// lanes.
#ifdef V8_TARGET_BIG_ENDIAN
#define LANE(ptr, index) ptr[kSimd128Size / sizeof(*ptr) - (index)-1]
#else
#define LANE(ptr, index) ptr[index]
#endif

//------------------------------------------------------------------------------
// Compilation Hints.
//------------------------------------------------------------------------------
#define COMPILE_STRATEGY_DEFAULT (0x00)
#define COMPILE_STRATEGY_LAZY (0x01)
#define COMPILE_STRATEGY_EAGER (0x02)
#define BASELINE_TIER_DEFAULT (0x00 << 2)
#define BASELINE_TIER_BASELINE (0x01 << 2)
#define BASELINE_TIER_OPTIMIZED (0x02 << 2)
#define TOP_TIER_DEFAULT (0x00 << 4)
#define TOP_TIER_BASELINE (0x01 << 4)
#define TOP_TIER_OPTIMIZED (0x02 << 4)

#endif  // V8_WASM_MACRO_GEN_H_
```
Response:
Let's break down the thought process for analyzing the given C++ code.

**1. Initial Scan and Understanding the Purpose:**

The first thing I notice is the `#include` directives and the `namespace v8::internal::wasm`. This immediately tells me it's related to the WebAssembly implementation within the V8 JavaScript engine. The class name `WasmMacroGenTest` and the `TEST_F` macros strongly suggest this is a unit test file. The name `wasm-macro-gen` hints at testing a macro generation mechanism for WebAssembly bytecode.

**2. Analyzing the Core Structure:**

I see a series of `TEST_F` macros. Each one has a descriptive name like `Constants`, `Statements`, `Expressions`, etc. This suggests the file is organized to test different categories of WebAssembly instructions or constructs.

The `#define EXPECT_SIZE` macro is crucial. It takes a size and a variable number of arguments (represented by `__VA_ARGS__`). It creates a `code` array, does `USE(code)` (which likely silences a compiler warning about unused variables), and then asserts that the `sizeof(code)` matches the given `size`. This tells me the tests are verifying the byte size of generated WebAssembly instructions.

**3. Deconstructing the Tests:**

I start going through each `TEST_F` and look at the `EXPECT_SIZE` calls. For example, in `WasmMacroGenTest, Constants`:

* `EXPECT_SIZE(2, WASM_ONE);` means the macro `WASM_ONE` should generate 2 bytes of WebAssembly code.
* `EXPECT_SIZE(2, WASM_I32V_1(-22));` means `WASM_I32V_1(-22)` should also generate 2 bytes. The `I32V_1` suggests it's related to encoding an i32 value. The different suffixes (`_1`, `_2`, etc.) likely indicate different variable-length encodings for integers.

I do this for each test category, making a mental note of the types of macros being tested: constants, basic statements (nop, end, local/global set), control flow (if, else, block, loop, br, br_if), macro statements (while, increment), table branches, expressions (loads, gets, unary/binary ops), function calls, and various arithmetic/conversion operations for different data types (i32, i64, f32, f64).

**4. Connecting to WebAssembly Concepts:**

As I analyze the macros, I relate them to my understanding of WebAssembly. For instance:

* `WASM_LOCAL_GET(0)` and `WASM_LOCAL_SET(0, ...)` are clearly about accessing local variables.
* `WASM_GLOBAL_GET(0)` and `WASM_GLOBAL_SET(0, ...)` are about global variables.
* `WASM_I32_ADD(..., ...)` and similar macros for other types represent standard arithmetic operations.
* `WASM_IF(...)`, `WASM_LOOP(...)`, `WASM_BR(...)` are fundamental control flow structures in WebAssembly.
* `WASM_CALL_FUNCTION(...)` and `WASM_CALL_INDIRECT(...)` are for invoking functions.

**5. Addressing Specific Questions:**

* **Functionality:** Based on the test names and the macros being tested, the primary function is to verify the correct byte size of various WebAssembly instructions generated by the "wasm-macro-gen" system.

* **Torque:** The code is C++, not Torque. The prompt's condition about `.tq` extension is a conditional check.

* **JavaScript Relationship:**  WebAssembly is executed within JavaScript environments (like web browsers and Node.js). The macros being tested here directly correspond to WebAssembly bytecode that a JavaScript engine would interpret and execute. I can provide JavaScript examples of equivalent functionality.

* **Code Logic and Assumptions:** The core logic is the `EXPECT_SIZE` macro. The assumption is that the `wasm-macro-gen` correctly produces WebAssembly bytecode of a specific size for each macro. I can create hypothetical inputs and outputs based on this assumption.

* **Common Programming Errors:** This is a bit trickier as it's a testing file. However, I can think about common errors *related to* WebAssembly and how these macros might help avoid them, or what errors developers might make when *manually* writing WebAssembly (which these macros aim to simplify). For example, incorrect encoding of integer literals or using the wrong instruction for a particular operation.

**6. Structuring the Answer:**

Finally, I organize the information into a clear and structured answer, addressing each point in the prompt. I provide explanations, JavaScript examples, hypothetical inputs/outputs, and common error scenarios. I make sure to clearly differentiate between what the test file *does* and how it relates to broader WebAssembly concepts and potential user errors.

This systematic approach of scanning, analyzing structure, deconstructing tests, connecting to core concepts, and then specifically addressing the prompt's questions allows for a comprehensive understanding and explanation of the given code.
这个 C++ 代码文件 `v8/test/unittests/wasm/wasm-macro-gen-unittest.cc` 是 V8 JavaScript 引擎中用于测试 WebAssembly 宏生成器功能的单元测试。

**功能列举:**

1. **测试 WebAssembly 指令宏的正确性:**  这个文件主要测试 `test/common/wasm/wasm-macro-gen.h` 中定义的 WebAssembly 指令宏是否能生成正确大小的 WebAssembly 字节码。

2. **验证不同 WebAssembly 指令的编码长度:** 通过 `EXPECT_SIZE` 宏，它断言了各种 WebAssembly 指令（如常量、语句、表达式、运算符等）在编码后的字节长度是否符合预期。

3. **覆盖多种 WebAssembly 指令类型:** 测试涵盖了 WebAssembly 的各种指令，包括：
   - **常量 (Constants):**  例如 `WASM_ONE`, `WASM_ZERO`,  不同大小的整数和浮点数常量 (`WASM_I32V_n`, `WASM_I64V_n`, `WASM_F32`, `WASM_F64`)。
   - **语句 (Statements):** 例如 `WASM_NOP`, `WASM_END`,  局部/全局变量的设置 (`WASM_LOCAL_SET`, `WASM_GLOBAL_SET`), 内存操作 (`WASM_STORE_MEM`), 控制流 (`WASM_IF`, `WASM_IF_ELSE`, `WASM_BLOCK`, `WASM_LOOP`, `WASM_BR`, `WASM_BR_IF`), 返回 (`WASM_RETURN`, `WASM_RETURN0`), 以及 `WASM_UNREACHABLE`。
   - **宏语句 (Macro Statements):**  例如 `WASM_WHILE`, `WASM_INC_LOCAL`, `WASM_CONTINUE`。
   - **分支表 (BrTable):** 例如 `WASM_BR_TABLE`。
   - **表达式 (Expressions):** 例如局部/全局变量的获取 (`WASM_LOCAL_GET`, `WASM_GLOBAL_GET`), 内存加载 (`WASM_LOAD_MEM`), 一元运算 (`WASM_NOT`), 带返回值的控制流 (`WASM_BRV`, `WASM_BRV_IF`)。
   - **函数调用 (CallFunction):**  直接调用 (`WASM_CALL_FUNCTION0`, `WASM_CALL_FUNCTION`) 和间接调用 (`WASM_CALL_INDIRECT`).
   - **整数运算 (Int32Ops, Int64Ops):**  各种算术、位运算和比较操作，例如 `WASM_I32_ADD`, `WASM_I64_SHL`, `WASM_I32_EQ`, 等等。
   - **浮点数运算 (Float32Ops, Float64Ops):**  各种算术、比较和数学函数，例如 `WASM_F32_ADD`, `WASM_F64_SQRT`, `WASM_F32_LT`, 等等。
   - **类型转换 (Conversions):**  不同类型之间的转换，例如 `WASM_I32_SCONVERT_F32`, `WASM_F64_CONVERT_F32`。
   - **加载和存储 (LoadsAndStores):**  针对不同内存类型的加载和存储操作，包括带偏移量的版本。

**关于 .tq 结尾：**

如果 `v8/test/unittests/wasm/wasm-macro-gen-unittest.cc` 以 `.tq` 结尾，那么它的确是一个 V8 Torque 源代码文件。Torque 是 V8 使用的一种领域特定语言，用于生成高效的运行时代码。然而，根据你提供的文件内容，它以 `.cc` 结尾，因此是 C++ 文件。

**与 JavaScript 的功能关系及示例：**

这个 C++ 文件测试的是 V8 引擎内部 WebAssembly 宏生成器的功能。这些宏最终会生成 WebAssembly 的字节码，而这些字节码可以在 JavaScript 环境中执行。

例如，`EXPECT_SIZE(5, WASM_I32_ADD(WASM_ZERO, WASM_ZERO));` 测试了 `WASM_I32_ADD` 宏（用于生成 i32 相加的指令）的字节码长度。  在 JavaScript 中，当你执行一段 WebAssembly 代码时，V8 引擎会解析并执行类似这样的加法操作。

以下是一个 JavaScript 示例，展示了如何在 JavaScript 中使用 WebAssembly 进行整数加法：

```javascript
async function runWasmAdd() {
  const wasmCode = new Uint8Array([
    0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, // Magic number and version
    0x01, 0x07, 0x01, 0x60, 0x02, 0x7f, 0x7f, 0x01, 0x7f, // Function signature: (i32, i32) -> i32
    0x03, 0x02, 0x01, 0x00, // Import section (none)
    0x0a, 0x09, 0x01, 0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x6a, 0x0b, // Code section: local.get 0, local.get 1, i32.add, end
    0x07, 0x08, 0x01, 0x06, 0x61, 0x64, 0x64, 0x65, 0x72, 0x00, 0x00 // Export section: export function "adder"
  ]);
  const wasmModule = await WebAssembly.compile(wasmCode);
  const wasmInstance = await WebAssembly.instantiate(wasmModule);
  const result = wasmInstance.exports.adder(5, 10);
  console.log(result); // 输出 15
}

runWasmAdd();
```

在这个 JavaScript 例子中，`0x6a` 就是 `i32.add` 指令的 WebAssembly 字节码。 `WASM_I32_ADD` 宏的目的就是生成这个 `0x6a` 以及操作数。

**代码逻辑推理（假设输入与输出）：**

`EXPECT_SIZE` 宏的逻辑非常简单：它接收一个期望的大小和一个或多个表示 WebAssembly 指令宏的参数。它将这些宏展开成实际的字节码，然后检查生成的字节码的 `sizeof` 是否等于期望的大小。

**假设输入与输出示例：**

假设我们有以下测试：

```c++
TEST_F(WasmMacroGenTest, SimpleAdd) {
  EXPECT_SIZE(5, WASM_I32_ADD(WASM_I32V_1(5), WASM_I32V_1(10)));
}
```

**假设输入:**
- `WASM_I32_ADD` 宏
- `WASM_I32V_1(5)` 宏，假设生成字节码 `0x05` (简化表示，实际可能更复杂)
- `WASM_I32V_1(10)` 宏，假设生成字节码 `0x0a` (简化表示)

**代码逻辑:**
1. `WASM_I32_ADD(WASM_I32V_1(5), WASM_I32V_1(10))`  会被展开成类似 `0x6a, 0x05, 0x0a` (假设 `0x6a` 是 `i32.add` 的操作码)。
2. `uint8_t code[] = { 0x6a, 0x05, 0x0a };`
3. `sizeof(code)` 的结果是 3。
4. `EXPECT_EQ(static_cast<size_t>(5), sizeof(code));`  这将会 **失败**，因为期望大小是 5，而实际大小是 3。

**修正后的假设输入与输出 (更贴近实际 WASM 编码):**

实际上，`WASM_ZERO` 宏很可能代表编码为 `0x41` 的常量 0。 `WASM_I32_ADD(WASM_ZERO, WASM_ZERO)` 可能会展开成 `0x6a, 0x41, 0x41`，其大小为 3。  而 `EXPECT_SIZE(5, WASM_I32_ADD(WASM_ZERO, WASM_ZERO));` 测试的是操作码本身的大小，通常操作码是单字节的。

更准确地说，`WASM_ZERO` 这样的常量宏会直接生成表示常量的字节码，例如 `0x41` 表示 i32 常量 0。`WASM_I32_ADD` 是一个操作码。

例如，对于 `EXPECT_SIZE(5, WASM_I32_ADD(WASM_ZERO, WASM_ZERO));`：

- `WASM_ZERO` 展开可能得到 `0x41`
- `WASM_I32_ADD` 操作码是 `0x6a`

但是，`WASM_I32_ADD(WASM_ZERO, WASM_ZERO)` 实际上是先将两个 `WASM_ZERO` (都生成 `0x41`) 压入栈，然后执行 `i32.add` (操作码 `0x6a`)。所以其结构可能是 `get_local 0; get_local 1; i32.add;` 这样的模式，但这与代码中的宏的使用方式不同。

代码中的宏是直接生成指令及其操作数。  对于 `WASM_I32_ADD(WASM_ZERO, WASM_ZERO)`，更可能的展开方式是：`i32.add` 操作码 (1 字节) + 第一个操作数 (假设 `WASM_ZERO` 编码为 1 字节) + 第二个操作数 (假设 `WASM_ZERO` 编码为 1 字节)。但这与 `EXPECT_SIZE(5, ...)` 不符。

仔细看代码，`WASM_ZERO` 本身可能不是一个完整的指令，而是一个表示常量 0 的宏，它可能被 `WASM_I32_ADD` 宏内部使用。 `WASM_I32_ADD(WASM_ZERO, WASM_ZERO)`  很可能生成 `i32.add` 操作码，然后紧跟着两个表示 0 的编码。

**用户常见的编程错误示例：**

虽然这个文件是测试代码，但它可以帮助揭示用户在编写 WebAssembly 代码时可能犯的错误：

1. **错误的指令操作码:**  用户可能会使用错误的字节码来表示某个操作。例如，误用了 `i32.sub` 的操作码代替了 `i32.add`。

   ```javascript
   // 错误的 WebAssembly 代码，本意是加法
   const wrongWasmCode = new Uint8Array([ /* ... i32.sub 操作码 ... */ ]);
   ```

2. **操作数类型不匹配:**  WebAssembly 是强类型语言。如果指令期望接收 `i32` 类型的操作数，但用户提供了 `f32` 类型，就会出错。

   ```c++
   // 假设 WASM_F32_ADD 只能操作 f32
   // 错误地将 i32 类型的 WASM_ZERO 传递给它
   // EXPECT_SIZE(..., WASM_F32_ADD(WASM_ZERO, WASM_ZERO));
   ```

3. **错误的指令顺序或控制流:**  在复杂的 WebAssembly 函数中，指令的顺序至关重要。错误的跳转目标、`if`/`else` 结构不匹配等都会导致错误。

4. **内存访问越界:**  当使用 `WASM_LOAD_MEM` 或 `WASM_STORE_MEM` 时，如果提供的内存地址超出了分配的内存范围，会导致运行时错误。

   ```c++
   // 假设内存大小有限
   // 访问超出范围的内存地址
   // EXPECT_SIZE(..., WASM_STORE_MEM(MachineType::Int32(), WASM_I32V_1(large_address), ...));
   ```

5. **函数签名不匹配:**  在使用 `WASM_CALL_FUNCTION` 或 `WASM_CALL_INDIRECT` 时，如果调用方提供的参数类型或数量与被调用函数的签名不符，会导致类型错误或运行时崩溃。

总而言之，`v8/test/unittests/wasm/wasm-macro-gen-unittest.cc` 通过测试 WebAssembly 宏生成器的输出，确保 V8 引擎能够正确地生成和编码 WebAssembly 指令，这对于保证 WebAssembly 代码在 V8 中的正确执行至关重要。

Prompt: 
```
这是目录为v8/test/unittests/wasm/wasm-macro-gen-unittest.cc的一个v8源代码， 请列举一下它的功能, 
如果v8/test/unittests/wasm/wasm-macro-gen-unittest.cc以.tq结尾，那它是个v8 torque源代码，
如果它与javascript的功能有关系，请用javascript举例说明,
如果有代码逻辑推理，请给出假设输入与输出，
如果涉及用户常见的编程错误，请举例说明

"""
// Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "test/unittests/test-utils.h"

#include "test/common/wasm/wasm-macro-gen.h"

namespace v8 {
namespace internal {
namespace wasm {

class WasmMacroGenTest : public TestWithZone {};

#define EXPECT_SIZE(size, ...)                          \
  do {                                                  \
    uint8_t code[] = {__VA_ARGS__};                     \
    USE(code);                                          \
    EXPECT_EQ(static_cast<size_t>(size), sizeof(code)); \
  } while (false)

TEST_F(WasmMacroGenTest, Constants) {
  EXPECT_SIZE(2, WASM_ONE);
  EXPECT_SIZE(2, WASM_ZERO);

  EXPECT_SIZE(2, WASM_I32V_1(-22));
  EXPECT_SIZE(2, WASM_I32V_1(54));

  EXPECT_SIZE(2, WASM_I32V_1(1));
  EXPECT_SIZE(3, WASM_I32V_2(200));
  EXPECT_SIZE(4, WASM_I32V_3(10000));
  EXPECT_SIZE(5, WASM_I32V_4(-9828934));
  EXPECT_SIZE(6, WASM_I32V_5(-1119828934));

  EXPECT_SIZE(2, WASM_I64V_1(1));
  EXPECT_SIZE(3, WASM_I64V_2(300));
  EXPECT_SIZE(4, WASM_I64V_3(10000));
  EXPECT_SIZE(5, WASM_I64V_4(-9828934));
  EXPECT_SIZE(6, WASM_I64V_5(-1119828934));
  EXPECT_SIZE(10, WASM_I64V_9(0x123456789ABCDEF0ULL));

  EXPECT_SIZE(5, WASM_F32(1.0f));
  EXPECT_SIZE(5, WASM_F32(10000.0f));
  EXPECT_SIZE(5, WASM_F32(-9828934.0f));

  EXPECT_SIZE(9, WASM_F64(1.5));
  EXPECT_SIZE(9, WASM_F64(10200.0));
  EXPECT_SIZE(9, WASM_F64(-9818934.0));
}

TEST_F(WasmMacroGenTest, Statements) {
  EXPECT_SIZE(1, WASM_NOP);
  EXPECT_SIZE(1, WASM_END);

  EXPECT_SIZE(4, WASM_LOCAL_SET(0, WASM_ZERO));

  EXPECT_SIZE(4, WASM_GLOBAL_SET(0, WASM_ZERO));

  EXPECT_SIZE(7, WASM_STORE_MEM(MachineType::Int32(), WASM_ZERO, WASM_ZERO));

  EXPECT_SIZE(6, WASM_IF(WASM_ZERO, WASM_NOP));

  EXPECT_SIZE(8, WASM_IF_ELSE(WASM_ZERO, WASM_NOP, WASM_NOP));

  EXPECT_SIZE(5, WASM_SELECT(WASM_ZERO, WASM_NOP, WASM_NOP));

  EXPECT_SIZE(2, WASM_BR(0));
  EXPECT_SIZE(4, WASM_BR_IF(0, WASM_ZERO));

  EXPECT_SIZE(4, WASM_BLOCK(WASM_NOP));
  EXPECT_SIZE(5, WASM_BLOCK(WASM_NOP, WASM_NOP));
  EXPECT_SIZE(6, WASM_BLOCK(WASM_NOP, WASM_NOP, WASM_NOP));

  EXPECT_SIZE(5, WASM_INFINITE_LOOP);

  EXPECT_SIZE(4, WASM_LOOP(WASM_NOP));
  EXPECT_SIZE(5, WASM_LOOP(WASM_NOP, WASM_NOP));
  EXPECT_SIZE(6, WASM_LOOP(WASM_NOP, WASM_NOP, WASM_NOP));
  EXPECT_SIZE(5, WASM_LOOP(WASM_BR(0)));
  EXPECT_SIZE(7, WASM_LOOP(WASM_BR_IF(0, WASM_ZERO)));

  EXPECT_SIZE(1, WASM_RETURN0);
  EXPECT_SIZE(3, WASM_RETURN(WASM_ZERO));

  EXPECT_SIZE(1, WASM_UNREACHABLE);
}

TEST_F(WasmMacroGenTest, MacroStatements) {
  EXPECT_SIZE(11, WASM_WHILE(WASM_ZERO, WASM_NOP));
  EXPECT_SIZE(7, WASM_INC_LOCAL(0));
  EXPECT_SIZE(7, WASM_INC_LOCAL_BY(0, 3));

  EXPECT_SIZE(2, WASM_CONTINUE(0));
}

TEST_F(WasmMacroGenTest, BrTable) {
  EXPECT_SIZE(5, WASM_BR_TABLE(WASM_ZERO, 1, BR_TARGET(0)));
  EXPECT_SIZE(6, WASM_BR_TABLE(WASM_ZERO, 2, BR_TARGET(0), BR_TARGET(0)));
}

TEST_F(WasmMacroGenTest, Expressions) {
  EXPECT_SIZE(2, WASM_LOCAL_GET(0));
  EXPECT_SIZE(2, WASM_LOCAL_GET(1));
  EXPECT_SIZE(2, WASM_LOCAL_GET(12));
  EXPECT_SIZE(2, WASM_GLOBAL_GET(0));
  EXPECT_SIZE(2, WASM_GLOBAL_GET(1));
  EXPECT_SIZE(2, WASM_GLOBAL_GET(12));
  EXPECT_SIZE(5, WASM_LOAD_MEM(MachineType::Int32(), WASM_ZERO));
  EXPECT_SIZE(5, WASM_LOAD_MEM(MachineType::Float64(), WASM_ZERO));
  EXPECT_SIZE(5, WASM_LOAD_MEM(MachineType::Float32(), WASM_ZERO));

  EXPECT_SIZE(3, WASM_NOT(WASM_ZERO));

  EXPECT_SIZE(4, WASM_BRV(1, WASM_ZERO));
  EXPECT_SIZE(6, WASM_BRV_IF(1, WASM_ZERO, WASM_ZERO));

  EXPECT_SIZE(5, WASM_BLOCK(WASM_ZERO));
  EXPECT_SIZE(6, WASM_BLOCK(WASM_NOP, WASM_ZERO));
  EXPECT_SIZE(7, WASM_BLOCK(WASM_NOP, WASM_NOP, WASM_ZERO));

  EXPECT_SIZE(5, WASM_LOOP(WASM_ZERO));
  EXPECT_SIZE(6, WASM_LOOP(WASM_NOP, WASM_ZERO));
  EXPECT_SIZE(7, WASM_LOOP(WASM_NOP, WASM_NOP, WASM_ZERO));
}

TEST_F(WasmMacroGenTest, CallFunction) {
  EXPECT_SIZE(2, WASM_CALL_FUNCTION0(0));
  EXPECT_SIZE(2, WASM_CALL_FUNCTION0(1));
  EXPECT_SIZE(2, WASM_CALL_FUNCTION0(11));

  EXPECT_SIZE(4, WASM_CALL_FUNCTION(0, WASM_ZERO));
  EXPECT_SIZE(6, WASM_CALL_FUNCTION(1, WASM_ZERO, WASM_ZERO));
}

TEST_F(WasmMacroGenTest, CallIndirect) {
  EXPECT_SIZE(5, WASM_CALL_INDIRECT(0, WASM_ZERO));
  EXPECT_SIZE(5, WASM_CALL_INDIRECT(1, WASM_ZERO));
  EXPECT_SIZE(5, WASM_CALL_INDIRECT(11, WASM_ZERO));

  EXPECT_SIZE(7, WASM_CALL_INDIRECT(0, WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(9, WASM_CALL_INDIRECT(1, WASM_ZERO, WASM_ZERO, WASM_ZERO));
}

TEST_F(WasmMacroGenTest, Int32Ops) {
  EXPECT_SIZE(5, WASM_I32_ADD(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_SUB(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_MUL(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_DIVS(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_DIVU(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_REMS(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_REMU(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_AND(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_IOR(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_XOR(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_SHL(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_SHR(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_SAR(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_ROR(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_ROL(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_EQ(WASM_ZERO, WASM_ZERO));

  EXPECT_SIZE(5, WASM_I32_LTS(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_LES(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_LTU(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_LEU(WASM_ZERO, WASM_ZERO));

  EXPECT_SIZE(5, WASM_I32_GTS(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_GES(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_GTU(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_GEU(WASM_ZERO, WASM_ZERO));

  EXPECT_SIZE(3, WASM_I32_CLZ(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I32_CTZ(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I32_POPCNT(WASM_ZERO));

  EXPECT_SIZE(3, WASM_I32_EQZ(WASM_ZERO));
}

TEST_F(WasmMacroGenTest, Int64Ops) {
  EXPECT_SIZE(5, WASM_I64_ADD(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_SUB(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_MUL(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_DIVS(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_DIVU(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_REMS(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_REMU(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_AND(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_IOR(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_XOR(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_SHL(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_SHR(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_SAR(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_ROR(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_ROL(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_EQ(WASM_ZERO, WASM_ZERO));

  EXPECT_SIZE(5, WASM_I64_LTS(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_LES(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_LTU(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_LEU(WASM_ZERO, WASM_ZERO));

  EXPECT_SIZE(5, WASM_I64_GTS(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_GES(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_GTU(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_GEU(WASM_ZERO, WASM_ZERO));

  EXPECT_SIZE(3, WASM_I64_CLZ(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I64_CTZ(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I64_POPCNT(WASM_ZERO));

  EXPECT_SIZE(3, WASM_I64_EQZ(WASM_ZERO));
}

TEST_F(WasmMacroGenTest, Float32Ops) {
  EXPECT_SIZE(5, WASM_F32_ADD(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F32_SUB(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F32_MUL(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F32_DIV(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F32_MIN(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F32_MAX(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F32_COPYSIGN(WASM_ZERO, WASM_ZERO));

  EXPECT_SIZE(3, WASM_F32_ABS(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F32_NEG(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F32_CEIL(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F32_FLOOR(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F32_TRUNC(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F32_NEARESTINT(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F32_SQRT(WASM_ZERO));

  EXPECT_SIZE(5, WASM_F32_EQ(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F32_LT(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F32_LE(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F32_GT(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F32_GE(WASM_ZERO, WASM_ZERO));
}

TEST_F(WasmMacroGenTest, Float64Ops) {
  EXPECT_SIZE(5, WASM_F64_ADD(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F64_SUB(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F64_MUL(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F64_DIV(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F64_MIN(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F64_MAX(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F64_COPYSIGN(WASM_ZERO, WASM_ZERO));

  EXPECT_SIZE(3, WASM_F64_ABS(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F64_NEG(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F64_CEIL(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F64_FLOOR(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F64_TRUNC(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F64_NEARESTINT(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F64_SQRT(WASM_ZERO));

  EXPECT_SIZE(5, WASM_F64_EQ(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F64_LT(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F64_LE(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F64_GT(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F64_GE(WASM_ZERO, WASM_ZERO));
}

TEST_F(WasmMacroGenTest, Conversions) {
  EXPECT_SIZE(3, WASM_I32_SCONVERT_F32(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I32_SCONVERT_F64(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I32_UCONVERT_F32(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I32_UCONVERT_F64(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I32_CONVERT_I64(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I64_SCONVERT_F32(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I64_SCONVERT_F64(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I64_UCONVERT_F32(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I64_UCONVERT_F64(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I64_SCONVERT_I32(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I64_UCONVERT_I32(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F32_SCONVERT_I32(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F32_UCONVERT_I32(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F32_SCONVERT_I64(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F32_UCONVERT_I64(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F32_CONVERT_F64(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F32_REINTERPRET_I32(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F64_SCONVERT_I32(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F64_UCONVERT_I32(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F64_SCONVERT_I64(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F64_UCONVERT_I64(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F64_CONVERT_F32(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F64_REINTERPRET_I64(WASM_ZERO));
}

static const MachineType kMemTypes[] = {
    MachineType::Int8(),   MachineType::Uint8(),  MachineType::Int16(),
    MachineType::Uint16(), MachineType::Int32(),  MachineType::Uint32(),
    MachineType::Int64(),  MachineType::Uint64(), MachineType::Float32(),
    MachineType::Float64()};

TEST_F(WasmMacroGenTest, LoadsAndStores) {
  for (size_t i = 0; i < arraysize(kMemTypes); i++) {
    EXPECT_SIZE(5, WASM_LOAD_MEM(kMemTypes[i], WASM_ZERO));
  }
  for (size_t i = 0; i < arraysize(kMemTypes); i++) {
    EXPECT_SIZE(7, WASM_STORE_MEM(kMemTypes[i], WASM_ZERO, WASM_LOCAL_GET(0)));
  }
}

TEST_F(WasmMacroGenTest, LoadsAndStoresWithOffset) {
  for (size_t i = 0; i < arraysize(kMemTypes); i++) {
    EXPECT_SIZE(5, WASM_LOAD_MEM_OFFSET(kMemTypes[i], 11, WASM_ZERO));
  }
  for (size_t i = 0; i < arraysize(kMemTypes); i++) {
    EXPECT_SIZE(7, WASM_STORE_MEM_OFFSET(kMemTypes[i], 13, WASM_ZERO,
                                         WASM_LOCAL_GET(0)));
  }
}

#undef EXPECT_SIZE

}  // namespace wasm
}  // namespace internal
}  // namespace v8

"""

```
Response: Let's break down the thought process to analyze this C++ file and summarize its functionality.

1. **Understand the Goal:** The request asks for a summary of the C++ source code's functionality. This means identifying what the code *does*, not just what it *is*.

2. **Initial Scan for Keywords and Structure:**  Quickly read through the code, looking for recognizable patterns and keywords. I see:
    * `// Copyright`: Standard header information, likely not core to the functionality.
    * `#include`:  Includes `test-utils.h` and `wasm-macro-gen.h`. This is a strong clue that the file is testing something related to `wasm-macro-gen.h`.
    * `namespace v8::internal::wasm`:  Indicates this code is part of the V8 JavaScript engine, specifically the WebAssembly implementation.
    * `class WasmMacroGenTest : public TestWithZone`:  Confirms this is a unit test. The `TestWithZone` base class is a common pattern in V8 testing.
    * `#define EXPECT_SIZE(...)`:  A macro. This macro is used extensively in the `TEST_F` blocks. It takes a size and a list of other things.
    * `TEST_F(WasmMacroGenTest, ...)`:  These are the actual test cases. The first argument is the test fixture class, and the second is the test name.

3. **Focus on the Core Logic: The `EXPECT_SIZE` Macro:**  The repeated use of `EXPECT_SIZE` suggests it's central to the test's purpose. Let's analyze it:
    * `uint8_t code[] = {__VA_ARGS__};`: Creates a byte array named `code` initialized with the comma-separated arguments passed to the macro.
    * `USE(code);`:  This is likely a macro or function (from `test-utils.h`) that prevents compiler warnings about an unused variable. It's not functionally important to understanding *what* is being tested.
    * `EXPECT_EQ(static_cast<size_t>(size), sizeof(code));`:  This is the key part. It asserts that the provided `size` argument is equal to the `sizeof(code)`, which is the size of the byte array created.

4. **Connecting the Dots:  Testing the Macros in `wasm-macro-gen.h`:**  The `EXPECT_SIZE` macro takes a size and then what looks like WebAssembly instructions (e.g., `WASM_ONE`, `WASM_I32V_1(-22)`, `WASM_NOP`). The fact that it's checking the `sizeof(code)` where `code` is initialized with these "WASM_" things strongly suggests that these are macros defined in `wasm-macro-gen.h` that generate WebAssembly bytecode. The tests are verifying the *size* of the bytecode generated by these macros.

5. **Analyzing Individual Test Cases:** Now, examine the `TEST_F` blocks:
    * `Constants`: Tests macros that generate constant values (integers, floats).
    * `Statements`: Tests macros that generate WebAssembly statements (like `nop`, `end`, control flow).
    * `MacroStatements`: Tests higher-level macros that might expand into multiple basic statements.
    * `BrTable`: Tests the `WASM_BR_TABLE` macro.
    * `Expressions`: Tests macros that generate WebAssembly expressions (values).
    * `CallFunction`, `CallIndirect`: Tests macros for function calls.
    * `Int32Ops`, `Int64Ops`, `Float32Ops`, `Float64Ops`: Tests macros for various arithmetic and logical operations on different data types.
    * `Conversions`: Tests macros for converting between data types.
    * `LoadsAndStores`, `LoadsAndStoresWithOffset`: Tests macros for memory access.

6. **Synthesizing the Summary:** Based on the analysis, the file's main function is to test the `wasm-macro-gen.h` header. Specifically, it verifies that the macros defined in that header generate the correct *size* of WebAssembly bytecode for various constants, statements, expressions, and operations.

7. **Refining the Language:**  Use clear and concise language. Avoid jargon where possible, or explain it briefly. Mention the core components like the `EXPECT_SIZE` macro and the purpose of checking bytecode size.

8. **Considering Edge Cases and Details (Self-Correction):**
    * Initially, I might just say "it tests WASM macros."  But that's too vague. The key is it tests the *size* of the generated bytecode.
    * The `USE(code)` line isn't directly relevant to the *functionality being tested*, so while it's in the code, it's not a core part of the summary.
    * The specific WebAssembly opcodes aren't the focus; the *macros that generate them* are.

By following these steps, we arrive at the detailed and accurate summary provided in the initial good answer. The process involves understanding the code's structure, focusing on the core logic (the `EXPECT_SIZE` macro), and connecting it to the included header file (`wasm-macro-gen.h`).

这个C++源代码文件 `wasm-macro-gen-unittest.cc` 的主要功能是**测试 `wasm-macro-gen.h` 头文件中定义的 WebAssembly 指令宏的正确性**。

具体来说，它通过一系列单元测试用例来验证以下几点：

1. **生成的 WebAssembly 指令的字节大小是否正确:**  测试用例使用 `EXPECT_SIZE` 宏来断言由各种 `WASM_...` 宏生成的字节序列的长度是否与预期一致。 这涵盖了各种 WebAssembly 操作码、常量、语句和表达式。

2. **测试了各种 WebAssembly 构造:**  测试用例覆盖了 WebAssembly 的多种语法结构，包括：
    * **常量:**  例如 `WASM_ONE`, `WASM_ZERO`, `WASM_I32V_n`, `WASM_F32`, `WASM_F64` 等，测试了不同类型的常量表示。
    * **语句:**  例如 `WASM_NOP`, `WASM_END`, `WASM_LOCAL_SET`, `WASM_GLOBAL_SET`, `WASM_IF`, `WASM_LOOP`, `WASM_RETURN` 等，测试了控制流和变量操作。
    * **宏语句:**  例如 `WASM_WHILE`, `WASM_INC_LOCAL`, `WASM_CONTINUE` 等，测试了更高级的宏提供的便利功能。
    * **分支表:**  测试了 `WASM_BR_TABLE` 宏。
    * **表达式:**  例如 `WASM_LOCAL_GET`, `WASM_GLOBAL_GET`, `WASM_LOAD_MEM`, `WASM_I32_ADD`, `WASM_F64_DIV` 等，测试了各种操作和数据获取。
    * **函数调用:**  例如 `WASM_CALL_FUNCTION0`, `WASM_CALL_FUNCTION`, `WASM_CALL_INDIRECT` 等，测试了直接和间接函数调用。
    * **各种数据类型的操作:** 测试了 `i32`, `i64`, `f32`, `f64` 类型的算术、逻辑、比较和转换操作。
    * **内存加载和存储:**  测试了不同数据类型的内存加载和存储操作，包括带偏移量的版本。

**总结来说，`wasm-macro-gen-unittest.cc` 文件是一个全面的单元测试套件，旨在确保 `wasm-macro-gen.h` 中定义的宏能够正确地生成 WebAssembly 字节码，并且生成的字节码长度符合预期。 这对于确保 V8 引擎在生成 WebAssembly 代码时的正确性至关重要。**

该文件通过使用 `EXPECT_SIZE` 宏来简化测试编写，该宏可以方便地验证生成的字节数组的大小。 每个测试用例都针对特定的 WebAssembly 构造或操作码，从而提供细粒度的测试覆盖。

### 提示词
```这是目录为v8/test/unittests/wasm/wasm-macro-gen-unittest.cc的一个c++源代码文件， 请归纳一下它的功能
```

### 源代码
```
// Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "test/unittests/test-utils.h"

#include "test/common/wasm/wasm-macro-gen.h"

namespace v8 {
namespace internal {
namespace wasm {

class WasmMacroGenTest : public TestWithZone {};

#define EXPECT_SIZE(size, ...)                          \
  do {                                                  \
    uint8_t code[] = {__VA_ARGS__};                     \
    USE(code);                                          \
    EXPECT_EQ(static_cast<size_t>(size), sizeof(code)); \
  } while (false)

TEST_F(WasmMacroGenTest, Constants) {
  EXPECT_SIZE(2, WASM_ONE);
  EXPECT_SIZE(2, WASM_ZERO);

  EXPECT_SIZE(2, WASM_I32V_1(-22));
  EXPECT_SIZE(2, WASM_I32V_1(54));

  EXPECT_SIZE(2, WASM_I32V_1(1));
  EXPECT_SIZE(3, WASM_I32V_2(200));
  EXPECT_SIZE(4, WASM_I32V_3(10000));
  EXPECT_SIZE(5, WASM_I32V_4(-9828934));
  EXPECT_SIZE(6, WASM_I32V_5(-1119828934));

  EXPECT_SIZE(2, WASM_I64V_1(1));
  EXPECT_SIZE(3, WASM_I64V_2(300));
  EXPECT_SIZE(4, WASM_I64V_3(10000));
  EXPECT_SIZE(5, WASM_I64V_4(-9828934));
  EXPECT_SIZE(6, WASM_I64V_5(-1119828934));
  EXPECT_SIZE(10, WASM_I64V_9(0x123456789ABCDEF0ULL));

  EXPECT_SIZE(5, WASM_F32(1.0f));
  EXPECT_SIZE(5, WASM_F32(10000.0f));
  EXPECT_SIZE(5, WASM_F32(-9828934.0f));

  EXPECT_SIZE(9, WASM_F64(1.5));
  EXPECT_SIZE(9, WASM_F64(10200.0));
  EXPECT_SIZE(9, WASM_F64(-9818934.0));
}

TEST_F(WasmMacroGenTest, Statements) {
  EXPECT_SIZE(1, WASM_NOP);
  EXPECT_SIZE(1, WASM_END);

  EXPECT_SIZE(4, WASM_LOCAL_SET(0, WASM_ZERO));

  EXPECT_SIZE(4, WASM_GLOBAL_SET(0, WASM_ZERO));

  EXPECT_SIZE(7, WASM_STORE_MEM(MachineType::Int32(), WASM_ZERO, WASM_ZERO));

  EXPECT_SIZE(6, WASM_IF(WASM_ZERO, WASM_NOP));

  EXPECT_SIZE(8, WASM_IF_ELSE(WASM_ZERO, WASM_NOP, WASM_NOP));

  EXPECT_SIZE(5, WASM_SELECT(WASM_ZERO, WASM_NOP, WASM_NOP));

  EXPECT_SIZE(2, WASM_BR(0));
  EXPECT_SIZE(4, WASM_BR_IF(0, WASM_ZERO));

  EXPECT_SIZE(4, WASM_BLOCK(WASM_NOP));
  EXPECT_SIZE(5, WASM_BLOCK(WASM_NOP, WASM_NOP));
  EXPECT_SIZE(6, WASM_BLOCK(WASM_NOP, WASM_NOP, WASM_NOP));

  EXPECT_SIZE(5, WASM_INFINITE_LOOP);

  EXPECT_SIZE(4, WASM_LOOP(WASM_NOP));
  EXPECT_SIZE(5, WASM_LOOP(WASM_NOP, WASM_NOP));
  EXPECT_SIZE(6, WASM_LOOP(WASM_NOP, WASM_NOP, WASM_NOP));
  EXPECT_SIZE(5, WASM_LOOP(WASM_BR(0)));
  EXPECT_SIZE(7, WASM_LOOP(WASM_BR_IF(0, WASM_ZERO)));

  EXPECT_SIZE(1, WASM_RETURN0);
  EXPECT_SIZE(3, WASM_RETURN(WASM_ZERO));

  EXPECT_SIZE(1, WASM_UNREACHABLE);
}

TEST_F(WasmMacroGenTest, MacroStatements) {
  EXPECT_SIZE(11, WASM_WHILE(WASM_ZERO, WASM_NOP));
  EXPECT_SIZE(7, WASM_INC_LOCAL(0));
  EXPECT_SIZE(7, WASM_INC_LOCAL_BY(0, 3));

  EXPECT_SIZE(2, WASM_CONTINUE(0));
}

TEST_F(WasmMacroGenTest, BrTable) {
  EXPECT_SIZE(5, WASM_BR_TABLE(WASM_ZERO, 1, BR_TARGET(0)));
  EXPECT_SIZE(6, WASM_BR_TABLE(WASM_ZERO, 2, BR_TARGET(0), BR_TARGET(0)));
}

TEST_F(WasmMacroGenTest, Expressions) {
  EXPECT_SIZE(2, WASM_LOCAL_GET(0));
  EXPECT_SIZE(2, WASM_LOCAL_GET(1));
  EXPECT_SIZE(2, WASM_LOCAL_GET(12));
  EXPECT_SIZE(2, WASM_GLOBAL_GET(0));
  EXPECT_SIZE(2, WASM_GLOBAL_GET(1));
  EXPECT_SIZE(2, WASM_GLOBAL_GET(12));
  EXPECT_SIZE(5, WASM_LOAD_MEM(MachineType::Int32(), WASM_ZERO));
  EXPECT_SIZE(5, WASM_LOAD_MEM(MachineType::Float64(), WASM_ZERO));
  EXPECT_SIZE(5, WASM_LOAD_MEM(MachineType::Float32(), WASM_ZERO));

  EXPECT_SIZE(3, WASM_NOT(WASM_ZERO));

  EXPECT_SIZE(4, WASM_BRV(1, WASM_ZERO));
  EXPECT_SIZE(6, WASM_BRV_IF(1, WASM_ZERO, WASM_ZERO));

  EXPECT_SIZE(5, WASM_BLOCK(WASM_ZERO));
  EXPECT_SIZE(6, WASM_BLOCK(WASM_NOP, WASM_ZERO));
  EXPECT_SIZE(7, WASM_BLOCK(WASM_NOP, WASM_NOP, WASM_ZERO));

  EXPECT_SIZE(5, WASM_LOOP(WASM_ZERO));
  EXPECT_SIZE(6, WASM_LOOP(WASM_NOP, WASM_ZERO));
  EXPECT_SIZE(7, WASM_LOOP(WASM_NOP, WASM_NOP, WASM_ZERO));
}

TEST_F(WasmMacroGenTest, CallFunction) {
  EXPECT_SIZE(2, WASM_CALL_FUNCTION0(0));
  EXPECT_SIZE(2, WASM_CALL_FUNCTION0(1));
  EXPECT_SIZE(2, WASM_CALL_FUNCTION0(11));

  EXPECT_SIZE(4, WASM_CALL_FUNCTION(0, WASM_ZERO));
  EXPECT_SIZE(6, WASM_CALL_FUNCTION(1, WASM_ZERO, WASM_ZERO));
}

TEST_F(WasmMacroGenTest, CallIndirect) {
  EXPECT_SIZE(5, WASM_CALL_INDIRECT(0, WASM_ZERO));
  EXPECT_SIZE(5, WASM_CALL_INDIRECT(1, WASM_ZERO));
  EXPECT_SIZE(5, WASM_CALL_INDIRECT(11, WASM_ZERO));

  EXPECT_SIZE(7, WASM_CALL_INDIRECT(0, WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(9, WASM_CALL_INDIRECT(1, WASM_ZERO, WASM_ZERO, WASM_ZERO));
}

TEST_F(WasmMacroGenTest, Int32Ops) {
  EXPECT_SIZE(5, WASM_I32_ADD(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_SUB(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_MUL(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_DIVS(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_DIVU(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_REMS(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_REMU(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_AND(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_IOR(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_XOR(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_SHL(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_SHR(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_SAR(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_ROR(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_ROL(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_EQ(WASM_ZERO, WASM_ZERO));

  EXPECT_SIZE(5, WASM_I32_LTS(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_LES(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_LTU(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_LEU(WASM_ZERO, WASM_ZERO));

  EXPECT_SIZE(5, WASM_I32_GTS(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_GES(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_GTU(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_GEU(WASM_ZERO, WASM_ZERO));

  EXPECT_SIZE(3, WASM_I32_CLZ(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I32_CTZ(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I32_POPCNT(WASM_ZERO));

  EXPECT_SIZE(3, WASM_I32_EQZ(WASM_ZERO));
}

TEST_F(WasmMacroGenTest, Int64Ops) {
  EXPECT_SIZE(5, WASM_I64_ADD(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_SUB(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_MUL(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_DIVS(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_DIVU(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_REMS(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_REMU(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_AND(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_IOR(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_XOR(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_SHL(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_SHR(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_SAR(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_ROR(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_ROL(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_EQ(WASM_ZERO, WASM_ZERO));

  EXPECT_SIZE(5, WASM_I64_LTS(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_LES(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_LTU(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_LEU(WASM_ZERO, WASM_ZERO));

  EXPECT_SIZE(5, WASM_I64_GTS(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_GES(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_GTU(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_GEU(WASM_ZERO, WASM_ZERO));

  EXPECT_SIZE(3, WASM_I64_CLZ(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I64_CTZ(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I64_POPCNT(WASM_ZERO));

  EXPECT_SIZE(3, WASM_I64_EQZ(WASM_ZERO));
}

TEST_F(WasmMacroGenTest, Float32Ops) {
  EXPECT_SIZE(5, WASM_F32_ADD(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F32_SUB(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F32_MUL(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F32_DIV(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F32_MIN(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F32_MAX(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F32_COPYSIGN(WASM_ZERO, WASM_ZERO));

  EXPECT_SIZE(3, WASM_F32_ABS(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F32_NEG(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F32_CEIL(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F32_FLOOR(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F32_TRUNC(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F32_NEARESTINT(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F32_SQRT(WASM_ZERO));

  EXPECT_SIZE(5, WASM_F32_EQ(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F32_LT(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F32_LE(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F32_GT(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F32_GE(WASM_ZERO, WASM_ZERO));
}

TEST_F(WasmMacroGenTest, Float64Ops) {
  EXPECT_SIZE(5, WASM_F64_ADD(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F64_SUB(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F64_MUL(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F64_DIV(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F64_MIN(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F64_MAX(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F64_COPYSIGN(WASM_ZERO, WASM_ZERO));

  EXPECT_SIZE(3, WASM_F64_ABS(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F64_NEG(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F64_CEIL(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F64_FLOOR(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F64_TRUNC(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F64_NEARESTINT(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F64_SQRT(WASM_ZERO));

  EXPECT_SIZE(5, WASM_F64_EQ(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F64_LT(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F64_LE(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F64_GT(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F64_GE(WASM_ZERO, WASM_ZERO));
}

TEST_F(WasmMacroGenTest, Conversions) {
  EXPECT_SIZE(3, WASM_I32_SCONVERT_F32(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I32_SCONVERT_F64(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I32_UCONVERT_F32(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I32_UCONVERT_F64(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I32_CONVERT_I64(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I64_SCONVERT_F32(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I64_SCONVERT_F64(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I64_UCONVERT_F32(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I64_UCONVERT_F64(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I64_SCONVERT_I32(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I64_UCONVERT_I32(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F32_SCONVERT_I32(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F32_UCONVERT_I32(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F32_SCONVERT_I64(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F32_UCONVERT_I64(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F32_CONVERT_F64(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F32_REINTERPRET_I32(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F64_SCONVERT_I32(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F64_UCONVERT_I32(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F64_SCONVERT_I64(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F64_UCONVERT_I64(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F64_CONVERT_F32(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F64_REINTERPRET_I64(WASM_ZERO));
}

static const MachineType kMemTypes[] = {
    MachineType::Int8(),   MachineType::Uint8(),  MachineType::Int16(),
    MachineType::Uint16(), MachineType::Int32(),  MachineType::Uint32(),
    MachineType::Int64(),  MachineType::Uint64(), MachineType::Float32(),
    MachineType::Float64()};

TEST_F(WasmMacroGenTest, LoadsAndStores) {
  for (size_t i = 0; i < arraysize(kMemTypes); i++) {
    EXPECT_SIZE(5, WASM_LOAD_MEM(kMemTypes[i], WASM_ZERO));
  }
  for (size_t i = 0; i < arraysize(kMemTypes); i++) {
    EXPECT_SIZE(7, WASM_STORE_MEM(kMemTypes[i], WASM_ZERO, WASM_LOCAL_GET(0)));
  }
}

TEST_F(WasmMacroGenTest, LoadsAndStoresWithOffset) {
  for (size_t i = 0; i < arraysize(kMemTypes); i++) {
    EXPECT_SIZE(5, WASM_LOAD_MEM_OFFSET(kMemTypes[i], 11, WASM_ZERO));
  }
  for (size_t i = 0; i < arraysize(kMemTypes); i++) {
    EXPECT_SIZE(7, WASM_STORE_MEM_OFFSET(kMemTypes[i], 13, WASM_ZERO,
                                         WASM_LOCAL_GET(0)));
  }
}

#undef EXPECT_SIZE

}  // namespace wasm
}  // namespace internal
}  // namespace v8
```
Response:
Let's break down the thought process for analyzing this V8 test file.

**1. Initial Understanding and Context:**

* **File Path:** `v8/test/unittests/regexp/regexp-unittest.cc` immediately tells us this is a C++ unit test file specifically for the regular expression functionality within the V8 JavaScript engine. The `.cc` extension confirms it's C++ code.
* **Purpose:** Unit tests are designed to verify small, isolated units of code. In this case, it's testing various aspects of the regular expression implementation.
* **V8 Context:**  Knowing it's V8 code means we're dealing with internal V8 APIs and data structures, not standard JavaScript APIs directly, although they test the underlying implementation of JavaScript regex.

**2. Scanning for Key Structures and Patterns:**

* **`TEST_F(RegExpTest...)` and `TEST_F(RegExpTestWithContext...)`:** These are the primary building blocks. They define individual test cases. `RegExpTest` and `RegExpTestWithContext` are likely test fixture classes providing setup and teardown. The "WithContext" version likely sets up a V8 context to run JavaScript.
* **`RunJS(...)`:** This function appears frequently. It's highly probable it executes JavaScript code within the test environment. This is crucial for testing the interaction between V8's regex engine and JavaScript.
* **`CHECK_EQ(...)`, `CHECK(...)`, `CHECK_LT(...)`:** These are assertion macros. They verify expected outcomes of the code being tested. They are the core of any unit test.
* **`RegExpBytecodeGenerator`:** This class suggests testing the internal bytecode generation process for regular expressions.
* **`CreatePeephole...Bytecode(...)`:**  The "peephole" keyword strongly suggests testing peephole optimizations, a technique for optimizing bytecode.
* **`UncachedExternalStringResource`:** This class hints at testing how the regex engine handles strings that are not directly managed by V8's internal string caching.
* **Specific method names:**  Looking for names like `test`, `match`, `exec`, `toString` provides clues about which JavaScript regex methods are being tested.

**3. Analyzing Individual Test Cases (Examples):**

* **`RegExpPrototypeToString`:** The name clearly indicates testing the `toString()` method of the `RegExp` prototype. The `RunJS` calls that check for exceptions when calling `toString` on `null` confirm this. The `use_counts` check points to internal V8 metrics related to accessing the prototype and the `toString` method.

* **`UncachedExternalString`:** The name and the `UncachedExternalStringResource` class point to testing how regex behaves with external strings. The JavaScript code using `substring` and `match` confirms it's testing string operations with a regex.

* **`PeepholeNoChange`:** The name and the `CreatePeepholeNoChangeBytecode` function suggest testing a scenario where peephole optimization *shouldn't* change the generated bytecode. The comparison of the original and optimized byte arrays using `memcmp` confirms this.

* **`PeepholeSkipUntilChar`:** The name and the bytecode generation function indicate testing a peephole optimization where a sequence of instructions is replaced by a `SKIP_UNTIL_CHAR` instruction. The checks on the expected bytecode lengths and the first byte of the optimized array confirm this.

* **`RegExpInterruptReentrantExecution`:** This test's name and the use of `RequestInterrupt` suggest testing how the regex engine handles interruptions during execution, potentially related to stack overflow or similar scenarios. The `ReenterRegExp` function and the `Exec_Single` call point to an internal execution mechanism.

**4. Identifying Functional Areas:**

By examining the test case names and the code within them, we can group the functionalities being tested:

* **Basic RegExp Functionality:**  Testing core methods like `test`, `exec`, and the behavior of simple regex patterns.
* **`toString()` Method:** Specifically testing the `toString()` method of `RegExp`.
* **External Strings:** Testing how regex interacts with strings not directly managed by V8.
* **Bytecode Generation:** Testing the process of generating bytecode for regular expressions.
* **Peephole Optimizations:**  A significant focus on verifying various peephole optimizations.
* **Unicode Property Escapes:** Testing the handling of Unicode property escapes in regex.
* **Reentrancy and Interrupts:** Testing how the regex engine handles reentrant calls and interruptions.

**5. Connecting to JavaScript (where applicable):**

For tests involving `RunJS`, it's straightforward to illustrate the JavaScript functionality being tested. For example, the `RegExpPrototypeToString` test directly relates to the JavaScript:

```javascript
RegExp.prototype.toString.call(/abc/); // Output: "/abc/"
RegExp.prototype.toString.call(/abc/gim); // Output: "/abc/gim"
RegExp.prototype.toString.call(null); // Throws a TypeError
```

**6. Inferring Logic and Assumptions:**

For the peephole optimization tests, the code defines specific sequences of bytecode instructions and then checks if the optimizer correctly transforms them. The assumption is that specific sequences can be optimized into more efficient single instructions. The tests provide the "input bytecode" and verify the "output bytecode" after optimization.

**7. Identifying Potential User Errors:**

The `RegExpPrototypeToString` test explicitly demonstrates a common user error: calling `RegExp.prototype.toString` on a non-RegExp object that isn't the prototype itself. This leads to a `TypeError` in JavaScript.

**8. Final Summarization:**

Combine the identified functionalities into a concise summary, highlighting the key areas of the regex engine being tested. Emphasize that this is low-level testing of V8's internal implementation.

This systematic approach of scanning, analyzing, grouping, and connecting to JavaScript allows for a comprehensive understanding of the test file's purpose and the functionalities it covers.
这是对v8源代码文件 `v8/test/unittests/regexp/regexp-unittest.cc` 的功能总结，基于你提供的代码片段：

**核心功能： 正则表达式功能的单元测试**

`v8/test/unittests/regexp/regexp-unittest.cc` 文件包含了大量针对 V8 JavaScript 引擎中正则表达式功能的单元测试。这些测试旨在验证正则表达式引擎在各种场景下的正确性和性能。

**具体功能点归纳：**

1. **`RegExp.prototype.toString()` 的测试:**
   - 验证 `RegExp.prototype.toString()` 方法在不同正则表达式对象上的行为，包括带有不同标志的正则表达式。
   - 测试当 `RegExp.prototype.toString()` 被非正则表达式对象调用时的异常情况 (例如 `null`)。
   - 检查内部计数器，用于追踪对 `RegExp.prototype` getter 和 `toString` 方法的调用次数，用于性能分析或内部行为验证。

   **JavaScript 示例:**
   ```javascript
   const regex1 = /abc/;
   console.log(regex1.toString()); // 输出: "/abc/"

   const regex2 = /abc/gim;
   console.log(regex2.toString()); // 输出: "/abc/gim"

   try {
     RegExp.prototype.toString.call(null);
   } catch (e) {
     console.error(e); // 输出 TypeError
   }
   ```

2. **处理未缓存的外部字符串的测试:**
   - 创建一个未被 V8 字符串缓存管理的外部字符串资源 (`UncachedExternalStringResource`)。
   - 验证正则表达式引擎能否正确地处理这种类型的字符串。
   - 测试对外部字符串执行正则表达式匹配和捕获组操作。

   **假设输入与输出:**
   - **假设输入:**  一个外部字符串 "abcdefghijklmnopqrstuvwxyz"，正则表达式 `/y(.)/`。
   - **预期输出:**  `external.substring(1).match(re)[1]` 应该返回字符串 "z"。

3. **正则表达式字节码窥孔优化测试 (Peephole Optimization):**
   - 这部分测试专注于 V8 正则表达式引擎的字节码优化过程，特别是“窥孔优化”。
   - 它定义了不同的字节码序列 (`CreatePeephole...Bytecode`)，模拟在未优化和优化情况下生成的字节码。
   - 通过比较优化前后字节码的长度和内容，验证特定的优化是否按预期进行。
   - 测试了多种窥孔优化场景，包括：
     - **`PeepholeNoChange`**:  验证在某些情况下不应该进行优化。
     - **`PeepholeSkipUntilChar`**:  将一系列加载字符和检查字符的操作优化为 `SKIP_UNTIL_CHAR` 指令。
     - **`PeepholeSkipUntilBitInTable`**: 针对字符集的优化。
     - **`PeepholeSkipUntilCharPosChecked`**:  带有位置检查的字符跳过优化。
     - **`PeepholeSkipUntilCharAnd`**:  涉及位运算的字符跳过优化。
     - **`PeepholeSkipUntilCharOrChar`**:  涉及多个字符或关系的字符跳过优化。
     - **`PeepholeSkipUntilGtOrNotBitInTable`**:  更复杂的条件跳过优化。
     - **`PeepholeLabelFixupsInside` 和 `PeepholeLabelFixupsComplex`**:  测试优化过程中对字节码标签 (Label) 的正确调整。

   **代码逻辑推理示例 (PeepholeSkipUntilChar):**
   - **假设输入 (未优化字节码):**  加载当前字符，检查是否为 'x'，前进到下一个位置，跳转到开始。
   - **预期输出 (优化后字节码):**  `SKIP_UNTIL_CHAR 'x'` 指令。
   - **推理:** 当正则表达式需要循环跳过字符直到遇到特定字符时，窥孔优化可以将多个独立的指令合并为一个更高效的指令。

4. **Unicode 属性转义代码大小测试:**
   - 验证当使用 Unicode 属性转义符（例如 `\p{L}` 表示任何字母字符）时，生成的正则表达式代码大小是否在合理范围内，防止因过度内联导致代码过大。

   **JavaScript 示例:**
   ```javascript
   const regex = /\p{L}\p{L}\p{L}/u;
   regex.exec('\u200b'); // \u200b 是一个零宽度空格，不匹配
   ```

5. **正则表达式重入执行和中断测试:**
   - 测试在正则表达式执行过程中发生中断并尝试重新进入正则表达式引擎时的行为。
   - 这通常与处理栈溢出或递归调用等复杂场景有关。

   **涉及用户常见的编程错误 (与重入执行相关):**
   - **无限递归的正则表达式:**  编写一个会导致正则表达式引擎无限递归的模式，可能导致栈溢出。
     ```javascript
     // 这是一个可能导致问题的模式，具体行为取决于引擎的实现和输入
     const regex = /^(a*)*$/;
     const str = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa";
     regex.test(str); // 可能导致栈溢出
     ```

**总结：**

`v8/test/unittests/regexp/regexp-unittest.cc` 文件是 V8 引擎中一个至关重要的测试文件，它深入测试了正则表达式功能的各个方面，从基本的匹配和 `toString` 方法，到复杂的字节码优化和对特殊类型字符串的处理，以及对异常情况的处理。 这些测试确保了 V8 的正则表达式引擎的正确性、性能和健壮性。

由于这是第三部分，并且没有提供前两部分的内容，所以这个总结主要基于你提供的代码片段。 如果提供了前两部分，可以进行更全面的功能归纳。

Prompt: 
```
这是目录为v8/test/unittests/regexp/regexp-unittest.cc的一个v8源代码， 请列举一下它的功能, 
如果v8/test/unittests/regexp/regexp-unittest.cc以.tq结尾，那它是个v8 torque源代码，
如果它与javascript的功能有关系，请用javascript举例说明,
如果有代码逻辑推理，请给出假设输入与输出，
如果涉及用户常见的编程错误，请举例说明
这是第3部分，共3部分，请归纳一下它的功能

"""
oString->Int32Value(isolate()->GetCurrentContext()).FromJust());

  // .toString() throws on non-RegExps that aren't RegExp.prototype
  v8::Local<v8::Value> resultToStringError = RunJS(
      "var exception;"
      "try { RegExp.prototype.toString.call(null) }"
      "catch (e) { exception = e; }"
      "exception");
  CHECK_EQ(2, use_counts[v8::Isolate::kRegExpPrototypeStickyGetter]);
  CHECK_EQ(1, use_counts[v8::Isolate::kRegExpPrototypeToString]);
  CHECK(resultToStringError->IsObject());
}

class UncachedExternalStringResource
    : public v8::String::ExternalOneByteStringResource {
 public:
  const char* data() const override { return "abcdefghijklmnopqrstuvwxyz"; }
  size_t length() const override { return 26; }
  bool IsCacheable() const override { return false; }
};

TEST_F(RegExpTestWithContext, UncachedExternalString) {
  v8::HandleScope scope(isolate());
  v8::Local<v8::String> external =
      v8::String::NewExternalOneByte(isolate(),
                                     new UncachedExternalStringResource())
          .ToLocalChecked();
  CHECK_EQ(v8::Utils::OpenDirectHandle(*external)->map(),
           ReadOnlyRoots(i_isolate()).uncached_external_one_byte_string_map());
  v8::Local<v8::Object> global = context()->Global();
  global->Set(context(), NewString("external"), external).FromJust();
  RunJS("var re = /y(.)/; re.test('ab');");
  // TODO(v8:12781): once IsString matcher is added in
  // gmock-support.h, we could replace this.
  Local<Value> result = RunJS("external.substring(1).match(re)[1]");
  CHECK(result->IsString());
  v8::String::Utf8Value utf8(isolate(), result);
  CHECK_EQ(0, strcmp("z", *utf8));
}

// Test bytecode peephole optimization

void CreatePeepholeNoChangeBytecode(RegExpMacroAssembler* m) {
  Label fail, backtrack;
  m->PushBacktrack(&fail);
  m->CheckNotAtStart(0, nullptr);
  m->LoadCurrentCharacter(2, nullptr);
  m->CheckNotCharacter('o', nullptr);
  m->LoadCurrentCharacter(1, nullptr, false);
  m->CheckNotCharacter('o', nullptr);
  m->LoadCurrentCharacter(0, nullptr, false);
  m->CheckNotCharacter('f', nullptr);
  m->WriteCurrentPositionToRegister(0, 0);
  m->WriteCurrentPositionToRegister(1, 3);
  m->AdvanceCurrentPosition(3);
  m->PushBacktrack(&backtrack);
  m->Succeed();
  m->Bind(&backtrack);
  m->Backtrack();
  m->Bind(&fail);
  m->Fail();
}

TEST_F(RegExpTest, PeepholeNoChange) {
  Zone zone(i_isolate()->allocator(), ZONE_NAME);
  Factory* factory = i_isolate()->factory();
  HandleScope scope(i_isolate());

  RegExpBytecodeGenerator orig(i_isolate(), &zone);
  RegExpBytecodeGenerator opt(i_isolate(), &zone);

  CreatePeepholeNoChangeBytecode(&orig);
  CreatePeepholeNoChangeBytecode(&opt);

  Handle<String> source = factory->NewStringFromStaticChars("^foo");

  v8_flags.regexp_peephole_optimization = false;
  DirectHandle<TrustedByteArray> array =
      Cast<TrustedByteArray>(orig.GetCode(source, {}));
  int length = array->length();
  uint8_t* byte_array = array->begin();

  v8_flags.regexp_peephole_optimization = true;
  DirectHandle<TrustedByteArray> array_optimized =
      Cast<TrustedByteArray>(opt.GetCode(source, {}));
  uint8_t* byte_array_optimized = array_optimized->begin();

  CHECK_EQ(0, memcmp(byte_array, byte_array_optimized, length));
}

void CreatePeepholeSkipUntilCharBytecode(RegExpMacroAssembler* m) {
  Label start;
  m->Bind(&start);
  m->LoadCurrentCharacter(0, nullptr, true);
  m->CheckCharacter('x', nullptr);
  m->AdvanceCurrentPosition(1);
  m->GoTo(&start);
}

TEST_F(RegExpTest, PeepholeSkipUntilChar) {
  Zone zone(i_isolate()->allocator(), ZONE_NAME);
  Factory* factory = i_isolate()->factory();
  HandleScope scope(i_isolate());

  RegExpBytecodeGenerator orig(i_isolate(), &zone);
  RegExpBytecodeGenerator opt(i_isolate(), &zone);

  CreatePeepholeSkipUntilCharBytecode(&orig);
  CreatePeepholeSkipUntilCharBytecode(&opt);

  Handle<String> source = factory->NewStringFromStaticChars("dummy");

  v8_flags.regexp_peephole_optimization = false;
  DirectHandle<TrustedByteArray> array =
      Cast<TrustedByteArray>(orig.GetCode(source, {}));
  int length = array->length();

  v8_flags.regexp_peephole_optimization = true;
  DirectHandle<TrustedByteArray> array_optimized =
      Cast<TrustedByteArray>(opt.GetCode(source, {}));
  int length_optimized = array_optimized->length();

  int length_expected = RegExpBytecodeLength(BC_LOAD_CURRENT_CHAR) +
                        RegExpBytecodeLength(BC_CHECK_CHAR) +
                        RegExpBytecodeLength(BC_ADVANCE_CP_AND_GOTO) +
                        RegExpBytecodeLength(BC_POP_BT);
  int length_optimized_expected = RegExpBytecodeLength(BC_SKIP_UNTIL_CHAR) +
                                  RegExpBytecodeLength(BC_POP_BT);

  CHECK_EQ(length, length_expected);
  CHECK_EQ(length_optimized, length_optimized_expected);

  CHECK_EQ(BC_SKIP_UNTIL_CHAR, array_optimized->get(0));
  CHECK_EQ(BC_POP_BT,
           array_optimized->get(RegExpBytecodeLength(BC_SKIP_UNTIL_CHAR)));
}

void CreatePeepholeSkipUntilBitInTableBytecode(RegExpMacroAssembler* m,
                                               Factory* factory) {
  Handle<ByteArray> bit_table = factory->NewByteArray(
      RegExpMacroAssembler::kTableSize, AllocationType::kOld);
  for (uint32_t i = 0; i < RegExpMacroAssembler::kTableSize; i++) {
    bit_table->set(i, 0);
  }

  Label start;
  m->Bind(&start);
  m->LoadCurrentCharacter(0, nullptr, true);
  m->CheckBitInTable(bit_table, nullptr);
  m->AdvanceCurrentPosition(1);
  m->GoTo(&start);
}

TEST_F(RegExpTest, PeepholeSkipUntilBitInTable) {
  Zone zone(i_isolate()->allocator(), ZONE_NAME);
  Factory* factory = i_isolate()->factory();
  HandleScope scope(i_isolate());

  RegExpBytecodeGenerator orig(i_isolate(), &zone);
  RegExpBytecodeGenerator opt(i_isolate(), &zone);

  CreatePeepholeSkipUntilBitInTableBytecode(&orig, factory);
  CreatePeepholeSkipUntilBitInTableBytecode(&opt, factory);

  Handle<String> source = factory->NewStringFromStaticChars("dummy");

  v8_flags.regexp_peephole_optimization = false;
  DirectHandle<TrustedByteArray> array =
      Cast<TrustedByteArray>(orig.GetCode(source, {}));
  int length = array->length();

  v8_flags.regexp_peephole_optimization = true;
  DirectHandle<TrustedByteArray> array_optimized =
      Cast<TrustedByteArray>(opt.GetCode(source, {}));
  int length_optimized = array_optimized->length();

  int length_expected = RegExpBytecodeLength(BC_LOAD_CURRENT_CHAR) +
                        RegExpBytecodeLength(BC_CHECK_BIT_IN_TABLE) +
                        RegExpBytecodeLength(BC_ADVANCE_CP_AND_GOTO) +
                        RegExpBytecodeLength(BC_POP_BT);
  int length_optimized_expected =
      RegExpBytecodeLength(BC_SKIP_UNTIL_BIT_IN_TABLE) +
      RegExpBytecodeLength(BC_POP_BT);

  CHECK_EQ(length, length_expected);
  CHECK_EQ(length_optimized, length_optimized_expected);

  CHECK_EQ(BC_SKIP_UNTIL_BIT_IN_TABLE, array_optimized->get(0));
  CHECK_EQ(BC_POP_BT, array_optimized->get(
                          RegExpBytecodeLength(BC_SKIP_UNTIL_BIT_IN_TABLE)));
}

void CreatePeepholeSkipUntilCharPosCheckedBytecode(RegExpMacroAssembler* m) {
  Label start;
  m->Bind(&start);
  m->LoadCurrentCharacter(0, nullptr, true, 1, 2);
  m->CheckCharacter('x', nullptr);
  m->AdvanceCurrentPosition(1);
  m->GoTo(&start);
}

TEST_F(RegExpTest, PeepholeSkipUntilCharPosChecked) {
  Zone zone(i_isolate()->allocator(), ZONE_NAME);
  Factory* factory = i_isolate()->factory();
  HandleScope scope(i_isolate());

  RegExpBytecodeGenerator orig(i_isolate(), &zone);
  RegExpBytecodeGenerator opt(i_isolate(), &zone);

  CreatePeepholeSkipUntilCharPosCheckedBytecode(&orig);
  CreatePeepholeSkipUntilCharPosCheckedBytecode(&opt);

  Handle<String> source = factory->NewStringFromStaticChars("dummy");

  v8_flags.regexp_peephole_optimization = false;
  DirectHandle<TrustedByteArray> array =
      Cast<TrustedByteArray>(orig.GetCode(source, {}));
  int length = array->length();

  v8_flags.regexp_peephole_optimization = true;
  DirectHandle<TrustedByteArray> array_optimized =
      Cast<TrustedByteArray>(opt.GetCode(source, {}));
  int length_optimized = array_optimized->length();

  int length_expected = RegExpBytecodeLength(BC_CHECK_CURRENT_POSITION) +
                        RegExpBytecodeLength(BC_LOAD_CURRENT_CHAR_UNCHECKED) +
                        RegExpBytecodeLength(BC_CHECK_CHAR) +
                        RegExpBytecodeLength(BC_ADVANCE_CP_AND_GOTO) +
                        RegExpBytecodeLength(BC_POP_BT);
  int length_optimized_expected =
      RegExpBytecodeLength(BC_SKIP_UNTIL_CHAR_POS_CHECKED) +
      RegExpBytecodeLength(BC_POP_BT);

  CHECK_EQ(length, length_expected);
  CHECK_EQ(length_optimized, length_optimized_expected);

  CHECK_EQ(BC_SKIP_UNTIL_CHAR_POS_CHECKED, array_optimized->get(0));
  CHECK_EQ(BC_POP_BT, array_optimized->get(RegExpBytecodeLength(
                          BC_SKIP_UNTIL_CHAR_POS_CHECKED)));
}

void CreatePeepholeSkipUntilCharAndBytecode(RegExpMacroAssembler* m) {
  Label start;
  m->Bind(&start);
  m->LoadCurrentCharacter(0, nullptr, true, 1, 2);
  m->CheckCharacterAfterAnd('x', 0xFF, nullptr);
  m->AdvanceCurrentPosition(1);
  m->GoTo(&start);
}

TEST_F(RegExpTest, PeepholeSkipUntilCharAnd) {
  Zone zone(i_isolate()->allocator(), ZONE_NAME);
  Factory* factory = i_isolate()->factory();
  HandleScope scope(i_isolate());

  RegExpBytecodeGenerator orig(i_isolate(), &zone);
  RegExpBytecodeGenerator opt(i_isolate(), &zone);

  CreatePeepholeSkipUntilCharAndBytecode(&orig);
  CreatePeepholeSkipUntilCharAndBytecode(&opt);

  Handle<String> source = factory->NewStringFromStaticChars("dummy");

  v8_flags.regexp_peephole_optimization = false;
  DirectHandle<TrustedByteArray> array =
      Cast<TrustedByteArray>(orig.GetCode(source, {}));
  int length = array->length();

  v8_flags.regexp_peephole_optimization = true;
  DirectHandle<TrustedByteArray> array_optimized =
      Cast<TrustedByteArray>(opt.GetCode(source, {}));
  int length_optimized = array_optimized->length();

  int length_expected = RegExpBytecodeLength(BC_CHECK_CURRENT_POSITION) +
                        RegExpBytecodeLength(BC_LOAD_CURRENT_CHAR_UNCHECKED) +
                        RegExpBytecodeLength(BC_AND_CHECK_CHAR) +
                        RegExpBytecodeLength(BC_ADVANCE_CP_AND_GOTO) +
                        RegExpBytecodeLength(BC_POP_BT);
  int length_optimized_expected = RegExpBytecodeLength(BC_SKIP_UNTIL_CHAR_AND) +
                                  RegExpBytecodeLength(BC_POP_BT);

  CHECK_EQ(length, length_expected);
  CHECK_EQ(length_optimized, length_optimized_expected);

  CHECK_EQ(BC_SKIP_UNTIL_CHAR_AND, array_optimized->get(0));
  CHECK_EQ(BC_POP_BT,
           array_optimized->get(RegExpBytecodeLength(BC_SKIP_UNTIL_CHAR_AND)));
}

void CreatePeepholeSkipUntilCharOrCharBytecode(RegExpMacroAssembler* m) {
  Label start;
  m->Bind(&start);
  m->LoadCurrentCharacter(0, nullptr, true);
  m->CheckCharacter('x', nullptr);
  m->CheckCharacter('y', nullptr);
  m->AdvanceCurrentPosition(1);
  m->GoTo(&start);
}

TEST_F(RegExpTest, PeepholeSkipUntilCharOrChar) {
  Zone zone(i_isolate()->allocator(), ZONE_NAME);
  Factory* factory = i_isolate()->factory();
  HandleScope scope(i_isolate());

  RegExpBytecodeGenerator orig(i_isolate(), &zone);
  RegExpBytecodeGenerator opt(i_isolate(), &zone);

  CreatePeepholeSkipUntilCharOrCharBytecode(&orig);
  CreatePeepholeSkipUntilCharOrCharBytecode(&opt);

  Handle<String> source = factory->NewStringFromStaticChars("dummy");

  v8_flags.regexp_peephole_optimization = false;
  DirectHandle<TrustedByteArray> array =
      Cast<TrustedByteArray>(orig.GetCode(source, {}));
  int length = array->length();

  v8_flags.regexp_peephole_optimization = true;
  DirectHandle<TrustedByteArray> array_optimized =
      Cast<TrustedByteArray>(opt.GetCode(source, {}));
  int length_optimized = array_optimized->length();

  int length_expected = RegExpBytecodeLength(BC_LOAD_CURRENT_CHAR) +
                        RegExpBytecodeLength(BC_CHECK_CHAR) +
                        RegExpBytecodeLength(BC_CHECK_CHAR) +
                        RegExpBytecodeLength(BC_ADVANCE_CP_AND_GOTO) +
                        RegExpBytecodeLength(BC_POP_BT);
  int length_optimized_expected =
      RegExpBytecodeLength(BC_SKIP_UNTIL_CHAR_OR_CHAR) +
      RegExpBytecodeLength(BC_POP_BT);

  CHECK_EQ(length, length_expected);
  CHECK_EQ(length_optimized, length_optimized_expected);

  CHECK_EQ(BC_SKIP_UNTIL_CHAR_OR_CHAR, array_optimized->get(0));
  CHECK_EQ(BC_POP_BT, array_optimized->get(
                          RegExpBytecodeLength(BC_SKIP_UNTIL_CHAR_OR_CHAR)));
}

void CreatePeepholeSkipUntilGtOrNotBitInTableBytecode(RegExpMacroAssembler* m,
                                                      Factory* factory) {
  Handle<ByteArray> bit_table = factory->NewByteArray(
      RegExpMacroAssembler::kTableSize, AllocationType::kOld);
  for (uint32_t i = 0; i < RegExpMacroAssembler::kTableSize; i++) {
    bit_table->set(i, 0);
  }

  Label start, end, advance;
  m->Bind(&start);
  m->LoadCurrentCharacter(0, nullptr, true);
  m->CheckCharacterGT('x', nullptr);
  m->CheckBitInTable(bit_table, &advance);
  m->GoTo(&end);
  m->Bind(&advance);
  m->AdvanceCurrentPosition(1);
  m->GoTo(&start);
  m->Bind(&end);
}

TEST_F(RegExpTest, PeepholeSkipUntilGtOrNotBitInTable) {
  Zone zone(i_isolate()->allocator(), ZONE_NAME);
  Factory* factory = i_isolate()->factory();
  HandleScope scope(i_isolate());

  RegExpBytecodeGenerator orig(i_isolate(), &zone);
  RegExpBytecodeGenerator opt(i_isolate(), &zone);

  CreatePeepholeSkipUntilGtOrNotBitInTableBytecode(&orig, factory);
  CreatePeepholeSkipUntilGtOrNotBitInTableBytecode(&opt, factory);

  Handle<String> source = factory->NewStringFromStaticChars("dummy");

  v8_flags.regexp_peephole_optimization = false;
  DirectHandle<TrustedByteArray> array =
      Cast<TrustedByteArray>(orig.GetCode(source, {}));
  int length = array->length();

  v8_flags.regexp_peephole_optimization = true;
  DirectHandle<TrustedByteArray> array_optimized =
      Cast<TrustedByteArray>(opt.GetCode(source, {}));
  int length_optimized = array_optimized->length();

  int length_expected = RegExpBytecodeLength(BC_LOAD_CURRENT_CHAR) +
                        RegExpBytecodeLength(BC_CHECK_GT) +
                        RegExpBytecodeLength(BC_CHECK_BIT_IN_TABLE) +
                        RegExpBytecodeLength(BC_GOTO) +
                        RegExpBytecodeLength(BC_ADVANCE_CP_AND_GOTO) +
                        RegExpBytecodeLength(BC_POP_BT);
  int length_optimized_expected =
      RegExpBytecodeLength(BC_SKIP_UNTIL_GT_OR_NOT_BIT_IN_TABLE) +
      RegExpBytecodeLength(BC_POP_BT);

  CHECK_EQ(length, length_expected);
  CHECK_EQ(length_optimized, length_optimized_expected);

  CHECK_EQ(BC_SKIP_UNTIL_GT_OR_NOT_BIT_IN_TABLE, array_optimized->get(0));
  CHECK_EQ(BC_POP_BT, array_optimized->get(RegExpBytecodeLength(
                          BC_SKIP_UNTIL_GT_OR_NOT_BIT_IN_TABLE)));
}

void CreatePeepholeLabelFixupsInsideBytecode(RegExpMacroAssembler* m,
                                             Label* dummy_before,
                                             Label* dummy_after,
                                             Label* dummy_inside) {
  Label loop;
  m->Bind(dummy_before);
  m->LoadCurrentCharacter(0, dummy_before);
  m->CheckCharacter('a', dummy_after);
  m->CheckCharacter('b', dummy_inside);
  m->Bind(&loop);
  m->LoadCurrentCharacter(0, nullptr, true);
  m->CheckCharacter('x', nullptr);
  m->Bind(dummy_inside);
  m->CheckCharacter('y', nullptr);
  m->AdvanceCurrentPosition(1);
  m->GoTo(&loop);
  m->Bind(dummy_after);
  m->LoadCurrentCharacter(0, dummy_before);
  m->CheckCharacter('a', dummy_after);
  m->CheckCharacter('b', dummy_inside);
}

TEST_F(RegExpTest, PeepholeLabelFixupsInside) {
  Zone zone(i_isolate()->allocator(), ZONE_NAME);
  Factory* factory = i_isolate()->factory();
  HandleScope scope(i_isolate());

  RegExpBytecodeGenerator orig(i_isolate(), &zone);
  RegExpBytecodeGenerator opt(i_isolate(), &zone);

  {
    Label dummy_before, dummy_after, dummy_inside;
    CreatePeepholeLabelFixupsInsideBytecode(&opt, &dummy_before, &dummy_after,
                                            &dummy_inside);
  }
  Label dummy_before, dummy_after, dummy_inside;
  CreatePeepholeLabelFixupsInsideBytecode(&orig, &dummy_before, &dummy_after,
                                          &dummy_inside);

  CHECK_EQ(0x00, dummy_before.pos());
  CHECK_EQ(0x28, dummy_inside.pos());
  CHECK_EQ(0x38, dummy_after.pos());

  const Label* labels[] = {&dummy_before, &dummy_after, &dummy_inside};
  const int label_positions[4][3] = {
      {0x04, 0x3C},  // dummy_before
      {0x0C, 0x44},  // dummy after
      {0x14, 0x4C}   // dummy inside
  };

  Handle<String> source = factory->NewStringFromStaticChars("dummy");

  v8_flags.regexp_peephole_optimization = false;
  DirectHandle<TrustedByteArray> array =
      Cast<TrustedByteArray>(orig.GetCode(source, {}));

  for (int label_idx = 0; label_idx < 3; label_idx++) {
    for (int pos_idx = 0; pos_idx < 2; pos_idx++) {
      CHECK_EQ(labels[label_idx]->pos(),
               array->get(label_positions[label_idx][pos_idx]));
    }
  }

  v8_flags.regexp_peephole_optimization = true;
  DirectHandle<TrustedByteArray> array_optimized =
      Cast<TrustedByteArray>(opt.GetCode(source, {}));

  const int pos_fixups[] = {
      0,  // Position before optimization should be unchanged.
      4,  // Position after first replacement should be 4 (optimized size (20) -
          // original size (32) + preserve length (16)).
  };
  const int target_fixups[] = {
      0,  // dummy_before should be unchanged
      4,  // dummy_inside should be 4
      4   // dummy_after should be 4
  };

  for (int label_idx = 0; label_idx < 3; label_idx++) {
    for (int pos_idx = 0; pos_idx < 2; pos_idx++) {
      int label_pos = label_positions[label_idx][pos_idx] + pos_fixups[pos_idx];
      int jump_address =
          *reinterpret_cast<uint32_t*>(array_optimized->begin() + label_pos);
      int expected_jump_address =
          labels[label_idx]->pos() + target_fixups[label_idx];
      CHECK_EQ(expected_jump_address, jump_address);
    }
  }
}

void CreatePeepholeLabelFixupsComplexBytecode(RegExpMacroAssembler* m,
                                              Label* dummy_before,
                                              Label* dummy_between,
                                              Label* dummy_after,
                                              Label* dummy_inside) {
  Label loop1, loop2;
  m->Bind(dummy_before);
  m->LoadCurrentCharacter(0, dummy_before);
  m->CheckCharacter('a', dummy_between);
  m->CheckCharacter('b', dummy_after);
  m->CheckCharacter('c', dummy_inside);
  m->Bind(&loop1);
  m->LoadCurrentCharacter(0, nullptr, true);
  m->CheckCharacter('x', nullptr);
  m->CheckCharacter('y', nullptr);
  m->AdvanceCurrentPosition(1);
  m->GoTo(&loop1);
  m->Bind(dummy_between);
  m->LoadCurrentCharacter(0, dummy_before);
  m->CheckCharacter('a', dummy_between);
  m->CheckCharacter('b', dummy_after);
  m->CheckCharacter('c', dummy_inside);
  m->Bind(&loop2);
  m->LoadCurrentCharacter(0, nullptr, true);
  m->CheckCharacter('x', nullptr);
  m->Bind(dummy_inside);
  m->CheckCharacter('y', nullptr);
  m->AdvanceCurrentPosition(1);
  m->GoTo(&loop2);
  m->Bind(dummy_after);
  m->LoadCurrentCharacter(0, dummy_before);
  m->CheckCharacter('a', dummy_between);
  m->CheckCharacter('b', dummy_after);
  m->CheckCharacter('c', dummy_inside);
}

TEST_F(RegExpTest, PeepholeLabelFixupsComplex) {
  Zone zone(i_isolate()->allocator(), ZONE_NAME);
  Factory* factory = i_isolate()->factory();
  HandleScope scope(i_isolate());

  RegExpBytecodeGenerator orig(i_isolate(), &zone);
  RegExpBytecodeGenerator opt(i_isolate(), &zone);

  {
    Label dummy_before, dummy_between, dummy_after, dummy_inside;
    CreatePeepholeLabelFixupsComplexBytecode(
        &opt, &dummy_before, &dummy_between, &dummy_after, &dummy_inside);
  }
  Label dummy_before, dummy_between, dummy_after, dummy_inside;
  CreatePeepholeLabelFixupsComplexBytecode(&orig, &dummy_before, &dummy_between,
                                           &dummy_after, &dummy_inside);

  CHECK_EQ(0x00, dummy_before.pos());
  CHECK_EQ(0x40, dummy_between.pos());
  CHECK_EQ(0x70, dummy_inside.pos());
  CHECK_EQ(0x80, dummy_after.pos());

  const Label* labels[] = {&dummy_before, &dummy_between, &dummy_after,
                           &dummy_inside};
  const int label_positions[4][3] = {
      {0x04, 0x44, 0x84},  // dummy_before
      {0x0C, 0x4C, 0x8C},  // dummy between
      {0x14, 0x54, 0x94},  // dummy after
      {0x1C, 0x5C, 0x9C}   // dummy inside
  };

  Handle<String> source = factory->NewStringFromStaticChars("dummy");

  v8_flags.regexp_peephole_optimization = false;
  DirectHandle<TrustedByteArray> array =
      Cast<TrustedByteArray>(orig.GetCode(source, {}));

  for (int label_idx = 0; label_idx < 4; label_idx++) {
    for (int pos_idx = 0; pos_idx < 3; pos_idx++) {
      CHECK_EQ(labels[label_idx]->pos(),
               array->get(label_positions[label_idx][pos_idx]));
    }
  }

  v8_flags.regexp_peephole_optimization = true;
  DirectHandle<TrustedByteArray> array_optimized =
      Cast<TrustedByteArray>(opt.GetCode(source, {}));

  const int pos_fixups[] = {
      0,    // Position before optimization should be unchanged.
      -12,  // Position after first replacement should be -12 (optimized size =
            // 20 - 32 = original size).
      -8    // Position after second replacement should be -8 (-12 from first
            // optimization -12 from second optimization + 16 preserved
            // bytecodes).
  };
  const int target_fixups[] = {
      0,    // dummy_before should be unchanged
      -12,  // dummy_between should be -12
      -8,   // dummy_inside should be -8
      -8    // dummy_after should be -8
  };

  for (int label_idx = 0; label_idx < 4; label_idx++) {
    for (int pos_idx = 0; pos_idx < 3; pos_idx++) {
      int label_pos = label_positions[label_idx][pos_idx] + pos_fixups[pos_idx];
      int jump_address =
          *reinterpret_cast<uint32_t*>(array_optimized->begin() + label_pos);
      int expected_jump_address =
          labels[label_idx]->pos() + target_fixups[label_idx];
      CHECK_EQ(expected_jump_address, jump_address);
    }
  }
}

TEST_F(RegExpTestWithContext, UnicodePropertyEscapeCodeSize) {
  FlagScope<bool> f(&v8_flags.regexp_tier_up, false);

  v8::HandleScope scope(isolate());
  i::DirectHandle<i::JSRegExp> re = Utils::OpenDirectHandle(
      *RunJS("const r = /\\p{L}\\p{L}\\p{L}/u; r.exec('\\u200b'); r;")
           .As<v8::RegExp>());

  static constexpr int kMaxSize = 200 * KB;
  static constexpr bool kIsNotLatin1 = false;

  Tagged<RegExpData> data = re->data(i_isolate());
  SBXCHECK(Is<IrRegExpData>(data));
  Tagged<IrRegExpData> re_data = Cast<IrRegExpData>(data);

  if (re_data->has_bytecode(kIsNotLatin1)) {
    // On x64, excessive inlining produced >250KB.
    CHECK_LT(re_data->bytecode(kIsNotLatin1)->AllocatedSize(), kMaxSize);
  } else if (re_data->has_code(kIsNotLatin1)) {
    Tagged<Code> code = re_data->code(i_isolate(), kIsNotLatin1);
    // On x64, excessive inlining produced >360KB.
    CHECK_LT(code->Size(), kMaxSize);
    CHECK_EQ(code->kind(), CodeKind::REGEXP);
  } else {
    UNREACHABLE();
  }
}

namespace {

struct RegExpExecData {
  i::Isolate* isolate;
  i::Handle<i::JSRegExp> regexp;
  i::Handle<i::String> subject;
};

i::Handle<i::Object> RegExpExec(const RegExpExecData* d) {
  return i::RegExp::Exec_Single(d->isolate, d->regexp, d->subject, 0,
                                d->isolate->regexp_last_match_info())
      .ToHandleChecked();
}

void ReenterRegExp(v8::Isolate* isolate, void* data) {
  RegExpExecData* d = static_cast<RegExpExecData*>(data);
  i::DirectHandle<i::Object> result = RegExpExec(d);
  CHECK(IsNull(*result));
}

}  // namespace

// Tests reentrant irregexp calls.
TEST_F(RegExpTestWithContext, RegExpInterruptReentrantExecution) {
  CHECK(!v8_flags.jitless);
  v8_flags.regexp_tier_up = false;  // Enter irregexp, not the interpreter.

  v8::HandleScope scope(isolate());

  RegExpExecData d;
  d.isolate = reinterpret_cast<i::Isolate*>(isolate());
  d.regexp = v8::Utils::OpenHandle(
      *v8::RegExp::New(context(), NewString("(a*)*x"), v8::RegExp::kNone)
           .ToLocalChecked());
  d.subject = v8::Utils::OpenHandle(*NewString("aaaa"));

  isolate()->RequestInterrupt(&ReenterRegExp, &d);

  i::DirectHandle<i::Object> result = RegExpExec(&d);
  CHECK(IsNull(*result));
}

#undef CHECK_PARSE_ERROR
#undef CHECK_SIMPLE
#undef CHECK_MIN_MAX

}  // namespace internal
}  // namespace v8

"""


```
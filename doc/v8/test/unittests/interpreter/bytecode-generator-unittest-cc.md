Response:
Let's break down the thought process to arrive at the summary of the provided C++ code.

1. **Initial Scan and Keyword Spotting:**  I first quickly scanned the code, looking for obvious keywords and patterns. I saw `#include`, `namespace v8`, `namespace internal`, `namespace interpreter`, class declarations (`BytecodeGeneratorTest`), function definitions, `TEST_F`, and the use of `gtest` macros like `CHECK`. This immediately tells me it's C++ code within the V8 project, specifically related to testing. The name `BytecodeGeneratorTest` strongly suggests it's testing the bytecode generator.

2. **Understanding the Test Class:** I focused on the `BytecodeGeneratorTest` class. I noted the inheritance from `TestWithContext`, which is a common pattern in V8 unit tests for setting up a V8 isolate environment. The `SetUpTestSuite` and `SetUp` methods confirm this is a test fixture. The presence of `BytecodeExpectationsPrinter` and its usage in the `printer()` method indicates that the tests involve comparing generated bytecode against some expectations.

3. **Analyzing Helper Functions:** I then examined the helper functions outside the test class:
    * `LoadUniqueProperties`, `UniqueVars`, `Repeat`: These functions are clearly for generating repetitive strings, likely to create more complex test cases. The names suggest they create unique variable/property names or repeat code snippets.
    * `kGoldenFileDirectory`, `SkipGoldenFileHeader`, `LoadGolden`: This set of functions points to a "golden file" approach for testing. The code loads expected output from files in a specific directory.
    * `BuildActual`: This function takes a list of code snippets and uses the `BytecodeExpectationsPrinter` to generate the actual bytecode output.
    * `ltrim`, `rtrim`, `trim`:  These are standard string trimming functions, suggesting that whitespace differences in the generated bytecode are not considered significant.
    * `CompareTexts`: This is the core comparison function. It reads the generated and expected output line by line, trims whitespace, and reports differences.

4. **Understanding the `TEST_F` Macros:**  The `TEST_F` macros are `gtest`'s way of defining test cases. Each `TEST_F` takes a name (e.g., `PrimitiveReturnStatements`) and a code block. The names themselves are highly informative, hinting at the specific language features or scenarios being tested (e.g., returning primitive values, primitive expressions, logical expressions, parameters, constants, property access, loops, etc.).

5. **Inferring the Testing Mechanism:** Based on the above observations, I concluded the following testing process:
    * **Input:**  JavaScript code snippets (strings within the `snippets` arrays).
    * **Processing:** The `BytecodeGenerator` (the class being tested, although not directly instantiated in this file) processes these snippets to generate bytecode. The `BytecodeExpectationsPrinter` formats this bytecode.
    * **Expected Output:**  Pre-computed "golden" files containing the expected bytecode for each snippet.
    * **Comparison:** The `CompareTexts` function compares the generated bytecode with the content of the corresponding golden file.

6. **Connecting to JavaScript Functionality:**  The names of the test cases clearly align with JavaScript language features (return statements, expressions, logical operators, parameters, variables, constants, property access, control flow like `if` and loops). This confirms that the `bytecode-generator-unittest.cc` is indeed testing the bytecode generation for various JavaScript constructs.

7. **Considering Torque:** The prompt specifically asked about `.tq` files. Since this file is `.cc`, it's C++, not Torque. Therefore, the Torque condition is false.

8. **Thinking about Common Programming Errors:** While the code itself doesn't directly *demonstrate* common programming errors, the *purpose* of these tests is to ensure the bytecode generator handles various valid JavaScript constructs correctly. Incorrect bytecode generation *could* lead to runtime errors if the generated code doesn't accurately reflect the intended JavaScript logic.

9. **Structuring the Summary:** Finally, I organized my observations into the requested categories:
    * **Functionality:**  Describing the core purpose of testing the bytecode generator.
    * **Torque:** Addressing the `.tq` question.
    * **Relationship to JavaScript:**  Highlighting the connection between the tests and JavaScript language features, and providing a JavaScript example.
    * **Code Logic Inference:** Explaining the input, processing, and output of the tests, and providing a concrete example.
    * **User Programming Errors:** Discussing how incorrect bytecode generation could surface as runtime errors for users.
    * **Overall Functionality (Summary):**  A concise summary of the file's purpose.

By following these steps, I could systematically analyze the provided C++ code and generate a comprehensive and accurate summary, addressing all the points raised in the prompt. The key was to understand the purpose of unit tests, recognize common testing patterns (like golden files), and connect the test names to the corresponding JavaScript concepts.
好的，我们来分析一下 `v8/test/unittests/interpreter/bytecode-generator-unittest.cc` 这个文件的功能。

**文件功能归纳:**

`v8/test/unittests/interpreter/bytecode-generator-unittest.cc` 是 V8 JavaScript 引擎的一个单元测试文件。它的主要功能是测试 **字节码生成器 (Bytecode Generator)** 的正确性。

**具体功能分解:**

1. **测试字节码生成器的输出:** 该文件包含了一系列的测试用例（通过 `TEST_F` 宏定义），每个测试用例都包含一段 JavaScript 代码片段。  测试的目标是验证 V8 的字节码生成器能否为这些 JavaScript 代码生成 **预期** 的字节码序列。

2. **使用“黄金文件”进行比较:**  测试使用了 “黄金文件”（Golden File）机制。
    * 每个测试用例都对应一个 `.golden` 文件（位于 `test/unittests/interpreter/bytecode_expectations/` 目录下）。
    * 这个 `.golden` 文件中存储了为对应 JavaScript 代码片段预期的字节码序列。
    * 测试运行时，`BytecodeGeneratorTest` 会使用 `BytecodeExpectationsPrinter` 生成实际的字节码，并将其与 `.golden` 文件中的内容进行比较。
    * 如果两者一致，则测试通过；否则，测试失败。

3. **覆盖多种 JavaScript 语法和语义:**  从测试用例的命名（例如 `PrimitiveReturnStatements`, `PrimitiveExpressions`, `LogicalExpressions`, `Parameters`, `PropertyLoads`, `BasicLoops` 等）可以看出，该文件覆盖了 JavaScript 中各种基本的语法结构、操作符和语义，例如：
    * 原始类型返回值
    * 原始表达式
    * 逻辑表达式
    * 函数参数
    * 常量（整数、浮点数、字符串）
    * 属性访问（读取和写入）
    * 控制流语句（`if` 语句，循环语句 `while`, `do-while`, `for`）
    * 运算符（一元运算符、二元运算符）
    * 类型判断 (`typeof`)
    * 变量声明
    * 函数字面量
    * 正则表达式字面量
    * 数组字面量
    * 对象字面量
    * 全局变量的加载和存储
    * 函数调用（全局函数、属性方法、运行时函数）
    * `delete` 运算符

4. **辅助函数:** 文件中包含一些辅助函数，用于生成测试所需的 JavaScript 代码片段或加载/比较黄金文件内容：
    * `LoadUniqueProperties`: 生成加载唯一属性的代码。
    * `UniqueVars`: 生成声明唯一变量的代码。
    * `Repeat`: 重复字符串。
    * `LoadGolden`: 从黄金文件中加载预期输出。
    * `BuildActual`: 使用 `BytecodeExpectationsPrinter` 生成实际的字节码输出。
    * `CompareTexts`: 比较生成的字节码和预期字节码。

**关于文件后缀和 Torque:**

你提到如果文件以 `.tq` 结尾，它就是 V8 Torque 源代码。 `v8/test/unittests/interpreter/bytecode-generator-unittest.cc` 的后缀是 `.cc`，这表明它是一个 **C++ 源代码文件**，而不是 Torque 源代码文件。 Torque 是一种用于生成 V8 代码的 DSL (领域特定语言)。

**与 JavaScript 功能的关系及示例:**

该文件中的每个测试用例都直接对应着一个或多个 JavaScript 的功能。以下是一些例子：

* **`PrimitiveReturnStatements` 测试:**  测试 `return` 语句返回各种原始类型值的情况。

   ```javascript
   // 对应的 JavaScript 代码片段 (例如)
   return;
   return null;
   return true;
   return 0;
   ```

* **`PrimitiveExpressions` 测试:** 测试各种原始类型的表达式求值。

   ```javascript
   // 对应的 JavaScript 代码片段 (例如)
   var x = 0; return x + 3;
   var x = 4; return x * 3;
   var x = 1; return x | 2;
   ```

* **`PropertyLoads` 测试:** 测试对象属性的读取。

   ```javascript
   // 对应的 JavaScript 代码片段 (例如)
   function f(a) { return a.name; }
   f({name : "test"});

   function f(a) { return a["key"]; }
   f({key : "test"});
   ```

* **`BasicLoops` 测试:** 测试 `while` 循环。

   ```javascript
   // 对应的 JavaScript 代码片段 (例如)
   var x = 0;
   while (x < 10) {
       x = x + 1;
   }
   return x;
   ```

**代码逻辑推理和假设输入输出:**

以 `PrimitiveExpressions` 测试中的一个片段为例：

* **JavaScript 代码:** `var x = 0; return x + 3;`
* **假设输入:**  V8 引擎的字节码生成器接收到这个 JavaScript 代码片段。
* **预期输出 (可能的字节码 - 简化表示):**
    * `CreateVariable`  // 创建变量 x
    * `LdaSmi [0]`    // 加载小的整数 0 到累加器
    * `StaLocal [x]`  // 将累加器中的值存储到局部变量 x
    * `LdaLocal [x]`  // 加载局部变量 x 的值到累加器
    * `AddSmi [3]`    // 将小的整数 3 加到累加器
    * `Return`        // 返回累加器中的值

   实际的字节码会更复杂，包含操作码和操作数，但大致逻辑如此。 `.golden` 文件中会存储这个预期的字节码序列的文本表示。

**涉及用户常见的编程错误:**

虽然这个单元测试本身不是直接用来捕捉用户编程错误的，但它确保了 V8 的字节码生成器能够正确地处理各种合法的 JavaScript 代码。 如果字节码生成器出现错误，可能会导致：

* **运行时错误:** 生成的字节码无法正确执行，导致程序崩溃或抛出异常。 例如，如果属性访问的字节码生成错误，可能会在尝试访问不存在的属性时出错。
* **逻辑错误:** 生成的字节码与预期的语义不符，导致程序行为不正确。 例如，如果条件判断的字节码生成错误，可能会导致 `if` 语句执行了错误的分支。
* **性能问题:** 生成了低效的字节码，导致程序运行缓慢。

**总结 (针对第 1 部分):**

`v8/test/unittests/interpreter/bytecode-generator-unittest.cc` 的主要功能是作为 V8 JavaScript 引擎中字节码生成器的单元测试套件的一部分。它通过对比实际生成的字节码与预期的“黄金”字节码，来验证字节码生成器对于各种 JavaScript 语法和语义的正确性。 这个文件对于确保 V8 引擎的稳定性和正确性至关重要。

### 提示词
```
这是目录为v8/test/unittests/interpreter/bytecode-generator-unittest.cc的一个v8源代码， 请列举一下它的功能, 
如果v8/test/unittests/interpreter/bytecode-generator-unittest.cc以.tq结尾，那它是个v8 torque源代码，
如果它与javascript的功能有关系，请用javascript举例说明,
如果有代码逻辑推理，请给出假设输入与输出，
如果涉及用户常见的编程错误，请举例说明
这是第1部分，共3部分，请归纳一下它的功能
```

### 源代码
```cpp
// Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/interpreter/bytecode-generator.h"

#include <fstream>

#include "src/init/v8.h"
#include "src/interpreter/bytecode-array-iterator.h"
#include "src/interpreter/interpreter.h"
#include "src/objects/objects-inl.h"
#include "test/unittests/interpreter/bytecode-expectations-printer.h"
#include "test/unittests/test-utils.h"
#include "testing/gtest/include/gtest/gtest.h"

namespace v8 {

namespace internal {
namespace interpreter {

class BytecodeGeneratorTest : public TestWithContext {
 public:
  BytecodeGeneratorTest() : printer_(isolate()) {}
  static void SetUpTestSuite() {
    i::v8_flags.always_turbofan = false;
    i::v8_flags.allow_natives_syntax = true;
    i::v8_flags.enable_lazy_source_positions = false;
    TestWithContext::SetUpTestSuite();
  }

  void SetUp() override { TestWithContext::SetUp(); }

  BytecodeExpectationsPrinter& printer() { return printer_; }

 private:
  BytecodeExpectationsPrinter printer_;
};

int global_counter = 0;  // For unique variable/property names.

std::string LoadUniqueProperties(int n) {
  // Don't take any fancy recursive shortcuts here because
  // {LoadUniqueProperty} must actually be called {n} times.
  std::string result;
  for (int i = 0; i < n; i++) {
    result += "  b.name" + std::to_string(global_counter++) + ";\n";
  }
  return result;
}

std::string UniqueVars(int n) {
  std::string result;
  for (int i = 0; i < n; i++) {
    result += "var a" + std::to_string(global_counter++) + " = 0;\n";
  }
  return result;
}

std::string Repeat(std::string s, int n) {
  if (n == 1) return s;
  std::string half = Repeat(s, n >> 1);
  std::string result = half + half;
  if (n & 1) result += s;
  return result;
}

static const char* kGoldenFileDirectory =
    "test/unittests/interpreter/bytecode_expectations/";

void SkipGoldenFileHeader(std::istream* stream) {
  std::string line;
  int separators_seen = 0;
  while (std::getline(*stream, line)) {
    if (line == "---") separators_seen += 1;
    if (separators_seen == 2) return;
  }
}

std::string LoadGolden(const std::string& golden_filename) {
  std::ifstream expected_file((kGoldenFileDirectory + golden_filename).c_str());
  CHECK(expected_file.is_open());
  SkipGoldenFileHeader(&expected_file);
  std::ostringstream expected_stream;
  // Restore the first separator, which was consumed by SkipGoldenFileHeader
  expected_stream << "---\n" << expected_file.rdbuf();
  return expected_stream.str();
}

template <size_t N>
std::string BuildActual(const BytecodeExpectationsPrinter& printer,
                        std::string (&snippet_list)[N],
                        const char* prologue = nullptr,
                        const char* epilogue = nullptr) {
  std::ostringstream actual_stream;
  for (std::string snippet : snippet_list) {
    std::string source_code;
    if (prologue) source_code += prologue;
    source_code += snippet;
    if (epilogue) source_code += epilogue;
    printer.PrintExpectation(&actual_stream, source_code);
  }
  return actual_stream.str();
}

// inplace left trim
static inline void ltrim(std::string* str) {
  str->erase(str->begin(),
             std::find_if(str->begin(), str->end(),
                          [](unsigned char ch) { return !std::isspace(ch); }));
}

// inplace right trim
static inline void rtrim(std::string* str) {
  str->erase(std::find_if(str->rbegin(), str->rend(),
                          [](unsigned char ch) { return !std::isspace(ch); })
                 .base(),
             str->end());
}

static inline std::string trim(std::string* str) {
  ltrim(str);
  rtrim(str);
  return *str;
}

bool CompareTexts(const std::string& generated, const std::string& expected) {
  std::istringstream generated_stream(generated);
  std::istringstream expected_stream(expected);
  std::string generated_line;
  std::string expected_line;
  // Line number does not include golden file header.
  int line_number = 0;
  bool strings_match = true;

  do {
    std::getline(generated_stream, generated_line);
    std::getline(expected_stream, expected_line);

    if (!generated_stream.good() && !expected_stream.good()) {
      return strings_match;
    }

    if (!generated_stream.good()) {
      std::cerr << "Expected has extra lines after line " << line_number
                << "\n";
      std::cerr << "  Expected: '" << expected_line << "'\n";
      return false;
    } else if (!expected_stream.good()) {
      std::cerr << "Generated has extra lines after line " << line_number
                << "\n";
      std::cerr << "  Generated: '" << generated_line << "'\n";
      return false;
    }

    if (trim(&generated_line) != trim(&expected_line)) {
      std::cerr << "Inputs differ at line " << line_number << "\n";
      std::cerr << "  Generated: '" << generated_line << "'\n";
      std::cerr << "  Expected:  '" << expected_line << "'\n";
      strings_match = false;
    }
    line_number++;
  } while (true);
}

TEST_F(BytecodeGeneratorTest, PrimitiveReturnStatements) {
  std::string snippets[] = {
      "",

      "return;\n",

      "return null;\n",

      "return true;\n",

      "return false;\n",

      "return 0;\n",

      "return +1;\n",

      "return -1;\n",

      "return +127;\n",

      "return -128;\n",

      "return 2.0;\n",
  };

  CHECK(CompareTexts(BuildActual(printer(), snippets),
                     LoadGolden("PrimitiveReturnStatements.golden")));
}

TEST_F(BytecodeGeneratorTest, PrimitiveExpressions) {
  std::string snippets[] = {
      "var x = 0; return x;\n",

      "var x = 0; return x + 3;\n",

      "var x = 0; return 3 + x;\n",

      "var x = 0; return x - 3;\n",

      "var x = 0; return 3 - x;\n",

      "var x = 4; return x * 3;\n",

      "var x = 4; return 3 * x;\n",

      "var x = 4; return x / 3;\n",

      "var x = 4; return 3 / x;\n",

      "var x = 4; return x % 3;\n",

      "var x = 4; return 3 % x;\n",

      "var x = 1; return x | 2;\n",

      "var x = 1; return 2 | x;\n",

      "var x = 1; return x ^ 2;\n",

      "var x = 1; return 2 ^ x;\n",

      "var x = 1; return x & 2;\n",

      "var x = 1; return 2 & x;\n",

      "var x = 10; return x << 3;\n",

      "var x = 10; return 3 << x;\n",

      "var x = 10; return x >> 3;\n",

      "var x = 10; return 3 >> x;\n",

      "var x = 10; return x >>> 3;\n",

      "var x = 10; return 3 >>> x;\n",

      "var x = 0; return (x, 3);\n",
  };

  CHECK(CompareTexts(BuildActual(printer(), snippets),
                     LoadGolden("PrimitiveExpressions.golden")));
}

TEST_F(BytecodeGeneratorTest, LogicalExpressions) {
  std::string snippets[] = {
      "var x = 0; return x || 3;\n",

      "var x = 0; return (x == 1) || 3;\n",

      "var x = 0; return x && 3;\n",

      "var x = 0; return (x == 0) && 3;\n",

      "var x = 0; return x || (1, 2, 3);\n",

      "var a = 2, b = 3, c = 4; return a || (a, b, a, b, c = 5, 3);\n",

      // clang-format off
      "var x = 1; var a = 2, b = 3; return x || (" +
      Repeat("\n  a = 1, b = 2, ", 32) +
      "3);\n",

      "var x = 0; var a = 2, b = 3; return x && (" +
      Repeat("\n  a = 1, b = 2, ", 32) +
      "3);\n",

      "var x = 1; var a = 2, b = 3; return (x > 3) || (" +
      Repeat("\n  a = 1, b = 2, ", 32) +
      "3);\n",

      "var x = 0; var a = 2, b = 3; return (x < 5) && (" +
      Repeat("\n  a = 1, b = 2, ", 32) +
      "3);\n",
      // clang-format on

      "return 0 && 3;\n",

      "return 1 || 3;\n",

      "var x = 1; return x && 3 || 0, 1;\n",
  };

  CHECK(CompareTexts(BuildActual(printer(), snippets),
                     LoadGolden("LogicalExpressions.golden")));
}

TEST_F(BytecodeGeneratorTest, Parameters) {
  printer().set_wrap(false);
  printer().set_test_function_name("f");

  std::string snippets[] = {
      "function f() { return this; }",

      "function f(arg1) { return arg1; }",

      "function f(arg1) { return this; }",

      "function f(arg1, arg2, arg3, arg4, arg5, arg6, arg7) { return arg4; }",

      "function f(arg1, arg2, arg3, arg4, arg5, arg6, arg7) { return this; }",

      "function f(arg1) { arg1 = 1; }",

      "function f(arg1, arg2, arg3, arg4) { arg2 = 1; }",
  };

  CHECK(CompareTexts(BuildActual(printer(), snippets, "", "\nf();"),
                     LoadGolden("Parameters.golden")));
}

TEST_F(BytecodeGeneratorTest, IntegerConstants) {
  std::string snippets[] = {
      "return 12345678;\n",

      "var a = 1234; return 5678;\n",

      "var a = 1234; return 1234;\n",
  };

  CHECK(CompareTexts(BuildActual(printer(), snippets),
                     LoadGolden("IntegerConstants.golden")));
}

TEST_F(BytecodeGeneratorTest, HeapNumberConstants) {
  std::string snippets[] = {
      "return 1.2;\n",

      "var a = 1.2; return 2.6;\n",

      "var a = 3.14; return 3.14;\n",
  };

  CHECK(CompareTexts(BuildActual(printer(), snippets),
                     LoadGolden("HeapNumberConstants.golden")));
}

TEST_F(BytecodeGeneratorTest, StringConstants) {
  std::string snippets[] = {
      "return \"This is a string\";\n",

      "var a = \"First string\"; return \"Second string\";\n",

      "var a = \"Same string\"; return \"Same string\";\n",
  };

  CHECK(CompareTexts(BuildActual(printer(), snippets),
                     LoadGolden("StringConstants.golden")));
}

TEST_F(BytecodeGeneratorTest, PropertyLoads) {
  printer().set_wrap(false);
  printer().set_test_function_name("f");

  // clang-format off
  std::string snippets[] = {
    "function f(a) { return a.name; }\n"
    "f({name : \"test\"});\n",

    "function f(a) { return a[\"key\"]; }\n"
    "f({key : \"test\"});\n",

    "function f(a) { return a[100]; }\n"
    "f({100 : \"test\"});\n",

    "function f(a, b) { return a[b]; }\n"
    "f({arg : \"test\"}, \"arg\");\n",

    "function f(a) { var b = a.name; return a[-124]; }\n"
    "f({\"-124\" : \"test\", name : 123 })",

    "function f(a) {\n"
    "  var b = {};\n" +
       LoadUniqueProperties(128) +
    "  return a.name;\n"
    "}\n"
    "f({name : \"test\"})\n",

    "function f(a, b) {\n"
    "  var c;\n"
    "  c = a[b];\n" +
       Repeat("  c = a[b];\n", 127) +
    "  return a[b];\n"
    "}\n"
    "f({name : \"test\"}, \"name\")\n",
  };
  // clang-format on

  CHECK(CompareTexts(BuildActual(printer(), snippets),
                     LoadGolden("PropertyLoads.golden")));
}

TEST_F(BytecodeGeneratorTest, PropertyLoadStore) {
  printer().set_wrap(false);
  printer().set_top_level(true);

  std::string snippets[] = {
      R"(
      l = {
        'aa': 1.1,
        'bb': 2.2
      };

      v = l['aa'] + l['bb'];
      l['bb'] = 7;
      l['aa'] = l['bb'];
      )",

      R"(
      l = {
        'cc': 3.1,
        'dd': 4.2
      };
      if (l['cc'] < 3) {
        l['cc'] = 3;
      } else {
        l['dd'] = 3;
      }
      )",
  };
  CHECK(CompareTexts(BuildActual(printer(), snippets),
                     LoadGolden("PropertyLoadStore.golden")));
}

TEST_F(BytecodeGeneratorTest, IIFE) {
  printer().set_wrap(false);
  printer().set_top_level(true);
  printer().set_print_callee(true);

  std::string snippets[] = {
      R"(
      (function() {
        l = {};
        l.a = 2;
        l.b = l.a;
        return arguments.callee;
      })();
    )",
      R"(
      (function() {
        l = {
          'a': 4.3,
          'b': 3.4
        };
        if (l.a < 3) {
          l.a = 3;
        } else {
          l.a = l.b;
        }
        return arguments.callee;
      })();
    )",
      R"(
      this.f0 = function() {};
      this.f1 = function(a) {};
      this.f2 = function(a, b) {};
      this.f3 = function(a, b, c) {};
      this.f4 = function(a, b, c, d) {};
      this.f5 = function(a, b, c, d, e) {};
      (function() {
        this.f0();
        this.f1(1);
        this.f2(1, 2);
        this.f3(1, 2, 3);
        this.f4(1, 2, 3, 4);
        this.f5(1, 2, 3, 4, 5);
        return arguments.callee;
      })();
    )",
      R"(
      function f0() {}
      function f1(a) {}
      function f2(a, b) {}
      function f3(a, b, c) {}
      function f4(a, b, c, d) {}
      function f5(a, b, c, d, e) {}
      (function() {
        f0();
        f1(1);
        f2(1, 2);
        f3(1, 2, 3);
        f4(1, 2, 3, 4);
        f5(1, 2, 3, 4, 5);
        return arguments.callee;
      })();
    )",
  };
  CHECK(CompareTexts(BuildActual(printer(), snippets),
                     LoadGolden("IIFE.golden")));
}

TEST_F(BytecodeGeneratorTest, PropertyStores) {
  printer().set_wrap(false);
  printer().set_test_function_name("f");

  // For historical reasons, this test expects the first unique identifier
  // to be 128.
  global_counter = 128;

  // clang-format off
  std::string snippets[] = {
    "function f(a) { a.name = \"val\"; }\n"
    "f({name : \"test\"})",

    "function f(a) { a[\"key\"] = \"val\"; }\n"
    "f({key : \"test\"})",

    "function f(a) { a[100] = \"val\"; }\n"
    "f({100 : \"test\"})",

    "function f(a, b) { a[b] = \"val\"; }\n"
    "f({arg : \"test\"}, \"arg\")",

    "function f(a) { a.name = a[-124]; }\n"
    "f({\"-124\" : \"test\", name : 123 })",

    "function f(a) { \"use strict\"; a.name = \"val\"; }\n"
    "f({name : \"test\"})",

    "function f(a, b) { \"use strict\"; a[b] = \"val\"; }\n"
    "f({arg : \"test\"}, \"arg\")",

    "function f(a) {\n"
    "  a.name = 1;\n"
    "  var b = {};\n" +
       LoadUniqueProperties(128) +
    "  a.name = 2;\n"
    "}\n"
    "f({name : \"test\"})\n",

    "function f(a) {\n"
    " 'use strict';\n"
    "  a.name = 1;\n"
    "  var b = {};\n" +
       LoadUniqueProperties(128) +
    "  a.name = 2;\n"
    "}\n"
    "f({name : \"test\"})\n",

    "function f(a, b) {\n"
    "  a[b] = 1;\n" +
       Repeat("  a[b] = 1;\n", 127) +
    "  a[b] = 2;\n"
    "}\n"
    "f({name : \"test\"})\n",

    "function f(a, b) {\n"
    "  'use strict';\n"
    "  a[b] = 1;\n" +
       Repeat("  a[b] = 1;\n", 127) +
    "  a[b] = 2;\n"
    "}\n"
    "f({name : \"test\"})\n",
  };
  // clang-format on

  CHECK(CompareTexts(BuildActual(printer(), snippets),
                     LoadGolden("PropertyStores.golden")));
}

#define FUNC_ARG "new (function Obj() { this.func = function() { return; }})()"

TEST_F(BytecodeGeneratorTest, PropertyCall) {
  printer().set_wrap(false);
  printer().set_test_function_name("f");

  // For historical reasons, this test expects the first unique identifier
  // to be 384.
  global_counter = 384;

  // clang-format off
  std::string snippets[] = {
      "function f(a) { return a.func(); }\n"
      "f(" FUNC_ARG ")",

      "function f(a, b, c) { return a.func(b, c); }\n"
      "f(" FUNC_ARG ", 1, 2)",

      "function f(a, b) { return a.func(b + b, b); }\n"
      "f(" FUNC_ARG ", 1)",

      "function f(a) {\n"
      "  var b = {};\n" +
         LoadUniqueProperties(128) +
      "  a.func;\n"
      "  return a.func(); }\n"
      "f(" FUNC_ARG ")",

      "function f(a) { return a.func(1).func(2).func(3); }\n"
      "f(new (function Obj() { this.func = function(a) { return this; }})())",
  };
  // clang-format on

  CHECK(CompareTexts(BuildActual(printer(), snippets),
                     LoadGolden("PropertyCall.golden")));
}

TEST_F(BytecodeGeneratorTest, LoadGlobal) {
  printer().set_wrap(false);
  printer().set_test_function_name("f");

  // For historical reasons, this test expects the first unique identifier
  // to be 512.
  global_counter = 512;

  // clang-format off
  std::string snippets[] = {
    "var a = 1;\n"
    "function f() { return a; }\n"
    "f()",

    "function t() { }\n"
    "function f() { return t; }\n"
    "f()",

    "a = 1;\n"
    "function f() { return a; }\n"
    "f()",

    "a = 1;\n"
    "function f(c) {\n"
    "  var b = {};\n" +
       LoadUniqueProperties(128) +
    "  return a;\n"
    "}\n"
    "f({name: 1});\n",
  };
  // clang-format on

  CHECK(CompareTexts(BuildActual(printer(), snippets),
                     LoadGolden("LoadGlobal.golden")));
}

TEST_F(BytecodeGeneratorTest, StoreGlobal) {
  printer().set_wrap(false);
  printer().set_test_function_name("f");

  // For historical reasons, this test expects the first unique identifier
  // to be 640.
  global_counter = 640;

  // clang-format off
  std::string snippets[] = {
    "var a = 1;\n"
    "function f() { a = 2; }\n"
    "f();\n",

    "var a = \"test\"; function f(b) { a = b; }\n"
    "f(\"global\");\n",

    "'use strict'; var a = 1;\n"
    "function f() { a = 2; }\n"
    "f();\n",

    "a = 1;\n"
    "function f() { a = 2; }\n"
    "f();\n",

    "a = 1;\n"
    "function f(c) {\n"
    "  var b = {};\n" +
       LoadUniqueProperties(128) +
    "  a = 2;\n"
    "}\n"
    "f({name: 1});\n",

    "a = 1;\n"
    "function f(c) {\n"
    "  'use strict';\n"
    "  var b = {};\n" +
       LoadUniqueProperties(128) +
    "  a = 2;\n"
    "}\n"
    "f({name: 1});\n",
  };
  // clang-format on

  CHECK(CompareTexts(BuildActual(printer(), snippets),
                     LoadGolden("StoreGlobal.golden")));
}

TEST_F(BytecodeGeneratorTest, CallGlobal) {
  printer().set_wrap(false);
  printer().set_test_function_name("f");

  std::string snippets[] = {
      "function t() { }\n"
      "function f() { return t(); }\n"
      "f();\n",

      "function t(a, b, c) { }\n"
      "function f() { return t(1, 2, 3); }\n"
      "f();\n",
  };

  CHECK(CompareTexts(BuildActual(printer(), snippets),
                     LoadGolden("CallGlobal.golden")));
}

TEST_F(BytecodeGeneratorTest, CallRuntime) {
  printer().set_wrap(false);
  printer().set_test_function_name("f");

  std::string snippets[] = {
      "function f() { %TheHole() }\n"
      "f();\n",

      "function f(a) { return %IsArray(a) }\n"
      "f(undefined);\n",

      "function f() { return %Add(1, 2) }\n"
      "f();\n",
  };

  CHECK(CompareTexts(BuildActual(printer(), snippets),
                     LoadGolden("CallRuntime.golden")));
}

TEST_F(BytecodeGeneratorTest, IfConditions) {
  printer().set_wrap(false);
  printer().set_test_function_name("f");

  // clang-format off
  std::string snippets[] = {
    "function f() {\n"
    "  if (0) {\n"
    "    return 1;\n"
    "  } else {\n"
    "    return -1;\n"
    "  }\n"
    "};\n"
    "f();\n",

    "function f() {\n"
    "  if ('lucky') {\n"
    "    return 1;\n"
    "  } else {\n"
    "    return -1;\n"
    "  }\n"
    "};\n"
    "f();\n",

    "function f() {\n"
    "  if (false) {\n"
    "    return 1;\n"
    "  } else {\n"
    "    return -1;\n"
    "  }\n"
    "};\n"
    "f();\n",

    "function f() {\n"
    "  if (false) {\n"
    "    return 1;\n"
    "  }\n"
    "};\n"
    "f();\n",

    "function f() {\n"
    "  var a = 1;\n"
    "  if (a) {\n"
    "    a += 1;\n"
    "  } else {\n"
    "    return 2;\n"
    "  }\n"
    "};\n"
    "f();\n",

    "function f(a) {\n"
    "  if (a <= 0) {\n"
    "    return 200;\n"
    "  } else {\n"
    "    return -200;\n"
    "  }\n"
    "};\n"
    "f(99);\n",

    "function f(a, b) { if (a in b) { return 200; } }"
    "f('prop', { prop: 'yes'});\n",

    "function f(z) { var a = 0; var b = 0; if (a === 0.01) {\n" +
      Repeat("  b = a; a = b;\n", 64) +
    " return 200; } else { return -200; } } f(0.001);\n",

    "function f() {\n"
    "  var a = 0; var b = 0;\n"
    "  if (a) {\n" +
         Repeat("  b = a; a = b;\n", 64) +
    "  return 200; } else { return -200; }\n"
    "};\n"
    "f();\n",

    "function f(a, b) {\n"
    "  if (a == b) { return 1; }\n"
    "  if (a === b) { return 1; }\n"
    "  if (a < b) { return 1; }\n"
    "  if (a > b) { return 1; }\n"
    "  if (a <= b) { return 1; }\n"
    "  if (a >= b) { return 1; }\n"
    "  if (a in b) { return 1; }\n"
    "  if (a instanceof b) { return 1; }\n"
    "  return 0;\n"
    "}\n"
    "f(1, 1);\n",

    "function f() {\n"
    "  var a = 0;\n"
    "  if (a) {\n"
    "    return 20;\n"
    "  } else {\n"
    "    return -20;\n"
    "  }\n"
    "};\n"
    "f();\n",

    "function f(a, b) {\n"
    "  if (a == b || a < 0) {\n"
    "    return 1;\n"
    "  } else if (a > 0 && b > 0) {\n"
    "    return 0;\n"
    "  } else {\n"
    "    return -1;\n"
    "  }\n"
    "};\n"
    "f(-1, 1);\n",
  };
  // clang-format on

  CHECK(CompareTexts(BuildActual(printer(), snippets),
                     LoadGolden("IfConditions.golden")));
}

TEST_F(BytecodeGeneratorTest, DeclareGlobals) {
  printer().set_wrap(false);
  printer().set_test_function_name("f");
  printer().set_top_level(true);

  std::string snippets[] = {
      "var a = 1;\n",

      "function f() {}\n",

      "var a = 1;\n"
      "a=2;\n",

      "function f() {}\n"
      "f();\n",
  };

  CHECK(CompareTexts(BuildActual(printer(), snippets),
                     LoadGolden("DeclareGlobals.golden")));
}

TEST_F(BytecodeGeneratorTest, BreakableBlocks) {
  std::string snippets[] = {
      "var x = 0;\n"
      "label: {\n"
      "  x = x + 1;\n"
      "  break label;\n"
      "  x = x + 1;\n"
      "}\n"
      "return x;\n",

      "var sum = 0;\n"
      "outer: {\n"
      "  for (var x = 0; x < 10; ++x) {\n"
      "    for (var y = 0; y < 3; ++y) {\n"
      "      ++sum;\n"
      "      if (x + y == 12) { break outer; }\n"
      "    }\n"
      "  }\n"
      "}\n"
      "return sum;\n",

      "outer: {\n"
      "  let y = 10;\n"
      "  function f() { return y; }\n"
      "  break outer;\n"
      "}\n",

      "let x = 1;\n"
      "outer: {\n"
      "  inner: {\n"
      "   let y = 2;\n"
      "    function f() { return x + y; }\n"
      "    if (y) break outer;\n"
      "    y = 3;\n"
      "  }\n"
      "}\n"
      "x = 4;\n",
  };

  CHECK(CompareTexts(BuildActual(printer(), snippets),
                     LoadGolden("BreakableBlocks.golden")));
}

TEST_F(BytecodeGeneratorTest, BasicLoops) {
  std::string snippets[] = {
      "var x = 0;\n"
      "while (false) { x = 99; break; continue; }\n"
      "return x;\n",

      "var x = 0;\n"
      "while (false) {\n"
      "  x = x + 1;\n"
      "};\n"
      "return x;\n",

      "var x = 0;\n"
      "var y = 1;\n"
      "while (x < 10) {\n"
      "  y = y * 12;\n"
      "  x = x + 1;\n"
      "  if (x == 3) continue;\n"
      "  if (x == 4) break;\n"
      "}\n"
      "return y;\n",

      "var i = 0;\n"
      "while (true) {\n"
      "  if (i < 0) continue;\n"
      "  if (i == 3) break;\n"
      "  if (i == 4) break;\n"
      "  if (i == 10) continue;\n"
      "  if (i == 5) break;\n"
      "  i = i + 1;\n"
      "}\n"
      "return i;\n",

      "var i = 0;\n"
      "while (true) {\n"
      "  while (i < 3) {\n"
      "    if (i == 2) break;\n"
      "    i = i + 1;\n"
      "  }\n"
      "  i = i + 1;\n"
      "  break;\n"
      "}\n"
      "return i;\n",

      "var x = 10;\n"
      "var y = 1;\n"
      "while (x) {\n"
      "  y = y * 12;\n"
      "  x = x - 1;\n"
      "}\n"
      "return y;\n",

      "var x = 0; var y = 1;\n"
      "do {\n"
      "  y = y * 10;\n"
      "  if (x == 5) break;\n"
      "  if (x == 6) continue;\n"
      "  x = x + 1;\n"
      "} while (x < 10);\n"
      "return y;\n",

      "var x = 10;\n"
      "var y = 1;\n"
      "do {\n"
      "  y = y * 12;\n"
      "  x = x - 1;\n"
      "} while (x);\n"
      "return y;\n",

      "var x = 0; var y = 1;\n"
      "do {\n"
      "  y = y * 10;\n"
      "  if (x == 5) break;\n"
      "  x = x + 1;\n"
      "  if (x == 6) continue;\n"
      "} while (false);\n"
      "return y;\n",

      "var x = 0; var y = 1;\n"
      "do {\n"
      "  y = y * 10;\n"
      "  if (x == 5) break;\n"
      "  x = x + 1;\n"
      "  if (x == 6) continue;\n"
      "} while (true);\n"
      "return y;\n",

      "var x = 0;\n"
      "for (;;) {\n"
      "  if (x == 1) break;\n"
      "  if (x == 2) continue;\n"
      "  x = x + 1;\n"
      "}\n",

      "for (var x = 0;;) {\n"
      "  if (x == 1) break;\n"
      "  if (x == 2) continue;\n"
      "  x = x + 1;\n"
      "}\n",

      "var x = 0;\n"
      "for (;; x = x + 1) {\n"
      "  if (x == 1) break;\n"
      "  if (x == 2) continue;\n"
      "}\n",

      "for (var x = 0;; x = x + 1) {\n"
      "  if (x == 1) break;\n"
      "  if (x == 2) continue;\n"
      "}\n",

      "var u = 0;\n"
      "for (var i = 0; i < 100; i = i + 1) {\n"
      "  u = u + 1;\n"
      "  continue;\n"
      "}\n",

      "var y = 1;\n"
      "for (var x = 10; x; --x) {\n"
      "  y = y * 12;\n"
      "}\n"
      "return y;\n",

      "var x = 0;\n"
      "for (var i = 0; false; i++) {\n"
      "  x = x + 1;\n"
      "};\n"
      "return x;\n",

      "var x = 0;\n"
      "for (var i = 0; true; ++i) {\n"
      "  x = x + 1;\n"
      "  if (x == 20) break;\n"
      "};\n"
      "return x;\n",

      "var a = 0;\n"
      "while (a) {\n"
      "  { \n"
      "   let z = 1;\n"
      "   function f() { z = 2; }\n"
      "   if (z) continue;\n"
      "   z++;\n"
      "  }\n"
      "}\n",
  };

  CHECK(CompareTexts(BuildActual(printer(), snippets),
                     LoadGolden("BasicLoops.golden")));
}

TEST_F(BytecodeGeneratorTest, UnaryOperators) {
  std::string snippets[] = {
      "var x = 0;\n"
      "while (x != 10) {\n"
      "  x = x + 10;\n"
      "}\n"
      "return x;\n",

      "var x = false;\n"
      "do {\n"
      "  x = !x;\n"
      "} while(x == false);\n"
      "return x;\n",

      "var x = 101;\n"
      "return void(x * 3);\n",

      "var x = 1234;\n"
      "var y = void (x * x - 1);\n"
      "return y;\n",

      "var x = 13;\n"
      "return ~x;\n",

      "var x = 13;\n"
      "return +x;\n",

      "var x = 13;\n"
      "return -x;\n",
  };

  CHECK(CompareTexts(BuildActual(printer(), snippets),
                     LoadGolden("UnaryOperators.golden")));
}

TEST_F(BytecodeGeneratorTest, Typeof) {
  printer().set_wrap(false);
  printer().set_test_function_name("f");

  std::string snippets[] = {
      "function f() {\n"
      " var x = 13;\n"
      " return typeof(x);\n"
      "};",

      "var x = 13;\n"
      "function f() {\n"
      " return typeof(x);\n"
      "};",
  };

  CHECK(CompareTexts(BuildActual(printer(), snippets, "", "\nf();"),
                     LoadGolden("Typeof.golden")));
}

TEST_F(BytecodeGeneratorTest, CompareTypeOf) {
  std::string snippets[] = {
      "return typeof(1) === 'number';\n",

      "return 'string' === typeof('foo');\n",

      "return typeof(true) == 'boolean';\n",

      "return 'string' === typeof(undefined);\n",

      "return 'unknown' === typeof(undefined);\n",
  };

  CHECK(CompareTexts(BuildActual(printer(), snippets),
                     LoadGolden("CompareTypeOf.golden")));
}

TEST_F(BytecodeGeneratorTest, VariableWithHint) {
  printer().set_wrap(false);
  printer().set_test_function_name("test");

  std::string snippets[] = {
      "var test;\n"
      "(function () {\n"
      "    function foo() {\n"
      "        let a = typeof('str'); if (a === 'string') {}\n"
      "        let b = typeof('str'); if (b === 1) {}\n"
      "        let c = typeof('str'); c = 1; if (c === 'string') {}\n"
      "        let d = typeof('str');\n"
      "        if (d === 'string' || d === 'number') {}\n"
      "        let e = 'hello world';\n"
      "        if (e == 'string' || e == 'number') {}\n"
      "        let f = 'hi';\n"
      "        for (let i = 0; i < 2; ++i) {\n"
      "            if (f === 'hi') {}\n"
      "        }\n"
      "        let g = true;\n"
      "        if (g === 's') {}\n"
      "        let j = true;\n"
      "        let k = j || 's';\n"
      "        if (k === 's') {}\n"
      "    }\n"
      "    foo();\n"
      "    test = foo;\n"
      "})();\n",
  };

  CHECK(CompareTexts(BuildActual(printer(), snippets),
                     LoadGolden("VariableWithHint.golden")));
}

TEST_F(BytecodeGeneratorTest, CompareBoolean) {
  std::string snippets[] = {
      "var a = 1;\n"
      "return a === true;\n",

      "var a = true;\n"
      "return true === a;\n",

      "var a = false;\n"
      "return true !== a;\n",

      "var a = 1;\n"
      "return true === a ? 1 : 2;\n",

      "var a = true;\n"
      "return false === a ? 1 : 2;\n",

      "var a = 1;\n"
      "return true !== a ? 1 : 2;\n",

      "var a = false;\n"
      "return false !== null ? 1 : 2;\n",

      "var a = 0;\n"
      "if (a !== true) {\n"
      "  return 1;\n"
      "}\n",

      "var a = true;\n"
      "var b = 0;\n"
      "while (a !== true) {\n"
      "  b++;\n"
      "}\n",

      "(0 === true) ? 1 : 2;\n",

      "(0 !== true) ? 1 : 2;\n",

      "(false === 0) ? 1 : 2;\n",

      "(0 === true || 0 === false) ? 1 : 2;\n",

      "if (0 === true || 0 === false) return 1;\n",

      "if (!('false' === false)) return 1;\n",

      "if (!('false' !== false)) return 1;\n",
  };

  CHECK(CompareTexts(BuildActual(printer(), snippets),
                     LoadGolden("CompareBoolean.golden")));
}

TEST_F(BytecodeGeneratorTest, CompareNil) {
  std::string snippets[] = {
      "var a = 1;\n"
      "return a === null;\n",

      "var a = undefined;\n"
      "return undefined === a;\n",

      "var a = undefined;\n"
      "return undefined !== a;\n",

      "var a = 2;\n"
      "return a != null;\n",

      "var a = undefined;\n"
      "return undefined == a;\n",

      "var a = undefined;\n"
      "return undefined === a ? 1 : 2;\n",

      "var a = 0;\n"
      "return null == a ? 1 : 2;\n",

      "var a = 0;\n"
      "return undefined !== a ? 1 : 2;\n",

      "var a = 0;\n"
      "return a === null ? 1 : 2;\n",

      "var a = 0;\n"
      "if (a === null) {\n"
      "  return 1;\n"
      "} else {\n"
      "  return 2;\n"
      "}\n",

      "var a = 0;\n"
      "if (a != undefined) {\n"
      "  return 1;\n"
      "}\n",

      "var a = undefined;\n"
      "var b = 0;\n"
      "while (a !== undefined) {\n"
      "  b++;\n"
      "}\n",
  };

  CHECK(CompareTexts(BuildActual(printer(), snippets),
                     LoadGolden("CompareNil.golden")));
}

TEST_F(BytecodeGeneratorTest, Delete) {
  std::string snippets[] = {
      "var a = {x:13, y:14}; return delete a.x;\n",

      "'use strict'; var a = {x:13, y:14}; return delete a.x;\n",

      "var a = {1:13, 2:14}; return delete a[2];\n",

      "var a = 10; return delete a;\n",

      "'use strict';\n"
      "var a = {1:10};\n"
      "(function f1() {return a;});\n"
      "return delete a[1];\n",

      "return delete 'test';\n",

      "return delete this;\n",
  };

  CHECK(CompareTexts(BuildActual(printer(), snippets),
                     LoadGolden("Delete.golden")));
}

TEST_F(BytecodeGeneratorTest, GlobalDelete) {
  printer().set_wrap(false);
  printer().set_test_function_name("f");

  std::string snippets[] = {
      "var a = {x:13, y:14};\n"
      "function f() {\n"
      "  return delete a.x;\n"
      "};\n"
      "f();\n",

      "a = {1:13, 2:14};\n"
      "function f() {\n"
      "  'use strict';\n"
      "  return delete a[1];\n"
      "};\n"
      "f();\n",

      "var a = {x:13, y:14};\n"
      "function f() {\n"
      "  return delete a;\n"
      "};\n"
      "f();\n",

      "b = 30;\n"
      "function f() {\n"
      "  return delete b;\n"
      "};\n"
      "f();\n",
  };

  CHECK(CompareTexts(BuildActual(printer(), snippets),
                     LoadGolden("GlobalDelete.golden")));
}

TEST_F(BytecodeGeneratorTest, FunctionLiterals) {
  std::string snippets[] = {
      "return function(){ }\n",

      "return (function(){ })()\n",

      "return (function(x){ return x; })(1)\n",
  };

  CHECK(CompareTexts(BuildActual(printer(), snippets),
                     LoadGolden("FunctionLiterals.golden")));
}

TEST_F(BytecodeGeneratorTest, RegExpLiterals) {
  std::string snippets[] = {
      "return /ab+d/;\n",

      "return /(\\w+)\\s(\\w+)/i;\n",

      "return /ab+d/.exec('abdd');\n",
  };

  CHECK(CompareTexts(BuildActual(printer(), snippets),
                     LoadGolden("RegExpLiterals.golden")));
}

TEST_F(BytecodeGeneratorTest, ArrayLiterals) {
  std::string snippets[] = {
      "return [ 1, 2 ];\n",

      "var a = 1; return [ a, a + 1 ];\n",

      "return [ [ 1, 2 ], [ 3 ] ];\n",

      "var a = 1; return [ [ a, 2 ], [ a + 2 ] ];\n",

      "var a = [ 1, 2 ]; return [ ...a ];\n",

      "var a = [ 1, 2 ]; return [ 0, ...a ];\n",

      "var a = [ 1, 2 ]; return [ ...a, 3 ];\n",
  };

  CHECK(CompareTexts(BuildActual(printer(), snippets),
                     LoadGolden("ArrayLiterals.golden")));
}

TEST_F(BytecodeGeneratorTest, ObjectLiterals) {
  std::string snippets[] = {
      "return { };\n",

      "return { name: 'string', val: 9.2 };\n",

      "var a = 1; return { name: 'string', val: a };\n",

      "var a = 1; return { val: a, val: a + 1 };\n",

      "return { func: function() { } };\n",

      "return { func(a) { return a; } };\n",

      "return {
```
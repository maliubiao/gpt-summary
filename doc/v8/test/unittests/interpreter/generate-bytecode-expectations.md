Response:
Let's break down the thought process to analyze this C++ code.

1. **Understand the Goal:** The filename `generate-bytecode-expectations.cc` strongly suggests the program's purpose: to generate or verify bytecode output for given JavaScript code. The inclusion of "expectations" implies comparing actual bytecode with expected bytecode.

2. **Identify Key Components:** Scan the code for important classes, functions, and data structures. Keywords like `ProgramOptions`, `V8InitializationScope`, `BytecodeExpectationsPrinter`, `ReadRawJSSnippet`, `ExtractSnippets`, `GenerateExpectationsFile`, `CheckBaselineExpectations`, and `main` stand out.

3. **Analyze `ProgramOptions`:** This class is clearly responsible for handling command-line arguments. Note the different flags: `--help`, `--raw-js`, `--stdin`, `--rebaseline`, `--check-baseline`, `--no-wrap`, `--module`, `--top-level`, `--print-callee`, `--elide-redundant-tdz-checks`, `--verbose`, `--output`, `--test-function-name`. Each flag suggests a specific functionality or configuration option. The `Validate()` method confirms input consistency. The `UpdateFromHeader()` and `PrintHeader()` methods hint at a file format with embedded options.

4. **Analyze `V8InitializationScope`:**  This class manages the V8 runtime environment. It initializes V8, creates an isolate, and handles cleanup. It's a common pattern in V8 testing and tools.

5. **Analyze `BytecodeExpectationsPrinter`:**  This is likely the core component for generating the bytecode "expectations." The methods `set_wrap`, `set_module`, `set_top_level`, `set_print_callee`, and `set_test_function_name` control how the bytecode is generated and formatted. The `PrintExpectation()` method is the key function for processing JavaScript snippets.

6. **Analyze Input Handling (`ReadRawJSSnippet`, `ReadNextSnippet`, `ExtractSnippets`):** The code handles different input formats. `--raw-js` indicates direct JavaScript input. Otherwise, it parses a specific format with `"snippet: \""` and `\"` delimiters. The `UnescapeString` function handles escaped characters within the snippets.

7. **Analyze Output Generation (`GenerateExpectationsFile`, `WriteExpectationsFile`, `WriteExpectationsToString`):** The `GenerateExpectationsFile` function orchestrates the bytecode generation using `BytecodeExpectationsPrinter`. `WriteExpectationsFile` writes the output to a file or stdout. `WriteExpectationsToString` captures the output as a string, which is useful for comparison.

8. **Analyze Baseline Functionality (`CollectGoldenFiles`, `CheckBaselineExpectations`):** The `--rebaseline` and `--check-baseline` flags suggest a testing workflow. `CollectGoldenFiles` finds existing "golden" files (expected outputs). `CheckBaselineExpectations` compares the generated bytecode with the content of a golden file, reporting any differences.

9. **Analyze `main` Function:** This function ties everything together. It parses command-line arguments, initializes V8, reads input snippets, generates bytecode expectations, and either writes the output or compares it with baseline files. The logic for handling single files vs. multiple files and the `--rebaseline`/`--check-baseline` flags is important.

10. **Infer Functionality from Usage:**  The `PrintUsage` function provides a high-level overview of how to use the tool and reinforces the identified functionalities.

11. **Connect to JavaScript:**  The core purpose is to analyze JavaScript. The examples in the prompt directly relate to JavaScript code and what bytecode would be generated for it.

12. **Identify Potential Errors:**  The code includes error handling (e.g., `REPORT_ERROR`). Consider common mistakes when working with this tool, like incorrect command-line arguments, mismatches between generated and expected output, and misunderstandings of the input format.

13. **Relate to Torque (Based on the Prompt):** The prompt introduces the concept of `.tq` files. Since this file is `.cc`, it's *not* a Torque file. However, the prompt asks what would happen *if* it were. Torque is V8's internal DSL for defining built-in functions, so a `.tq` file would define the *implementation* of some JavaScript functionality, not the bytecode *expectation*.

14. **Structure the Answer:** Organize the findings logically, starting with the primary function, then detailing specific aspects like command-line options, input/output, and baseline handling. Use clear language and provide illustrative JavaScript examples where applicable. Address all parts of the prompt (functionality, Torque, JavaScript examples, logic, and common errors).

This detailed thought process, involving code scanning, keyword identification, logical deduction, and relating it to the problem domain (V8 bytecode generation), leads to the comprehensive answer provided previously.
`v8/test/unittests/interpreter/generate-bytecode-expectations.cc` 是一个 C++ 源代码文件，它属于 V8 JavaScript 引擎的测试框架。它的主要功能是 **生成或验证 JavaScript 代码片段的预期字节码 (bytecode) 输出**。

以下是该文件的详细功能分解：

**1. 功能概述:**

* **为 JavaScript 代码生成预期字节码:** 该工具读取一段 JavaScript 代码片段，然后在 V8 引擎中执行它，并提取生成的字节码。
* **生成 "golden" 文件:** 生成的字节码可以保存到一个 "golden" 文件中，作为未来测试的基准 (baseline)。
* **验证字节码:** 该工具可以读取一个已有的 "golden" 文件和一个新的 JavaScript 代码片段，比较新生成的字节码和 "golden" 文件中的字节码，以确保 V8 引擎的字节码生成器没有意外的改变。
* **支持多种输入方式:** 可以从命令行参数指定的文件读取 JavaScript 代码，也可以从标准输入读取。
* **支持多种输出方式:** 可以将生成的字节码输出到标准输出，也可以保存到指定的文件中。
* **支持不同的代码上下文:** 可以处理独立的 JavaScript 代码片段，也可以处理需要包裹在函数中的代码。
* **支持模块 (Module) 和顶层代码 (Top-level Code):** 可以为 JavaScript 模块和顶层代码生成字节码。
* **提供选项控制字节码生成行为:**  例如，是否包裹在函数中、测试函数名、是否打印被调用函数的字节码等。
* **用于自动化测试:** 该工具的主要目的是为了帮助 V8 开发人员编写和维护测试用例，确保字节码生成器的正确性。

**2. 如果 `v8/test/unittests/interpreter/generate-bytecode-expectations.cc` 以 `.tq` 结尾:**

如果该文件以 `.tq` 结尾，那么它将是一个 **V8 Torque 源代码文件**。Torque 是 V8 内部使用的一种领域特定语言 (DSL)，用于定义 V8 中内置函数 (built-in functions) 的实现。与 C++ 代码不同，Torque 代码会被编译成 C++ 代码，然后再被 V8 编译。

**3. 与 JavaScript 的功能关系及 JavaScript 示例:**

`generate-bytecode-expectations.cc` 的核心功能是分析和展示 JavaScript 代码生成的字节码。以下是一些 JavaScript 示例，以及该工具可能生成的预期字节码（简化表示）：

**示例 1: 简单函数**

```javascript
function add(a, b) {
  return a + b;
}
```

该工具可能会生成类似以下的预期字节码：

```
---
wrap: yes
---
snippet: "function add(a, b) { return a + b; }"
---
LdaSmi [0]
Star r2
LdaSmi [1]
Star r3
Ldar r2
Add r3, r4
Return
```

**示例 2: 变量声明和赋值**

```javascript
let x = 10;
console.log(x);
```

该工具可能会生成类似以下的预期字节码：

```
---
wrap: no
top level: yes
---
snippet: "let x = 10; console.log(x);"
---
LdaSmi [10]
StarGlobalLexicalScope slot[0]
LdaGlobal [console]
StaCurrentContextSlot [0]
LdaCurrentContextSlot [0]
GetProperty a0, [log]
LdaGlobalLexicalScope slot[0]
CallRuntime [Call] with arguments (r0, r1)
Pop
Return
```

**解释:**

* `LdaSmi [0]`:  加载小整数 0 到累加器。
* `Star r2`: 将累加器的值存储到寄存器 r2。
* `Ldar r2`: 将寄存器 r2 的值加载到累加器。
* `Add r3, r4`: 将累加器中的值与寄存器 r3 中的值相加，结果存储到寄存器 r4。
* `Return`: 返回累加器中的值。
* `LdaGlobal [console]`: 加载全局对象 `console`。
* `GetProperty a0, [log]`: 从寄存器 `a0` (console 对象) 获取属性 `log`。
* `CallRuntime [Call] with arguments (r0, r1)`: 调用运行时函数 `Call`，传入参数。

**4. 代码逻辑推理和假设输入与输出:**

假设我们有一个名为 `test.js` 的文件，内容如下：

```javascript
function multiply(x) {
  return x * 2;
}
multiply(5);
```

**使用以下命令运行该工具（假设已编译并添加到 PATH）：**

```bash
generate-bytecode-expectations test.js
```

**假设输出（到标准输出）：**

```
#
# Autogenerated by generate-bytecode-expectations.
#

---
wrap: yes
---
snippet: "function multiply(x) { return x * 2; }\nmultiply(5);"
---
LdaSmi [5]
Star r2
Ldar r2
LdaSmi [2]
Mul r3, r4
Return
```

**解释:**

* 工具读取了 `test.js` 的内容。
* 它默认将代码包裹在一个函数中 (`wrap: yes`)。
* `snippet` 包含了输入的 JavaScript 代码。
* 后面的字节码是 `multiply` 函数的字节码，它将参数 `x` 乘以 2 并返回。  由于 `multiply(5)` 的调用发生在函数定义之后且在包裹的函数内部，其字节码也会被包含。

**如果使用 `--no-wrap` 和 `--top-level` 选项：**

```bash
generate-bytecode-expectations --no-wrap --top-level test.js
```

**假设输出：**

```
#
# Autogenerated by generate-bytecode-expectations.
#

---
wrap: no
top level: yes
---
snippet: "function multiply(x) { return x * 2; }\nmultiply(5);"
---
LdaUndefined
Star r0
LdaConstant [0]
Star r1
LdaSmi [5]
Star r3
Ldar r3
LdaSmi [2]
Mul r4, r5
Return
LdaSmi [5]
PushContext [0]
CallUndefinedReceiver0 r0, [0]
PopContext r0
Pop
Return
```

**解释:**

*  `wrap: no` 和 `top level: yes` 表明代码被视为顶层代码，没有被包裹在额外的函数中。
*  输出的字节码会包含函数定义和 `multiply(5)` 的调用。

**5. 涉及用户常见的编程错误:**

该工具本身并不会直接捕获 JavaScript 编程错误。它的目的是展示 V8 *如何处理* 给定的 JavaScript 代码，即使代码可能存在错误。

然而，使用该工具的方式可能会暴露一些用户在使用 V8 或编写测试时可能犯的错误：

* **不理解字节码的含义:** 用户可能会看到生成的字节码，但不清楚其对应的 JavaScript 操作，这会导致对 V8 引擎行为的误解。
* **期望的字节码与实际生成的不同:** 当修改了 V8 引擎的代码（特别是字节码生成器相关部分）后，运行该工具可能会发现实际生成的字节码与之前 "golden" 文件中的预期不符。这通常意味着引入了 bug 或行为上的改变。
* **忽略了不同选项对字节码的影响:**  用户可能会在不同的选项设置下运行工具，但没有意识到 `--wrap`, `--top-level`, `--module` 等选项会显著影响生成的字节码。
* **在不适当的上下文中使用字节码分析:**  直接查看字节码对于理解高级的 JavaScript 语义可能不够直观，有时需要结合 V8 的其他工具和知识。

**示例：期望的字节码不一致**

假设用户错误地认为以下代码会生成完全相同的字节码：

```javascript
let a = 1;
let b = 2;
console.log(a + b);
```

和

```javascript
let x = 1;
let y = 2;
console.log(x + y);
```

运行该工具并比较生成的字节码可能会发现，虽然逻辑相同，但变量名可能会影响字节码中的寄存器分配等细节，导致字节码不完全一致。这提醒用户，即使 JavaScript 逻辑相同，底层的实现细节也可能有所不同。

总而言之，`v8/test/unittests/interpreter/generate-bytecode-expectations.cc` 是一个强大的测试工具，用于理解和验证 V8 引擎的字节码生成行为，对于 V8 开发和测试至关重要。 它帮助开发者确保 JavaScript 代码被正确地翻译成高效的字节码执行。

### 提示词
```
这是目录为v8/test/unittests/interpreter/generate-bytecode-expectations.cc的一个v8源代码， 请列举一下它的功能, 
如果v8/test/unittests/interpreter/generate-bytecode-expectations.cc以.tq结尾，那它是个v8 torque源代码，
如果它与javascript的功能有关系，请用javascript举例说明,
如果有代码逻辑推理，请给出假设输入与输出，
如果涉及用户常见的编程错误，请举例说明
```

### 源代码
```
// Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include <algorithm>
#include <cstring>
#include <fstream>
#include <memory>
#include <sstream>
#include <vector>

#include "include/libplatform/libplatform.h"
#include "include/v8-array-buffer.h"
#include "include/v8-context.h"
#include "include/v8-initialization.h"
#include "include/v8-local-handle.h"
#include "include/v8-message.h"
#include "src/base/logging.h"
#include "src/interpreter/interpreter.h"
#include "test/unittests/interpreter/bytecode-expectations-printer.h"

#ifdef V8_OS_POSIX
#include <dirent.h>
#elif V8_OS_WIN
#include <windows.h>
#endif

using v8::internal::interpreter::BytecodeExpectationsPrinter;

#define REPORT_ERROR(MESSAGE) (((std::cerr << "ERROR: ") << MESSAGE) << '\n')

namespace {

const char* kGoldenFilesPath =
    "test/unittests/interpreter/bytecode_expectations/";

class ProgramOptions final {
 public:
  static ProgramOptions FromCommandLine(int argc, char** argv);

  ProgramOptions()
      : parsing_failed_(false),
        print_help_(false),
        read_raw_js_snippet_(false),
        read_from_stdin_(false),
        rebaseline_(false),
        check_baseline_(false),
        wrap_(true),
        module_(false),
        top_level_(false),
        print_callee_(false),
        elide_redundant_tdz_checks_(false),
        verbose_(false) {}

  bool Validate() const;
  void UpdateFromHeader(std::istream* stream);
  void PrintHeader(std::ostream* stream) const;

  bool parsing_failed() const { return parsing_failed_; }
  bool print_help() const { return print_help_; }
  bool read_raw_js_snippet() const { return read_raw_js_snippet_; }
  bool read_from_stdin() const { return read_from_stdin_; }
  bool write_to_stdout() const {
    return output_filename_.empty() && !rebaseline_;
  }
  bool rebaseline() const { return rebaseline_; }
  bool check_baseline() const { return check_baseline_; }
  bool baseline() const { return rebaseline_ || check_baseline_; }
  bool wrap() const { return wrap_; }
  bool module() const { return module_; }
  bool top_level() const { return top_level_; }
  bool print_callee() const { return print_callee_; }
  bool elide_redundant_tdz_checks() const {
    return elide_redundant_tdz_checks_;
  }
  bool verbose() const { return verbose_; }
  bool suppress_runtime_errors() const { return baseline() && !verbose_; }
  std::vector<std::string> input_filenames() const { return input_filenames_; }
  std::string output_filename() const { return output_filename_; }
  std::string test_function_name() const { return test_function_name_; }

 private:
  bool parsing_failed_;
  bool print_help_;
  bool read_raw_js_snippet_;
  bool read_from_stdin_;
  bool rebaseline_;
  bool check_baseline_;
  bool wrap_;
  bool module_;
  bool top_level_;
  bool print_callee_;
  bool elide_redundant_tdz_checks_;
  bool verbose_;
  std::vector<std::string> input_filenames_;
  std::string output_filename_;
  std::string test_function_name_;
};

class V8_NODISCARD V8InitializationScope final {
 public:
  explicit V8InitializationScope(const char* exec_path);
  ~V8InitializationScope();
  V8InitializationScope(const V8InitializationScope&) = delete;
  V8InitializationScope& operator=(const V8InitializationScope&) = delete;

  v8::Platform* platform() const { return platform_.get(); }
  v8::Isolate* isolate() const { return isolate_; }

 private:
  std::unique_ptr<v8::Platform> platform_;
  std::unique_ptr<v8::ArrayBuffer::Allocator> allocator_;
  v8::Isolate* isolate_;
};

bool ParseBoolean(const char* string) {
  if (strcmp(string, "yes") == 0) {
    return true;
  } else if (strcmp(string, "no") == 0) {
    return false;
  } else {
    UNREACHABLE();
  }
}

const char* BooleanToString(bool value) { return value ? "yes" : "no"; }

bool CollectGoldenFiles(std::vector<std::string>* golden_file_list,
                        const char* directory_path) {
#ifdef V8_OS_POSIX
  DIR* directory = opendir(directory_path);
  if (!directory) return false;

  auto str_ends_with = [](const char* string, const char* suffix) {
    size_t string_size = strlen(string);
    size_t suffix_size = strlen(suffix);
    if (string_size < suffix_size) return false;

    return strcmp(string + (string_size - suffix_size), suffix) == 0;
  };

  dirent* entry = readdir(directory);
  while (entry) {
    if (str_ends_with(entry->d_name, ".golden")) {
      std::string golden_filename(kGoldenFilesPath);
      golden_filename += entry->d_name;
      golden_file_list->push_back(golden_filename);
    }
    entry = readdir(directory);
  }

  closedir(directory);
#elif V8_OS_WIN
  std::string search_path(directory_path + std::string("/*.golden"));
  WIN32_FIND_DATAA fd;
  HANDLE find_handle = FindFirstFileA(search_path.c_str(), &fd);
  if (find_handle == INVALID_HANDLE_VALUE) return false;
  do {
    if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
      std::string golden_filename(kGoldenFilesPath);
      std::string temp_filename(fd.cFileName);
      golden_filename += temp_filename;
      golden_file_list->push_back(golden_filename);
    }
  } while (FindNextFileA(find_handle, &fd));
  FindClose(find_handle);
#endif  // V8_OS_POSIX
  return true;
}

// static
ProgramOptions ProgramOptions::FromCommandLine(int argc, char** argv) {
  ProgramOptions options;

  for (int i = 1; i < argc; ++i) {
    if (strcmp(argv[i], "--help") == 0) {
      options.print_help_ = true;
    } else if (strcmp(argv[i], "--raw-js") == 0) {
      options.read_raw_js_snippet_ = true;
    } else if (strcmp(argv[i], "--stdin") == 0) {
      options.read_from_stdin_ = true;
    } else if (strcmp(argv[i], "--rebaseline") == 0) {
      options.rebaseline_ = true;
    } else if (strcmp(argv[i], "--check-baseline") == 0) {
      options.check_baseline_ = true;
    } else if (strcmp(argv[i], "--no-wrap") == 0) {
      options.wrap_ = false;
    } else if (strcmp(argv[i], "--module") == 0) {
      options.module_ = true;
    } else if (strcmp(argv[i], "--top-level") == 0) {
      options.top_level_ = true;
    } else if (strcmp(argv[i], "--print-callee") == 0) {
      options.print_callee_ = true;
    } else if (strcmp(argv[i], "--elide-redundant-tdz-checks") == 0) {
      options.elide_redundant_tdz_checks_ = true;
    } else if (strcmp(argv[i], "--verbose") == 0) {
      options.verbose_ = true;
    } else if (strncmp(argv[i], "--output=", 9) == 0) {
      options.output_filename_ = argv[i] + 9;
    } else if (strncmp(argv[i], "--test-function-name=", 21) == 0) {
      options.test_function_name_ = argv[i] + 21;
    } else if (strncmp(argv[i], "--", 2) != 0) {  // It doesn't start with --
      options.input_filenames_.push_back(argv[i]);
    } else {
      REPORT_ERROR("Unknown option " << argv[i]);
      options.parsing_failed_ = true;
      break;
    }
  }

  if (options.rebaseline() && options.check_baseline()) {
    REPORT_ERROR("Can't check baseline and rebaseline at the same time.");
    std::exit(1);
  }

  if ((options.check_baseline_ || options.rebaseline_) &&
      options.input_filenames_.empty()) {
#if defined(V8_OS_POSIX) || defined(V8_OS_WIN)
    if (options.verbose_) {
      std::cout << "Looking for golden files in " << kGoldenFilesPath << '\n';
    }
    if (!CollectGoldenFiles(&options.input_filenames_, kGoldenFilesPath)) {
      REPORT_ERROR("Golden files autodiscovery failed.");
      options.parsing_failed_ = true;
    }
#else
    REPORT_ERROR(
        "Golden files autodiscovery requires a POSIX or Window OS, sorry.");
    options.parsing_failed_ = true;
#endif
  }

  return options;
}

bool ProgramOptions::Validate() const {
  if (parsing_failed_) return false;
  if (print_help_) return true;

  if (!read_from_stdin_ && input_filenames_.empty()) {
    REPORT_ERROR("No input file specified.");
    return false;
  }

  if (read_from_stdin_ && !input_filenames_.empty()) {
    REPORT_ERROR("Reading from stdin, but input files supplied.");
    return false;
  }

  if (baseline() && read_raw_js_snippet_) {
    REPORT_ERROR(
        "Cannot use --rebaseline or --check-baseline on a raw JS snippet.");
    return false;
  }

  if (baseline() && !output_filename_.empty()) {
    REPORT_ERROR(
        "Output file cannot be specified together with --rebaseline or "
        "--check-baseline.");
    return false;
  }

  if (baseline() && read_from_stdin_) {
    REPORT_ERROR(
        "Cannot --rebaseline or --check-baseline when input is --stdin.");
    return false;
  }

  if (input_filenames_.size() > 1 && !baseline() && !read_raw_js_snippet()) {
    REPORT_ERROR(
        "Multiple input files, but no --rebaseline, --check-baseline or "
        "--raw-js specified.");
    return false;
  }

  if (top_level_ && !test_function_name_.empty()) {
    REPORT_ERROR(
        "Test function name specified while processing top level code.");
    return false;
  }

  if (module_ && (!top_level_ || wrap_)) {
    REPORT_ERROR(
        "The flag --module currently requires --top-level and --no-wrap.");
    return false;
  }

  return true;
}

void ProgramOptions::UpdateFromHeader(std::istream* stream) {
  std::string line;
  const char* kPrintCallee = "print callee: ";

  // Skip to the beginning of the options header
  while (std::getline(*stream, line)) {
    if (line == "---") break;
  }

  while (std::getline(*stream, line)) {
    if (line.compare(0, 8, "module: ") == 0) {
      module_ = ParseBoolean(line.c_str() + 8);
    } else if (line.compare(0, 6, "wrap: ") == 0) {
      wrap_ = ParseBoolean(line.c_str() + 6);
    } else if (line.compare(0, 20, "test function name: ") == 0) {
      test_function_name_ = line.c_str() + 20;
    } else if (line.compare(0, 11, "top level: ") == 0) {
      top_level_ = ParseBoolean(line.c_str() + 11);
    } else if (line.compare(0, strlen(kPrintCallee), kPrintCallee) == 0) {
      print_callee_ = ParseBoolean(line.c_str() + strlen(kPrintCallee));
    } else if (line.compare(0, 28, "elide redundant tdz checks: ") == 0) {
      elide_redundant_tdz_checks_ = ParseBoolean(line.c_str() + 28);
    } else if (line == "---") {
      break;
    } else if (line.empty()) {
      continue;
    } else {
      UNREACHABLE();
    }
  }
}

void ProgramOptions::PrintHeader(std::ostream* stream) const {
  *stream << "---"
          << "\nwrap: " << BooleanToString(wrap_);

  if (!test_function_name_.empty()) {
    *stream << "\ntest function name: " << test_function_name_;
  }

  if (module_) *stream << "\nmodule: yes";
  if (top_level_) *stream << "\ntop level: yes";
  if (print_callee_) *stream << "\nprint callee: yes";
  if (elide_redundant_tdz_checks_) {
    *stream << "\nelide redundant tdz checks: yes";
  }

  *stream << "\n\n";
}

V8InitializationScope::V8InitializationScope(const char* exec_path)
    : platform_(v8::platform::NewDefaultPlatform()) {
  i::v8_flags.always_turbofan = false;
  i::v8_flags.allow_natives_syntax = true;
  i::v8_flags.enable_lazy_source_positions = false;

  // The bytecode expectations printer changes flags; this is not security
  // relevant, allow this.
  i::v8_flags.freeze_flags_after_init = false;

  v8::V8::InitializeICUDefaultLocation(exec_path);
  v8::V8::InitializeExternalStartupData(exec_path);
  v8::V8::InitializePlatform(platform_.get());
  v8::V8::Initialize();

  v8::Isolate::CreateParams create_params;
  allocator_.reset(v8::ArrayBuffer::Allocator::NewDefaultAllocator());
  create_params.array_buffer_allocator = allocator_.get();

  isolate_ = v8::Isolate::New(create_params);
}

V8InitializationScope::~V8InitializationScope() {
  isolate_->Dispose();
  v8::V8::Dispose();
  v8::V8::DisposePlatform();
}

std::string ReadRawJSSnippet(std::istream* stream) {
  std::stringstream body_buffer;
  CHECK(body_buffer << stream->rdbuf());
  return body_buffer.str();
}

bool ReadNextSnippet(std::istream* stream, std::string* string_out) {
  std::string line;
  bool found_begin_snippet = false;
  string_out->clear();
  while (std::getline(*stream, line)) {
    if (line == "snippet: \"") {
      found_begin_snippet = true;
      continue;
    }
    if (!found_begin_snippet) continue;
    if (line == "\"") return true;
    if (line.size() == 0) {
      string_out->append("\n");  // consume empty line
      continue;
    }
    CHECK_GE(line.size(), 2u);  // We should have the indent
    string_out->append(line.begin() + 2, line.end());
    *string_out += '\n';
  }
  return false;
}

std::string UnescapeString(const std::string& escaped_string) {
  std::string unescaped_string;
  bool previous_was_backslash = false;
  for (char c : escaped_string) {
    if (previous_was_backslash) {
      // If it was not an escape sequence, emit the previous backslash
      if (c != '\\' && c != '"') unescaped_string += '\\';
      unescaped_string += c;
      previous_was_backslash = false;
    } else {
      if (c == '\\') {
        previous_was_backslash = true;
        // Defer emission to the point where we can check if it was an escape.
      } else {
        unescaped_string += c;
      }
    }
  }
  return unescaped_string;
}

void ExtractSnippets(std::vector<std::string>* snippet_list,
                     std::istream* body_stream, bool read_raw_js_snippet) {
  if (read_raw_js_snippet) {
    snippet_list->push_back(ReadRawJSSnippet(body_stream));
  } else {
    std::string snippet;
    while (ReadNextSnippet(body_stream, &snippet)) {
      snippet_list->push_back(UnescapeString(snippet));
    }
  }
}

void GenerateExpectationsFile(std::ostream* stream,
                              const std::vector<std::string>& snippet_list,
                              const V8InitializationScope& platform,
                              const ProgramOptions& options) {
  v8::Isolate::Scope isolate_scope(platform.isolate());
  v8::HandleScope handle_scope(platform.isolate());
  v8::Local<v8::Context> context = v8::Context::New(platform.isolate());
  v8::Context::Scope context_scope(context);

  BytecodeExpectationsPrinter printer(platform.isolate());
  printer.set_wrap(options.wrap());
  printer.set_module(options.module());
  printer.set_top_level(options.top_level());
  printer.set_print_callee(options.print_callee());
  if (!options.test_function_name().empty()) {
    printer.set_test_function_name(options.test_function_name());
  }
  bool old_elide_redundant_tdz_checks =
      i::v8_flags.ignition_elide_redundant_tdz_checks;
  if (options.elide_redundant_tdz_checks()) {
    i::v8_flags.ignition_elide_redundant_tdz_checks = true;
  }

  *stream << "#\n# Autogenerated by generate-bytecode-expectations.\n#\n\n";
  options.PrintHeader(stream);
  for (const std::string& snippet : snippet_list) {
    printer.PrintExpectation(stream, snippet);
  }

  i::v8_flags.ignition_elide_redundant_tdz_checks =
      old_elide_redundant_tdz_checks;
}

bool WriteExpectationsFile(const std::vector<std::string>& snippet_list,
                           const V8InitializationScope& platform,
                           const ProgramOptions& options,
                           const std::string& output_filename) {
  std::ofstream output_file_handle;
  if (!options.write_to_stdout()) {
    output_file_handle.open(output_filename.c_str(), std::ios::binary);
    if (!output_file_handle.is_open()) {
      REPORT_ERROR("Could not open " << output_filename << " for writing.");
      return false;
    }
  }
  std::ostream& output_stream =
      options.write_to_stdout() ? std::cout : output_file_handle;

  GenerateExpectationsFile(&output_stream, snippet_list, platform, options);

  return true;
}

std::string WriteExpectationsToString(
    const std::vector<std::string>& snippet_list,
    const V8InitializationScope& platform, const ProgramOptions& options) {
  std::stringstream output_string;

  GenerateExpectationsFile(&output_string, snippet_list, platform, options);

  return output_string.str();
}

void PrintMessage(v8::Local<v8::Message> message, v8::Local<v8::Value>) {
  std::cerr << "INFO: "
            << *v8::String::Utf8Value(message->GetIsolate(), message->Get())
            << '\n';
}

void DiscardMessage(v8::Local<v8::Message>, v8::Local<v8::Value>) {}

void PrintUsage(const char* exec_path) {
  std::cerr
      << "\nUsage: " << exec_path
      << " [OPTIONS]... [INPUT FILES]...\n\n"
         "Options:\n"
         "  --help        Print this help message.\n"
         "  --verbose     Emit messages about the progress of the tool.\n"
         "  --raw-js      Read raw JavaScript, instead of the output format.\n"
         "  --stdin       Read from standard input instead of file.\n"
         "  --rebaseline  Rebaseline input snippet file.\n"
         "  --check-baseline   Checks the current baseline is valid.\n"
         "  --no-wrap     Do not wrap the snippet in a function.\n"
         "  --print-callee     Print bytecode of callee, function should "
         "return arguments.callee.\n"
         "  --module      Compile as JavaScript module.\n"
         "  --test-function-name=foo  "
         "Specify the name of the test function.\n"
         "  --top-level   Process top level code, not the top-level function.\n"
         "  --output=file.name\n"
         "      Specify the output file. If not specified, output goes to "
         "stdout.\n"
         "  --pool-type=(number|string|mixed)\n"
         "      Specify the type of the entries in the constant pool "
         "(default: mixed).\n"
         "\n"
         "When using --rebaseline or --check-baseline, flags --no-wrap,\n"
         "--test-function-name and --pool-type will be overridden by the\n"
         "options specified in the input file header.\n\n"
         "Each raw JavaScript file is interpreted as a single snippet.\n\n"
         "This tool is intended as a help in writing tests.\n"
         "Please, DO NOT blindly copy and paste the output "
         "into the test suite.\n";
}

}  // namespace

bool CheckBaselineExpectations(const std::string& input_filename,
                               const std::vector<std::string>& snippet_list,
                               const V8InitializationScope& platform,
                               const ProgramOptions& options) {
  std::string actual =
      WriteExpectationsToString(snippet_list, platform, options);

  std::ifstream input_stream(input_filename);
  if (!input_stream.is_open()) {
    REPORT_ERROR("Could not open " << input_filename << " for reading.");
    std::exit(2);
  }

  bool check_failed = false;
  std::string expected((std::istreambuf_iterator<char>(input_stream)),
                       std::istreambuf_iterator<char>());
  if (expected != actual) {
    REPORT_ERROR("Mismatch: " << input_filename);
    check_failed = true;
    if (expected.size() != actual.size()) {
      REPORT_ERROR("  Expected size (" << expected.size()
                                       << ") != actual size (" << actual.size()
                                       << ")");
    }

    int line = 1;
    for (size_t i = 0; i < std::min(expected.size(), actual.size()); ++i) {
      if (expected[i] != actual[i]) {
        // Find the start of the line that has the mismatch carefully
        // handling the case where it's the first line that mismatches.
        size_t start = expected[i] != '\n' ? expected.rfind("\n", i)
                                           : actual.rfind("\n", i);
        if (start == std::string::npos) {
          start = 0;
        } else {
          ++start;
        }

        // If there is no new line, then these two lines will consume the
        // remaining characters in the string, because npos - start will
        // always be longer than the string itself.
        std::string expected_line =
            expected.substr(start, expected.find("\n", i) - start);
        std::string actual_line =
            actual.substr(start, actual.find("\n", i) - start);
        REPORT_ERROR("  First mismatch on line " << line << ")");
        REPORT_ERROR("    Expected : '" << expected_line << "'");
        REPORT_ERROR("    Actual   : '" << actual_line << "'");
        break;
      }
      if (expected[i] == '\n') line++;
    }
  }
  return check_failed;
}

int main(int argc, char** argv) {
  ProgramOptions options = ProgramOptions::FromCommandLine(argc, argv);

  if (!options.Validate() || options.print_help()) {
    PrintUsage(argv[0]);
    return options.print_help() ? 0 : 1;
  }

  V8InitializationScope platform(argv[0]);
  {
    v8::Isolate::Scope isolate_scope(platform.isolate());
    platform.isolate()->AddMessageListener(
        options.suppress_runtime_errors() ? DiscardMessage : PrintMessage);
  }

  std::vector<std::string> snippet_list;

  if (options.read_from_stdin()) {
    // Rebaseline will never get here, so we will always take the
    // GenerateExpectationsFile at the end of this function.
    DCHECK(!options.rebaseline() && !options.check_baseline());
    ExtractSnippets(&snippet_list, &std::cin, options.read_raw_js_snippet());
  } else {
    bool check_failed = false;
    for (const std::string& input_filename : options.input_filenames()) {
      if (options.verbose()) {
        std::cerr << "Processing " << input_filename << '\n';
      }

      std::ifstream input_stream(input_filename.c_str());
      if (!input_stream.is_open()) {
        REPORT_ERROR("Could not open " << input_filename << " for reading.");
        return 2;
      }

      ProgramOptions updated_options = options;
      if (options.baseline()) {
        updated_options.UpdateFromHeader(&input_stream);
        CHECK(updated_options.Validate());
      }

      ExtractSnippets(&snippet_list, &input_stream,
                      options.read_raw_js_snippet());
      input_stream.close();

      if (options.rebaseline()) {
        if (!WriteExpectationsFile(snippet_list, platform, updated_options,
                                   input_filename)) {
          return 3;
        }
      } else if (options.check_baseline()) {
        check_failed |= CheckBaselineExpectations(input_filename, snippet_list,
                                                  platform, updated_options);
      }

      if (options.baseline()) {
        snippet_list.clear();
      }
    }
    if (check_failed) {
      return 4;
    }
  }

  if (!options.baseline()) {
    if (!WriteExpectationsFile(snippet_list, platform, options,
                               options.output_filename())) {
      return 3;
    }
  }
}
```
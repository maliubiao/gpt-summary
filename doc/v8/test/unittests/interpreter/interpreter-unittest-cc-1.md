Response:
The user wants a summary of the functionalities of the provided C++ code snippet. This snippet is part of the V8 JavaScript engine's unit tests, specifically for the interpreter.

Here's a breakdown of how to analyze the code:

1. **Identify the core testing target:** The code uses `TEST_F(InterpreterTest, ...)` which indicates that it's testing the `InterpreterTest` fixture. The names of the individual test cases (e.g., `InterpreterBinaryOpFeedback`, `InterpreterUnaryOpFeedback`, `InterpreterLoadGlobal`) strongly suggest the aspects of the interpreter being tested.

2. **Analyze each test case:**  Each `TEST_F` block focuses on a specific interpreter feature or bytecode instruction. Look for patterns like:
    - Setting up a `FeedbackVectorSpec` and `FeedbackSlot` – indicates testing of feedback mechanisms for optimization.
    - Using `BytecodeArrayBuilder` – signifies the creation of bytecode sequences.
    - Invoking `UnaryOperation`, `BinaryOperation`, `LoadNamedProperty`, `CallProperty`, `Jump`, etc. – reveals the bytecode instructions being tested.
    - Using `InterpreterTester` to execute the generated bytecode.
    - Assertions using `CHECK_EQ` to verify expected outcomes.

3. **Infer functionality from test case names and actions:**
    - `InterpreterBinaryOpFeedback`: Tests how the interpreter handles feedback for binary operations (like +, -, *, etc.).
    - `InterpreterUnaryOpFeedback`: Tests feedback for unary operations (!, -, +, ++, --).
    - `InterpreterBitwiseTypeFeedback`: Tests feedback for bitwise operations (&, |, ^, <<, >>, >>>).
    - `InterpreterParameter1Assign`: Checks assignment to function parameters.
    - `InterpreterLoadGlobal`, `InterpreterStoreGlobal`: Tests loading and storing global variables.
    - `InterpreterCallGlobal`: Tests calling global functions.
    - `InterpreterLoadUnallocated`, `InterpreterStoreUnallocated`: Tests accessing variables that haven't been explicitly declared.
    - `InterpreterLoadNamedProperty`, `InterpreterLoadKeyedProperty`: Tests loading object properties using names and keys.
    - `InterpreterSetNamedProperty`, `InterpreterSetKeyedProperty`: Tests setting object properties.
    - `InterpreterCall`: Tests function calls with different numbers of arguments and receivers.
    - `InterpreterJumps`: Tests unconditional jumps in the bytecode.
    - `InterpreterConditionalJumps`, `InterpreterConditionalJumps2`: Tests conditional jumps based on boolean values.
    - `InterpreterJumpConstantWith16BitOperand`, `InterpreterJumpWith32BitOperand`: Tests jumps with large offsets, ensuring correct handling of different operand sizes.

4. **Look for Javascript equivalents:** When the functionality relates to common Javascript operations (like arithmetic, property access, function calls), provide simple Javascript examples.

5. **Identify potential programming errors:**  Think about common mistakes developers make that these tests might be implicitly covering (e.g., type errors in operations, accessing non-existent properties).

6. **Consider Torque:** The prompt mentions `.tq` files. While this specific snippet is C++, remember to mention that if the filename ended in `.tq`, it would be a Torque file (V8's internal language).

7. **Synthesize the summary:** Combine the findings from each test case into a concise overview of the file's purpose.
Based on the provided C++ code snippet from `v8/test/unittests/interpreter/interpreter-unittest.cc`, here's a summary of its functionalities, keeping in mind it's the second part of a seven-part series:

**Functionalities Demonstrated in this Snippet:**

This section of the `interpreter-unittest.cc` file primarily focuses on testing the **feedback mechanism** and **bytecode execution** of the V8 interpreter for various operations and scenarios. It verifies that the interpreter correctly records and utilizes feedback to optimize future executions. Specifically, it covers:

* **Feedback for Binary Operations:** Tests how the interpreter records feedback (like the types of operands involved) for binary operations (e.g., +, -, bitwise operators). This feedback helps the interpreter make optimizations in subsequent executions of the same code.
* **Feedback for Unary Operations:** Similar to binary operations, it tests the feedback mechanism for unary operations (e.g., negation, increment, decrement).
* **Feedback for Bitwise Operations:** Specifically tests the feedback collected for bitwise operations, ensuring the interpreter can track if operands are Smis (small integers), Numbers, or require more generic handling.
* **Parameter Assignment:** Tests that assigning a value to a function parameter within the function body works as expected and doesn't unexpectedly affect the original passed argument.
* **Global Variable Access (Load and Store):**  Verifies the interpreter's ability to load and store values to global variables declared using `var`.
* **Global Function Calls:** Tests the interpreter's ability to call functions defined in the global scope.
* **Unallocated Variable Access (Load and Store):** Checks how the interpreter handles accessing and assigning to variables that haven't been explicitly declared with `var` (implicitly becoming global).
* **Named Property Access (Load and Store):** Tests the mechanism for accessing and setting properties of objects using their names. It also demonstrates the interpreter's Inline Cache (IC) mechanism, showing transitions from miss to monomorphic, polymorphic, and megamorphic states based on the diversity of object shapes encountered.
* **Keyed Property Access (Load and Store):**  Similar to named property access, but for accessing and setting properties using computed keys (e.g., object[key]). It also demonstrates IC transitions.
* **Function Calls (with Receiver):**  Tests calling methods on objects, ensuring the `this` keyword is correctly bound (the receiver is passed correctly). It covers various numbers of arguments.
* **Unconditional Jumps:** Verifies the functionality of unconditional jump instructions in the bytecode.
* **Conditional Jumps:** Tests conditional jump instructions based on boolean values (true or false).
* **Jumps with Large Offsets:** Includes tests for jump instructions that need to jump over a significant amount of code, ensuring different operand sizes for jump targets are handled correctly (16-bit and potentially 32-bit offsets).

**If `v8/test/unittests/interpreter/interpreter-unittest.cc` ended with `.tq`:**

It would be a V8 Torque source code file. Torque is a domain-specific language used within V8 for implementing built-in functions and some runtime components in a more type-safe and efficient manner than raw C++.

**Relationship with Javascript and Examples:**

Many of the functionalities tested are directly related to common Javascript features:

* **Binary/Unary Operations:**
  ```javascript
  let a = 5;
  let b = 10;
  let sum = a + b; // Binary operation
  let negativeA = -a; // Unary operation
  ```

* **Global Variables:**
  ```javascript
  var globalVar = 100;

  function myFunction() {
    console.log(globalVar);
    globalVar = 200;
  }
  ```

* **Global Functions:**
  ```javascript
  function add(x, y) {
    return x + y;
  }

  let result = add(5, 3);
  ```

* **Unallocated Variables:**
  ```javascript
  unallocatedVar = 50; // Implicitly becomes a global variable

  function accessUnallocated() {
    console.log(unallocatedVar);
  }
  ```

* **Named Property Access:**
  ```javascript
  const myObject = { name: "example", value: 42 };
  console.log(myObject.name); // Loading named property
  myObject.name = "updated"; // Setting named property
  ```

* **Keyed Property Access:**
  ```javascript
  const myObject = { "key-1": 10, "key-2": 20 };
  const keyName = "key-1";
  console.log(myObject[keyName]); // Loading keyed property
  myObject["key-2"] = 30; // Setting keyed property
  ```

* **Function Calls (with Receiver):**
  ```javascript
  const myObject = {
    value: 5,
    getValue: function() {
      return this.value; // 'this' refers to myObject
    }
  };
  console.log(myObject.getValue());
  ```

* **Control Flow (Jumps):** While Javascript doesn't have explicit "jump" statements like assembly, its control flow structures (like `if`, `else`, `for`, `while`) are implemented using jump instructions in the underlying bytecode.

**Code Logic Inference (with Hypothetical Input and Output):**

Consider the `InterpreterBinaryOpFeedback` test case with the `Token::kAdd` operation:

**Hypothetical Input:** Two Small Integers (Smis) as operands.

**Expected Output:** The feedback slot associated with the addition operation should be updated to indicate that it encountered `kSignedSmall` operands. The result of the addition should be the correct sum of the two integers.

**User Common Programming Errors:**

* **Type Errors in Operations:** Performing operations on incompatible types (e.g., adding a number to an object without a defined `valueOf` or `toString` method). The feedback mechanism helps optimize for common type combinations but might lead to deoptimization if unexpected types are encountered frequently.

  ```javascript
  let x = 5;
  let y = { value: 10 };
  let result = x + y; // Potential TypeError or unexpected string concatenation
  ```

* **Accessing Non-Existent Properties:** Trying to read a property that doesn't exist on an object. The IC mechanism tracks the shapes of objects, and accessing missing properties can lead to cache misses and slower execution.

  ```javascript
  const obj = { name: "test" };
  console.log(obj.age); // Accessing a non-existent property
  ```

* **Incorrect `this` Binding:** In function calls, especially within object methods, misunderstanding how `this` is bound can lead to unexpected behavior. The tests for `InterpreterCall` with a receiver directly address this.

  ```javascript
  const myObj = {
    value: 10,
    getValueLater: function() {
      setTimeout(function() {
        console.log(this.value); // 'this' might not refer to myObj here
      }, 100);
    }
  };
  myObj.getValueLater();
  ```

**Summary of Functionality (Part 2):**

This second part of the `interpreter-unittest.cc` file heavily focuses on verifying the **correctness of the V8 interpreter's bytecode execution and its feedback collection mechanism**. It tests various bytecode instructions related to arithmetic operations, property access (both named and keyed), function calls, and control flow (jumps). The tests ensure that the interpreter accurately records information about the types and shapes of objects it encounters, which is crucial for the Just-In-Time (JIT) compiler to perform optimizations later. It also covers basic functionality like global variable access and parameter handling.

Prompt: 
```
这是目录为v8/test/unittests/interpreter/interpreter-unittest.cc的一个v8源代码， 请列举一下它的功能, 
如果v8/test/unittests/interpreter/interpreter-unittest.cc以.tq结尾，那它是个v8 torque源代码，
如果它与javascript的功能有关系，请用javascript举例说明,
如果有代码逻辑推理，请给出假设输入与输出，
如果涉及用户常见的编程错误，请举例说明
这是第2部分，共7部分，请归纳一下它的功能

"""
, metadata);
    auto callable = tester.GetCallable<>();

    Handle<Object> return_val = callable().ToHandleChecked();
    Tagged<MaybeObject> feedback0 = callable.vector()->Get(slot0);
    CHECK(IsSmi(feedback0));
    CHECK_EQ(test_case.feedback, feedback0.ToSmi().value());
    CHECK(
        Object::Equals(i_isolate(), test_case.result, return_val).ToChecked());
  }
}

TEST_F(InterpreterTest, InterpreterUnaryOpFeedback) {
  Handle<Smi> smi_one = Handle<Smi>(Smi::FromInt(1), i_isolate());
  Handle<Smi> smi_max = Handle<Smi>(Smi::FromInt(Smi::kMaxValue), i_isolate());
  Handle<Smi> smi_min = Handle<Smi>(Smi::FromInt(Smi::kMinValue), i_isolate());
  Handle<HeapNumber> number = i_isolate()->factory()->NewHeapNumber(2.1);
  Handle<BigInt> bigint =
      BigInt::FromNumber(i_isolate(), smi_max).ToHandleChecked();
  Handle<String> str = i_isolate()->factory()->NewStringFromAsciiChecked("42");

  struct TestCase {
    Token::Value op;
    Handle<Smi> smi_feedback_value;
    Handle<Smi> smi_to_number_feedback_value;
    Handle<HeapNumber> number_feedback_value;
    Handle<BigInt> bigint_feedback_value;
    Handle<Object> any_feedback_value;
  };
  TestCase const kTestCases[] = {
      // Testing ADD and BIT_NOT would require generalizing the test setup.
      {Token::kSub, smi_one, smi_min, number, bigint, str},
      {Token::kInc, smi_one, smi_max, number, bigint, str},
      {Token::kDec, smi_one, smi_min, number, bigint, str}};
  for (TestCase const& test_case : kTestCases) {
    i::FeedbackVectorSpec feedback_spec(zone());
    BytecodeArrayBuilder builder(zone(), 6, 0, &feedback_spec);

    i::FeedbackSlot slot0 = feedback_spec.AddBinaryOpICSlot();
    i::FeedbackSlot slot1 = feedback_spec.AddBinaryOpICSlot();
    i::FeedbackSlot slot2 = feedback_spec.AddBinaryOpICSlot();
    i::FeedbackSlot slot3 = feedback_spec.AddBinaryOpICSlot();
    i::FeedbackSlot slot4 = feedback_spec.AddBinaryOpICSlot();

    Handle<i::FeedbackMetadata> metadata =
        i::FeedbackMetadata::New(i_isolate(), &feedback_spec);

    builder.LoadAccumulatorWithRegister(builder.Parameter(0))
        .UnaryOperation(test_case.op, GetIndex(slot0))
        .LoadAccumulatorWithRegister(builder.Parameter(1))
        .UnaryOperation(test_case.op, GetIndex(slot1))
        .LoadAccumulatorWithRegister(builder.Parameter(2))
        .UnaryOperation(test_case.op, GetIndex(slot2))
        .LoadAccumulatorWithRegister(builder.Parameter(3))
        .UnaryOperation(test_case.op, GetIndex(slot3))
        .LoadAccumulatorWithRegister(builder.Parameter(4))
        .UnaryOperation(test_case.op, GetIndex(slot4))
        .Return();

    Handle<BytecodeArray> bytecode_array = builder.ToBytecodeArray(i_isolate());

    InterpreterTester tester(i_isolate(), bytecode_array, metadata);
    using H = Handle<Object>;
    auto callable = tester.GetCallable<H, H, H, H, H>();

    Handle<Object> return_val =
        callable(test_case.smi_feedback_value,
                 test_case.smi_to_number_feedback_value,
                 test_case.number_feedback_value,
                 test_case.bigint_feedback_value, test_case.any_feedback_value)
            .ToHandleChecked();
    USE(return_val);
    Tagged<MaybeObject> feedback0 = callable.vector()->Get(slot0);
    CHECK(IsSmi(feedback0));
    CHECK_EQ(BinaryOperationFeedback::kSignedSmall, feedback0.ToSmi().value());

    Tagged<MaybeObject> feedback1 = callable.vector()->Get(slot1);
    CHECK(IsSmi(feedback1));
    CHECK_EQ(BinaryOperationFeedback::kNumber, feedback1.ToSmi().value());

    Tagged<MaybeObject> feedback2 = callable.vector()->Get(slot2);
    CHECK(IsSmi(feedback2));
    CHECK_EQ(BinaryOperationFeedback::kNumber, feedback2.ToSmi().value());

    Tagged<MaybeObject> feedback3 = callable.vector()->Get(slot3);
    CHECK(IsSmi(feedback3));
    CHECK_EQ(BinaryOperationFeedback::kBigInt, feedback3.ToSmi().value());

    Tagged<MaybeObject> feedback4 = callable.vector()->Get(slot4);
    CHECK(IsSmi(feedback4));
    CHECK_EQ(BinaryOperationFeedback::kAny, feedback4.ToSmi().value());
  }
}

TEST_F(InterpreterTest, InterpreterBitwiseTypeFeedback) {
  const Token::Value kBitwiseBinaryOperators[] = {
      Token::kBitOr, Token::kBitXor, Token::kBitAnd,
      Token::kShl,   Token::kShr,    Token::kSar};

  for (Token::Value op : kBitwiseBinaryOperators) {
    i::FeedbackVectorSpec feedback_spec(zone());
    BytecodeArrayBuilder builder(zone(), 5, 0, &feedback_spec);

    i::FeedbackSlot slot0 = feedback_spec.AddBinaryOpICSlot();
    i::FeedbackSlot slot1 = feedback_spec.AddBinaryOpICSlot();
    i::FeedbackSlot slot2 = feedback_spec.AddBinaryOpICSlot();

    Handle<i::FeedbackMetadata> metadata =
        i::FeedbackMetadata::New(i_isolate(), &feedback_spec);

    builder.LoadAccumulatorWithRegister(builder.Parameter(0))
        .BinaryOperation(op, builder.Parameter(1), GetIndex(slot0))
        .BinaryOperation(op, builder.Parameter(2), GetIndex(slot1))
        .BinaryOperation(op, builder.Parameter(3), GetIndex(slot2))
        .Return();

    Handle<BytecodeArray> bytecode_array = builder.ToBytecodeArray(i_isolate());

    InterpreterTester tester(i_isolate(), bytecode_array, metadata);
    using H = Handle<Object>;
    auto callable = tester.GetCallable<H, H, H, H>();

    Handle<Smi> arg1 = Handle<Smi>(Smi::FromInt(2), i_isolate());
    Handle<Smi> arg2 = Handle<Smi>(Smi::FromInt(2), i_isolate());
    Handle<HeapNumber> arg3 = i_isolate()->factory()->NewHeapNumber(2.2);
    Handle<String> arg4 =
        i_isolate()->factory()->NewStringFromAsciiChecked("2");

    Handle<Object> return_val =
        callable(arg1, arg2, arg3, arg4).ToHandleChecked();
    USE(return_val);
    Tagged<MaybeObject> feedback0 = callable.vector()->Get(slot0);
    CHECK(IsSmi(feedback0));
    CHECK_EQ(BinaryOperationFeedback::kSignedSmall, feedback0.ToSmi().value());

    Tagged<MaybeObject> feedback1 = callable.vector()->Get(slot1);
    CHECK(IsSmi(feedback1));
    CHECK_EQ(BinaryOperationFeedback::kNumber, feedback1.ToSmi().value());

    Tagged<MaybeObject> feedback2 = callable.vector()->Get(slot2);
    CHECK(IsSmi(feedback2));
    CHECK_EQ(BinaryOperationFeedback::kAny, feedback2.ToSmi().value());
  }
}

TEST_F(InterpreterTest, InterpreterParameter1Assign) {
  BytecodeArrayBuilder builder(zone(), 1, 0);

  builder.LoadLiteral(Smi::FromInt(5))
      .StoreAccumulatorInRegister(builder.Receiver())
      .LoadAccumulatorWithRegister(builder.Receiver())
      .Return();
  Handle<BytecodeArray> bytecode_array = builder.ToBytecodeArray(i_isolate());

  InterpreterTester tester(i_isolate(), bytecode_array);
  auto callable = tester.GetCallableWithReceiver<>();

  DirectHandle<Object> return_val =
      callable(Handle<Smi>(Smi::FromInt(3), i_isolate())).ToHandleChecked();
  CHECK_EQ(Cast<Smi>(*return_val), Smi::FromInt(5));
}

TEST_F(InterpreterTest, InterpreterLoadGlobal) {
  // Test loading a global.
  std::string source(
      "var global = 321;\n"
      "function " +
      InterpreterTester::function_name() +
      "() {\n"
      "  return global;\n"
      "}");
  InterpreterTester tester(i_isolate(), source.c_str());
  auto callable = tester.GetCallable<>();

  DirectHandle<Object> return_val = callable().ToHandleChecked();
  CHECK_EQ(Cast<Smi>(*return_val), Smi::FromInt(321));
}

TEST_F(InterpreterTest, InterpreterStoreGlobal) {
  Factory* factory = i_isolate()->factory();

  // Test storing to a global.
  std::string source(
      "var global = 321;\n"
      "function " +
      InterpreterTester::function_name() +
      "() {\n"
      "  global = 999;\n"
      "}");
  InterpreterTester tester(i_isolate(), source.c_str());
  auto callable = tester.GetCallable<>();

  callable().ToHandleChecked();
  Handle<i::String> name = factory->InternalizeUtf8String("global");
  DirectHandle<i::Object> global_obj =
      Object::GetProperty(i_isolate(), i_isolate()->global_object(), name)
          .ToHandleChecked();
  CHECK_EQ(Cast<Smi>(*global_obj), Smi::FromInt(999));
}

TEST_F(InterpreterTest, InterpreterCallGlobal) {
  // Test calling a global function.
  std::string source(
      "function g_add(a, b) { return a + b; }\n"
      "function " +
      InterpreterTester::function_name() +
      "() {\n"
      "  return g_add(5, 10);\n"
      "}");
  InterpreterTester tester(i_isolate(), source.c_str());
  auto callable = tester.GetCallable<>();

  DirectHandle<Object> return_val = callable().ToHandleChecked();
  CHECK_EQ(Cast<Smi>(*return_val), Smi::FromInt(15));
}

TEST_F(InterpreterTest, InterpreterLoadUnallocated) {
  // Test loading an unallocated global.
  std::string source(
      "unallocated = 123;\n"
      "function " +
      InterpreterTester::function_name() +
      "() {\n"
      "  return unallocated;\n"
      "}");
  InterpreterTester tester(i_isolate(), source.c_str());
  auto callable = tester.GetCallable<>();

  DirectHandle<Object> return_val = callable().ToHandleChecked();
  CHECK_EQ(Cast<Smi>(*return_val), Smi::FromInt(123));
}

TEST_F(InterpreterTest, InterpreterStoreUnallocated) {
  Factory* factory = i_isolate()->factory();

  // Test storing to an unallocated global.
  std::string source(
      "unallocated = 321;\n"
      "function " +
      InterpreterTester::function_name() +
      "() {\n"
      "  unallocated = 999;\n"
      "}");
  InterpreterTester tester(i_isolate(), source.c_str());
  auto callable = tester.GetCallable<>();

  callable().ToHandleChecked();
  Handle<i::String> name = factory->InternalizeUtf8String("unallocated");
  DirectHandle<i::Object> global_obj =
      Object::GetProperty(i_isolate(), i_isolate()->global_object(), name)
          .ToHandleChecked();
  CHECK_EQ(Cast<Smi>(*global_obj), Smi::FromInt(999));
}

TEST_F(InterpreterTest, InterpreterLoadNamedProperty) {
  AstValueFactory ast_factory(zone(), i_isolate()->ast_string_constants(),
                              HashSeed(i_isolate()));

  FeedbackVectorSpec feedback_spec(zone());
  FeedbackSlot slot = feedback_spec.AddLoadICSlot();

  Handle<i::FeedbackMetadata> metadata =
      FeedbackMetadata::New(i_isolate(), &feedback_spec);

  const AstRawString* name = ast_factory.GetOneByteString("val");

  BytecodeArrayBuilder builder(zone(), 1, 0, &feedback_spec);

  builder.LoadNamedProperty(builder.Receiver(), name, GetIndex(slot)).Return();
  ast_factory.Internalize(i_isolate());
  Handle<BytecodeArray> bytecode_array = builder.ToBytecodeArray(i_isolate());

  InterpreterTester tester(i_isolate(), bytecode_array, metadata);
  auto callable = tester.GetCallableWithReceiver<>();

  Handle<JSAny> object = InterpreterTester::NewObject("({ val : 123 })");
  // Test IC miss.
  DirectHandle<Object> return_val = callable(object).ToHandleChecked();
  CHECK_EQ(Cast<Smi>(*return_val), Smi::FromInt(123));

  // Test transition to monomorphic IC.
  return_val = callable(object).ToHandleChecked();
  CHECK_EQ(Cast<Smi>(*return_val), Smi::FromInt(123));

  // Test transition to polymorphic IC.
  Handle<JSAny> object2 =
      InterpreterTester::NewObject("({ val : 456, other : 123 })");
  return_val = callable(object2).ToHandleChecked();
  CHECK_EQ(Cast<Smi>(*return_val), Smi::FromInt(456));

  // Test transition to megamorphic IC.
  Handle<JSAny> object3 =
      InterpreterTester::NewObject("({ val : 789, val2 : 123 })");
  callable(object3).ToHandleChecked();
  Handle<JSAny> object4 =
      InterpreterTester::NewObject("({ val : 789, val3 : 123 })");
  callable(object4).ToHandleChecked();
  Handle<JSAny> object5 =
      InterpreterTester::NewObject("({ val : 789, val4 : 123 })");
  return_val = callable(object5).ToHandleChecked();
  CHECK_EQ(Cast<Smi>(*return_val), Smi::FromInt(789));
}

TEST_F(InterpreterTest, InterpreterLoadKeyedProperty) {
  AstValueFactory ast_factory(zone(), i_isolate()->ast_string_constants(),
                              HashSeed(i_isolate()));

  FeedbackVectorSpec feedback_spec(zone());
  FeedbackSlot slot = feedback_spec.AddKeyedLoadICSlot();

  Handle<i::FeedbackMetadata> metadata =
      FeedbackMetadata::New(i_isolate(), &feedback_spec);

  const AstRawString* key = ast_factory.GetOneByteString("key");

  BytecodeArrayBuilder builder(zone(), 1, 1, &feedback_spec);

  builder.LoadLiteral(key)
      .LoadKeyedProperty(builder.Receiver(), GetIndex(slot))
      .Return();
  ast_factory.Internalize(i_isolate());
  Handle<BytecodeArray> bytecode_array = builder.ToBytecodeArray(i_isolate());

  InterpreterTester tester(i_isolate(), bytecode_array, metadata);
  auto callable = tester.GetCallableWithReceiver<>();

  Handle<JSAny> object = InterpreterTester::NewObject("({ key : 123 })");
  // Test IC miss.
  DirectHandle<Object> return_val = callable(object).ToHandleChecked();
  CHECK_EQ(Cast<Smi>(*return_val), Smi::FromInt(123));

  // Test transition to monomorphic IC.
  return_val = callable(object).ToHandleChecked();
  CHECK_EQ(Cast<Smi>(*return_val), Smi::FromInt(123));

  // Test transition to megamorphic IC.
  Handle<JSAny> object3 =
      InterpreterTester::NewObject("({ key : 789, val2 : 123 })");
  return_val = callable(object3).ToHandleChecked();
  CHECK_EQ(Cast<Smi>(*return_val), Smi::FromInt(789));
}

TEST_F(InterpreterTest, InterpreterSetNamedProperty) {
  AstValueFactory ast_factory(zone(), i_isolate()->ast_string_constants(),
                              HashSeed(i_isolate()));

  FeedbackVectorSpec feedback_spec(zone());
  FeedbackSlot slot = feedback_spec.AddStoreICSlot(LanguageMode::kStrict);

  Handle<i::FeedbackMetadata> metadata =
      FeedbackMetadata::New(i_isolate(), &feedback_spec);

  const AstRawString* name = ast_factory.GetOneByteString("val");

  BytecodeArrayBuilder builder(zone(), 1, 0, &feedback_spec);

  builder.LoadLiteral(Smi::FromInt(999))
      .SetNamedProperty(builder.Receiver(), name, GetIndex(slot),
                        LanguageMode::kStrict)
      .Return();
  ast_factory.Internalize(i_isolate());
  Handle<BytecodeArray> bytecode_array = builder.ToBytecodeArray(i_isolate());

  InterpreterTester tester(i_isolate(), bytecode_array, metadata);
  auto callable = tester.GetCallableWithReceiver<>();
  Handle<JSAny> object = InterpreterTester::NewObject("({ val : 123 })");
  // Test IC miss.
  Handle<Object> result;
  callable(object).ToHandleChecked();
  CHECK(Runtime::GetObjectProperty(i_isolate(), object, name->string())
            .ToHandle(&result));
  CHECK_EQ(Cast<Smi>(*result), Smi::FromInt(999));

  // Test transition to monomorphic IC.
  callable(object).ToHandleChecked();
  CHECK(Runtime::GetObjectProperty(i_isolate(), object, name->string())
            .ToHandle(&result));
  CHECK_EQ(Cast<Smi>(*result), Smi::FromInt(999));

  // Test transition to polymorphic IC.
  Handle<JSAny> object2 =
      InterpreterTester::NewObject("({ val : 456, other : 123 })");
  callable(object2).ToHandleChecked();
  CHECK(Runtime::GetObjectProperty(i_isolate(), object2, name->string())
            .ToHandle(&result));
  CHECK_EQ(Cast<Smi>(*result), Smi::FromInt(999));

  // Test transition to megamorphic IC.
  Handle<JSAny> object3 =
      InterpreterTester::NewObject("({ val : 789, val2 : 123 })");
  callable(object3).ToHandleChecked();
  Handle<JSAny> object4 =
      InterpreterTester::NewObject("({ val : 789, val3 : 123 })");
  callable(object4).ToHandleChecked();
  Handle<JSAny> object5 =
      InterpreterTester::NewObject("({ val : 789, val4 : 123 })");
  callable(object5).ToHandleChecked();
  CHECK(Runtime::GetObjectProperty(i_isolate(), object5, name->string())
            .ToHandle(&result));
  CHECK_EQ(Cast<Smi>(*result), Smi::FromInt(999));
}

TEST_F(InterpreterTest, InterpreterSetKeyedProperty) {
  AstValueFactory ast_factory(zone(), i_isolate()->ast_string_constants(),
                              HashSeed(i_isolate()));

  FeedbackVectorSpec feedback_spec(zone());
  FeedbackSlot slot = feedback_spec.AddKeyedStoreICSlot(LanguageMode::kSloppy);

  Handle<i::FeedbackMetadata> metadata =
      FeedbackMetadata::New(i_isolate(), &feedback_spec);

  const AstRawString* name = ast_factory.GetOneByteString("val");

  BytecodeArrayBuilder builder(zone(), 1, 1, &feedback_spec);

  builder.LoadLiteral(name)
      .StoreAccumulatorInRegister(Register(0))
      .LoadLiteral(Smi::FromInt(999))
      .SetKeyedProperty(builder.Receiver(), Register(0), GetIndex(slot),
                        i::LanguageMode::kSloppy)
      .Return();
  ast_factory.Internalize(i_isolate());
  Handle<BytecodeArray> bytecode_array = builder.ToBytecodeArray(i_isolate());

  InterpreterTester tester(i_isolate(), bytecode_array, metadata);
  auto callable = tester.GetCallableWithReceiver<>();
  Handle<JSAny> object = InterpreterTester::NewObject("({ val : 123 })");
  // Test IC miss.
  Handle<Object> result;
  callable(object).ToHandleChecked();
  CHECK(Runtime::GetObjectProperty(i_isolate(), object, name->string())
            .ToHandle(&result));
  CHECK_EQ(Cast<Smi>(*result), Smi::FromInt(999));

  // Test transition to monomorphic IC.
  callable(object).ToHandleChecked();
  CHECK(Runtime::GetObjectProperty(i_isolate(), object, name->string())
            .ToHandle(&result));
  CHECK_EQ(Cast<Smi>(*result), Smi::FromInt(999));

  // Test transition to megamorphic IC.
  Handle<JSAny> object2 =
      InterpreterTester::NewObject("({ val : 456, other : 123 })");
  callable(object2).ToHandleChecked();
  CHECK(Runtime::GetObjectProperty(i_isolate(), object2, name->string())
            .ToHandle(&result));
  CHECK_EQ(Cast<Smi>(*result), Smi::FromInt(999));
}

TEST_F(InterpreterTest, InterpreterCall) {
  Factory* factory = i_isolate()->factory();

  FeedbackVectorSpec feedback_spec(zone());
  FeedbackSlot slot = feedback_spec.AddLoadICSlot();
  FeedbackSlot call_slot = feedback_spec.AddCallICSlot();

  Handle<i::FeedbackMetadata> metadata =
      FeedbackMetadata::New(i_isolate(), &feedback_spec);
  int slot_index = GetIndex(slot);
  int call_slot_index = -1;
  call_slot_index = GetIndex(call_slot);

  // Check with no args.
  {
    AstValueFactory ast_factory(zone(), i_isolate()->ast_string_constants(),
                                HashSeed(i_isolate()));
    const AstRawString* name = ast_factory.GetOneByteString("func");

    BytecodeArrayBuilder builder(zone(), 1, 1, &feedback_spec);
    Register reg = builder.register_allocator()->NewRegister();
    RegisterList args = builder.register_allocator()->NewRegisterList(1);
    builder.LoadNamedProperty(builder.Receiver(), name, slot_index)
        .StoreAccumulatorInRegister(reg)
        .MoveRegister(builder.Receiver(), args[0]);

    builder.CallProperty(reg, args, call_slot_index);

    builder.Return();
    ast_factory.Internalize(i_isolate());
    Handle<BytecodeArray> bytecode_array = builder.ToBytecodeArray(i_isolate());

    InterpreterTester tester(i_isolate(), bytecode_array, metadata);
    auto callable = tester.GetCallableWithReceiver<>();

    Handle<JSAny> object = InterpreterTester::NewObject(
        "new (function Obj() { this.func = function() { return 0x265; }})()");
    DirectHandle<Object> return_val = callable(object).ToHandleChecked();
    CHECK_EQ(Cast<Smi>(*return_val), Smi::FromInt(0x265));
  }

  // Check that receiver is passed properly.
  {
    AstValueFactory ast_factory(zone(), i_isolate()->ast_string_constants(),
                                HashSeed(i_isolate()));
    const AstRawString* name = ast_factory.GetOneByteString("func");

    BytecodeArrayBuilder builder(zone(), 1, 1, &feedback_spec);
    Register reg = builder.register_allocator()->NewRegister();
    RegisterList args = builder.register_allocator()->NewRegisterList(1);
    builder.LoadNamedProperty(builder.Receiver(), name, slot_index)
        .StoreAccumulatorInRegister(reg)
        .MoveRegister(builder.Receiver(), args[0]);
    builder.CallProperty(reg, args, call_slot_index);
    builder.Return();
    ast_factory.Internalize(i_isolate());
    Handle<BytecodeArray> bytecode_array = builder.ToBytecodeArray(i_isolate());

    InterpreterTester tester(i_isolate(), bytecode_array, metadata);
    auto callable = tester.GetCallableWithReceiver<>();

    Handle<JSAny> object = InterpreterTester::NewObject(
        "new (function Obj() {"
        "  this.val = 1234;"
        "  this.func = function() { return this.val; };"
        "})()");
    DirectHandle<Object> return_val = callable(object).ToHandleChecked();
    CHECK_EQ(Cast<Smi>(*return_val), Smi::FromInt(1234));
  }

  // Check with two parameters (+ receiver).
  {
    AstValueFactory ast_factory(zone(), i_isolate()->ast_string_constants(),
                                HashSeed(i_isolate()));
    const AstRawString* name = ast_factory.GetOneByteString("func");

    BytecodeArrayBuilder builder(zone(), 1, 4, &feedback_spec);
    Register reg = builder.register_allocator()->NewRegister();
    RegisterList args = builder.register_allocator()->NewRegisterList(3);

    builder.LoadNamedProperty(builder.Receiver(), name, slot_index)
        .StoreAccumulatorInRegister(reg)
        .LoadAccumulatorWithRegister(builder.Receiver())
        .StoreAccumulatorInRegister(args[0])
        .LoadLiteral(Smi::FromInt(51))
        .StoreAccumulatorInRegister(args[1])
        .LoadLiteral(Smi::FromInt(11))
        .StoreAccumulatorInRegister(args[2]);

    builder.CallProperty(reg, args, call_slot_index);

    builder.Return();

    ast_factory.Internalize(i_isolate());
    Handle<BytecodeArray> bytecode_array = builder.ToBytecodeArray(i_isolate());

    InterpreterTester tester(i_isolate(), bytecode_array, metadata);
    auto callable = tester.GetCallableWithReceiver<>();

    Handle<JSAny> object = InterpreterTester::NewObject(
        "new (function Obj() { "
        "  this.func = function(a, b) { return a - b; }"
        "})()");
    DirectHandle<Object> return_val = callable(object).ToHandleChecked();
    CHECK(Object::SameValue(*return_val, Smi::FromInt(40)));
  }

  // Check with 10 parameters (+ receiver).
  {
    AstValueFactory ast_factory(zone(), i_isolate()->ast_string_constants(),
                                HashSeed(i_isolate()));
    const AstRawString* name = ast_factory.GetOneByteString("func");

    BytecodeArrayBuilder builder(zone(), 1, 12, &feedback_spec);
    Register reg = builder.register_allocator()->NewRegister();
    RegisterList args = builder.register_allocator()->NewRegisterList(11);

    builder.LoadNamedProperty(builder.Receiver(), name, slot_index)
        .StoreAccumulatorInRegister(reg)
        .LoadAccumulatorWithRegister(builder.Receiver())
        .StoreAccumulatorInRegister(args[0])
        .LoadLiteral(ast_factory.GetOneByteString("a"))
        .StoreAccumulatorInRegister(args[1])
        .LoadLiteral(ast_factory.GetOneByteString("b"))
        .StoreAccumulatorInRegister(args[2])
        .LoadLiteral(ast_factory.GetOneByteString("c"))
        .StoreAccumulatorInRegister(args[3])
        .LoadLiteral(ast_factory.GetOneByteString("d"))
        .StoreAccumulatorInRegister(args[4])
        .LoadLiteral(ast_factory.GetOneByteString("e"))
        .StoreAccumulatorInRegister(args[5])
        .LoadLiteral(ast_factory.GetOneByteString("f"))
        .StoreAccumulatorInRegister(args[6])
        .LoadLiteral(ast_factory.GetOneByteString("g"))
        .StoreAccumulatorInRegister(args[7])
        .LoadLiteral(ast_factory.GetOneByteString("h"))
        .StoreAccumulatorInRegister(args[8])
        .LoadLiteral(ast_factory.GetOneByteString("i"))
        .StoreAccumulatorInRegister(args[9])
        .LoadLiteral(ast_factory.GetOneByteString("j"))
        .StoreAccumulatorInRegister(args[10]);

    builder.CallProperty(reg, args, call_slot_index);

    builder.Return();

    ast_factory.Internalize(i_isolate());
    Handle<BytecodeArray> bytecode_array = builder.ToBytecodeArray(i_isolate());

    InterpreterTester tester(i_isolate(), bytecode_array, metadata);
    auto callable = tester.GetCallableWithReceiver<>();

    Handle<JSAny> object = InterpreterTester::NewObject(
        "new (function Obj() { "
        "  this.prefix = \"prefix_\";"
        "  this.func = function(a, b, c, d, e, f, g, h, i, j) {"
        "      return this.prefix + a + b + c + d + e + f + g + h + i + j;"
        "  }"
        "})()");
    DirectHandle<Object> return_val = callable(object).ToHandleChecked();
    DirectHandle<i::String> expected =
        factory->NewStringFromAsciiChecked("prefix_abcdefghij");
    CHECK(i::Cast<i::String>(*return_val)->Equals(*expected));
  }
}

static BytecodeArrayBuilder& SetRegister(BytecodeArrayBuilder* builder,
                                         Register reg, int value,
                                         Register scratch) {
  return builder->StoreAccumulatorInRegister(scratch)
      .LoadLiteral(Smi::FromInt(value))
      .StoreAccumulatorInRegister(reg)
      .LoadAccumulatorWithRegister(scratch);
}

static BytecodeArrayBuilder& IncrementRegister(BytecodeArrayBuilder* builder,
                                               Register reg, int value,
                                               Register scratch,
                                               int slot_index) {
  return builder->StoreAccumulatorInRegister(scratch)
      .LoadLiteral(Smi::FromInt(value))
      .BinaryOperation(Token::kAdd, reg, slot_index)
      .StoreAccumulatorInRegister(reg)
      .LoadAccumulatorWithRegister(scratch);
}

TEST_F(InterpreterTest, InterpreterJumps) {
  FeedbackVectorSpec feedback_spec(zone());
  BytecodeArrayBuilder builder(zone(), 1, 2, &feedback_spec);

  FeedbackSlot slot = feedback_spec.AddBinaryOpICSlot();
  FeedbackSlot slot1 = feedback_spec.AddBinaryOpICSlot();
  FeedbackSlot slot2 = feedback_spec.AddJumpLoopSlot();

  Handle<i::FeedbackMetadata> metadata =
      FeedbackMetadata::New(i_isolate(), &feedback_spec);

  Register reg(0), scratch(1);
  BytecodeLoopHeader loop_header;
  BytecodeLabel label[2];

  builder.LoadLiteral(Smi::zero())
      .StoreAccumulatorInRegister(reg)
      .Jump(&label[0]);
  SetRegister(&builder, reg, 1024, scratch).Bind(&label[0]).Bind(&loop_header);
  IncrementRegister(&builder, reg, 1, scratch, GetIndex(slot)).Jump(&label[1]);
  SetRegister(&builder, reg, 2048, scratch)
      .JumpLoop(&loop_header, 0, 0, slot2.ToInt());
  SetRegister(&builder, reg, 4096, scratch).Bind(&label[1]);
  IncrementRegister(&builder, reg, 2, scratch, GetIndex(slot1))
      .LoadAccumulatorWithRegister(reg)
      .Return();

  Handle<BytecodeArray> bytecode_array = builder.ToBytecodeArray(i_isolate());
  DirectHandle<Object> return_value = RunBytecode(bytecode_array, metadata);
  CHECK_EQ(Smi::ToInt(*return_value), 3);
}

TEST_F(InterpreterTest, InterpreterConditionalJumps) {
  FeedbackVectorSpec feedback_spec(zone());
  BytecodeArrayBuilder builder(zone(), 1, 2, &feedback_spec);

  FeedbackSlot slot = feedback_spec.AddBinaryOpICSlot();
  FeedbackSlot slot1 = feedback_spec.AddBinaryOpICSlot();
  FeedbackSlot slot2 = feedback_spec.AddBinaryOpICSlot();
  FeedbackSlot slot3 = feedback_spec.AddBinaryOpICSlot();
  FeedbackSlot slot4 = feedback_spec.AddBinaryOpICSlot();

  Handle<i::FeedbackMetadata> metadata =
      FeedbackMetadata::New(i_isolate(), &feedback_spec);

  Register reg(0), scratch(1);
  BytecodeLabel label[2];
  BytecodeLabel done, done1;

  builder.LoadLiteral(Smi::zero())
      .StoreAccumulatorInRegister(reg)
      .LoadFalse()
      .JumpIfFalse(ToBooleanMode::kAlreadyBoolean, &label[0]);
  IncrementRegister(&builder, reg, 1024, scratch, GetIndex(slot))
      .Bind(&label[0])
      .LoadTrue()
      .JumpIfFalse(ToBooleanMode::kAlreadyBoolean, &done);
  IncrementRegister(&builder, reg, 1, scratch, GetIndex(slot1))
      .LoadTrue()
      .JumpIfTrue(ToBooleanMode::kAlreadyBoolean, &label[1]);
  IncrementRegister(&builder, reg, 2048, scratch, GetIndex(slot2))
      .Bind(&label[1]);
  IncrementRegister(&builder, reg, 2, scratch, GetIndex(slot3))
      .LoadFalse()
      .JumpIfTrue(ToBooleanMode::kAlreadyBoolean, &done1);
  IncrementRegister(&builder, reg, 4, scratch, GetIndex(slot4))
      .LoadAccumulatorWithRegister(reg)
      .Bind(&done)
      .Bind(&done1)
      .Return();

  Handle<BytecodeArray> bytecode_array = builder.ToBytecodeArray(i_isolate());
  DirectHandle<Object> return_value = RunBytecode(bytecode_array, metadata);
  CHECK_EQ(Smi::ToInt(*return_value), 7);
}

TEST_F(InterpreterTest, InterpreterConditionalJumps2) {
  // TODO(oth): Add tests for all conditional jumps near and far.

  FeedbackVectorSpec feedback_spec(zone());
  BytecodeArrayBuilder builder(zone(), 1, 2, &feedback_spec);

  FeedbackSlot slot = feedback_spec.AddBinaryOpICSlot();
  FeedbackSlot slot1 = feedback_spec.AddBinaryOpICSlot();
  FeedbackSlot slot2 = feedback_spec.AddBinaryOpICSlot();
  FeedbackSlot slot3 = feedback_spec.AddBinaryOpICSlot();
  FeedbackSlot slot4 = feedback_spec.AddBinaryOpICSlot();

  Handle<i::FeedbackMetadata> metadata =
      FeedbackMetadata::New(i_isolate(), &feedback_spec);

  Register reg(0), scratch(1);
  BytecodeLabel label[2];
  BytecodeLabel done, done1;

  builder.LoadLiteral(Smi::zero())
      .StoreAccumulatorInRegister(reg)
      .LoadFalse()
      .JumpIfFalse(ToBooleanMode::kAlreadyBoolean, &label[0]);
  IncrementRegister(&builder, reg, 1024, scratch, GetIndex(slot))
      .Bind(&label[0])
      .LoadTrue()
      .JumpIfFalse(ToBooleanMode::kAlreadyBoolean, &done);
  IncrementRegister(&builder, reg, 1, scratch, GetIndex(slot1))
      .LoadTrue()
      .JumpIfTrue(ToBooleanMode::kAlreadyBoolean, &label[1]);
  IncrementRegister(&builder, reg, 2048, scratch, GetIndex(slot2))
      .Bind(&label[1]);
  IncrementRegister(&builder, reg, 2, scratch, GetIndex(slot3))
      .LoadFalse()
      .JumpIfTrue(ToBooleanMode::kAlreadyBoolean, &done1);
  IncrementRegister(&builder, reg, 4, scratch, GetIndex(slot4))
      .LoadAccumulatorWithRegister(reg)
      .Bind(&done)
      .Bind(&done1)
      .Return();

  Handle<BytecodeArray> bytecode_array = builder.ToBytecodeArray(i_isolate());
  DirectHandle<Object> return_value = RunBytecode(bytecode_array, metadata);
  CHECK_EQ(Smi::ToInt(*return_value), 7);
}

TEST_F(InterpreterTest, InterpreterJumpConstantWith16BitOperand) {
  AstValueFactory ast_factory(zone(), i_isolate()->ast_string_constants(),
                              HashSeed(i_isolate()));
  FeedbackVectorSpec feedback_spec(zone());
  BytecodeArrayBuilder builder(zone(), 1, 257, &feedback_spec);

  FeedbackSlot slot = feedback_spec.AddBinaryOpICSlot();
  Handle<i::FeedbackMetadata> metadata =
      FeedbackMetadata::New(i_isolate(), &feedback_spec);

  Register reg(0), scratch(256);
  BytecodeLabel done, fake;

  builder.LoadLiteral(Smi::zero());
  builder.StoreAccumulatorInRegister(reg);
  // Conditional jump to the fake label, to force both basic blocks to be live.
  builder.JumpIfTrue(ToBooleanMode::kConvertToBoolean, &fake);
  // Consume all 8-bit operands
  for (int i = 1; i <= 256; i++) {
    builder.LoadLiteral(i + 0.5);
    builder.BinaryOperation(Token::kAdd, reg, GetIndex(slot));
    builder.StoreAccumulatorInRegister(reg);
  }
  builder.Jump(&done);

  // Emit more than 16-bit immediate operands worth of code to jump over.
  builder.Bind(&fake);
  for (int i = 0; i < 6600; i++) {
    builder.LoadLiteral(Smi::zero());  // 1-byte
    builder.BinaryOperation(Token::kAdd, scratch,
                            GetIndex(slot));      // 6-bytes
    builder.StoreAccumulatorInRegister(scratch);  // 4-bytes
    builder.MoveRegister(scratch, reg);           // 6-bytes
  }
  builder.Bind(&done);
  builder.LoadAccumulatorWithRegister(reg);
  builder.Return();

  ast_factory.Internalize(i_isolate());
  Handle<BytecodeArray> bytecode_array = builder.ToBytecodeArray(i_isolate());
  {
    BytecodeArrayIterator iterator(bytecode_array);

    bool found_16bit_constant_jump = false;
    while (!iterator.done()) {
      if (iterator.current_bytecode() == Bytecode::kJumpConstant &&
          iterator.current_operand_scale() == OperandScale::kDouble) {
        found_16bit_constant_jump = true;
        break;
      }
      iterator.Advance();
    }
    CHECK(found_16bit_constant_jump);
  }

  Handle<Object> return_value = RunBytecode(bytecode_array, metadata);
  CHECK_EQ(Cast<HeapNumber>(return_value)->value(), 256.0 / 2 * (1.5 + 256.5));
}

TEST_F(InterpreterTest, InterpreterJumpWith32BitOperand) {
  AstValueFactory ast_factory(zone(), i_isolate()->ast_string_constants(),
                              HashSeed(i_isolate()));
  BytecodeArrayBuilder builder(zone(), 1, 1);
  Register reg(0);
  BytecodeLabel done;

  builder.LoadLiteral(Smi::zero());
  builder.StoreAccumulatorInRegister(reg);
  // Consume all 16-bit constant pool entries. Make sure to use doubles so that
  // the jump can't re-use an integer.
  for (int i = 1; i <= 65536; i++) {
    builder.LoadLiteral(i + 0.5);
  }
  builder.Jump(&done);
  
"""


```
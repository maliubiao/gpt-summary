Response: The user wants a summary of the C++ code provided, focusing on its functionality and relationship to Javascript. Since this is part 2 of 4, I should keep the previous parts in mind if they were provided (though they weren't in this prompt).

Here's a breakdown of the code:

1. **`TEST_F(InterpreterTest, ...)` blocks:** These are unit tests within the V8 JavaScript engine's testing framework. They are testing the functionality of the interpreter.

2. **Bytecode Generation:**  The tests frequently use `BytecodeArrayBuilder` to create sequences of bytecode instructions. This indicates the tests are directly interacting with V8's internal bytecode representation of JavaScript code.

3. **Running Bytecode:** The `RunBytecode` function is used to execute the generated bytecode.

4. **Comparisons:** Several tests focus on comparison operations (`==`, `===`, `<`, `>`, etc.) between different JavaScript data types (Smis, HeapNumbers, BigInts, Strings). They verify the interpreter's behavior for these comparisons.

5. **Typeof and Instanceof:** There are tests for the `typeof` and `instanceof` operators in JavaScript.

6. **`in` operator:**  A test covers the functionality of the `in` operator.

7. **Logical Not:** A test verifies the behavior of the logical NOT operator (`!`).

8. **Function Calls:** Some tests involve calling functions and function literals.

9. **Regular Expressions:**  Tests are included for regular expression literals and their execution.

10. **Array and Object Literals:** Tests are present for creating and accessing array and object literals.

11. **`new` operator:** The `new` operator and constructor functions are tested.

12. **Context Variables and Parameters:**  Tests verify the handling of variables and parameters within different execution contexts (closures).

13. **Comma Operator:** The comma operator's behavior is checked.

14. **Logical OR and AND:** Tests for the logical OR (`||`) and AND (`&&`) operators.

15. **Try...Catch and Try...Finally:**  Error handling mechanisms are tested.

16. **`throw` statement:** The `throw` statement's functionality is validated.

17. **Increment and Decrement Operators:**  Tests for prefix and postfix increment/decrement operators.

18. **Compound Assignment Operators:** Tests for operators like `+=`, `-=`, etc.

19. **`arguments` object:** Tests cover the creation and behavior of the `arguments` object within functions.

20. **Conditional Operator:**  The ternary conditional operator (`? :`) is tested.

21. **`delete` operator:** Tests for the `delete` operator.

22. **Loops:**  Basic loop constructs (`while`, `do...while`, `for`) are tested.

**Relationship to Javascript:**  The entire file is dedicated to testing the interpreter, which is the core component of V8 responsible for executing JavaScript code. Each test case directly corresponds to a specific JavaScript language feature or behavior.

**Plan for the summary:**

* State that this part of the file contains unit tests for the V8 JavaScript interpreter.
* Highlight the main categories of JavaScript features being tested in this section (comparisons, operators, literals, function calls, error handling, etc.).
* Provide Javascript examples to illustrate the functionality being tested in the C++ code.
这个C++源代码文件是V8 JavaScript引擎的一部分，专门用于测试**解释器（Interpreter）**的各种功能。具体来说，这部分代码侧重于测试以下JavaScript特性在解释器中的实现和行为：

**主要功能归纳：**

* **比较运算符（Comparison Operators）:**  测试各种数据类型（Smi, HeapNumber, BigInt, String）之间的比较操作，包括相等性判断（`==`, `===`）、不等性判断（`!=`, `!==`）、以及大小比较（`<`, `<=`, `>`, `>=`）。
* **`typeof` 运算符:** 测试 `typeof` 运算符对不同数据类型返回正确类型字符串的能力。
* **`instanceof` 运算符:**  测试 `instanceof` 运算符判断对象是否为特定构造函数实例的能力。
* **`in` 运算符:** 测试 `in` 运算符判断对象是否拥有指定属性的能力。
* **逻辑非运算符 (`!`)**: 测试逻辑非运算符对不同类型的值进行取反的效果。
* **函数调用 (Function Calls):** 测试调用普通函数和函数字面量的行为。
* **正则表达式字面量 (RegExp Literals):** 测试正则表达式字面量的创建和执行。
* **数组字面量 (Array Literals):** 测试数组字面量的创建和元素访问。
* **对象字面量 (Object Literals):** 测试对象字面量的创建、属性定义（包括方法、getter/setter）和访问。
* **`new` 运算符 (Construct):** 测试使用 `new` 运算符创建对象实例的行为。
* **作用域和上下文 (Context Variables and Parameters):** 测试在不同作用域（包括闭包）中访问和修改变量的能力。
* **逗号运算符 (Comma Operator):** 测试逗号运算符的求值顺序和结果。
* **逻辑或运算符 (`||`)**: 测试逻辑或运算符的短路求值行为。
* **逻辑与运算符 (`&&`)**: 测试逻辑与运算符的短路求值行为。
* **`try...catch` 语句:** 测试 `try...catch` 语句捕获和处理异常的能力。
* **`try...finally` 语句:** 测试 `try...finally` 语句确保 `finally` 代码块始终执行的能力。
* **`throw` 语句:** 测试 `throw` 语句抛出异常的能力。
* **自增自减运算符 (`++`, `--`)**: 测试前缀和后缀自增自减运算符的行为。
* **复合赋值运算符 (`+=`, `-=`, `*=`, `/=`)**: 测试复合赋值运算符的运算结果。
* **`arguments` 对象:** 测试函数内部 `arguments` 对象的创建和使用，包括在严格模式和非严格模式下的行为，以及剩余参数的情况。
* **条件运算符 (Conditional Operator, `? :`)**: 测试条件运算符根据条件选择不同表达式的能力。
* **`delete` 运算符:** 测试 `delete` 运算符删除对象属性的能力，包括全局对象属性和局部变量属性。
* **基本循环结构 (`while`, `do...while`, `for`):** 测试基本循环结构的执行流程。

**与 JavaScript 的关系及 JavaScript 示例：**

这个 C++ 文件中的每一个测试用例都直接对应着一个或多个 JavaScript 语言特性。它确保 V8 的解释器能够正确地执行这些特性并产生预期的结果。

以下是一些 JavaScript 示例，对应着 C++ 代码中测试的功能：

**1. 比较运算符 (`InterpreterSmiComparisons`, `InterpreterHeapNumberComparisons`, `InterpreterBigIntComparisons`, `InterpreterStringComparisons`)**

```javascript
console.log(10 == 10);   // true
console.log(10 === "10"); // false
console.log(5 < 10);    // true
console.log("apple" > "banana"); // false
```

**2. `typeof` 运算符 (`InterpreterCompareTypeOf`)**

```javascript
console.log(typeof undefined); // "undefined"
console.log(typeof null);      // "object"
console.log(typeof 123);       // "number"
console.log(typeof "hello");   // "string"
console.log(typeof {});        // "object"
console.log(typeof function(){}); // "function"
```

**3. `instanceof` 运算符 (`InterpreterInstanceOf`)**

```javascript
function MyClass() {}
const myInstance = new MyClass();
console.log(myInstance instanceof MyClass); // true
console.log(myInstance instanceof Object);  // true
```

**4. `in` 运算符 (`InterpreterTestIn`)**

```javascript
const myObject = { name: "John", age: 30 };
console.log("name" in myObject); // true
console.log("address" in myObject); // false

const myArray = ["apple", "banana"];
console.log(0 in myArray);    // true
console.log("length" in myArray); // true
```

**5. 逻辑非运算符 (`InterpreterUnaryNot`, `InterpreterUnaryNotNonBoolean`)**

```javascript
console.log(!true);      // false
console.log(!false);     // true
console.log(!0);         // true
console.log(!"hello");   // false
```

**6. 函数调用和函数字面量 (`InterpreterFunctionLiteral`)**

```javascript
function add(a, b) {
  return a + b;
}
console.log(add(5, 3)); // 8

const multiply = function(x, y) {
  return x * y;
};
console.log(multiply(4, 2)); // 8

function outerFunction(val) {
  return (function(x) { return x + 2; })(val);
}
console.log(outerFunction(3)); // 5
```

**7. 正则表达式字面量 (`InterpreterRegExpLiterals`)**

```javascript
const regex = /ab+c/i;
const str = "aBcdef";
console.log(regex.test(str)); // true
console.log(str.match(regex)[0]); // "aBc"
```

**8. 数组字面量 (`InterpreterArrayLiterals`)**

```javascript
const myArray = [1, 2, "three"];
console.log(myArray[0]); // 1
console.log(myArray[2]); // "three"
```

**9. 对象字面量 (`InterpreterObjectLiterals`)**

```javascript
const myObject = {
  name: "Example",
  value: 10,
  greet: function() {
    console.log("Hello!");
  },
  get doubleValue() {
    return this.value * 2;
  },
  set setValue(newValue) {
    this.value = newValue;
  }
};
console.log(myObject.name);       // "Example"
myObject.greet();               // "Hello!"
console.log(myObject.doubleValue); // 20
myObject.setValue = 25;
console.log(myObject.value);      // 25
```

**10. `new` 运算符 (`InterpreterConstruct`, `InterpreterConstructWithArgument`, `InterpreterConstructWithArguments`)**

```javascript
function Counter(start) {
  this.count = start || 0;
}
const counter1 = new Counter();
console.log(counter1.count); // 0

const counter2 = new Counter(5);
console.log(counter2.count); // 5
```

**11. 作用域和上下文 (`InterpreterContextVariables`, `InterpreterContextParameters`, `InterpreterOuterContextVariables`)**

```javascript
let globalVar = 10;

function outer() {
  let outerVar = 20;
  function inner(innerArg) {
    console.log(globalVar + outerVar + innerArg);
  }
  inner(30); // 输出 60
}
outer();
```

总而言之，这个 C++ 文件是 V8 引擎中非常重要的组成部分，它通过大量的单元测试来确保 JavaScript 代码能够被正确地解释和执行。每个测试用例都针对特定的 JavaScript 语法和语义，是 V8 引擎质量保证的关键环节。
Prompt: 
```
这是目录为v8/test/unittests/interpreter/interpreter-unittest.cc的一个c++源代码文件， 请归纳一下它的功能, 如果它与javascript的功能有关系，请用javascript举例说明
这是第2部分，共4部分，请归纳一下它的功能

"""
builder.LoadLiteral(Smi::zero());
  builder.Bind(&done);
  builder.Return();

  ast_factory.Internalize(i_isolate());
  Handle<BytecodeArray> bytecode_array = builder.ToBytecodeArray(i_isolate());
  {
    BytecodeArrayIterator iterator(bytecode_array);

    bool found_32bit_jump = false;
    while (!iterator.done()) {
      if (iterator.current_bytecode() == Bytecode::kJump &&
          iterator.current_operand_scale() == OperandScale::kQuadruple) {
        found_32bit_jump = true;
        break;
      }
      iterator.Advance();
    }
    CHECK(found_32bit_jump);
  }

  Handle<Object> return_value = RunBytecode(bytecode_array);
  CHECK_EQ(Cast<HeapNumber>(return_value)->value(), 65536.5);
}

static const Token::Value kComparisonTypes[] = {
    Token::kEq,         Token::kEqStrict,    Token::kLessThan,
    Token::kLessThanEq, Token::kGreaterThan, Token::kGreaterThanEq};

template <typename T>
bool CompareC(Token::Value op, T lhs, T rhs, bool types_differed = false) {
  switch (op) {
    case Token::kEq:
      return lhs == rhs;
    case Token::kNotEq:
      return lhs != rhs;
    case Token::kEqStrict:
      return (lhs == rhs) && !types_differed;
    case Token::kNotEqStrict:
      return (lhs != rhs) || types_differed;
    case Token::kLessThan:
      return lhs < rhs;
    case Token::kLessThanEq:
      return lhs <= rhs;
    case Token::kGreaterThan:
      return lhs > rhs;
    case Token::kGreaterThanEq:
      return lhs >= rhs;
    default:
      UNREACHABLE();
  }
}

TEST_F(InterpreterTest, InterpreterSmiComparisons) {
  // NB Constants cover 31-bit space.
  int inputs[] = {v8::internal::kMinInt / 2,
                  v8::internal::kMinInt / 4,
                  -108733832,
                  -999,
                  -42,
                  -2,
                  -1,
                  0,
                  +1,
                  +2,
                  42,
                  12345678,
                  v8::internal::kMaxInt / 4,
                  v8::internal::kMaxInt / 2};

  for (size_t c = 0; c < arraysize(kComparisonTypes); c++) {
    Token::Value comparison = kComparisonTypes[c];
    for (size_t i = 0; i < arraysize(inputs); i++) {
      for (size_t j = 0; j < arraysize(inputs); j++) {
        FeedbackVectorSpec feedback_spec(zone());
        BytecodeArrayBuilder builder(zone(), 1, 1, &feedback_spec);

        FeedbackSlot slot = feedback_spec.AddCompareICSlot();
        Handle<i::FeedbackMetadata> metadata =
            FeedbackMetadata::New(i_isolate(), &feedback_spec);

        Register r0(0);
        builder.LoadLiteral(Smi::FromInt(inputs[i]))
            .StoreAccumulatorInRegister(r0)
            .LoadLiteral(Smi::FromInt(inputs[j]))
            .CompareOperation(comparison, r0, GetIndex(slot))
            .Return();

        Handle<BytecodeArray> bytecode_array =
            builder.ToBytecodeArray(i_isolate());
        InterpreterTester tester(i_isolate(), bytecode_array, metadata);
        auto callable = tester.GetCallable<>();
        DirectHandle<Object> return_value = callable().ToHandleChecked();
        CHECK(IsBoolean(*return_value));
        CHECK_EQ(Object::BooleanValue(*return_value, i_isolate()),
                 CompareC(comparison, inputs[i], inputs[j]));
        if (tester.HasFeedbackMetadata()) {
          Tagged<MaybeObject> feedback = callable.vector()->Get(slot);
          CHECK(IsSmi(feedback));
          CHECK_EQ(CompareOperationFeedback::kSignedSmall,
                   feedback.ToSmi().value());
        }
      }
    }
  }
}

TEST_F(InterpreterTest, InterpreterHeapNumberComparisons) {
  double inputs[] = {std::numeric_limits<double>::min(),
                     std::numeric_limits<double>::max(),
                     -0.001,
                     0.01,
                     0.1000001,
                     1e99,
                     -1e-99};
  for (size_t c = 0; c < arraysize(kComparisonTypes); c++) {
    Token::Value comparison = kComparisonTypes[c];
    for (size_t i = 0; i < arraysize(inputs); i++) {
      for (size_t j = 0; j < arraysize(inputs); j++) {
        AstValueFactory ast_factory(zone(), i_isolate()->ast_string_constants(),
                                    HashSeed(i_isolate()));

        FeedbackVectorSpec feedback_spec(zone());
        BytecodeArrayBuilder builder(zone(), 1, 1, &feedback_spec);

        FeedbackSlot slot = feedback_spec.AddCompareICSlot();
        Handle<i::FeedbackMetadata> metadata =
            FeedbackMetadata::New(i_isolate(), &feedback_spec);

        Register r0(0);
        builder.LoadLiteral(inputs[i])
            .StoreAccumulatorInRegister(r0)
            .LoadLiteral(inputs[j])
            .CompareOperation(comparison, r0, GetIndex(slot))
            .Return();

        ast_factory.Internalize(i_isolate());
        Handle<BytecodeArray> bytecode_array =
            builder.ToBytecodeArray(i_isolate());
        InterpreterTester tester(i_isolate(), bytecode_array, metadata);
        auto callable = tester.GetCallable<>();
        DirectHandle<Object> return_value = callable().ToHandleChecked();
        CHECK(IsBoolean(*return_value));
        CHECK_EQ(Object::BooleanValue(*return_value, i_isolate()),
                 CompareC(comparison, inputs[i], inputs[j]));
        if (tester.HasFeedbackMetadata()) {
          Tagged<MaybeObject> feedback = callable.vector()->Get(slot);
          CHECK(IsSmi(feedback));
          CHECK_EQ(CompareOperationFeedback::kNumber, feedback.ToSmi().value());
        }
      }
    }
  }
}

TEST_F(InterpreterTest, InterpreterBigIntComparisons) {
  // This test only checks that the recorded type feedback is kBigInt.
  AstBigInt inputs[] = {AstBigInt("0"), AstBigInt("-42"),
                        AstBigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF")};
  for (size_t c = 0; c < arraysize(kComparisonTypes); c++) {
    Token::Value comparison = kComparisonTypes[c];
    for (size_t i = 0; i < arraysize(inputs); i++) {
      for (size_t j = 0; j < arraysize(inputs); j++) {
        AstValueFactory ast_factory(zone(), i_isolate()->ast_string_constants(),
                                    HashSeed(i_isolate()));

        FeedbackVectorSpec feedback_spec(zone());
        BytecodeArrayBuilder builder(zone(), 1, 1, &feedback_spec);

        FeedbackSlot slot = feedback_spec.AddCompareICSlot();
        Handle<i::FeedbackMetadata> metadata =
            FeedbackMetadata::New(i_isolate(), &feedback_spec);

        Register r0(0);
        builder.LoadLiteral(inputs[i])
            .StoreAccumulatorInRegister(r0)
            .LoadLiteral(inputs[j])
            .CompareOperation(comparison, r0, GetIndex(slot))
            .Return();

        ast_factory.Internalize(i_isolate());
        Handle<BytecodeArray> bytecode_array =
            builder.ToBytecodeArray(i_isolate());
        InterpreterTester tester(i_isolate(), bytecode_array, metadata);
        auto callable = tester.GetCallable<>();
        DirectHandle<Object> return_value = callable().ToHandleChecked();
        CHECK(IsBoolean(*return_value));
        if (tester.HasFeedbackMetadata()) {
          Tagged<MaybeObject> feedback = callable.vector()->Get(slot);
          CHECK(IsSmi(feedback));
          // TODO(panq): Create a standalone unit test for kBigInt64.
          CHECK(CompareOperationFeedback::kBigInt64 ==
                    feedback.ToSmi().value() ||
                CompareOperationFeedback::kBigInt == feedback.ToSmi().value());
        }
      }
    }
  }
}

TEST_F(InterpreterTest, InterpreterStringComparisons) {
  std::string inputs[] = {"A", "abc", "z", "", "Foo!", "Foo"};

  for (size_t c = 0; c < arraysize(kComparisonTypes); c++) {
    Token::Value comparison = kComparisonTypes[c];
    for (size_t i = 0; i < arraysize(inputs); i++) {
      for (size_t j = 0; j < arraysize(inputs); j++) {
        AstValueFactory ast_factory(zone(), i_isolate()->ast_string_constants(),
                                    HashSeed(i_isolate()));

        const char* lhs = inputs[i].c_str();
        const char* rhs = inputs[j].c_str();

        FeedbackVectorSpec feedback_spec(zone());
        FeedbackSlot slot = feedback_spec.AddCompareICSlot();
        Handle<i::FeedbackMetadata> metadata =
            FeedbackMetadata::New(i_isolate(), &feedback_spec);

        BytecodeArrayBuilder builder(zone(), 1, 1, &feedback_spec);
        Register r0(0);
        builder.LoadLiteral(ast_factory.GetOneByteString(lhs))
            .StoreAccumulatorInRegister(r0)
            .LoadLiteral(ast_factory.GetOneByteString(rhs))
            .CompareOperation(comparison, r0, GetIndex(slot))
            .Return();

        ast_factory.Internalize(i_isolate());
        Handle<BytecodeArray> bytecode_array =
            builder.ToBytecodeArray(i_isolate());
        InterpreterTester tester(i_isolate(), bytecode_array, metadata);
        auto callable = tester.GetCallable<>();
        DirectHandle<Object> return_value = callable().ToHandleChecked();
        CHECK(IsBoolean(*return_value));
        CHECK_EQ(Object::BooleanValue(*return_value, i_isolate()),
                 CompareC(comparison, inputs[i], inputs[j]));
        if (tester.HasFeedbackMetadata()) {
          Tagged<MaybeObject> feedback = callable.vector()->Get(slot);
          CHECK(IsSmi(feedback));
          int const expected_feedback =
              Token::IsOrderedRelationalCompareOp(comparison)
                  ? CompareOperationFeedback::kString
                  : CompareOperationFeedback::kInternalizedString;
          CHECK_EQ(expected_feedback, feedback.ToSmi().value());
        }
      }
    }
  }
}

static void LoadStringAndAddSpace(BytecodeArrayBuilder* builder,
                                  AstValueFactory* ast_factory,
                                  const char* cstr,
                                  FeedbackSlot string_add_slot) {
  Register string_reg = builder->register_allocator()->NewRegister();

  (*builder)
      .LoadLiteral(ast_factory->GetOneByteString(cstr))
      .StoreAccumulatorInRegister(string_reg)
      .LoadLiteral(ast_factory->GetOneByteString(" "))
      .BinaryOperation(Token::kAdd, string_reg, GetIndex(string_add_slot));
}

TEST_F(InterpreterTest, InterpreterMixedComparisons) {
  // This test compares a HeapNumber with a String. The latter is
  // convertible to a HeapNumber so comparison will be between numeric
  // values except for the strict comparisons where no conversion is
  // performed.
  const char* inputs[] = {"-1.77", "-40.333", "0.01", "55.77e50", "2.01"};

  enum WhichSideString { kLhsIsString, kRhsIsString };

  enum StringType { kInternalizedStringConstant, kComputedString };

  for (size_t c = 0; c < arraysize(kComparisonTypes); c++) {
    Token::Value comparison = kComparisonTypes[c];
    for (size_t i = 0; i < arraysize(inputs); i++) {
      for (size_t j = 0; j < arraysize(inputs); j++) {
        // We test the case where either the lhs or the rhs is a string...
        for (WhichSideString which_side : {kLhsIsString, kRhsIsString}) {
          // ... and the case when the string is internalized or computed.
          for (StringType string_type :
               {kInternalizedStringConstant, kComputedString}) {
            const char* lhs_cstr = inputs[i];
            const char* rhs_cstr = inputs[j];
            double lhs = StringToDouble(lhs_cstr, NO_CONVERSION_FLAG);
            double rhs = StringToDouble(rhs_cstr, NO_CONVERSION_FLAG);

            AstValueFactory ast_factory(zone(),
                                        i_isolate()->ast_string_constants(),
                                        HashSeed(i_isolate()));
            FeedbackVectorSpec feedback_spec(zone());
            BytecodeArrayBuilder builder(zone(), 1, 0, &feedback_spec);

            FeedbackSlot string_add_slot = feedback_spec.AddBinaryOpICSlot();
            FeedbackSlot slot = feedback_spec.AddCompareICSlot();
            Handle<i::FeedbackMetadata> metadata =
                FeedbackMetadata::New(i_isolate(), &feedback_spec);

            // lhs is in a register, rhs is in the accumulator.
            Register lhs_reg = builder.register_allocator()->NewRegister();

            if (which_side == kRhsIsString) {
              // Comparison with HeapNumber on the lhs and String on the rhs.

              builder.LoadLiteral(lhs).StoreAccumulatorInRegister(lhs_reg);

              if (string_type == kInternalizedStringConstant) {
                // rhs string is internalized.
                builder.LoadLiteral(ast_factory.GetOneByteString(rhs_cstr));
              } else {
                CHECK_EQ(string_type, kComputedString);
                // rhs string is not internalized (append a space to the end).
                LoadStringAndAddSpace(&builder, &ast_factory, rhs_cstr,
                                      string_add_slot);
              }
            } else {
              CHECK_EQ(which_side, kLhsIsString);
              // Comparison with String on the lhs and HeapNumber on the rhs.

              if (string_type == kInternalizedStringConstant) {
                // lhs string is internalized
                builder.LoadLiteral(ast_factory.GetOneByteString(lhs_cstr));
              } else {
                CHECK_EQ(string_type, kComputedString);
                // lhs string is not internalized (append a space to the end).
                LoadStringAndAddSpace(&builder, &ast_factory, lhs_cstr,
                                      string_add_slot);
              }
              builder.StoreAccumulatorInRegister(lhs_reg);

              builder.LoadLiteral(rhs);
            }

            builder.CompareOperation(comparison, lhs_reg, GetIndex(slot))
                .Return();

            ast_factory.Internalize(i_isolate());
            Handle<BytecodeArray> bytecode_array =
                builder.ToBytecodeArray(i_isolate());
            InterpreterTester tester(i_isolate(), bytecode_array, metadata);
            auto callable = tester.GetCallable<>();
            DirectHandle<Object> return_value = callable().ToHandleChecked();
            CHECK(IsBoolean(*return_value));
            CHECK_EQ(Object::BooleanValue(*return_value, i_isolate()),
                     CompareC(comparison, lhs, rhs, true));
            if (tester.HasFeedbackMetadata()) {
              Tagged<MaybeObject> feedback = callable.vector()->Get(slot);
              CHECK(IsSmi(feedback));
              if (kComparisonTypes[c] == Token::kEq) {
                // For sloppy equality, we have more precise feedback.
                CHECK_EQ(
                    CompareOperationFeedback::kNumber |
                        (string_type == kInternalizedStringConstant
                             ? CompareOperationFeedback::kInternalizedString
                             : CompareOperationFeedback::kString),
                    feedback.ToSmi().value());
              } else {
                // Comparison with a number and string collects kAny feedback.
                CHECK_EQ(CompareOperationFeedback::kAny,
                         feedback.ToSmi().value());
              }
            }
          }
        }
      }
    }
  }
}

TEST_F(InterpreterTest, InterpreterStrictNotEqual) {
  Factory* factory = i_isolate()->factory();
  const char* code_snippet =
      "function f(lhs, rhs) {\n"
      "  return lhs !== rhs;\n"
      "}\n"
      "f(0, 0);\n";
  InterpreterTester tester(i_isolate(), code_snippet);
  auto callable = tester.GetCallable<Handle<Object>, Handle<Object>>();

  // Test passing different types.
  const char* inputs[] = {"-1.77", "-40.333", "0.01", "55.77e5", "2.01"};
  for (size_t i = 0; i < arraysize(inputs); i++) {
    for (size_t j = 0; j < arraysize(inputs); j++) {
      double lhs = StringToDouble(inputs[i], NO_CONVERSION_FLAG);
      double rhs = StringToDouble(inputs[j], NO_CONVERSION_FLAG);
      Handle<Object> lhs_obj = factory->NewNumber(lhs);
      Handle<Object> rhs_obj = factory->NewStringFromAsciiChecked(inputs[j]);

      DirectHandle<Object> return_value =
          callable(lhs_obj, rhs_obj).ToHandleChecked();
      CHECK(IsBoolean(*return_value));
      CHECK_EQ(Object::BooleanValue(*return_value, i_isolate()),
               CompareC(Token::kNotEqStrict, lhs, rhs, true));
    }
  }

  // Test passing string types.
  const char* inputs_str[] = {"A", "abc", "z", "", "Foo!", "Foo"};
  for (size_t i = 0; i < arraysize(inputs_str); i++) {
    for (size_t j = 0; j < arraysize(inputs_str); j++) {
      Handle<Object> lhs_obj =
          factory->NewStringFromAsciiChecked(inputs_str[i]);
      Handle<Object> rhs_obj =
          factory->NewStringFromAsciiChecked(inputs_str[j]);

      DirectHandle<Object> return_value =
          callable(lhs_obj, rhs_obj).ToHandleChecked();
      CHECK(IsBoolean(*return_value));
      CHECK_EQ(Object::BooleanValue(*return_value, i_isolate()),
               CompareC(Token::kNotEqStrict, inputs_str[i], inputs_str[j]));
    }
  }

  // Test passing doubles.
  double inputs_number[] = {std::numeric_limits<double>::min(),
                            std::numeric_limits<double>::max(),
                            -0.001,
                            0.01,
                            0.1000001,
                            1e99,
                            -1e-99};
  for (size_t i = 0; i < arraysize(inputs_number); i++) {
    for (size_t j = 0; j < arraysize(inputs_number); j++) {
      Handle<Object> lhs_obj = factory->NewNumber(inputs_number[i]);
      Handle<Object> rhs_obj = factory->NewNumber(inputs_number[j]);

      DirectHandle<Object> return_value =
          callable(lhs_obj, rhs_obj).ToHandleChecked();
      CHECK(IsBoolean(*return_value));
      CHECK_EQ(
          Object::BooleanValue(*return_value, i_isolate()),
          CompareC(Token::kNotEqStrict, inputs_number[i], inputs_number[j]));
    }
  }
}

TEST_F(InterpreterTest, InterpreterCompareTypeOf) {
  using LiteralFlag = TestTypeOfFlags::LiteralFlag;

  Factory* factory = i_isolate()->factory();

  std::pair<Handle<Object>, LiteralFlag> inputs[] = {
      {handle(Smi::FromInt(24), i_isolate()), LiteralFlag::kNumber},
      {factory->NewNumber(2.5), LiteralFlag::kNumber},
      {factory->NewStringFromAsciiChecked("foo"), LiteralFlag::kString},
      {factory
           ->NewConsString(factory->NewStringFromAsciiChecked("foo"),
                           factory->NewStringFromAsciiChecked("bar"))
           .ToHandleChecked(),
       LiteralFlag::kString},
      {factory->prototype_string(), LiteralFlag::kString},
      {factory->NewSymbol(), LiteralFlag::kSymbol},
      {factory->true_value(), LiteralFlag::kBoolean},
      {factory->false_value(), LiteralFlag::kBoolean},
      {factory->undefined_value(), LiteralFlag::kUndefined},
      {InterpreterTester::NewObject(
           "(function() { return function() {}; })();"),
       LiteralFlag::kFunction},
      {InterpreterTester::NewObject("new Object();"), LiteralFlag::kObject},
      {factory->null_value(), LiteralFlag::kObject},
  };
  const LiteralFlag kLiterals[] = {
#define LITERAL_FLAG(name, _) LiteralFlag::k##name,
      TYPEOF_LITERAL_LIST(LITERAL_FLAG)
#undef LITERAL_FLAG
  };

  for (size_t l = 0; l < arraysize(kLiterals); l++) {
    LiteralFlag literal_flag = kLiterals[l];
    if (literal_flag == LiteralFlag::kOther) continue;

    BytecodeArrayBuilder builder(zone(), 2, 0);
    builder.LoadAccumulatorWithRegister(builder.Parameter(0))
        .CompareTypeOf(kLiterals[l])
        .Return();
    Handle<BytecodeArray> bytecode_array = builder.ToBytecodeArray(i_isolate());
    InterpreterTester tester(i_isolate(), bytecode_array);
    auto callable = tester.GetCallable<Handle<Object>>();

    for (size_t i = 0; i < arraysize(inputs); i++) {
      DirectHandle<Object> return_value =
          callable(inputs[i].first).ToHandleChecked();
      CHECK(IsBoolean(*return_value));
      CHECK_EQ(Object::BooleanValue(*return_value, i_isolate()),
               inputs[i].second == literal_flag);
    }
  }
}

TEST_F(InterpreterTest, InterpreterInstanceOf) {
  Factory* factory = i_isolate()->factory();
  DirectHandle<i::String> name = factory->NewStringFromAsciiChecked("cons");
  Handle<i::JSFunction> func = factory->NewFunctionForTesting(name);
  Handle<i::JSObject> instance = factory->NewJSObject(func);
  Handle<i::Object> other = factory->NewNumber(3.3333);
  Handle<i::Object> cases[] = {Cast<i::Object>(instance), other};
  for (size_t i = 0; i < arraysize(cases); i++) {
    bool expected_value = (i == 0);
    FeedbackVectorSpec feedback_spec(zone());
    BytecodeArrayBuilder builder(zone(), 1, 1, &feedback_spec);

    Register r0(0);
    size_t case_entry = builder.AllocateDeferredConstantPoolEntry();
    builder.SetDeferredConstantPoolEntry(case_entry, cases[i]);
    builder.LoadConstantPoolEntry(case_entry).StoreAccumulatorInRegister(r0);

    FeedbackSlot slot = feedback_spec.AddInstanceOfSlot();
    Handle<i::FeedbackMetadata> metadata =
        FeedbackMetadata::New(i_isolate(), &feedback_spec);

    size_t func_entry = builder.AllocateDeferredConstantPoolEntry();
    builder.SetDeferredConstantPoolEntry(func_entry, func);
    builder.LoadConstantPoolEntry(func_entry)
        .CompareOperation(Token::kInstanceOf, r0, GetIndex(slot))
        .Return();

    Handle<BytecodeArray> bytecode_array = builder.ToBytecodeArray(i_isolate());
    DirectHandle<Object> return_value = RunBytecode(bytecode_array, metadata);
    CHECK(IsBoolean(*return_value));
    CHECK_EQ(Object::BooleanValue(*return_value, i_isolate()), expected_value);
  }
}

TEST_F(InterpreterTest, InterpreterTestIn) {
  Factory* factory = i_isolate()->factory();
  // Allocate an array
  Handle<i::JSArray> array =
      factory->NewJSArray(0, i::ElementsKind::PACKED_SMI_ELEMENTS);
  // Check for these properties on the array object
  const char* properties[] = {"length", "fuzzle", "x", "0"};
  for (size_t i = 0; i < arraysize(properties); i++) {
    AstValueFactory ast_factory(zone(), i_isolate()->ast_string_constants(),
                                HashSeed(i_isolate()));

    bool expected_value = (i == 0);
    FeedbackVectorSpec feedback_spec(zone());
    BytecodeArrayBuilder builder(zone(), 1, 1, &feedback_spec);

    Register r0(0);
    builder.LoadLiteral(ast_factory.GetOneByteString(properties[i]))
        .StoreAccumulatorInRegister(r0);

    FeedbackSlot slot = feedback_spec.AddKeyedHasICSlot();
    Handle<i::FeedbackMetadata> metadata =
        FeedbackMetadata::New(i_isolate(), &feedback_spec);

    size_t array_entry = builder.AllocateDeferredConstantPoolEntry();
    builder.SetDeferredConstantPoolEntry(array_entry, array);
    builder.LoadConstantPoolEntry(array_entry)
        .CompareOperation(Token::kIn, r0, GetIndex(slot))
        .Return();

    ast_factory.Internalize(i_isolate());
    Handle<BytecodeArray> bytecode_array = builder.ToBytecodeArray(i_isolate());
    DirectHandle<Object> return_value = RunBytecode(bytecode_array, metadata);
    CHECK(IsBoolean(*return_value));
    CHECK_EQ(Object::BooleanValue(*return_value, i_isolate()), expected_value);
  }
}

TEST_F(InterpreterTest, InterpreterUnaryNot) {
  for (size_t i = 1; i < 10; i++) {
    bool expected_value = ((i & 1) == 1);
    BytecodeArrayBuilder builder(zone(), 1, 0);

    builder.LoadFalse();
    for (size_t j = 0; j < i; j++) {
      builder.LogicalNot(ToBooleanMode::kAlreadyBoolean);
    }
    builder.Return();
    Handle<BytecodeArray> bytecode_array = builder.ToBytecodeArray(i_isolate());
    DirectHandle<Object> return_value = RunBytecode(bytecode_array);
    CHECK(IsBoolean(*return_value));
    CHECK_EQ(Object::BooleanValue(*return_value, i_isolate()), expected_value);
  }
}

TEST_F(InterpreterTest, InterpreterUnaryNotNonBoolean) {
  AstValueFactory ast_factory(zone(), i_isolate()->ast_string_constants(),
                              HashSeed(i_isolate()));

  std::pair<LiteralForTest, bool> object_type_tuples[] = {
      std::make_pair(LiteralForTest(LiteralForTest::kUndefined), true),
      std::make_pair(LiteralForTest(LiteralForTest::kNull), true),
      std::make_pair(LiteralForTest(LiteralForTest::kFalse), true),
      std::make_pair(LiteralForTest(LiteralForTest::kTrue), false),
      std::make_pair(LiteralForTest(9.1), false),
      std::make_pair(LiteralForTest(0), true),
      std::make_pair(LiteralForTest(ast_factory.GetOneByteString("hello")),
                     false),
      std::make_pair(LiteralForTest(ast_factory.GetOneByteString("")), true),
  };
  ast_factory.Internalize(i_isolate());

  for (size_t i = 0; i < arraysize(object_type_tuples); i++) {
    BytecodeArrayBuilder builder(zone(), 1, 0);

    LoadLiteralForTest(&builder, object_type_tuples[i].first);
    builder.LogicalNot(ToBooleanMode::kConvertToBoolean).Return();
    Handle<BytecodeArray> bytecode_array = builder.ToBytecodeArray(i_isolate());
    DirectHandle<Object> return_value = RunBytecode(bytecode_array);
    CHECK(IsBoolean(*return_value));
    CHECK_EQ(Object::BooleanValue(*return_value, i_isolate()),
             object_type_tuples[i].second);
  }
}

TEST_F(InterpreterTest, InterpreterTypeof) {
  std::pair<const char*, const char*> typeof_vals[] = {
      std::make_pair("return typeof undefined;", "undefined"),
      std::make_pair("return typeof null;", "object"),
      std::make_pair("return typeof true;", "boolean"),
      std::make_pair("return typeof false;", "boolean"),
      std::make_pair("return typeof 9.1;", "number"),
      std::make_pair("return typeof 7771;", "number"),
      std::make_pair("return typeof 'hello';", "string"),
      std::make_pair("return typeof global_unallocated;", "undefined"),
  };

  for (size_t i = 0; i < arraysize(typeof_vals); i++) {
    std::string source(InterpreterTester::SourceForBody(typeof_vals[i].first));
    InterpreterTester tester(i_isolate(), source.c_str());

    auto callable = tester.GetCallable<>();
    DirectHandle<v8::internal::String> return_value =
        Cast<v8::internal::String>(callable().ToHandleChecked());
    auto actual = return_value->ToCString();
    CHECK_EQ(strcmp(&actual[0], typeof_vals[i].second), 0);
  }
}

TEST_F(InterpreterTest, InterpreterCallRuntime) {
  BytecodeArrayBuilder builder(zone(), 1, 2);
  RegisterList args = builder.register_allocator()->NewRegisterList(2);

  builder.LoadLiteral(Smi::FromInt(15))
      .StoreAccumulatorInRegister(args[0])
      .LoadLiteral(Smi::FromInt(40))
      .StoreAccumulatorInRegister(args[1])
      .CallRuntime(Runtime::kAdd, args)
      .Return();
  Handle<BytecodeArray> bytecode_array = builder.ToBytecodeArray(i_isolate());

  DirectHandle<Object> return_val = RunBytecode(bytecode_array);
  CHECK_EQ(Cast<Smi>(*return_val), Smi::FromInt(55));
}

TEST_F(InterpreterTest, InterpreterFunctionLiteral) {
  // Test calling a function literal.
  std::string source("function " + InterpreterTester::function_name() +
                     "(a) {\n"
                     "  return (function(x){ return x + 2; })(a);\n"
                     "}");
  InterpreterTester tester(i_isolate(), source.c_str());
  auto callable = tester.GetCallable<Handle<Object>>();

  DirectHandle<i::Object> return_val =
      callable(Handle<Smi>(Smi::FromInt(3), i_isolate())).ToHandleChecked();
  CHECK_EQ(Cast<Smi>(*return_val), Smi::FromInt(5));
}

TEST_F(InterpreterTest, InterpreterRegExpLiterals) {
  Factory* factory = i_isolate()->factory();

  std::pair<const char*, Handle<Object>> literals[] = {
      std::make_pair("return /abd/.exec('cccabbdd');\n", factory->null_value()),
      std::make_pair("return /ab+d/.exec('cccabbdd')[0];\n",
                     factory->NewStringFromStaticChars("abbd")),
      std::make_pair("return /AbC/i.exec('ssaBC')[0];\n",
                     factory->NewStringFromStaticChars("aBC")),
      std::make_pair("return 'ssaBC'.match(/AbC/i)[0];\n",
                     factory->NewStringFromStaticChars("aBC")),
      std::make_pair("return 'ssaBCtAbC'.match(/(AbC)/gi)[1];\n",
                     factory->NewStringFromStaticChars("AbC")),
  };

  for (size_t i = 0; i < arraysize(literals); i++) {
    std::string source(InterpreterTester::SourceForBody(literals[i].first));
    InterpreterTester tester(i_isolate(), source.c_str());
    auto callable = tester.GetCallable<>();

    DirectHandle<i::Object> return_value = callable().ToHandleChecked();
    CHECK(Object::SameValue(*return_value, *literals[i].second));
  }
}

TEST_F(InterpreterTest, InterpreterArrayLiterals) {
  Factory* factory = i_isolate()->factory();

  std::pair<const char*, Handle<Object>> literals[] = {
      std::make_pair("return [][0];\n", factory->undefined_value()),
      std::make_pair("return [1, 3, 2][1];\n",
                     handle(Smi::FromInt(3), i_isolate())),
      std::make_pair("return ['a', 'b', 'c'][2];\n",
                     factory->NewStringFromStaticChars("c")),
      std::make_pair("var a = 100; return [a, a + 1, a + 2, a + 3][2];\n",
                     handle(Smi::FromInt(102), i_isolate())),
      std::make_pair("return [[1, 2, 3], ['a', 'b', 'c']][1][0];\n",
                     factory->NewStringFromStaticChars("a")),
      std::make_pair("var t = 't'; return [[t, t + 'est'], [1 + t]][0][1];\n",
                     factory->NewStringFromStaticChars("test"))};

  for (size_t i = 0; i < arraysize(literals); i++) {
    std::string source(InterpreterTester::SourceForBody(literals[i].first));
    InterpreterTester tester(i_isolate(), source.c_str());
    auto callable = tester.GetCallable<>();

    DirectHandle<i::Object> return_value = callable().ToHandleChecked();
    CHECK(Object::SameValue(*return_value, *literals[i].second));
  }
}

TEST_F(InterpreterTest, InterpreterObjectLiterals) {
  Factory* factory = i_isolate()->factory();

  std::pair<const char*, Handle<Object>> literals[] = {
      std::make_pair("return { }.name;", factory->undefined_value()),
      std::make_pair("return { name: 'string', val: 9.2 }.name;",
                     factory->NewStringFromStaticChars("string")),
      std::make_pair("var a = 15; return { name: 'string', val: a }.val;",
                     handle(Smi::FromInt(15), i_isolate())),
      std::make_pair("var a = 5; return { val: a, val: a + 1 }.val;",
                     handle(Smi::FromInt(6), i_isolate())),
      std::make_pair("return { func: function() { return 'test' } }.func();",
                     factory->NewStringFromStaticChars("test")),
      std::make_pair("return { func(a) { return a + 'st'; } }.func('te');",
                     factory->NewStringFromStaticChars("test")),
      std::make_pair("return { get a() { return 22; } }.a;",
                     handle(Smi::FromInt(22), i_isolate())),
      std::make_pair("var a = { get b() { return this.x + 't'; },\n"
                     "          set b(val) { this.x = val + 's' } };\n"
                     "a.b = 'te';\n"
                     "return a.b;",
                     factory->NewStringFromStaticChars("test")),
      std::make_pair("var a = 123; return { 1: a }[1];",
                     handle(Smi::FromInt(123), i_isolate())),
      std::make_pair("return Object.getPrototypeOf({ __proto__: null });",
                     factory->null_value()),
      std::make_pair("var a = 'test'; return { [a]: 1 }.test;",
                     handle(Smi::FromInt(1), i_isolate())),
      std::make_pair("var a = 'test'; return { b: a, [a]: a + 'ing' }['test']",
                     factory->NewStringFromStaticChars("testing")),
      std::make_pair("var a = 'proto_str';\n"
                     "var b = { [a]: 1, __proto__: { var : a } };\n"
                     "return Object.getPrototypeOf(b).var",
                     factory->NewStringFromStaticChars("proto_str")),
      std::make_pair("var n = 'name';\n"
                     "return { [n]: 'val', get a() { return 987 } }['a'];",
                     handle(Smi::FromInt(987), i_isolate())),
  };

  for (size_t i = 0; i < arraysize(literals); i++) {
    std::string source(InterpreterTester::SourceForBody(literals[i].first));
    InterpreterTester tester(i_isolate(), source.c_str());
    auto callable = tester.GetCallable<>();

    DirectHandle<i::Object> return_value = callable().ToHandleChecked();
    CHECK(Object::SameValue(*return_value, *literals[i].second));
  }
}

TEST_F(InterpreterTest, InterpreterConstruct) {
  std::string source(
      "function counter() { this.count = 0; }\n"
      "function " +
      InterpreterTester::function_name() +
      "() {\n"
      "  var c = new counter();\n"
      "  return c.count;\n"
      "}");
  InterpreterTester tester(i_isolate(), source.c_str());
  auto callable = tester.GetCallable<>();

  DirectHandle<Object> return_val = callable().ToHandleChecked();
  CHECK_EQ(Cast<Smi>(*return_val), Smi::zero());
}

TEST_F(InterpreterTest, InterpreterConstructWithArgument) {
  std::string source(
      "function counter(arg0) { this.count = 17; this.x = arg0; }\n"
      "function " +
      InterpreterTester::function_name() +
      "() {\n"
      "  var c = new counter(3);\n"
      "  return c.x;\n"
      "}");
  InterpreterTester tester(i_isolate(), source.c_str());
  auto callable = tester.GetCallable<>();

  DirectHandle<Object> return_val = callable().ToHandleChecked();
  CHECK_EQ(Cast<Smi>(*return_val), Smi::FromInt(3));
}

TEST_F(InterpreterTest, InterpreterConstructWithArguments) {
  std::string source(
      "function counter(arg0, arg1) {\n"
      "  this.count = 7; this.x = arg0; this.y = arg1;\n"
      "}\n"
      "function " +
      InterpreterTester::function_name() +
      "() {\n"
      "  var c = new counter(3, 5);\n"
      "  return c.count + c.x + c.y;\n"
      "}");
  InterpreterTester tester(i_isolate(), source.c_str());
  auto callable = tester.GetCallable<>();

  DirectHandle<Object> return_val = callable().ToHandleChecked();
  CHECK_EQ(Cast<Smi>(*return_val), Smi::FromInt(15));
}

TEST_F(InterpreterTest, InterpreterContextVariables) {
  std::ostringstream unique_vars;
  for (int i = 0; i < 250; i++) {
    unique_vars << "var a" << i << " = 0;";
  }
  std::pair<std::string, Handle<Object>> context_vars[] = {
      std::make_pair("var a; (function() { a = 1; })(); return a;",
                     handle(Smi::FromInt(1), i_isolate())),
      std::make_pair("var a = 10; (function() { a; })(); return a;",
                     handle(Smi::FromInt(10), i_isolate())),
      std::make_pair("var a = 20; var b = 30;\n"
                     "return (function() { return a + b; })();",
                     handle(Smi::FromInt(50), i_isolate())),
      std::make_pair("'use strict'; let a = 1;\n"
                     "{ let b = 2; return (function() { return a + b; })(); }",
                     handle(Smi::FromInt(3), i_isolate())),
      std::make_pair("'use strict'; let a = 10;\n"
                     "{ let b = 20; var c = function() { [a, b] };\n"
                     "  return a + b; }",
                     handle(Smi::FromInt(30), i_isolate())),
      std::make_pair("'use strict';" + unique_vars.str() +
                         "eval(); var b = 100; return b;",
                     handle(Smi::FromInt(100), i_isolate())),
  };

  for (size_t i = 0; i < arraysize(context_vars); i++) {
    std::string source(
        InterpreterTester::SourceForBody(context_vars[i].first.c_str()));
    InterpreterTester tester(i_isolate(), source.c_str());
    auto callable = tester.GetCallable<>();

    DirectHandle<i::Object> return_value = callable().ToHandleChecked();
    CHECK(Object::SameValue(*return_value, *context_vars[i].second));
  }
}

TEST_F(InterpreterTest, InterpreterContextParameters) {
  std::pair<const char*, Handle<Object>> context_params[] = {
      std::make_pair("return (function() { return arg1; })();",
                     handle(Smi::FromInt(1), i_isolate())),
      std::make_pair("(function() { arg1 = 4; })(); return arg1;",
                     handle(Smi::FromInt(4), i_isolate())),
      std::make_pair("(function() { arg3 = arg2 - arg1; })(); return arg3;",
                     handle(Smi::FromInt(1), i_isolate())),
  };

  for (size_t i = 0; i < arraysize(context_params); i++) {
    std::string source = "function " + InterpreterTester::function_name() +
                         "(arg1, arg2, arg3) {" + context_params[i].first + "}";
    InterpreterTester tester(i_isolate(), source.c_str());
    auto callable =
        tester.GetCallable<Handle<Object>, Handle<Object>, Handle<Object>>();

    Handle<Object> a1 = handle(Smi::FromInt(1), i_isolate());
    Handle<Object> a2 = handle(Smi::FromInt(2), i_isolate());
    Handle<Object> a3 = handle(Smi::FromInt(3), i_isolate());
    DirectHandle<i::Object> return_value =
        callable(a1, a2, a3).ToHandleChecked();
    CHECK(Object::SameValue(*return_value, *context_params[i].second));
  }
}

TEST_F(InterpreterTest, InterpreterOuterContextVariables) {
  std::pair<const char*, Handle<Object>> context_vars[] = {
      std::make_pair("return outerVar * innerArg;",
                     handle(Smi::FromInt(200), i_isolate())),
      std::make_pair("outerVar = innerArg; return outerVar",
                     handle(Smi::FromInt(20), i_isolate())),
  };

  std::string header(
      "function Outer() {"
      "  var outerVar = 10;"
      "  function Inner(innerArg) {"
      "    this.innerFunc = function() { ");
  std::string footer(
      "  }}"
      "  this.getInnerFunc = function() { return new Inner(20).innerFunc; }"
      "}"
      "var f = new Outer().getInnerFunc();");

  for (size_t i = 0; i < arraysize(context_vars); i++) {
    std::string source = header + context_vars[i].first + footer;
    InterpreterTester tester(i_isolate(), source.c_str(), "*");
    auto callable = tester.GetCallable<>();

    DirectHandle<i::Object> return_value = callable().ToHandleChecked();
    CHECK(Object::SameValue(*return_value, *context_vars[i].second));
  }
}

TEST_F(InterpreterTest, InterpreterComma) {
  Factory* factory = i_isolate()->factory();

  std::pair<const char*, Handle<Object>> literals[] = {
      std::make_pair("var a; return 0, a;\n", factory->undefined_value()),
      std::make_pair("return 'a', 2.2, 3;\n",
                     handle(Smi::FromInt(3), i_isolate())),
      std::make_pair("return 'a', 'b', 'c';\n",
                     factory->NewStringFromStaticChars("c")),
      std::make_pair("return 3.2, 2.3, 4.5;\n", factory->NewNumber(4.5)),
      std::make_pair("var a = 10; return b = a, b = b+1;\n",
                     handle(Smi::FromInt(11), i_isolate())),
      std::make_pair("var a = 10; return b = a, b = b+1, b + 10;\n",
                     handle(Smi::FromInt(21), i_isolate()))};

  for (size_t i = 0; i < arraysize(literals); i++) {
    std::string source(InterpreterTester::SourceForBody(literals[i].first));
    InterpreterTester tester(i_isolate(), source.c_str());
    auto callable = tester.GetCallable<>();

    DirectHandle<i::Object> return_value = callable().ToHandleChecked();
    CHECK(Object::SameValue(*return_value, *literals[i].second));
  }
}

TEST_F(InterpreterTest, InterpreterLogicalOr) {
  Factory* factory = i_isolate()->factory();

  std::pair<const char*, Handle<Object>> literals[] = {
      std::make_pair("var a, b; return a || b;\n", factory->undefined_value()),
      std::make_pair("var a, b = 10; return a || b;\n",
                     handle(Smi::FromInt(10), i_isolate())),
      std::make_pair("var a = '0', b = 10; return a || b;\n",
                     factory->NewStringFromStaticChars("0")),
      std::make_pair("return 0 || 3.2;\n", factory->NewNumber(3.2)),
      std::make_pair("return 'a' || 0;\n",
                     factory->NewStringFromStaticChars("a")),
      std::make_pair("var a = '0', b = 10; return (a == 0) || b;\n",
                     factory->true_value())};

  for (size_t i = 0; i < arraysize(literals); i++) {
    std::string source(InterpreterTester::SourceForBody(literals[i].first));
    InterpreterTester tester(i_isolate(), source.c_str());
    auto callable = tester.GetCallable<>();

    DirectHandle<i::Object> return_value = callable().ToHandleChecked();
    CHECK(Object::SameValue(*return_value, *literals[i].second));
  }
}

TEST_F(InterpreterTest, InterpreterLogicalAnd) {
  Factory* factory = i_isolate()->factory();

  std::pair<const char*, Handle<Object>> literals[] = {
      std::make_pair("var a, b = 10; return a && b;\n",
                     factory->undefined_value()),
      std::make_pair("var a = 0, b = 10; return a && b / a;\n",
                     handle(Smi::zero(), i_isolate())),
      std::make_pair("var a = '0', b = 10; return a && b;\n",
                     handle(Smi::FromInt(10), i_isolate())),
      std::make_pair("return 0.0 && 3.2;\n", handle(Smi::zero(), i_isolate())),
      std::make_pair("return 'a' && 'b';\n",
                     factory->NewStringFromStaticChars("b")),
      std::make_pair("return 'a' && 0 || 'b', 'c';\n",
                     factory->NewStringFromStaticChars("c")),
      std::make_pair("var x = 1, y = 3; return x && 0 + 1 || y;\n",
                     handle(Smi::FromInt(1), i_isolate())),
      std::make_pair("var x = 1, y = 3; return (x == 1) && (3 == 3) || y;\n",
                     factory->true_value())};

  for (size_t i = 0; i < arraysize(literals); i++) {
    std::string source(InterpreterTester::SourceForBody(literals[i].first));
    InterpreterTester tester(i_isolate(), source.c_str());
    auto callable = tester.GetCallable<>();

    DirectHandle<i::Object> return_value = callable().ToHandleChecked();
    CHECK(Object::SameValue(*return_value, *literals[i].second));
  }
}

TEST_F(InterpreterTest, InterpreterTryCatch) {
  std::pair<const char*, Handle<Object>> catches[] = {
      std::make_pair("var a = 1; try { a = 2 } catch(e) { a = 3 }; return a;",
                     handle(Smi::FromInt(2), i_isolate())),
      std::make_pair("var a; try { undef.x } catch(e) { a = 2 }; return a;",
                     handle(Smi::FromInt(2), i_isolate())),
      std::make_pair("var a; try { throw 1 } catch(e) { a = e + 2 }; return a;",
                     handle(Smi::FromInt(3), i_isolate())),
      std::make_pair("var a; try { throw 1 } catch(e) { a = e + 2 };"
                     "       try { throw a } catch(e) { a = e + 3 }; return a;",
                     handle(Smi::FromInt(6), i_isolate())),
  };

  for (size_t i = 0; i < arraysize(catches); i++) {
    std::string source(InterpreterTester::SourceForBody(catches[i].first));
    InterpreterTester tester(i_isolate(), source.c_str());
    auto callable = tester.GetCallable<>();

    DirectHandle<i::Object> return_value = callable().ToHandleChecked();
    CHECK(Object::SameValue(*return_value, *catches[i].second));
  }
}

TEST_F(InterpreterTest, InterpreterTryFinally) {
  Factory* factory = i_isolate()->factory();

  std::pair<const char*, Handle<Object>> finallies[] = {
      std::make_pair(
          "var a = 1; try { a = a + 1; } finally { a = a + 2; }; return a;",
          factory->NewStringFromStaticChars("R4")),
      std::make_pair(
          "var a = 1; try { a = 2; return 23; } finally { a = 3 }; return a;",
          factory->NewStringFromStaticChars("R23")),
      std::make_pair(
          "var a = 1; try { a = 2; throw 23; } finally { a = 3 }; return a;",
          factory->NewStringFromStaticChars("E23")),
      std::make_pair(
          "var a = 1; try { a = 2; throw 23; } finally { return a; };",
          factory->NewStringFromStaticChars("R2")),
      std::make_pair(
          "var a = 1; try { a = 2; throw 23; } finally { throw 42; };",
          factory->NewStringFromStaticChars("E42")),
      std::make_pair("var a = 1; for (var i = 10; i < 20; i += 5) {"
                     "  try { a = 2; break; } finally { a = 3; }"
                     "} return a + i;",
                     factory->NewStringFromStaticChars("R13")),
      std::make_pair("var a = 1; for (var i = 10; i < 20; i += 5) {"
                     "  try { a = 2; continue; } finally { a = 3; }"
                     "} return a + i;",
                     factory->NewStringFromStaticChars("R23")),
      std::make_pair("var a = 1; try { a = 2;"
                     "  try { a = 3; throw 23; } finally { a = 4; }"
                     "} catch(e) { a = a + e; } return a;",
                     factory->NewStringFromStaticChars("R27")),
      std::make_pair("var func_name;"
                     "function tcf2(a) {"
                     "  try { throw new Error('boom');} "
                     "  catch(e) {return 153; } "
                     "  finally {func_name = tcf2.name;}"
                     "}"
                     "tcf2();"
                     "return func_name;",
                     factory->NewStringFromStaticChars("Rtcf2")),
  };

  const char* try_wrapper =
      "(function() { try { return 'R' + f() } catch(e) { return 'E' + e }})()";

  for (size_t i = 0; i < arraysize(finallies); i++) {
    std::string source(InterpreterTester::SourceForBody(finallies[i].first));
    InterpreterTester tester(i_isolate(), source.c_str());
    tester.GetCallable<>();
    DirectHandle<Object> wrapped =
        v8::Utils::OpenDirectHandle(*CompileRun(try_wrapper));
    CHECK(Object::SameValue(*wrapped, *finallies[i].second));
  }
}

TEST_F(InterpreterTest, InterpreterThrow) {
  Factory* factory = i_isolate()->factory();

  std::pair<const char*, Handle<Object>> throws[] = {
      std::make_pair("throw undefined;\n", factory->undefined_value()),
      std::make_pair("throw 1;\n", handle(Smi::FromInt(1), i_isolate())),
      std::make_pair("throw 'Error';\n",
                     factory->NewStringFromStaticChars("Error")),
      std::make_pair("var a = true; if (a) { throw 'Error'; }\n",
                     factory->NewStringFromStaticChars("Error")),
      std::make_pair("var a = false; if (a) { throw 'Error'; }\n",
                     factory->undefined_value()),
      std::make_pair("throw 'Error1'; throw 'Error2'\n",
                     factory->NewStringFromStaticChars("Error1")),
  };

  const char* try_wrapper =
      "(function() { try { f(); } catch(e) { return e; }})()";

  for (size_t i = 0; i < arraysize(throws); i++) {
    std::string source(InterpreterTester::SourceForBody(throws[i].first));
    InterpreterTester tester(i_isolate(), source.c_str());
    tester.GetCallable<>();
    DirectHandle<Object> thrown_obj =
        v8::Utils::OpenDirectHandle(*CompileRun(try_wrapper));
    CHECK(Object::SameValue(*thrown_obj, *throws[i].second));
  }
}

TEST_F(InterpreterTest, InterpreterCountOperators) {
  Factory* factory = i_isolate()->factory();

  std::pair<const char*, Handle<Object>> count_ops[] = {
      std::make_pair("var a = 1; return ++a;",
                     handle(Smi::FromInt(2), i_isolate())),
      std::make_pair("var a = 1; return a++;",
                     handle(Smi::FromInt(1), i_isolate())),
      std::make_pair("var a = 5; return --a;",
                     handle(Smi::FromInt(4), i_isolate())),
      std::make_pair("var a = 5; return a--;",
                     handle(Smi::FromInt(5), i_isolate())),
      std::make_pair("var a = 5.2; return --a;", factory->NewHeapNumber(4.2)),
      std::make_pair("var a = 'string'; return ++a;", factory->nan_value()),
      std::make_pair("var a = 'string'; return a--;", factory->nan_value()),
      std::make_pair("var a = true; return ++a;",
                     handle(Smi::FromInt(2), i_isolate())),
      std::make_pair("var a = false; return a--;",
                     handle(Smi::zero(), i_isolate())),
      std::make_pair("var a = { val: 11 }; return ++a.val;",
                     handle(Smi::FromInt(12), i_isolate())),
      std::make_pair("var a = { val: 11 }; return a.val--;",
                     handle(Smi::FromInt(11), i_isolate())),
      std::make_pair("var a = { val: 11 }; return ++a.val;",
                     handle(Smi::FromInt(12), i_isolate())),
      std::make_pair("var name = 'val'; var a = { val: 22 }; return --a[name];",
                     handle(Smi::FromInt(21), i_isolate())),
      std::make_pair("var name = 'val'; var a = { val: 22 }; return a[name]++;",
                     handle(Smi::FromInt(22), i_isolate())),
      std::make_pair("var a = 1; (function() { a = 2 })(); return ++a;",
                     handle(Smi::FromInt(3), i_isolate())),
      std::make_pair("var a = 1; (function() { a = 2 })(); return a--;",
                     handle(Smi::FromInt(2), i_isolate())),
      std::make_pair("var i = 5; while(i--) {}; return i;",
                     handle(Smi::FromInt(-1), i_isolate())),
      std::make_pair("var i = 1; if(i--) { return 1; } else { return 2; };",
                     handle(Smi::FromInt(1), i_isolate())),
      std::make_pair("var i = -2; do {} while(i++) {}; return i;",
                     handle(Smi::FromInt(1), i_isolate())),
      std::make_pair("var i = -1; for(; i++; ) {}; return i",
                     handle(Smi::FromInt(1), i_isolate())),
      std::make_pair("var i = 20; switch(i++) {\n"
                     "  case 20: return 1;\n"
                     "  default: return 2;\n"
                     "}",
                     handle(Smi::FromInt(1), i_isolate())),
  };

  for (size_t i = 0; i < arraysize(count_ops); i++) {
    std::string source(InterpreterTester::SourceForBody(count_ops[i].first));
    InterpreterTester tester(i_isolate(), source.c_str());
    auto callable = tester.GetCallable<>();

    DirectHandle<i::Object> return_value = callable().ToHandleChecked();
    CHECK(Object::SameValue(*return_value, *count_ops[i].second));
  }
}

TEST_F(InterpreterTest, InterpreterGlobalCountOperators) {
  std::pair<const char*, Handle<Object>> count_ops[] = {
      std::make_pair("var global = 100;function f(){ return ++global; }",
                     handle(Smi::FromInt(101), i_isolate())),
      std::make_pair("var global = 100; function f(){ return --global; }",
                     handle(Smi::FromInt(99), i_isolate())),
      std::make_pair("var global = 100; function f(){ return global++; }",
                     handle(Smi::FromInt(100), i_isolate())),
      std::make_pair("unallocated = 200; function f(){ return ++unallocated; }",
                     handle(Smi::FromInt(201), i_isolate())),
      std::make_pair("unallocated = 200; function f(){ return --unallocated; }",
                     handle(Smi::FromInt(199), i_isolate())),
      std::make_pair("unallocated = 200; function f(){ return unallocated++; }",
                     handle(Smi::FromInt(200), i_isolate())),
  };

  for (size_t i = 0; i < arraysize(count_ops); i++) {
    InterpreterTester tester(i_isolate(), count_ops[i].first);
    auto callable = tester.GetCallable<>();

    DirectHandle<i::Object> return_value = callable().ToHandleChecked();
    CHECK(Object::SameValue(*return_value, *count_ops[i].second));
  }
}

TEST_F(InterpreterTest, InterpreterCompoundExpressions) {
  Factory* factory = i_isolate()->factory();

  std::pair<const char*, Handle<Object>> compound_expr[] = {
      std::make_pair("var a = 1; a += 2; return a;",
                     Handle<Object>(Smi::FromInt(3), i_isolate())),
      std::make_pair("var a = 10; a /= 2; return a;",
                     Handle<Object>(Smi::FromInt(5), i_isolate())),
      std::make_pair("var a = 'test'; a += 'ing'; return a;",
                     factory->NewStringFromStaticChars("testing")),
      std::make_pair("var a = { val: 2 }; a.val *= 2; return a.val;",
                     Handle<Object>(Smi::FromInt(4), i_isolate())),
      std::make_pair("var a = 1; (function f() { a = 2; })(); a += 24;"
                     "return a;",
                     Handle<Object>(Smi::FromInt(26), i_isolate())),
  };

  for (size_t i = 0; i < arraysize(compound_expr); i++) {
    std::string source(
        InterpreterTester::SourceForBody(compound_expr[i].first));
    InterpreterTester tester(i_isolate(), source.c_str());
    auto callable = tester.GetCallable<>();

    DirectHandle<i::Object> return_value = callable().ToHandleChecked();
    CHECK(Object::SameValue(*return_value, *compound_expr[i].second));
  }
}

TEST_F(InterpreterTest, InterpreterGlobalCompoundExpressions) {
  std::pair<const char*, Handle<Object>> compound_expr[2] = {
      std::make_pair("var global = 100;"
                     "function f() { global += 20; return global; }",
                     Handle<Object>(Smi::FromInt(120), i_isolate())),
      std::make_pair("unallocated = 100;"
                     "function f() { unallocated -= 20; return unallocated; }",
                     Handle<Object>(Smi::FromInt(80), i_isolate())),
  };

  for (size_t i = 0; i < arraysize(compound_expr); i++) {
    InterpreterTester tester(i_isolate(), compound_expr[i].first);
    auto callable = tester.GetCallable<>();

    DirectHandle<i::Object> return_value = callable().ToHandleChecked();
    CHECK(Object::SameValue(*return_value, *compound_expr[i].second));
  }
}

TEST_F(InterpreterTest, InterpreterCreateArguments) {
  Factory* factory = i_isolate()->factory();

  std::pair<const char*, int> create_args[] = {
      std::make_pair("function f() { return arguments[0]; }", 0),
      std::make_pair("function f(a) { return arguments[0]; }", 0),
      std::make_pair("function f() { return arguments[2]; }", 2),
      std::make_pair("function f(a) { return arguments[2]; }", 2),
      std::make_pair("function f(a, b, c, d) { return arguments[2]; }", 2),
      std::make_pair("function f(a) {"
                     "'use strict'; return arguments[0]; }",
                     0),
      std::make_pair("function f(a, b, c, d) {"
                     "'use strict'; return arguments[2]; }",
                     2),
      // Check arguments are mapped in sloppy mode and unmapped in strict.
      std::make_pair("function f(a, b, c, d) {"
                     "  c = b; return arguments[2]; }",
                     1),
      std::make_pair("function f(a, b, c, d) {"
                     "  'use strict'; c = b; return arguments[2]; }",
                     2),
      // Check arguments for duplicate parameters in sloppy mode.
      std::make_pair("function f(a, a, b) { return arguments[1]; }", 1),
      // check rest parameters
      std::make_pair("function f(...restArray) { return restArray[0]; }", 0),
      std::make_pair("function f(a, ...restArray) { return restArray[0]; }", 1),
      std::make_pair("function f(a, ...restArray) { return arguments[0]; }", 0),
      std::make_pair("function f(a, ...restArray) { return arguments[1]; }", 1),
      std::make_pair("function f(a, ...restArray) { return restArray[1]; }", 2),
      std::make_pair("function f(a, ...arguments) { return arguments[0]; }", 1),
      std::make_pair("function f(a, b, ...restArray) { return restArray[0]; }",
                     2),
  };

  // Test passing no arguments.
  for (size_t i = 0; i < arraysize(create_args); i++) {
    InterpreterTester tester(i_isolate(), create_args[i].first);
    auto callable = tester.GetCallable<>();
    Handle<Object> return_val = callable().ToHandleChecked();
    CHECK(return_val.is_identical_to(factory->undefined_value()));
  }

  // Test passing one argument.
  for (size_t i = 0; i < arraysize(create_args); i++) {
    InterpreterTester tester(i_isolate(), create_args[i].first);
    auto callable = tester.GetCallable<Handle<Object>>();
    Handle<Object> return_val =
        callable(handle(Smi::FromInt(40), i_isolate())).ToHandleChecked();
    if (create_args[i].second == 0) {
      CHECK_EQ(Cast<Smi>(*return_val), Smi::FromInt(40));
    } else {
      CHECK(return_val.is_identical_to(factory->undefined_value()));
    }
  }

  // Test passing three argument.
  for (size_t i = 0; i < arraysize(create_args); i++) {
    Handle<Object> args[3] = {
        handle(Smi::FromInt(40), i_isolate()),
        handle(Smi::FromInt(60), i_isolate()),
        handle(Smi::FromInt(80), i_isolate()),
    };

    InterpreterTester tester(i_isolate(), create_args[i].first);
    auto callable =
        tester.GetCallable<Handle<Object>, Handle<Object>, Handle<Object>>();
    DirectHandle<Object> return_val =
        callable(args[0], args[1], args[2]).ToHandleChecked();
    CHECK(Object::SameValue(*return_val, *args[create_args[i].second]));
  }
}

TEST_F(InterpreterTest, InterpreterConditional) {
  std::pair<const char*, Handle<Object>> conditional[] = {
      std::make_pair("return true ? 2 : 3;",
                     handle(Smi::FromInt(2), i_isolate())),
      std::make_pair("return false ? 2 : 3;",
                     handle(Smi::FromInt(3), i_isolate())),
      std::make_pair("var a = 1; return a ? 20 : 30;",
                     handle(Smi::FromInt(20), i_isolate())),
      std::make_pair("var a = 1; return a ? 20 : 30;",
                     handle(Smi::FromInt(20), i_isolate())),
      std::make_pair("var a = 'string'; return a ? 20 : 30;",
                     handle(Smi::FromInt(20), i_isolate())),
      std::make_pair("var a = undefined; return a ? 20 : 30;",
                     handle(Smi::FromInt(30), i_isolate())),
      std::make_pair("return 1 ? 2 ? 3 : 4 : 5;",
                     handle(Smi::FromInt(3), i_isolate())),
      std::make_pair("return 0 ? 2 ? 3 : 4 : 5;",
                     handle(Smi::FromInt(5), i_isolate())),
  };

  for (size_t i = 0; i < arraysize(conditional); i++) {
    std::string source(InterpreterTester::SourceForBody(conditional[i].first));
    InterpreterTester tester(i_isolate(), source.c_str());
    auto callable = tester.GetCallable<>();

    DirectHandle<i::Object> return_value = callable().ToHandleChecked();
    CHECK(Object::SameValue(*return_value, *conditional[i].second));
  }
}

TEST_F(InterpreterTest, InterpreterDelete) {
  Factory* factory = i_isolate()->factory();

  // Tests for delete for local variables that work both in strict
  // and sloppy modes
  std::pair<const char*, Handle<Object>> test_delete[] = {
      std::make_pair(
          "var a = { x:10, y:'abc', z:30.2}; delete a.x; return a.x;\n",
          factory->undefined_value()),
      std::make_pair(
          "var b = { x:10, y:'abc', z:30.2}; delete b.x; return b.y;\n",
          factory->NewStringFromStaticChars("abc")),
      std::make_pair("var c = { x:10, y:'abc', z:30.2}; var d = c; delete d.x; "
                     "return c.x;\n",
                     factory->undefined_value()),
      std::make_pair("var e = { x:10, y:'abc', z:30.2}; var g = e; delete g.x; "
                     "return e.y;\n",
                     factory->NewStringFromStaticChars("abc")),
      std::make_pair("var a = { x:10, y:'abc', z:30.2};\n"
                     "var b = a;"
                     "delete b.x;"
                     "return b.x;\n",
                     factory->undefined_value()),
      std::make_pair("var a = {1:10};\n"
                     "(function f1() {return a;});"
                     "return delete a[1];",
                     factory->ToBoolean(true)),
      std::make_pair("return delete this;", factory->ToBoolean(true)),
      std::make_pair("return delete 'test';", factory->ToBoolean(true))};

  // Test delete in sloppy mode
  for (size_t i = 0; i < arraysize(test_delete); i++) {
    std::string source(InterpreterTester::SourceForBody(test_delete[i].first));
    InterpreterTester tester(i_isolate(), source.c_str());
    auto callable = tester.GetCallable<>();

    DirectHandle<i::Object> return_value = callable().ToHandleChecked();
    CHECK(Object::SameValue(*return_value, *test_delete[i].second));
  }

  // Test delete in strict mode
  for (size_t i = 0; i < arraysize(test_delete); i++) {
    std::string strict_test =
        "'use strict'; " + std::string(test_delete[i].first);
    std::string source(InterpreterTester::SourceForBody(strict_test.c_str()));
    InterpreterTester tester(i_isolate(), source.c_str());
    auto callable = tester.GetCallable<>();

    DirectHandle<i::Object> return_value = callable().ToHandleChecked();
    CHECK(Object::SameValue(*return_value, *test_delete[i].second));
  }
}

TEST_F(InterpreterTest, InterpreterDeleteSloppyUnqualifiedIdentifier) {
  Factory* factory = i_isolate()->factory();

  // These tests generate a syntax error for strict mode. We don't
  // test for it here.
  std::pair<const char*, Handle<Object>> test_delete[] = {
      std::make_pair("var sloppy_a = { x:10, y:'abc'};\n"
                     "var sloppy_b = delete sloppy_a;\n"
                     "if (delete sloppy_a) {\n"
                     "  return undefined;\n"
                     "} else {\n"
                     "  return sloppy_a.x;\n"
                     "}\n",
                     Handle<Object>(Smi::FromInt(10), i_isolate())),
      // TODO(mythria) When try-catch is implemented change the tests to check
      // if delete actually deletes
      std::make_pair("sloppy_a = { x:10, y:'abc'};\n"
                     "var sloppy_b = delete sloppy_a;\n"
                     // "try{return a.x;} catch(e) {return b;}\n"
                     "return sloppy_b;",
                     factory->ToBoolean(true)),
      std::make_pair("sloppy_a = { x:10, y:'abc'};\n"
                     "var sloppy_b = delete sloppy_c;\n"
                     "return sloppy_b;",
                     factory->ToBoolean(true))};

  for (size_t i = 0; i < arraysize(test_delete); i++) {
    std::string source(InterpreterTester::SourceForBody(test_delete[i].first));
    InterpreterTester tester(i_isolate(), source.c_str());
    auto callable = tester.GetCallable<>();

    DirectHandle<i::Object> return_value = callable().ToHandleChecked();
    CHECK(Object::SameValue(*return_value, *test_delete[i].second));
  }
}

TEST_F(InterpreterTest, InterpreterGlobalDelete) {
  Factory* factory = i_isolate()->factory();

  std::pair<const char*, Handle<Object>> test_global_delete[] = {
      std::make_pair("var a = { x:10, y:'abc', z:30.2 };\n"
                     "function f() {\n"
                     "  delete a.x;\n"
                     "  return a.x;\n"
                     "}\n"
                     "f();\n",
                     factory->undefined_value()),
      std::make_pair("var b = {1:10, 2:'abc', 3:30.2 };\n"
                     "function f() {\n"
                     "  delete b[2];\n"
                     "  return b[1];\n"
                     " }\n"
                     "f();\n",
                     Handle<Object>(Smi::FromInt(10), i_isolate())),
      std::make_pair("var c = { x:10, y:'abc', z:30.2 };\n"
                     "function f() {\n"
                     "   var d = c;\n"
                     "   delete d.y;\n"
                     "   return d.x;\n"
                     "}\n"
                     "f();\n",
                     Handle<Object>(Smi::FromInt(10), i_isolate())),
      std::make_pair("e = { x:10, y:'abc' };\n"
                     "function f() {\n"
                     "  return delete e;\n"
                     "}\n"
                     "f();\n",
                     factory->ToBoolean(true)),
      std::make_pair("var g = { x:10, y:'abc' };\n"
                     "function f() {\n"
                     "  return delete g;\n"
                     "}\n"
                     "f();\n",
                     factory->ToBoolean(false)),
      std::make_pair("function f() {\n"
                     "  var obj = {h:10, f1() {return delete this;}};\n"
                     "  return obj.f1();\n"
                     "}\n"
                     "f();",
                     factory->ToBoolean(true)),
      std::make_pair("function f() {\n"
                     "  var obj = {h:10,\n"
                     "             f1() {\n"
                     "              'use strict';\n"
                     "              return delete this.h;}};\n"
                     "  return obj.f1();\n"
                     "}\n"
                     "f();",
                     factory->ToBoolean(true))};

  for (size_t i = 0; i < arraysize(test_global_delete); i++) {
    InterpreterTester tester(i_isolate(), test_global_delete[i].first);
    auto callable = tester.GetCallable<>();

    DirectHandle<i::Object> return_value = callable().ToHandleChecked();
    CHECK(Object::SameValue(*return_value, *test_global_delete[i].second));
  }
}

TEST_F(InterpreterTest, InterpreterBasicLoops) {
  Factory* factory = i_isolate()->factory();

  std::pair<const char*, Handle<Object>> loops[] = {
      std::make_pair("var a = 10; var b = 1;\n"
                     "while (a) {\n"
                     "  b = b * 2;\n"
                     "  a = a - 1;\n"
                     "};\n"
                     "return b;\n",
                     factory->NewHeapNumber(1024)),
      std::make_pair("var a = 1; var b = 1;\n"
                     "do {\n"
                     "  b = b * 2;\n"
                     "  --a;\n"
                     "} while(a);\n"
                     "return b;\n",
                     handle(Smi::FromInt(2), i_isolate())),
      std::make_pair("var b = 1;\n"
                     "for ( var a = 10; a; a--) {\n"
                     "  b *= 2;\n"
                     "}\n"
                     "return b;",
                     factory->NewHeapNumber(1024)),
      std::make_pair("var a = 10; var b = 1;\n"
                     "while (a > 0) {\n"
                     "  b = b * 2;\n"
                     "  a = a - 1;\n"
                     "};\n"
                     "return b;\n",
                     factory->NewHeapNumber(1024)),
      std::make_pair("var a = 1; var b = 1;\n"
                     "do {\n"
                     "  b = b * 2;\n"
                     "  --
"""


```
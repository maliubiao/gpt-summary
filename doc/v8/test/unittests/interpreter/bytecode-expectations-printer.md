Response:
Let's break down the thought process for analyzing this C++ code.

1. **Initial Understanding of the File Path:** The path `v8/test/unittests/interpreter/bytecode-expectations-printer.cc` immediately suggests this is a *testing* utility within the *interpreter* component of V8, specifically dealing with *bytecode*. The "expectations-printer" part hints at its purpose: generating expected bytecode output for tests.

2. **Scanning the Includes:**  The `#include` directives provide crucial clues about the file's functionality:
    * `<iomanip>`, `<iostream>`, `<vector>`: Standard C++ libraries for formatting output, input/output streams, and dynamic arrays.
    * `"include/libplatform/libplatform.h"`, `"include/v8-function.h"`: Indicate interaction with the V8 API, likely for compiling and running JavaScript code.
    * `"src/api/api-inl.h"`, `"src/base/logging.h"`: Internal V8 API and logging facilities.
    * `"src/codegen/source-position-table.h"`:  Related to mapping bytecode instructions back to source code locations.
    * `"src/interpreter/..."`:  A suite of headers specifically for the interpreter, including bytecode structures, generation, and execution.
    * `"src/objects/..."`: Headers defining V8's object model (numbers, modules, etc.).
    * `"src/runtime/runtime.h"`: Access to V8's runtime functions.
    * `"src/utils/ostreams.h"`:  V8's output stream utilities.

3. **Namespace Identification:**  The code is within the `v8::internal::interpreter` namespace, confirming it's an internal part of V8's interpreter.

4. **Static Data Exploration:**  The static constants `NameForNativeContextIntrinsicIndex`, `kDefaultTopFunctionName`, and `kIndent` suggest formatting and naming conventions within the printer. The switch statement in `NameForNativeContextIntrinsicIndex` maps internal indices to string representations, useful for debugging bytecode.

5. **Method-by-Method Analysis (Key Functions):**  Focus on the core functionalities.

    * **`V8StringFromUTF8`:** Clearly converts C-style strings to V8's `v8::String` type. This is fundamental for interacting with the V8 API.
    * **`WrapCodeInFunction`:**  Indicates this utility can wrap snippets of JavaScript code within a function. This is common in testing to create a controlled execution environment.
    * **`CompileScript` and `CompileModule`:**  These are V8 API calls for compiling JavaScript code (as a script or a module) into an executable form.
    * **`Run`:** Executes a compiled script.
    * **`GetBytecodeArrayFor...` functions:** These are the *core* functions. They retrieve the generated bytecode array from different V8 structures (global function, module, script, and even the result of executing a script that returns a function). This confirms the primary purpose: extracting bytecode.
    * **`PrintEscapedString`:** Handles special characters in strings for output, suggesting the output is likely intended for a format like a string literal in a test file.
    * **`PrintBytecodeOperand`:**  Deciphers and formats the operands of bytecode instructions, considering different operand types and sizes. This is where the detailed bytecode inspection happens.
    * **`PrintBytecode`:**  Formats a single bytecode instruction with its operands.
    * **`PrintSourcePosition`:**  Integrates source code location information into the output, useful for understanding the mapping between source and bytecode.
    * **`PrintV8String` and `PrintConstant`:**  Format different types of V8 values (strings and constants) for output.
    * **`PrintFrameSize`:** Prints information about the stack frame used by the bytecode.
    * **`PrintBytecodeSequence`:** Iterates through the bytecode array and prints each instruction.
    * **`PrintConstantPool`:** Prints the constant pool associated with the bytecode array.
    * **`PrintCodeSnippet`:** Prints the original JavaScript code snippet.
    * **`PrintHandlers`:**  Deals with exception handling information in the bytecode.
    * **`PrintBytecodeArray`:**  Combines the printing of frame size, bytecode sequence, constant pool, and handlers.
    * **`PrintExpectation`:**  This is the *main* function from a user perspective. It takes a JavaScript code snippet, compiles it, retrieves the bytecode, and formats the output. The conditional logic for `module_`, `print_callee_`, and `top_level_` suggests different modes of operation for the printer.

6. **Inferring the Overall Functionality:** Based on the individual function analysis, the core purpose becomes clear:  `bytecode-expectations-printer.cc` is a utility to generate human-readable representations of the bytecode generated by the V8 JavaScript engine for given code snippets. This output is likely used in V8's testing infrastructure to verify that the bytecode generated for specific JavaScript code matches the expected bytecode.

7. **Addressing Specific Questions:** Now, armed with a good understanding, answer the specific questions from the prompt:

    * **Functionality:** Summarize the core purpose (generate bytecode expectations).
    * **`.tq` extension:** Explain that `.tq` indicates Torque (V8's internal type system) and that this file is `.cc`, so it's C++.
    * **Relationship to JavaScript:** Explain the connection (compiles and inspects bytecode of JS code) and provide JavaScript examples illustrating how different JS code leads to different bytecode.
    * **Code Logic Inference:** Focus on `PrintBytecodeOperand` as the most logical place for this, provide a simple bytecode example and trace its formatting.
    * **Common Programming Errors:**  Think about how unexpected bytecode *could* arise from user errors and provide relevant JavaScript examples (typos, scope issues, etc.). The connection here is that this tool helps *catch* those errors in V8's implementation by ensuring consistent bytecode generation.

By following this structured approach – understanding the file path, examining includes, analyzing key functions, and inferring the overall purpose – we can effectively understand even relatively complex code like this. The key is to build up the understanding incrementally.
`v8/test/unittests/interpreter/bytecode-expectations-printer.cc` 是一个 V8 源代码文件，其主要功能是**生成给定 JavaScript 代码片段的字节码表示，用于 V8 解释器单元测试的预期结果。**  换句话说，它是一个工具，可以让你看到 V8 引擎是如何将你的 JavaScript 代码转换为字节码指令的，并将这些指令以一种易于比较和验证的格式输出。

让我们更详细地分解它的功能：

**核心功能:**

1. **编译 JavaScript 代码:** 它使用 V8 的 API 来编译给定的 JavaScript 代码片段。这包括将代码解析成抽象语法树 (AST)，然后生成解释器可以执行的字节码。

2. **提取字节码:** 编译后，它会从生成的函数或脚本中提取字节码数组。

3. **格式化输出字节码:**  它将提取的字节码数组以人类可读的格式打印出来，包括：
    * **帧大小 (frame size):**  函数执行时所需的栈帧大小。
    * **字节码序列 (bytecode sequence):**  实际的字节码指令列表，每个指令都带有助记符和操作数。
    * **常量池 (constant pool):**  代码中使用的常量值，例如字符串、数字等。
    * **异常处理表 (handlers):**  定义了 try-catch 块的范围和处理程序入口点。
    * **源代码位置 (source position):** 将字节码指令映射回原始源代码的位置。

4. **支持不同的代码上下文:** 它可以处理顶层脚本、函数内部的代码，以及模块代码。

5. **生成预期结果:**  其主要目的是生成单元测试中用于验证字节码生成的“期望”输出。通过比较实际生成的字节码和预期的字节码，可以确保 V8 解释器的正确性。

**关于文件扩展名 `.tq`:**

如果 `v8/test/unittests/interpreter/bytecode-expectations-printer.cc` 以 `.tq` 结尾，那么它确实是 **V8 Torque 源代码**。 Torque 是 V8 用于实现其内置函数和某些运行时功能的领域特定语言。但是，根据你提供的代码内容，这个文件是以 `.cc` 结尾的，所以它是 **C++ 源代码**。

**与 JavaScript 的关系 (及 JavaScript 示例):**

这个 C++ 文件的功能是直接与 JavaScript 相关的，因为它处理的是 JavaScript 代码的字节码表示。你可以用它来观察不同的 JavaScript 代码是如何被编译成不同的字节码序列的。

**JavaScript 示例:**

假设我们有以下 JavaScript 代码片段：

```javascript
function add(a, b) {
  return a + b;
}
add(1, 2);
```

使用 `bytecode-expectations-printer.cc`，我们可以期望得到类似以下的字节码输出 (简化版，实际输出会更详细):

```
-- -
snippet: "
function add(a, b) {
  return a + b;
}
add(1, 2);
"
frame size: 3
parameter count: 2
bytecode array length: 10
bytecodes: [
  /*    0 E> */ B(Ldar), R(arg0),
  /*    2 E> */ B(Star), R(0),
  /*    4 E> */ B(Ldar), R(arg1),
  /*    6 E> */ B(Star), R(1),
  /*    8 E> */ B(Ldar), R(0),
  /*   10 E> */ B(Add), R(1),
  /*   12 E> */ B(Return),
  /*   14 E> */ B(LdaSmi), I8(1),
  /*   16 E> */ B(Star), R(0),
  /*   18 E> */ B(LdaSmi), I8(2),
  /*   20 E> */ B(CallRuntime), U16(Runtime::kAdd), R(0), U8(2),
  /*   24 E> */ B(Pop), R(0),
  /*   26 S> */ B(LdaUndefined),
  /*   28 S> */ B(Return),
]
constant pool: [
]
handlers: [
]
```

**解释:**

* `Ldar R(arg0)`: 将参数 `a` 加载到累加器寄存器。
* `Star R(0)`: 将累加器寄存器的值存储到局部寄存器 `R(0)`。
* `Add R(1)`: 将局部寄存器 `R(1)` 的值（参数 `b`）与累加器寄存器的值相加。
* `Return`: 返回累加器寄存器的值。
* `LdaSmi I8(1)`: 加载小的整数值 `1`。
* `CallRuntime U16(Runtime::kAdd), R(0), U8(2)`: 调用运行时函数 `Add`，传入参数。

**代码逻辑推理 (假设输入与输出):**

假设我们有以下 JavaScript 代码片段：

```javascript
let x = 10;
console.log(x);
```

**预期输入 (传递给 `PrintExpectation` 函数的 `snippet`):**

```
let x = 10;
console.log(x);
```

**可能的输出 (简化版):**

```
-- -
snippet: "
let x = 10;
console.log(x);
"
frame size: 1
parameter count: 0
bytecode array length: 8
bytecodes: [
  /*    0 S> */ B(LdaSmi), I8(10),
  /*    2 S> */ B(StarGlobal), U32(0), U8(0),
  /*    6 S> */ B(LdaGlobal), U32(1), U8(0),
  /*   10 S> */ B(PushContext), R(context),
  /*   12 S> */ B(LdaGlobal), U32(2), U8(0),
  /*   16 S> */ B(CallProperty1), R(closure), R(0), U8(0),
  /*   20 S> */ B(PopContext), R(context),
  /*   22 S> */ B(LdaUndefined),
  /*   24 S> */ B(Return),
]
constant pool: [
  String ["x"],
  String ["console"],
  String ["log"]
]
handlers: [
]
```

**解释:**

* `LdaSmi I8(10)`: 加载小的整数值 10。
* `StarGlobal U32(0), U8(0)`: 将累加器中的值存储到全局变量，索引为 0 (对应常量池中的 "x")。
* `LdaGlobal U32(1), U8(0)`: 加载全局变量，索引为 1 (对应常量池中的 "console")。
* `CallProperty1`: 调用对象的属性方法（这里是 `console.log`）。

**涉及用户常见的编程错误 (及示例):**

虽然 `bytecode-expectations-printer.cc` 的主要功能不是直接检测用户编程错误，但它可以帮助理解 V8 如何处理这些错误，或者揭示一些潜在的性能问题。

**示例 1:  未声明的变量**

```javascript
function test() {
  y = 5; // 忘记使用 'let', 'const', 或 'var'
  return y;
}
test();
```

字节码输出可能会显示对全局对象的访问，因为 `y` 被隐式地创建为全局变量。 这可以帮助理解 JavaScript 的作用域规则。

**示例 2:  错误的类型操作**

```javascript
function multiply(a, b) {
  return a * b;
}
multiply("hello", 5);
```

字节码输出可能会显示类型转换或运行时检查，因为 V8 需要处理字符串和数字相乘的情况。 这可以帮助理解 JavaScript 的动态类型特性。

**总结:**

`v8/test/unittests/interpreter/bytecode-expectations-printer.cc` 是一个 V8 内部的强大工具，用于理解 JavaScript 代码如何被编译成字节码。 它对于 V8 开发人员进行单元测试、调试和性能分析至关重要。虽然普通 JavaScript 开发人员不需要直接使用它，但理解其功能可以帮助更深入地了解 JavaScript 引擎的工作原理。

### 提示词
```
这是目录为v8/test/unittests/interpreter/bytecode-expectations-printer.cc的一个v8源代码， 请列举一下它的功能, 
如果v8/test/unittests/interpreter/bytecode-expectations-printer.cc以.tq结尾，那它是个v8 torque源代码，
如果它与javascript的功能有关系，请用javascript举例说明,
如果有代码逻辑推理，请给出假设输入与输出，
如果涉及用户常见的编程错误，请举例说明
```

### 源代码
```
// Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "test/unittests/interpreter/bytecode-expectations-printer.h"

#include <iomanip>
#include <iostream>
#include <vector>

#include "include/libplatform/libplatform.h"
#include "include/v8-function.h"
#include "src/api/api-inl.h"
#include "src/base/logging.h"
#include "src/codegen/source-position-table.h"
#include "src/interpreter/bytecode-array-iterator.h"
#include "src/interpreter/bytecode-generator.h"
#include "src/interpreter/bytecodes.h"
#include "src/interpreter/interpreter-intrinsics.h"
#include "src/interpreter/interpreter.h"
#include "src/objects/heap-number-inl.h"
#include "src/objects/module-inl.h"
#include "src/objects/objects-inl.h"
#include "src/runtime/runtime.h"
#include "src/utils/ostreams.h"

namespace v8 {
namespace internal {
namespace interpreter {

static const char* NameForNativeContextIntrinsicIndex(uint32_t idx) {
  switch (idx) {
    case Context::REFLECT_APPLY_INDEX:
      return "reflect_apply";
    case Context::REFLECT_CONSTRUCT_INDEX:
      return "reflect_construct";
    default:
      return "UnknownIntrinsicIndex";
  }
}

// static
const char* const BytecodeExpectationsPrinter::kDefaultTopFunctionName =
    "__genbckexp_wrapper__";
const char* const BytecodeExpectationsPrinter::kIndent = "  ";

v8::Local<v8::String> BytecodeExpectationsPrinter::V8StringFromUTF8(
    const char* data) const {
  return v8::String::NewFromUtf8(isolate_, data).ToLocalChecked();
}

std::string BytecodeExpectationsPrinter::WrapCodeInFunction(
    const char* function_name, const std::string& function_body) const {
  std::ostringstream program_stream;
  program_stream << "function " << function_name << "() {" << function_body
                 << "}\n"
                 << function_name << "();";

  return program_stream.str();
}

v8::Local<v8::Script> BytecodeExpectationsPrinter::CompileScript(
    const char* program) const {
  v8::Local<v8::String> source = V8StringFromUTF8(program);
  return v8::Script::Compile(isolate_->GetCurrentContext(), source)
      .ToLocalChecked();
}

v8::Local<v8::Module> BytecodeExpectationsPrinter::CompileModule(
    const char* program) const {
  ScriptOrigin origin(Local<v8::Value>(), 0, 0, false, -1, Local<v8::Value>(),
                      false, false, true);
  v8::ScriptCompiler::Source source(V8StringFromUTF8(program), origin);
  return v8::ScriptCompiler::CompileModule(isolate_, &source).ToLocalChecked();
}

void BytecodeExpectationsPrinter::Run(v8::Local<v8::Script> script) const {
  MaybeLocal<Value> result = script->Run(isolate_->GetCurrentContext());
  USE(result);
}

i::Handle<v8::internal::BytecodeArray>
BytecodeExpectationsPrinter::GetBytecodeArrayForGlobal(
    const char* global_name) const {
  const v8::Local<v8::Context>& context = isolate_->GetCurrentContext();
  v8::Local<v8::String> v8_global_name = V8StringFromUTF8(global_name);
  v8::Local<v8::Function> function = v8::Local<v8::Function>::Cast(
      context->Global()->Get(context, v8_global_name).ToLocalChecked());
  i::DirectHandle<i::JSFunction> js_function =
      i::Cast<i::JSFunction>(v8::Utils::OpenDirectHandle(*function));

  i::Handle<i::BytecodeArray> bytecodes = i::handle(
      js_function->shared()->GetBytecodeArray(i_isolate()), i_isolate());

  return bytecodes;
}

i::Handle<i::BytecodeArray>
BytecodeExpectationsPrinter::GetBytecodeArrayForModule(
    v8::Local<v8::Module> module) const {
  i::Handle<i::Module> i_module = v8::Utils::OpenHandle(*module);
  return i::handle(
      Cast<SharedFunctionInfo>(Cast<i::SourceTextModule>(i_module)->code())
          ->GetBytecodeArray(i_isolate()),
      i_isolate());
}

i::Handle<i::BytecodeArray>
BytecodeExpectationsPrinter::GetBytecodeArrayForScript(
    v8::Local<v8::Script> script) const {
  i::DirectHandle<i::JSFunction> js_function =
      v8::Utils::OpenDirectHandle(*script);
  return i::handle(js_function->shared()->GetBytecodeArray(i_isolate()),
                   i_isolate());
}

i::Handle<i::BytecodeArray>
BytecodeExpectationsPrinter::GetBytecodeArrayOfCallee(
    const char* source_code) const {
  Local<v8::Context> context = isolate_->GetCurrentContext();
  Local<v8::Script> script =
      v8::Script::Compile(
          context,
          v8::String::NewFromUtf8(isolate_, source_code).ToLocalChecked())
          .ToLocalChecked();
  i::Handle<i::Object> i_object =
      v8::Utils::OpenHandle(*script->Run(context).ToLocalChecked());
  i::DirectHandle<i::JSFunction> js_function = i::Cast<i::JSFunction>(i_object);
  CHECK(js_function->shared()->HasBytecodeArray());
  return i::handle(js_function->shared()->GetBytecodeArray(i_isolate()),
                   i_isolate());
}

void BytecodeExpectationsPrinter::PrintEscapedString(
    std::ostream* stream, const std::string& string) const {
  for (char c : string) {
    switch (c) {
      case '"':
        *stream << "\\\"";
        break;
      case '\\':
        *stream << "\\\\";
        break;
      default:
        *stream << c;
        break;
    }
  }
}

void BytecodeExpectationsPrinter::PrintBytecodeOperand(
    std::ostream* stream, const BytecodeArrayIterator& bytecode_iterator,
    const Bytecode& bytecode, int op_index, int parameter_count) const {
  OperandType op_type = Bytecodes::GetOperandType(bytecode, op_index);
  OperandSize op_size = Bytecodes::GetOperandSize(
      bytecode, op_index, bytecode_iterator.current_operand_scale());

  const char* size_tag;
  switch (op_size) {
    case OperandSize::kByte:
      size_tag = "8";
      break;
    case OperandSize::kShort:
      size_tag = "16";
      break;
    case OperandSize::kQuad:
      size_tag = "32";
      break;
    default:
      UNREACHABLE();
  }

  if (Bytecodes::IsRegisterOperandType(op_type)) {
    Register register_value = bytecode_iterator.GetRegisterOperand(op_index);
    *stream << 'R';
    if (op_size != OperandSize::kByte) *stream << size_tag;
    if (register_value.is_current_context()) {
      *stream << "(context)";
    } else if (register_value.is_function_closure()) {
      *stream << "(closure)";
    } else if (register_value.is_parameter()) {
      int parameter_index = register_value.ToParameterIndex();
      if (parameter_index == 0) {
        *stream << "(this)";
      } else {
        *stream << "(arg" << (parameter_index - 1) << ')';
      }
    } else {
      *stream << '(' << register_value.index() << ')';
    }
  } else {
    switch (op_type) {
      case OperandType::kFlag8:
        *stream << 'U' << size_tag << '(';
        *stream << bytecode_iterator.GetFlag8Operand(op_index);
        break;
      case OperandType::kFlag16:
        *stream << 'U' << size_tag << '(';
        *stream << bytecode_iterator.GetFlag16Operand(op_index);
        break;
      case OperandType::kIdx: {
        *stream << 'U' << size_tag << '(';
        *stream << bytecode_iterator.GetIndexOperand(op_index);
        break;
      }
      case OperandType::kUImm:
        *stream << 'U' << size_tag << '(';
        *stream << bytecode_iterator.GetUnsignedImmediateOperand(op_index);
        break;
      case OperandType::kImm:
        *stream << 'I' << size_tag << '(';
        *stream << bytecode_iterator.GetImmediateOperand(op_index);
        break;
      case OperandType::kRegCount:
        *stream << 'U' << size_tag << '(';
        *stream << bytecode_iterator.GetRegisterCountOperand(op_index);
        break;
      case OperandType::kRuntimeId: {
        *stream << 'U' << size_tag << '(';
        Runtime::FunctionId id =
            bytecode_iterator.GetRuntimeIdOperand(op_index);
        *stream << "Runtime::k" << i::Runtime::FunctionForId(id)->name;
        break;
      }
      case OperandType::kIntrinsicId: {
        *stream << 'U' << size_tag << '(';
        Runtime::FunctionId id =
            bytecode_iterator.GetIntrinsicIdOperand(op_index);
        *stream << "Runtime::k" << i::Runtime::FunctionForId(id)->name;
        break;
      }
      case OperandType::kNativeContextIndex: {
        *stream << 'U' << size_tag << '(';
        uint32_t idx = bytecode_iterator.GetNativeContextIndexOperand(op_index);
        *stream << "%" << NameForNativeContextIntrinsicIndex(idx);
        break;
      }
      default:
        UNREACHABLE();
    }

    *stream << ')';
  }
}

void BytecodeExpectationsPrinter::PrintBytecode(
    std::ostream* stream, const BytecodeArrayIterator& bytecode_iterator,
    int parameter_count) const {
  Bytecode bytecode = bytecode_iterator.current_bytecode();
  OperandScale operand_scale = bytecode_iterator.current_operand_scale();
  if (Bytecodes::OperandScaleRequiresPrefixBytecode(operand_scale)) {
    Bytecode prefix = Bytecodes::OperandScaleToPrefixBytecode(operand_scale);
    *stream << "B(" << Bytecodes::ToString(prefix) << "), ";
  }
  *stream << "B(" << Bytecodes::ToString(bytecode) << ')';
  int operands_count = Bytecodes::NumberOfOperands(bytecode);
  for (int op_index = 0; op_index < operands_count; ++op_index) {
    *stream << ", ";
    PrintBytecodeOperand(stream, bytecode_iterator, bytecode, op_index,
                         parameter_count);
  }
}

void BytecodeExpectationsPrinter::PrintSourcePosition(
    std::ostream* stream, SourcePositionTableIterator* source_iterator,
    int bytecode_offset) const {
  static const size_t kPositionWidth = 4;
  if (!source_iterator->done() &&
      source_iterator->code_offset() == bytecode_offset) {
    *stream << "/* " << std::setw(kPositionWidth)
            << source_iterator->source_position().ScriptOffset();
    if (source_iterator->is_statement()) {
      *stream << " S> */ ";
    } else {
      *stream << " E> */ ";
    }
    source_iterator->Advance();
  } else {
    *stream << "   " << std::setw(kPositionWidth) << ' ' << "       ";
  }
}

void BytecodeExpectationsPrinter::PrintV8String(
    std::ostream* stream, i::Tagged<i::String> string) const {
  *stream << '"';
  for (int i = 0, length = string->length(); i < length; ++i) {
    *stream << i::AsEscapedUC16ForJSON(string->Get(i));
  }
  *stream << '"';
}

void BytecodeExpectationsPrinter::PrintConstant(
    std::ostream* stream, i::DirectHandle<i::Object> constant) const {
  if (IsSmi(*constant)) {
    *stream << "Smi [";
    i::Smi::SmiPrint(i::Cast<i::Smi>(*constant), *stream);
    *stream << "]";
  } else {
    *stream << i::Cast<i::HeapObject>(*constant)->map()->instance_type();
    if (IsHeapNumber(*constant)) {
      *stream << " [";
      i::Cast<i::HeapNumber>(*constant)->HeapNumberShortPrint(*stream);
      *stream << "]";
    } else if (IsString(*constant)) {
      *stream << " [";
      PrintV8String(stream, i::Cast<i::String>(*constant));
      *stream << "]";
    }
  }
}

void BytecodeExpectationsPrinter::PrintFrameSize(
    std::ostream* stream,
    i::DirectHandle<i::BytecodeArray> bytecode_array) const {
  int32_t frame_size = bytecode_array->frame_size();

  DCHECK(IsAligned(frame_size, kSystemPointerSize));
  *stream << "frame size: " << frame_size / kSystemPointerSize
          << "\nparameter count: " << bytecode_array->parameter_count() << '\n';
}

void BytecodeExpectationsPrinter::PrintBytecodeSequence(
    std::ostream* stream, i::Handle<i::BytecodeArray> bytecode_array) const {
  *stream << "bytecode array length: " << bytecode_array->length()
          << "\nbytecodes: [\n";

  SourcePositionTableIterator source_iterator(
      bytecode_array->SourcePositionTable());
  BytecodeArrayIterator bytecode_iterator(bytecode_array);
  for (; !bytecode_iterator.done(); bytecode_iterator.Advance()) {
    *stream << kIndent;
    PrintSourcePosition(stream, &source_iterator,
                        bytecode_iterator.current_offset());
    PrintBytecode(stream, bytecode_iterator, bytecode_array->parameter_count());
    *stream << ",\n";
  }
  *stream << "]\n";
}

void BytecodeExpectationsPrinter::PrintConstantPool(
    std::ostream* stream, i::Tagged<i::TrustedFixedArray> constant_pool) const {
  *stream << "constant pool: [\n";
  int num_constants = constant_pool->length();
  if (num_constants > 0) {
    for (int i = 0; i < num_constants; ++i) {
      *stream << kIndent;
      PrintConstant(stream, handle(constant_pool->get(i), i_isolate()));
      *stream << ",\n";
    }
  }
  *stream << "]\n";
}

void BytecodeExpectationsPrinter::PrintCodeSnippet(
    std::ostream* stream, const std::string& body) const {
  *stream << "snippet: \"\n";
  std::stringstream body_stream(body);
  std::string body_line;
  while (std::getline(body_stream, body_line)) {
    *stream << kIndent;
    PrintEscapedString(stream, body_line);
    *stream << '\n';
  }
  *stream << "\"\n";
}

void BytecodeExpectationsPrinter::PrintHandlers(
    std::ostream* stream,
    i::DirectHandle<i::BytecodeArray> bytecode_array) const {
  *stream << "handlers: [\n";
  HandlerTable table(*bytecode_array);
  for (int i = 0, num_entries = table.NumberOfRangeEntries(); i < num_entries;
       ++i) {
    *stream << "  [" << table.GetRangeStart(i) << ", " << table.GetRangeEnd(i)
            << ", " << table.GetRangeHandler(i) << "],\n";
  }
  *stream << "]\n";
}

void BytecodeExpectationsPrinter::PrintBytecodeArray(
    std::ostream* stream, i::Handle<i::BytecodeArray> bytecode_array) const {
  PrintFrameSize(stream, bytecode_array);
  PrintBytecodeSequence(stream, bytecode_array);
  PrintConstantPool(stream, bytecode_array->constant_pool());
  PrintHandlers(stream, bytecode_array);
}

void BytecodeExpectationsPrinter::PrintExpectation(
    std::ostream* stream, const std::string& snippet) const {
  std::string source_code =
      wrap_ ? WrapCodeInFunction(test_function_name_.c_str(), snippet)
            : snippet;

  i::v8_flags.compilation_cache = false;
  i::Handle<i::BytecodeArray> bytecode_array;
  if (module_) {
    CHECK(top_level_ && !wrap_);
    v8::Local<v8::Module> module = CompileModule(source_code.c_str());
    bytecode_array = GetBytecodeArrayForModule(module);
  } else if (print_callee_) {
    bytecode_array = GetBytecodeArrayOfCallee(source_code.c_str());
  } else {
    v8::Local<v8::Script> script = CompileScript(source_code.c_str());
    if (top_level_) {
      bytecode_array = GetBytecodeArrayForScript(script);
    } else {
      Run(script);
      bytecode_array = GetBytecodeArrayForGlobal(test_function_name_.c_str());
    }
  }

  *stream << "---\n";
  PrintCodeSnippet(stream, snippet);
  PrintBytecodeArray(stream, bytecode_array);
  *stream << '\n';
}

}  // namespace interpreter
}  // namespace internal
}  // namespace v8
```
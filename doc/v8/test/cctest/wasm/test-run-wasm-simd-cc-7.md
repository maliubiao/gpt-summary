Response:
Let's break down the thought process for analyzing this V8 test file.

**1. Initial Scan and Keyword Recognition:**

* **File Path:** `v8/test/cctest/wasm/test-run-wasm-simd.cc`. Immediately signals this is a C++ test file within V8's Wasm (WebAssembly) testing framework. The "simd" part indicates it's specifically testing SIMD (Single Instruction, Multiple Data) instructions in Wasm.
* **`.cc` Extension:** Confirms it's C++ source code, *not* Torque (`.tq`).
* **`TEST(...)` Macros:**  These are a strong indicator of individual test cases. We can start counting them.
* **`WasmRunner`:** This class is likely a utility for setting up and running Wasm modules within the test environment. It's parameterized with return types and argument types.
* **`WASM_...` Macros (e.g., `WASM_LOCAL_GET`, `WASM_SIMD_LOAD_MEM`):** These are clearly macros representing Wasm instructions or operations. They are the core of the Wasm code being tested.
* **`CHECK_EQ(...)`:**  Standard C++ testing assertion macro, checking for equality.
* **`FOR_INT32_INPUTS`, `FOR_INT8_INPUTS`:** Macros likely used to iterate through various input values for testing.
* **`SKIP_TEST_IF_NO_TURBOSHAFT`:** This suggests tests are related to Turbofan, V8's optimizing compiler, and might be skipped if Turboshaft isn't enabled or applicable.
* **`EXPERIMENTAL_FLAG_SCOPE(revectorize)`:**  Indicates that the tests are related to a specific optimization called "revectorize," likely aimed at improving SIMD code generation.
* **`CpuFeatures::IsSupported(AVX2)`:**  Checks if the CPU supports AVX2 instructions, suggesting these tests target AVX2 SIMD capabilities.
* **`TSSimd256VerifyScope`:**  A custom scope likely used to verify that specific 256-bit SIMD instructions are generated by the compiler.

**2. Understanding the Overall Purpose:**

Based on the keywords, the primary function of this file is to test the execution of Wasm SIMD instructions within V8's Turbofan compiler, specifically focusing on the "revectorize" optimization and AVX2 support.

**3. Analyzing Individual Test Cases (General Approach):**

For each `TEST(...)` block:

* **Identify the Test Name:**  The name often gives a hint about the specific Wasm instruction or scenario being tested (e.g., `RunWasmTurbofan_I64x2ShiftLeft`).
* **Examine the `WasmRunner` Setup:** Note the input and output types. This tells you the function signature of the generated Wasm code.
* **Focus on the `r.Build({...})` Block:** This contains the sequence of Wasm instructions being tested. Try to decipher what operations are being performed. Look for patterns like loading from memory, performing SIMD operations, and storing back to memory.
* **Analyze the Input Generation (`FOR_..._INPUTS`):**  Understand the range of input values being used for testing.
* **Inspect the Expected Output Calculation:**  See how the expected results are determined. This often involves bitwise operations, logical shifts, or standard arithmetic.
* **Examine the Assertions (`CHECK_EQ`):** Verify that the actual output from the Wasm execution matches the expected output.
* **Look for `TSSimd256VerifyScope`:**  This confirms whether the test expects specific 256-bit SIMD instructions to be generated.

**4. Identifying Key Features and Functionality:**

After examining multiple test cases, you start to see recurring themes:

* **Testing Various SIMD Operations:** Arithmetic (`Add`, `Sub`, `Mul`), bitwise (`Not`, `And`, `Or`, `Xor`), shifts (`Shl`, `Shr`), comparisons, lane manipulation (`ReplaceLane`, `ExtractLane`), conversions (`ConvertI8x16Low`, `ConvertI32x4`), and memory access (`Load`, `Store`).
* **Focus on 128-bit and 256-bit SIMD:** The code uses `kWasmS128` for 128-bit vectors and implicitly tests 256-bit operations via the `TSSimd256VerifyScope`.
* **Testing "Force Packing":** Several tests explicitly mention "ForcePack" and aim to verify optimizations where 128-bit operations can be combined into 256-bit operations.
* **Testing "Intersect Packing":** Similar to force packing, this likely involves optimizing operations that share some common sub-operations.
* **Testing Different Data Types:** `i8`, `i16`, `i32`, `f32`, and their vector counterparts.
* **Testing Different Execution Tiers:**  Specifically mentioning `TestExecutionTier::kTurbofan`.

**5. Connecting to JavaScript (If Applicable):**

Since the file tests Wasm SIMD, you can relate it to the JavaScript WebAssembly API, particularly the `WebAssembly.Module` and `WebAssembly.Instance` objects, and how to create and execute Wasm code from JavaScript. For SIMD, you would highlight the Typed Arrays and how they interact with Wasm memory.

**6. Identifying Potential Programming Errors:**

By looking at the operations and data types involved, you can infer potential errors:

* **Type Mismatches:**  Trying to perform operations on incompatible SIMD vector types.
* **Out-of-Bounds Memory Access:**  Incorrect offsets when loading or storing data in Wasm memory.
* **Incorrect Bitwise Operations:**  Misunderstanding the behavior of bitwise AND, OR, XOR, or shifts.
* **Loss of Precision:**  When converting between integer and floating-point types.
* **Endianness Issues:** Though less likely in this specific code, it's a general concern with memory representation.

**7. Iterative Refinement:**

The process is not strictly linear. You might jump back and forth between analyzing individual tests and forming a higher-level understanding. As you see more patterns, your understanding becomes more refined.

By following this structured approach, you can effectively analyze complex C++ test files like the one provided, even without being an expert in all the intricacies of the V8 codebase. The key is to break it down into smaller parts, identify the core components, and gradually build a comprehensive understanding.
This is part 8 of a 9-part series of tests for WebAssembly (Wasm) SIMD (Single Instruction, Multiple Data) functionality within the V8 JavaScript engine. Specifically, this file, `v8/test/cctest/wasm/test-run-wasm-simd.cc`, contains C++ tests that directly execute Wasm code snippets to verify the correctness of SIMD instructions.

Here's a breakdown of its functionalities:

**Core Functionality:**

* **Testing Wasm SIMD Instructions:** The primary goal is to test the behavior of various Wasm SIMD instructions. This includes:
    * **Arithmetic operations:** Addition, subtraction, multiplication (e.g., `kExprI32x4Add`, `kExprF32x4Mul`).
    * **Bitwise operations:** NOT (e.g., `kExprS128Not`).
    * **Shift operations:** Logical right shift (e.g., via `LogicalShiftRight`).
    * **Comparison operations:** (Implicit through checking equality).
    * **Lane manipulation:** Replacing and extracting lanes within SIMD vectors (e.g., `WASM_SIMD_F32x4_REPLACE_LANE`, `WASM_SIMD_I32x4_EXTRACT_LANE`).
    * **Conversions:** Converting between different integer sizes and signedness (e.g., `kExprI16x8SConvertI8x16Low`, `kExprI16x8UConvertI8x16Low`, `kExprI16x8SConvertI32x4`, `kExprI16x8UConvertI32x4`).
    * **Memory access:** Loading and storing SIMD vectors from and to memory (e.g., `WASM_SIMD_LOAD_MEM`, `WASM_SIMD_STORE_MEM`).
    * **Packing and Unpacking:** Combining smaller data types into larger vectors and vice-versa (implicitly tested through conversions).
* **Targeting the Turbofan Compiler:**  The tests are designed to specifically exercise the Turbofan optimizing compiler for Wasm. This is indicated by `WasmRunner<...>(TestExecutionTier::kTurbofan)`.
* **Focus on Vectorization Optimizations:** The presence of `EXPERIMENTAL_FLAG_SCOPE(revectorize)` and checks for CPU features like AVX2 (`CpuFeatures::IsSupported(AVX2)`) suggests these tests are heavily focused on verifying vectorization optimizations, where the compiler tries to map SIMD instructions to efficient hardware vector instructions.
* **Testing Specific Optimization Techniques:** The tests include scenarios designed to trigger and verify specific optimization techniques like:
    * **Force Packing:** Combining multiple 128-bit SIMD operations into a single 256-bit operation (evident in tests with names containing "ForcePack").
    * **Intersect Packing:** Optimizing operations that share common sub-expressions.
* **Using a Test Framework:** The code uses V8's internal testing framework with macros like `TEST`, `CHECK_EQ`, `SKIP_TEST_IF_NO_TURBOSHAFT`.
* **Generating Wasm Code Programmatically:** The `WasmRunner` class and `WASM_...` macros are used to construct Wasm bytecode within the C++ test.
* **Verifying Generated Assembly (Indirectly):** The `TSSimd256VerifyScope` is used to assert that specific 256-bit SIMD instructions are generated by the compiler for certain code patterns.

**Is it a Torque source file?**

No, `v8/test/cctest/wasm/test-run-wasm-simd.cc` ends with `.cc`, which signifies it's a **C++** source file, not a Torque (`.tq`) file.

**Relationship to JavaScript:**

Wasm modules are executed within a JavaScript environment. This test file indirectly relates to JavaScript because it verifies the correct execution of Wasm code that can be loaded and run by JavaScript.

**JavaScript Example (Illustrative):**

While the test file is C++, the functionality it tests is directly related to the Wasm SIMD features that can be utilized by Wasm modules loaded in JavaScript.

```javascript
// Assume you have a WebAssembly module loaded and instantiated as 'wasmModule'

// Get access to the Wasm memory
const wasmMemory = wasmModule.instance.exports.memory;
const memoryBuffer = wasmMemory.buffer;

// Assume your Wasm module has exported a function 'test_simd_add'
// that performs a SIMD addition operation.

// Create TypedArrays to interact with the Wasm memory
const input1Array = new Int32Array(memoryBuffer, input1Offset, 4); // Assuming 4 i32 inputs
const input2Array = new Int32Array(memoryBuffer, input2Offset, 4);
const outputArray = new Int32Array(memoryBuffer, outputOffset, 4);

// Set input values (this would be managed by the C++ test)
input1Array.set([1, 2, 3, 4]);
input2Array.set([5, 6, 7, 8]);

// Call the Wasm function
wasmModule.instance.exports.test_simd_add();

// Read the output (the C++ test would check this)
console.log(outputArray); // Expected output: [6, 8, 10, 12]
```

**Code Logic Reasoning (Example from the provided snippet):**

Let's look at the `TEST(RunWasmTurbofan_I64x2ShiftLeft)` example:

**Assumptions:**

* `memory` is a byte array representing the Wasm linear memory.
* The Wasm code loads two 32-bit integers `a` and `b` from memory.
* It performs a bitwise NOT on `a` and `b`, converts them to 64-bit integers, and then performs a logical right shift by 1.
* The results are stored back into memory as 64-bit integers.

**Hypothetical Input:**

* `memory[0]` (value of `a`): `5` (binary: `00000000 00000000 00000000 00000101`)
* `memory[1]` (value of `b`): `10` (binary: `00000000 00000000 00000000 00001010`)
* `memory[10]` (value of `c`): `15`
* `memory[11]` (value of `d`): `-5`

**Expected Output:**

1. **`expected_a`:**
   * `~a`:  `11111111 11111111 11111111 11111010` (bitwise NOT of 5)
   * `static_cast<int64_t>(~a)`: `0xFFFFFFFFFFFFFFFA`
   * `LogicalShiftRight(0xFFFFFFFFFFFFFFFA, 1)`: `0x7FFFFFFFFFFFFFFD` (which is a large positive number)

2. **`expected_b`:**
   * `~b`: `11111111 11111111 11111111 11110101` (bitwise NOT of 10)
   * `static_cast<int64_t>(~b)`: `0xFFFFFFFFFFFFFFF5`
   * `LogicalShiftRight(0xFFFFFFFFFFFFFFF5, 1)`: `0x7FFFFFFFFFFFFFFA`

3. **`expected_c`:** (c = a + b = 15)
   * `~c`: `11111111 11111111 11111111 11110000`
   * `static_cast<int64_t>(~c)`: `0xFFFFFFFFFFFFFFF0`
   * `LogicalShiftRight(0xFFFFFFFFFFFFFFF0, 1)`: `0x7FFFFFFFFFFFFFF8`

4. **`expected_d`:** (d = a - b = -5)
   * `~d`:  If `d` is -5 (represented in two's complement), `~d` would be the bitwise inverse.
   * `static_cast<int64_t>(~d)` and `LogicalShiftRight` would follow similarly.

**User Programming Errors (Examples):**

* **Incorrect SIMD Vector Alignment:** When manually manipulating memory, users might load or store SIMD vectors at incorrect memory addresses, leading to crashes or undefined behavior. Wasm implementations often require specific alignment (e.g., 16-byte alignment for `i32x4`).
* **Type Mismatches in SIMD Operations:** Attempting to perform operations between SIMD vectors of incompatible types (e.g., adding an `i32x4` to an `f32x4`).
* **Out-of-Bounds Lane Access:** Trying to access a lane index that is outside the valid range for a given SIMD vector type (e.g., accessing lane 4 of an `i32x4`).
* **Incorrectly Handling Signed vs. Unsigned Conversions:**  Misunderstanding the behavior of signed and unsigned conversion instructions can lead to unexpected results, especially with narrowing conversions. For example, converting a large signed integer to a smaller unsigned integer.
* **Forgetting to Check for SIMD Support:**  Users might write code that uses SIMD instructions without checking if the underlying hardware and browser support them. This can lead to errors or unexpected fallback behavior.

**Example of a potential error (not directly in this code but related):**

```javascript
// Assuming a Wasm function expects an i32x4 input

const inputData = new Int32Array([1, 2, 3, 4]);
// Incorrectly passing individual numbers instead of a SIMD vector
wasmModule.instance.exports.simdFunction(1, 2, 3, 4); // This would likely be wrong
```

**Summary of Functionality (Part 8):**

This part of the Wasm SIMD test suite in V8 focuses on thoroughly testing various SIMD instructions, particularly those involving integer and floating-point operations, conversions, and memory access, with a strong emphasis on verifying the effectiveness of the Turbofan compiler's vectorization optimizations, including "force packing" and "intersect packing" techniques. It uses C++ to directly construct and execute Wasm code snippets, asserting the correctness of the results. The tests also indirectly verify that the compiler can generate efficient 256-bit SIMD instructions when appropriate.

### 提示词
```
这是目录为v8/test/cctest/wasm/test-run-wasm-simd.cc的一个v8源代码， 请列举一下它的功能, 
如果v8/test/cctest/wasm/test-run-wasm-simd.cc以.tq结尾，那它是个v8 torque源代码，
如果它与javascript的功能有关系，请用javascript举例说明,
如果有代码逻辑推理，请给出假设输入与输出，
如果涉及用户常见的编程错误，请举例说明
这是第8部分，共9部分，请归纳一下它的功能
```

### 源代码
```cpp
WASM_I32V(1))),

           WASM_SIMD_STORE_MEM_OFFSET(8, WASM_ZERO, WASM_LOCAL_GET(temp1)),
           WASM_SIMD_STORE_MEM_OFFSET(24, WASM_ZERO, WASM_LOCAL_GET(temp2)),

           WASM_ONE});
    }
    FOR_INT32_INPUTS(a) {
      FOR_INT32_INPUTS(b) {
        // Don't loop over setting c and d, because an O(n^4) test takes too
        // much time.
        int32_t c = a + b;
        int32_t d = a - b;
        r.builder().WriteMemory(&memory[0], a);
        r.builder().WriteMemory(&memory[1], b);
        r.builder().WriteMemory(&memory[10], c);
        r.builder().WriteMemory(&memory[11], d);
        r.Call();
        const int64_t expected_a =
            LogicalShiftRight(~static_cast<int64_t>(a), 1);
        const int64_t expected_b =
            LogicalShiftRight(~static_cast<int64_t>(b), 1);
        const int64_t expected_c =
            LogicalShiftRight(~static_cast<int64_t>(c), 1);
        const int64_t expected_d =
            LogicalShiftRight(~static_cast<int64_t>(d), 1);
        const int64_t* const output_mem =
            reinterpret_cast<const int64_t*>(&memory[2]);
        const int64_t actual_a = output_mem[0];
        const int64_t actual_b = output_mem[1];
        const int64_t actual_c = output_mem[2];
        const int64_t actual_d = output_mem[3];
        CHECK_EQ(expected_a, actual_a);
        CHECK_EQ(expected_b, actual_b);
        CHECK_EQ(expected_c, actual_c);
        CHECK_EQ(expected_d, actual_d);
      }
    }
  }
}

TEST(RunWasmTurbofan_ForcePackI16x16ConvertI8x16) {
  SKIP_TEST_IF_NO_TURBOSHAFT;
  EXPERIMENTAL_FLAG_SCOPE(revectorize);
  if (!CpuFeatures::IsSupported(AVX2)) return;
  WasmRunner<int32_t, int32_t, int32_t> r(TestExecutionTier::kTurbofan);
  int8_t* memory = r.builder().AddMemoryElems<int8_t>(48);
  uint8_t param1 = 0;
  uint8_t param2 = 1;

  uint8_t temp1 = r.AllocateLocal(kWasmS128);
  uint8_t temp2 = r.AllocateLocal(kWasmS128);
  uint8_t temp3 = r.AllocateLocal(kWasmS128);
  constexpr uint8_t offset = 16;
  {
    TSSimd256VerifyScope ts_scope(
        r.zone(), TSSimd256VerifyScope::VerifyHaveOpcode<
                      compiler::turboshaft::Opcode::kSimdPack128To256>);
    r.Build({WASM_LOCAL_SET(temp3, WASM_SIMD_LOAD_MEM(WASM_LOCAL_GET(param1))),
             WASM_LOCAL_SET(
                 temp1,
                 WASM_SIMD_UNOP(
                     kExprI16x8Neg,
                     WASM_SIMD_UNOP(kExprS128Not,
                                    WASM_SIMD_UNOP(kExprI16x8SConvertI8x16Low,
                                                   WASM_LOCAL_GET(temp3))))),
             WASM_LOCAL_SET(
                 temp2,
                 WASM_SIMD_UNOP(
                     kExprI16x8Neg,
                     WASM_SIMD_UNOP(kExprS128Not,
                                    WASM_SIMD_UNOP(kExprI16x8SConvertI8x16Low,
                                                   WASM_LOCAL_GET(temp3))))),
             WASM_SIMD_STORE_MEM(WASM_LOCAL_GET(param2), WASM_LOCAL_GET(temp1)),
             WASM_SIMD_STORE_MEM_OFFSET(offset, WASM_LOCAL_GET(param2),
                                        WASM_LOCAL_GET(temp2)),
             WASM_ONE});
  }
  FOR_INT8_INPUTS(x) {
    for (int i = 0; i < 16; i++) {
      r.builder().WriteMemory(&memory[i], x);
    }
    r.Call(0, 16);
    int16_t expected_signed = -(~static_cast<int16_t>(x));
    int16_t* out_memory = reinterpret_cast<int16_t*>(memory);
    for (int i = 0; i < 8; i++) {
      CHECK_EQ(expected_signed, out_memory[8 + i]);
      CHECK_EQ(expected_signed, out_memory[16 + i]);
    }
  }
}

TEST(RunWasmTurbofan_ForcePackI16x16ConvertI8x16ExpectFail) {
  SKIP_TEST_IF_NO_TURBOSHAFT;
  EXPERIMENTAL_FLAG_SCOPE(revectorize);
  if (!CpuFeatures::IsSupported(AVX2)) return;
  WasmRunner<int32_t, int32_t, int32_t> r(TestExecutionTier::kTurbofan);
  r.builder().AddMemoryElems<int8_t>(48);
  uint8_t param1 = 0;
  uint8_t param2 = 1;

  uint8_t temp1 = r.AllocateLocal(kWasmS128);
  uint8_t temp2 = r.AllocateLocal(kWasmS128);
  uint8_t temp3 = r.AllocateLocal(kWasmS128);
  constexpr uint8_t offset = 16;
  {
    TSSimd256VerifyScope ts_scope(
        r.zone(),
        TSSimd256VerifyScope::VerifyHaveOpcode<
            compiler::turboshaft::Opcode::kSimdPack128To256>,
        ExpectedResult::kFail);
    // ExprI16x8SConvertI8x16Low use the result of another
    // ExprI16x8SConvertI8x16Low so the force pack should fail.
    r.Build({WASM_LOCAL_SET(temp3, WASM_SIMD_LOAD_MEM(WASM_LOCAL_GET(param1))),
             WASM_LOCAL_SET(
                 temp1,
                 WASM_SIMD_UNOP(
                     kExprI16x8Neg,
                     WASM_SIMD_UNOP(kExprS128Not,
                                    WASM_SIMD_UNOP(kExprI16x8SConvertI8x16Low,
                                                   WASM_LOCAL_GET(temp3))))),
             WASM_LOCAL_SET(
                 temp2,
                 WASM_SIMD_UNOP(
                     kExprI16x8Neg,
                     WASM_SIMD_UNOP(kExprS128Not,
                                    WASM_SIMD_UNOP(kExprI16x8SConvertI8x16Low,
                                                   WASM_LOCAL_GET(temp1))))),
             WASM_SIMD_STORE_MEM(WASM_LOCAL_GET(param2), WASM_LOCAL_GET(temp1)),
             WASM_SIMD_STORE_MEM_OFFSET(offset, WASM_LOCAL_GET(param2),
                                        WASM_LOCAL_GET(temp2)),
             WASM_ONE});
  }
}

TEST(RunWasmTurbofan_ForcePackInternalI16x16ConvertI8x16) {
  SKIP_TEST_IF_NO_TURBOSHAFT;
  EXPERIMENTAL_FLAG_SCOPE(revectorize);
  if (!CpuFeatures::IsSupported(AVX2)) return;
  WasmRunner<int32_t, int32_t, int32_t> r(TestExecutionTier::kTurbofan);
  int8_t* memory = r.builder().AddMemoryElems<int8_t>(64);
  uint8_t param1 = 0;
  uint8_t param2 = 1;

  // Load a i16x8 vector from memory, convert it to i8x16, and add the result
  // back to the original vector. This means that kExprI16x8SConvertI8x16Low
  // will be in an internal packed node, whose inputs are also packed nodes. In
  // this case we should properly handle the inputs by Simd256Extract128Lane.
  uint8_t temp1 = r.AllocateLocal(kWasmS128);
  uint8_t temp2 = r.AllocateLocal(kWasmS128);
  uint8_t temp3 = r.AllocateLocal(kWasmS128);
  uint8_t temp4 = r.AllocateLocal(kWasmS128);
  uint8_t temp5 = r.AllocateLocal(kWasmS128);
  uint8_t temp6 = r.AllocateLocal(kWasmS128);
  constexpr uint8_t offset = 16;
  {
    TSSimd256VerifyScope ts_scope(
        r.zone(), TSSimd256VerifyScope::VerifyHaveOpcode<
                      compiler::turboshaft::Opcode::kSimdPack128To256>);
    r.Build(
        {WASM_LOCAL_SET(temp3, WASM_SIMD_LOAD_MEM(WASM_LOCAL_GET(param1))),
         WASM_LOCAL_SET(
             temp4, WASM_SIMD_LOAD_MEM_OFFSET(offset, WASM_LOCAL_GET(param1))),
         WASM_LOCAL_SET(
             temp1, WASM_SIMD_UNOP(kExprI16x8Neg,
                                   WASM_SIMD_UNOP(kExprI16x8SConvertI8x16Low,
                                                  WASM_LOCAL_GET(temp3)))),
         WASM_LOCAL_SET(
             temp2, WASM_SIMD_UNOP(kExprI16x8Neg,
                                   WASM_SIMD_UNOP(kExprI16x8SConvertI8x16Low,
                                                  WASM_LOCAL_GET(temp3)))),
         WASM_LOCAL_SET(temp5,
                        WASM_SIMD_BINOP(kExprI16x8Add, WASM_LOCAL_GET(temp1),
                                        WASM_LOCAL_GET(temp3))),
         WASM_LOCAL_SET(temp6,
                        WASM_SIMD_BINOP(kExprI16x8Add, WASM_LOCAL_GET(temp2),
                                        WASM_LOCAL_GET(temp4))),
         WASM_SIMD_STORE_MEM(WASM_LOCAL_GET(param2), WASM_LOCAL_GET(temp5)),
         WASM_SIMD_STORE_MEM_OFFSET(offset, WASM_LOCAL_GET(param2),
                                    WASM_LOCAL_GET(temp6)),
         WASM_ONE});
  }
  FOR_INT8_INPUTS(x) {
    for (int i = 0; i < 16; i++) {
      r.builder().WriteMemory(&memory[i], x);
      r.builder().WriteMemory(&memory[i + 16], x);
    }
    r.Call(0, 32);
    int16_t extended_x = static_cast<int16_t>(x);
    int16_t expected_signed =
        -extended_x + ((extended_x << 8) + (extended_x & 0xFF));
    int16_t* out_memory = reinterpret_cast<int16_t*>(memory);
    for (int i = 0; i < 8; i++) {
      CHECK_EQ(expected_signed, out_memory[16 + i]);
      CHECK_EQ(expected_signed, out_memory[24 + i]);
    }
  }
}

TEST(RunWasmTurbofan_ForcePackLoadZero) {
  SKIP_TEST_IF_NO_TURBOSHAFT;
  EXPERIMENTAL_FLAG_SCOPE(revectorize);
  if (!CpuFeatures::IsSupported(AVX2)) return;
  // Use load32_zero for the force packing test.
  {
    // Test ForcePackType::kSplat
    WasmRunner<int32_t> r(TestExecutionTier::kTurbofan);
    int32_t* memory = r.builder().AddMemoryElems<int32_t>(9);
    uint8_t temp1 = r.AllocateLocal(kWasmS128);
    uint8_t temp2 = r.AllocateLocal(kWasmS128);
    {
      TSSimd256VerifyScope ts_scope(
          r.zone(), TSSimd256VerifyScope::VerifyHaveOpcode<
                        compiler::turboshaft::Opcode::kSimdPack128To256>);
      r.Build({WASM_LOCAL_SET(
                   temp1, WASM_SIMD_UNOP(kExprS128Not,
                                         WASM_SIMD_LOAD_OP(kExprS128Load32Zero,
                                                           WASM_ZERO))),
               WASM_LOCAL_SET(
                   temp2, WASM_SIMD_UNOP(kExprS128Not,
                                         WASM_SIMD_LOAD_OP(kExprS128Load32Zero,
                                                           WASM_ZERO))),

               WASM_SIMD_STORE_MEM_OFFSET(20, WASM_ZERO, WASM_LOCAL_GET(temp2)),
               WASM_SIMD_STORE_MEM_OFFSET(4, WASM_ZERO, WASM_LOCAL_GET(temp1)),

               WASM_ONE});
    }

    FOR_INT32_INPUTS(a) {
      int32_t expected_a = ~a;
      constexpr int32_t expected_padding = ~0;
      r.builder().WriteMemory(&memory[0], a);
      r.Call();
      CHECK_EQ(memory[1], expected_a);
      CHECK_EQ(memory[2], expected_padding);
      CHECK_EQ(memory[3], expected_padding);
      CHECK_EQ(memory[4], expected_padding);
      CHECK_EQ(memory[5], expected_a);
      CHECK_EQ(memory[6], expected_padding);
      CHECK_EQ(memory[7], expected_padding);
      CHECK_EQ(memory[8], expected_padding);
    }
  }

  {
    // Test ForcePackType::kGeneral
    WasmRunner<int32_t> r(TestExecutionTier::kTurbofan);
    int32_t* memory = r.builder().AddMemoryElems<int32_t>(10);
    uint8_t temp1 = r.AllocateLocal(kWasmS128);
    uint8_t temp2 = r.AllocateLocal(kWasmS128);
    {
      TSSimd256VerifyScope ts_scope(
          r.zone(), TSSimd256VerifyScope::VerifyHaveOpcode<
                        compiler::turboshaft::Opcode::kSimdPack128To256>);
      r.Build({WASM_LOCAL_SET(
                   temp1, WASM_SIMD_UNOP(kExprS128Not,
                                         WASM_SIMD_LOAD_OP(kExprS128Load32Zero,
                                                           WASM_ZERO))),
               WASM_LOCAL_SET(
                   temp2, WASM_SIMD_UNOP(kExprS128Not, WASM_SIMD_LOAD_OP_OFFSET(
                                                           kExprS128Load32Zero,
                                                           WASM_ZERO, 4))),

               WASM_SIMD_STORE_MEM_OFFSET(24, WASM_ZERO, WASM_LOCAL_GET(temp2)),
               WASM_SIMD_STORE_MEM_OFFSET(8, WASM_ZERO, WASM_LOCAL_GET(temp1)),

               WASM_ONE});
    }

    FOR_INT32_INPUTS(x) {
      FOR_INT32_INPUTS(y) {
        r.builder().WriteMemory(&memory[0], x);
        r.builder().WriteMemory(&memory[1], y);
        r.Call();
        int expected_x = ~x;
        int expected_y = ~y;
        constexpr int32_t expected_padding = ~0;
        CHECK_EQ(memory[2], expected_x);
        CHECK_EQ(memory[3], expected_padding);
        CHECK_EQ(memory[4], expected_padding);
        CHECK_EQ(memory[5], expected_padding);
        CHECK_EQ(memory[6], expected_y);
        CHECK_EQ(memory[7], expected_padding);
        CHECK_EQ(memory[8], expected_padding);
        CHECK_EQ(memory[8], expected_padding);
      }
    }
  }
}

template <bool inputs_swapped = false>
void RunForcePackF32x4ReplaceLaneIntersectTest() {
  SKIP_TEST_IF_NO_TURBOSHAFT;
  EXPERIMENTAL_FLAG_SCOPE(revectorize);
  if (!CpuFeatures::IsSupported(AVX2)) return;
  WasmRunner<int32_t, int32_t, int32_t> r(TestExecutionTier::kTurbofan);
  float* memory = r.builder().AddMemoryElems<float>(16);
  uint8_t param1 = 0;
  uint8_t param2 = 1;
  uint8_t temp1 = r.AllocateLocal(kWasmS128);
  uint8_t temp2 = r.AllocateLocal(kWasmS128);
  uint8_t temp3 = r.AllocateLocal(kWasmS128);
  uint8_t temp4 = r.AllocateLocal(kWasmS128);
  uint8_t temp5 = r.AllocateLocal(kWasmS128);
  constexpr uint8_t offset = 16;
  uint8_t add1, add2, add3, add4;
  if constexpr (inputs_swapped) {
    add1 = temp3;
    add2 = temp2;
    add3 = temp4;
    add4 = temp3;
  } else {
    add1 = temp2;
    add2 = temp3;
    add3 = temp3;
    add4 = temp4;
  }

  {
    TSSimd256VerifyScope ts_scope(
        r.zone(), TSSimd256VerifyScope::VerifyHaveOpcode<
                      compiler::turboshaft::Opcode::kSimdPack128To256>);
    // Test force-packing two f32x4 replace_lanes(2, 3) or (3, 4) in
    // ForcePackNode, and intersected replace_lanes(3, 4) or (2, 3) in
    // IntersectPackNode. Reduce the ForcePackNode and IntersectPackNode in
    // different order.
    r.Build(
        {WASM_LOCAL_SET(temp1, WASM_SIMD_F32x4_SPLAT(WASM_F32(3.14f))),
         WASM_LOCAL_SET(temp2, WASM_SIMD_F32x4_REPLACE_LANE(
                                   0, WASM_LOCAL_GET(temp1), WASM_F32(0.0f))),
         WASM_LOCAL_SET(temp3, WASM_SIMD_F32x4_REPLACE_LANE(
                                   1, WASM_LOCAL_GET(temp1), WASM_F32(1.0f))),
         WASM_LOCAL_SET(temp4, WASM_SIMD_F32x4_REPLACE_LANE(
                                   2, WASM_LOCAL_GET(temp1), WASM_F32(2.0f))),
         WASM_LOCAL_SET(
             temp5,
             WASM_SIMD_BINOP(
                 kExprF32x4Mul, WASM_SIMD_LOAD_MEM(WASM_LOCAL_GET(param1)),
                 WASM_SIMD_BINOP(kExprF32x4Add, WASM_LOCAL_GET(add1),
                                 WASM_LOCAL_GET(add2)))),
         WASM_LOCAL_SET(
             temp4,
             WASM_SIMD_BINOP(
                 kExprF32x4Mul,
                 WASM_SIMD_LOAD_MEM_OFFSET(offset, WASM_LOCAL_GET(param1)),
                 WASM_SIMD_BINOP(kExprF32x4Add, WASM_LOCAL_GET(add3),
                                 WASM_LOCAL_GET(add4)))),
         WASM_SIMD_STORE_MEM(WASM_LOCAL_GET(param2), WASM_LOCAL_GET(temp5)),
         WASM_SIMD_STORE_MEM_OFFSET(offset, WASM_LOCAL_GET(param2),
                                    WASM_LOCAL_GET(temp4)),
         WASM_ONE});
  }

  for (int i = 0; i < 8; i++) {
    r.builder().WriteMemory(&memory[i], 2.0f);
  }
  r.Call(0, 32);
  CHECK_EQ(Mul(Add(3.14f, 0.0f), 2.0f), memory[8]);
  CHECK_EQ(Mul(Add(3.14f, 1.0f), 2.0f), memory[9]);
  CHECK_EQ(Mul(Add(3.14f, 1.0f), 2.0f), memory[13]);
  CHECK_EQ(Mul(Add(3.14f, 2.0f), 2.0f), memory[14]);
}

TEST(RunWasmTurbofan_ForcePackF32x4ReplaceLaneIntersect1) {
  RunForcePackF32x4ReplaceLaneIntersectTest<false>();
}

TEST(RunWasmTurbofan_ForcePackF32x4ReplaceLaneIntersect2) {
  RunForcePackF32x4ReplaceLaneIntersectTest<true>();
}

TEST(RunWasmTurbofan_IntersectPackNodeMerge1) {
  SKIP_TEST_IF_NO_TURBOSHAFT;
  EXPERIMENTAL_FLAG_SCOPE(revectorize);
  if (!CpuFeatures::IsSupported(AVX2)) return;
  WasmRunner<int32_t, int32_t, int32_t> r(TestExecutionTier::kTurbofan);
  float* memory = r.builder().AddMemoryElems<float>(24);
  uint8_t param1 = 0;
  uint8_t param2 = 1;
  uint8_t temp1 = r.AllocateLocal(kWasmS128);
  uint8_t temp2 = r.AllocateLocal(kWasmS128);
  uint8_t temp3 = r.AllocateLocal(kWasmS128);
  uint8_t temp4 = r.AllocateLocal(kWasmS128);
  uint8_t temp5 = r.AllocateLocal(kWasmS128);
  uint8_t temp6 = r.AllocateLocal(kWasmS128);
  uint8_t temp7 = r.AllocateLocal(kWasmS128);
  uint8_t temp8 = r.AllocateLocal(kWasmS128);
  constexpr uint8_t offset = 16;
  // Build an SLPTree with default, ForcePackNode and IntersectPackNode. Build
  // another SLPTree that will merge with the default and IntersectPackNode.
  {
    TSSimd256VerifyScope ts_scope(
        r.zone(), TSSimd256VerifyScope::VerifyHaveOpcode<
                      compiler::turboshaft::Opcode::kSimdPack128To256>);
    r.Build(
        {WASM_LOCAL_SET(temp1, WASM_SIMD_F32x4_SPLAT(WASM_F32(3.14f))),
         WASM_LOCAL_SET(temp2, WASM_SIMD_F32x4_REPLACE_LANE(
                                   0, WASM_LOCAL_GET(temp1), WASM_F32(0.0f))),
         WASM_LOCAL_SET(temp3, WASM_SIMD_F32x4_REPLACE_LANE(
                                   1, WASM_LOCAL_GET(temp1), WASM_F32(1.0f))),
         WASM_LOCAL_SET(temp4, WASM_SIMD_F32x4_REPLACE_LANE(
                                   2, WASM_LOCAL_GET(temp1), WASM_F32(2.0f))),
         WASM_LOCAL_SET(temp5, WASM_SIMD_LOAD_MEM(WASM_ZERO)),
         WASM_LOCAL_SET(temp6, WASM_SIMD_LOAD_MEM_OFFSET(offset, WASM_ZERO)),
         WASM_LOCAL_SET(
             temp7, WASM_SIMD_BINOP(
                        kExprF32x4Add, WASM_LOCAL_GET(temp5),
                        WASM_SIMD_BINOP(kExprF32x4Add, WASM_LOCAL_GET(temp2),
                                        WASM_LOCAL_GET(temp3)))),
         WASM_LOCAL_SET(
             temp8, WASM_SIMD_BINOP(
                        kExprF32x4Add, WASM_LOCAL_GET(temp6),
                        WASM_SIMD_BINOP(kExprF32x4Add, WASM_LOCAL_GET(temp3),
                                        WASM_LOCAL_GET(temp4)))),
         WASM_SIMD_STORE_MEM(WASM_LOCAL_GET(param1), WASM_LOCAL_GET(temp7)),
         WASM_SIMD_STORE_MEM_OFFSET(offset, WASM_LOCAL_GET(param1),
                                    WASM_LOCAL_GET(temp8)),
         WASM_LOCAL_SET(
             temp7, WASM_SIMD_BINOP(
                        kExprF32x4Add, WASM_LOCAL_GET(temp5),
                        WASM_SIMD_BINOP(kExprF32x4Add, WASM_LOCAL_GET(temp2),
                                        WASM_LOCAL_GET(temp3)))),
         WASM_LOCAL_SET(
             temp8, WASM_SIMD_BINOP(
                        kExprF32x4Add, WASM_LOCAL_GET(temp6),
                        WASM_SIMD_BINOP(kExprF32x4Add, WASM_LOCAL_GET(temp4),
                                        WASM_LOCAL_GET(temp4)))),
         WASM_SIMD_STORE_MEM(WASM_LOCAL_GET(param2), WASM_LOCAL_GET(temp7)),
         WASM_SIMD_STORE_MEM_OFFSET(offset, WASM_LOCAL_GET(param2),
                                    WASM_LOCAL_GET(temp8)),
         WASM_ONE});
  }
  for (int i = 0; i < 8; i++) {
    r.builder().WriteMemory(&memory[i], 2.0f);
  }

  r.Call(32, 64);
  CHECK_EQ(Add(Add(3.14f, 0.0f), 2.0f), memory[8]);
  CHECK_EQ(Add(Add(3.14f, 1.0f), 2.0f), memory[9]);
  CHECK_EQ(Add(Add(3.14f, 1.0f), 2.0f), memory[13]);
  CHECK_EQ(Add(Add(3.14f, 2.0f), 2.0f), memory[14]);
  CHECK_EQ(Add(Add(3.14f, 0.0f), 2.0f), memory[16]);
  CHECK_EQ(Add(Add(3.14f, 1.0f), 2.0f), memory[17]);
  CHECK_EQ(Add(Add(2.0f, 2.0f), 2.0f), memory[22]);
}

TEST(RunWasmTurbofan_IntersectPackNodeMerge2) {
  SKIP_TEST_IF_NO_TURBOSHAFT;
  EXPERIMENTAL_FLAG_SCOPE(revectorize);
  if (!CpuFeatures::IsSupported(AVX2)) return;
  WasmRunner<int32_t, int32_t, int32_t> r(TestExecutionTier::kTurbofan);
  float* memory = r.builder().AddMemoryElems<float>(24);
  uint8_t param1 = 0;
  uint8_t param2 = 1;
  uint8_t temp1 = r.AllocateLocal(kWasmS128);
  uint8_t temp2 = r.AllocateLocal(kWasmS128);
  uint8_t temp3 = r.AllocateLocal(kWasmS128);
  uint8_t temp4 = r.AllocateLocal(kWasmS128);
  uint8_t temp5 = r.AllocateLocal(kWasmS128);
  uint8_t temp6 = r.AllocateLocal(kWasmS128);
  uint8_t temp7 = r.AllocateLocal(kWasmS128);
  uint8_t temp8 = r.AllocateLocal(kWasmS128);
  constexpr uint8_t offset = 16;
  // Build an SLPTree with default, ForcePackNode(2, 3) and IntersectPackNode(3,
  // 4). Build another SLPTree that will create new IntersectPackNode(1, 3) and
  // (4, 4) and expand the existing revetorizable_intersect_node map entries.
  // This test will ensure no missing IntersectPackNode after the merge.
  {
    TSSimd256VerifyScope ts_scope(
        r.zone(), TSSimd256VerifyScope::VerifyHaveOpcode<
                      compiler::turboshaft::Opcode::kSimdPack128To256>);
    r.Build(
        {WASM_LOCAL_SET(temp1, WASM_SIMD_F32x4_SPLAT(WASM_F32(3.14f))),
         WASM_LOCAL_SET(temp2, WASM_SIMD_F32x4_REPLACE_LANE(
                                   0, WASM_LOCAL_GET(temp1), WASM_F32(0.0f))),
         WASM_LOCAL_SET(temp3, WASM_SIMD_F32x4_REPLACE_LANE(
                                   1, WASM_LOCAL_GET(temp1), WASM_F32(1.0f))),
         WASM_LOCAL_SET(temp4, WASM_SIMD_F32x4_REPLACE_LANE(
                                   2, WASM_LOCAL_GET(temp1), WASM_F32(2.0f))),
         WASM_LOCAL_SET(temp5, WASM_SIMD_LOAD_MEM(WASM_ZERO)),
         WASM_LOCAL_SET(temp6, WASM_SIMD_LOAD_MEM_OFFSET(offset, WASM_ZERO)),
         WASM_LOCAL_SET(
             temp7, WASM_SIMD_BINOP(
                        kExprF32x4Add, WASM_LOCAL_GET(temp5),
                        WASM_SIMD_BINOP(kExprF32x4Add, WASM_LOCAL_GET(temp2),
                                        WASM_LOCAL_GET(temp3)))),
         WASM_LOCAL_SET(
             temp8, WASM_SIMD_BINOP(
                        kExprF32x4Add, WASM_LOCAL_GET(temp6),
                        WASM_SIMD_BINOP(kExprF32x4Add, WASM_LOCAL_GET(temp3),
                                        WASM_LOCAL_GET(temp4)))),
         WASM_SIMD_STORE_MEM(WASM_LOCAL_GET(param1), WASM_LOCAL_GET(temp7)),
         WASM_SIMD_STORE_MEM_OFFSET(offset, WASM_LOCAL_GET(param1),
                                    WASM_LOCAL_GET(temp8)),
         WASM_LOCAL_SET(temp1, WASM_SIMD_F32x4_REPLACE_LANE(
                                   3, WASM_LOCAL_GET(temp1), WASM_F32(3.0f))),
         WASM_LOCAL_SET(
             temp7, WASM_SIMD_BINOP(
                        kExprF32x4Add, WASM_LOCAL_GET(temp5),
                        WASM_SIMD_BINOP(kExprF32x4Add, WASM_LOCAL_GET(temp1),
                                        WASM_LOCAL_GET(temp4)))),
         WASM_LOCAL_SET(
             temp8, WASM_SIMD_BINOP(
                        kExprF32x4Add, WASM_LOCAL_GET(temp6),
                        WASM_SIMD_BINOP(kExprF32x4Add, WASM_LOCAL_GET(temp3),
                                        WASM_LOCAL_GET(temp4)))),
         WASM_SIMD_STORE_MEM(WASM_LOCAL_GET(param2), WASM_LOCAL_GET(temp7)),
         WASM_SIMD_STORE_MEM_OFFSET(offset, WASM_LOCAL_GET(param2),
                                    WASM_LOCAL_GET(temp8)),
         WASM_ONE});
  }
  for (int i = 0; i < 8; i++) {
    r.builder().WriteMemory(&memory[i], 2.0f);
  }

  r.Call(32, 64);
  CHECK_EQ(Add(Add(3.14f, 0.0f), 2.0f), memory[8]);
  CHECK_EQ(Add(Add(3.14f, 1.0f), 2.0f), memory[9]);
  CHECK_EQ(Add(Add(3.14f, 1.0f), 2.0f), memory[13]);
  CHECK_EQ(Add(Add(3.14f, 2.0f), 2.0f), memory[14]);
  CHECK_EQ(Add(Add(3.14f, 2.0f), 2.0f), memory[18]);
  CHECK_EQ(Add(Add(3.14f, 3.0f), 2.0f), memory[19]);
  CHECK_EQ(Add(Add(3.14f, 1.0f), 2.0f), memory[21]);
  CHECK_EQ(Add(Add(3.14f, 2.0f), 2.0f), memory[22]);
}

TEST(RunWasmTurbofan_RevecCommutativeOp) {
  EXPERIMENTAL_FLAG_SCOPE(revectorize);
  if (!CpuFeatures::IsSupported(AVX) || !CpuFeatures::IsSupported(AVX2)) return;
  WasmRunner<int32_t, int32_t, int32_t, int32_t> r(
      TestExecutionTier::kTurbofan);
  int32_t* memory = r.builder().AddMemoryElems<int32_t>(16);
  // Add int variable a to each element of 256 bit vectors b, store the result
  // in c
  //   int32_t a,
  //   simd128 *b,*c;
  //   *c = splat(a) + *b;
  //   *(c+1) = *(b+1) + splat(a);
  uint8_t param1 = 0;
  uint8_t param2 = 1;
  uint8_t param3 = 2;

  uint8_t temp1 = r.AllocateLocal(kWasmS128);
  uint8_t temp2 = r.AllocateLocal(kWasmS128);
  uint8_t temp3 = r.AllocateLocal(kWasmS128);
  constexpr uint8_t offset = 16;
  {
    TSSimd256VerifyScope ts_scope(
        r.zone(), TSSimd256VerifyScope::VerifyHaveOpWithKind<
                      compiler::turboshaft::Simd256BinopOp,
                      compiler::turboshaft::Simd256BinopOp::Kind::kI32x8Add>);
    r.Build(
        {WASM_LOCAL_SET(temp1, WASM_SIMD_I32x4_SPLAT(WASM_LOCAL_GET(param1))),
         WASM_LOCAL_SET(temp2, WASM_SIMD_BINOP(
                                   kExprI32x4Add, WASM_LOCAL_GET(temp1),
                                   WASM_SIMD_LOAD_MEM(WASM_LOCAL_GET(param2)))),
         WASM_LOCAL_SET(temp3,
                        WASM_SIMD_BINOP(kExprI32x4Add,
                                        WASM_SIMD_LOAD_MEM_OFFSET(
                                            offset, WASM_LOCAL_GET(param2)),
                                        WASM_LOCAL_GET(temp1))),
         WASM_SIMD_STORE_MEM(WASM_LOCAL_GET(param3), WASM_LOCAL_GET(temp2)),
         WASM_SIMD_STORE_MEM_OFFSET(offset, WASM_LOCAL_GET(param3),
                                    WASM_LOCAL_GET(temp3)),
         WASM_ONE});
  }

  for (int32_t x : compiler::ValueHelper::GetVector<int32_t>()) {
    for (int32_t y : compiler::ValueHelper::GetVector<int32_t>()) {
      for (int i = 0; i < 8; i++) {
        r.builder().WriteMemory(&memory[i], y);
      }
      int64_t expected = base::AddWithWraparound(x, y);
      CHECK_EQ(r.Call(x, 0, 32), 1);
      for (int i = 0; i < 8; i++) {
        CHECK_EQ(expected, memory[i + 8]);
      }
    }
  }
}

TEST(RunWasmTurbofan_I16x16SConvertI32x8) {
  RunIntToIntNarrowingRevecTest<int32_t, int16_t>(
      kExprI16x8SConvertI32x4, compiler::IrOpcode::kI16x16SConvertI32x8);
}

TEST(RunWasmTurbofan_I16x16UConvertI32x8) {
  RunIntToIntNarrowingRevecTest<int32_t, uint16_t>(
      kExprI16x8UConvertI32x4, compiler::IrOpcode::kI16x16UConvertI32x8);
}

TEST(RunWasmTurbofan_I8x32SConvertI16x16) {
  RunIntToIntNarrowingRevecTest<int16_t, int8_t>(
      kExprI8x16SConvertI16x8, compiler::IrOpcode::kI8x32SConvertI16x16);
}

TEST(RunWasmTurbofan_I8x32UConvertI16x16) {
  RunIntToIntNarrowingRevecTest<int16_t, uint8_t>(
      kExprI8x16UConvertI16x8, compiler::IrOpcode::kI8x32UConvertI16x16);
}

#define RunExtendIntToF32x4RevecTest(format, sign, convert_opcode,             \
                                     convert_sign, param_type, extract_type,   \
                                     convert_type)                             \
  TEST(RunWasmTurbofan_Extend##format##sign##ConvertF32x8##convert_sign) {     \
    SKIP_TEST_IF_NO_TURBOSHAFT;                                                \
    EXPERIMENTAL_FLAG_SCOPE(revectorize);                                      \
    if (!CpuFeatures::IsSupported(AVX) || !CpuFeatures::IsSupported(AVX2))     \
      return;                                                                  \
    WasmRunner<int32_t, int32_t, int32_t> r(TestExecutionTier::kTurbofan);     \
    param_type* memory =                                                       \
        r.builder().AddMemoryElems<param_type>(48 / sizeof(param_type));       \
    uint8_t param1 = 0;                                                        \
    uint8_t param2 = 1;                                                        \
    uint8_t input = r.AllocateLocal(kWasmS128);                                \
    uint8_t output1 = r.AllocateLocal(kWasmS128);                              \
    uint8_t output2 = r.AllocateLocal(kWasmS128);                              \
    constexpr uint8_t offset = 16;                                             \
    {                                                                          \
      TSSimd256VerifyScope ts_scope(                                           \
          r.zone(), TSSimd256VerifyScope::VerifyHaveOpWithKind<                \
                        compiler::turboshaft::Simd256UnaryOp,                  \
                        compiler::turboshaft::Simd256UnaryOp::Kind::           \
                            kF32x8##convert_sign##ConvertI32x8>);              \
      r.Build(                                                                 \
          {WASM_LOCAL_SET(input, WASM_SIMD_LOAD_MEM(WASM_LOCAL_GET(param1))),  \
           WASM_LOCAL_SET(                                                     \
               output1,                                                        \
               WASM_SIMD_F32x4_SPLAT(WASM_UNOP(                                \
                   convert_opcode, WASM_SIMD_##format##_EXTRACT_LANE##sign(    \
                                       0, WASM_LOCAL_GET(input))))),           \
           WASM_LOCAL_SET(                                                     \
               output1, WASM_SIMD_F32x4_REPLACE_LANE(                          \
                            1, WASM_LOCAL_GET(output1),                        \
                            WASM_UNOP(convert_opcode,                          \
                                      WASM_SIMD_##format##_EXTRACT_LANE##sign( \
                                          1, WASM_LOCAL_GET(input))))),        \
           WASM_LOCAL_SET(                                                     \
               output1, WASM_SIMD_F32x4_REPLACE_LANE(                          \
                            2, WASM_LOCAL_GET(output1),                        \
                            WASM_UNOP(convert_opcode,                          \
                                      WASM_SIMD_##format##_EXTRACT_LANE##sign( \
                                          2, WASM_LOCAL_GET(input))))),        \
           WASM_LOCAL_SET(                                                     \
               output1, WASM_SIMD_F32x4_REPLACE_LANE(                          \
                            3, WASM_LOCAL_GET(output1),                        \
                            WASM_UNOP(convert_opcode,                          \
                                      WASM_SIMD_##format##_EXTRACT_LANE##sign( \
                                          3, WASM_LOCAL_GET(input))))),        \
           WASM_LOCAL_SET(                                                     \
               output2,                                                        \
               WASM_SIMD_F32x4_SPLAT(WASM_UNOP(                                \
                   convert_opcode, WASM_SIMD_##format##_EXTRACT_LANE##sign(    \
                                       4, WASM_LOCAL_GET(input))))),           \
           WASM_LOCAL_SET(                                                     \
               output2, WASM_SIMD_F32x4_REPLACE_LANE(                          \
                            1, WASM_LOCAL_GET(output2),                        \
                            WASM_UNOP(convert_opcode,                          \
                                      WASM_SIMD_##format##_EXTRACT_LANE##sign( \
                                          5, WASM_LOCAL_GET(input))))),        \
           WASM_LOCAL_SET(                                                     \
               output2, WASM_SIMD_F32x4_REPLACE_LANE(                          \
                            2, WASM_LOCAL_GET(output2),                        \
                            WASM_UNOP(convert_opcode,                          \
                                      WASM_SIMD_##format##_EXTRACT_LANE##sign( \
                                          6, WASM_LOCAL_GET(input))))),        \
           WASM_LOCAL_SET(                                                     \
               output2, WASM_SIMD_F32x4_REPLACE_LANE(                          \
                            3, WASM_LOCAL_GET(output2),                        \
                            WASM_UNOP(convert_opcode,                          \
                                      WASM_SIMD_##format##_EXTRACT_LANE##sign( \
                                          7, WASM_LOCAL_GET(input))))),        \
           WASM_SIMD_STORE_MEM(WASM_LOCAL_GET(param2),                         \
                               WASM_LOCAL_GET(output1)),                       \
           WASM_SIMD_STORE_MEM_OFFSET(offset, WASM_LOCAL_GET(param2),          \
                                      WASM_LOCAL_GET(output2)),                \
           WASM_ONE});                                                         \
    }                                                                          \
                                                                               \
    constexpr uint32_t lanes = kSimd128Size / sizeof(param_type);              \
    auto values = compiler::ValueHelper::GetVector<param_type>();              \
    float* output = (float*)(memory + lanes);                                  \
    for (uint32_t i = 0; i + lanes <= values.size(); i++) {                    \
      for (uint32_t j = 0; j < lanes; j++) {                                   \
        r.builder().WriteMemory(&memory[j], values[i + j]);                    \
      }                                                                        \
      r.Call(0, 16);                                                           \
```
Response:
Let's break down the thought process for analyzing the provided C++ code snippet.

**1. Understanding the Goal:**

The request asks for an explanation of the `BlinkAXEventIntent.cc` file's functionality, its relation to web technologies (JavaScript, HTML, CSS), example use cases, and potential user errors. This means we need to understand *what* the code does, *why* it does it, and *how* it connects to the broader web development context.

**2. Initial Code Scan - Identifying Key Components:**

The first step is to quickly scan the code and identify the main elements:

* **`BlinkAXEventIntent` class:** This is the central entity. We need to understand its members and methods.
* **`FromEditCommand`, `FromClearedSelection`, `FromModifiedSelection`, `FromNewSelection` (static methods):** These look like factory methods for creating `BlinkAXEventIntent` objects based on different scenarios.
* **`EditCommand`, `SelectionModifyAlteration`, `SelectionModifyDirection`, `TextGranularity`, `SetSelectionBy`:** These are parameter types used in the factory methods. They represent different kinds of user actions or browser states.
* **`ax::mojom::blink::Command`, `ax::mojom::blink::InputEventType`, `ax::mojom::blink::MoveDirection`, `ax::mojom::blink::TextBoundary`:** These are enums likely related to accessibility.
* **`InputEvent::InputType`:**  Another enum related to input events.
* **`IsLtr` function:**  Seems to handle left-to-right text direction.
* **Hashing (`BlinkAXEventIntentHashTraits`):** Used for comparing `BlinkAXEventIntent` objects.

**3. Focusing on the Core Functionality - The Factory Methods:**

The factory methods are key to understanding how `BlinkAXEventIntent` objects are created. Let's examine each one:

* **`FromEditCommand`:**  This method takes an `EditCommand` and translates it into a `BlinkAXEventIntent`. The `switch` statement mapping `InputEvent::InputType` to `ax::mojom::blink::Command` and `ax::mojom::blink::InputEventType` is crucial. This clearly links user input (like typing, pasting, formatting) to accessibility events.

* **`FromClearedSelection`:** This one is simpler. It creates an intent for clearing a selection, using `ax::mojom::blink::Command::kClearSelection`.

* **`FromModifiedSelection`:** This is more complex, handling modifications to an existing selection (extending or moving). The logic for determining `move_direction` and `text_boundary` based on the input parameters is important. The platform-specific `PlatformWordBehavior` is a notable detail.

* **`FromNewSelection`:** This handles the creation of a completely new selection. The comment about difficulty in determining the exact `text_boundary` is insightful.

**4. Connecting to Web Technologies (JavaScript, HTML, CSS):**

Now, let's think about how these accessibility intents relate to the front-end:

* **JavaScript:** JavaScript can trigger actions that result in `EditCommand` or selection changes. For example, a rich text editor implemented in JavaScript would use these underlying browser mechanisms.
* **HTML:** HTML provides the structure for the content that users interact with. The accessibility events generated by this code describe changes within that HTML structure. Specifically, input elements, text areas, and contenteditable elements are directly relevant.
* **CSS:** While CSS primarily handles styling, it can indirectly affect accessibility. For example, `direction: rtl` influences the `IsLtr` check.

**5. Examples and Use Cases:**

Based on the understanding of the factory methods, we can create concrete examples:

* **Typing:**  `FromEditCommand` with `InputEvent::InputType::kInsertText`.
* **Deleting a word:** `FromEditCommand` with `InputEvent::InputType::kDeleteWordBackward`.
* **Selecting text with the mouse:** `FromNewSelection`.
* **Moving the cursor with arrow keys:** `FromModifiedSelection`.

**6. Logical Reasoning and Assumptions:**

The code makes logical deductions based on the input parameters. For example:

* Mapping `InputEvent::InputType` to specific accessibility commands.
* Determining `move_direction` based on the `direction` and `direction_of_selection`.
* Choosing the appropriate `text_boundary` based on `granularity` and `move_direction`.

We can formulate input/output examples based on these deductions.

**7. Identifying Potential User/Programming Errors:**

Consider how developers might misuse this or related APIs, or how user actions could lead to unexpected behavior:

* **Incorrect `InputEvent::InputType`:**  Passing a wrong input type might lead to incorrect accessibility information.
* **Forgetting to handle accessibility events:** Developers might not properly listen for and process these events, leading to an inaccessible experience.
* **Assumptions about platform behavior:** The code explicitly handles platform differences in word selection. Developers might make incorrect assumptions if they don't account for these differences.

**8. Structuring the Answer:**

Finally, organize the findings into a clear and logical answer, covering the requested points: functionality, relation to web technologies, examples, logical reasoning, and potential errors. Use clear language and provide specific code examples where appropriate (even if those examples are conceptual, demonstrating how JavaScript or HTML interacts with the underlying mechanisms).

This structured approach allows for a comprehensive analysis of the code snippet and the ability to answer the prompt effectively.这个文件 `blink_ax_event_intent.cc` 的主要功能是定义和管理 `BlinkAXEventIntent` 类，这个类封装了关于用户在网页上进行交互操作的意图信息，特别是与文本编辑和选择相关的操作。这些意图信息被用于辅助功能（Accessibility，简称AX）系统，帮助屏幕阅读器等辅助技术理解用户的操作，并向用户提供更准确的反馈。

以下是该文件的更详细的功能分解：

**1. 封装用户操作意图：**

* `BlinkAXEventIntent` 类作为一个数据结构，用于存储用户操作的意图。它包含了以下关键信息：
    * `command`:  一个 `ax::mojom::blink::Command` 枚举值，表示用户操作的抽象命令，例如插入、删除、格式化、移动选择等。
    * `input_event_type`: 一个 `ax::mojom::blink::InputEventType` 枚举值，表示触发该操作的具体输入事件类型，例如插入文本、删除单词、撤销等。
    * `text_boundary`: 一个 `ax::mojom::blink::TextBoundary` 枚举值，用于描述文本操作的边界，例如字符、单词、句子、行、段落等。
    * `move_direction`: 一个 `ax::mojom::blink::MoveDirection` 枚举值，表示移动的方向，例如向前、向后。

**2. 提供从不同操作生成意图的方法：**

该文件提供了一系列静态方法，用于从不同的用户操作场景生成 `BlinkAXEventIntent` 对象：

* **`FromEditCommand(const EditCommand& edit_command)`:**  从 `EditCommand` 对象生成意图。`EditCommand` 通常代表对文本内容进行的修改操作，例如输入、删除、粘贴等。这个方法会根据 `EditCommand` 中 `InputEvent::InputType` 的不同值，映射到相应的辅助功能命令和输入事件类型。

* **`FromClearedSelection(const SetSelectionBy set_selection_by)`:**  生成清除选择的意图。

* **`FromModifiedSelection(…)`:** 生成修改现有选择的意图，例如扩展或移动选择。这个方法考虑了选择修改的各种参数，如修改方式（扩展/移动）、方向、粒度（字符/单词/句子等）、文本方向以及平台特定的单词行为。

* **`FromNewSelection(…)`:** 生成创建新选择的意图。这个方法根据选择的粒度和起始/结束位置来确定意图。

**3. 与 JavaScript, HTML, CSS 的关系：**

`BlinkAXEventIntent` 处于 Blink 渲染引擎的核心层，负责处理底层的用户交互和文档模型变化。虽然它本身不是直接用 JavaScript, HTML 或 CSS 编写的，但它的功能与这三种技术紧密相关：

* **JavaScript:** JavaScript 代码可以触发各种用户操作，例如通过监听键盘事件、鼠标事件等，然后执行相应的文本编辑或选择操作。这些操作最终会通过 Blink 引擎的内部机制转化为 `EditCommand` 或选择修改等，从而生成 `BlinkAXEventIntent`。

    * **例子：** 当用户在一个 `<textarea>` 元素中输入字符时，JavaScript 可以监听 `keypress` 或 `input` 事件，并更新文本内容。Blink 引擎会检测到这个变化，并生成一个 `InputEvent::InputType::kInsertText` 类型的 `EditCommand`，最终通过 `FromEditCommand` 生成对应的 `BlinkAXEventIntent`。

* **HTML:** HTML 定义了网页的结构和内容，包括各种可交互的元素，如输入框、文本区域、可编辑的 `div` 等。用户在这些元素上的操作会触发相应的事件和命令，最终影响 `BlinkAXEventIntent` 的生成。

    * **例子：** 用户在一个 `contenteditable` 的 `div` 中使用 Ctrl+B 快捷键来加粗选中的文本。这个操作会生成一个 `InputEvent::InputType::kFormatBold` 类型的 `EditCommand`，`FromEditCommand` 会将其转化为 `ax::mojom::blink::Command::kFormat` 和 `ax::mojom::blink::InputEventType::kFormatBold` 的 `BlinkAXEventIntent`。

* **CSS:** CSS 主要负责网页的样式，但某些 CSS 属性也会影响文本的处理和选择，从而间接地影响 `BlinkAXEventIntent` 的生成。例如，`direction: rtl;` 会影响文本的方向，`FromModifiedSelection` 方法中的 `IsLtr` 函数会考虑这个因素来确定移动方向。

    * **例子：** 在一个设置了 `direction: rtl;` 的文本框中，用户按下向左方向键移动光标。`FromModifiedSelection` 会考虑到文本方向是从右向左，因此会生成一个表示向后移动的 `BlinkAXEventIntent`，尽管用户按下的是逻辑上的“左”键。

**4. 逻辑推理的举例说明：**

`FromModifiedSelection` 方法包含较多的逻辑推理，根据不同的输入参数来确定最终的意图。

**假设输入：**

* `alter`: `SelectionModifyAlteration::kExtend` (扩展选择)
* `direction`: `SelectionModifyDirection::kForward` (向前)
* `granularity`: `TextGranularity::kWord` (单词)
* `set_selection_by`:  (不影响这里的逻辑)
* `direction_of_selection`: `TextDirection::kLtr` (从左到右)
* `platform_word_behavior`: `PlatformWordBehavior::kWordDontSkipSpaces` (例如，macOS 的行为，移动到当前单词的末尾)

**输出：**

* `command`: `ax::mojom::blink::Command::kExtendSelection`
* `move_direction`: `ax::mojom::blink::MoveDirection::kForward`
* `text_boundary`: `ax::mojom::blink::TextBoundary::kWordEnd`

**推理过程：**

1. 由于 `alter` 是 `kExtend`，所以命令是 `kExtendSelection`。
2. `direction` 是 `kForward`，`direction_of_selection` 是 `kLtr`，所以 `move_direction` 是 `kForward`。
3. `granularity` 是 `kWord`，`move_direction` 是 `kForward`，并且 `platform_word_behavior` 是 `kWordDontSkipSpaces`，根据代码中的 `switch` 语句，`text_boundary` 被设置为 `kWordEnd`。

**5. 用户或编程常见的使用错误举例说明：**

虽然开发者通常不会直接创建 `BlinkAXEventIntent` 对象，但理解其背后的逻辑有助于避免与辅助功能相关的错误。

* **错误理解平台特定的行为：**  在处理文本选择和移动时，不同操作系统和浏览器可能有不同的行为。例如，在 Windows 上按 Ctrl+右箭头通常会将光标移动到下一个单词的开头，而在 macOS 上则移动到当前单词的末尾。如果开发者在 JavaScript 中模拟键盘操作或进行文本处理时，没有考虑到这些平台差异，可能会导致生成的辅助功能事件不准确，从而误导屏幕阅读器用户。

    * **例子：** 一个自定义的富文本编辑器，在处理光标移动时，可能错误地假设所有平台都使用相同的单词边界规则。这会导致在某些平台上，屏幕阅读器在用户按单词移动光标时，朗读的内容与用户实际光标所在的位置不一致。

* **不正确的 `InputEvent::InputType` 的使用：**  如果开发者在某些场景下手动创建或修改 `EditCommand` 对象，并设置了错误的 `InputEvent::InputType`，可能会导致 `FromEditCommand` 方法生成错误的辅助功能意图。

    * **例子：**  开发者可能错误地将一个实际的文本插入操作的 `InputEvent::InputType` 设置为 `kHistoryUndo`。这将导致辅助功能系统误以为用户正在执行撤销操作，而不是插入文本。

* **忽略辅助功能事件的重要性：**  开发者可能在实现某些复杂的交互功能时，没有充分考虑到辅助功能的需求，导致关键的用户操作没有生成相应的 `BlinkAXEventIntent`。这会使得使用辅助技术的用户无法理解或完成相应的操作。

    * **例子：**  一个自定义的滑块控件，如果其值的改变没有触发相应的辅助功能事件，屏幕阅读器用户就无法知道滑块的值发生了变化。

总而言之，`blink_ax_event_intent.cc` 文件定义了 Blink 引擎中用于表达用户操作意图的关键数据结构和生成逻辑，它在连接用户交互、底层渲染引擎和辅助功能系统之间起着桥梁的作用。理解其功能有助于开发者构建更加可访问的网页应用。

Prompt: 
```
这是目录为blink/renderer/core/accessibility/blink_ax_event_intent.cc的chromium blink引擎源代码文件， 请列举一下它的功能, 
如果它与javascript, html, css的功能有关系，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明

"""
// Copyright 2020 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "third_party/blink/renderer/core/accessibility/blink_ax_event_intent.h"

#include <limits>

#include "third_party/blink/renderer/core/events/input_event.h"
#include "third_party/blink/renderer/platform/wtf/hash_functions.h"
#include "ui/accessibility/ax_enums.mojom-blink.h"

namespace blink {

// static
BlinkAXEventIntent BlinkAXEventIntent::FromEditCommand(
    const EditCommand& edit_command) {
  ax::mojom::blink::Command command;
  ax::mojom::blink::InputEventType input_event_type;
  switch (edit_command.GetInputType()) {
    case InputEvent::InputType::kNone:
      return BlinkAXEventIntent();  // An empty intent.

    // Insertion.
    case InputEvent::InputType::kInsertText:
      command = ax::mojom::blink::Command::kInsert;
      input_event_type = ax::mojom::blink::InputEventType::kInsertText;
      break;
    case InputEvent::InputType::kInsertLineBreak:
      command = ax::mojom::blink::Command::kInsert;
      input_event_type = ax::mojom::blink::InputEventType::kInsertLineBreak;
      break;
    case InputEvent::InputType::kInsertParagraph:
      command = ax::mojom::blink::Command::kInsert;
      input_event_type = ax::mojom::blink::InputEventType::kInsertParagraph;
      break;
    case InputEvent::InputType::kInsertOrderedList:
      command = ax::mojom::blink::Command::kInsert;
      input_event_type = ax::mojom::blink::InputEventType::kInsertOrderedList;
      break;
    case InputEvent::InputType::kInsertUnorderedList:
      command = ax::mojom::blink::Command::kInsert;
      input_event_type = ax::mojom::blink::InputEventType::kInsertUnorderedList;
      break;
    case InputEvent::InputType::kInsertHorizontalRule:
      command = ax::mojom::blink::Command::kInsert;
      input_event_type =
          ax::mojom::blink::InputEventType::kInsertHorizontalRule;
      break;
    case InputEvent::InputType::kInsertFromPaste:
      command = ax::mojom::blink::Command::kInsert;
      input_event_type = ax::mojom::blink::InputEventType::kInsertFromPaste;
      break;
    case InputEvent::InputType::kInsertFromDrop:
      command = ax::mojom::blink::Command::kInsert;
      input_event_type = ax::mojom::blink::InputEventType::kInsertFromDrop;
      break;
    case InputEvent::InputType::kInsertFromYank:
      command = ax::mojom::blink::Command::kInsert;
      input_event_type = ax::mojom::blink::InputEventType::kInsertFromYank;
      break;
    case InputEvent::InputType::kInsertTranspose:
      command = ax::mojom::blink::Command::kInsert;
      input_event_type = ax::mojom::blink::InputEventType::kInsertTranspose;
      break;
    case InputEvent::InputType::kInsertReplacementText:
      command = ax::mojom::blink::Command::kInsert;
      input_event_type =
          ax::mojom::blink::InputEventType::kInsertReplacementText;
      break;
    case InputEvent::InputType::kInsertCompositionText:
      command = ax::mojom::blink::Command::kInsert;
      input_event_type =
          ax::mojom::blink::InputEventType::kInsertCompositionText;
      break;
    case InputEvent::InputType::kInsertLink:
      command = ax::mojom::blink::Command::kInsert;
      input_event_type = ax::mojom::blink::InputEventType::kInsertLink;
      break;

    // Deletion.
    case InputEvent::InputType::kDeleteWordBackward:
      command = ax::mojom::blink::Command::kDelete;
      input_event_type = ax::mojom::blink::InputEventType::kDeleteWordBackward;
      break;
    case InputEvent::InputType::kDeleteWordForward:
      command = ax::mojom::blink::Command::kDelete;
      input_event_type = ax::mojom::blink::InputEventType::kDeleteWordForward;
      break;
    case InputEvent::InputType::kDeleteSoftLineBackward:
      command = ax::mojom::blink::Command::kDelete;
      input_event_type =
          ax::mojom::blink::InputEventType::kDeleteSoftLineBackward;
      break;
    case InputEvent::InputType::kDeleteSoftLineForward:
      command = ax::mojom::blink::Command::kDelete;
      input_event_type =
          ax::mojom::blink::InputEventType::kDeleteSoftLineForward;
      break;
    case InputEvent::InputType::kDeleteHardLineBackward:
      command = ax::mojom::blink::Command::kDelete;
      input_event_type =
          ax::mojom::blink::InputEventType::kDeleteHardLineBackward;
      break;
    case InputEvent::InputType::kDeleteHardLineForward:
      command = ax::mojom::blink::Command::kDelete;
      input_event_type =
          ax::mojom::blink::InputEventType::kDeleteHardLineForward;
      break;
    case InputEvent::InputType::kDeleteContentBackward:
      command = ax::mojom::blink::Command::kDelete;
      input_event_type =
          ax::mojom::blink::InputEventType::kDeleteContentBackward;
      break;
    case InputEvent::InputType::kDeleteContentForward:
      command = ax::mojom::blink::Command::kDelete;
      input_event_type =
          ax::mojom::blink::InputEventType::kDeleteContentForward;
      break;
    case InputEvent::InputType::kDeleteByCut:
      command = ax::mojom::blink::Command::kDelete;
      input_event_type = ax::mojom::blink::InputEventType::kDeleteByCut;
      break;
    case InputEvent::InputType::kDeleteByDrag:
      command = ax::mojom::blink::Command::kDelete;
      input_event_type = ax::mojom::blink::InputEventType::kDeleteByDrag;
      break;

    // History.
    case InputEvent::InputType::kHistoryUndo:
      command = ax::mojom::blink::Command::kHistory;
      input_event_type = ax::mojom::blink::InputEventType::kHistoryUndo;
      break;
    case InputEvent::InputType::kHistoryRedo:
      command = ax::mojom::blink::Command::kHistory;
      input_event_type = ax::mojom::blink::InputEventType::kHistoryRedo;
      break;

    // Formatting.
    case InputEvent::InputType::kFormatBold:
      command = ax::mojom::blink::Command::kFormat;
      input_event_type = ax::mojom::blink::InputEventType::kFormatBold;
      break;
    case InputEvent::InputType::kFormatItalic:
      command = ax::mojom::blink::Command::kFormat;
      input_event_type = ax::mojom::blink::InputEventType::kFormatItalic;
      break;
    case InputEvent::InputType::kFormatUnderline:
      command = ax::mojom::blink::Command::kFormat;
      input_event_type = ax::mojom::blink::InputEventType::kFormatUnderline;
      break;
    case InputEvent::InputType::kFormatStrikeThrough:
      command = ax::mojom::blink::Command::kFormat;
      input_event_type = ax::mojom::blink::InputEventType::kFormatStrikeThrough;
      break;
    case InputEvent::InputType::kFormatSuperscript:
      command = ax::mojom::blink::Command::kFormat;
      input_event_type = ax::mojom::blink::InputEventType::kFormatSuperscript;
      break;
    case InputEvent::InputType::kFormatSubscript:
      command = ax::mojom::blink::Command::kFormat;
      input_event_type = ax::mojom::blink::InputEventType::kFormatSubscript;
      break;
    case InputEvent::InputType::kFormatJustifyCenter:
      command = ax::mojom::blink::Command::kFormat;
      input_event_type = ax::mojom::blink::InputEventType::kFormatJustifyCenter;
      break;
    case InputEvent::InputType::kFormatJustifyFull:
      command = ax::mojom::blink::Command::kFormat;
      input_event_type = ax::mojom::blink::InputEventType::kFormatJustifyFull;
      break;
    case InputEvent::InputType::kFormatJustifyRight:
      command = ax::mojom::blink::Command::kFormat;
      input_event_type = ax::mojom::blink::InputEventType::kFormatJustifyRight;
      break;
    case InputEvent::InputType::kFormatJustifyLeft:
      command = ax::mojom::blink::Command::kFormat;
      input_event_type = ax::mojom::blink::InputEventType::kFormatJustifyLeft;
      break;
    case InputEvent::InputType::kFormatIndent:
      command = ax::mojom::blink::Command::kFormat;
      input_event_type = ax::mojom::blink::InputEventType::kFormatIndent;
      break;
    case InputEvent::InputType::kFormatOutdent:
      command = ax::mojom::blink::Command::kFormat;
      input_event_type = ax::mojom::blink::InputEventType::kFormatOutdent;
      break;
    case InputEvent::InputType::kFormatRemove:
      command = ax::mojom::blink::Command::kFormat;
      input_event_type = ax::mojom::blink::InputEventType::kFormatRemove;
      break;
    case InputEvent::InputType::kFormatSetBlockTextDirection:
      command = ax::mojom::blink::Command::kFormat;
      input_event_type =
          ax::mojom::blink::InputEventType::kFormatSetBlockTextDirection;
      break;

    case InputEvent::InputType::kNumberOfInputTypes:
      NOTREACHED()
          << "Should never be assigned as an input type to |edit_command|.";
  }

  return BlinkAXEventIntent(command, input_event_type);
}

// static
BlinkAXEventIntent BlinkAXEventIntent::FromClearedSelection(
    const SetSelectionBy set_selection_by) {
  // text boundary and move direction are not needed in this case.
  return BlinkAXEventIntent(ax::mojom::blink::Command::kClearSelection);
}

// static
BlinkAXEventIntent BlinkAXEventIntent::FromModifiedSelection(
    const SelectionModifyAlteration alter,
    const SelectionModifyDirection direction,
    const TextGranularity granularity,
    const SetSelectionBy set_selection_by,
    const TextDirection direction_of_selection,
    const PlatformWordBehavior platform_word_behavior) {
  ax::mojom::blink::Command command;
  switch (alter) {
    case SelectionModifyAlteration::kExtend:
      // Includes the case when the existing selection has been shrunk.
      command = ax::mojom::blink::Command::kExtendSelection;
      break;
    case SelectionModifyAlteration::kMove:
      // The existing selection has been move by a specific |granularity|, e.g.
      // the caret has been moved to the beginning of the next word.
      command = ax::mojom::blink::Command::kMoveSelection;
      break;
  }

  ax::mojom::blink::MoveDirection move_direction;
  switch (direction) {
    case SelectionModifyDirection::kBackward:
      move_direction = ax::mojom::blink::MoveDirection::kBackward;
      break;
    case SelectionModifyDirection::kForward:
      move_direction = ax::mojom::blink::MoveDirection::kForward;
      break;
    case SelectionModifyDirection::kLeft:
      move_direction = IsLtr(direction_of_selection)
                           ? ax::mojom::blink::MoveDirection::kBackward
                           : ax::mojom::blink::MoveDirection::kForward;
      break;
    case SelectionModifyDirection::kRight:
      move_direction = IsLtr(direction_of_selection)
                           ? ax::mojom::blink::MoveDirection::kForward
                           : ax::mojom::blink::MoveDirection::kBackward;
      break;
  }

  ax::mojom::blink::TextBoundary text_boundary;
  switch (granularity) {
    case TextGranularity::kCharacter:
      text_boundary = ax::mojom::blink::TextBoundary::kCharacter;
      break;
    case TextGranularity::kWord:
      switch (move_direction) {
        case ax::mojom::blink::MoveDirection::kNone:
          NOTREACHED();
        case ax::mojom::blink::MoveDirection::kBackward:
          // All platforms behave the same when moving backward by word.
          text_boundary = ax::mojom::blink::TextBoundary::kWordStart;
          break;
        case ax::mojom::blink::MoveDirection::kForward:
          switch (platform_word_behavior) {
            case PlatformWordBehavior::kWordSkipSpaces:
              // Windows behavior is to always move to the beginning of the next
              // word.
              text_boundary = ax::mojom::blink::TextBoundary::kWordStart;
              break;
            case PlatformWordBehavior::kWordDontSkipSpaces:
              // Mac, Linux and ChromeOS behavior is to move to the end of the
              // current word.
              text_boundary = ax::mojom::blink::TextBoundary::kWordEnd;
              break;
          }
          break;
      }
      break;
    case TextGranularity::kSentence:
      // This granularity always moves to the start of the next or previous
      // sentence.
      text_boundary = ax::mojom::blink::TextBoundary::kSentenceStart;
      break;
    case TextGranularity::kLine:
      // This granularity always moves to the start of the next or previous
      // line.
      text_boundary = ax::mojom::blink::TextBoundary::kLineStart;
      break;
    case TextGranularity::kParagraph:
      // This granularity always moves to the start of the next or previous
      // paragraph.
      text_boundary = ax::mojom::blink::TextBoundary::kParagraphStart;
      break;
    case TextGranularity::kSentenceBoundary:
      // This granularity moves either to the start or the end of the current
      // sentence, depending on the direction.
      switch (move_direction) {
        case ax::mojom::blink::MoveDirection::kNone:
          NOTREACHED();
        case ax::mojom::blink::MoveDirection::kBackward:
          text_boundary = ax::mojom::blink::TextBoundary::kSentenceStart;
          break;
        case ax::mojom::blink::MoveDirection::kForward:
          text_boundary = ax::mojom::blink::TextBoundary::kSentenceEnd;
          break;
      }
      break;
    case TextGranularity::kLineBoundary:
      // This granularity moves either to the start or the end of the current
      // line, depending on the direction.
      switch (move_direction) {
        case ax::mojom::blink::MoveDirection::kNone:
          NOTREACHED();
        case ax::mojom::blink::MoveDirection::kBackward:
          text_boundary = ax::mojom::blink::TextBoundary::kLineStart;
          break;
        case ax::mojom::blink::MoveDirection::kForward:
          text_boundary = ax::mojom::blink::TextBoundary::kLineEnd;
          break;
      }
      break;
    case TextGranularity::kParagraphBoundary:
      // This granularity moves either to the start or the end of the current
      // paragraph, depending on the direction.
      switch (move_direction) {
        case ax::mojom::blink::MoveDirection::kNone:
          NOTREACHED();
        case ax::mojom::blink::MoveDirection::kBackward:
          text_boundary = ax::mojom::blink::TextBoundary::kParagraphStart;
          break;
        case ax::mojom::blink::MoveDirection::kForward:
          text_boundary = ax::mojom::blink::TextBoundary::kParagraphEnd;
          break;
      }
      break;
    case TextGranularity::kDocumentBoundary:
      text_boundary = ax::mojom::blink::TextBoundary::kWebPage;
      break;
  }

  return BlinkAXEventIntent(command, text_boundary, move_direction);
}

// static
BlinkAXEventIntent BlinkAXEventIntent::FromNewSelection(
    const TextGranularity granularity,
    bool is_base_first,
    const SetSelectionBy set_selection_by) {
  // Unfortunately, when setting a completely new selection, |text_boundary| is
  // not always known, or is hard to compute. For example, if a new selection
  // has been made using the mouse, it would be expensive to compute any
  // meaningful granularity information.
  ax::mojom::blink::TextBoundary text_boundary;
  switch (granularity) {
    case TextGranularity::kCharacter:
      text_boundary = ax::mojom::blink::TextBoundary::kCharacter;
      break;
    case TextGranularity::kWord:
      text_boundary = ax::mojom::blink::TextBoundary::kWordStartOrEnd;
      break;
    case TextGranularity::kSentence:
    case TextGranularity::kSentenceBoundary:
      text_boundary = ax::mojom::blink::TextBoundary::kSentenceStartOrEnd;
      break;
    case TextGranularity::kLine:
    case TextGranularity::kLineBoundary:
      text_boundary = ax::mojom::blink::TextBoundary::kLineStartOrEnd;
      break;
    case TextGranularity::kParagraph:
    case TextGranularity::kParagraphBoundary:
      text_boundary = ax::mojom::blink::TextBoundary::kParagraphStartOrEnd;
      break;
    case TextGranularity::kDocumentBoundary:
      text_boundary = ax::mojom::blink::TextBoundary::kWebPage;
      break;
  }

  return BlinkAXEventIntent(
      ax::mojom::blink::Command::kSetSelection, text_boundary,
      is_base_first ? ax::mojom::blink::MoveDirection::kForward
                    : ax::mojom::blink::MoveDirection::kBackward);
}

BlinkAXEventIntent::BlinkAXEventIntent() = default;

BlinkAXEventIntent::BlinkAXEventIntent(ax::mojom::blink::Command command)
    : intent_(command), is_initialized_(true) {}

BlinkAXEventIntent::BlinkAXEventIntent(
    ax::mojom::blink::Command command,
    ax::mojom::blink::InputEventType input_event_type)
    : intent_(command, input_event_type), is_initialized_(true) {}

BlinkAXEventIntent::BlinkAXEventIntent(
    ax::mojom::blink::Command command,
    ax::mojom::blink::TextBoundary text_boundary,
    ax::mojom::blink::MoveDirection move_direction)
    : intent_(command, text_boundary, move_direction), is_initialized_(true) {}

BlinkAXEventIntent::BlinkAXEventIntent(WTF::HashTableDeletedValueType type)
    : is_initialized_(true), is_deleted_(true) {}

BlinkAXEventIntent::~BlinkAXEventIntent() = default;

BlinkAXEventIntent::BlinkAXEventIntent(const BlinkAXEventIntent& intent) =
    default;

BlinkAXEventIntent& BlinkAXEventIntent::operator=(
    const BlinkAXEventIntent& intent) = default;

bool operator==(const BlinkAXEventIntent& a, const BlinkAXEventIntent& b) {
  return BlinkAXEventIntentHashTraits::GetHash(a) ==
         BlinkAXEventIntentHashTraits::GetHash(b);
}

bool operator!=(const BlinkAXEventIntent& a, const BlinkAXEventIntent& b) {
  return !(a == b);
}

bool BlinkAXEventIntent::IsHashTableDeletedValue() const {
  return is_deleted_;
}

std::string BlinkAXEventIntent::ToString() const {
  if (!is_initialized())
    return "AXEventIntent(uninitialized)";
  if (IsHashTableDeletedValue())
    return "AXEventIntent(is_deleted)";
  return intent().ToString();
}

// static
unsigned int BlinkAXEventIntentHashTraits::GetHash(
    const BlinkAXEventIntent& key) {
  // If the intent is uninitialized, it is not safe to rely on the memory being
  // initialized to zero, because any uninitialized field that might be
  // accidentally added in the future will produce a potentially non-zero memory
  // value especially in the hard to control "intent_" member.
  if (!key.is_initialized())
    return 0u;
  if (key.IsHashTableDeletedValue())
    return std::numeric_limits<unsigned>::max();

  unsigned hash = 1u;
  WTF::AddIntToHash(hash, static_cast<const unsigned>(key.intent().command));
  WTF::AddIntToHash(hash,
                    static_cast<const unsigned>(key.intent().input_event_type));
  WTF::AddIntToHash(hash,
                    static_cast<const unsigned>(key.intent().text_boundary));
  WTF::AddIntToHash(hash,
                    static_cast<const unsigned>(key.intent().move_direction));
  return hash;
}

}  // namespace blink

"""

```
Response:
My thought process for analyzing the provided code snippet and generating the summary goes through these stages:

1. **Understand the Goal:** The request asks for a summary of the functionality of the provided C++ code, which is a test file for the Blink rendering engine related to CSS rule feature sets. Crucially, it asks to relate this to web technologies (JavaScript, HTML, CSS), provide examples, explain logical reasoning with inputs and outputs, highlight common errors, describe user steps to reach this code, and finally, summarize the provided *part* of the file.

2. **Identify the Core Functionality:**  The file name `rule_feature_set_test.cc` and the presence of `TEST_F` macros immediately indicate this is a unit test file. The tests are within a class `RuleFeatureSetTest`. The code heavily uses terms like `CollectFeatures`, `InvalidationLists`, `CollectInvalidationSetsForClass`, `CollectInvalidationSetsForPseudoClass`, `HasClassInvalidation`, etc. This suggests the core functionality being tested is the mechanism for determining which elements need to be re-evaluated when CSS rules change. This is about CSS invalidation.

3. **Analyze Individual Tests:**  I go through each `TEST_F` block to understand what specific aspect of the `RuleFeatureSet` is being tested. I look for patterns and recurring concepts.

    * **`invalidatesHasInShadowTree`:** Focuses on the `:has()` pseudo-class and how it interacts with shadow DOM.
    * **`invalidatesMultipleHasAfterHostAtSubjectPosition` and `invalidatesMultipleHasAfterHostAtNonSubjectPosition`:**  Tests scenarios with multiple `:has()` pseudo-classes after the `:host` pseudo-class, examining the impact on invalidation.
    * **`MediaQueryResultFlagsEquality`:**  Checks the equality and inequality of `RuleFeatureSet` objects based on media query result flags. This suggests `RuleFeatureSet` stores information about media queries.
    * **`RefTestData` and the `ref_equal_test_data`/`ref_not_equal_test_data` arrays:** This is a pattern for comparing the `RuleFeatureSet` generated by one selector with the `RuleFeatureSet` of another. The extensive list of selectors in `ref_equal_test_data` strongly indicates testing the correctness of `RuleFeatureSet` generation for various CSS selectors, particularly focusing on the `:is()` and `:not()` pseudo-classes, and combinators.
    * **`RuleFeatureSetRefTest`, `RuleFeatureSetSelectorRefTest`, `RuleFeatureSetRefEqualTest`, `RuleFeatureSetRefNotEqualTest`:**  These are test fixture classes designed to structure the comparison tests.
    * **`ref_scope_equal_test_data` and `RuleFeatureSetScopeRefTest`:**  These focus on testing the `@scope` at-rule and how it affects the `RuleFeatureSet`.
    * **`CopyOnWrite` tests:** These examine the memory management aspects of `RuleFeatureSet`, specifically the copy-on-write optimization for sharing invalidation sets.
    * **Tests with `isPseudoContainingComplexInsideHas`:** These test complex selectors within the `:has()` pseudo-class, often involving the `:is()` pseudo-class. This highlights testing nested and complex selector logic.

4. **Relate to Web Technologies (JavaScript, HTML, CSS):**  Based on the identified functionality, I connect it to the core concepts of web development:

    * **CSS:** The entire test suite is about CSS selectors and how changes in CSS rules trigger updates in the rendered page. Examples of CSS selectors like classes (`.a`), IDs (`#id`), pseudo-classes (`:hover`, `:has()`, `:is()`, `:not()`), pseudo-elements (`::before`), combinators (` `, `+`, `~`, `>`), and the `@scope` at-rule are directly related to CSS.
    * **HTML:** CSS rules target HTML elements. The invalidation mechanism determines which HTML elements need to be re-rendered when CSS changes. The shadow DOM mentioned in one test is also an HTML feature.
    * **JavaScript:** While this specific code isn't directly JavaScript, JavaScript often manipulates the DOM and CSS styles. Changes made via JavaScript can trigger the same invalidation logic being tested here.

5. **Provide Examples:** For each web technology connection, I create simple, illustrative examples.

6. **Logical Reasoning (Input/Output):**  For key tests, especially those involving `CollectFeatures` and invalidation sets, I construct hypothetical inputs (CSS selectors) and describe the expected outputs (which invalidation sets would be populated).

7. **Common Errors:** I think about typical mistakes developers might make when working with CSS that could relate to the tested functionality. Incorrectly using complex selectors, misunderstanding the specificity of selectors, or not being aware of how changes in one part of the stylesheet can affect other elements are good examples.

8. **User Steps for Debugging:** I consider how a developer might end up looking at this specific test file. This involves scenarios like investigating CSS invalidation issues, adding new CSS features, or debugging test failures.

9. **Summarize the Specific Part:**  Finally, I focus on the *provided* code snippet. This section starts with `TEST_F(RuleFeatureSetTest, invalidatesHasInShadowTree)` and ends abruptly. Therefore, I summarize the functionality covered in *this specific portion* of the file, highlighting the tests related to `:has()`, `:host`, and the comparison tests using `ref_equal_test_data`.

10. **Structure and Refine:**  I organize the information logically, using headings and bullet points for clarity. I review the text for accuracy and conciseness. I ensure the language is clear and avoids overly technical jargon where possible while still being precise.

By following these steps, I can effectively analyze the code and generate a comprehensive summary that addresses all aspects of the request. The process involves understanding the code's purpose, analyzing individual components, connecting it to broader concepts, and providing concrete examples and explanations.
这是 `blink/renderer/core/css/rule_feature_set_test.cc` 文件的第三部分，它延续了对 Blink 引擎中 `RuleFeatureSet` 类的功能测试。根据提供的代码片段，我们可以归纳出以下功能：

**主要功能：测试 `RuleFeatureSet` 类如何收集和比较 CSS 规则的特征，特别是涉及到 CSS 选择器的各种复杂用法以及 `@scope` 规则。**

**具体功能点（基于提供的代码片段）：**

1. **测试 `:has()` 伪类在 Shadow DOM 中的失效场景:**
   - `invalidatesHasInShadowTree` 测试了当选择器中包含 `:has()` 且涉及到 Shadow DOM 时，`RuleFeatureSet` 如何收集失效信息。它验证了当 `.a` 或 `.b` 类发生变化时，选择器 `:host .a:has(.b) .c` 是否会正确地标记 `c` 需要失效。
   - **关系：CSS，HTML（Shadow DOM）**
   - **举例：** 当一个 Web 组件使用了 Shadow DOM，并且其样式规则中使用了 `:host .parent:has(.child) .target` 这样的选择器。这个测试确保了当 `.parent` 或 `.child` 的类名发生变化时，`.target` 元素能够正确地被标记为需要重新渲染。
   - **逻辑推理：**
     - **假设输入：** CSS 选择器 `:host .a:has(.b) .c`
     - **输出：**
       - 当 `.a` 变化时，`.c` 需要失效。
       - 当 `.b` 变化时，由于 `:has()` 的存在，需要更细粒度的失效判断 (NeedsHasInvalidationForClass)。
       - 当 `:has()` 自身变化时（伪类变化），`.c` 需要失效。

2. **测试多个 `:has()` 伪类的失效场景:**
   - `invalidatesMultipleHasAfterHostAtSubjectPosition` 和 `invalidatesMultipleHasAfterHostAtNonSubjectPosition` 测试了在 `:host` 之后使用多个 `:has()` 伪类时的失效行为。区分了 `:has()` 作为主题选择器和非主题选择器的情况。
   - **关系：CSS**
   - **举例：** CSS 选择器 `:host:has(.feature1):has(.feature2) .content`，测试当 `.feature1` 或 `.feature2` 的状态变化时，`.content` 是否需要失效。
   - **逻辑推理：**
     - **假设输入：** CSS 选择器 `:host:has(.a):has(.b)` 或 `:host:has(.a):has(.b) .c`
     - **输出：**
       - 当 `.a` 或 `.b` 变化时，需要 `Has` 失效判断。
       - 当 `:has()` 自身变化时，根据是否为主题选择器，失效目标不同。

3. **测试 `MediaQueryResultFlags` 的相等性:**
   - `MediaQueryResultFlagsEquality` 测试了 `RuleFeatureSet` 中用于存储媒体查询结果标志的结构体的相等性比较。
   - **关系：CSS（Media Queries）**
   - **举例：** 比较两个 `RuleFeatureSet` 对象，一个依赖于视口大小，另一个依赖于设备特性，验证它们不相等。
   - **逻辑推理：** 不同的媒体查询条件应该导致 `RuleFeatureSet` 对象不同。

4. **通过大量用例测试 `RuleFeatureSet` 的等价性:**
   - `ref_equal_test_data` 数组和 `RuleFeatureSetRefEqualTest` 测试套件定义了一系列 CSS 选择器对，预期它们的 `RuleFeatureSet` 表示是相等的。这主要测试了 `:is()` 伪类的各种用法，以及它与其他选择器的组合。
   - **关系：CSS**
   - **举例：** 测试 `:is(.a)` 和 `.a` 的 `RuleFeatureSet` 是否相同，或者更复杂的 `:is(.a :is(.b + .c))` 和 `.a .c, .b + .c` 的等价性。
   - **假设输入与输出：** 对于每一对选择器，期望 `CollectFeatures` 函数产生相同的 `RuleFeatureSet` 对象。例如，输入选择器字符串 `":is(.a, .b) .c"`，期望其生成的 `RuleFeatureSet` 与输入 `".a .c, .b .c"` 生成的相同。

5. **通过大量用例测试 `RuleFeatureSet` 的不等价性:**
   - `ref_not_equal_test_data` 数组和 `RuleFeatureSetRefNotEqualTest` 测试套件定义了一系列 CSS 选择器对，预期它们的 `RuleFeatureSet` 表示是不相等的。
   - **关系：CSS**
   - **举例：** 测试 `.a` 和 `.b` 的 `RuleFeatureSet` 是否不同。

6. **测试 `@scope` 规则的特征收集:**
   - `ref_scope_equal_test_data` 数组和 `RuleFeatureSetScopeRefTest` 测试套件定义了一系列 `@scope` 规则及其等价的普通 CSS 选择器，用于测试 `RuleFeatureSet` 如何处理作用域规则。
   - **关系：CSS**
   - **举例：** 测试 `@scope (.a) { div {} }` 和 `.a div, .a:is(div) {}` 的 `RuleFeatureSet` 是否相同。
   - **假设输入与输出：** 输入 `@scope (.a) { div {} }`，期望生成的 `RuleFeatureSet` 与输入 `.a div, .a:is(div) {}` 生成的相同。

**与 JavaScript, HTML, CSS 的关系举例:**

* **CSS:**  几乎所有的测试都直接与 CSS 选择器的解析和特征提取有关。例如，测试 `:has()`, `:is()`, `:not()`, `@scope` 等 CSS 特性。
* **HTML:**  `:host` 伪类与 Web Components 和 Shadow DOM 相关。失效机制最终影响的是 HTML 元素的渲染。
* **JavaScript:** 虽然这个文件是 C++ 代码，但它测试的 CSS 功能会被 JavaScript 所触发。例如，通过 JavaScript 修改元素的类名或样式，会触发 Blink 引擎的样式计算和失效流程，而 `RuleFeatureSet` 正是这个流程中的一部分。

**用户或编程常见的使用错误举例:**

* **CSS 选择器错误:**  开发者可能会写出不正确的 CSS 选择器，导致样式没有应用到预期的元素上。例如，错误地使用了 `:has()` 伪类的语法，或者混淆了不同组合器的作用。这些测试帮助确保 Blink 引擎能够正确处理各种选择器，即使是复杂的选择器。
* **对 Shadow DOM 的理解不足:**  开发者可能不清楚在 Shadow DOM 中使用 `:host` 和其他相关伪类的行为，导致样式作用域错误。`invalidatesHasInShadowTree` 这样的测试可以帮助发现与 Shadow DOM 相关的样式问题。
* **媒体查询配置错误:**  开发者可能在媒体查询中使用了错误的单位或条件，导致样式在不期望的情况下生效或失效。`MediaQueryResultFlagsEquality` 相关的测试可以帮助确保媒体查询相关的特征被正确处理。
* **对 `:is()` 和 `:not()` 的误用:**  开发者可能不完全理解 `:is()` 的分组作用或 `:not()` 的排除作用，导致样式规则的意外行为。大量的 `:is()` 和 `:not()` 测试用例旨在覆盖这些用法的各种场景。
* **对 `@scope` 规则的理解不足:**  开发者可能不清楚 `@scope` 规则如何限制样式的作用域，导致样式泄露或无法生效。`RuleFeatureSetScopeRefTest` 旨在验证引擎对 `@scope` 规则的正确处理。

**用户操作如何一步步的到达这里 (作为调试线索):**

1. **用户报告样式问题:** 用户在使用 Chromium 浏览器浏览网页时，发现某些元素的样式没有正确应用，或者在某些特定操作后样式发生了错误的变化。
2. **开发者进行调试:**  Web 开发者尝试使用浏览器的开发者工具（例如，Elements 面板）检查元素的样式，查看应用的 CSS 规则。
3. **怀疑是 CSS 选择器或失效问题:** 如果开发者发现样式规则存在，但没有生效，或者生效的时机不对，他们可能会怀疑是 CSS 选择器的问题，或者是浏览器的样式失效机制出现了问题。
4. **深入 Blink 引擎代码:** 为了更深入地理解问题，Chromium 开发者可能会查看 Blink 引擎的源代码，特别是与 CSS 样式计算和失效相关的部分。
5. **查看 `RuleFeatureSet` 相关代码:**  如果怀疑问题与 CSS 规则的特征提取或比较有关，开发者可能会查看 `blink/renderer/core/css/rule_feature_set.h` 和 `blink/renderer/core/css/rule_feature_set.cc` 文件。
6. **阅读或运行测试用例:** 为了理解 `RuleFeatureSet` 的具体工作方式以及它如何处理各种 CSS 选择器，开发者可能会查看 `blink/renderer/core/css/rule_feature_set_test.cc` 文件中的测试用例，例如我们正在分析的这个文件。通过阅读这些测试用例，开发者可以了解 `RuleFeatureSet` 预期如何处理特定的 CSS 场景。他们也可能运行这些测试用例来验证代码的行为是否符合预期。
7. **定位问题根源:** 通过阅读和运行测试用例，结合对代码的理解，开发者可以更准确地定位样式问题的根源，例如，是否是某个复杂的 CSS 选择器没有被正确解析，或者失效机制在特定情况下没有正常工作。

**总结第 3 部分的功能:**

这部分主要通过大量的单元测试，详细验证了 `RuleFeatureSet` 类在处理各种复杂 CSS 选择器（尤其是涉及到 `:is()`, `:not()`, `:has()`, 和 Shadow DOM）以及 `@scope` 规则时的特征收集和比较的正确性。这些测试用例覆盖了等价性和不等价性的场景，旨在确保 Blink 引擎能够准确地识别 CSS 规则的特征，为后续的样式计算和失效流程提供可靠的基础。 此外，也测试了媒体查询相关特征的存储和比较。

### 提示词
```
这是目录为blink/renderer/core/css/rule_feature_set_test.cc的chromium blink引擎源代码文件， 请列举一下它的功能, 
如果它与javascript, html, css的功能有关系，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索。
这是第3部分，共4部分，请归纳一下它的功能
```

### 源代码
```cpp
on_lists.siblings));
  }
}

TEST_F(RuleFeatureSetTest, invalidatesHasInShadowTree) {
  EXPECT_EQ(SelectorPreMatch::kMayMatch,
            CollectFeatures(":host .a:has(.b) .c"));

  {
    InvalidationLists invalidation_lists;
    CollectInvalidationSetsForClass(invalidation_lists, "a");
    EXPECT_TRUE(HasClassInvalidation("c", invalidation_lists.descendants));
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.siblings));
    EXPECT_FALSE(NeedsHasInvalidationForClass("a"));
  }

  {
    InvalidationLists invalidation_lists;
    CollectInvalidationSetsForClass(invalidation_lists, "b");
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.descendants));
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.siblings));
    EXPECT_TRUE(NeedsHasInvalidationForClass("b"));
  }

  {
    InvalidationLists invalidation_lists;
    CollectInvalidationSetsForPseudoClass(invalidation_lists,
                                          CSSSelector::kPseudoHas);
    EXPECT_EQ(1u, invalidation_lists.descendants.size());
    EXPECT_TRUE(HasClassInvalidation("c", invalidation_lists.descendants));
    EXPECT_FALSE(invalidation_lists.descendants[0]->TreeBoundaryCrossing());
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.siblings));
  }
}

TEST_F(RuleFeatureSetTest, invalidatesMultipleHasAfterHostAtSubjectPosition) {
  EXPECT_EQ(SelectorPreMatch::kMayMatch,
            CollectFeatures(":host:has(.a):has(.b)"));

  {
    InvalidationLists invalidation_lists;
    CollectInvalidationSetsForClass(invalidation_lists, "a");
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.descendants));
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.siblings));
    EXPECT_TRUE(NeedsHasInvalidationForClass("a"));
  }

  {
    InvalidationLists invalidation_lists;
    CollectInvalidationSetsForClass(invalidation_lists, "b");
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.descendants));
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.siblings));
    EXPECT_TRUE(NeedsHasInvalidationForClass("b"));
  }

  {
    InvalidationLists invalidation_lists;
    CollectInvalidationSetsForPseudoClass(invalidation_lists,
                                          CSSSelector::kPseudoHas);
    EXPECT_EQ(0u, invalidation_lists.descendants.size());
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.descendants));
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.siblings));
  }
}

TEST_F(RuleFeatureSetTest,
       invalidatesMultipleHasAfterHostAtNonSubjectPosition) {
  EXPECT_EQ(SelectorPreMatch::kMayMatch,
            CollectFeatures(":host:has(.a):has(.b) .c"));

  {
    InvalidationLists invalidation_lists;
    CollectInvalidationSetsForClass(invalidation_lists, "a");
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.descendants));
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.siblings));
    EXPECT_TRUE(NeedsHasInvalidationForClass("a"));
  }

  {
    InvalidationLists invalidation_lists;
    CollectInvalidationSetsForClass(invalidation_lists, "b");
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.descendants));
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.siblings));
    EXPECT_TRUE(NeedsHasInvalidationForClass("b"));
  }

  {
    InvalidationLists invalidation_lists;
    CollectInvalidationSetsForPseudoClass(invalidation_lists,
                                          CSSSelector::kPseudoHas);
    EXPECT_EQ(1u, invalidation_lists.descendants.size());
    EXPECT_TRUE(HasClassInvalidation("c", invalidation_lists.descendants));
    EXPECT_TRUE(invalidation_lists.descendants[0]->TreeBoundaryCrossing());
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.siblings));
  }
}

TEST_F(RuleFeatureSetTest, MediaQueryResultFlagsEquality) {
  RuleFeatureSet empty;

  RuleFeatureSet viewport_dependent;
  viewport_dependent.MutableMediaQueryResultFlags().is_viewport_dependent =
      true;

  RuleFeatureSet device_dependent;
  device_dependent.MutableMediaQueryResultFlags().is_device_dependent = true;

  RuleFeatureSet font_unit;
  font_unit.MutableMediaQueryResultFlags().unit_flags =
      MediaQueryExpValue::kFontRelative;

  RuleFeatureSet dynamic_viewport_unit;
  dynamic_viewport_unit.MutableMediaQueryResultFlags().unit_flags =
      MediaQueryExpValue::kDynamicViewport;

  EXPECT_EQ(empty, empty);
  EXPECT_EQ(viewport_dependent, viewport_dependent);
  EXPECT_EQ(device_dependent, device_dependent);
  EXPECT_EQ(font_unit, font_unit);

  EXPECT_NE(viewport_dependent, device_dependent);
  EXPECT_NE(empty, device_dependent);
  EXPECT_NE(font_unit, viewport_dependent);
  EXPECT_NE(font_unit, dynamic_viewport_unit);
}

struct RefTestData {
  const char* main;
  const char* ref;
};

// The test passes if |main| produces the same RuleFeatureSet as |ref|.
RefTestData ref_equal_test_data[] = {
    // clang-format off
    {".a", ".a"},

    // :is
    {":is(.a)", ".a"},
    {":is(.a .b)", ".a .b"},
    {".a :is(.b .c)", ".a .c, .b .c"},
    {".a + :is(.b .c)", ".a + .c, .b .c"},
    {".a + :is(.b .c)", ".a + .c, .b .c"},
    {"div + :is(.b .c)", "div + .c, .b .c"},
    {":is(.a :is(.b + .c))", ".a .c, .b + .c"},
    {".a + :is(.b) :is(.c)", ".a + .b .c"},
    {":is(#a:nth-child(1))", "#a:nth-child(1)"},
    {":is(#a:nth-child(1), #b:nth-child(1))",
     "#a:nth-child(1), #b:nth-child(1)"},
    {":is(#a, #b):nth-child(1)", "#a:nth-child(1), #b:nth-child(1)"},
    {":is(:nth-child(1))", ":nth-child(1)"},
    {".a :is(.b, .c):nth-child(1)", ".a .b:nth-child(1), .a .c:nth-child(1)"},
    // TODO(andruud): We currently add _all_ rightmost features to the nth-
    // sibling set, so .b is added here, since nth-child is present _somewhere_
    // in the rightmost compound. Hence the unexpected '.b:nth-child(1)'
    // selector in the ref.
    {".a :is(.b, .c:nth-child(1))",
     ".a .b, .a .c:nth-child(1), .b:nth-child(1)"},
    {":is(.a) .b", ".a .b"},
    {":is(.a, .b) .c", ".a .c, .b .c"},
    {":is(.a .b, .c .d) .e", ".a .b .e, .c .d .e"},
    {":is(:is(.a .b, .c) :is(.d, .e .f), .g) .h",
     ".a .b .h, .c .h, .d .h, .e .f .h, .g .h"},
    {":is(.a, .b) :is(.c, .d)", ".a .c, .a .d, .b .c, .b .d"},
    {":is(.a .b, .c .d) :is(.e .f, .g .h)",
     ".a .b .f, .a .b .h, .c .d .f, .c .d .h, .e .f, .g .h"},
    {":is(.a + .b)", ".a + .b"},
    {":is(.a + .b, .c + .d) .e", ".a + .b .e, .c + .d .e"},
    {":is(.a ~ .b, .c + .e + .f) :is(.c .d, .e)",
     ".a ~ .b .d, .a ~ .b .e, .c + .e + .f .d, .c + .e + .f .e, .c .d"},
    {":is(.a) + .b", ".a + .b"},
    {":is(.a, .b) + .c", ".a + .c, .b + .c"},
    {":is(.a + .b, .c + .d) + .e", ".a + .b + .e, .c + .d + .e"},
    {":is(.a + .b, .c + .d) + :is(.e + .f, .g + .h)",
     ".a + .b + .f, .a + .b + .h, .c + .d + .f, .c + .d + .h,"
     ".e + .f, .g + .h"},
    {":is(div)", "div"},
    {":is(div, span)", "div, span"},
    {":is(.a, div)", ".a, div"},
    {":is(.a, :is(div, span))", ".a, div, span"},
    {":is(.a, span) :is(div, .b)", ".a div, .a .b, span div, span .b"},
    {":is(.a, span) + :is(div, .b)",
     ".a + div, .a + .b, span + div, span + .b"},
    {":is(.a, .b)::slotted(.c)", ".a::slotted(.c), .b::slotted(.c)"},
    {".a :is(.b, .c)::slotted(.d)", ".a .b::slotted(.d), .a .c::slotted(.d)"},
    {".a + :is(.b, .c)::slotted(.d)",
     ".a + .b::slotted(.d), .a + .c::slotted(.d)"},
    {".a::slotted(:is(.b, .c))", ".a::slotted(.b), .a::slotted(.c)"},
    {":is(.a, .b)::cue(i)", ".a::cue(i), .b::cue(i)"},
    {".a :is(.b, .c)::cue(i)", ".a .b::cue(i), .a .c::cue(i)"},
    {".a + :is(.b, .c)::cue(i)", ".a + .b::cue(i), .a + .c::cue(i)"},
    {".a::cue(:is(.b, .c))", ".a::cue(.b), .a::cue(.c)"},
    {":is(.a, :host + .b, .c) .d", ".a .d, :host + .b .d, .c .d"},
    {":is(.a, :host(.b) .c, .d) div", ".a div, :host(.b) .c div, .d div"},
    {".a::host(:is(.b, .c))", ".a::host(.b), .a::host(.c)"},
    {".a :is(.b, .c)::part(foo)", ".a .b::part(foo), .a .c::part(foo)"},
    {":is(.a, .b)::part(foo)", ".a::part(foo), .b::part(foo)"},
    {":is(.a, .b) :is(.c, .d)::part(foo)",
     ".a .c::part(foo), .a .d ::part(foo),"
     ".b .c::part(foo), .b .d ::part(foo)"},
    {":is(.a, .b)::first-letter", ".a::first-letter, .b::first-letter"},
    {":is(.a, .b .c)::first-line", ".a::first-line, .b .c::first-line"},
    // TODO(andruud): Here we would normally expect a ref:
    // '.a::first-line, .b + .c::first-line', however the latter selector
    // currently marks the sibling invalidation set for .b as whole subtree
    // invalid, whereas the :is() version does not. This could be improved.
    {":is(.a, .b + .c)::first-line", ".a::first-line, .b + .c, .b + .c *"},
    {":is(.a, .b ~ .c > .d)::first-line",
     ".a::first-line, .b ~ .c > .d::first-line"},
    {":is(.a, :host-context(.b), .c)", ".a, :host-context(.b), .c"},
    {":is(.a, :host-context(.b), .c) .d", ".a .d, :host-context(.b) .d, .c .d"},
    {":is(.a, :host-context(.b), .c) + .d",
     ".a + .d, :host-context(.b) + .d, .c + .d"},
    {":host-context(.a) :is(.b, .c)",
     ":host-context(.a) .b, :host-context(.a) .c"},
    {":host-context(:is(.a))", ":host-context(.a)"},
    {":host-context(:is(.a, .b))", ":host-context(.a), :host-context(.b)"},
    {":is(.a, .b + .c).d", ".a.d, .b + .c.d"},
    {".a :is(.b .c .d).e", ".a .d.e, .b .c .d.e"},
    {":is(*)", "*"},
    {".a :is(*)", ".a *"},
    {":is(*) .a", "* .a"},
    {".a + :is(*)", ".a + *"},
    {":is(*) + .a", "* + .a"},
    {".a + :is(.b, *)", ".a + .b, .a + *"},
    {":is(.a, *) + .b", ".a + .b, * + .b"},
    {".a :is(.b, *)", ".a .b, .a *"},
    {":is(.a, *) .b", ".a .b, * .b"},
    {":is(.a + .b, .c) *", ".a + .b *, .c *"},
    {":is(.a + *, .c) *", ".a + * *, .c *"},
    {".a + .b + .c:is(*)", ".a + .b + .c"},
    {".a :not(.b)", ".a *, .b"},
    {".a :not(.b, .c)", ".a *, .b, .c"},
    {".a :not(.b, .c .d)", ".a *, .b, .c .d"},
    {".a :not(.b, .c + .d)", ".a *, .b, .c + .d"},
    {".a + :not(.b, .c + .d)", ".a + *, .b, .c + .d"},
    {":not(.a .b) .c", ".a .c, .b .c"},
    {":not(.a .b, .c) + .d", "* + .d, .a .b + .d, .c + .d"},
    {":not(.a .b, .c .d) :not(.e + .f, .g + .h)",
     ".a .b *, .c .d *, :not(.e + .f), :not(.g + .h)"},
    {":not(.a, .b)", ":not(.a), :not(.b)"},
    {":not(.a .b, .c)", ":not(.a .b), :not(.c)"},
    {":not(.a :not(.b + .c), :not(div))", ":not(.a :not(.b + .c)), :not(div)"},
    {":not(:is(.a))", ":not(.a)"},
    {":not(:is(.a, .b))", ":not(.a), :not(.b)"},
    {":not(:is(.a .b))", ":not(.a .b)"},
    {":not(:is(.a .b, .c + .d))", ":not(.a .b, .c + .d)"},
    {".a :not(:is(.b .c))", ".a :not(.b .c)"},
    {":not(:is(.a)) .b", ":not(.a) .b"},
    {":not(:is(.a .b, .c)) :not(:is(.d + .e, .f))",
     ":not(.a .b, .c) :not(.d + .e, .f)"},
    // We don't have any special support for nested :not(): it's treated
    // as a single :not() level in terms of invalidation:
    {":not(:not(.a))", ":not(.a)"},
    {":not(:not(:not(.a)))", ":not(.a)"},
    {".a :not(:is(:not(.b), .c))", ".a :not(.b), .a :not(.c)"},
    {":not(:is(:not(.a), .b)) .c", ":not(.a) .c, :not(.b) .c"},
    {".a :is(:hover)", ".a :hover"},
    {":is(:hover) .a", ":hover .a"},
    {"button:is(:hover, :focus)", "button:hover, button:focus"},
    {".a :is(.b, :hover)", ".a .b, .a :hover"},
    {".a + :is(:hover) + .c", ".a + :hover + .c"},
    {".a + :is(.b, :hover) + .c", ".a + .b + .c, .a + :hover + .c"},
    {":is(ol, li)::before", "ol::before, li::before"},
    {":is(.a + .b, .c)::before", ".a + .b::before, .c::before"},
    {":is(ol, li)::-internal-input-suggested",
     "ol::-internal-input-suggested, li::-internal-input-suggested"},
    {":is([foo], [bar])", "[foo], [bar]"},
    {".a :is([foo], [bar])", ".a [foo], .a [bar]"},
    {":is([foo], [bar]) .a", "[foo] .a, [bar] .a"},
    {":is([a], [b]) :is([c], [d])", "[a] [c], [a] [d], [b] [c], [b] [d]"},

    {"", "div"},
    {"", "::before"},
    {"", ":host"},
    {"", "*"},
    {"ol", "ul"},
    {"::cue(a)", "::cue(b)"},
    {"div", "span"},
    // clang-format on
};

// The test passes if |main| does not produce the same RuleFeatureSet as |ref|.
RefTestData ref_not_equal_test_data[] = {
    // clang-format off
    {"", ".a"},
    {"", "#a"},
    {"", ":hover"},
    {"", ":host(.a)"},
    {"", ":host-context(.a)"},
    {"", ":not(.a)"},
    {".a", ".b"},
    {".a", ".a, .b"},
    {"#a", "#b"},
    {"[foo]", "[bar]"},
    {":link", ":visited"},
    {".a::before", ".b::after"},
    {".a .b", ".a .c"},
    {".a + .b", ".a + .c"},
    {".a + .b .c", ".a + .b .d"},
    {"div + .a", "div + .b"},
    {".a:nth-child(1)", ".b:nth-child(1)"},
    // clang-format on
};

class RuleFeatureSetRefTest : public RuleFeatureSetTest {
 public:
  void Run(const RefTestData& data) {
    RuleFeatureSet main_set;
    RuleFeatureSet ref_set;

    SCOPED_TRACE(testing::Message() << "Ref: " << data.ref);
    SCOPED_TRACE(testing::Message() << "Main: " << data.main);
    SCOPED_TRACE("Please see RuleFeatureSet::ToString for documentation");

    CollectTo(data.main, main_set);
    CollectTo(data.ref, ref_set);

    Compare(main_set, ref_set);
  }

  virtual void CollectTo(
      const char*,
      RuleFeatureSet&,
      CSSNestingType nesting_type = CSSNestingType::kNone,
      StyleRule* parent_rule_for_nesting = nullptr) const = 0;
  virtual void Compare(const RuleFeatureSet&, const RuleFeatureSet&) const = 0;
};

class RuleFeatureSetSelectorRefTest : public RuleFeatureSetRefTest {
 public:
  void CollectTo(const char* text,
                 RuleFeatureSet& set,
                 CSSNestingType nesting_type = CSSNestingType::kNone,
                 StyleRule* parent_rule_for_nesting = nullptr) const override {
    CollectFeaturesTo(text, set, nesting_type, parent_rule_for_nesting);
  }
};

class RuleFeatureSetRefEqualTest
    : public RuleFeatureSetSelectorRefTest,
      public testing::WithParamInterface<RefTestData> {
 public:
  void Compare(const RuleFeatureSet& main,
               const RuleFeatureSet& ref) const override {
    EXPECT_EQ(main, ref);
  }
};

INSTANTIATE_TEST_SUITE_P(RuleFeatureSetTest,
                         RuleFeatureSetRefEqualTest,
                         testing::ValuesIn(ref_equal_test_data));

TEST_P(RuleFeatureSetRefEqualTest, All) {
  Run(GetParam());
}

class RuleFeatureSetRefNotEqualTest
    : public RuleFeatureSetSelectorRefTest,
      public testing::WithParamInterface<RefTestData> {
 public:
  void Compare(const RuleFeatureSet& main,
               const RuleFeatureSet& ref) const override {
    EXPECT_NE(main, ref);
  }
};

INSTANTIATE_TEST_SUITE_P(RuleFeatureSetTest,
                         RuleFeatureSetRefNotEqualTest,
                         testing::ValuesIn(ref_not_equal_test_data));

TEST_P(RuleFeatureSetRefNotEqualTest, All) {
  Run(GetParam());
}

RefTestData ref_scope_equal_test_data[] = {
    // Note that for ordering consistency :is() is sometimes used
    // "unnecessarily" in the refs below.
    {"@scope (.a) { div {} }", ".a div, .a:is(div) {}"},
    {"@scope (#a) { div {} }", "#a div, #a:is(div) {}"},
    {"@scope (main) { div {} }", "main div, main:is(div) {}"},
    {"@scope ([foo]) { div {} }", "[foo] div, [foo]:is(div) {}"},
    {"@scope (.a) { .b {} }", ".a .b, .a.b {}"},
    {"@scope (.a) { #b {} }", ".a #b, .a#b {}"},
    {"@scope (.a) { [foo] {} }", ".a [foo], .a[foo] {}"},
    {"@scope (.a) { .a {} }", ".a .a, .a.a {}"},

    // Sibling combinators:
    {"@scope (.a) { .b + .c {} }", ".b + .c, .a .c, .a {}"},
    {"@scope (.a, .b) { .c + .d {} }",
     ".c + .d, :is(.a, .b) .d, :is(.a, .b) {}"},
    {"@scope (.a) { .b ~ :scope {} }", ".b ~ *, .a *, .a {}"},
    {"@scope (.a) { .b + :scope {} }", ".b + *, .a *, .a {}"},

    // Multiple items in selector lists:
    {"@scope (.a, .b) { div {} }", ":is(.a, .b) div, :is(.a, .b):is(div) {}"},
    {"@scope (.a, :is(.b, .c)) { div {} }",
     ":is(.a, .b, .c) div, :is(.a, .b, .c):is(div) {}"},

    // Using "to" keyword:
    {"@scope (.a, .b) to (.c, .d) { div {} }",
     ":is(.a, .b, .c, .d) div, :is(.a, .b):is(.c, .d):is(div) {}"},

    // TODO(crbug.com/1280240): Many of the following tests current expect
    // whole-subtree invalidation, because we don't extract any features from
    // :scope. That should be improved.

    // Explicit :scope:
    {"@scope (.a) { :scope {} }", ".a *, .a {}"},
    {"@scope (.a) { .b :scope {} }", ".a :is(.b *), .b .a {}"},
    {"@scope (.a, .b) { :scope {} }", ":is(.a, .b) *, :is(.a, .b) {}"},

    {"@scope (.a) to (:scope) { .b {} }", ".a .b, .a.b {}"},
    {"@scope (.a) to (:scope) { :scope {} }", ".a *, .a {}"},
    {"@scope (.a, .b) { @scope (.c, :scope .d) { .e {} } }",
     ":is(.a, .b):is(.c, .d) .e, :is(.a, .b):is(.c, .d):is(.e) {}"},

    // &
    {"@scope (.a) { & {} }", ".a .a {}"},
    {"@scope (.a) { .b & {} }", ".b .a, .a .a {}"},
    {"@scope (.a, .b) { & {} }", ":is(.a, .b) :is(.a, .b) {}"},

    {"@scope (.a, .b) { @scope (.c, & .d) { .e {} } }",
     ":is(.a, .b, .c, .d) .e, :is(.a, .b), :is(.c, .d) {}"},
    {"@scope (.a) to (&) { .b {} }", ".a .b, .a {}"},
    {"@scope (.a) to (&) { & {} }", ".a .a {}"},

    // Nested @scopes
    {"@scope (.a, .b) { @scope (.c, .d) { .e {} } }",
     ":is(.a, .b, .c, .d) .e, :is(.a, .b, .c, .d):is(.e) {}"},
    {"@scope (.a, .b) { @scope (.c, .d) { :scope {} } }",
     ":is(.a, .b, .c, .d) *, :is(.a, .b, .c, .d) {}"},
    {"@scope (.a, .b) { @scope (:scope, .c) { :scope {} } }",
     ":is(.a, .b, .c) *, :is(.a, .b, .c) {}"},
    {"@scope (.a) to (.b) { @scope (.c) to (.d) { .e {} } }",
     ":is(.a, .b, .c, .d) .e, :is(.a, .b):is(.c, .d):is(.e) {}"},
};

class RuleFeatureSetScopeRefTest
    : public RuleFeatureSetRefTest,
      public testing::WithParamInterface<RefTestData> {
 public:

  void CollectTo(const char* text,
                 RuleFeatureSet& set,
                 CSSNestingType nesting_type = CSSNestingType::kNone,
                 StyleRule* parent_rule_for_nesting = nullptr) const override {
    Document* document =
        Document::CreateForTest(execution_context_.GetExecutionContext());
    StyleRuleBase* rule = css_test_helpers::ParseRule(*document, text);
    ASSERT_TRUE(rule);

    const StyleScope* scope = nullptr;

    // Find the inner StyleRule.
    while (IsA<StyleRuleScope>(rule)) {
      auto& scope_rule = To<StyleRuleScope>(*rule);
      scope = scope_rule.GetStyleScope().CopyWithParent(scope);
      const HeapVector<Member<StyleRuleBase>>& child_rules =
          scope_rule.ChildRules();
      ASSERT_EQ(1u, child_rules.size());
      rule = child_rules[0].Get();
    }

    auto* style_rule = DynamicTo<StyleRule>(rule);
    ASSERT_TRUE(style_rule);

    CollectFeaturesTo(style_rule, scope, set);
  }

  void Compare(const RuleFeatureSet& main,
               const RuleFeatureSet& ref) const override {
    EXPECT_EQ(main, ref);
  }
};

INSTANTIATE_TEST_SUITE_P(SelectorChecker,
                         RuleFeatureSetScopeRefTest,
                         testing::ValuesIn(ref_scope_equal_test_data));

TEST_P(RuleFeatureSetScopeRefTest, All) {
  Run(GetParam());
}

TEST_F(RuleFeatureSetTest, CopyOnWrite) {
  // RuleFeatureSet local1 has an entry in each of the class/id/attribute/
  // pseudo sets.
  RuleFeatureSet local1;
  CollectFeatures(".a .b");
  CollectFeatures("#d .e");
  CollectFeatures("[thing] .f");
  CollectFeatures(":hover .h");
  MergeInto(local1);
  ClearFeatures();
  EXPECT_TRUE(HasRefCountForClassInvalidationSet(local1, "a", RefCount::kOne));
  EXPECT_TRUE(HasRefCountForIdInvalidationSet(local1, "d", RefCount::kOne));
  EXPECT_TRUE(
      HasRefCountForAttributeInvalidationSet(local1, "thing", RefCount::kOne));
  EXPECT_TRUE(HasRefCountForPseudoInvalidationSet(
      local1, CSSSelector::kPseudoHover, RefCount::kOne));

  // RuleFeatureSet local2 overlaps partially with local1.
  RuleFeatureSet local2;
  CollectFeatures(".a .c");
  CollectFeatures("#d img");
  MergeInto(local2);
  ClearFeatures();
  EXPECT_TRUE(HasRefCountForClassInvalidationSet(local2, "a", RefCount::kOne));
  EXPECT_TRUE(HasRefCountForIdInvalidationSet(local2, "d", RefCount::kOne));

  // RuleFeatureSet local3 overlaps partially with local1, but not with local2.
  RuleFeatureSet local3;
  CollectFeatures("[thing] .g");
  CollectFeatures(":hover .i");
  MergeInto(local3);
  ClearFeatures();
  EXPECT_TRUE(
      HasRefCountForAttributeInvalidationSet(local3, "thing", RefCount::kOne));
  EXPECT_TRUE(HasRefCountForPseudoInvalidationSet(
      local3, CSSSelector::kPseudoHover, RefCount::kOne));

  // Using an empty RuleFeatureSet to simulate the global RuleFeatureSet:
  RuleFeatureSet global;

  // After adding local1, we expect to share the InvalidationSets with local1.
  global.Merge(local1);
  EXPECT_TRUE(HasRefCountForClassInvalidationSet(global, "a", RefCount::kMany));
  EXPECT_TRUE(HasRefCountForIdInvalidationSet(global, "d", RefCount::kMany));
  EXPECT_TRUE(
      HasRefCountForAttributeInvalidationSet(global, "thing", RefCount::kMany));
  EXPECT_TRUE(HasRefCountForPseudoInvalidationSet(
      global, CSSSelector::kPseudoHover, RefCount::kMany));

  // For the InvalidationSet keys that overlap with local1, |global| now had to
  // copy the existing InvalidationSets at those keys before modifying them,
  // so we expect |global| to be the only reference holder to those
  // InvalidationSets.
  global.Merge(local2);
  EXPECT_TRUE(HasRefCountForClassInvalidationSet(global, "a", RefCount::kOne));
  EXPECT_TRUE(HasRefCountForIdInvalidationSet(global, "d", RefCount::kOne));
  EXPECT_TRUE(
      HasRefCountForAttributeInvalidationSet(global, "thing", RefCount::kMany));
  EXPECT_TRUE(HasRefCountForPseudoInvalidationSet(
      global, CSSSelector::kPseudoHover, RefCount::kMany));

  global.Merge(local3);
  EXPECT_TRUE(HasRefCountForClassInvalidationSet(global, "a", RefCount::kOne));
  EXPECT_TRUE(HasRefCountForIdInvalidationSet(global, "d", RefCount::kOne));
  EXPECT_TRUE(
      HasRefCountForAttributeInvalidationSet(global, "thing", RefCount::kOne));
  EXPECT_TRUE(HasRefCountForPseudoInvalidationSet(
      global, CSSSelector::kPseudoHover, RefCount::kOne));
}

TEST_F(RuleFeatureSetTest, CopyOnWrite_SiblingDescendantPairs) {
  // Test data:
  Vector<const char*> data;
  // Descendant.
  data.push_back(".a .b0");
  data.push_back(".a .b1");
  // Sibling.
  data.push_back(".a + .b2");
  data.push_back(".a + .b3");
  // Sibling with sibling descendants.
  data.push_back(".a + .b4 .b5");
  data.push_back(".a + .b6 .b7");
  // Sibling with descendants.
  data.push_back(".a + .b8, .a .b9");
  data.push_back(".a + .b10, .a .b11");
  // Sibling with sibling descendants and descendants.
  data.push_back(".a + .b12 .b13, .a .b14");
  data.push_back(".a + .b15 .b16, .a .b17");

  // For each possible pair in |data|, make sure that we are properly sharing
  // the InvalidationSet from |local1| until we add the InvalidationSet from
  // |local2|.
  for (const char* selector1 : data) {
    for (const char* selector2 : data) {
      RuleFeatureSet local1;
      CollectFeatures(selector1);
      MergeInto(local1);
      ClearFeatures();

      RuleFeatureSet local2;
      CollectFeatures(selector2);
      MergeInto(local2);
      ClearFeatures();

      RuleFeatureSet global;
      global.Merge(local1);
      EXPECT_TRUE(
          HasRefCountForClassInvalidationSet(global, "a", RefCount::kMany));
      global.Merge(local2);
      EXPECT_TRUE(
          HasRefCountForClassInvalidationSet(global, "a", RefCount::kOne));
    }
  }
}

TEST_F(RuleFeatureSetTest, CopyOnWrite_SelfInvalidation) {
  RuleFeatureSet local1;
  CollectFeatures(".a");
  MergeInto(local1);
  ClearFeatures();

  RuleFeatureSet local2;
  CollectFeatures(".a");
  MergeInto(local2);
  ClearFeatures();

  // Adding the SelfInvalidationSet to the SelfInvalidationSet does not cause
  // a copy.
  RuleFeatureSet global;
  global.Merge(local1);
  EXPECT_TRUE(HasRefCountForClassInvalidationSet(global, "a", RefCount::kMany));
  global.Merge(local2);
  EXPECT_TRUE(HasRefCountForClassInvalidationSet(global, "a", RefCount::kMany));
}

TEST_F(RuleFeatureSetTest, isPseudoContainingComplexInsideHas1) {
  EXPECT_EQ(SelectorPreMatch::kMayMatch, CollectFeatures(".a:has(:is(.b .c))"));

  {
    InvalidationLists invalidation_lists;
    CollectInvalidationSetsForClass(invalidation_lists, "a");
    EXPECT_TRUE(HasSelfInvalidation(invalidation_lists.descendants));
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.siblings));
  }

  {
    InvalidationLists invalidation_lists;
    CollectInvalidationSetsForClass(invalidation_lists, "b");
    EXPECT_TRUE(HasClassInvalidation("a", invalidation_lists.descendants));
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.siblings));
  }

  {
    InvalidationLists invalidation_lists;
    CollectInvalidationSetsForClass(invalidation_lists, "c");
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.descendants));
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.siblings));
  }
}

TEST_F(RuleFeatureSetTest, isPseudoContainingComplexInsideHas2) {
  EXPECT_EQ(SelectorPreMatch::kMayMatch,
            CollectFeatures(".a:has(:is(.b > .c))"));

  {
    InvalidationLists invalidation_lists;
    CollectInvalidationSetsForClass(invalidation_lists, "a");
    EXPECT_TRUE(HasSelfInvalidation(invalidation_lists.descendants));
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.siblings));
  }

  {
    InvalidationLists invalidation_lists;
    CollectInvalidationSetsForClass(invalidation_lists, "b");
    EXPECT_TRUE(HasClassInvalidation("a", invalidation_lists.descendants));
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.siblings));
  }

  {
    InvalidationLists invalidation_lists;
    CollectInvalidationSetsForClass(invalidation_lists, "c");
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.descendants));
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.siblings));
  }
}

TEST_F(RuleFeatureSetTest, isPseudoContainingComplexInsideHas3) {
  EXPECT_EQ(SelectorPreMatch::kMayMatch,
            CollectFeatures(".a:has(~ :is(.b ~ .c))"));

  {
    InvalidationLists invalidation_lists;
    CollectInvalidationSetsForClass(invalidation_lists, "a");
    EXPECT_TRUE(HasSelfInvalidation(invalidation_lists.descendants));
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.siblings));
  }

  {
    InvalidationLists invalidation_lists;
    CollectInvalidationSetsForClass(invalidation_lists, "b");
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.descendants));
    EXPECT_TRUE(
        HasSiblingClassInvalidation(SiblingInvalidationSet::kDirectAdjacentMax,
                                    "a", invalidation_lists.siblings));
    EXPECT_TRUE(
        HasSiblingNoDescendantInvalidation(invalidation_lists.siblings));
  }

  {
    InvalidationLists invalidation_lists;
    CollectInvalidationSetsForClass(invalidation_lists, "c");
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.descendants));
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.siblings));
  }
}

TEST_F(RuleFeatureSetTest, isPseudoContainingComplexInsideHas4) {
  EXPECT_EQ(SelectorPreMatch::kMayMatch,
            CollectFeatures(".a:has(~ :is(.b + .c))"));

  {
    InvalidationLists invalidation_lists;
    CollectInvalidationSetsForClass(invalidation_lists, "a");
    EXPECT_TRUE(HasSelfInvalidation(invalidation_lists.descendants));
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.siblings));
  }

  {
    InvalidationLists invalidation_lists;
    CollectInvalidationSetsForClass(invalidation_lists, "b");
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.descendants));
    EXPECT_TRUE(
        HasSiblingClassInvalidation(SiblingInvalidationSet::kDirectAdjacentMax,
                                    "a", invalidation_lists.siblings));
    EXPECT_TRUE(
        HasSiblingNoDescendantInvalidation(invalidation_lists.siblings));
  }

  {
    InvalidationLists invalidation_lists;
    CollectInvalidationSetsForClass(invalidation_lists, "c");
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.descendants));
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.siblings));
  }
}

TEST_F(RuleFeatureSetTest, isPseudoContainingComplexInsideHas5) {
  EXPECT_EQ(SelectorPreMatch::kMayMatch,
            CollectFeatures(".a:has(~ :is(.b .c ~ .d))"));

  {
    InvalidationLists invalidation_lists;
    CollectInvalidationSetsForClass(invalidation_lists, "a");
    EXPECT_TRUE(HasSelfInvalidation(invalidation_lists.descendants));
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.siblings));
  }

  {
    InvalidationLists invalidation_lists;
    CollectInvalidationSetsForClass(invalidation_lists, "b");
    EXPECT_TRUE(HasClassInvalidation("a", invalidation_lists.descendants));
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.siblings));
  }

  {
    InvalidationLists invalidation_lists;
    CollectInvalidationSetsForClass(invalidation_lists, "c");
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.descendants));
    EXPECT_TRUE(
        HasSiblingClassInvalidation(SiblingInvalidationSet::kDirectAdjacentMax,
                                    "a", invalidation_lists.siblings));
    EXPECT_TRUE(
        HasSiblingNoDescendantInvalidation(invalidation_lists.siblings));
  }

  {
    InvalidationLists invalidation_lists;
    CollectInvalidationSetsForClass(invalidation_lists, "d");
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.descendants));
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.siblings));
  }
}

TEST_F(RuleFeatureSetTest, isPseudoContainingComplexInsideHas6) {
  EXPECT_EQ(SelectorPreMatch::kMayMatch,
            CollectFeatures(".a:has(~ :is(.b > .c + .d))"));

  {
    InvalidationLists invalidation_lists;
    CollectInvalidationSetsForClass(invalidation_lists, "a");
    EXPECT_TRUE(HasSelfInvalidation(invalidation_lists.descendants));
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.siblings));
  }

  {
    InvalidationLists invalidation_lists;
    CollectInvalidationSetsForClass(invalidation_lists, "b");
    EXPECT_TRUE(HasClassInvalidation("a", invalidation_lists.descendants));
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.siblings));
  }

  {
    InvalidationLists invalidation_lists;
    CollectInvalidationSetsForClass(invalidation_lists, "c");
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.descendants));
    EXPECT_TRUE(
        HasSiblingClassInvalidation(SiblingInvalidationSet::kDirectAdjacentMax,
                                    "a", invalidation_lists.siblings));
    EXPECT_TRUE(
        HasSiblingNoDescendantInvalidation(invalidation_lists.siblings));
  }

  {
    InvalidationLists invalidation_lists;
    CollectInvalidationSetsForClass(invalidation_lists, "d");
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.descendants));
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.siblings));
  }
}

TEST_F(RuleFeatureSetTest, isPseudoContainingComplexInsideHas7) {
  EXPECT_EQ(SelectorPreMatch::kMayMatch,
            CollectFeatures(".a:has(:is(.b ~ .c .d))"));

  {
    InvalidationLists invalidation_lists;
    CollectInvalidationSetsForClass(invalidation_lists, "a");
    EXPECT_TRUE(HasSelfInvalidation(invalidation_lists.descendants));
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.siblings));
  }

  {
    InvalidationLists invalidation_lists;
    CollectInvalidationSetsForClass(invalidation_lists, "b");
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.descendants));
    EXPECT_TRUE(
        HasSiblingAndSiblingDescendantInvalidationForLogicalCombinationsInHas(
            "a", "c", "a", invalidation_lists.siblings));
  }

  {
    InvalidationLists invalidation_lists;
    CollectInvalidationSetsForClass(invalidation_lists, "c");
    EXPECT_TRUE(HasClassInvalidation("a", invalidation_lists.descendants));
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.siblings));
  }

  {
    InvalidationLists invalidation_lists;
    CollectInvalidationSetsForClass(invalidation_lists, "d");
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.descendants));
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.siblings));
  }
}

TEST_F(RuleFeatureSetTest, isPseudoContainingComplexInsideHas8) {
  EXPECT_EQ(SelectorPreMatch::kMayMatch,
            CollectFeatures(".a:has(:is(.b + .c > .d))"));

  {
    InvalidationLists invalidation_lists;
    CollectInvalidationSetsForClass(invalidation_lists, "a");
    EXPECT_TRUE(HasSelfInvalidation(invalidation_lists.descendants));
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.siblings));
  }

  {
    InvalidationLists invalidation_lists;
    CollectInvalidationSetsForClass(invalidation_lists, "b");
    EXPECT_TRUE(HasNoInvalidation(invalidation_lists.descendants));
    EXPECT_TRUE(
        HasSiblingAndSiblingDescendantInvalidationForLogicalCombinationsInHas(
            "a", "c", "a", invalidation_lists.siblings));
  }

  {
    InvalidationLists invalidation_lists;
    CollectInvalidationSetsForClass(invalidation_lists, "c");
    EXPECT_TRUE(HasClassInvalidation("a"
```
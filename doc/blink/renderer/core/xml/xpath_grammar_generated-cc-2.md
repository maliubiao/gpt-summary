Response:
Let's break down the thought process for analyzing this C++ code snippet.

**1. Initial Understanding and Context:**

The very first step is to recognize the context provided: `blink/renderer/core/xml/xpath_grammar_generated.cc`. This immediately tells us several crucial things:

* **Blink Renderer:** This is part of the Chromium rendering engine, responsible for displaying web pages.
* **Core XML:** It deals with XML processing within the rendering engine.
* **XPath Grammar:** This specifically points to the implementation of XPath, a language for navigating and selecting nodes in XML documents.
* **`_generated.cc`:** This suffix strongly suggests that this file is automatically generated, likely from a grammar definition file (like a `.y` file used by `yacc` or `bison`).

**2. High-Level Purpose Identification:**

Based on the context, the primary function of this file is clear: **It's the generated C++ code for parsing XPath expressions.**  This is the core of the file's functionality.

**3. Analyzing Code Structure (Even Without Deep Understanding):**

Even without meticulously understanding every line, we can observe key structural elements:

* **`YyParser` Class:**  The presence of a class named `YyParser` is a strong indicator of a parser implementation. Parsers often have a central class to manage the parsing process.
* **`parse()` Method:**  The `parse()` method is a typical entry point for initiating the parsing process.
* **State Machine Logic:**  The `yynewstate`, `yyerrlab`, `yyacceptlab`, and `yyabortlab` labels, along with the `yystack_`, `yypact_`, `yytable_`, and `yycheck_` arrays, strongly suggest a table-driven parser implementation (likely generated by `yacc` or `bison`). These elements manage the parser's state, actions, and error handling.
* **Error Handling:** The `yyerrlab` section and the `error()` method clearly indicate mechanisms for handling syntax errors in the XPath expression.
* **Symbol Definitions (`symbol_kind`):** The mention of `symbol_kind` suggests an enumeration or class defining the different tokens (keywords, operators, literals) in the XPath language.
* **Debugging Support (`YYDEBUG`):** The conditional compilation using `#if YYDEBUG` points to built-in debugging features, like stack printing and rule reduction information.
* **Token Translation (`yytranslate_`):** The `yytranslate_` function suggests a way to map the output of a lexer (which breaks the input string into tokens) to the parser's internal representation of those tokens.

**4. Connecting to Web Technologies (JavaScript, HTML, CSS):**

Now, let's relate this to the broader web context:

* **JavaScript:**  JavaScript often needs to interact with the DOM (Document Object Model) of an HTML or XML document. XPath provides a powerful way for JavaScript to query and select specific nodes within that DOM. Therefore, this XPath parser is likely used by JavaScript APIs that support XPath (like `document.evaluate()` in browsers).
* **HTML:** While XPath is primarily designed for XML, browsers often allow its use on HTML documents as well (treating them as a form of XML). So, this parser could be used when XPath is applied to HTML.
* **CSS:**  CSS Selectors are a different language for selecting elements in HTML. While XPath and CSS Selectors have overlapping functionality, they are distinct. This file is *not* directly involved in parsing CSS Selectors. However, both serve the purpose of selecting elements within a document, and there might be internal architectural reasons why they reside in related parts of the rendering engine. It's important to distinguish them, though.

**5. Logic Reasoning and Examples (Hypothetical):**

Since the code is a parser, the core logic is about transforming an input string (the XPath expression) into a structured representation (an abstract syntax tree or similar).

* **Input:**  `//div[@id='main']/p`
* **Output (Conceptual):** A tree structure representing the steps: select all `div` elements with the attribute `id` equal to 'main', then select all `p` elements that are descendants of those `div` elements. The generated code will contain the logic to perform these steps based on the grammar rules.

**6. Common Errors:**

Think about what could go wrong when writing XPath expressions:

* **Syntax Errors:**  Misspelled keywords, incorrect operator usage, unbalanced parentheses, etc. The `yyerrlab` section and the `error()` method are directly related to handling these errors.
* **Semantic Errors:**  Valid syntax, but the expression doesn't select the intended nodes (e.g., referring to a non-existent attribute). While the *parser* might not catch these, the *evaluation* phase (which happens after parsing) would.

**7. Debugging and User Actions:**

How does a user end up triggering this code?

1. **JavaScript Interaction:** A JavaScript developer uses `document.evaluate()` with an XPath expression. The browser then needs to parse that expression, leading to this code being executed.
2. **Developer Tools:** Browsers' developer tools often allow inspecting elements using XPath. Typing an XPath query in the "Elements" panel could trigger this parsing logic.
3. **Internal Browser Operations:** Some internal browser functionalities might use XPath for configuration or data manipulation.

**8.归纳功能 (Summarizing the Function):**

Finally, after analyzing the code and its context, we summarize its core function:

* **Parses XPath Expressions:**  Transforms a text-based XPath string into an internal representation that can be used to evaluate the expression against an XML or HTML document.
* **Generated Code:** It's automatically generated from a grammar definition.
* **Error Handling:** Detects and reports syntax errors in XPath expressions.
* **Foundation for XPath Evaluation:**  The parsing is a necessary first step before the XPath expression can be actually executed to select nodes.

This systematic approach, moving from high-level context to detailed code analysis and then connecting it back to the broader web ecosystem, is crucial for understanding the purpose and functionality of a code file like this.
这是`blink/renderer/core/xml/xpath_grammar_generated.cc`文件的第三部分，延续了前面两部分的内容，共同构成了 XPath 语法解析器的 C++ 代码实现。

**归纳其功能：**

总的来说，`xpath_grammar_generated.cc` 文件的功能是**实现了一个用于解析 XPath 表达式的语法分析器**。 这个分析器是由类似 `bison` 或 `yacc` 这样的语法分析器生成工具根据 `xpath_grammar.y` (或其他类似的 `.y` 文件) 定义的语法规则自动生成的。

**具体来说，这第三部分主要负责以下功能：**

1. **错误处理和恢复机制：**
   - **`yyerrlab` 和 `yyerrlab1` 标签：**  定义了当解析过程中遇到语法错误时的处理逻辑。
   - **`yyerrstatus_` 变量：** 用于跟踪错误状态，防止在错误恢复期间重复报错。
   - **错误消息报告：**  通过调用 `error()` 函数报告遇到的语法错误。
   - **丢弃错误的 token：**  如果尝试重用错误的 lookahead token 失败，则会丢弃它。
   - **堆栈回溯和错误 token 移入：** 当发生错误时，会弹出堆栈直到找到一个可以移入错误 token 的状态，然后移入错误 token，尝试继续解析。

2. **成功和失败处理：**
   - **`yyacceptlab` 标签：**  当解析成功完成时跳转到这里，设置 `yyresult` 为 0。
   - **`yyabortlab` 标签：**  当解析因错误或其他原因中止时跳转到这里，设置 `yyresult` 为 1。

3. **资源清理：**
   - **`yyreturn` 标签：**  解析结束后执行的清理操作。
   - **丢弃 lookahead token：** 如果存在未处理的 lookahead token，则会销毁它。
   - **弹出堆栈：**  在解析结束后，会弹出剩余的堆栈元素并销毁它们。

4. **异常处理（可选）：**
   - **`catch (...)` 块（在 `#if YY_EXCEPTIONS` 中）：**  如果启用了异常处理，则会捕获异常，清理 lookahead token 和堆栈，然后重新抛出异常。

5. **错误消息接口：**
   - **`error(const syntax_error& yyexc)` 函数：**  提供了一个接受 `syntax_error` 异常对象的 `error` 函数重载。

6. **调试支持：**
   - **`symbol_name(symbol_kind_type yysymbol)` 函数（在 `#if YYDEBUG || 0` 中）：**  在调试模式下，返回给定符号的名称字符串。
   - **`yypact_ninf_` 和 `yytable_ninf_` 常量：**  定义了 `yypact_` 和 `yytable_` 数组中的负无穷值，用于表示默认行为。

7. **解析表数据：**
   - **`yypact_[]`，`yydefact_[]`，`yypgoto_[]`，`yydefgoto_[]`，`yytable_[]`，`yycheck_[]`，`yystos_[]`，`yyr1_[]`，`yyr2_[]` 数组：**  这些数组存储了驱动语法分析器的核心数据，包括：
     - `yypact_`: Action 表（根据当前状态和输入符号决定执行的操作）。
     - `yydefact_`: Default Action 表（当 Action 表中没有对应项时使用的默认操作）。
     - `yypgoto_`: Goto 表（在规约后决定跳转到的新状态）。
     - `yydefgoto_`: Default Goto 表。
     - `yytable_`: 包含 Action 表和 Goto 表的数据。
     - `yycheck_`: 用于验证 `yytable_` 中条目的有效性。
     - `yystos_`: 存储每个状态的符号。
     - `yyr1_`: 每个规约规则左侧非终结符的编号。
     - `yyr2_`: 每个规约规则右侧符号的个数。

8. **符号名称表（调试）：**
   - **`yytname_[]` 数组（在 `#if YYDEBUG` 中）：**  在调试模式下，存储了所有终结符和非终结符的名称字符串。

9. **行号表（调试）：**
   - **`yyrline_[]` 数组（在 `#if YYDEBUG` 中）：**  在调试模式下，存储了每个规约规则在源文件中的行号。

10. **堆栈打印和规约打印（调试）：**
    - **`yy_stack_print_()` 函数（在 `#if YYDEBUG` 中）：**  在调试模式下，打印当前的解析堆栈。
    - **`yy_reduce_print_(int yyrule)` 函数（在 `#if YYDEBUG` 中）：**  在调试模式下，打印正在进行的规约操作的详细信息。

11. **Token 翻译：**
    - **`yytranslate_(int t)` 函数：**  将词法分析器（lexer）生成的 token 编号转换为语法分析器内部使用的符号编号。

**与 JavaScript, HTML, CSS 的关系：**

* **JavaScript:**  JavaScript 可以通过 DOM API (例如 `document.evaluate()`) 执行 XPath 查询来选取 HTML 或 XML 文档中的节点。 这个 `xpath_grammar_generated.cc` 文件生成的解析器就是负责解析这些 JavaScript 代码中提供的 XPath 字符串，将其转换为内部结构以便进行后续的节点查找和匹配。

    **举例说明：**
    假设 JavaScript 代码中有如下语句：
    ```javascript
    const element = document.evaluate("//div[@id='content']/p[1]", document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
    ```
    当执行 `document.evaluate()` 时，传入的 XPath 字符串 `//div[@id='content']/p[1]` 就需要被解析。 `xpath_grammar_generated.cc` 中生成的解析器会分析这个字符串，理解它的含义（选取 id 为 'content' 的 div 元素的第一个 p 子元素）。

* **HTML:** XPath 主要用于 XML 文档，但浏览器通常也支持在 HTML 文档上使用 XPath。 当 JavaScript 对 HTML 文档执行 XPath 查询时，这个解析器同样会被调用来处理 XPath 表达式。

* **CSS:**  CSS 使用选择器来选取 HTML 元素进行样式设置。 虽然 XPath 和 CSS 选择器在功能上有一定的重叠，但它们是不同的语言。 `xpath_grammar_generated.cc` **不负责解析 CSS 选择器**。  CSS 选择器的解析由 Blink 引擎中专门的 CSS 解析器模块负责。  虽然都涉及到文档元素的选取，但它们的实现机制和语法规则是不同的。

**逻辑推理和假设输入输出：**

假设用户输入一个 XPath 表达式：`/bookstore/book[price>30]/title`

1. **词法分析 (lexer) 阶段 (虽然不在本文件中，但先假设)：**  词法分析器会将输入字符串分解成 token 流：
   ```
   '/', "kAxisName"(bookstore), '/', "kAxisName"(book), '[', "kAxisName"(price), "kRelOp"(>), "kNumber"(30), ']', '/', "kAxisName"(title)
   ```

2. **语法分析 (parser) 阶段 (本文件主要负责)：**  `xpath_grammar_generated.cc` 中的解析器会根据语法规则，逐步将 token 组合成语法结构：
   - 移入 '/'
   - 移入 "kAxisName"(bookstore)
   - 执行规约，形成一个 LocationPath 的一部分
   - 移入 '/'
   - 移入 "kAxisName"(book)
   - 移入 '['
   - 移入 "kAxisName"(price)
   - 移入 "kRelOp"(>)
   - 移入 "kNumber"(30)
   - 执行规约，形成一个 Predicate
   - 移入 ']'
   - 执行规约，将 Predicate 关联到 Step
   - 移入 '/'
   - 移入 "kAxisName"(title)
   - ...最终完成整个 XPath 表达式的解析，形成一个抽象语法树 (AST) 或类似的内部表示。

**假设输入：**  XPath 表达式字符串 `"//div[@class='item' and text()='Example']/a"`

**可能的输出（抽象表示）：**  一个表示 XPath 结构的内部对象，例如：

```
LocationPath {
  absolute: false,
  steps: [
    Step {
      axis: DescendantOrSelf,
      nodeTest: NameTest { name: "div" },
      predicates: [
        Predicate {
          expr: BinaryExpr {
            op: "and",
            left: BinaryExpr {
              op: "=",
              left: AttributeAccessor { name: "class" },
              right: Literal { value: "item" }
            },
            right: BinaryExpr {
              op: "=",
              left: FunctionCall { name: "text", arguments: [] },
              right: Literal { value: "Example" }
            }
          }
        }
      ]
    },
    Step {
      axis: Child,
      nodeTest: NameTest { name: "a" },
      predicates: []
    }
  ]
}
```
（这只是一个简化的概念性输出，实际的内部表示会更复杂）

**用户或编程常见的使用错误：**

1. **语法错误：**  XPath 表达式中存在不符合语法规则的部分。
   - **假设输入：** `"//div[@id='my-id'"`  (缺少闭合的方括号)
   - **输出：**  解析器会调用 `error()` 函数报告语法错误，例如 "syntax error, unexpected end of file"。

2. **拼写错误：**  XPath 的关键字或函数名拼写错误。
   - **假设输入：** `"//selekt[@class='foo']"` (`select` 拼写错误为 `selekt`)
   - **输出：**  解析器可能会将其识别为未知的轴名称或其他类型的 token，并报告相应的语法错误。

3. **括号不匹配：**  圆括号或方括号没有正确匹配。
   - **假设输入：** `"//div[(@class='bar')]"` (多余的圆括号)
   - **输出：**  解析器会报告语法错误，例如 "syntax error, unexpected ')'"。

4. **运算符使用错误：**  使用了错误的运算符或运算符的位置不正确。
   - **假设输入：** `"//book price > 10"` (缺少路径分隔符)
   - **输出：**  解析器会报告语法错误，因为它期望在轴名称或节点测试之后看到路径分隔符。

**用户操作如何一步步到达这里（作为调试线索）：**

1. **用户在网页的 JavaScript 代码中编写了使用 XPath 的代码：**
   ```javascript
   const elements = document.querySelectorAll('div'); // 假设有多个 div 元素
   elements.forEach(element => {
       const title = document.evaluate("./h2/text()", element, null, XPathResult.STRING_TYPE, null).stringValue;
       console.log(title);
   });
   ```

2. **当浏览器执行这段 JavaScript 代码时，遇到了 `document.evaluate()` 函数。**

3. **`document.evaluate()` 内部会调用 Blink 引擎中处理 XPath 的相关模块。**

4. **XPath 表达式字符串 `"./h2/text()"` 被传递给 XPath 解析器。**

5. **`xpath_grammar_generated.cc` 中生成的解析器开始工作，对该字符串进行词法分析和语法分析。**

6. **如果在解析过程中发现任何语法错误（例如，用户将表达式写成 `"./h2/tex()"`），则会触发 `yyerrlab` 相关的错误处理逻辑，并调用 `error()` 函数报告错误。**

7. **开发者可以通过浏览器开发者工具的 Console 面板看到错误信息，从而定位问题所在。**

**总结：**

`xpath_grammar_generated.cc` 文件的第三部分是 XPath 语法解析器实现的关键组成部分，负责处理解析过程中的错误、成功和失败状态，进行资源清理，并包含了驱动解析器的核心数据表。 它在浏览器处理 JavaScript 中执行的 XPath 查询时发挥着至关重要的作用。理解这部分代码的功能有助于理解 Blink 引擎如何解析和处理 XPath 表达式，并能帮助开发者调试与 XPath 相关的错误。

### 提示词
```
这是目录为blink/renderer/core/xml/xpath_grammar_generated.cc的chromium blink引擎源代码文件， 请列举一下它的功能, 
如果它与javascript, html, css的功能有关系，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索。
这是第3部分，共3部分，请归纳一下它的功能
```

### 源代码
```cpp
NULLPTR, YY_MOVE (yylhs));
    }
    goto yynewstate;


  /*--------------------------------------.
  | yyerrlab -- here on detecting error.  |
  `--------------------------------------*/
  yyerrlab:
    // If not already recovering from an error, report this error.
    if (!yyerrstatus_)
      {
        ++yynerrs_;
        std::string msg = YY_("syntax error");
        error (YY_MOVE (msg));
      }


    if (yyerrstatus_ == 3)
      {
        /* If just tried and failed to reuse lookahead token after an
           error, discard it.  */

        // Return failure if at end of input.
        if (yyla.kind () == symbol_kind::S_YYEOF)
          YYABORT;
        else if (!yyla.empty ())
          {
            yy_destroy_ ("Error: discarding", yyla);
            yyla.clear ();
          }
      }

    // Else will try to reuse lookahead token after shifting the error token.
    goto yyerrlab1;


  /*---------------------------------------------------.
  | yyerrorlab -- error raised explicitly by YYERROR.  |
  `---------------------------------------------------*/
  yyerrorlab:
    /* Pacify compilers when the user code never invokes YYERROR and
       the label yyerrorlab therefore never appears in user code.  */
    if (false)
      YYERROR;

    /* Do not reclaim the symbols of the rule whose action triggered
       this YYERROR.  */
    yypop_ (yylen);
    yylen = 0;
    YY_STACK_PRINT ();
    goto yyerrlab1;


  /*-------------------------------------------------------------.
  | yyerrlab1 -- common code for both syntax error and YYERROR.  |
  `-------------------------------------------------------------*/
  yyerrlab1:
    yyerrstatus_ = 3;   // Each real token shifted decrements this.
    // Pop stack until we find a state that shifts the error token.
    for (;;)
      {
        yyn = yypact_[+yystack_[0].state];
        if (!yy_pact_value_is_default_ (yyn))
          {
            yyn += symbol_kind::S_YYerror;
            if (0 <= yyn && yyn <= yylast_
                && yycheck_[yyn] == symbol_kind::S_YYerror)
              {
                yyn = yytable_[yyn];
                if (0 < yyn)
                  break;
              }
          }

        // Pop the current state because it cannot handle the error token.
        if (yystack_.size () == 1)
          YYABORT;

        yy_destroy_ ("Error: popping", yystack_[0]);
        yypop_ ();
        YY_STACK_PRINT ();
      }
    {
      stack_symbol_type error_token;


      // Shift the error token.
      error_token.state = state_type (yyn);
      yypush_ ("Shifting", YY_MOVE (error_token));
    }
    goto yynewstate;


  /*-------------------------------------.
  | yyacceptlab -- YYACCEPT comes here.  |
  `-------------------------------------*/
  yyacceptlab:
    yyresult = 0;
    goto yyreturn;


  /*-----------------------------------.
  | yyabortlab -- YYABORT comes here.  |
  `-----------------------------------*/
  yyabortlab:
    yyresult = 1;
    goto yyreturn;


  /*-----------------------------------------------------.
  | yyreturn -- parsing is finished, return the result.  |
  `-----------------------------------------------------*/
  yyreturn:
    if (!yyla.empty ())
      yy_destroy_ ("Cleanup: discarding lookahead", yyla);

    /* Do not reclaim the symbols of the rule whose action triggered
       this YYABORT or YYACCEPT.  */
    yypop_ (yylen);
    YY_STACK_PRINT ();
    while (1 < yystack_.size ())
      {
        yy_destroy_ ("Cleanup: popping", yystack_[0]);
        yypop_ ();
      }

    return yyresult;
  }
#if YY_EXCEPTIONS
    catch (...)
      {
        YYCDEBUG << "Exception caught: cleaning lookahead and stack\n";
        // Do not try to display the values of the reclaimed symbols,
        // as their printers might throw an exception.
        if (!yyla.empty ())
          yy_destroy_ (YY_NULLPTR, yyla);

        while (1 < yystack_.size ())
          {
            yy_destroy_ (YY_NULLPTR, yystack_[0]);
            yypop_ ();
          }
        throw;
      }
#endif // YY_EXCEPTIONS
  }

  void
  YyParser::error (const syntax_error& yyexc)
  {
    error (yyexc.what ());
  }

#if YYDEBUG || 0
  const char *
  YyParser::symbol_name (symbol_kind_type yysymbol)
  {
    return yytname_[yysymbol];
  }
#endif // #if YYDEBUG || 0





  const signed char YyParser::yypact_ninf_ = -44;

  const signed char YyParser::yytable_ninf_ = -1;

  const signed char
  YyParser::yypact_[] =
  {
      77,    77,   -44,    -9,    -4,    18,   -44,   -44,   -44,   -44,
     -44,    19,    -2,   -44,    77,   -44,    36,   -44,   -44,    13,
     -44,    11,    19,    -2,   -44,    19,   -44,    21,   -44,    17,
      34,    38,    44,    46,    20,    49,   -44,   -44,    25,    -3,
      59,    77,   -44,    19,   -44,    13,    29,   -44,    -2,    -2,
      19,    19,   -44,    13,    19,    95,    -2,    -2,    77,    77,
      77,    77,    77,    77,    77,   -44,    30,   -44,   -44,   -44,
       0,   -44,    31,   -44,   -44,   -44,   -44,   -44,   -44,   -44,
      13,    13,    38,    44,    46,    20,    49,    49,   -44,   -44,
     -44,    77,   -44,   -44
  };

  const signed char
  YyParser::yydefact_[] =
  {
       0,     0,    16,     0,     0,     0,    31,    29,    32,    28,
      26,    21,     5,    17,     0,    27,     0,    41,     4,     3,
       8,     0,    21,     0,    15,    45,    33,    60,    39,    42,
       2,    47,    49,    51,    53,    55,    58,    61,     0,     0,
       0,     0,    12,    22,    23,     6,     0,     1,     0,     0,
      21,    21,    11,     7,    46,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,    18,     0,    19,    34,    38,
       0,    36,     0,    24,    30,     9,    10,    14,    13,    40,
      43,    44,    48,    50,    52,    54,    56,    57,    59,    20,
      35,     0,    25,    37
  };

  const signed char
  YyParser::yypgoto_[] =
  {
     -44,     2,   -44,   -44,   -11,   -43,   -44,    35,   -18,    33,
     -36,   -16,   -44,   -44,   -44,   -44,   -32,   -44,     5,   -44,
     -44,     3,     8,    -5,     1,   -23,    -1
  };

  const signed char
  YyParser::yydefgoto_[] =
  {
      -1,    69,    17,    18,    19,    20,    21,    22,    42,    43,
      44,    23,    24,    25,    26,    70,    71,    27,    28,    29,
      30,    31,    32,    33,    34,    35,    36
  };

  const signed char
  YyParser::yytable_[] =
  {
      37,    45,    16,    49,    52,    75,    76,    73,     2,     3,
       4,    66,    53,    57,    38,     9,    46,    11,    73,    39,
      13,    67,     3,     4,    90,    15,    62,    63,    91,    49,
      50,    10,    77,    78,    48,    10,    47,    49,    56,    86,
      87,    40,    58,    72,    41,    80,    81,    59,    60,    65,
      55,    61,    64,    74,    89,    84,    51,    92,    54,    93,
      79,    82,    85,    88,    49,    49,     1,    83,     0,     2,
       3,     4,     5,     6,     7,     8,     9,    10,    11,     0,
      12,    13,    14,    68,     1,     0,    15,     2,     3,     4,
       5,     6,     7,     8,     9,    10,    11,     0,    12,    13,
      14,     0,     0,     0,    15,     2,     3,     4,     5,     6,
       7,     8,     9,    10,    11,     0,    12,    13,    14,     0,
       0,     0,    15
  };

  const signed char
  YyParser::yycheck_[] =
  {
       1,    12,     0,    19,    22,    48,    49,    43,    10,    11,
      12,    14,    23,    29,    23,    17,    14,    19,    54,    23,
      22,    24,    11,    12,    24,    27,     6,     7,    28,    45,
      19,    18,    50,    51,    21,    18,     0,    53,    21,    62,
      63,    23,     8,    41,    25,    56,    57,     9,     4,    24,
      29,     5,     3,    24,    24,    60,    21,    26,    25,    91,
      55,    58,    61,    64,    80,    81,     7,    59,    -1,    10,
      11,    12,    13,    14,    15,    16,    17,    18,    19,    -1,
      21,    22,    23,    24,     7,    -1,    27,    10,    11,    12,
      13,    14,    15,    16,    17,    18,    19,    -1,    21,    22,
      23,    -1,    -1,    -1,    27,    10,    11,    12,    13,    14,
      15,    16,    17,    18,    19,    -1,    21,    22,    23,    -1,
      -1,    -1,    27
  };

  const signed char
  YyParser::yystos_[] =
  {
       0,     7,    10,    11,    12,    13,    14,    15,    16,    17,
      18,    19,    21,    22,    23,    27,    31,    32,    33,    34,
      35,    36,    37,    41,    42,    43,    44,    47,    48,    49,
      50,    51,    52,    53,    54,    55,    56,    56,    23,    23,
      23,    25,    38,    39,    40,    34,    31,     0,    21,    41,
      19,    37,    38,    34,    39,    29,    21,    41,     8,     9,
       4,     5,     6,     7,     3,    24,    14,    24,    24,    31,
      45,    46,    31,    40,    24,    35,    35,    38,    38,    48,
      34,    34,    51,    52,    53,    54,    55,    55,    56,    24,
      24,    28,    26,    46
  };

  const signed char
  YyParser::yyr1_[] =
  {
       0,    30,    31,    32,    32,    33,    33,    33,    34,    34,
      34,    35,    35,    35,    35,    35,    36,    36,    37,    37,
      37,    38,    38,    39,    39,    40,    41,    42,    42,    43,
      43,    43,    43,    43,    44,    44,    45,    45,    46,    47,
      47,    48,    48,    48,    48,    49,    49,    50,    50,    51,
      51,    52,    52,    53,    53,    54,    54,    54,    55,    55,
      56,    56
  };

  const signed char
  YyParser::yyr2_[] =
  {
       0,     2,     1,     1,     1,     1,     2,     2,     1,     3,
       3,     2,     2,     3,     3,     1,     1,     1,     3,     3,
       4,     0,     1,     1,     2,     3,     1,     1,     1,     1,
       3,     1,     1,     1,     3,     4,     1,     3,     1,     1,
       3,     1,     1,     3,     3,     1,     2,     1,     3,     1,
       3,     1,     3,     1,     3,     1,     3,     3,     1,     3,
       1,     2
  };


#if YYDEBUG
  // YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
  // First, the terminals, then, starting at \a YYNTOKENS, nonterminals.
  const char*
  const YyParser::yytname_[] =
  {
  "\"end of file\"", "error", "\"invalid token\"", "kMulOp", "kEqOp",
  "kRelOp", "kPlus", "kMinus", "kOr", "kAnd", "kAxisName", "kNodeType",
  "kPI", "kFunctionName", "kLiteral", "kVariableReference", "kNumber",
  "kDotDot", "kSlashSlash", "kNameTest", "kXPathError", "'/'", "'@'",
  "'('", "')'", "'['", "']'", "'.'", "','", "'|'", "$accept", "Expr",
  "LocationPath", "AbsoluteLocationPath", "RelativeLocationPath", "Step",
  "AxisSpecifier", "NodeTest", "OptionalPredicateList", "PredicateList",
  "Predicate", "DescendantOrSelf", "AbbreviatedStep", "PrimaryExpr",
  "FunctionCall", "ArgumentList", "Argument", "UnionExpr", "PathExpr",
  "FilterExpr", "OrExpr", "AndExpr", "EqualityExpr", "RelationalExpr",
  "AdditiveExpr", "MultiplicativeExpr", "UnaryExpr", YY_NULLPTR
  };
#endif


#if YYDEBUG
  const short
  YyParser::yyrline_[] =
  {
       0,   136,   136,   144,   150,   158,   163,   168,   176,   182,
     188,   197,   205,   220,   228,   243,   247,   249,   256,   266,
     271,   279,   283,   290,   296,   304,   311,   318,   323,   330,
     335,   340,   345,   350,   354,   361,   370,   376,   384,   388,
     390,   399,   404,   406,   412,   421,   423,   430,   432,   439,
     441,   448,   450,   457,   459,   466,   468,   473,   480,   482,
     489,   491
  };

  void
  YyParser::yy_stack_print_ () const
  {
    *yycdebug_ << "Stack now";
    for (stack_type::const_iterator
           i = yystack_.begin (),
           i_end = yystack_.end ();
         i != i_end; ++i)
      *yycdebug_ << ' ' << int (i->state);
    *yycdebug_ << '\n';
  }

  void
  YyParser::yy_reduce_print_ (int yyrule) const
  {
    int yylno = yyrline_[yyrule];
    int yynrhs = yyr2_[yyrule];
    // Print the symbols being reduced, and their result.
    *yycdebug_ << "Reducing stack by rule " << yyrule - 1
               << " (line " << yylno << "):\n";
    // The symbols being reduced.
    for (int yyi = 0; yyi < yynrhs; yyi++)
      YY_SYMBOL_PRINT ("   $" << yyi + 1 << " =",
                       yystack_[(yynrhs) - (yyi + 1)]);
  }
#endif // YYDEBUG

  YyParser::symbol_kind_type
  YyParser::yytranslate_ (int t)
  {
    // YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to
    // TOKEN-NUM as returned by yylex.
    static
    const signed char
    translate_table[] =
    {
       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
      23,    24,     2,     2,    28,     2,    27,    21,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,    22,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,    25,     2,    26,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,    29,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
      15,    16,    17,    18,    19,    20
    };
    // Last valid token kind.
    const int code_max = 275;

    if (t <= 0)
      return symbol_kind::S_YYEOF;
    else if (t <= code_max)
      return YY_CAST (symbol_kind_type, translate_table[t]);
    else
      return symbol_kind::S_YYUNDEF;
  }

#line 77 "third_party/blink/renderer/core/xml/xpath_grammar.y"
} // xpathyy
#line 2021 "third_party/blink/renderer/core/xml/xpath_grammar_generated.cc"

#line 498 "third_party/blink/renderer/core/xml/xpath_grammar.y"
```
Response:
Let's break down the thought process for analyzing the provided C++ code for the XPath parser.

1. **Understand the Goal:** The request asks for the functionality of the `xpath_parser.cc` file, its relationship to web technologies (JavaScript, HTML, CSS), examples of its logic, common user errors, and how a user might trigger its execution.

2. **Initial Code Scan (High-Level):**  First, skim the code to get a general sense of its purpose. Keywords like "XPath," "Parser," "Token," "Lex," and "Parse" immediately suggest that this file is responsible for taking XPath expressions (strings) and converting them into some internal representation that can be evaluated. The presence of `third_party/blink` strongly indicates this is part of a browser engine.

3. **Identify Core Functionality:**  Look for the main class and its key methods. The `Parser` class stands out. The `ParseStatement` method seems to be the entry point for parsing an XPath string. The `Lex` method is likely responsible for the lexical analysis (breaking the string into tokens). `NextTokenInternal` and `NextToken` appear to be helper functions for retrieving the next token.

4. **Analyze Key Methods in Detail:**

   * **`ParseStatement`:**  This method's arguments (`statement`, `resolver`, `exception_state`) provide context. It takes an XPath string, a namespace resolver, and an object to report errors. The call to `YyParser(this).parse()` suggests it uses a generated parser (likely using something like Bison or Yacc, as hinted by `xpath_grammar_generated.h`). This confirms its primary function is parsing.

   * **`Lex`:**  This method seems to be the interface between the lexer and the parser generated by `YyParser`. It calls `NextToken` to get the next token and then populates the `yylval` structure with the token's value.

   * **`NextTokenInternal`:** This is where the real lexical analysis happens. It skips whitespace, then checks the first character to determine the type of token (operators, strings, numbers, names, etc.). The logic for handling different token types (string literals, numbers, names, operators) should be examined more closely. The use of `PeekCurHelper` and `PeekAheadHelper` suggests lookahead is needed for certain tokens.

   * **Helper Functions:**  Functions like `LexString`, `LexNumber`, `LexNCName`, `LexQName` are clearly responsible for recognizing specific lexical structures. `IsBinaryOperatorContext` is interesting – it highlights the context-sensitive nature of XPath parsing. `ExpandQName` reveals how namespace prefixes are resolved.

5. **Relate to Web Technologies (JavaScript, HTML, CSS):**

   * **JavaScript:**  The code includes `<script>` tags. The most obvious connection is the `document.evaluate()` method, which allows JavaScript to execute XPath queries against the DOM. This is the primary user-facing API that triggers the XPath parser. Think about how JavaScript passes the XPath string to the browser engine.

   * **HTML:** XPath queries operate on the HTML DOM tree. The parser needs to understand the structure of the DOM to correctly interpret XPath expressions. Examples of selecting elements, attributes, and text nodes based on HTML structure are crucial.

   * **CSS:** While not a direct link, both XPath and CSS selectors target elements in a document. It's worth mentioning the conceptual similarity even though the syntax and capabilities differ.

6. **Logic Inference and Examples:**

   * **Tokenization:**  Pick a few common XPath constructs (e.g., `/`, `//`, `@`, `text()`, node names, string literals, numbers) and trace how `NextTokenInternal` would identify them. Show the input XPath snippet and the corresponding token.

   * **Namespace Handling:** Demonstrate how `ExpandQName` would resolve a prefixed name given a resolver. Show an example with a namespace declaration in the HTML.

   * **Binary Operator Disambiguation:** Illustrate how `IsBinaryOperatorContext` is used to differentiate between the multiplication operator (`*`) and the wildcard node test (`*`).

7. **Common User Errors:** Think about the mistakes developers commonly make when writing XPath expressions:

   * Incorrect syntax (typos, missing quotes, unmatched brackets).
   * Incorrect namespace prefixes.
   * Trying to use XPath features not supported by the browser (if any).

8. **Debugging Clues (How to Reach This Code):**  Think about the sequence of user actions that would lead to the execution of this code:

   * User opens a web page.
   * JavaScript code on the page calls `document.evaluate()`.
   * The browser engine receives the XPath string.
   * The browser engine creates an instance of the `Parser` class.
   * The `ParseStatement` method is called.
   * The lexer (`NextTokenInternal`, etc.) and the generated parser are used to analyze the XPath string.

9. **Structure and Refine:** Organize the findings into logical sections. Use clear headings and examples. Ensure the explanation is easy to understand for someone who might not be deeply familiar with browser internals. Review the generated answer and look for areas where more detail or clarity could be added. For instance, explicitly stating the role of `xpath_grammar_generated.h` reinforces the idea of a generated parser.

**Self-Correction Example during the process:** Initially, I might focus too heavily on the low-level details of the lexer. Then, realizing the prompt also asks about the *purpose* and *relevance* to web technologies, I would shift focus to the higher-level functions like `ParseStatement` and how they connect to JavaScript's `document.evaluate()`. I would also ensure I provide clear examples to illustrate the concepts. Similarly, I might initially forget to mention the role of `xpath_grammar_generated.h` and would add that in a later refinement step to provide a more complete picture.
这个文件 `xpath_parser.cc` 是 Chromium Blink 渲染引擎中负责解析 XPath 表达式的核心组件。它的主要功能是将一个字符串形式的 XPath 表达式转换成一个内部的、可执行的表达式树结构。

以下是它的功能及其与 JavaScript, HTML, CSS 的关系，逻辑推理，常见错误和调试线索的详细说明：

**文件功能:**

1. **词法分析 (Lexical Analysis):**
   - 将输入的 XPath 字符串分解成一个个有意义的单元，称为“词法单元”或“Token”。
   - 例如，将字符串 `/bookstore/book[@category='fiction']` 分解成 `/`, `bookstore`, `/`, `book`, `[@`, `category`, `=`, `'fiction'`, `]`.
   - `NextTokenInternal()` 和相关的 `Lex...` 函数（如 `LexString`, `LexNumber`, `LexNCName`, `LexQName`) 负责执行词法分析。
   - 它会识别关键字（如 `and`, `or`, `div`, `mod`），操作符（如 `/`, `//`, `@`, `=`, `<`, `>`），函数名（如 `text()`, `comment()`），节点类型（如 `node()`, `text()`），轴名称（如 `child`, `parent`, `ancestor`），字符串字面量，数字字面量等。

2. **语法分析 (Syntactic Analysis):**
   - 接收词法分析器产生的 Token 序列，并根据 XPath 的语法规则，构建一个抽象语法树 (AST) 或其他内部表示形式。
   - 这个过程检查 XPath 表达式是否符合语法规范。
   - `YyParser` (在 `third_party/blink/renderer/core/xml/xpath_grammar_generated.h` 中定义，通常由类似 Bison 或 Yacc 的工具生成) 负责执行语法分析。`ParseStatement` 函数是解析的入口点。

3. **错误处理:**
   - 在词法分析和语法分析过程中，如果发现输入的 XPath 表达式不符合规范，会报告错误。
   - 例如，如果缺少引号，或者使用了未知的轴名称。
   - `exception_state` 参数用于报告错误信息。

4. **命名空间解析:**
   - XPath 支持 XML 命名空间。`ExpandQName` 函数负责解析带有命名空间前缀的名称，将其分解为本地名称和命名空间 URI。
   - 它依赖于 `V8XPathNSResolver` 接口，该接口允许 JavaScript 提供命名空间前缀到 URI 的映射。

**与 JavaScript, HTML, CSS 的关系:**

* **JavaScript:**
    - **主要接口:** JavaScript 中的 `document.evaluate()` 方法是触发 XPath 解析和执行的主要途径。当你调用 `document.evaluate()` 并传入一个 XPath 字符串时，Blink 引擎会使用 `xpath_parser.cc` 来解析这个字符串。
    - **`V8XPathNSResolver`:**  `document.evaluate()` 方法可以接受一个 `XPathNSResolver` 对象作为参数。这个对象允许 JavaScript 代码提供自定义的命名空间解析逻辑。Blink 会将这个 JavaScript 对象包装成 `V8XPathNSResolver` 传递给解析器。

    **例子:**

    ```javascript
    const xpathExpression = "/bookstore/book[@category='fiction']/title/text()";
    const result = document.evaluate(xpathExpression, document, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);

    if (result.snapshotLength > 0) {
      console.log(result.snapshotItem(0).nodeValue);
    }
    ```
    在这个例子中，`xpath_parser.cc` 会解析 `xpathExpression` 字符串。

* **HTML:**
    - **XPath 的目标:** XPath 表达式通常用于查询和选择 HTML 或 XML 文档中的节点。解析后的 XPath 表达式会在 HTML 文档的 DOM 树上进行求值。
    - **文档上下文:** `document.evaluate()` 的第二个参数指定了 XPath 查询的上下文节点，通常是 `document` 本身，或者文档中的某个特定元素。

    **例子:**

    假设有以下 HTML 片段：

    ```html
    <bookstore xmlns:b="http://example.org/books">
      <b:book category="fiction">
        <title>The Great Gatsby</title>
      </b:book>
    </bookstore>
    ```

    JavaScript 代码：

    ```javascript
    const resolver = {
      lookupNamespaceURI: function(prefix) {
        if (prefix === 'b') {
          return 'http://example.org/books';
        }
        return null;
      }
    };

    const xpathExpression = "/b:bookstore/b:book/title/text()";
    const result = document.evaluate(xpathExpression, document, resolver, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
    ```
    在这个例子中，`xpath_parser.cc` 需要使用 `resolver` 来解析 `b:bookstore` 和 `b:book` 中的命名空间前缀 `b`。

* **CSS:**
    - **间接关系:** CSS 选择器和 XPath 都用于选择文档中的元素，但它们的语法和功能有所不同。浏览器内部可能使用类似的词法分析和语法分析技术来处理 CSS 选择器，但 `xpath_parser.cc` 主要负责 XPath 的解析。
    - **没有直接调用:** CSS 解析过程不会直接调用 `xpath_parser.cc`。

**逻辑推理 (假设输入与输出):**

假设输入一个简单的 XPath 表达式：`//div[@id='myDiv']`

1. **词法分析:**
   - `//` -> `TokenType::kSlashSlash`
   - `div` -> `TokenType::kNameTest`, value: "div"
   - `[` -> `[`
   - `@` -> `@`
   - `id` -> `TokenType::kNameTest`, value: "id"
   - `=` -> `TokenType::kEqOp`, value: `EqTestOp::kOpcodeEqual`
   - `'myDiv'` -> `TokenType::kLiteral`, value: "myDiv"
   - `]` -> `]`

2. **语法分析:**
   - `YyParser` 会根据 XPath 的语法规则，将这些 Token 组合成一个表达式树。
   - 可能会生成类似以下的结构：
     - `PathExpression`
       - `StepExpression` (axis: `descendant-or-self`, nodeTest: "node()")
         - `StepExpression` (axis: `child`, nodeTest: "div")
           - `Predicate`
             - `EqualityExpression`
               - `AttributeAccessor` (name: "id")
               - `LiteralExpression` (value: "myDiv")

**用户或编程常见的使用错误:**

1. **语法错误:**
   - 缺少引号： `/bookstore/book[@category=fiction]` (应该为 `[@category='fiction']`)
   - 括号不匹配： `/bookstore/book[price > 10` (缺少右括号)
   - 使用了 XPath 不支持的语法。

   **例子:** 用户在 JavaScript 中使用了错误的 XPath 字符串：

   ```javascript
   const xpath = "/bookstore/book[price > 10"; // 缺少 ]
   try {
     document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
   } catch (e) {
     console.error(e); // 会抛出一个 DOMException: "The string '/bookstore/book[price > 10' is not a valid XPath expression."
   }
   ```

2. **命名空间错误:**
   - 在使用了命名空间的 XML 文档中，XPath 表达式没有正确处理命名空间前缀。

   **例子:**

   ```xml
   <html xmlns="http://www.w3.org/1999/xhtml">
     <div>Hello</div>
   </html>
   ```

   ```javascript
   // 错误的 XPath，没有处理 HTML 命名空间
   const xpath = "//div";
   const result = document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
   console.log(result.singleNodeValue); // 可能为 null

   // 正确的 XPath，需要处理 HTML 命名空间
   const resolver = {
     lookupNamespaceURI: function(prefix) {
       if (prefix === 'h') {
         return 'http://www.w3.org/1999/xhtml';
       }
       return null;
     }
   };
   const xpathWithNS = "//h:div";
   const resultWithNS = document.evaluate(xpathWithNS, document, resolver, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
   console.log(resultWithNS.singleNodeValue); // 应该能找到 div 元素
   ```
   在这种情况下，`xpath_parser.cc` 会在 `ExpandQName` 中尝试使用提供的 `resolver` 来解析 `h:div`。如果 `resolver` 无法找到 `h` 前缀的命名空间 URI，就会抛出命名空间错误。

3. **使用了浏览器不支持的 XPath 功能 (虽然 XPath 1.0 的支持已经很广泛):**
   - 尝试使用 XPath 2.0 或更高版本的功能，这些功能可能尚未在所有浏览器中实现。

**用户操作是如何一步步的到达这里 (调试线索):**

1. **用户在浏览器中访问一个网页。**
2. **网页的 JavaScript 代码执行。**
3. **JavaScript 代码中调用了 `document.evaluate(xpathExpression, ...)` 方法。**
4. **浏览器引擎接收到 `document.evaluate` 的调用，并将 XPath 字符串传递给 Blink 的 XPath 模块。**
5. **Blink 的 XPath 模块创建 `xpath::Parser` 类的实例。**
6. **调用 `parser->ParseStatement(xpathExpression, resolver, exception_state)` 方法。**
7. **`ParseStatement` 方法内部：**
   - 调用 `Reset` 方法初始化解析器状态。
   - 设置命名空间解析器 `resolver_`。
   - 创建 `YyParser` 实例，并将当前的 `Parser` 对象传递给它。
   - 调用 `YyParser::parse()` 方法开始语法分析。
   - 在 `YyParser::parse()` 过程中，会多次调用 `Parser::Lex` 方法来获取下一个 Token。
   - `Parser::Lex` 方法会调用 `Parser::NextToken()`，最终调用 `Parser::NextTokenInternal()` 来执行词法分析。
   - 如果在词法分析或语法分析过程中发现错误，会设置 `got_namespace_error_` 或抛出异常。
8. **如果解析成功，`ParseStatement` 方法会返回构建好的表达式树 (`top_expr_`)。**
9. **XPath 模块随后会对这个表达式树在当前的 DOM 树上进行求值。**

**调试线索:**

- **断点:** 在 `xpath_parser.cc` 的 `ParseStatement`, `Lex`, `NextTokenInternal`, `ExpandQName` 等关键函数设置断点，可以观察 XPath 字符串是如何被分解成 Token，以及如何构建表达式树的。
- **日志:** 在这些函数中添加日志输出，可以跟踪解析过程中的状态和变量值。
- **Chrome DevTools:** 使用 Chrome DevTools 的 "Sources" 面板，可以逐步执行 JavaScript 代码，查看 `document.evaluate` 调用时传递的 XPath 字符串，并观察是否提供了自定义的命名空间解析器。
- **错误信息:** 仔细查看浏览器控制台中抛出的 XPath 错误信息，这些信息通常会指出错误的类型和位置。

总而言之，`xpath_parser.cc` 是 Blink 引擎中一个至关重要的组件，它负责将用户提供的 XPath 字符串转化为可执行的指令，使得 JavaScript 能够方便地查询和操作 HTML 或 XML 文档的内容。理解其功能和工作原理有助于开发者更好地使用 XPath，并排查相关的错误。

Prompt: 
```
这是目录为blink/renderer/core/xml/xpath_parser.cc的chromium blink引擎源代码文件， 请列举一下它的功能, 
如果它与javascript, html, css的功能有关系，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索。

"""
/*
 * Copyright 2005 Maksim Orlovich <maksim@kde.org>
 * Copyright (C) 2006 Apple Computer, Inc.
 * Copyright (C) 2007 Alexey Proskuryakov <ap@webkit.org>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "third_party/blink/renderer/core/xml/xpath_parser.h"

#include "base/memory/ptr_util.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_xpath_ns_resolver.h"
#include "third_party/blink/renderer/core/frame/web_feature.h"
#include "third_party/blink/renderer/core/xml/xpath_evaluator.h"
#include "third_party/blink/renderer/core/xml/xpath_grammar_generated.h"
#include "third_party/blink/renderer/core/xml/xpath_path.h"
#include "third_party/blink/renderer/core/xml/xpath_util.h"
#include "third_party/blink/renderer/platform/bindings/exception_state.h"
#include "third_party/blink/renderer/platform/instrumentation/use_counter.h"
#include "third_party/blink/renderer/platform/wtf/std_lib_extras.h"
#include "third_party/blink/renderer/platform/wtf/text/string_hash.h"
#include "third_party/blink/renderer/platform/wtf/text/unicode.h"

namespace blink {
namespace xpath {

using xpathyy::YyParser;
using TokenType = xpathyy::YyParser::token;

Parser* Parser::current_parser_ = nullptr;

enum XMLCat { kNameStart, kNameCont, kNotPartOfName };

typedef HashMap<String, Step::Axis> AxisNamesMap;

static XMLCat CharCat(UChar a_char) {
  // might need to add some special cases from the XML spec.

  if (a_char == '_')
    return kNameStart;

  if (a_char == '.' || a_char == '-')
    return kNameCont;
  WTF::unicode::CharCategory category = WTF::unicode::Category(a_char);
  if (category &
      (WTF::unicode::kLetter_Uppercase | WTF::unicode::kLetter_Lowercase |
       WTF::unicode::kLetter_Other | WTF::unicode::kLetter_Titlecase |
       WTF::unicode::kNumber_Letter))
    return kNameStart;
  if (category &
      (WTF::unicode::kMark_NonSpacing | WTF::unicode::kMark_SpacingCombining |
       WTF::unicode::kMark_Enclosing | WTF::unicode::kLetter_Modifier |
       WTF::unicode::kNumber_DecimalDigit))
    return kNameCont;
  return kNotPartOfName;
}

static void SetUpAxisNamesMap(AxisNamesMap& axis_names) {
  struct AxisName {
    const char* name;
    Step::Axis axis;
  };
  const AxisName kAxisNameList[] = {
      {"ancestor", Step::kAncestorAxis},
      {"ancestor-or-self", Step::kAncestorOrSelfAxis},
      {"attribute", Step::kAttributeAxis},
      {"child", Step::kChildAxis},
      {"descendant", Step::kDescendantAxis},
      {"descendant-or-self", Step::kDescendantOrSelfAxis},
      {"following", Step::kFollowingAxis},
      {"following-sibling", Step::kFollowingSiblingAxis},
      {"namespace", Step::kNamespaceAxis},
      {"parent", Step::kParentAxis},
      {"preceding", Step::kPrecedingAxis},
      {"preceding-sibling", Step::kPrecedingSiblingAxis},
      {"self", Step::kSelfAxis}};
  for (const auto& axis_name : kAxisNameList)
    axis_names.Set(axis_name.name, axis_name.axis);
}

static bool IsAxisName(const String& name, Step::Axis& type) {
  DEFINE_STATIC_LOCAL(AxisNamesMap, axis_names, ());

  if (axis_names.empty())
    SetUpAxisNamesMap(axis_names);

  AxisNamesMap::iterator it = axis_names.find(name);
  if (it == axis_names.end())
    return false;
  type = it->value;
  return true;
}

static bool IsNodeTypeName(const String& name) {
  DEFINE_STATIC_LOCAL(HashSet<String>, node_type_names,
                      ({
                          "comment", "text", "processing-instruction", "node",
                      }));
  return node_type_names.Contains(name);
}

// Returns whether the current token can possibly be a binary operator, given
// the previous token. Necessary to disambiguate some of the operators
// (* (multiply), div, and, or, mod) in the [32] Operator rule
// (check http://www.w3.org/TR/xpath#exprlex).
bool Parser::IsBinaryOperatorContext() const {
  switch (last_token_type_) {
    case 0:
    case '@':
    case TokenType::kAxisName:
    case '(':
    case '[':
    case ',':
    case TokenType::kAnd:
    case TokenType::kOr:
    case TokenType::kMulOp:
    case '/':
    case TokenType::kSlashSlash:
    case '|':
    case TokenType::kPlus:
    case TokenType::kMinus:
    case TokenType::kEqOp:
    case TokenType::kRelOp:
      return false;
    default:
      return true;
  }
}

// See https://www.w3.org/TR/1999/REC-xpath-19991116/#NT-ExprWhitespace .
void Parser::SkipWS() {
  while (next_pos_ < data_.length() && IsXMLSpace(data_[next_pos_]))
    ++next_pos_;
}

Token Parser::MakeTokenAndAdvance(int code, int advance) {
  next_pos_ += advance;
  return Token(code);
}

Token Parser::MakeTokenAndAdvance(int code,
                                  NumericOp::Opcode val,
                                  int advance) {
  next_pos_ += advance;
  return Token(code, val);
}

Token Parser::MakeTokenAndAdvance(int code, EqTestOp::Opcode val, int advance) {
  next_pos_ += advance;
  return Token(code, val);
}

// Returns next char if it's there and interesting, 0 otherwise
char Parser::PeekAheadHelper() {
  if (next_pos_ + 1 >= data_.length())
    return 0;
  UChar next = data_[next_pos_ + 1];
  if (next >= 0xff)
    return 0;
  return next;
}

char Parser::PeekCurHelper() {
  if (next_pos_ >= data_.length())
    return 0;
  UChar next = data_[next_pos_];
  if (next >= 0xff)
    return 0;
  return next;
}

Token Parser::LexString() {
  UChar delimiter = data_[next_pos_];
  int start_pos = next_pos_ + 1;

  for (next_pos_ = start_pos; next_pos_ < data_.length(); ++next_pos_) {
    if (data_[next_pos_] == delimiter) {
      String value = data_.Substring(start_pos, next_pos_ - start_pos);
      if (value.IsNull())
        value = "";
      ++next_pos_;  // Consume the char.
      return Token(TokenType::kLiteral, value);
    }
  }

  // Ouch, went off the end -- report error.
  return Token(TokenType::kXPathError);
}

Token Parser::LexNumber() {
  int start_pos = next_pos_;
  bool seen_dot = false;

  // Go until end or a non-digits character.
  for (; next_pos_ < data_.length(); ++next_pos_) {
    UChar a_char = data_[next_pos_];
    if (a_char >= 0xff)
      break;

    if (a_char < '0' || a_char > '9') {
      if (a_char == '.' && !seen_dot)
        seen_dot = true;
      else
        break;
    }
  }

  return Token(TokenType::kNumber,
               data_.Substring(start_pos, next_pos_ - start_pos));
}

bool Parser::LexNCName(String& name) {
  int start_pos = next_pos_;
  if (next_pos_ >= data_.length())
    return false;

  if (CharCat(data_[next_pos_]) != kNameStart)
    return false;

  // Keep going until we get a character that's not good for names.
  for (; next_pos_ < data_.length(); ++next_pos_) {
    if (CharCat(data_[next_pos_]) == kNotPartOfName)
      break;
  }

  name = data_.Substring(start_pos, next_pos_ - start_pos);
  return true;
}

bool Parser::LexQName(String& name) {
  String n1;
  if (!LexNCName(n1))
    return false;

  SkipWS();

  // If the next character is :, what we just got it the prefix, if not,
  // it's the whole thing.
  if (PeekAheadHelper() != ':') {
    name = n1;
    return true;
  }

  String n2;
  if (!LexNCName(n2))
    return false;

  name = n1 + ":" + n2;
  return true;
}

Token Parser::NextTokenInternal() {
  SkipWS();

  if (next_pos_ >= data_.length())
    return Token(0);

  char code = PeekCurHelper();
  switch (code) {
    case '(':
    case ')':
    case '[':
    case ']':
    case '@':
    case ',':
    case '|':
      return MakeTokenAndAdvance(code);
    case '\'':
    case '\"':
      return LexString();
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      return LexNumber();
    case '.': {
      char next = PeekAheadHelper();
      if (next == '.')
        return MakeTokenAndAdvance(TokenType::kDotDot, 2);
      if (next >= '0' && next <= '9')
        return LexNumber();
      return MakeTokenAndAdvance('.');
    }
    case '/':
      if (PeekAheadHelper() == '/')
        return MakeTokenAndAdvance(TokenType::kSlashSlash, 2);
      return MakeTokenAndAdvance('/');
    case '+':
      return MakeTokenAndAdvance(TokenType::kPlus);
    case '-':
      return MakeTokenAndAdvance(TokenType::kMinus);
    case '=':
      return MakeTokenAndAdvance(TokenType::kEqOp, EqTestOp::kOpcodeEqual);
    case '!':
      if (PeekAheadHelper() == '=') {
        return MakeTokenAndAdvance(TokenType::kEqOp, EqTestOp::kOpcodeNotEqual,
                                   2);
      }
      return Token(TokenType::kXPathError);
    case '<':
      if (PeekAheadHelper() == '=') {
        return MakeTokenAndAdvance(TokenType::kRelOp,
                                   EqTestOp::kOpcodeLessOrEqual, 2);
      }
      return MakeTokenAndAdvance(TokenType::kRelOp, EqTestOp::kOpcodeLessThan);
    case '>':
      if (PeekAheadHelper() == '=') {
        return MakeTokenAndAdvance(TokenType::kRelOp,
                                   EqTestOp::kOpcodeGreaterOrEqual, 2);
      }
      return MakeTokenAndAdvance(TokenType::kRelOp,
                                 EqTestOp::kOpcodeGreaterThan);
    case '*':
      if (IsBinaryOperatorContext())
        return MakeTokenAndAdvance(TokenType::kMulOp, NumericOp::kOP_Mul);
      ++next_pos_;
      return Token(TokenType::kNameTest, "*");
    case '$': {  // $ QName
      next_pos_++;
      String name;
      if (!LexQName(name))
        return Token(TokenType::kXPathError);
      // DOM XPath API doesn't support any variables.
      if (use_counter_) {
        UseCounter::Count(use_counter_,
                          WebFeature::kXPathMissingVariableParsed);
      }
      return Token(TokenType::kVariableReference, name);
    }
  }

  String name;
  if (!LexNCName(name))
    return Token(TokenType::kXPathError);

  SkipWS();
  // If we're in an operator context, check for any operator names
  if (IsBinaryOperatorContext()) {
    if (name == "and")  // ### hash?
      return Token(TokenType::kAnd);
    if (name == "or")
      return Token(TokenType::kOr);
    if (name == "mod")
      return Token(TokenType::kMulOp, NumericOp::kOP_Mod);
    if (name == "div")
      return Token(TokenType::kMulOp, NumericOp::kOP_Div);
  }

  // See whether we are at a :
  if (PeekCurHelper() == ':') {
    next_pos_++;
    // Any chance it's an axis name?
    if (PeekCurHelper() == ':') {
      next_pos_++;

      // It might be an axis name.
      Step::Axis axis;
      if (IsAxisName(name, axis))
        return Token(TokenType::kAxisName, axis);
      // Ugh, :: is only valid in axis names -> error
      return Token(TokenType::kXPathError);
    }

    // Seems like this is a fully qualified qname, or perhaps the * modified
    // one from NameTest
    SkipWS();
    if (PeekCurHelper() == '*') {
      next_pos_++;
      return Token(TokenType::kNameTest, name + ":*");
    }

    // Make a full qname.
    String n2;
    if (!LexNCName(n2))
      return Token(TokenType::kXPathError);

    name = name + ":" + n2;
  }

  SkipWS();
  if (PeekCurHelper() == '(') {
    // Note: we don't swallow the ( here!

    // Either node type of function name
    if (IsNodeTypeName(name)) {
      if (name == "processing-instruction")
        return Token(TokenType::kPI, name);

      return Token(TokenType::kNodeType, name);
    }
    // Must be a function name.
    return Token(TokenType::kFunctionName, name);
  }

  // At this point, it must be NAMETEST.
  return Token(TokenType::kNameTest, name);
}

Token Parser::NextToken() {
  Token to_ret = NextTokenInternal();
  last_token_type_ = to_ret.type;
  return to_ret;
}

Parser::Parser(UseCounter* use_counter) : use_counter_(use_counter) {
  Reset(String());
}

Parser::~Parser() = default;

void Parser::Reset(const String& data) {
  next_pos_ = 0;
  data_ = data;
  last_token_type_ = 0;

  top_expr_ = nullptr;
  got_namespace_error_ = false;
}

int Parser::Lex(void* data) {
  auto* yylval = static_cast<YyParser::semantic_type*>(data);
  Token tok = NextToken();

  switch (tok.type) {
    case TokenType::kAxisName:
      yylval->build<Step::Axis>() = tok.axis;
      break;
    case TokenType::kMulOp:
      yylval->build<NumericOp::Opcode>() = tok.numop;
      break;
    case TokenType::kRelOp:
    case TokenType::kEqOp:
      yylval->build<EqTestOp::Opcode>() = tok.eqop;
      break;
    case TokenType::kNodeType:
    case TokenType::kPI:
    case TokenType::kFunctionName:
    case TokenType::kLiteral:
    case TokenType::kVariableReference:
    case TokenType::kNumber:
    case TokenType::kNameTest:
      yylval->build<String>() = String(tok.str);
      break;
  }

  return tok.type;
}

bool Parser::ExpandQName(const String& q_name,
                         AtomicString& local_name,
                         AtomicString& namespace_uri) {
  wtf_size_t colon = q_name.find(':');
  if (colon != kNotFound) {
    if (!resolver_)
      return false;
    String prefix = q_name.Left(colon);
    v8::TryCatch try_catch(resolver_->GetIsolate());
    try_catch.SetVerbose(true);  // Print exceptions to console.
    String uri;
    if (!resolver_->lookupNamespaceURI(nullptr, prefix).To(&uri))
      return false;
    if (uri.IsNull())
      return false;
    namespace_uri = AtomicString(uri);
    local_name = AtomicString(q_name.Substring(colon + 1));
  } else {
    local_name = AtomicString(q_name);
  }

  return true;
}

Expression* Parser::ParseStatement(const String& statement,
                                   V8XPathNSResolver* resolver,
                                   ExceptionState& exception_state) {
  Reset(statement);

  resolver_ = resolver;

  Parser* old_parser = current_parser_;
  current_parser_ = this;
  int parse_error = YyParser(this).parse();
  current_parser_ = old_parser;

  if (parse_error) {
    top_expr_ = nullptr;

    if (got_namespace_error_)
      exception_state.ThrowDOMException(
          DOMExceptionCode::kNamespaceError,
          "The string '" + statement + "' contains unresolvable namespaces.");
    else
      exception_state.ThrowDOMException(
          DOMExceptionCode::kSyntaxError,
          "The string '" + statement + "' is not a valid XPath expression.");
    return nullptr;
  }
  Expression* result = top_expr_;
  top_expr_ = nullptr;

  return result;
}

}  // namespace xpath
}  // namespace blink

"""

```
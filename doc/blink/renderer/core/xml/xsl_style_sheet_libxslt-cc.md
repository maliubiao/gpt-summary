Response:
Let's break down the thought process for analyzing this code.

1. **Understand the Goal:** The request asks for the functionality of the `XSLStyleSheet_libxslt.cc` file, its relationship to web technologies (JS, HTML, CSS), examples of its behavior, potential errors, and how a user might trigger this code.

2. **Initial Scan for Keywords and Structure:** I started by skimming the code, looking for recognizable terms and structural elements:
    * `#include`:  Immediately tells me this is C++ code and what dependencies it has (e.g., `ExecutionContext.h`, `XSLStyleSheet.h`, `libxml`, `libxslt`). These headers are clues about the file's purpose.
    * Class Definition (`class XSLStyleSheet`):  Confirms this is defining a class, which is likely a key data structure.
    * Constructor Overloads:  Indicate different ways an `XSLStyleSheet` object can be created. The arguments to the constructors hint at the information needed to create a style sheet (parent, URL, owning node/document).
    * Method Names:  `ParseString`, `LoadChildSheets`, `CompileStyleSheet`, `ApplyTo`, `OwnerDocument`, `LocateStylesheetSubResource`. These are action verbs that suggest the core functionalities.
    * Usage of `libxml` and `libxslt`:  Strong indicators that this code deals with XML and XSLT processing.
    * `namespace blink`: This is a Chromium-specific namespace, so the context is definitely within the Blink rendering engine.

3. **Focusing on Core Functionality (Deduction based on methods):**

    * **Loading and Parsing:**  The constructors and `ParseString` method are clearly about loading and parsing the XSLT stylesheet content. The use of `xmlCreateMemoryParserCtxt`, `xmlCtxtReadMemory` confirms this. The `LoadChildSheets` method and its interaction with `LoadChildSheet` suggest the handling of `<xsl:import>` and `<xsl:include>` directives.
    * **Compilation:** The `CompileStyleSheet` method using `xsltParseStylesheetDoc` is a key step in preparing the stylesheet for transformation.
    * **Handling Includes/Imports:**  `LoadChildSheets` and `LoadChildSheet` explicitly handle the fetching and parsing of imported/included stylesheets. The cycle detection logic is important.
    * **Resource Management:** The destructor `~XSLStyleSheet` and the handling of `stylesheet_doc_` suggest management of the underlying libxml `xmlDocPtr`.
    * **Context Awareness:**  The references to `OwnerDocument`, `ExecutionContext`, and `LocalFrame` indicate that the stylesheet is aware of its embedding within the web page.
    * **Error Handling:**  The mention of `GenericErrorFunc` and `ParseErrorFunc` suggests error reporting during parsing. The `compilation_failed_` flag is for tracking compilation errors.

4. **Relating to Web Technologies (JS, HTML, CSS):**

    * **Direct Connection to XSLT:** The core purpose is to handle XSLT, which is directly related to XML transformations.
    * **HTML:** XSLT can transform XML into HTML. This is a primary use case. I thought about how a browser uses XSLT to display XML data.
    * **CSS:** While XSLT *can* generate CSS, it's not its primary function. The connection is more indirect: the HTML generated by XSLT will likely use CSS for styling.
    * **JavaScript:**  JavaScript can trigger XSLT transformations through the `XSLTProcessor` API. This is the most direct link for JavaScript. I looked for clues in the code that might hint at how it interacts with the browser's scripting environment. The `ExecutionContext` was a key indicator here.

5. **Crafting Examples and Scenarios:**  Once I understood the core functions, I could create illustrative examples.

    * **Loading and Parsing:** A simple XML document and XSLT stylesheet with imports seemed like a good starting point.
    * **Compilation Errors:** A syntax error in the XSLT is an obvious error scenario.
    * **Include/Import Cycles:** This demonstrates the preventative logic.
    * **User Trigger:**  Thinking about how a user interacts with the browser to cause XSLT to be processed led to scenarios like directly opening an XML file with a stylesheet link or using JavaScript.

6. **Debugging Hints:** I considered the information available in the code that would be useful for debugging: URL handling, error reporting (even if not fully implemented in the provided snippet), and the loading of child stylesheets.

7. **Review and Refine:**  I reread my analysis to ensure clarity, accuracy, and completeness. I checked that I addressed all parts of the prompt. I made sure the examples were clear and easy to understand.

**Self-Correction/Refinement During the Process:**

* **Initial Over-reliance on Method Names:**  I started by focusing heavily on method names, but then realized I needed to delve into the *code within* those methods to understand the actual implementation using `libxml` and `libxslt`.
* **Specificity of Examples:** My initial examples might have been too generic. I refined them to be more concrete, showing the actual input and expected output (or error).
* **Clarifying the User Trigger:** I realized I needed to explicitly state the different ways a user might encounter XSLT processing in a browser.
* **Emphasis on Error Handling:** While the code snippet didn't have extensive error handling *logic*, I noted the *existence* of error reporting mechanisms and the `compilation_failed_` flag, as these are relevant to understanding potential issues.

By following this structured approach, combining code analysis with an understanding of web technologies, and refining my understanding through examples and error scenarios, I could generate the comprehensive answer.
这个文件 `blink/renderer/core/xml/xsl_style_sheet_libxslt.cc` 是 Chromium Blink 渲染引擎中负责处理 **XSLT (Extensible Stylesheet Language Transformations)** 样式表的代码。它使用了 `libxslt` 库，这是一个流行的 C 语言库，用于解析和编译 XSLT 样式表。

以下是该文件的主要功能：

**1. XSLT 样式表的加载、解析和编译:**

* **加载:**  从网络或本地文件系统中读取 XSLT 样式表的内容。
* **解析:** 使用 `libxml` 库将 XSLT 样式表的 XML 结构解析成内部表示。`ParseString` 方法负责将字符串形式的 XSLT 内容解析成 `xmlDocPtr` (libxml 的文档指针)。
* **编译:** 使用 `libxslt` 库将解析后的 XSLT 样式表编译成可以用于转换 XML 文档的内部结构。`CompileStyleSheet` 方法调用 `xsltParseStylesheetDoc` 执行编译。

**2. 处理 XSLT 的 `<xsl:import>` 和 `<xsl:include>` 指令:**

* `LoadChildSheets` 和 `LoadChildSheet` 方法负责查找和加载 XSLT 样式表中通过 `<xsl:import>` 和 `<xsl:include>` 引入的子样式表。
* 它会递归地加载这些子样式表，并构建一个样式表树。
* 它还会检测导入循环，避免无限递归。

**3. 与 Blink 引擎的其他部分集成:**

* **资源加载:** 使用 Blink 的资源加载机制 (`ResourceLoaderOptions`, `FetchParameters`, `XSLStyleSheetResource`) 来获取 XSLT 样式表的内容。
* **文档上下文:**  关联到拥有该样式表的文档 (`OwnerDocument`)，并使用文档的上下文信息进行资源加载。
* **错误处理:** 集成了 Blink 的错误报告机制 (`FrameConsole`)，用于报告 XSLT 解析错误。
* **生命周期管理:**  作为 `XSLStyleSheet` 类的实现，负责其对象的创建、销毁和内存管理。

**与 JavaScript, HTML, CSS 的关系：**

XSLT 的主要功能是将 XML 文档转换为其他格式，其中最常见的应用就是将 XML 数据转换为 HTML 页面，并且可以配合 CSS 对生成的 HTML 进行样式化。 JavaScript 可以通过编程方式触发 XSLT 转换。

**举例说明:**

* **HTML:** 当浏览器加载一个 XML 文档，并且该文档通过处理指令 (`<?xml-stylesheet type="text/xsl" href="style.xsl"?>`) 链接了一个 XSLT 样式表时，Blink 引擎会使用这个文件中的代码来加载、解析和编译 `style.xsl`。然后，`libxslt` 会根据这个样式表将 XML 文档转换为 HTML，最终渲染到页面上。
    * **假设输入 (XML 文档):**
      ```xml
      <?xml version="1.0"?>
      <?xml-stylesheet type="text/xsl" href="my-style.xsl"?>
      <bookstore>
        <book>
          <title>The Great Gatsby</title>
          <author>F. Scott Fitzgerald</author>
        </book>
      </bookstore>
      ```
    * **假设输入 (XSLT 样式表 my-style.xsl):**
      ```xml
      <?xml version="1.0" encoding="UTF-8"?>
      <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
      <xsl:template match="/">
        <html>
          <body>
            <h2>Books</h2>
            <ul>
              <xsl:for-each select="bookstore/book">
                <li><xsl:value-of select="title"/> by <xsl:value-of select="author"/></li>
              </xsl:for-each>
            </ul>
          </body>
        </html>
      </xsl:template>
      </xsl:stylesheet>
      ```
    * **输出 (生成的 HTML):**
      ```html
      <html>
        <body>
          <h2>Books</h2>
          <ul>
            <li>The Great Gatsby by F. Scott Fitzgerald</li>
          </ul>
        </body>
      </html>
      ```

* **CSS:**  生成的 HTML 页面可以使用 CSS 进行样式化。例如，可以在 XSLT 中生成带有特定 class 或 id 的 HTML 元素，然后在 CSS 中定义这些元素的样式。

* **JavaScript:** JavaScript 可以使用 `XSLTProcessor` API 来显式地执行 XSLT 转换。
    * **假设输入 (XML 文档 - 同上):**
    * **假设输入 (XSLT 样式表 - 同上):**
    * **假设输入 (JavaScript 代码):**
      ```javascript
      const xmlString = `<?xml version="1.0"?><bookstore><book><title>The Great Gatsby</title><author>F. Scott Fitzgerald</author></book></bookstore>`;
      const xslString = `<?xml version="1.0" encoding="UTF-8"?><xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"><xsl:template match="/"><html><body><h2>Books</h2><ul><xsl:for-each select="bookstore/book"><li><xsl:value-of select="title"/> by <xsl:value-of select="author"/></li></xsl:for-each></ul></body></html></xsl:template></xsl:stylesheet>`;

      const parser = new DOMParser();
      const xsltProcessor = new XSLTProcessor();

      const xmlDoc = parser.parseFromString(xmlString, "text/xml");
      const xslDoc = parser.parseFromString(xslString, "text/xml");

      xsltProcessor.importStylesheet(xslDoc);
      const resultDocument = xsltProcessor.transformToDocument(xmlDoc);

      // 将 resultDocument 的内容添加到 HTML 页面
      document.body.appendChild(resultDocument.documentElement);
      ```
    * **输出:**  将生成的 HTML 结构添加到当前页面的 `<body>` 中。

**用户或编程常见的使用错误:**

1. **XSLT 语法错误:**  如果在 XSLT 样式表中存在语法错误（例如，未闭合的标签，错误的属性），`libxslt` 在解析或编译时会报错。
    * **假设输入 (错误的 XSLT):**
      ```xml
      <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
        <xsl:template match="/">
          <html>
            <body>
              <b>Hello  // 缺少闭合标签
            </body>
          </html>
        </xsl:template>
      </xsl:stylesheet>
      ```
    * **输出:**  Blink 引擎的控制台会输出解析错误信息，样式表可能无法加载或编译成功，导致 XML 文档无法正确转换。

2. **导入/包含路径错误:**  如果在 `<xsl:import>` 或 `<xsl:include>` 指令中指定的路径不正确，导致无法找到子样式表，加载过程会失败。
    * **假设输入 (XSLT 包含错误的路径):**
      ```xml
      <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
        <xsl:import href="nonexistent-style.xsl"/>
        <xsl:template match="/">...</xsl:template>
      </xsl:stylesheet>
      ```
    * **输出:**  Blink 引擎的控制台可能会显示加载资源失败的错误，样式表加载不完整，可能导致转换结果不正确。

3. **循环导入:**  如果样式表之间存在循环导入关系（例如，A 导入 B，B 导入 A），会导致无限递归加载。这个文件中的代码会尝试检测并阻止这种情况。
    * **假设输入 (样式表 A.xsl):**
      ```xml
      <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
        <xsl:import href="B.xsl"/>
        <xsl:template match="/">...</xsl:template>
      </xsl:stylesheet>
      ```
    * **假设输入 (样式表 B.xsl):**
      ```xml
      <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
        <xsl:import href="A.xsl"/>
        <xsl:template match="/">...</xsl:template>
      </xsl:stylesheet>
      ```
    * **输出:**  代码中的循环检测逻辑会阻止无限递归，可能导致部分样式表未加载，或者抛出错误。

**用户操作如何一步步到达这里 (作为调试线索):**

1. **用户在浏览器中打开一个 XML 文件。**
2. **该 XML 文件包含一个指向 XSLT 样式表的处理指令 `<?xml-stylesheet type="text/xsl" href="style.xsl"?>`。**
3. **Blink 引擎的 XML 解析器遇到该处理指令。**
4. **Blink 引擎会创建一个 `XSLStyleSheet` 对象来表示该样式表。**
5. **Blink 引擎会使用资源加载机制去获取 `style.xsl` 的内容。**
6. **`XSLStyleSheet::ParseString` 方法会被调用，使用 `libxml` 解析 `style.xsl` 的内容。**
7. **`XSLStyleSheet::LoadChildSheets` 方法会被调用，查找并加载通过 `<xsl:import>` 和 `<xsl:include>` 引入的子样式表。**  这会递归地重复步骤 4-6。
8. **`XSLStyleSheet::CompileStyleSheet` 方法会被调用，使用 `libxslt` 将解析后的样式表编译成内部结构。**
9. **当需要将 XML 文档转换为 HTML 时，Blink 引擎会使用编译后的 XSLT 样式表进行转换。**

**调试线索:**

* **网络请求:** 检查浏览器的开发者工具的网络面板，查看是否成功加载了 XSLT 样式表以及其导入/包含的子样式表。
* **控制台错误:** 检查浏览器的开发者工具的控制台，查看是否有关于 XSLT 解析或编译的错误信息。
* **断点调试:** 在 Blink 引擎的源代码中设置断点，例如在 `XSLStyleSheet::ParseString`、`XSLStyleSheet::LoadChildSheet` 或 `XSLStyleSheet::CompileStyleSheet` 等方法中，可以逐步跟踪样式表的加载和编译过程，查看中间状态和变量值。
* **libxslt 错误:** `libxslt` 自身也会产生错误信息。Blink 引擎会尝试捕获这些错误并报告给控制台。

总而言之，`blink/renderer/core/xml/xsl_style_sheet_libxslt.cc` 是 Blink 引擎中处理 XSLT 样式表的关键组件，负责加载、解析、编译 XSLT 代码，并处理样式表之间的依赖关系，最终为 XML 到 HTML 的转换提供支持。

### 提示词
```
这是目录为blink/renderer/core/xml/xsl_style_sheet_libxslt.cc的chromium blink引擎源代码文件， 请列举一下它的功能, 
如果它与javascript, html, css的功能有关系，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索。
```

### 源代码
```cpp
/*
 * This file is part of the XSL implementation.
 *
 * Copyright (C) 2004, 2005, 2006, 2008, 2012 Apple Inc. All rights reserved.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public License
 * along with this library; see the file COPYING.LIB.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA 02110-1301, USA.
 */

#include "third_party/blink/renderer/core/execution_context/execution_context.h"
#include "third_party/blink/renderer/core/xml/xsl_style_sheet.h"

#include <libxml/uri.h>
#include <libxslt/xsltutils.h>
#include "services/network/public/mojom/fetch_api.mojom-blink.h"
#include "third_party/blink/renderer/core/dom/document.h"
#include "third_party/blink/renderer/core/dom/node.h"
#include "third_party/blink/renderer/core/dom/transform_source.h"
#include "third_party/blink/renderer/core/frame/local_frame.h"
#include "third_party/blink/renderer/core/loader/resource/xsl_style_sheet_resource.h"
#include "third_party/blink/renderer/core/xml/parser/xml_document_parser_scope.h"
#include "third_party/blink/renderer/core/xml/parser/xml_parser_input.h"
#include "third_party/blink/renderer/core/xml/xslt_processor.h"
#include "third_party/blink/renderer/platform/loader/fetch/fetch_initiator_type_names.h"
#include "third_party/blink/renderer/platform/loader/fetch/fetch_parameters.h"

namespace blink {

XSLStyleSheet::XSLStyleSheet(XSLStyleSheet* parent_style_sheet,
                             const String& original_url,
                             const KURL& final_url)
    : owner_node_(nullptr),
      original_url_(original_url),
      final_url_(final_url),
      is_disabled_(false),
      embedded_(false),
      // Child sheets get marked as processed when the libxslt engine has
      // finally seen them.
      processed_(false),
      stylesheet_doc_(nullptr),
      stylesheet_doc_taken_(false),
      compilation_failed_(false),
      parent_style_sheet_(parent_style_sheet),
      owner_document_(nullptr) {}

XSLStyleSheet::XSLStyleSheet(Node* parent_node,
                             const String& original_url,
                             const KURL& final_url,
                             bool embedded)
    : owner_node_(parent_node),
      original_url_(original_url),
      final_url_(final_url),
      is_disabled_(false),
      embedded_(embedded),
      processed_(true),  // The root sheet starts off processed.
      stylesheet_doc_(nullptr),
      stylesheet_doc_taken_(false),
      compilation_failed_(false),
      parent_style_sheet_(nullptr),
      owner_document_(nullptr) {}

XSLStyleSheet::XSLStyleSheet(Document* owner_document,
                             Node* style_sheet_root_node,
                             const String& original_url,
                             const KURL& final_url,
                             bool embedded)
    : owner_node_(style_sheet_root_node),
      original_url_(original_url),
      final_url_(final_url),
      is_disabled_(false),
      embedded_(embedded),
      processed_(true),  // The root sheet starts off processed.
      stylesheet_doc_(nullptr),
      stylesheet_doc_taken_(false),
      compilation_failed_(false),
      parent_style_sheet_(nullptr),
      owner_document_(owner_document) {}

XSLStyleSheet::~XSLStyleSheet() {
  if (!stylesheet_doc_taken_)
    xmlFreeDoc(stylesheet_doc_);
}

void XSLStyleSheet::CheckLoaded() {
  if (XSLStyleSheet* style_sheet = parentStyleSheet())
    style_sheet->CheckLoaded();
  if (ownerNode())
    ownerNode()->SheetLoaded();
}

xmlDocPtr XSLStyleSheet::GetDocument() {
  if (embedded_ && OwnerDocument() && OwnerDocument()->GetTransformSource())
    return (xmlDocPtr)OwnerDocument()->GetTransformSource()->PlatformSource();
  return stylesheet_doc_;
}

void XSLStyleSheet::ClearDocuments() {
  stylesheet_doc_ = nullptr;
  for (unsigned i = 0; i < children_.size(); ++i)
    children_.at(i)->ClearDocuments();
}

bool XSLStyleSheet::ParseString(const String& source) {
  // Parse in a single chunk into an xmlDocPtr
  if (!stylesheet_doc_taken_)
    xmlFreeDoc(stylesheet_doc_);
  stylesheet_doc_taken_ = false;

  FrameConsole* console = nullptr;
  if (LocalFrame* frame = OwnerDocument()->GetFrame())
    console = &frame->Console();

  XMLDocumentParserScope scope(OwnerDocument(), XSLTProcessor::GenericErrorFunc,
                               XSLTProcessor::ParseErrorFunc, console);
  XMLParserInput input(source);

  xmlParserCtxtPtr ctxt = xmlCreateMemoryParserCtxt(input.Data(), input.size());
  if (!ctxt)
    return false;

  if (parent_style_sheet_) {
    // The XSL transform may leave the newly-transformed document
    // with references to the symbol dictionaries of the style sheet
    // and any of its children. XML document disposal can corrupt memory
    // if a document uses more than one symbol dictionary, so we
    // ensure that all child stylesheets use the same dictionaries as their
    // parents.
    xmlDictFree(ctxt->dict);
    ctxt->dict = parent_style_sheet_->stylesheet_doc_->dict;
    xmlDictReference(ctxt->dict);
  }

  stylesheet_doc_ =
      xmlCtxtReadMemory(ctxt, input.Data(), input.size(),
                        final_url_.GetString().Utf8().c_str(), input.Encoding(),
                        XML_PARSE_NOENT | XML_PARSE_DTDATTR |
                            XML_PARSE_NOWARNING | XML_PARSE_NOCDATA);

  xmlFreeParserCtxt(ctxt);
  LoadChildSheets();
  return stylesheet_doc_;
}

void XSLStyleSheet::LoadChildSheets() {
  if (!GetDocument())
    return;

  xmlNodePtr stylesheet_root = GetDocument()->children;

  // Top level children may include other things such as DTD nodes, we ignore
  // those.
  while (stylesheet_root && stylesheet_root->type != XML_ELEMENT_NODE)
    stylesheet_root = stylesheet_root->next;

  if (embedded_) {
    // We have to locate (by ID) the appropriate embedded stylesheet
    // element, so that we can walk the import/include list.
    xmlAttrPtr id_node = xmlGetID(
        GetDocument(), (const xmlChar*)(final_url_.GetString().Utf8().c_str()));
    if (!id_node)
      return;
    stylesheet_root = id_node->parent;
  } else {
    // FIXME: Need to handle an external URI with a # in it. This is a
    // pretty minor edge case, so we'll deal with it later.
  }

  if (stylesheet_root) {
    // Walk the children of the root element and look for import/include
    // elements. Imports must occur first.
    xmlNodePtr curr = stylesheet_root->children;
    while (curr) {
      if (curr->type != XML_ELEMENT_NODE) {
        curr = curr->next;
        continue;
      }
      if (IS_XSLT_ELEM(curr) && IS_XSLT_NAME(curr, "import")) {
        xmlChar* uri_ref =
            xsltGetNsProp(curr, (const xmlChar*)"href", XSLT_NAMESPACE);
        LoadChildSheet(String::FromUTF8((const char*)uri_ref));
        xmlFree(uri_ref);
      } else {
        break;
      }
      curr = curr->next;
    }

    // Now handle includes.
    while (curr) {
      if (curr->type == XML_ELEMENT_NODE && IS_XSLT_ELEM(curr) &&
          IS_XSLT_NAME(curr, "include")) {
        xmlChar* uri_ref =
            xsltGetNsProp(curr, (const xmlChar*)"href", XSLT_NAMESPACE);
        LoadChildSheet(String::FromUTF8((const char*)uri_ref));
        xmlFree(uri_ref);
      }
      curr = curr->next;
    }
  }
}

void XSLStyleSheet::LoadChildSheet(const String& href) {
  // Use parent styleheet's URL as the base URL
  KURL url(BaseURL(), href);

  // Check for a cycle in our import chain. If we encounter a stylesheet in
  // our parent chain with the same URL, then just bail.
  for (XSLStyleSheet* parent_sheet = parentStyleSheet(); parent_sheet;
       parent_sheet = parent_sheet->parentStyleSheet()) {
    if (url == parent_sheet->BaseURL())
      return;
  }

  const String& url_string = url.GetString();
  ResourceLoaderOptions fetch_options(
      OwnerDocument()->GetExecutionContext()->GetCurrentWorld());
  fetch_options.initiator_info.name = fetch_initiator_type_names::kXml;
  FetchParameters params(
      ResourceRequest(OwnerDocument()->CompleteURL(url_string)), fetch_options);
  params.MutableResourceRequest().SetMode(
      network::mojom::RequestMode::kSameOrigin);
  XSLStyleSheetResource* resource = XSLStyleSheetResource::FetchSynchronously(
      params, OwnerDocument()->Fetcher());
  if (!resource->Sheet())
    return;

  XSLStyleSheet* style_sheet = MakeGarbageCollected<XSLStyleSheet>(
      this, url_string, resource->GetResponse().CurrentRequestUrl());
  children_.push_back(style_sheet);
  style_sheet->ParseString(resource->Sheet());
  CheckLoaded();
}

xsltStylesheetPtr XSLStyleSheet::CompileStyleSheet() {
  // FIXME: Hook up error reporting for the stylesheet compilation process.
  if (embedded_)
    return xsltLoadStylesheetPI(GetDocument());

  // Certain libxslt versions are corrupting the xmlDoc on compilation
  // failures - hence attempting to recompile after a failure is unsafe.
  if (compilation_failed_)
    return nullptr;

  // xsltParseStylesheetDoc makes the document part of the stylesheet
  // so we have to release our pointer to it.
  DCHECK(!stylesheet_doc_taken_);
  xsltStylesheetPtr result = xsltParseStylesheetDoc(stylesheet_doc_);
  if (result)
    stylesheet_doc_taken_ = true;
  else
    compilation_failed_ = true;
  return result;
}

Document* XSLStyleSheet::OwnerDocument() {
  for (XSLStyleSheet* style_sheet = this; style_sheet;
       style_sheet = style_sheet->parentStyleSheet()) {
    if (style_sheet->owner_document_)
      return style_sheet->owner_document_.Get();
    Node* node = style_sheet->ownerNode();
    if (node)
      return &node->GetDocument();
  }
  return nullptr;
}

xmlDocPtr XSLStyleSheet::LocateStylesheetSubResource(xmlDocPtr parent_doc,
                                                     const xmlChar* uri) {
  bool matched_parent = (parent_doc == GetDocument());
  for (unsigned i = 0; i < children_.size(); ++i) {
    XSLStyleSheet* child = children_.at(i).Get();
    if (matched_parent) {
      if (child->Processed())
        continue;  // libxslt has been given this sheet already.

      // Check the URI of the child stylesheet against the doc URI.
      // In order to ensure that libxml canonicalized both URLs, we get
      // the original href string from the import rule and canonicalize it
      // using libxml before comparing it with the URI argument.
      std::string import_href = child->href().Utf8();
      xmlChar* base = xmlNodeGetBase(parent_doc, (xmlNodePtr)parent_doc);
      xmlChar* child_uri =
          xmlBuildURI((const xmlChar*)import_href.c_str(), base);
      bool equal_ur_is = xmlStrEqual(uri, child_uri);
      xmlFree(base);
      xmlFree(child_uri);
      if (equal_ur_is) {
        child->MarkAsProcessed();
        return child->GetDocument();
      }
      continue;
    }
    xmlDocPtr result = child->LocateStylesheetSubResource(parent_doc, uri);
    if (result)
      return result;
  }

  return nullptr;
}

void XSLStyleSheet::MarkAsProcessed() {
  DCHECK(!processed_);
  DCHECK(!stylesheet_doc_taken_);
  processed_ = true;
  stylesheet_doc_taken_ = true;
}

void XSLStyleSheet::Trace(Visitor* visitor) const {
  visitor->Trace(owner_node_);
  visitor->Trace(children_);
  visitor->Trace(parent_style_sheet_);
  visitor->Trace(owner_document_);
  StyleSheet::Trace(visitor);
}

}  // namespace blink
```
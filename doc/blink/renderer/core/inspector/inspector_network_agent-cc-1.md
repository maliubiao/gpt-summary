Response:
The user wants a summary of the functionality of the provided C++ code snippet from `inspector_network_agent.cc`. This is the second part of a larger file. The request specifically asks for:

1. **Functionality Listing:** A breakdown of what the code does.
2. **Relationship to Web Technologies:** How the code interacts with JavaScript, HTML, and CSS, with examples.
3. **Logical Inferences:** Scenarios with hypothetical inputs and outputs.
4. **Common Usage Errors:** Examples of mistakes developers might make.
5. **Summary of Functionality (for this part):**  A concise overview of the code's purpose within the larger file.

Let's analyze the code section by section:

* **`BuildObjectForTiming` function:**  This clearly deals with network timing information, converting low-level timing data into a structure suitable for the DevTools protocol. It calculates time differences for various stages of a network request.

* **`FormDataToString` function:** This function handles the conversion of form data into a string representation, potentially for inclusion in DevTools messages. It also seems to handle cases where the form data is too large.

* **`StringFromASCII` function:** A utility for converting standard C++ strings to Blink's `String` type, assuming the content is ASCII.

* **`BuildSecurityDetails` function:** This is a crucial function for capturing security information related to HTTPS connections. It extracts details from `net::SSLInfo` and converts them into a DevTools protocol structure, including certificate information, TLS protocol details, and Certificate Transparency (CT) data.

* **`BuildObjectForResourceRequest` function:**  This function takes a `ResourceRequest` object (representing an outgoing network request) and transforms it into a DevTools protocol representation. It handles headers, request method, priority, referrer policy, and post data.

* **`AlternateProtocolUsageToString` function:**  This function maps internal Chromium network status codes for alternate protocols (like HTTP/3) to human-readable strings for the DevTools protocol.

* **`BuildObjectForResourceResponse` function:**  This function is the counterpart to `BuildObjectForResourceRequest`. It takes a `ResourceResponse` object (representing an incoming network response) and converts it to a DevTools protocol structure. It includes status codes, headers, MIME type, caching information, timing data, security details, and service worker involvement.

* **`InspectorNetworkAgent` methods:**
    * `Trace`: Standard Blink tracing method for debugging.
    * `ShouldBlockRequest`: Determines if a request should be blocked based on user-defined patterns.
    * `ShouldBypassServiceWorker`: Checks if service worker bypass is enabled.
    * `DidBlockRequest`: Handles the event when a request is blocked, reporting it to DevTools.
    * `DidChangeResourcePriority`:  Notifies DevTools about changes in resource priority.
    * `RequestId`: Generates a unique ID for network requests.
    * `WillSendRequestInternal`: A central function for handling the "will send request" event, populating DevTools data.
    * `WillSendNavigationRequest`: Specifically handles the start of navigation requests.
    * `SetDevToolsIds`: Assigns DevTools-specific identifiers to requests.
    * `PrepareRequest`:  Modifies outgoing requests based on DevTools settings (e.g., adding custom headers, disabling cache).
    * `WillSendRequest`: The public entry point for the "will send request" event.
    * `MarkResourceAsCached`:  Indicates that a resource was served from the cache.
    * `DidReceiveResourceResponse`: Handles the "response received" event, providing response details to DevTools.

**Overall Functionality of this Part:**

This part of `inspector_network_agent.cc` is primarily responsible for:

1. **Converting internal Chromium network data structures (requests, responses, timing, security) into the format required by the Chrome DevTools Protocol.** This involves creating `protocol::Network::*` objects.
2. **Implementing the logic for intercepting and modifying network requests based on DevTools settings.** This includes blocking URLs, bypassing the service worker, adding custom headers, and disabling the cache.
3. **Reporting network events (request start, response received, loading finished, errors) to the DevTools frontend.** This is done via the `GetFrontend()->...` calls.

**Relationship to Web Technologies:**

* **JavaScript:**  The information captured by this code is ultimately used by the "Network" tab in Chrome DevTools, which web developers use to inspect network activity generated by their JavaScript code (e.g., `fetch`, `XMLHttpRequest`). For example, the `FormDataToString` function deals with data that might be sent from a JavaScript form submission. The timing information helps developers understand the performance of network requests initiated by their scripts.

* **HTML:**  The loading of HTML documents and their associated resources (images, scripts, stylesheets) is tracked here. The `BuildObjectForResourceRequest` and `BuildObjectForResourceResponse` functions handle requests for these HTML-related resources. The referrer policy is relevant to how the browser handles the `Referer` header when navigating between HTML pages.

* **CSS:**  Requests for CSS files are also monitored. The resource type detection logic (`InspectorPageAgent::ToResourceType`) would classify CSS files appropriately. The caching mechanisms influenced by this code affect how CSS is loaded.

**Logical Inferences (Hypothetical Inputs & Outputs):**

* **Input (WillSendRequest):** A JavaScript `fetch('/api/data')` call is made.
* **Output (requestWillBeSent):** The `WillSendRequestInternal` function would be called, creating a `protocol::Network::Request` object. This object would contain the URL `/api/data`, the method `GET`, and any relevant headers. The `initiator` field would indicate that the request originated from a `fetch` call.

* **Input (DidReceiveResourceResponse):** The server responds to the `/api/data` request with a 200 OK status, JSON data, and `Content-Type: application/json`.
* **Output (responseReceived):** The `DidReceiveResourceResponse` function would be called, creating a `protocol::Network::Response` object. This object would contain the status code `200`, the status text `OK`, the `Content-Type`, and potentially timing information.

* **Input (PrepareRequest):** The user enables "Disable cache" in DevTools. A subsequent request for an image is made.
* **Output (request modification):** The `PrepareRequest` function would modify the `ResourceRequest` object for the image, setting the cache mode to `kBypassCache`.

**Common Usage Errors (From a Web Developer Perspective, Relating to DevTools):**

* **Misinterpreting Timing Data:** Developers might not fully understand the different timing phases (DNS lookup, connection, SSL handshake, etc.) and draw incorrect conclusions about performance bottlenecks. This code provides the raw data, and the DevTools UI tries to present it clearly, but misinterpretation is possible.

* **Assuming Cache is Disabled:**  A developer might enable "Disable cache" in DevTools and assume all requests will bypass the cache. However, certain internal requests or browser behaviors might still involve caching, leading to unexpected results if they don't understand the nuances. This code implements the cache disabling, but understanding its scope is key for developers.

* **Not Understanding Service Worker Interference:** Developers might be confused when network requests behave unexpectedly due to service worker caching or interception. This code helps track service worker involvement, which is crucial for debugging such scenarios. The `ShouldBypassServiceWorker` functionality is directly related to this.

**Summary of Functionality (for this part):**

This section of `inspector_network_agent.cc` is primarily responsible for intercepting and inspecting network requests and responses within the Blink rendering engine. It translates low-level network data into a format suitable for the Chrome DevTools Protocol, allowing developers to monitor and analyze network activity. It also implements DevTools features for modifying network behavior, such as blocking requests, disabling the cache, and bypassing service workers.

这是 `blink/renderer/core/inspector/inspector_network_agent.cc` 文件的第二部分代码，主要负责将 Blink 内部的网络请求和响应信息转换为 Chrome DevTools 协议 (CDP) 的格式，并处理一些与网络拦截和修改相关的逻辑。

**功能归纳:**

1. **构建网络请求和响应的 DevTools 协议对象:**
   - `BuildObjectForTiming`: 将 `ResourceLoadTiming` 对象转换为 `protocol::Network::ResourceTiming` 对象，包含 DNS 解析、连接、SSL 握手、发送接收数据等各个阶段的时间戳。
   - `FormDataToString`: 将 `EncodedFormData` 对象转换为字符串或 `protocol::Network::PostDataEntry` 数组，用于表示 POST 请求的数据。
   - `StringFromASCII`: 将 C++ 的 `std::string` 转换为 Blink 的 `String` 对象，并断言字符串只包含 ASCII 字符。
   - `BuildSecurityDetails`: 将 `net::SSLInfo` 对象转换为 `protocol::Network::SecurityDetails` 对象，包含 TLS 协议版本、密钥交换算法、加密算法、证书信息、证书透明度 (CT) 信息等。
   - `BuildObjectForResourceRequest`: 将 `ResourceRequest` 对象转换为 `protocol::Network::Request` 对象，包含请求 URL、方法、头部、优先级、Referrer Policy、POST 数据等。
   - `AlternateProtocolUsageToString`: 将 `net::AlternateProtocolUsage` 枚举值转换为 `protocol::Network::AlternateProtocolUsageEnum` 字符串。
   - `BuildObjectForResourceResponse`: 将 `ResourceResponse` 对象转换为 `protocol::Network::Response` 对象，包含状态码、状态文本、头部、MIME 类型、字符集、连接重用信息、编码数据长度、安全状态、是否来自缓存/Service Worker 等。

2. **网络请求拦截和修改:**
   - `ShouldBlockRequest`:  检查当前请求的 URL 是否匹配用户设置的阻止 URL 列表。
   - `ShouldBypassServiceWorker`: 检查是否启用了绕过 Service Worker 的选项。
   - `PrepareRequest`:  在请求发送前进行修改，例如添加额外的请求头、禁用缓存、绕过 Service Worker。

3. **向 DevTools 前端发送网络事件:**
   - `DidBlockRequest`: 当请求被阻止时，向 DevTools 前端发送 `loadingFailed` 事件，包含阻止原因。
   - `DidChangeResourcePriority`: 当资源优先级改变时，向 DevTools 前端发送 `resourceChangedPriority` 事件。
   - `WillSendRequestInternal`:  在请求即将发送时，向 DevTools 前端发送 `requestWillBeSent` 事件，包含请求的详细信息。
   - `WillSendNavigationRequest`:  在导航请求即将发送时，记录请求信息。
   - `MarkResourceAsCached`:  当资源从缓存加载时，向 DevTools 前端发送 `requestServedFromCache` 事件。
   - `DidReceiveResourceResponse`:  在收到响应头时，向 DevTools 前端发送 `responseReceived` 事件，包含响应的详细信息。

4. **管理网络资源数据:**
   - 使用 `NetworkResourcesData` 类来存储和管理网络请求的相关信息，例如请求 ID、加载器 ID、资源类型、POST 数据等。

**与 JavaScript, HTML, CSS 的关系及举例说明:**

* **JavaScript:**  当 JavaScript 代码发起网络请求（例如使用 `fetch` 或 `XMLHttpRequest`）时，`InspectorNetworkAgent` 会捕获这些请求，并将相关信息（例如请求的 URL、方法、头部、POST 数据）通过 `BuildObjectForResourceRequest` 转换为 DevTools 协议对象，最终在 DevTools 的 Network 面板中显示出来。例如，如果 JavaScript 代码发送了一个包含 JSON 数据的 POST 请求，`FormDataToString` 会将 JSON 数据转换为字符串形式在 DevTools 中展示。

* **HTML:**  当浏览器加载 HTML 页面时，会请求各种资源（例如图片、CSS、JavaScript 文件）。`InspectorNetworkAgent` 会记录这些请求，并通过 `BuildObjectForResourceResponse` 提供响应信息，例如资源的状态码、MIME 类型、大小等。例如，当 HTML 中包含一个 `<img>` 标签时，`InspectorNetworkAgent` 会记录对该图片资源的请求和响应信息。

* **CSS:**  加载 CSS 文件也是网络请求的一种。`InspectorNetworkAgent` 会捕获对 CSS 文件的请求，并在 DevTools 中显示其请求头、响应头、加载时间等信息。例如，如果 CSS 文件使用了 HTTPS，`BuildSecurityDetails` 会提取 SSL 证书信息并在 DevTools 中展示。

**逻辑推理 (假设输入与输出):**

假设用户在 DevTools 中设置了阻止 URL 模式 `*.example.com/*`。

* **假设输入:** 浏览器尝试加载 `https://sub.example.com/image.png`。
* **输出:** `ShouldBlockRequest` 方法会被调用，传入 `https://sub.example.com/image.png` 作为参数。由于 URL 匹配阻止模式，该方法会返回 `true`，导致请求被阻止，并且 `DidBlockRequest` 方法会被调用，向 DevTools 前端发送一个 `loadingFailed` 事件，并包含阻止原因。

假设用户在 DevTools 中启用了 "Disable cache"。

* **假设输入:**  浏览器尝试加载一个之前已经缓存过的 JavaScript 文件。
* **输出:**  `PrepareRequest` 方法会被调用，并将该 JavaScript 文件的 `ResourceRequest` 对象的缓存模式设置为 `mojom::FetchCacheMode::kBypassCache`，强制浏览器跳过缓存直接从服务器请求该文件。

**涉及用户或编程常见的使用错误 (举例说明):**

* **开发者在 JavaScript 代码中错误地构造了 POST 请求的 body 数据:**  例如，没有正确设置 `Content-Type` 头部，或者将数据序列化为服务器无法解析的格式。虽然 `InspectorNetworkAgent` 会尽力展示请求的 body 数据，但如果数据格式错误，服务器可能无法正常处理，开发者需要检查 DevTools 中显示的请求数据来排查问题。

* **开发者误以为设置了 "Disable cache" 后所有资源都会重新加载:** 实际上，某些内部请求或者浏览器行为可能仍然会使用缓存。开发者需要在 DevTools 中仔细观察每个请求的 `from cache` 状态来确认资源是否真的从网络加载。

* **开发者没有理解 Service Worker 的缓存机制，导致资源加载行为与预期不符:**  例如，Service Worker 可能会缓存某些资源，即使服务器上的资源已经更新，浏览器仍然加载缓存的版本。开发者可以使用 DevTools 的 Network 面板查看资源的 `from service worker` 状态，并配合 Service Worker 相关的调试工具来解决问题。

总而言之，这部分代码是 Chrome DevTools Network 面板功能实现的核心组成部分，它负责收集、转换和报告浏览器内部的网络活动，并允许开发者通过 DevTools 修改浏览器的网络行为，从而帮助开发者调试和优化 Web 应用的网络性能和行为。

Prompt: 
```
这是目录为blink/renderer/core/inspector/inspector_network_agent.cc的chromium blink引擎源代码文件， 请列举一下它的功能, 
如果它与javascript, html, css的功能有关系，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明
这是第2部分，共4部分，请归纳一下它的功能

"""
MillisecondDelta(timing.DomainLookupStart()))
      .setDnsEnd(timing.CalculateMillisecondDelta(timing.DomainLookupEnd()))
      .setConnectStart(timing.CalculateMillisecondDelta(timing.ConnectStart()))
      .setConnectEnd(timing.CalculateMillisecondDelta(timing.ConnectEnd()))
      .setSslStart(timing.CalculateMillisecondDelta(timing.SslStart()))
      .setSslEnd(timing.CalculateMillisecondDelta(timing.SslEnd()))
      .setWorkerStart(timing.CalculateMillisecondDelta(timing.WorkerStart()))
      .setWorkerReady(timing.CalculateMillisecondDelta(timing.WorkerReady()))
      .setWorkerFetchStart(
          timing.CalculateMillisecondDelta(timing.WorkerFetchStart()))
      .setWorkerRespondWithSettled(
          timing.CalculateMillisecondDelta(timing.WorkerRespondWithSettled()))
      .setSendStart(timing.CalculateMillisecondDelta(timing.SendStart()))
      .setSendEnd(timing.CalculateMillisecondDelta(timing.SendEnd()))
      .setReceiveHeadersStart(
          timing.CalculateMillisecondDelta(timing.ReceiveHeadersStart()))
      .setReceiveHeadersEnd(
          timing.CalculateMillisecondDelta(timing.ReceiveHeadersEnd()))
      .setPushStart(timing.PushStart().since_origin().InSecondsF())
      .setPushEnd(timing.PushEnd().since_origin().InSecondsF())
      .build();
}

static bool FormDataToString(
    scoped_refptr<EncodedFormData> body,
    size_t max_body_size,
    protocol::Array<protocol::Network::PostDataEntry>* data_entries,
    String* content) {
  *content = "";
  if (!body || body->IsEmpty())
    return false;

  // SizeInBytes below doesn't support all element types, so first check if all
  // the body elements are of the right type.
  for (const auto& element : body->Elements()) {
    if (element.type_ != FormDataElement::kData)
      return true;
  }

  if (max_body_size != 0 && body->SizeInBytes() > max_body_size)
    return true;

  for (const auto& element : body->Elements()) {
    auto data_entry = protocol::Network::PostDataEntry::create().build();
    data_entry->setBytes(
        protocol::Binary::fromSpan(base::as_byte_span(element.data_)));
    data_entries->push_back(std::move(data_entry));
  }

  Vector<char> bytes;
  body->Flatten(bytes);
  *content = String::FromUTF8WithLatin1Fallback(base::as_byte_span(bytes));
  return true;
}

static String StringFromASCII(const std::string& str) {
  String ret(str);
  DCHECK(ret.ContainsOnlyASCIIOrEmpty());
  return ret;
}

static std::unique_ptr<protocol::Network::SecurityDetails> BuildSecurityDetails(
    const net::SSLInfo& ssl_info) {
  // This function should be kept in sync with the corresponding function in
  // network_handler.cc in //content.
  if (!ssl_info.cert)
    return nullptr;
  auto signed_certificate_timestamp_list = std::make_unique<
      protocol::Array<protocol::Network::SignedCertificateTimestamp>>();
  for (auto const& sct : ssl_info.signed_certificate_timestamps) {
    std::unique_ptr<protocol::Network::SignedCertificateTimestamp>
        signed_certificate_timestamp =
            protocol::Network::SignedCertificateTimestamp::create()
                .setStatus(StringFromASCII(net::ct::StatusToString(sct.status)))
                .setOrigin(
                    StringFromASCII(net::ct::OriginToString(sct.sct->origin)))
                .setLogDescription(String::FromUTF8(sct.sct->log_description))
                .setLogId(StringFromASCII(base::HexEncode(
                    sct.sct->log_id.c_str(), sct.sct->log_id.length())))
                .setTimestamp(sct.sct->timestamp.InMillisecondsSinceUnixEpoch())
                .setHashAlgorithm(
                    StringFromASCII(net::ct::HashAlgorithmToString(
                        sct.sct->signature.hash_algorithm)))
                .setSignatureAlgorithm(
                    StringFromASCII(net::ct::SignatureAlgorithmToString(
                        sct.sct->signature.signature_algorithm)))
                .setSignatureData(StringFromASCII(base::HexEncode(
                    sct.sct->signature.signature_data.c_str(),
                    sct.sct->signature.signature_data.length())))
                .build();
    signed_certificate_timestamp_list->emplace_back(
        std::move(signed_certificate_timestamp));
  }
  std::vector<std::string> san_dns;
  std::vector<std::string> san_ip;
  ssl_info.cert->GetSubjectAltName(&san_dns, &san_ip);
  auto san_list = std::make_unique<protocol::Array<String>>();
  for (const std::string& san : san_dns) {
    // DNS names in a SAN list are always ASCII.
    san_list->push_back(StringFromASCII(san));
  }
  for (const std::string& san : san_ip) {
    net::IPAddress ip(base::as_byte_span(san));
    san_list->push_back(StringFromASCII(ip.ToString()));
  }

  const char* protocol = "";
  const char* key_exchange = "";
  const char* cipher = "";
  const char* mac = nullptr;
  if (ssl_info.connection_status) {
    net::SSLVersion ssl_version =
        net::SSLConnectionStatusToVersion(ssl_info.connection_status);
    net::SSLVersionToString(&protocol, ssl_version);
    bool is_aead;
    bool is_tls13;
    uint16_t cipher_suite =
        net::SSLConnectionStatusToCipherSuite(ssl_info.connection_status);
    net::SSLCipherSuiteToStrings(&key_exchange, &cipher, &mac, &is_aead,
                                 &is_tls13, cipher_suite);
    if (key_exchange == nullptr) {
      DCHECK(is_tls13);
      key_exchange = "";
    }
  }

  std::unique_ptr<protocol::Network::SecurityDetails> security_details =
      protocol::Network::SecurityDetails::create()
          .setProtocol(protocol)
          .setKeyExchange(key_exchange)
          .setCipher(cipher)
          .setSubjectName(
              String::FromUTF8(ssl_info.cert->subject().common_name))
          .setSanList(std::move(san_list))
          .setIssuer(String::FromUTF8(ssl_info.cert->issuer().common_name))
          .setValidFrom(ssl_info.cert->valid_start().InSecondsFSinceUnixEpoch())
          .setValidTo(ssl_info.cert->valid_expiry().InSecondsFSinceUnixEpoch())
          .setCertificateId(0)  // Keep this in protocol for compatibility.
          .setSignedCertificateTimestampList(
              std::move(signed_certificate_timestamp_list))
          .setCertificateTransparencyCompliance(
              SerializeCTPolicyCompliance(ssl_info.ct_policy_compliance))
          .setEncryptedClientHello(ssl_info.encrypted_client_hello)
          .build();

  if (ssl_info.key_exchange_group != 0) {
    const char* key_exchange_group =
        SSL_get_curve_name(ssl_info.key_exchange_group);
    if (key_exchange_group)
      security_details->setKeyExchangeGroup(key_exchange_group);
  }
  if (mac)
    security_details->setMac(mac);
  if (ssl_info.peer_signature_algorithm != 0) {
    security_details->setServerSignatureAlgorithm(
        ssl_info.peer_signature_algorithm);
  }

  return security_details;
}

static std::unique_ptr<protocol::Network::Request>
BuildObjectForResourceRequest(const ResourceRequest& request,
                              scoped_refptr<EncodedFormData> post_data,
                              size_t max_body_size) {
  String data_string;
  auto data_entries =
      std::make_unique<protocol::Array<protocol::Network::PostDataEntry>>();
  bool has_post_data = FormDataToString(post_data, max_body_size,
                                        data_entries.get(), &data_string);
  KURL url = request.Url();
  // protocol::Network::Request doesn't have a separate referrer string member
  // like blink::ResourceRequest, so here we add ResourceRequest's referrer
  // string to the protocol request's headers manually.
  auto headers = request.HttpHeaderFields();

  // The request's referrer must be generated at this point.
  DCHECK_NE(request.ReferrerString(), Referrer::ClientReferrerString());
  headers.Set(http_names::kReferer, AtomicString(request.ReferrerString()));

  std::unique_ptr<protocol::Network::Request> result =
      protocol::Network::Request::create()
          .setUrl(UrlWithoutFragment(url).GetString())
          .setMethod(request.HttpMethod())
          .setHeaders(BuildObjectForHeaders(headers))
          .setInitialPriority(ResourcePriorityJSON(request.Priority()))
          .setReferrerPolicy(GetReferrerPolicy(request.GetReferrerPolicy()))
          .build();
  if (url.HasFragmentIdentifier()) {
    result->setUrlFragment("#" + url.FragmentIdentifier().ToString());
  }
  if (!data_string.empty())
    result->setPostData(data_string);
  if (data_entries->size())
    result->setPostDataEntries(std::move(data_entries));
  if (has_post_data)
    result->setHasPostData(true);
  if (request.TrustTokenParams()) {
    result->setTrustTokenParams(
        BuildTrustTokenParams(*request.TrustTokenParams()));
  }
  return result;
}

String AlternateProtocolUsageToString(
    net::AlternateProtocolUsage alternate_protocol_usage) {
  switch (alternate_protocol_usage) {
    case net::AlternateProtocolUsage::ALTERNATE_PROTOCOL_USAGE_NO_RACE:
      return protocol::Network::AlternateProtocolUsageEnum::
          AlternativeJobWonWithoutRace;
    case net::AlternateProtocolUsage::ALTERNATE_PROTOCOL_USAGE_WON_RACE:
      return protocol::Network::AlternateProtocolUsageEnum::
          AlternativeJobWonRace;
    case net::AlternateProtocolUsage::
        ALTERNATE_PROTOCOL_USAGE_MAIN_JOB_WON_RACE:
      return protocol::Network::AlternateProtocolUsageEnum::MainJobWonRace;
    case net::AlternateProtocolUsage::ALTERNATE_PROTOCOL_USAGE_MAPPING_MISSING:
      return protocol::Network::AlternateProtocolUsageEnum::MappingMissing;
    case net::AlternateProtocolUsage::ALTERNATE_PROTOCOL_USAGE_BROKEN:
      return protocol::Network::AlternateProtocolUsageEnum::Broken;
    case net::AlternateProtocolUsage::
        ALTERNATE_PROTOCOL_USAGE_DNS_ALPN_H3_JOB_WON_WITHOUT_RACE:
      return protocol::Network::AlternateProtocolUsageEnum::
          DnsAlpnH3JobWonWithoutRace;
    case net::AlternateProtocolUsage::
        ALTERNATE_PROTOCOL_USAGE_DNS_ALPN_H3_JOB_WON_RACE:
      return protocol::Network::AlternateProtocolUsageEnum::DnsAlpnH3JobWonRace;
    case net::AlternateProtocolUsage::
        ALTERNATE_PROTOCOL_USAGE_UNSPECIFIED_REASON:
      return protocol::Network::AlternateProtocolUsageEnum::UnspecifiedReason;
    case net::AlternateProtocolUsage::ALTERNATE_PROTOCOL_USAGE_MAX:
      return protocol::Network::AlternateProtocolUsageEnum::UnspecifiedReason;
  }
  return protocol::Network::AlternateProtocolUsageEnum::UnspecifiedReason;
}

static std::unique_ptr<protocol::Network::Response>
BuildObjectForResourceResponse(const ResourceResponse& response,
                               const ExecutionContext* context,
                               const Resource* cached_resource = nullptr,
                               bool* is_empty = nullptr) {
  if (response.IsNull())
    return nullptr;

  int status = response.HttpStatusCode();
  String status_text = response.HttpStatusText();
  HTTPHeaderMap headers_map = response.HttpHeaderFields();

  int64_t encoded_data_length = response.EncodedDataLength();

  String security_state = protocol::Security::SecurityStateEnum::Unknown;
  switch (response.GetSecurityStyle()) {
    case SecurityStyle::kUnknown:
      security_state = protocol::Security::SecurityStateEnum::Unknown;
      break;
    case SecurityStyle::kNeutral:
      security_state = protocol::Security::SecurityStateEnum::Neutral;
      break;
    case SecurityStyle::kInsecure:
      security_state = protocol::Security::SecurityStateEnum::Insecure;
      break;
    case SecurityStyle::kSecure:
      security_state = protocol::Security::SecurityStateEnum::Secure;
      break;
    case SecurityStyle::kInsecureBroken:
      security_state = protocol::Security::SecurityStateEnum::InsecureBroken;
      break;
  }

  // Use mime type and charset from cached resource in case the one in response
  // is empty or the response is a 304 Not Modified.
  String mime_type = response.MimeType();
  String charset = response.TextEncodingName();
  if (cached_resource) {
    if (mime_type.empty() || response.HttpStatusCode() == 304) {
      mime_type = cached_resource->GetResponse().MimeType();
    }
    if (charset.empty() || response.HttpStatusCode() == 304) {
      charset = cached_resource->GetResponse().TextEncodingName();
    }
  }

  if (is_empty)
    *is_empty = !status && mime_type.empty() && !headers_map.size();

  std::unique_ptr<protocol::Network::Response> response_object =
      protocol::Network::Response::create()
          .setUrl(UrlWithoutFragment(response.CurrentRequestUrl()).GetString())
          .setStatus(status)
          .setStatusText(status_text)
          .setHeaders(BuildObjectForHeaders(headers_map))
          .setMimeType(mime_type)
          .setCharset(charset)
          .setConnectionReused(response.ConnectionReused())
          .setConnectionId(response.ConnectionID())
          .setEncodedDataLength(encoded_data_length)
          .setSecurityState(security_state)
          .build();

  response_object->setFromDiskCache(response.WasCached());
  response_object->setFromServiceWorker(response.WasFetchedViaServiceWorker());
  if (response.WasFetchedViaServiceWorker()) {
    response_object->setServiceWorkerResponseSource(
        BuildServiceWorkerResponseSource(response));
  }
  if (!response.ResponseTime().is_null()) {
    response_object->setResponseTime(
        response.ResponseTime().InMillisecondsFSinceUnixEpochIgnoringNull());
  }
  if (!response.CacheStorageCacheName().empty()) {
    response_object->setCacheStorageCacheName(response.CacheStorageCacheName());
  }
  if (response.GetServiceWorkerRouterInfo()) {
    auto router_info =
        protocol::Network::ServiceWorkerRouterInfo::create().build();
    if (response.GetServiceWorkerRouterInfo()->RuleIdMatched()) {
      router_info->setRuleIdMatched(
          *response.GetServiceWorkerRouterInfo()->RuleIdMatched());
    }

    if (response.GetServiceWorkerRouterInfo()->MatchedSourceType()) {
      router_info->setMatchedSourceType(BuildServiceWorkerRouterSourceType(
          *response.GetServiceWorkerRouterInfo()->MatchedSourceType()));
    }

    if (response.GetServiceWorkerRouterInfo()->ActualSourceType()) {
      router_info->setActualSourceType(BuildServiceWorkerRouterSourceType(
          *response.GetServiceWorkerRouterInfo()->ActualSourceType()));
    }
    response_object->setServiceWorkerRouterInfo(std::move(router_info));
  }

  response_object->setFromPrefetchCache(response.WasInPrefetchCache());
  if (auto* resource_load_timing = response.GetResourceLoadTiming()) {
    auto load_timing = BuildObjectForTiming(*resource_load_timing);

    if (RuntimeEnabledFeatures::ServiceWorkerStaticRouterTimingInfoEnabled(
            context)) {
      if (!resource_load_timing->WorkerRouterEvaluationStart().is_null()) {
        load_timing->setWorkerRouterEvaluationStart(
            resource_load_timing->CalculateMillisecondDelta(
                resource_load_timing->WorkerRouterEvaluationStart()));
      }

      if (!resource_load_timing->WorkerCacheLokupStart().is_null()) {
        load_timing->setWorkerCacheLookupStart(
            resource_load_timing->CalculateMillisecondDelta(
                resource_load_timing->WorkerCacheLokupStart()));
      }
    }

    response_object->setTiming(std::move(load_timing));
  }

  const net::IPEndPoint& remote_ip_endpoint = response.RemoteIPEndpoint();
  if (remote_ip_endpoint.address().IsValid()) {
    response_object->setRemoteIPAddress(
        IPAddressToString(remote_ip_endpoint.address()));
    response_object->setRemotePort(remote_ip_endpoint.port());
  }

  response_object->setProtocol(
      InspectorNetworkAgent::GetProtocolAsString(response));
  if (response.AlternateProtocolUsage() !=
      net::AlternateProtocolUsage::
          ALTERNATE_PROTOCOL_USAGE_UNSPECIFIED_REASON) {
    response_object->setAlternateProtocolUsage(
        AlternateProtocolUsageToString(response.AlternateProtocolUsage()));
  }

  const std::optional<net::SSLInfo>& ssl_info = response.GetSSLInfo();
  if (ssl_info.has_value()) {
    response_object->setSecurityDetails(BuildSecurityDetails(*ssl_info));
  }

  if (cached_resource && cached_resource->IsPreloadedByEarlyHints()) {
    response_object->setFromEarlyHints(true);
  }

  return response_object;
}

InspectorNetworkAgent::~InspectorNetworkAgent() = default;

void InspectorNetworkAgent::Trace(Visitor* visitor) const {
  visitor->Trace(inspected_frames_);
  visitor->Trace(worker_or_worklet_global_scope_);
  visitor->Trace(resources_data_);
  visitor->Trace(replay_xhrs_);
  visitor->Trace(pending_xhr_replay_data_);
  InspectorBaseAgent::Trace(visitor);
}

void InspectorNetworkAgent::ShouldBlockRequest(const KURL& url, bool* result) {
  if (blocked_urls_.IsEmpty())
    return;

  String url_string = url.GetString();
  for (const String& blocked : blocked_urls_.Keys()) {
    if (Matches(url_string, blocked)) {
      *result = true;
      return;
    }
  }
}

void InspectorNetworkAgent::ShouldBypassServiceWorker(bool* result) {
  if (bypass_service_worker_.Get())
    *result = true;
}

void InspectorNetworkAgent::DidBlockRequest(
    const ResourceRequest& request,
    DocumentLoader* loader,
    const KURL& fetch_context_url,
    const ResourceLoaderOptions& options,
    ResourceRequestBlockedReason reason,
    ResourceType resource_type) {
  InspectorPageAgent::ResourceType type =
      InspectorPageAgent::ToResourceType(resource_type);

  WillSendRequestInternal(loader, fetch_context_url, request,
                          ResourceResponse(), options, type,
                          base::TimeTicks::Now());

  String request_id = RequestId(loader, request.InspectorId());

  // Conversion Measurement API triggers recording of conversions
  // as redirects to a `/.well-known/register-conversion` url.
  // The redirect request is not actually executed
  // but stored internally and then aborted. As the redirect is blocked using
  // the ResourceRequestBlockedReason::kConversionRequest even when everything
  // worked out fine, we mark the request as successful, as to not confuse devs.
  if (reason == ResourceRequestBlockedReason::kConversionRequest) {
    GetFrontend()->loadingFinished(
        request_id, base::TimeTicks::Now().since_origin().InSecondsF(), 0);
    return;
  }

  String protocol_reason = BuildBlockedReason(reason);
  GetFrontend()->loadingFailed(
      request_id, base::TimeTicks::Now().since_origin().InSecondsF(),
      InspectorPageAgent::ResourceTypeJson(
          resources_data_->GetResourceType(request_id)),
      String(), false, protocol_reason);
}

void InspectorNetworkAgent::DidChangeResourcePriority(
    DocumentLoader* loader,
    uint64_t identifier,
    ResourceLoadPriority load_priority) {
  String request_id = RequestId(loader, identifier);
  GetFrontend()->resourceChangedPriority(
      request_id, ResourcePriorityJSON(load_priority),
      base::TimeTicks::Now().since_origin().InSecondsF());
}

String InspectorNetworkAgent::RequestId(DocumentLoader* loader,
                                        uint64_t identifier) {
  // It's difficult to go from a loader to an execution context, and in the case
  // of iframes the loader that is resolved via |GetTargetExecutionContext()| is
  // not the intended loader
  if (loader)
    return IdentifiersFactory::RequestId(loader, identifier);
  return IdentifiersFactory::RequestId(GetTargetExecutionContext(), identifier);
}

void InspectorNetworkAgent::WillSendRequestInternal(
    DocumentLoader* loader,
    const KURL& fetch_context_url,
    const ResourceRequest& request,
    const ResourceResponse& redirect_response,
    const ResourceLoaderOptions& options,
    InspectorPageAgent::ResourceType type,
    base::TimeTicks timestamp) {
  String loader_id = IdentifiersFactory::LoaderId(loader);
  String request_id = RequestId(loader, request.InspectorId());
  NetworkResourcesData::ResourceData const* data =
      resources_data_->Data(request_id);
  // Support for POST request redirect.
  scoped_refptr<EncodedFormData> post_data;
  if (data &&
      (redirect_response.HttpStatusCode() == net::HTTP_TEMPORARY_REDIRECT ||
       redirect_response.HttpStatusCode() == net::HTTP_PERMANENT_REDIRECT)) {
    post_data = data->PostData();
  } else if (request.HttpBody()) {
    post_data = request.HttpBody()->DeepCopy();
  }

  resources_data_->ResourceCreated(request_id, loader_id, request.Url(),
                                   post_data);
  if (options.initiator_info.name ==
      fetch_initiator_type_names::kXmlhttprequest) {
    type = InspectorPageAgent::kXHRResource;
  } else if (options.initiator_info.name ==
             fetch_initiator_type_names::kFetch) {
    type = InspectorPageAgent::kFetchResource;
  } else if (options.initiator_info.name ==
                 fetch_initiator_type_names::kBeacon ||
             options.initiator_info.name == fetch_initiator_type_names::kPing) {
    type = InspectorPageAgent::kPingResource;
  }

  if (pending_request_type_)
    type = *pending_request_type_;
  resources_data_->SetResourceType(request_id, type);

  String frame_id = loader && loader->GetFrame()
                        ? IdentifiersFactory::FrameId(loader->GetFrame())
                        : "";
  std::unique_ptr<protocol::Network::Initiator> initiator_object =
      BuildInitiatorObject(
          loader && loader->GetFrame() ? loader->GetFrame()->GetDocument()
                                       : nullptr,
          options.initiator_info, std::numeric_limits<int>::max());

  std::unique_ptr<protocol::Network::Request> request_info(
      BuildObjectForResourceRequest(request, post_data,
                                    max_post_data_size_.Get()));

  // |loader| is null while inspecting worker.
  // TODO(horo): Refactor MixedContentChecker and set mixed content type even if
  // |loader| is null.
  if (loader) {
    request_info->setMixedContentType(MixedContentTypeForContextType(
        MixedContentChecker::ContextTypeForInspector(loader->GetFrame(),
                                                     request)));
  }

  request_info->setReferrerPolicy(
      GetReferrerPolicy(request.GetReferrerPolicy()));
  if (options.initiator_info.is_link_preload)
    request_info->setIsLinkPreload(true);

  String resource_type = InspectorPageAgent::ResourceTypeJson(type);
  String documentURL = loader
                           ? UrlWithoutFragment(loader->Url()).GetString()
                           : UrlWithoutFragment(fetch_context_url).GetString();
  Maybe<String> maybe_frame_id;
  if (!frame_id.empty())
    maybe_frame_id = frame_id;
  if (loader && loader->GetFrame() && loader->GetFrame()->GetDocument()) {
    request_info->setIsSameSite(
        loader->GetFrame()->GetDocument()->SiteForCookies().IsFirstParty(
            GURL(request.Url())));
  }
  GetFrontend()->requestWillBeSent(
      request_id, loader_id, documentURL, std::move(request_info),
      timestamp.since_origin().InSecondsF(),
      base::Time::Now().InSecondsFSinceUnixEpoch(), std::move(initiator_object),
      redirect_response.EmittedExtraInfo(),
      BuildObjectForResourceResponse(redirect_response,
                                     GetTargetExecutionContext()),
      resource_type, std::move(maybe_frame_id), request.HasUserGesture());
  if (options.synchronous_policy == SynchronousPolicy::kRequestSynchronously)
    GetFrontend()->flush();

  if (pending_xhr_replay_data_) {
    resources_data_->SetXHRReplayData(request_id,
                                      pending_xhr_replay_data_.Get());
    pending_xhr_replay_data_.Clear();
  }
  pending_request_type_ = std::nullopt;
}

void InspectorNetworkAgent::WillSendNavigationRequest(
    uint64_t identifier,
    DocumentLoader* loader,
    const KURL& url,
    const AtomicString& http_method,
    EncodedFormData* http_body) {
  String loader_id = IdentifiersFactory::LoaderId(loader);
  String request_id = loader_id;
  NetworkResourcesData::ResourceData const* data =
      resources_data_->Data(request_id);
  // Support for POST request redirect.
  scoped_refptr<EncodedFormData> post_data;
  if (data)
    post_data = data->PostData();
  else if (http_body)
    post_data = http_body->DeepCopy();
  resources_data_->ResourceCreated(request_id, loader_id, url, post_data);
  resources_data_->SetResourceType(request_id,
                                   InspectorPageAgent::kDocumentResource);
}

// This method was pulled out of PrepareRequest(), because we want to be able
// to create DevTools issues before the PrepareRequest() call. We need these
// IDs to be set, to properly create a DevTools issue.
void InspectorNetworkAgent::SetDevToolsIds(
    ResourceRequest& request,
    const FetchInitiatorInfo& initiator_info) {
  // Network instrumentation ignores the requests initiated internally (these
  // are unexpected to the user and usually do not hit the remote server).
  // Ignore them and do not set the devtools id, so that other systems like
  // network interceptor in the browser do not mistakenly report it.
  if (initiator_info.name == fetch_initiator_type_names::kInternal)
    return;
  request.SetDevToolsToken(devtools_token_);

  // The loader parameter is for generating a browser generated ID for a browser
  // initiated request. We pass it null here because we are reporting a renderer
  // generated ID for a renderer initiated request.
  request.SetDevToolsId(
      IdentifiersFactory::SubresourceRequestId(request.InspectorId()));
}

void InspectorNetworkAgent::PrepareRequest(DocumentLoader* loader,
                                           ResourceRequest& request,
                                           ResourceLoaderOptions& options,
                                           ResourceType resource_type) {
  // Ignore the request initiated internally.
  if (options.initiator_info.name == fetch_initiator_type_names::kInternal)
    return;

  if (!extra_request_headers_.IsEmpty()) {
    for (const WTF::String& key : extra_request_headers_.Keys()) {
      const WTF::String& value = extra_request_headers_.Get(key);
      AtomicString header_name = AtomicString(key);
      // When overriding referrer, also override referrer policy
      // for this request to assure the request will be allowed.
      // TODO: Should we store the referrer header somewhere other than
      // |extra_request_headers_|?
      if (EqualIgnoringASCIICase(header_name, http_names::kReferer)) {
        request.SetReferrerString(value);
        request.SetReferrerPolicy(network::mojom::ReferrerPolicy::kAlways);
      } else {
        request.SetHttpHeaderField(header_name, AtomicString(value));
      }
    }
  }

  if (cache_disabled_.Get()) {
    if (LoadsFromCacheOnly(request) &&
        request.GetRequestContext() !=
            mojom::blink::RequestContextType::INTERNAL) {
      request.SetCacheMode(mojom::FetchCacheMode::kUnspecifiedForceCacheMiss);
    } else {
      request.SetCacheMode(mojom::FetchCacheMode::kBypassCache);
    }
  }
  if (bypass_service_worker_.Get())
    request.SetSkipServiceWorker(true);

  if (attach_debug_stack_enabled_.Get() &&
      // Preserving existing stack id when cloning requests instead of
      // overwriting
      !request.GetDevToolsStackId().has_value()) {
    ExecutionContext* context = nullptr;
    if (worker_or_worklet_global_scope_) {
      context = worker_or_worklet_global_scope_.Get();
    } else if (loader && loader->GetFrame()) {
      context = loader->GetFrame()->GetDocument()->domWindow();
    }
    String stack_id =
        RequestDebugHeaderScope::CaptureStackIdForCurrentLocation(context);
    if (!stack_id.IsNull()) {
      request.SetDevToolsStackId(stack_id);
    }
  }
  if (!accepted_encodings_.IsEmpty()) {
    scoped_refptr<
        base::RefCountedData<base::flat_set<net::SourceStream::SourceType>>>
        accepted_stream_types = request.GetDevToolsAcceptedStreamTypes();
    if (!accepted_stream_types) {
      accepted_stream_types = base::MakeRefCounted<base::RefCountedData<
          base::flat_set<net::SourceStream::SourceType>>>();
    }
    if (!accepted_encodings_.Get("none")) {
      for (auto key : accepted_encodings_.Keys())
        accepted_stream_types->data.insert(SourceTypeFromString(key));
    }
    request.SetDevToolsAcceptedStreamTypes(std::move(accepted_stream_types));
  }
}

void InspectorNetworkAgent::WillSendRequest(
    ExecutionContext*,
    DocumentLoader* loader,
    const KURL& fetch_context_url,
    const ResourceRequest& request,
    const ResourceResponse& redirect_response,
    const ResourceLoaderOptions& options,
    ResourceType resource_type,
    RenderBlockingBehavior render_blocking_behavior,
    base::TimeTicks timestamp) {
  // Ignore the request initiated internally.
  if (options.initiator_info.name == fetch_initiator_type_names::kInternal)
    return;

  InspectorPageAgent::ResourceType type =
      InspectorPageAgent::ToResourceType(resource_type);

  WillSendRequestInternal(loader, fetch_context_url, request, redirect_response,
                          options, type, timestamp);
}

void InspectorNetworkAgent::MarkResourceAsCached(DocumentLoader* loader,
                                                 uint64_t identifier) {
  GetFrontend()->requestServedFromCache(RequestId(loader, identifier));
}

void InspectorNetworkAgent::DidReceiveResourceResponse(
    uint64_t identifier,
    DocumentLoader* loader,
    const ResourceResponse& response,
    const Resource* cached_resource) {
  String request_id = RequestId(loader, identifier);
  bool is_not_modified = response.HttpStatusCode() == 304;

  bool resource_is_empty = true;
  std::unique_ptr<protocol::Network::Response> resource_response =
      BuildObjectForResourceResponse(response, GetTargetExecutionContext(),
                                     cached_resource, &resource_is_empty);

  InspectorPageAgent::ResourceType type =
      cached_resource
          ? InspectorPageAgent::ToResourceType(cached_resource->GetType())
          : InspectorPageAgent::kOtherResource;
  // Override with already discovered resource type.
  InspectorPageAgent::ResourceType saved_type =
      resources_data_->GetResourceType(request_id);
  if (saved_type == InspectorPageAgent::kScriptResource ||
      saved_type == InspectorPageAgent::kXHRResource ||
      saved_type == InspectorPageAgent::kDocumentResource ||
      saved_type == InspectorPageAgent::kFetchResource ||
      saved_type == InspectorPageAgent::kEventSourceResource ||
      saved_type == InspectorPageAgent::kPingResource) {
    type = saved_type;
  }

  // Main Worker requests are initiated in the browser, so saved_type will not
  // be found. We therefore must explicitly set it.
  if (worker_or_worklet_global_scope_ &&
      worker_or_worklet_global_scope_->IsWorkerGlobalScope()) {
    WorkerGlobalScope* worker_global_scope =
        To<WorkerGlobalScope>(worker_or_worklet_global_scope_.Get());
    auto main_resource_identifier =
        worker_global_scope->MainResourceIdentifier();

    if (main_resource_identifier == identifier) {
      DCHECK(saved_type == InspectorPageAgent::kOtherResource);
      type = InspectorPageAgent::kScriptResource;
    }
  }

  // Resources are added to NetworkResourcesData as a WeakMember here and
  // removed in willDestroyResource() called in the prefinalizer of Resource.
  // Because NetworkResourceData retains weak references only, it
  // doesn't affect Resource lifetime.
  if (cached_resource)
    resources_data_->AddResource(request_id, cached_resource);
  String frame_id = loader && loader->GetFrame()
                        ? IdentifiersFactory::FrameId(loader->GetFrame())
                        : "";
  String loader_id = IdentifiersFactory::LoaderId(loader);
  resources_data_->SetResourceType(request_id, type);
  resources_data_->ResponseReceived(request_id, frame_id, response);

  const std::optional<net::SSLInfo>& ssl_info = response.GetSSLInfo();
  if (ssl_info.has_value() && ssl_info->cert) {
    resources_data_->SetCertificate(request_id, ssl_info->cert);
  }

  if (IsNavigation(loader, identifier))
    return;
  if (resource_response && !resource_is_empty) {
    Maybe<String> maybe_frame_id;
    if (!frame_id.empty())
      maybe_frame_id = frame_id;
    GetFrontend()->responseReceived(
        request_id, loader_id,
        base::TimeTicks::Now().since_origin().InSecondsF(),
        InspectorPageAgent::ResourceTypeJson(type),
        std::move(resource_response), response.EmittedExtraInfo(),
        std::move(maybe_frame_id));
  }
  // If we revalidated the resource and got Not modified, send content length
  // following didReceiveResponse as there will be no calls to didReceiveData
  // from the network stack.
  if (is_
"""


```
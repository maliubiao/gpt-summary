Response:
Let's break down the thought process for analyzing the `decimal.cc` file and generating the comprehensive answer.

1. **Understand the Goal:** The core request is to analyze the functionality of `decimal.cc`, specifically focusing on its relation to web technologies (JavaScript, HTML, CSS), providing examples, logical inferences, and common usage errors.

2. **Initial Code Scan and Identification of Core Purpose:**  The first step is to quickly read through the code, noting key elements:
    * The copyright notice indicates it's related to Google and Blink.
    * The inclusion of `<cfloat>` and the presence of constants like `kExponentMax`, `kExponentMin`, `kPrecision` strongly suggest it deals with numerical representation, likely high-precision decimals.
    *  The namespace `blink` confirms its connection to the Blink rendering engine.
    *  The class `Decimal` is central, with methods for arithmetic operations (`+=`, `-=`, `*=`, `/=`, `+`, `-`, `*`, `/`), comparisons (`==`, `!=`, `<`, `<=`, `>`, `>=`), and other manipulations (`Abs`, `Ceil`, `Floor`, `Round`).
    *  The presence of `FromString`, `ToDouble`, and `ToString` hints at conversion between different representations.
    *  The `SpecialValueHandler` class suggests handling of special numerical values like infinity and NaN.

3. **Identify Core Functionality - High-Precision Decimal Arithmetic:**  Based on the initial scan, the primary function is clearly to provide a way to represent and manipulate decimal numbers with a higher precision than standard floating-point numbers (`double`). This is crucial for accuracy in certain web-related scenarios.

4. **Relate to Web Technologies (JavaScript, HTML, CSS):** This is a key part of the request. Consider how high-precision decimals might be relevant:

    * **JavaScript:** JavaScript's `Number` type is based on IEEE 754 double-precision floating-point numbers, which can have precision issues with decimal values. `decimal.cc` likely provides a more accurate representation for cases where precision is critical. Think about examples like financial calculations or dealing with very large or very small numbers.
    * **HTML:** While HTML itself doesn't directly deal with numerical calculations, it displays the results. The accuracy provided by `decimal.cc` could be important for displaying precise values generated by JavaScript or fetched from backend systems.
    * **CSS:** CSS mainly deals with styling, but properties like `calc()` can involve numerical computations. While less direct, the underlying engine might use high-precision decimals for intermediate calculations to ensure accuracy. Consider percentages or complex unit conversions.

5. **Provide Concrete Examples:** For each web technology, create specific examples that illustrate the benefits of using high-precision decimals:

    * **JavaScript:** Show the precision loss with standard `Number` and how `decimal.cc` (even indirectly) helps maintain accuracy in financial calculations.
    * **HTML:** Demonstrate how displaying the results of a precise calculation in HTML benefits from the accurate underlying representation.
    * **CSS:**  Illustrate how `calc()` might rely on high-precision arithmetic internally for accurate results, even if the final CSS value has limited precision.

6. **Logical Inferences (Assumptions, Inputs, Outputs):** Look for areas where the code performs transformations or calculations. Choose a couple of representative methods and illustrate their behavior with examples:

    * **`Add` (`operator+`):** Pick simple decimal inputs and predict the output based on standard decimal addition rules. Include cases with different signs and exponents.
    * **`Multiply` (`operator*`):** Similarly, choose simple decimal inputs for multiplication and predict the output, considering exponent handling.

7. **Identify Potential Usage Errors:** Think about common mistakes developers might make when dealing with decimal numbers or when the limitations of `decimal.cc` might be overlooked:

    * **Loss of Precision During Conversion:** Highlight the potential for precision loss when converting between `double` and `Decimal`.
    * **Performance Overhead:**  Mention that high-precision arithmetic can be slower than native floating-point operations.
    * **Misunderstanding Precision Limits:** Explain that while higher than `double`, `Decimal` still has a finite precision.
    * **Incorrect Usage of Comparison Operators:** Point out the need to be careful when comparing decimals for equality due to potential rounding or representation differences.

8. **Structure the Answer:** Organize the information logically with clear headings and bullet points. Start with a general overview of the file's functionality and then delve into specifics. Use clear and concise language.

9. **Refine and Review:** Read through the generated answer, checking for accuracy, clarity, and completeness. Ensure that the examples are easy to understand and that the explanations are technically sound. For instance, initially, I might have focused too much on direct JavaScript API usage, but the key is to understand *how* Blink uses it internally and the *benefits* it provides to web developers even if they don't directly interact with the `Decimal` class. Refine the examples and explanations accordingly. Ensure that the connection to HTML and CSS, while less direct, is still explained logically.

This iterative process of scanning, identifying, relating, exemplifying, inferring, and refining helps create a comprehensive and accurate analysis of the provided code snippet.
这个文件 `blink/renderer/platform/wtf/decimal.cc` 实现了 Blink 渲染引擎中的一个高精度定点数（Decimal）类。 它的主要功能是提供一种比标准浮点数（如 `double`）更精确的方式来表示和操作十进制数值。

**主要功能:**

1. **高精度十进制数表示:**  `Decimal` 类允许存储和操作具有固定精度的十进制数，避免了浮点数运算中常见的舍入误差。它内部使用一个 64 位整数来存储有效数字（coefficient）和一个 16 位整数来存储指数（exponent）。

2. **基本的算术运算:** 实现了加 (`+`, `+=`)、减 (`-`, `-=`)、乘 (`*`, `*=`)、除 (`/`, `/=`) 等基本的算术运算。这些运算都考虑了精度问题，力求得到精确的十进制结果。

3. **比较运算:** 实现了相等 (`==`)、不等 (`!=`)、小于 (`<`)、小于等于 (`<=`)、大于 (`>`)、大于等于 (`>=`) 等比较运算符，用于比较两个 `Decimal` 对象的大小。

4. **特殊值处理:**  能够处理特殊值，如正负无穷大 (`Infinity`) 和非数字 (`NaN`)。这与 JavaScript 中 Number 类型的行为类似。

5. **字符串和数字之间的转换:** 提供了 `FromString()` 方法将字符串转换为 `Decimal` 对象，以及 `ToString()` 方法将 `Decimal` 对象转换为字符串。还提供了 `FromDouble()` 和 `ToDouble()` 方法用于与 `double` 类型之间进行转换。

6. **其他数学函数:**  实现了 `Abs()` (绝对值)、`Ceil()` (向上取整)、`Floor()` (向下取整)、`Round()` (四舍五入)、`Remainder()` (求余) 等常用的数学函数。

**与 JavaScript, HTML, CSS 的关系及举例说明:**

`decimal.cc` 提供的 `Decimal` 类主要用于 Blink 引擎内部，**通常不会直接暴露给 JavaScript、HTML 或 CSS 代码使用**。 然而，它在引擎内部的运用可以间接地影响这些技术的功能和精度。

**1. JavaScript:**

* **影响:**  虽然 JavaScript 的 `Number` 类型是基于 IEEE 754 双精度浮点数的，但 Blink 引擎在某些内部操作中可能会使用 `Decimal` 来保证精度。 例如，在处理一些需要高精度计算的场景，比如处理 financial 数据或者进行复杂的布局计算时，Blink 可能会使用 `Decimal` 来避免浮点数误差。
* **举例说明:**
    * **假设输入 (JavaScript):**  考虑以下 JavaScript 代码：
      ```javascript
      let a = 0.1;
      let b = 0.2;
      console.log(a + b); // 输出可能为 0.30000000000000004，而不是精确的 0.3
      ```
    * **内部处理 (C++ `decimal.cc`):**  在 Blink 内部，如果某个计算（例如，某个 JavaScript API 的实现）需要非常精确地处理 0.1 和 0.2 这样的十进制数，可能会使用 `Decimal` 类进行计算，得到精确的 0.3。 然后，这个精确的结果可能被转换为 JavaScript 的 `Number` 类型返回。虽然最终返回给 JavaScript 的仍然是 `Number`，但在中间计算过程中使用 `Decimal` 可以提高精度。
    * **假设输出 (通过 Blink 内部 `Decimal` 辅助):**  虽然 JavaScript 本身仍可能受到浮点数精度的限制，但在某些特定情况下，Blink 内部使用 `Decimal` 可以确保一些关键计算的准确性，从而间接提高 Web 应用的可靠性。

**2. HTML:**

* **影响:**  `Decimal` 的精度可以影响 HTML 中数值的渲染。当 JavaScript 生成数值并将其插入到 HTML 中时，如果这些数值是通过 `Decimal` 精确计算得到的，那么在 HTML 中显示时也会更加准确。
* **举例说明:**
    * **假设输入 (JavaScript):**
      ```javascript
      let price = 9.99;
      let quantity = 100;
      let totalPrice = price * quantity; // 使用 JavaScript 的 Number 计算
      document.getElementById("total").innerText = totalPrice;
      ```
    * **内部处理 (可能使用 `decimal.cc`):**  假设 Blink 内部在处理一些与渲染或布局相关的数值时，使用了 `Decimal` 进行更精确的计算。虽然上面的 JavaScript 代码直接使用了 `Number`，但如果 Blink 在内部需要基于这些数值进行进一步的计算（例如，计算元素的位置或大小），使用 `Decimal` 可以避免累积误差。
    * **假设输出 (HTML):**  `<span id="total">998.9999999999999</span>` (使用 `Number` 可能出现精度问题)  vs. `<span id="total">999</span>` (如果 Blink 内部使用了 `Decimal` 进行相关的精度处理，最终显示的可能更接近期望值)。  **请注意，这里的关系是间接的，直接由 JavaScript `Number` 计算并输出到 HTML 的结果仍然受 JavaScript 浮点数精度的限制。** `decimal.cc` 的作用更多体现在 Blink 引擎内部的数值处理。

**3. CSS:**

* **影响:** 在 CSS 中，`calc()` 函数允许进行数值计算。 虽然 `calc()` 的结果最终会被转换为 CSS 长度或其他类型的值，但 Blink 内部在计算 `calc()` 表达式时，可能会利用 `Decimal` 来保证计算的准确性，尤其是在涉及小数或复杂的运算时。
* **举例说明:**
    * **假设输入 (CSS):**
      ```css
      .element {
        width: calc(100% / 3);
      }
      ```
    * **内部处理 (可能使用 `decimal.cc`):**  Blink 在计算 `100% / 3` 时，可能会使用 `Decimal` 类来得到一个高精度的结果（例如，0.333333...）。 然后，这个高精度的结果会被转换为 CSS 能够理解的长度值。
    * **假设输出 (实际像素值):**  如果使用标准浮点数进行计算，可能会有微小的舍入误差。 使用 `Decimal` 可以确保在计算过程中保持更高的精度，从而可能得到更准确的像素值。

**逻辑推理 (假设输入与输出):**

* **假设输入:** `Decimal a("0.1"); Decimal b("0.2"); Decimal sum = a + b;`
* **输出:** `sum` 的值将精确地表示为 0.3，而不会有浮点数误差。

* **假设输入:** `Decimal a("1"); Decimal b("3"); Decimal quotient = a / b;`
* **输出:** `quotient` 的值将是一个高精度的十进制数，尽可能精确地表示 1/3，例如 0.333333333333333333。

**用户或编程常见的使用错误 (针对 `Decimal` 类，虽然开发者通常不直接使用):**

由于开发者通常不会直接操作 `blink/renderer/platform/wtf/decimal.cc` 中定义的 `Decimal` 类，因此常见的用户错误更多是围绕**误解或忽视浮点数的精度问题**，而不是直接使用 `Decimal` 类出错。

1. **直接使用 JavaScript 的 `Number` 进行需要高精度的计算:**
   * **错误示例 (JavaScript):**
     ```javascript
     let price1 = 1.05;
     let price2 = 0.10;
     console.log(price1 - price2); // 输出 0.9500000000000001，而不是精确的 0.95
     ```
   * **说明:**  开发者期望得到精确的 0.95，但由于浮点数表示的限制，结果存在微小的误差。

2. **在需要精确比较时直接使用 `==` 比较浮点数:**
   * **错误示例 (JavaScript):**
     ```javascript
     let a = 0.1 + 0.2;
     let b = 0.3;
     console.log(a == b); // 输出 false，因为 a 的值可能略微大于 0.3
     ```
   * **说明:**  由于浮点数误差，`a` 的实际值可能不是精确的 0.3，导致比较失败。正确的做法是比较一个小的误差范围内。

3. **假设浮点数运算总是精确的:**
   * **错误示例:**  在进行复杂的金融计算或科学计算时，如果完全依赖 JavaScript 的 `Number` 类型，可能会累积误差，导致最终结果不准确。

**总结:**

`blink/renderer/platform/wtf/decimal.cc` 文件实现了 Blink 引擎内部使用的高精度定点数类。虽然开发者通常不会直接使用它，但它在引擎内部的运用有助于提高数值计算的精度，从而间接地影响 JavaScript 的行为、HTML 的渲染以及 CSS 的计算结果。理解其功能有助于理解 Blink 引擎在处理数值时的严谨性，并提醒开发者在需要高精度计算时注意浮点数的潜在问题。

### 提示词
```
这是目录为blink/renderer/platform/wtf/decimal.cc的chromium blink引擎源代码文件， 请列举一下它的功能, 
如果它与javascript, html, css的功能有关系，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明
```

### 源代码
```cpp
/*
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifdef UNSAFE_BUFFERS_BUILD
// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
#pragma allow_unsafe_buffers
#endif

#include "third_party/blink/renderer/platform/wtf/decimal.h"

#include <algorithm>
#include <cfloat>

#include "base/notreached.h"
#include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
#include "third_party/blink/renderer/platform/wtf/math_extras.h"
#include "third_party/blink/renderer/platform/wtf/text/string_builder.h"

namespace blink {

namespace {

constexpr int kExponentMax = 1023;
constexpr int kExponentMin = -1023;
constexpr int kPrecision = 18;

constexpr uint64_t kMaxCoefficient =
    UINT64_C(0xDE0B6B3A763FFFF);  // 999999999999999999 == 18 9's

// This class handles Decimal special values.
class SpecialValueHandler {
  STACK_ALLOCATED();

 public:
  enum HandleResult {
    kBothFinite,
    kBothInfinity,
    kEitherNaN,
    kLHSIsInfinity,
    kRHSIsInfinity,
  };

  SpecialValueHandler(const Decimal& lhs, const Decimal& rhs);
  SpecialValueHandler(const SpecialValueHandler&) = delete;
  SpecialValueHandler& operator=(const SpecialValueHandler&) = delete;

  HandleResult Handle();
  Decimal Value() const;

 private:
  enum Result {
    kResultIsLHS,
    kResultIsRHS,
    kResultIsUnknown,
  };

  const Decimal& lhs_;
  const Decimal& rhs_;
  Result result_ = kResultIsUnknown;
};

SpecialValueHandler::SpecialValueHandler(const Decimal& lhs, const Decimal& rhs)
    : lhs_(lhs), rhs_(rhs) {}

SpecialValueHandler::HandleResult SpecialValueHandler::Handle() {
  if (lhs_.IsFinite() && rhs_.IsFinite())
    return kBothFinite;

  if (lhs_.IsNaN()) {
    result_ = kResultIsLHS;
    return kEitherNaN;
  }

  if (rhs_.IsNaN()) {
    result_ = kResultIsRHS;
    return kEitherNaN;
  }

  if (lhs_.IsInfinity())
    return rhs_.IsInfinity() ? kBothInfinity : kLHSIsInfinity;

  DCHECK(rhs_.IsInfinity());
  return kRHSIsInfinity;
}

Decimal SpecialValueHandler::Value() const {
  DCHECK(result_ == kResultIsLHS || result_ == kResultIsRHS);
  return (result_ == kResultIsLHS) ? lhs_ : rhs_;
}

// This class is used for 128 bit unsigned integer arithmetic.
class UInt128 {
  STACK_ALLOCATED();

 public:
  UInt128(uint64_t low, uint64_t high) : high_(high), low_(low) {}

  UInt128& operator/=(uint32_t);

  uint64_t High() const { return high_; }
  uint64_t Low() const { return low_; }

  static UInt128 Multiply(uint64_t u, uint64_t v) {
    return UInt128(u * v, MultiplyHigh(u, v));
  }

 private:
  static uint32_t HighUInt32(uint64_t x) {
    return static_cast<uint32_t>(x >> 32);
  }
  static uint32_t LowUInt32(uint64_t x) {
    return static_cast<uint32_t>(x & ((static_cast<uint64_t>(1) << 32) - 1));
  }
  static uint64_t MakeUInt64(uint32_t low, uint32_t high) {
    return low | (static_cast<uint64_t>(high) << 32);
  }

  static uint64_t MultiplyHigh(uint64_t, uint64_t);

  uint64_t high_;
  uint64_t low_;
};

UInt128& UInt128::operator/=(const uint32_t divisor) {
  DCHECK(divisor);

  if (!high_) {
    low_ /= divisor;
    return *this;
  }

  uint32_t dividend[4];
  dividend[0] = LowUInt32(low_);
  dividend[1] = HighUInt32(low_);
  dividend[2] = LowUInt32(high_);
  dividend[3] = HighUInt32(high_);

  uint32_t quotient[4];
  uint32_t remainder = 0;
  for (int i = 3; i >= 0; --i) {
    const uint64_t work = MakeUInt64(dividend[i], remainder);
    remainder = static_cast<uint32_t>(work % divisor);
    quotient[i] = static_cast<uint32_t>(work / divisor);
  }
  low_ = MakeUInt64(quotient[0], quotient[1]);
  high_ = MakeUInt64(quotient[2], quotient[3]);
  return *this;
}

// Returns high 64bit of 128bit product.
uint64_t UInt128::MultiplyHigh(uint64_t u, uint64_t v) {
  const uint64_t u_low = LowUInt32(u);
  const uint64_t u_high = HighUInt32(u);
  const uint64_t v_low = LowUInt32(v);
  const uint64_t v_high = HighUInt32(v);
  const uint64_t partial_product = u_high * v_low + HighUInt32(u_low * v_low);
  return u_high * v_high + HighUInt32(partial_product) +
         HighUInt32(u_low * v_high + LowUInt32(partial_product));
}

static int CountDigits(uint64_t x) {
  int number_of_digits = 0;
  for (uint64_t power_of_ten = 1; x >= power_of_ten; power_of_ten *= 10) {
    ++number_of_digits;
    if (power_of_ten >= std::numeric_limits<uint64_t>::max() / 10)
      break;
  }
  return number_of_digits;
}

static uint64_t ScaleDown(uint64_t x, int n) {
  DCHECK_GE(n, 0);
  while (n > 0 && x) {
    x /= 10;
    --n;
  }
  return x;
}

static uint64_t ScaleUp(uint64_t x, int n) {
  DCHECK_GE(n, 0);
  DCHECK_LE(n, kPrecision);

  uint64_t y = 1;
  uint64_t z = 10;
  for (;;) {
    if (n & 1)
      y = y * z;

    n >>= 1;
    if (!n)
      return x * y;

    z = z * z;
  }
}

}  // namespace

Decimal::EncodedData::EncodedData(Sign sign, FormatClass format_class)
    : coefficient_(0), exponent_(0), format_class_(format_class), sign_(sign) {}

Decimal::EncodedData::EncodedData(Sign sign, int exponent, uint64_t coefficient)
    : format_class_(coefficient ? kClassNormal : kClassZero), sign_(sign) {
  if (exponent >= kExponentMin && exponent <= kExponentMax) {
    while (coefficient > kMaxCoefficient) {
      coefficient /= 10;
      ++exponent;
    }
  }

  if (exponent > kExponentMax) {
    coefficient_ = 0;
    exponent_ = 0;
    format_class_ = kClassInfinity;
    return;
  }

  if (exponent < kExponentMin) {
    coefficient_ = 0;
    exponent_ = 0;
    format_class_ = kClassZero;
    return;
  }

  coefficient_ = coefficient;
  exponent_ = static_cast<int16_t>(exponent);
}

bool Decimal::EncodedData::operator==(const EncodedData& another) const {
  return sign_ == another.sign_ && format_class_ == another.format_class_ &&
         exponent_ == another.exponent_ && coefficient_ == another.coefficient_;
}

Decimal::Decimal(int32_t i32)
    : data_(i32 < 0 ? kNegative : kPositive,
            0,
            i32 < 0 ? static_cast<uint64_t>(-static_cast<int64_t>(i32))
                    : static_cast<uint64_t>(i32)) {}

Decimal::Decimal(Sign sign, int exponent, uint64_t coefficient)
    : data_(sign, exponent, coefficient) {}

Decimal::Decimal(const EncodedData& data) : data_(data) {}

Decimal::Decimal(const Decimal& other) = default;

Decimal& Decimal::operator=(const Decimal& other) = default;

Decimal& Decimal::operator+=(const Decimal& other) {
  data_ = (*this + other).data_;
  return *this;
}

Decimal& Decimal::operator-=(const Decimal& other) {
  data_ = (*this - other).data_;
  return *this;
}

Decimal& Decimal::operator*=(const Decimal& other) {
  data_ = (*this * other).data_;
  return *this;
}

Decimal& Decimal::operator/=(const Decimal& other) {
  data_ = (*this / other).data_;
  return *this;
}

Decimal Decimal::operator-() const {
  if (IsNaN())
    return *this;

  Decimal result(*this);
  result.data_.SetSign(InvertSign(data_.GetSign()));
  return result;
}

Decimal Decimal::operator+(const Decimal& rhs) const {
  const Decimal& lhs = *this;
  const Sign lhs_sign = lhs.GetSign();
  const Sign rhs_sign = rhs.GetSign();

  SpecialValueHandler handler(lhs, rhs);
  switch (handler.Handle()) {
    case SpecialValueHandler::kBothFinite:
      break;

    case SpecialValueHandler::kBothInfinity:
      return lhs_sign == rhs_sign ? lhs : Nan();

    case SpecialValueHandler::kEitherNaN:
      return handler.Value();

    case SpecialValueHandler::kLHSIsInfinity:
      return lhs;

    case SpecialValueHandler::kRHSIsInfinity:
      return rhs;
  }

  const AlignedOperands aligned_operands = AlignOperands(lhs, rhs);

  const uint64_t result =
      lhs_sign == rhs_sign
          ? aligned_operands.lhs_coefficient + aligned_operands.rhs_coefficient
          : aligned_operands.lhs_coefficient - aligned_operands.rhs_coefficient;

  if (lhs_sign == kNegative && rhs_sign == kPositive && !result)
    return Decimal(kPositive, aligned_operands.exponent, 0);

  return static_cast<int64_t>(result) >= 0
             ? Decimal(lhs_sign, aligned_operands.exponent, result)
             : Decimal(InvertSign(lhs_sign), aligned_operands.exponent,
                       -static_cast<int64_t>(result));
}

Decimal Decimal::operator-(const Decimal& rhs) const {
  const Decimal& lhs = *this;
  const Sign lhs_sign = lhs.GetSign();
  const Sign rhs_sign = rhs.GetSign();

  SpecialValueHandler handler(lhs, rhs);
  switch (handler.Handle()) {
    case SpecialValueHandler::kBothFinite:
      break;

    case SpecialValueHandler::kBothInfinity:
      return lhs_sign == rhs_sign ? Nan() : lhs;

    case SpecialValueHandler::kEitherNaN:
      return handler.Value();

    case SpecialValueHandler::kLHSIsInfinity:
      return lhs;

    case SpecialValueHandler::kRHSIsInfinity:
      return Infinity(InvertSign(rhs_sign));
  }

  const AlignedOperands aligned_operands = AlignOperands(lhs, rhs);

  const uint64_t result =
      lhs_sign == rhs_sign
          ? aligned_operands.lhs_coefficient - aligned_operands.rhs_coefficient
          : aligned_operands.lhs_coefficient + aligned_operands.rhs_coefficient;

  if (lhs_sign == kNegative && rhs_sign == kNegative && !result)
    return Decimal(kPositive, aligned_operands.exponent, 0);

  return static_cast<int64_t>(result) >= 0
             ? Decimal(lhs_sign, aligned_operands.exponent, result)
             : Decimal(InvertSign(lhs_sign), aligned_operands.exponent,
                       -static_cast<int64_t>(result));
}

Decimal Decimal::operator*(const Decimal& rhs) const {
  const Decimal& lhs = *this;
  const Sign lhs_sign = lhs.GetSign();
  const Sign rhs_sign = rhs.GetSign();
  const Sign result_sign = lhs_sign == rhs_sign ? kPositive : kNegative;

  SpecialValueHandler handler(lhs, rhs);
  switch (handler.Handle()) {
    case SpecialValueHandler::kBothFinite: {
      const uint64_t lhs_coefficient = lhs.data_.Coefficient();
      const uint64_t rhs_coefficient = rhs.data_.Coefficient();
      int result_exponent = lhs.Exponent() + rhs.Exponent();
      UInt128 work(UInt128::Multiply(lhs_coefficient, rhs_coefficient));
      while (work.High()) {
        work /= 10;
        ++result_exponent;
      }
      return Decimal(result_sign, result_exponent, work.Low());
    }

    case SpecialValueHandler::kBothInfinity:
      return Infinity(result_sign);

    case SpecialValueHandler::kEitherNaN:
      return handler.Value();

    case SpecialValueHandler::kLHSIsInfinity:
      return rhs.IsZero() ? Nan() : Infinity(result_sign);

    case SpecialValueHandler::kRHSIsInfinity:
      return lhs.IsZero() ? Nan() : Infinity(result_sign);
  }

  NOTREACHED();
}

Decimal Decimal::operator/(const Decimal& rhs) const {
  const Decimal& lhs = *this;
  const Sign lhs_sign = lhs.GetSign();
  const Sign rhs_sign = rhs.GetSign();
  const Sign result_sign = lhs_sign == rhs_sign ? kPositive : kNegative;

  SpecialValueHandler handler(lhs, rhs);
  switch (handler.Handle()) {
    case SpecialValueHandler::kBothFinite:
      break;

    case SpecialValueHandler::kBothInfinity:
      return Nan();

    case SpecialValueHandler::kEitherNaN:
      return handler.Value();

    case SpecialValueHandler::kLHSIsInfinity:
      return Infinity(result_sign);

    case SpecialValueHandler::kRHSIsInfinity:
      return Zero(result_sign);
  }

  DCHECK(lhs.IsFinite());
  DCHECK(rhs.IsFinite());

  if (rhs.IsZero())
    return lhs.IsZero() ? Nan() : Infinity(result_sign);

  int result_exponent = lhs.Exponent() - rhs.Exponent();

  if (lhs.IsZero())
    return Decimal(result_sign, result_exponent, 0);

  uint64_t remainder = lhs.data_.Coefficient();
  const uint64_t divisor = rhs.data_.Coefficient();
  uint64_t result = 0;
  for (;;) {
    while (remainder < divisor && result < kMaxCoefficient / 10) {
      remainder *= 10;
      result *= 10;
      --result_exponent;
    }
    if (remainder < divisor)
      break;
    uint64_t quotient = remainder / divisor;
    if (result > kMaxCoefficient - quotient)
      break;
    result += quotient;
    remainder %= divisor;
    if (!remainder)
      break;
  }

  if (remainder > divisor / 2)
    ++result;

  return Decimal(result_sign, result_exponent, result);
}

bool Decimal::operator==(const Decimal& rhs) const {
  return data_ == rhs.data_ || CompareTo(rhs).IsZero();
}

bool Decimal::operator!=(const Decimal& rhs) const {
  if (data_ == rhs.data_)
    return false;
  const Decimal result = CompareTo(rhs);
  if (result.IsNaN())
    return false;
  return !result.IsZero();
}

bool Decimal::operator<(const Decimal& rhs) const {
  const Decimal result = CompareTo(rhs);
  if (result.IsNaN())
    return false;
  return !result.IsZero() && result.IsNegative();
}

bool Decimal::operator<=(const Decimal& rhs) const {
  if (data_ == rhs.data_)
    return true;
  const Decimal result = CompareTo(rhs);
  if (result.IsNaN())
    return false;
  return result.IsZero() || result.IsNegative();
}

bool Decimal::operator>(const Decimal& rhs) const {
  const Decimal result = CompareTo(rhs);
  if (result.IsNaN())
    return false;
  return !result.IsZero() && result.IsPositive();
}

bool Decimal::operator>=(const Decimal& rhs) const {
  if (data_ == rhs.data_)
    return true;
  const Decimal result = CompareTo(rhs);
  if (result.IsNaN())
    return false;
  return result.IsZero() || !result.IsNegative();
}

Decimal Decimal::Abs() const {
  Decimal result(*this);
  result.data_.SetSign(kPositive);
  return result;
}

Decimal::AlignedOperands Decimal::AlignOperands(const Decimal& lhs,
                                                const Decimal& rhs) {
  DCHECK(lhs.IsFinite());
  DCHECK(rhs.IsFinite());

  const int lhs_exponent = lhs.Exponent();
  const int rhs_exponent = rhs.Exponent();
  int exponent = std::min(lhs_exponent, rhs_exponent);
  uint64_t lhs_coefficient = lhs.data_.Coefficient();
  uint64_t rhs_coefficient = rhs.data_.Coefficient();

  if (lhs_exponent > rhs_exponent) {
    const int number_of_lhs_digits = CountDigits(lhs_coefficient);
    if (number_of_lhs_digits) {
      const int lhs_shift_amount = lhs_exponent - rhs_exponent;
      const int overflow = number_of_lhs_digits + lhs_shift_amount - kPrecision;
      if (overflow <= 0) {
        lhs_coefficient = ScaleUp(lhs_coefficient, lhs_shift_amount);
      } else {
        lhs_coefficient = ScaleUp(lhs_coefficient, lhs_shift_amount - overflow);
        rhs_coefficient = ScaleDown(rhs_coefficient, overflow);
        exponent += overflow;
      }
    }

  } else if (lhs_exponent < rhs_exponent) {
    const int number_of_rhs_digits = CountDigits(rhs_coefficient);
    if (number_of_rhs_digits) {
      const int rhs_shift_amount = rhs_exponent - lhs_exponent;
      const int overflow = number_of_rhs_digits + rhs_shift_amount - kPrecision;
      if (overflow <= 0) {
        rhs_coefficient = ScaleUp(rhs_coefficient, rhs_shift_amount);
      } else {
        rhs_coefficient = ScaleUp(rhs_coefficient, rhs_shift_amount - overflow);
        lhs_coefficient = ScaleDown(lhs_coefficient, overflow);
        exponent += overflow;
      }
    }
  }

  AlignedOperands aligned_operands;
  aligned_operands.exponent = exponent;
  aligned_operands.lhs_coefficient = lhs_coefficient;
  aligned_operands.rhs_coefficient = rhs_coefficient;
  return aligned_operands;
}

static bool IsMultiplePowersOfTen(uint64_t coefficient, int n) {
  return !coefficient || !(coefficient % ScaleUp(1, n));
}

// Round toward positive infinity.
Decimal Decimal::Ceil() const {
  if (IsSpecial())
    return *this;

  if (Exponent() >= 0)
    return *this;

  uint64_t result = data_.Coefficient();
  const int number_of_digits = CountDigits(result);
  const int number_of_drop_digits = -Exponent();
  if (number_of_digits <= number_of_drop_digits)
    return IsPositive() ? Decimal(1) : Zero(kPositive);

  result = ScaleDown(result, number_of_drop_digits);
  if (IsPositive() &&
      !IsMultiplePowersOfTen(data_.Coefficient(), number_of_drop_digits))
    ++result;
  return Decimal(GetSign(), 0, result);
}

Decimal Decimal::CompareTo(const Decimal& rhs) const {
  const Decimal result(*this - rhs);
  switch (result.data_.GetFormatClass()) {
    case EncodedData::kClassInfinity:
      return result.IsNegative() ? Decimal(-1) : Decimal(1);

    case EncodedData::kClassNaN:
    case EncodedData::kClassNormal:
      return result;

    case EncodedData::kClassZero:
      return Zero(kPositive);

    default:
      NOTREACHED();
  }
}

// Round toward negative infinity.
Decimal Decimal::Floor() const {
  if (IsSpecial())
    return *this;

  if (Exponent() >= 0)
    return *this;

  uint64_t result = data_.Coefficient();
  const int number_of_digits = CountDigits(result);
  const int number_of_drop_digits = -Exponent();
  if (number_of_digits < number_of_drop_digits)
    return IsPositive() ? Zero(kPositive) : Decimal(-1);

  result = ScaleDown(result, number_of_drop_digits);
  if (IsNegative() &&
      !IsMultiplePowersOfTen(data_.Coefficient(), number_of_drop_digits))
    ++result;
  return Decimal(GetSign(), 0, result);
}

Decimal Decimal::FromDouble(double double_value) {
  if (std::isfinite(double_value))
    return FromString(String::NumberToStringECMAScript(double_value));

  if (std::isinf(double_value))
    return Infinity(double_value < 0 ? kNegative : kPositive);

  return Nan();
}

Decimal Decimal::FromString(const String& str) {
  int exponent = 0;
  Sign exponent_sign = kPositive;
  int number_of_digits = 0;
  int number_of_digits_after_dot = 0;
  int number_of_extra_digits = 0;
  Sign sign = kPositive;

  enum {
    kStateDigit,
    kStateDot,
    kStateDotDigit,
    kStateE,
    kStateEDigit,
    kStateESign,
    kStateSign,
    kStateStart,
    kStateZero,
  } state = kStateStart;

#define HandleCharAndBreak(expected, nextState) \
  if (ch == expected) {                         \
    state = nextState;                          \
    break;                                      \
  }

#define HandleTwoCharsAndBreak(expected1, expected2, nextState) \
  if (ch == expected1 || ch == expected2) {                     \
    state = nextState;                                          \
    break;                                                      \
  }

  uint64_t accumulator = 0;
  for (unsigned index = 0; index < str.length(); ++index) {
    const int ch = str[index];
    switch (state) {
      case kStateDigit:
        if (ch >= '0' && ch <= '9') {
          if (number_of_digits < kPrecision) {
            ++number_of_digits;
            accumulator *= 10;
            accumulator += ch - '0';
          } else {
            ++number_of_extra_digits;
          }
          break;
        }

        HandleCharAndBreak('.', kStateDot);
        HandleTwoCharsAndBreak('E', 'e', kStateE);
        return Nan();

      case kStateDot:
      case kStateDotDigit:
        if (ch >= '0' && ch <= '9') {
          if (number_of_digits < kPrecision) {
            ++number_of_digits;
            ++number_of_digits_after_dot;
            accumulator *= 10;
            accumulator += ch - '0';
          }
          state = kStateDotDigit;
          break;
        }

        HandleTwoCharsAndBreak('E', 'e', kStateE);
        return Nan();

      case kStateE:
        if (ch == '+') {
          exponent_sign = kPositive;
          state = kStateESign;
          break;
        }

        if (ch == '-') {
          exponent_sign = kNegative;
          state = kStateESign;
          break;
        }

        if (ch >= '0' && ch <= '9') {
          exponent = ch - '0';
          state = kStateEDigit;
          break;
        }

        return Nan();

      case kStateEDigit:
        if (ch >= '0' && ch <= '9') {
          exponent *= 10;
          exponent += ch - '0';
          if (exponent > kExponentMax + kPrecision) {
            if (accumulator)
              return exponent_sign == kNegative ? Zero(kPositive)
                                                : Infinity(sign);
            return Zero(sign);
          }
          state = kStateEDigit;
          break;
        }

        return Nan();

      case kStateESign:
        if (ch >= '0' && ch <= '9') {
          exponent = ch - '0';
          state = kStateEDigit;
          break;
        }

        return Nan();

      case kStateSign:
        if (ch >= '1' && ch <= '9') {
          accumulator = ch - '0';
          number_of_digits = 1;
          state = kStateDigit;
          break;
        }

        HandleCharAndBreak('0', kStateZero);
        HandleCharAndBreak('.', kStateDot);
        return Nan();

      case kStateStart:
        if (ch >= '1' && ch <= '9') {
          accumulator = ch - '0';
          number_of_digits = 1;
          state = kStateDigit;
          break;
        }

        if (ch == '-') {
          sign = kNegative;
          state = kStateSign;
          break;
        }

        if (ch == '+') {
          sign = kPositive;
          state = kStateSign;
          break;
        }

        HandleCharAndBreak('0', kStateZero);
        HandleCharAndBreak('.', kStateDot);
        return Nan();

      case kStateZero:
        if (ch == '0')
          break;

        if (ch >= '1' && ch <= '9') {
          accumulator = ch - '0';
          number_of_digits = 1;
          state = kStateDigit;
          break;
        }

        HandleCharAndBreak('.', kStateDot);
        HandleTwoCharsAndBreak('E', 'e', kStateE);
        return Nan();

      default:
        NOTREACHED();
    }
  }

  if (state == kStateZero)
    return Zero(sign);

  if (state == kStateDigit || state == kStateEDigit ||
      state == kStateDotDigit) {
    int result_exponent = exponent * (exponent_sign == kNegative ? -1 : 1) -
                          number_of_digits_after_dot + number_of_extra_digits;
    if (result_exponent < kExponentMin)
      return Zero(kPositive);

    const int overflow = result_exponent - kExponentMax + 1;
    if (overflow > 0) {
      if (overflow + number_of_digits - number_of_digits_after_dot > kPrecision)
        return Infinity(sign);
      accumulator = ScaleUp(accumulator, overflow);
      result_exponent -= overflow;
    }

    return Decimal(sign, result_exponent, accumulator);
  }

  return Nan();
}

Decimal Decimal::Infinity(const Sign sign) {
  return Decimal(EncodedData(sign, EncodedData::kClassInfinity));
}

Decimal Decimal::Nan() {
  return Decimal(EncodedData(kPositive, EncodedData::kClassNaN));
}

Decimal Decimal::Remainder(const Decimal& rhs) const {
  const Decimal quotient = *this / rhs;
  return quotient.IsSpecial()
             ? quotient
             : *this - (quotient.IsNegative() ? quotient.Ceil()
                                              : quotient.Floor()) *
                           rhs;
}

Decimal Decimal::Round() const {
  if (IsSpecial())
    return *this;

  if (Exponent() >= 0)
    return *this;

  uint64_t result = data_.Coefficient();
  const int number_of_digits = CountDigits(result);
  const int number_of_drop_digits = -Exponent();
  if (number_of_digits < number_of_drop_digits)
    return Zero(kPositive);

  result = ScaleDown(result, number_of_drop_digits - 1);
  if (result % 10 >= 5)
    result += 10;
  result /= 10;
  return Decimal(GetSign(), 0, result);
}

double Decimal::ToDouble() const {
  if (IsFinite()) {
    bool valid;
    const double double_value = ToString().ToDouble(&valid);
    return valid ? double_value : std::numeric_limits<double>::quiet_NaN();
  }

  if (IsInfinity())
    return IsNegative() ? -std::numeric_limits<double>::infinity()
                        : std::numeric_limits<double>::infinity();

  return std::numeric_limits<double>::quiet_NaN();
}

String Decimal::ToString() const {
  switch (data_.GetFormatClass()) {
    case EncodedData::kClassInfinity:
      return GetSign() ? "-Infinity" : "Infinity";

    case EncodedData::kClassNaN:
      return "NaN";

    case EncodedData::kClassNormal:
    case EncodedData::kClassZero:
      break;

    default:
      NOTREACHED();
  }

  StringBuilder builder;
  if (GetSign())
    builder.Append('-');

  int original_exponent = Exponent();
  uint64_t coefficient = data_.Coefficient();

  if (original_exponent < 0) {
    const int kMaxDigits = DBL_DIG;
    uint64_t last_digit = 0;
    while (CountDigits(coefficient) > kMaxDigits) {
      last_digit = coefficient % 10;
      coefficient /= 10;
      ++original_exponent;
    }

    if (last_digit >= 5)
      ++coefficient;

    while (original_exponent < 0 && coefficient && !(coefficient % 10)) {
      coefficient /= 10;
      ++original_exponent;
    }
  }

  const String digits = String::Number(coefficient);
  int coefficient_length = static_cast<int>(digits.length());
  const int adjusted_exponent = original_exponent + coefficient_length - 1;
  if (original_exponent <= 0 && adjusted_exponent >= -6) {
    if (!original_exponent) {
      builder.Append(digits);
      return builder.ToString();
    }

    if (adjusted_exponent >= 0) {
      for (int i = 0; i < coefficient_length; ++i) {
        builder.Append(digits[i]);
        if (i == adjusted_exponent)
          builder.Append('.');
      }
      return builder.ToString();
    }

    builder.Append("0.");
    for (int i = adjusted_exponent + 1; i < 0; ++i)
      builder.Append('0');

    builder.Append(digits);

  } else {
    builder.Append(digits[0]);
    while (coefficient_length >= 2 && digits[coefficient_length - 1] == '0')
      --coefficient_length;
    if (coefficient_length >= 2) {
      builder.Append('.');
      for (int i = 1; i < coefficient_length; ++i)
        builder.Append(digits[i]);
    }

    if (adjusted_exponent) {
      builder.Append(adjusted_exponent < 0 ? "e" : "e+");
      builder.AppendNumber(adjusted_exponent);
    }
  }
  return builder.ToString();
}

Decimal Decimal::Zero(Sign sign) {
  return Decimal(EncodedData(sign, EncodedData::kClassZero));
}

std::ostream& operator<<(std::ostream& ostream, const Decimal& decimal) {
  Decimal::EncodedData data = decimal.Value();
  return ostream << "encode(" << String::Number(data.Coefficient()).Ascii()
                 << ", " << String::Number(data.Exponent()).Ascii() << ", "
                 << (data.GetSign() == Decimal::kNegative ? "Negative"
                                                          : "Positive")
                 << ")=" << decimal.ToString().Ascii();
}

}  // namespace blink
```
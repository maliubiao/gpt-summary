Response:
The user wants a summary of the functionalities present in the provided C++ source code file `image_capture_test.cc`.

Here's a breakdown of the thought process to achieve the desired summary:

1. **Identify the Core Purpose:** The file name `image_capture_test.cc` strongly suggests it's a test file for the `ImageCapture` API. This is confirmed by the inclusion of `#include "third_party/blink/renderer/modules/imagecapture/image_capture.h"`.

2. **Analyze Includes:**  Examine the included headers to understand the dependencies and what functionalities are being tested.
    * Standard testing frameworks (`testing/gmock`, `testing/gtest`) confirm it's a test file.
    * V8 bindings (`renderer/bindings/core/v8`, `renderer/bindings/modules/v8`) indicate interaction with JavaScript.
    * Media stream related headers (`renderer/modules/mediastream`) suggest testing the interaction of `ImageCapture` with video streams.
    * Core Blink headers (`renderer/core/frame`, `renderer/core/imagebitmap`, `renderer/core/page`) point to the integration within the Blink rendering engine.

3. **Examine Namespaces and Helper Structures:**
    * The code is within the `blink` namespace.
    * Notice the `CaptureErrorFunction` class: This likely tests how errors from `ImageCapture` are handled in the JavaScript context.
    * The `ConstrainWithDictionaryTraits` and related structures and functions (`CreateDictionaryMemberValue`, `ConstrainWith...Creator`) are related to testing the constraint mechanisms for `ImageCapture` settings. They appear to be setting up different ways to define constraints (bare values, dictionaries with `exact`, `ideal`, `min`, `max`).
    * `MediaSettingsRange` and `Point2D` creation functions are for setting up test data.

4. **Analyze Test Fixtures:**  The `ImageCaptureTest` class sets up the basic environment for testing `ImageCapture`. It creates mock objects for media stream components and tracks, allowing for controlled testing. The `SetupTrackMocks` function configures these mocks to simulate a video track.

5. **Identify Key Test Functions and Logic:**
    * The `CheckExactValues`, `CheckMaxValues`, `CheckMinValues`, and `CheckNoValues` functions are crucial. They verify the `PhotoSettings` generated by `ImageCapture` based on different constraint scenarios. This directly relates to the API's functionality of applying user-specified constraints.
    * `PopulateConstraintSet` is used to create various constraint sets for testing.

6. **Connect to JavaScript, HTML, CSS:**
    * The `ImageCapture` API is a JavaScript API. The inclusion of V8 binding headers and the `CaptureErrorFunction` directly demonstrate the connection.
    * While the code itself doesn't *directly* manipulate HTML or CSS, the `ImageCapture` API is used in web pages, which are built using HTML, CSS, and JavaScript. The API enables capturing images from a video stream accessed through `<video>` elements (HTML) and controlled by JavaScript. CSS might indirectly affect the video stream's appearance, though the API primarily deals with capturing the raw image data.

7. **Infer User/Programming Errors:** Based on the constraint testing, potential errors include:
    * Providing invalid constraint values (e.g., `min` greater than `max`).
    * Trying to set constraints on properties that the video source doesn't support.
    * Incorrectly handling promises returned by `ImageCapture` methods.

8. **Trace User Operations:** Think about how a user would trigger this code:
    1. A web page using JavaScript would request access to the user's camera via `navigator.mediaDevices.getUserMedia()`.
    2. The JavaScript would get a `MediaStreamTrack` from the video stream.
    3. An `ImageCapture` object would be created from the `MediaStreamTrack`.
    4. The JavaScript would call methods on the `ImageCapture` object, such as `getPhotoCapabilities()` or `takePhoto()`, potentially with constraints. This is where the tested code is invoked within the Blink engine.

9. **Synthesize the Summary:** Combine the above observations into a concise summary covering the core functionality, its relationship to web technologies, and potential errors.

10. **Structure the Output:** Organize the summary into the requested categories: functionality, relationship to JavaScript/HTML/CSS, logical reasoning (with assumptions and outputs), user/programming errors, user operation steps, and finally, a concise overall summary for part 1.
```cpp
// Copyright 2023 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifdef UNSAFE_BUFFERS_BUILD
// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
#pragma allow_unsafe_buffers
#endif

#include "third_party/blink/renderer/modules/imagecapture/image_capture.h"

#include "base/time/time.h"
#include "testing/gmock/include/gmock/gmock.h"
#include "testing/gtest/include/gtest/gtest.h"
#include "third_party/blink/public/web/web_heap.h"
#include "third_party/blink/renderer/bindings/core/v8/script_function.h"
#include "third_party/blink/renderer/bindings/core/v8/script_promise_resolver.h"
#include "third_party/blink/renderer/bindings/core/v8/script_promise_tester.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_binding_for_testing.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_union_string_stringsequence.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_constrain_boolean_parameters.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_constrain_dom_string_parameters.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_constrain_double_range.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_constrain_point_2d_parameters.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_media_settings_range.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_point_2d.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_union_boolean_constrainbooleanparameters.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_union_boolean_constraindoublerange_double.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_union_constraindomstringparameters_string_stringsequence.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_union_constraindoublerange_double.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_union_constrainpoint2dparameters_point2dsequence.h"
#include "third_party/blink/renderer/core/frame/local_frame.h"
#include "third_party/blink/renderer/core/imagebitmap/image_bitmap.h"
#include "third_party/blink/renderer/core/page/page.h"
#include "third_party/blink/renderer/modules/imagecapture/image_capture.h"
#include "third_party/blink/renderer/modules/mediastream/media_stream_video_capturer_source.h"
#include "third_party/blink/renderer/modules/mediastream/media_stream_video_track.h"
#include "third_party/blink/renderer/modules/mediastream/mock_media_stream_track.h"
#include "third_party/blink/renderer/modules/mediastream/mock_video_capturer_source.h"
#include "third_party/blink/renderer/platform/bindings/script_state.h"
#include "third_party/blink/renderer/platform/testing/io_task_runner_testing_platform_support.h"
#include "third_party/blink/renderer/platform/testing/task_environment.h"

namespace blink {

namespace {

using ExpectHasExposureModeAndFocusMode =
    base::StrongAlias<class ExpectHasExposureModeAndFocusModeTag, bool>;
using ExpectHasPanTiltZoom =
    base::StrongAlias<class ExpectHasPanTiltZoomTag, bool>;
using PopulatePanTiltZoom =
    base::StrongAlias<class PopulatePanTiltZoomZoomTag, bool>;

using testing::_;
using testing::Invoke;
using testing::NiceMock;
using testing::Return;

constexpr double kExposureCompensationDelta = 1;
constexpr double kExposureTimeDelta = 2;
constexpr double kColorTemperatureDelta = 3;
constexpr double kIsoDelta = 4;
constexpr double kBrightnessDelta = 5;
constexpr double kContrastDelta = 6;
constexpr double kSaturationDelta = 7;
constexpr double kSharpnessDelta = 8;
constexpr double kFocusDistanceDelta = 9;
constexpr double kPanDelta = 10;
constexpr double kTiltDelta = 11;
constexpr double kZoomDelta = 12;

// CaptureErrorFunction implements a javascript function which captures
// name, message and constraint of the exception passed as its argument.
class CaptureErrorFunction final
    : public ThenCallable<IDLAny, CaptureErrorFunction> {
 public:
  CaptureErrorFunction() = default;

  bool WasCalled() const { return was_called_; }
  const String& Name() const { return name_; }
  const String& Message() const { return message_; }
  const String& Constraint() const { return constraint_; }

  void React(ScriptState* script_state, ScriptValue value) {
    was_called_ = true;

    v8::Isolate* isolate = script_state->GetIsolate();
    v8::Local<v8::Context> context = script_state->GetContext();

    v8::Local<v8::Object> error_object =
        value.V8Value()->ToObject(context).ToLocalChecked();

    v8::Local<v8::Value> name =
        error_object->Get(context, V8String(isolate, "name")).ToLocalChecked();
    name_ = ToCoreString(isolate, name->ToString(context).ToLocalChecked());
    v8::Local<v8::Value> message =
        error_object->Get(context, V8String(isolate, "message"))
            .ToLocalChecked();
    message_ =
        ToCoreString(isolate, message->ToString(context).ToLocalChecked());
    v8::Local<v8::Value> constraint =
        error_object->Get(context, V8String(isolate, "constraint"))
            .ToLocalChecked();
    constraint_ =
        ToCoreString(isolate, constraint->ToString(context).ToLocalChecked());
  }

 private:
  bool was_called_ = false;
  String name_;
  String message_;
  String constraint_;
};

// These traits and type aliases simplify mapping from bare value types (bool,
// double, sequence, string) to constrain value dictionary types.
template <typename T>
struct ConstrainWithDictionaryTraits;

template <>
struct ConstrainWithDictionaryTraits<bool> {
  using DictionaryType = ConstrainBooleanParameters;
};

template <>
struct ConstrainWithDictionaryTraits<double> {
  using DictionaryType = ConstrainDoubleRange;
};

template <>
struct ConstrainWithDictionaryTraits<HeapVector<Member<Point2D>>> {
  using DictionaryType = ConstrainPoint2DParameters;
};

template <>
struct ConstrainWithDictionaryTraits<String> {
  using DictionaryType = ConstrainDOMStringParameters;
};

template <>
struct ConstrainWithDictionaryTraits<Vector<String>> {
  using DictionaryType = ConstrainDOMStringParameters;
};

template <typename T>
using ConstrainWithDictionaryType =
    ConstrainWithDictionaryTraits<T>::DictionaryType;

// The `ConstrainDOMStringParameters` dictionary type has `exact` and `ideal`
// members of type `(DOMString or sequence<DOMString>)`.
// https://w3c.github.io/mediacapture-main/#dom-constraindomstringparameters
V8UnionStringOrStringSequence* CreateDictionaryMemberValue(
    const String& value) {
  return MakeGarbageCollected<V8UnionStringOrStringSequence>(value);
}

V8UnionStringOrStringSequence* CreateDictionaryMemberValue(
    const Vector<String>& value) {
  return MakeGarbageCollected<V8UnionStringOrStringSequence>(value);
}

// All the other constrain value dictionary types (ConstrainBooleanParameters,
// ConstrainDoubleRange and ConstrainPoint2DParameters) have `exact` and
// `ideal` members of non-union types.
// https://w3c.github.io/mediacapture-main/#dom-constrainbooleanparameters
// https://w3c.github.io/mediacapture-main/#dom-constraindoublerange
// https://w3c.github.io/mediacapture-main/#dom-constrainpoint2dparameters
template <typename T>
const T& CreateDictionaryMemberValue(const T& value) {
  return value;
}

// This creator creates bare value (bool, double, sequence, string)
// constraints.
struct ConstrainWithBareValueCreator {
  template <typename T>
  static const T& Create(const T& bare_value) {
    return bare_value;
  }
};

// This creator creates constrain value dictionary constraints without members.
struct ConstrainWithEmptyDictionaryCreator {
  template <typename T>
  static auto* Create(const T&) {
    return ConstrainWithDictionaryType<T>::Create();
  }
};

// This creator creates constrain value dictionary constraints with `exact`
// members.
struct ConstrainWithExactDictionaryCreator {
  template <typename T>
  static auto* Create(const T& exact) {
    auto* constrain_value = ConstrainWithDictionaryType<T>::Create();
    constrain_value->setExact(CreateDictionaryMemberValue(exact));
    return constrain_value;
  }
};

// This creator creates constrain value dictionary constraints with `ideal`
// members.
struct ConstrainWithIdealDictionaryCreator {
  template <typename T>
  static auto* Create(const T& ideal) {
    auto* constrain_value = ConstrainWithDictionaryType<T>::Create();
    constrain_value->setIdeal(CreateDictionaryMemberValue(ideal));
    return constrain_value;
  }
};

// This creator creates constrain value dictionary constraints with `max`
// members.
struct ConstrainWithMaxDictionaryCreator {
  template <typename T>
  static auto* Create(const T& max) {
    auto* constrain_value = ConstrainWithDictionaryType<T>::Create();
    constrain_value->setMax(max);
    return constrain_value;
  }
};

// This creator creates constrain value dictionary constraints with `max`
// members for numeric (double) values and empty constrain value dictionary
// constraints for non-numeric (bool, sequence, string) values.
struct ConstrainWithMaxOrEmptyDictionaryCreator {
  static auto* Create(double max) {
    return ConstrainWithMaxDictionaryCreator::Create(max);
  }

  template <typename T>
  static auto* Create(const T&) {
    return ConstrainWithDictionaryType<T>::Create();
  }
};

// This creator creates constrain value dictionary constraints with `min`
// members.
struct ConstrainWithMinDictionaryCreator {
  template <typename T>
  static auto* Create(const T& min) {
    auto* constrain_value = ConstrainWithDictionaryType<T>::Create();
    constrain_value->setMin(min);
    return constrain_value;
  }
};

// This creator creates constrain value dictionary constraints with `min`
// members for numeric (double) values and empty constrain value dictionary
// constraints for non-numeric (bool, sequence, string) values.
struct ConstrainWithMinOrEmptyDictionaryCreator {
  static auto* Create(double min) {
    return ConstrainWithMinDictionaryCreator::Create(min);
  }

  template <typename T>
  static auto* Create(const T&) {
    return ConstrainWithDictionaryType<T>::Create();
  }
};

MediaSettingsRange* CreateMediaSettingsRange(double min,
                                             double max,
                                             double step) {
  auto* range = MediaSettingsRange::Create();
  range->setMin(min);
  range->setMax(max);
  range->setStep(step);
  return range;
}

MediaSettingsRange* CreateMediaSettingsRange(const char (&str)[3]) {
  int min = (static_cast<int>(str[0]) << 16) + (static_cast<int>(str[1]) << 8);
  return CreateMediaSettingsRange(min, min + 16, 8);
}

Point2D* CreatePoint2D(double x, double y) {
  auto* point = Point2D::Create();
  point->setX(x);
  point->setY(y);
  return point;
}

double RangeMean(const MediaSettingsRange* range) {
  return (range->min() + range->max()) / 2;
}

void CheckExactValues(
    const media::mojom::blink::PhotoSettingsPtr& settings,
    const MediaTrackCapabilities* all_capabilities,
    ExpectHasPanTiltZoom expect_has_pan_tilt_zoom = ExpectHasPanTiltZoom(true),
    ExpectHasExposureModeAndFocusMode expect_has_exposure_mode_and_focus_mode =
        ExpectHasExposureModeAndFocusMode(true)) {
  EXPECT_TRUE(settings->has_white_balance_mode);
  EXPECT_EQ(settings->white_balance_mode,
            media::mojom::blink::MeteringMode::CONTINUOUS);
  if (expect_has_exposure_mode_and_focus_mode) {
    EXPECT_TRUE(settings->has_exposure_mode);
    EXPECT_EQ(settings->exposure_mode,
              media::mojom::blink::MeteringMode::MANUAL);
    EXPECT_TRUE(settings->has_focus_mode);
    EXPECT_EQ(settings->focus_mode, media::mojom::blink::MeteringMode::NONE);
  } else {
    EXPECT_FALSE(settings->has_exposure_mode);
    EXPECT_FALSE(settings->has_focus_mode);
  }
  ASSERT_EQ(settings->points_of_interest.size(), 3u);
  EXPECT_EQ(settings->points_of_interest[0]->x, 0.0);
  EXPECT_EQ(settings->points_of_interest[0]->y, 0.0);
  EXPECT_EQ(settings->points_of_interest[1]->x, 0.25);
  EXPECT_EQ(settings->points_of_interest[1]->y, 0.75);
  EXPECT_EQ(settings->points_of_interest[2]->x, 1.0);
  EXPECT_EQ(settings->points_of_interest[2]->y, 1.0);
  EXPECT_TRUE(settings->has_exposure_compensation);
  EXPECT_EQ(settings->exposure_compensation,
            all_capabilities->exposureCompensation()->min() +
                kExposureCompensationDelta);
  EXPECT_TRUE(settings->has_exposure_time);
  EXPECT_EQ(settings->exposure_time,
            all_capabilities->exposureTime()->min() + kExposureTimeDelta);
  EXPECT_TRUE(settings->has_color_temperature);
  EXPECT_EQ(
      settings->color_temperature,
      all_capabilities->colorTemperature()->min() + kColorTemperatureDelta);
  EXPECT_TRUE(settings->has_iso);
  EXPECT_EQ(settings->iso, all_capabilities->iso()->min() + kIsoDelta);
  EXPECT_TRUE(settings->has_brightness);
  EXPECT_EQ(settings->brightness,
            all_capabilities->brightness()->min() + kBrightnessDelta);
  EXPECT_TRUE(settings->has_contrast);
  EXPECT_EQ(settings->contrast,
            all_capabilities->contrast()->min() + kContrastDelta);
  EXPECT_TRUE(settings->has_saturation);
  EXPECT_EQ(settings->saturation,
            all_capabilities->saturation()->min() + kSaturationDelta);
  EXPECT_TRUE(settings->has_sharpness);
  EXPECT_EQ(settings->sharpness,
            all_capabilities->sharpness()->min() + kSharpnessDelta);
  EXPECT_TRUE(settings->has_focus_distance);
  EXPECT_EQ(settings->focus_distance,
            all_capabilities->focusDistance()->min() + kFocusDistanceDelta);
  if (expect_has_pan_tilt_zoom) {
    EXPECT_TRUE(settings->has_pan);
    EXPECT_EQ(settings->pan, all_capabilities->pan()->min() + kPanDelta);
    EXPECT_TRUE(settings->has_tilt);
    EXPECT_EQ(settings->tilt, all_capabilities->tilt()->min() + kTiltDelta);
    EXPECT_TRUE(settings->has_zoom);
    EXPECT_EQ(settings->zoom, all_capabilities->zoom()->min() + kZoomDelta);
  } else {
    EXPECT_FALSE(settings->has_pan);
    EXPECT_FALSE(settings->has_tilt);
    EXPECT_FALSE(settings->has_zoom);
  }
  EXPECT_TRUE(settings->has_torch);
  EXPECT_EQ(settings->torch, true);
  EXPECT_TRUE(settings->has_background_blur_mode);
  EXPECT_EQ(settings->background_blur_mode,
            media::mojom::blink::BackgroundBlurMode::BLUR);
  EXPECT_TRUE(settings->eye_gaze_correction_mode.has_value());
  EXPECT_EQ(settings->eye_gaze_correction_mode.value(),
            media::mojom::blink::EyeGazeCorrectionMode::OFF);
  EXPECT_TRUE(settings->has_face_framing_mode);
  EXPECT_EQ(settings->face_framing_mode,
            media::mojom::blink::MeteringMode::CONTINUOUS);
  EXPECT_TRUE(settings->background_segmentation_mask_state.has_value());
  EXPECT_FALSE(settings->background_segmentation_mask_state.value());
}

void CheckMaxValues(const media::mojom::blink::PhotoSettingsPtr& settings,
                    const MediaTrackCapabilities* all_capabilities,
                    const MediaTrackSettings* default_settings,
                    ExpectHasPanTiltZoom expect_has_pan_tilt_zoom =
                        ExpectHasPanTiltZoom(true)) {
  EXPECT_FALSE(settings->has_white_balance_mode);
  EXPECT_FALSE(settings->has_exposure_mode);
  EXPECT_FALSE(settings->has_focus_mode);
  EXPECT_EQ(settings->points_of_interest.size(), 0u);
  EXPECT_TRUE(settings->has_exposure_compensation);
  EXPECT_EQ(settings->exposure_compensation,
            std::min(all_capabilities->exposureCompensation()->min() +
                         kExposureCompensationDelta,
                     default_settings->exposureCompensation()));
  EXPECT_TRUE(settings->has_exposure_time);
  EXPECT_EQ(
      settings->exposure_time,
      std::min(all_capabilities->exposureTime()->min() + kExposureTimeDelta,
               default_settings->exposureTime()));
  EXPECT_TRUE(settings->has_color_temperature);
  EXPECT_EQ(settings->color_temperature,
            std::min(all_capabilities->colorTemperature()->min() +
                         kColorTemperatureDelta,
                     default_settings->colorTemperature()));
  EXPECT_TRUE(settings->has_iso);
  EXPECT_EQ(settings->iso, std::min(all_capabilities->iso()->min() + kIsoDelta,
                                    default_settings->iso()));
  EXPECT_TRUE(settings->has_brightness);
  EXPECT_EQ(settings->brightness,
            std::min(all_capabilities->brightness()->min() + kBrightnessDelta,
                     default_settings->brightness()));
  EXPECT_TRUE(settings->has_contrast);
  EXPECT_EQ(settings->contrast,
            std::min(all_capabilities->contrast()->min() + kContrastDelta,
                     default_settings->contrast()));
  EXPECT_TRUE(settings->has_saturation);
  EXPECT_EQ(settings->saturation,
            std::min(all_capabilities->saturation()->min() + kSaturationDelta,
                     default_settings->saturation()));
  EXPECT_TRUE(settings->has_sharpness);
  EXPECT_EQ(settings->sharpness,
            std::min(all_capabilities->sharpness()->min() + kSharpnessDelta,
                     default_settings->sharpness()));
  EXPECT_TRUE(settings->has_focus_distance);
  EXPECT_EQ(
      settings->focus_distance,
      std::min(all_capabilities->focusDistance()->min() + kFocusDistanceDelta,
               default_settings->focusDistance()));
  if (expect_has_pan_tilt_zoom) {
    EXPECT_TRUE(settings->has_pan);
    EXPECT_EQ(settings->pan,
              std::min(all_capabilities->pan()->min() + kPanDelta,
                       default_settings->pan()));
    EXPECT_TRUE(settings->has_tilt);
    EXPECT_EQ(settings->tilt,
              std::min(all_capabilities->tilt()->min() + kTiltDelta,
                       default_settings->tilt()));
    EXPECT_TRUE(settings->has_zoom);
    EXPECT_EQ(settings->zoom,
              std::min(all_capabilities->zoom()->min() + kZoomDelta,
                       default_settings->zoom()));
  } else {
    EXPECT_FALSE(settings->has_pan);
    EXPECT_FALSE(settings->has_tilt);
    EXPECT_FALSE(settings->has_zoom);
  }
  EXPECT_FALSE(settings->has_torch);
  EXPECT_FALSE(settings->has_background_blur_mode);
  EXPECT_FALSE(settings->eye_gaze_correction_mode.has_value());
  EXPECT_FALSE(settings->has_face_framing_mode);
  EXPECT_FALSE(settings->background_segmentation_mask_state.has_value());
}

void CheckMinValues(const media::mojom::blink::PhotoSettingsPtr& settings,
                    const MediaTrackCapabilities* all_capabilities,
                    const MediaTrackSettings* default_settings,
                    ExpectHasPanTiltZoom expect_has_pan_tilt_zoom =
                        ExpectHasPanTiltZoom(true)) {
  EXPECT_FALSE(settings->has_white_balance_mode);
  EXPECT_FALSE(settings->has_exposure_mode);
  EXPECT_FALSE(settings->has_focus_mode);
  EXPECT_EQ(settings->points_of_interest.size(), 0u);
  EXPECT_TRUE(settings->has_exposure_compensation);
  EXPECT_EQ(settings->exposure_compensation,
            std::max(all_capabilities->exposureCompensation()->min() +
                         kExposureCompensationDelta,
                     default_settings->exposureCompensation()));
  EXPECT_TRUE(settings->has_exposure_time);
  EXPECT_EQ(
      settings->exposure_time,
      std::max(all_capabilities->exposureTime()->min() + kExposureTimeDelta,
               default_settings->exposureTime()));
  EXPECT_TRUE(settings->has_color_temperature);
  EXPECT_EQ(settings->color_temperature,
            std::max(all_capabilities->colorTemperature()->min() +
                         kColorTemperatureDelta,
                     default_settings->colorTemperature()));
  EXPECT_TRUE(settings->has_iso);
  EXPECT_EQ(settings->iso, std::max(all_capabilities->iso()->min() + kIsoDelta,
                                    default_settings->iso()));
  EXPECT_TRUE(settings->has_brightness);
  EXPECT_EQ(settings->brightness,
            std::max(all_capabilities->brightness()->min() + kBrightnessDelta,
                     default_settings->brightness()));
  EXPECT_TRUE(settings->has_contrast);
  EXPECT_EQ(settings->contrast,
            std::max(all_capabilities->contrast()->min() + kContrastDelta,
                     default_settings->contrast()));
  EXPECT_TRUE(settings->has_saturation);
  EXPECT_EQ(settings->saturation,
            std::max(all_capabilities->saturation()->min() + kSaturationDelta,
                     default_settings->saturation()));
  EXPECT_TRUE(settings->has_sharpness);
  EXPECT_EQ(settings->sharpness,
            std::max(all_capabilities->sharpness()->min() + kSharpnessDelta,
                     default_settings->sharpness()));
  EXPECT_TRUE(settings->has_focus_distance);
  EXPECT_EQ(
      settings->focus_distance,
      std::max(all_capabilities->focusDistance()->min() + kFocusDistanceDelta,
               default_settings->focusDistance()));
  if (expect_has_pan_tilt_zoom) {
    EXPECT_TRUE(settings->has_pan);
    EXPECT_EQ(settings->pan,
              std::max(all_capabilities->pan()->min() + kPanDelta,
                       default_settings->pan()));
    EXPECT_TRUE(settings->has_tilt);
    EXPECT_EQ(settings->tilt,
              std::max(all_capabilities->tilt()->min() + kTiltDelta,
                       default_settings->tilt()));
    EXPECT_TRUE(settings->has_zoom);
    EXPECT_EQ(settings->zoom,
              std::max(all_capabilities->zoom()->min() + kZoomDelta,
                       default_settings->zoom()));
  } else {
    EXPECT_FALSE(settings->has_pan);
    EXPECT_FALSE(settings->has_tilt);
    EXPECT_FALSE(settings->has_zoom);
  }
  EXPECT_FALSE(settings->has_torch);
  EXPECT_FALSE(settings->has_background_blur_mode);
  EXPECT_FALSE(settings->eye_gaze_correction_mode.has_value());
  EXPECT_FALSE(settings->has_face_framing_mode);
  EXPECT_FALSE(settings->background_segmentation_mask_state.has_value());
}

void CheckNoValues(const media::mojom::blink::PhotoSettingsPtr& settings,
                   size_t expected_points_of_interest_size = 0u) {
  EXPECT_FALSE(settings->has_white_balance_mode);
  EXPECT_FALSE(settings->has_exposure_mode);
  EXPECT_FALSE(settings->has_focus_mode);
  EXPECT_EQ(settings->points_of_interest.size(),
            expected_points_of_interest_size);
  EXPECT_FALSE(settings->has_exposure_compensation);
  EXPECT_FALSE(settings->has_exposure_time);
  EXPECT_FALSE(settings->has_color_temperature);
  EXPECT_FALSE(settings->has_iso);
  EXPECT_FALSE(settings->has_brightness);
  EXPECT_FALSE(settings->has_contrast);
  EXPECT_FALSE(settings->has_saturation);
  EXPECT_FALSE(settings->has_sharpness);
  EXPECT_FALSE(settings->has_focus_distance);
  EXPECT_FALSE(settings->has_pan);
  EXPECT_FALSE(settings->has_tilt);
  EXPECT_FALSE(settings->has_zoom);
  EXPECT_FALSE(settings->has_torch);
  EXPECT_FALSE(settings->has_background_blur_mode);
  EXPECT_FALSE(settings->eye_gaze_correction_mode.has_value());
  EXPECT_FALSE(settings->has_face_framing_mode);
  EXPECT_FALSE(settings->background_segmentation_mask_state.has_value());
}

template <typename ConstraintCreator>
void PopulateConstraintSet(
    MediaTrackConstraintSet* constraint_set,
    const MediaTrackCapabilities* all_capabilities,
    PopulatePanTiltZoom populate_pan_tilt_zoom = PopulatePanTiltZoom(true)) {
  constraint_set->setWhiteBalanceMode(
      MakeGarbageCollected<
          V8UnionConstrainDOMStringParametersOrStringOrStringSequence>(
          ConstraintCreator::Create(all_capabilities->whiteBalanceMode()[0])));
  constraint_set->setExposureMode(
      MakeGarbageCollected<
          V8UnionConstrainDOMStringParametersOrStringOrStringSequence>(
          ConstraintCreator::Create(all_capabilities->exposureMode())));
  constraint_set->setFocusMode(
      MakeGarbageCollected<
          V8UnionConstrainDOMStringParametersOrStringOrStringSequence>(
          ConstraintCreator::Create(all_capabilities->focusMode())));
  HeapVector<Member<Point2D>> points_of_interest = {CreatePoint2D(-0.75, -0.25),
                                                    CreatePoint2D(0.25, 0.75),
                                                    CreatePoint2D(1.25, 1.75)};
  constraint_set->setPointsOfInterest(
      MakeGarbageCollected<V8UnionConstrainPoint2DParametersOrPoint2DSequence>(
          ConstraintCreator::Create(points_of_interest)));
  constraint_set->setExposureCompensation(
      MakeGarbageCollected<V8UnionConstrainDoubleRangeOrDouble>(
          ConstraintCreator::Create(
              all_capabilities->exposureCompensation()->min() +
              kExposureCompensationDelta)));
  constraint_set->setExposureTime(
      MakeGarbageCollected<V8UnionConstrainDoubleRangeOrDouble>(
          ConstraintCreator::Create(all_capabilities->exposureTime()->min() +
                                    kExposureTimeDelta)));
  constraint_set->setColorTemperature(
      MakeGarbageCollected<V8UnionConstrainDoubleRangeOrDouble>(
          ConstraintCreator::Create(
              all_capabilities->colorTemperature()->min() +
              kColorTemperatureDelta)));
  constraint_set->setIso(
      MakeGarbageCollected<V8UnionConstrainDoubleRangeOrDouble>(
          ConstraintCreator::Create(all_capabilities->iso()->min() +
                                    kIsoDelta)));
  constraint_set->setBrightness(
      MakeGarbageCollected<V8UnionConstrainDoubleRangeOrDouble>(
          ConstraintCreator::Create(all_capabilities->brightness()->min() +
                                    kBrightnessDelta)));
  constraint_set->setContrast(
      MakeGarbageCollected<V8UnionConstrainDoubleRangeOrDouble>(
          ConstraintCreator::Create(all_capabilities->contrast()->min() +
                                    kContrastDelta)));
  constraint_set->setSaturation(
      MakeGarbageCollected<V8UnionConstrainDoubleRangeOrDouble>(
          ConstraintCreator::Create(all_capabilities->saturation()->min() +
                                    kSaturationDelta)));
  constraint_set->setSharpness(
      MakeGarbageCollected<V8UnionConstrainDoubleRangeOrDouble>(
          ConstraintCreator::Create(all_capabilities->sharpness()->min() +
                                    kSharpnessDelta)));
  constraint_set->setFocusDistance(
      MakeGarbageCollected<V8UnionConstrainDoubleRangeOrDouble>(
          ConstraintCreator::Create(all_capabilities->focusDistance()->min() +
                                    kFocusDistanceDelta
### 提示词
```
这是目录为blink/renderer/modules/imagecapture/image_capture_test.cc的chromium blink引擎源代码文件， 请列举一下它的功能, 
如果它与javascript, html, css的功能有关系，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索。
这是第1部分，共3部分，请归纳一下它的功能
```

### 源代码
```cpp
// Copyright 2023 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifdef UNSAFE_BUFFERS_BUILD
// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
#pragma allow_unsafe_buffers
#endif

#include "third_party/blink/renderer/modules/imagecapture/image_capture.h"

#include "base/time/time.h"
#include "testing/gmock/include/gmock/gmock.h"
#include "testing/gtest/include/gtest/gtest.h"
#include "third_party/blink/public/web/web_heap.h"
#include "third_party/blink/renderer/bindings/core/v8/script_function.h"
#include "third_party/blink/renderer/bindings/core/v8/script_promise_resolver.h"
#include "third_party/blink/renderer/bindings/core/v8/script_promise_tester.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_binding_for_testing.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_union_string_stringsequence.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_constrain_boolean_parameters.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_constrain_dom_string_parameters.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_constrain_double_range.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_constrain_point_2d_parameters.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_media_settings_range.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_point_2d.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_union_boolean_constrainbooleanparameters.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_union_boolean_constraindoublerange_double.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_union_constraindomstringparameters_string_stringsequence.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_union_constraindoublerange_double.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_union_constrainpoint2dparameters_point2dsequence.h"
#include "third_party/blink/renderer/core/frame/local_frame.h"
#include "third_party/blink/renderer/core/imagebitmap/image_bitmap.h"
#include "third_party/blink/renderer/core/page/page.h"
#include "third_party/blink/renderer/modules/imagecapture/image_capture.h"
#include "third_party/blink/renderer/modules/mediastream/media_stream_video_capturer_source.h"
#include "third_party/blink/renderer/modules/mediastream/media_stream_video_track.h"
#include "third_party/blink/renderer/modules/mediastream/mock_media_stream_track.h"
#include "third_party/blink/renderer/modules/mediastream/mock_video_capturer_source.h"
#include "third_party/blink/renderer/platform/bindings/script_state.h"
#include "third_party/blink/renderer/platform/testing/io_task_runner_testing_platform_support.h"
#include "third_party/blink/renderer/platform/testing/task_environment.h"

namespace blink {

namespace {

using ExpectHasExposureModeAndFocusMode =
    base::StrongAlias<class ExpectHasExposureModeAndFocusModeTag, bool>;
using ExpectHasPanTiltZoom =
    base::StrongAlias<class ExpectHasPanTiltZoomTag, bool>;
using PopulatePanTiltZoom =
    base::StrongAlias<class PopulatePanTiltZoomZoomTag, bool>;

using testing::_;
using testing::Invoke;
using testing::NiceMock;
using testing::Return;

constexpr double kExposureCompensationDelta = 1;
constexpr double kExposureTimeDelta = 2;
constexpr double kColorTemperatureDelta = 3;
constexpr double kIsoDelta = 4;
constexpr double kBrightnessDelta = 5;
constexpr double kContrastDelta = 6;
constexpr double kSaturationDelta = 7;
constexpr double kSharpnessDelta = 8;
constexpr double kFocusDistanceDelta = 9;
constexpr double kPanDelta = 10;
constexpr double kTiltDelta = 11;
constexpr double kZoomDelta = 12;

// CaptureErrorFunction implements a javascript function which captures
// name, message and constraint of the exception passed as its argument.
class CaptureErrorFunction final
    : public ThenCallable<IDLAny, CaptureErrorFunction> {
 public:
  CaptureErrorFunction() = default;

  bool WasCalled() const { return was_called_; }
  const String& Name() const { return name_; }
  const String& Message() const { return message_; }
  const String& Constraint() const { return constraint_; }

  void React(ScriptState* script_state, ScriptValue value) {
    was_called_ = true;

    v8::Isolate* isolate = script_state->GetIsolate();
    v8::Local<v8::Context> context = script_state->GetContext();

    v8::Local<v8::Object> error_object =
        value.V8Value()->ToObject(context).ToLocalChecked();

    v8::Local<v8::Value> name =
        error_object->Get(context, V8String(isolate, "name")).ToLocalChecked();
    name_ = ToCoreString(isolate, name->ToString(context).ToLocalChecked());
    v8::Local<v8::Value> message =
        error_object->Get(context, V8String(isolate, "message"))
            .ToLocalChecked();
    message_ =
        ToCoreString(isolate, message->ToString(context).ToLocalChecked());
    v8::Local<v8::Value> constraint =
        error_object->Get(context, V8String(isolate, "constraint"))
            .ToLocalChecked();
    constraint_ =
        ToCoreString(isolate, constraint->ToString(context).ToLocalChecked());
  }

 private:
  bool was_called_ = false;
  String name_;
  String message_;
  String constraint_;
};

// These traits and type aliases simplify mapping from bare value types (bool,
// double, sequence, string) to constrain value dictionary types.
template <typename T>
struct ConstrainWithDictionaryTraits;

template <>
struct ConstrainWithDictionaryTraits<bool> {
  using DictionaryType = ConstrainBooleanParameters;
};

template <>
struct ConstrainWithDictionaryTraits<double> {
  using DictionaryType = ConstrainDoubleRange;
};

template <>
struct ConstrainWithDictionaryTraits<HeapVector<Member<Point2D>>> {
  using DictionaryType = ConstrainPoint2DParameters;
};

template <>
struct ConstrainWithDictionaryTraits<String> {
  using DictionaryType = ConstrainDOMStringParameters;
};

template <>
struct ConstrainWithDictionaryTraits<Vector<String>> {
  using DictionaryType = ConstrainDOMStringParameters;
};

template <typename T>
using ConstrainWithDictionaryType =
    ConstrainWithDictionaryTraits<T>::DictionaryType;

// The `ConstrainDOMStringParameters` dictionary type has `exact` and `ideal`
// members of type `(DOMString or sequence<DOMString>)`.
// https://w3c.github.io/mediacapture-main/#dom-constraindomstringparameters
V8UnionStringOrStringSequence* CreateDictionaryMemberValue(
    const String& value) {
  return MakeGarbageCollected<V8UnionStringOrStringSequence>(value);
}

V8UnionStringOrStringSequence* CreateDictionaryMemberValue(
    const Vector<String>& value) {
  return MakeGarbageCollected<V8UnionStringOrStringSequence>(value);
}

// All the other constrain value dictionary types (ConstrainBooleanParameters,
// ConstrainDoubleRange and ConstrainPoint2DParameters) have `exact` and
// `ideal` members of non-union types.
// https://w3c.github.io/mediacapture-main/#dom-constrainbooleanparameters
// https://w3c.github.io/mediacapture-main/#dom-constraindoublerange
// https://w3c.github.io/mediacapture-main/#dom-constrainpoint2dparameters
template <typename T>
const T& CreateDictionaryMemberValue(const T& value) {
  return value;
}

// This creator creates bare value (bool, double, sequence, string)
// constraints.
struct ConstrainWithBareValueCreator {
  template <typename T>
  static const T& Create(const T& bare_value) {
    return bare_value;
  }
};

// This creator creates constrain value dictionary constraints without members.
struct ConstrainWithEmptyDictionaryCreator {
  template <typename T>
  static auto* Create(const T&) {
    return ConstrainWithDictionaryType<T>::Create();
  }
};

// This creator creates constrain value dictionary constraints with `exact`
// members.
struct ConstrainWithExactDictionaryCreator {
  template <typename T>
  static auto* Create(const T& exact) {
    auto* constrain_value = ConstrainWithDictionaryType<T>::Create();
    constrain_value->setExact(CreateDictionaryMemberValue(exact));
    return constrain_value;
  }
};

// This creator creates constrain value dictionary constraints with `ideal`
// members.
struct ConstrainWithIdealDictionaryCreator {
  template <typename T>
  static auto* Create(const T& ideal) {
    auto* constrain_value = ConstrainWithDictionaryType<T>::Create();
    constrain_value->setIdeal(CreateDictionaryMemberValue(ideal));
    return constrain_value;
  }
};

// This creator creates constrain value dictionary constraints with `max`
// members.
struct ConstrainWithMaxDictionaryCreator {
  template <typename T>
  static auto* Create(const T& max) {
    auto* constrain_value = ConstrainWithDictionaryType<T>::Create();
    constrain_value->setMax(max);
    return constrain_value;
  }
};

// This creator creates constrain value dictionary constraints with `max`
// members for numeric (double) values and empty constrain value dictionary
// constraints for non-numeric (bool, sequence, string) values.
struct ConstrainWithMaxOrEmptyDictionaryCreator {
  static auto* Create(double max) {
    return ConstrainWithMaxDictionaryCreator::Create(max);
  }

  template <typename T>
  static auto* Create(const T&) {
    return ConstrainWithDictionaryType<T>::Create();
  }
};

// This creator creates constrain value dictionary constraints with `min`
// members.
struct ConstrainWithMinDictionaryCreator {
  template <typename T>
  static auto* Create(const T& min) {
    auto* constrain_value = ConstrainWithDictionaryType<T>::Create();
    constrain_value->setMin(min);
    return constrain_value;
  }
};

// This creator creates constrain value dictionary constraints with `min`
// members for numeric (double) values and empty constrain value dictionary
// constraints for non-numeric (bool, sequence, string) values.
struct ConstrainWithMinOrEmptyDictionaryCreator {
  static auto* Create(double min) {
    return ConstrainWithMinDictionaryCreator::Create(min);
  }

  template <typename T>
  static auto* Create(const T&) {
    return ConstrainWithDictionaryType<T>::Create();
  }
};

MediaSettingsRange* CreateMediaSettingsRange(double min,
                                             double max,
                                             double step) {
  auto* range = MediaSettingsRange::Create();
  range->setMin(min);
  range->setMax(max);
  range->setStep(step);
  return range;
}

MediaSettingsRange* CreateMediaSettingsRange(const char (&str)[3]) {
  int min = (static_cast<int>(str[0]) << 16) + (static_cast<int>(str[1]) << 8);
  return CreateMediaSettingsRange(min, min + 16, 8);
}

Point2D* CreatePoint2D(double x, double y) {
  auto* point = Point2D::Create();
  point->setX(x);
  point->setY(y);
  return point;
}

double RangeMean(const MediaSettingsRange* range) {
  return (range->min() + range->max()) / 2;
}

void CheckExactValues(
    const media::mojom::blink::PhotoSettingsPtr& settings,
    const MediaTrackCapabilities* all_capabilities,
    ExpectHasPanTiltZoom expect_has_pan_tilt_zoom = ExpectHasPanTiltZoom(true),
    ExpectHasExposureModeAndFocusMode expect_has_exposure_mode_and_focus_mode =
        ExpectHasExposureModeAndFocusMode(true)) {
  EXPECT_TRUE(settings->has_white_balance_mode);
  EXPECT_EQ(settings->white_balance_mode,
            media::mojom::blink::MeteringMode::CONTINUOUS);
  if (expect_has_exposure_mode_and_focus_mode) {
    EXPECT_TRUE(settings->has_exposure_mode);
    EXPECT_EQ(settings->exposure_mode,
              media::mojom::blink::MeteringMode::MANUAL);
    EXPECT_TRUE(settings->has_focus_mode);
    EXPECT_EQ(settings->focus_mode, media::mojom::blink::MeteringMode::NONE);
  } else {
    EXPECT_FALSE(settings->has_exposure_mode);
    EXPECT_FALSE(settings->has_focus_mode);
  }
  ASSERT_EQ(settings->points_of_interest.size(), 3u);
  EXPECT_EQ(settings->points_of_interest[0]->x, 0.0);
  EXPECT_EQ(settings->points_of_interest[0]->y, 0.0);
  EXPECT_EQ(settings->points_of_interest[1]->x, 0.25);
  EXPECT_EQ(settings->points_of_interest[1]->y, 0.75);
  EXPECT_EQ(settings->points_of_interest[2]->x, 1.0);
  EXPECT_EQ(settings->points_of_interest[2]->y, 1.0);
  EXPECT_TRUE(settings->has_exposure_compensation);
  EXPECT_EQ(settings->exposure_compensation,
            all_capabilities->exposureCompensation()->min() +
                kExposureCompensationDelta);
  EXPECT_TRUE(settings->has_exposure_time);
  EXPECT_EQ(settings->exposure_time,
            all_capabilities->exposureTime()->min() + kExposureTimeDelta);
  EXPECT_TRUE(settings->has_color_temperature);
  EXPECT_EQ(
      settings->color_temperature,
      all_capabilities->colorTemperature()->min() + kColorTemperatureDelta);
  EXPECT_TRUE(settings->has_iso);
  EXPECT_EQ(settings->iso, all_capabilities->iso()->min() + kIsoDelta);
  EXPECT_TRUE(settings->has_brightness);
  EXPECT_EQ(settings->brightness,
            all_capabilities->brightness()->min() + kBrightnessDelta);
  EXPECT_TRUE(settings->has_contrast);
  EXPECT_EQ(settings->contrast,
            all_capabilities->contrast()->min() + kContrastDelta);
  EXPECT_TRUE(settings->has_saturation);
  EXPECT_EQ(settings->saturation,
            all_capabilities->saturation()->min() + kSaturationDelta);
  EXPECT_TRUE(settings->has_sharpness);
  EXPECT_EQ(settings->sharpness,
            all_capabilities->sharpness()->min() + kSharpnessDelta);
  EXPECT_TRUE(settings->has_focus_distance);
  EXPECT_EQ(settings->focus_distance,
            all_capabilities->focusDistance()->min() + kFocusDistanceDelta);
  if (expect_has_pan_tilt_zoom) {
    EXPECT_TRUE(settings->has_pan);
    EXPECT_EQ(settings->pan, all_capabilities->pan()->min() + kPanDelta);
    EXPECT_TRUE(settings->has_tilt);
    EXPECT_EQ(settings->tilt, all_capabilities->tilt()->min() + kTiltDelta);
    EXPECT_TRUE(settings->has_zoom);
    EXPECT_EQ(settings->zoom, all_capabilities->zoom()->min() + kZoomDelta);
  } else {
    EXPECT_FALSE(settings->has_pan);
    EXPECT_FALSE(settings->has_tilt);
    EXPECT_FALSE(settings->has_zoom);
  }
  EXPECT_TRUE(settings->has_torch);
  EXPECT_EQ(settings->torch, true);
  EXPECT_TRUE(settings->has_background_blur_mode);
  EXPECT_EQ(settings->background_blur_mode,
            media::mojom::blink::BackgroundBlurMode::BLUR);
  EXPECT_TRUE(settings->eye_gaze_correction_mode.has_value());
  EXPECT_EQ(settings->eye_gaze_correction_mode.value(),
            media::mojom::blink::EyeGazeCorrectionMode::OFF);
  EXPECT_TRUE(settings->has_face_framing_mode);
  EXPECT_EQ(settings->face_framing_mode,
            media::mojom::blink::MeteringMode::CONTINUOUS);
  EXPECT_TRUE(settings->background_segmentation_mask_state.has_value());
  EXPECT_FALSE(settings->background_segmentation_mask_state.value());
}

void CheckMaxValues(const media::mojom::blink::PhotoSettingsPtr& settings,
                    const MediaTrackCapabilities* all_capabilities,
                    const MediaTrackSettings* default_settings,
                    ExpectHasPanTiltZoom expect_has_pan_tilt_zoom =
                        ExpectHasPanTiltZoom(true)) {
  EXPECT_FALSE(settings->has_white_balance_mode);
  EXPECT_FALSE(settings->has_exposure_mode);
  EXPECT_FALSE(settings->has_focus_mode);
  EXPECT_EQ(settings->points_of_interest.size(), 0u);
  EXPECT_TRUE(settings->has_exposure_compensation);
  EXPECT_EQ(settings->exposure_compensation,
            std::min(all_capabilities->exposureCompensation()->min() +
                         kExposureCompensationDelta,
                     default_settings->exposureCompensation()));
  EXPECT_TRUE(settings->has_exposure_time);
  EXPECT_EQ(
      settings->exposure_time,
      std::min(all_capabilities->exposureTime()->min() + kExposureTimeDelta,
               default_settings->exposureTime()));
  EXPECT_TRUE(settings->has_color_temperature);
  EXPECT_EQ(settings->color_temperature,
            std::min(all_capabilities->colorTemperature()->min() +
                         kColorTemperatureDelta,
                     default_settings->colorTemperature()));
  EXPECT_TRUE(settings->has_iso);
  EXPECT_EQ(settings->iso, std::min(all_capabilities->iso()->min() + kIsoDelta,
                                    default_settings->iso()));
  EXPECT_TRUE(settings->has_brightness);
  EXPECT_EQ(settings->brightness,
            std::min(all_capabilities->brightness()->min() + kBrightnessDelta,
                     default_settings->brightness()));
  EXPECT_TRUE(settings->has_contrast);
  EXPECT_EQ(settings->contrast,
            std::min(all_capabilities->contrast()->min() + kContrastDelta,
                     default_settings->contrast()));
  EXPECT_TRUE(settings->has_saturation);
  EXPECT_EQ(settings->saturation,
            std::min(all_capabilities->saturation()->min() + kSaturationDelta,
                     default_settings->saturation()));
  EXPECT_TRUE(settings->has_sharpness);
  EXPECT_EQ(settings->sharpness,
            std::min(all_capabilities->sharpness()->min() + kSharpnessDelta,
                     default_settings->sharpness()));
  EXPECT_TRUE(settings->has_focus_distance);
  EXPECT_EQ(
      settings->focus_distance,
      std::min(all_capabilities->focusDistance()->min() + kFocusDistanceDelta,
               default_settings->focusDistance()));
  if (expect_has_pan_tilt_zoom) {
    EXPECT_TRUE(settings->has_pan);
    EXPECT_EQ(settings->pan,
              std::min(all_capabilities->pan()->min() + kPanDelta,
                       default_settings->pan()));
    EXPECT_TRUE(settings->has_tilt);
    EXPECT_EQ(settings->tilt,
              std::min(all_capabilities->tilt()->min() + kTiltDelta,
                       default_settings->tilt()));
    EXPECT_TRUE(settings->has_zoom);
    EXPECT_EQ(settings->zoom,
              std::min(all_capabilities->zoom()->min() + kZoomDelta,
                       default_settings->zoom()));
  } else {
    EXPECT_FALSE(settings->has_pan);
    EXPECT_FALSE(settings->has_tilt);
    EXPECT_FALSE(settings->has_zoom);
  }
  EXPECT_FALSE(settings->has_torch);
  EXPECT_FALSE(settings->has_background_blur_mode);
  EXPECT_FALSE(settings->eye_gaze_correction_mode.has_value());
  EXPECT_FALSE(settings->has_face_framing_mode);
  EXPECT_FALSE(settings->background_segmentation_mask_state.has_value());
}

void CheckMinValues(const media::mojom::blink::PhotoSettingsPtr& settings,
                    const MediaTrackCapabilities* all_capabilities,
                    const MediaTrackSettings* default_settings,
                    ExpectHasPanTiltZoom expect_has_pan_tilt_zoom =
                        ExpectHasPanTiltZoom(true)) {
  EXPECT_FALSE(settings->has_white_balance_mode);
  EXPECT_FALSE(settings->has_exposure_mode);
  EXPECT_FALSE(settings->has_focus_mode);
  EXPECT_EQ(settings->points_of_interest.size(), 0u);
  EXPECT_TRUE(settings->has_exposure_compensation);
  EXPECT_EQ(settings->exposure_compensation,
            std::max(all_capabilities->exposureCompensation()->min() +
                         kExposureCompensationDelta,
                     default_settings->exposureCompensation()));
  EXPECT_TRUE(settings->has_exposure_time);
  EXPECT_EQ(
      settings->exposure_time,
      std::max(all_capabilities->exposureTime()->min() + kExposureTimeDelta,
               default_settings->exposureTime()));
  EXPECT_TRUE(settings->has_color_temperature);
  EXPECT_EQ(settings->color_temperature,
            std::max(all_capabilities->colorTemperature()->min() +
                         kColorTemperatureDelta,
                     default_settings->colorTemperature()));
  EXPECT_TRUE(settings->has_iso);
  EXPECT_EQ(settings->iso, std::max(all_capabilities->iso()->min() + kIsoDelta,
                                    default_settings->iso()));
  EXPECT_TRUE(settings->has_brightness);
  EXPECT_EQ(settings->brightness,
            std::max(all_capabilities->brightness()->min() + kBrightnessDelta,
                     default_settings->brightness()));
  EXPECT_TRUE(settings->has_contrast);
  EXPECT_EQ(settings->contrast,
            std::max(all_capabilities->contrast()->min() + kContrastDelta,
                     default_settings->contrast()));
  EXPECT_TRUE(settings->has_saturation);
  EXPECT_EQ(settings->saturation,
            std::max(all_capabilities->saturation()->min() + kSaturationDelta,
                     default_settings->saturation()));
  EXPECT_TRUE(settings->has_sharpness);
  EXPECT_EQ(settings->sharpness,
            std::max(all_capabilities->sharpness()->min() + kSharpnessDelta,
                     default_settings->sharpness()));
  EXPECT_TRUE(settings->has_focus_distance);
  EXPECT_EQ(
      settings->focus_distance,
      std::max(all_capabilities->focusDistance()->min() + kFocusDistanceDelta,
               default_settings->focusDistance()));
  if (expect_has_pan_tilt_zoom) {
    EXPECT_TRUE(settings->has_pan);
    EXPECT_EQ(settings->pan,
              std::max(all_capabilities->pan()->min() + kPanDelta,
                       default_settings->pan()));
    EXPECT_TRUE(settings->has_tilt);
    EXPECT_EQ(settings->tilt,
              std::max(all_capabilities->tilt()->min() + kTiltDelta,
                       default_settings->tilt()));
    EXPECT_TRUE(settings->has_zoom);
    EXPECT_EQ(settings->zoom,
              std::max(all_capabilities->zoom()->min() + kZoomDelta,
                       default_settings->zoom()));
  } else {
    EXPECT_FALSE(settings->has_pan);
    EXPECT_FALSE(settings->has_tilt);
    EXPECT_FALSE(settings->has_zoom);
  }
  EXPECT_FALSE(settings->has_torch);
  EXPECT_FALSE(settings->has_background_blur_mode);
  EXPECT_FALSE(settings->eye_gaze_correction_mode.has_value());
  EXPECT_FALSE(settings->has_face_framing_mode);
  EXPECT_FALSE(settings->background_segmentation_mask_state.has_value());
}

void CheckNoValues(const media::mojom::blink::PhotoSettingsPtr& settings,
                   size_t expected_points_of_interest_size = 0u) {
  EXPECT_FALSE(settings->has_white_balance_mode);
  EXPECT_FALSE(settings->has_exposure_mode);
  EXPECT_FALSE(settings->has_focus_mode);
  EXPECT_EQ(settings->points_of_interest.size(),
            expected_points_of_interest_size);
  EXPECT_FALSE(settings->has_exposure_compensation);
  EXPECT_FALSE(settings->has_exposure_time);
  EXPECT_FALSE(settings->has_color_temperature);
  EXPECT_FALSE(settings->has_iso);
  EXPECT_FALSE(settings->has_brightness);
  EXPECT_FALSE(settings->has_contrast);
  EXPECT_FALSE(settings->has_saturation);
  EXPECT_FALSE(settings->has_sharpness);
  EXPECT_FALSE(settings->has_focus_distance);
  EXPECT_FALSE(settings->has_pan);
  EXPECT_FALSE(settings->has_tilt);
  EXPECT_FALSE(settings->has_zoom);
  EXPECT_FALSE(settings->has_torch);
  EXPECT_FALSE(settings->has_background_blur_mode);
  EXPECT_FALSE(settings->eye_gaze_correction_mode.has_value());
  EXPECT_FALSE(settings->has_face_framing_mode);
  EXPECT_FALSE(settings->background_segmentation_mask_state.has_value());
}

template <typename ConstraintCreator>
void PopulateConstraintSet(
    MediaTrackConstraintSet* constraint_set,
    const MediaTrackCapabilities* all_capabilities,
    PopulatePanTiltZoom populate_pan_tilt_zoom = PopulatePanTiltZoom(true)) {
  constraint_set->setWhiteBalanceMode(
      MakeGarbageCollected<
          V8UnionConstrainDOMStringParametersOrStringOrStringSequence>(
          ConstraintCreator::Create(all_capabilities->whiteBalanceMode()[0])));
  constraint_set->setExposureMode(
      MakeGarbageCollected<
          V8UnionConstrainDOMStringParametersOrStringOrStringSequence>(
          ConstraintCreator::Create(all_capabilities->exposureMode())));
  constraint_set->setFocusMode(
      MakeGarbageCollected<
          V8UnionConstrainDOMStringParametersOrStringOrStringSequence>(
          ConstraintCreator::Create(all_capabilities->focusMode())));
  HeapVector<Member<Point2D>> points_of_interest = {CreatePoint2D(-0.75, -0.25),
                                                    CreatePoint2D(0.25, 0.75),
                                                    CreatePoint2D(1.25, 1.75)};
  constraint_set->setPointsOfInterest(
      MakeGarbageCollected<V8UnionConstrainPoint2DParametersOrPoint2DSequence>(
          ConstraintCreator::Create(points_of_interest)));
  constraint_set->setExposureCompensation(
      MakeGarbageCollected<V8UnionConstrainDoubleRangeOrDouble>(
          ConstraintCreator::Create(
              all_capabilities->exposureCompensation()->min() +
              kExposureCompensationDelta)));
  constraint_set->setExposureTime(
      MakeGarbageCollected<V8UnionConstrainDoubleRangeOrDouble>(
          ConstraintCreator::Create(all_capabilities->exposureTime()->min() +
                                    kExposureTimeDelta)));
  constraint_set->setColorTemperature(
      MakeGarbageCollected<V8UnionConstrainDoubleRangeOrDouble>(
          ConstraintCreator::Create(
              all_capabilities->colorTemperature()->min() +
              kColorTemperatureDelta)));
  constraint_set->setIso(
      MakeGarbageCollected<V8UnionConstrainDoubleRangeOrDouble>(
          ConstraintCreator::Create(all_capabilities->iso()->min() +
                                    kIsoDelta)));
  constraint_set->setBrightness(
      MakeGarbageCollected<V8UnionConstrainDoubleRangeOrDouble>(
          ConstraintCreator::Create(all_capabilities->brightness()->min() +
                                    kBrightnessDelta)));
  constraint_set->setContrast(
      MakeGarbageCollected<V8UnionConstrainDoubleRangeOrDouble>(
          ConstraintCreator::Create(all_capabilities->contrast()->min() +
                                    kContrastDelta)));
  constraint_set->setSaturation(
      MakeGarbageCollected<V8UnionConstrainDoubleRangeOrDouble>(
          ConstraintCreator::Create(all_capabilities->saturation()->min() +
                                    kSaturationDelta)));
  constraint_set->setSharpness(
      MakeGarbageCollected<V8UnionConstrainDoubleRangeOrDouble>(
          ConstraintCreator::Create(all_capabilities->sharpness()->min() +
                                    kSharpnessDelta)));
  constraint_set->setFocusDistance(
      MakeGarbageCollected<V8UnionConstrainDoubleRangeOrDouble>(
          ConstraintCreator::Create(all_capabilities->focusDistance()->min() +
                                    kFocusDistanceDelta)));
  if (populate_pan_tilt_zoom) {
    constraint_set->setPan(
        MakeGarbageCollected<V8UnionBooleanOrConstrainDoubleRangeOrDouble>(
            ConstraintCreator::Create(all_capabilities->pan()->min() +
                                      kPanDelta)));
    constraint_set->setTilt(
        MakeGarbageCollected<V8UnionBooleanOrConstrainDoubleRangeOrDouble>(
            ConstraintCreator::Create(all_capabilities->tilt()->min() +
                                      kTiltDelta)));
    constraint_set->setZoom(
        MakeGarbageCollected<V8UnionBooleanOrConstrainDoubleRangeOrDouble>(
            ConstraintCreator::Create(all_capabilities->zoom()->min() +
                                      kZoomDelta)));
  }
  constraint_set->setTorch(
      MakeGarbageCollected<V8UnionBooleanOrConstrainBooleanParameters>(
          ConstraintCreator::Create(true)));
  constraint_set->setBackgroundBlur(
      MakeGarbageCollected<V8UnionBooleanOrConstrainBooleanParameters>(
          ConstraintCreator::Create(all_capabilities->backgroundBlur()[0])));
  constraint_set->setEyeGazeCorrection(
      MakeGarbageCollected<V8UnionBooleanOrConstrainBooleanParameters>(
          ConstraintCreator::Create(all_capabilities->eyeGazeCorrection()[0])));
  constraint_set->setFaceFraming(
      MakeGarbageCollected<V8UnionBooleanOrConstrainBooleanParameters>(
          ConstraintCreator::Create(all_capabilities->faceFraming()[0])));
  constraint_set->setBackgroundSegmentationMask(
      MakeGarbageCollected<V8UnionBooleanOrConstrainBooleanParameters>(
          ConstraintCreator::Create(
              all_capabilities->backgroundSegmentationMask()[0])));
}

class MockMediaStreamComponent
    : public GarbageCollected<MockMediaStreamComponent>,
      public MediaStreamComponent {
 public:
  virtual ~MockMediaStreamComponent() = default;
  MOCK_CONST_METHOD0(Clone, MediaStreamComponent*());
  MOCK_CONST_METHOD0(Source, MediaStreamSource*());
  MOCK_CONST_METHOD0(Id, String());
  MOCK_CONST_METHOD0(UniqueId, int());
  MOCK_CONST_METHOD0(GetSourceType, MediaStreamSource::StreamType());
  MOCK_CONST_METHOD0(GetSourceName, const String&());
  MOCK_CONST_METHOD0(GetReadyState, MediaStreamSource::ReadyState());
  MOCK_CONST_METHOD0(Remote, bool());
  MOCK_CONST_METHOD0(Enabled, bool());
  MOCK_METHOD1(SetEnabled, void(bool));
  MOCK_METHOD0(ContentHint, WebMediaStreamTrack::ContentHintType());
  MOCK_METHOD1(SetContentHint, void(WebMediaStreamTrack::ContentHintType));
  MOCK_CONST_METHOD0(GetPlatformTrack, MediaStreamTrackPlatform*());
  MOCK_METHOD1(SetPlatformTrack,
               void(std::unique_ptr<MediaStreamTrackPlatform>));
  MOCK_METHOD1(GetSettings, void(MediaStreamTrackPlatform::Settings&));
  MOCK_METHOD0(GetCaptureHandle, MediaStreamTrackPlatform::CaptureHandle());
  MOCK_METHOD0(CreationFrame, WebLocalFrame*());
  MOCK_METHOD1(SetCreationFrameGetter,
               void(base::RepeatingCallback<WebLocalFrame*()>));
  MOCK_METHOD1(AddSourceObserver, void(MediaStreamSource::Observer*));
  MOCK_METHOD1(AddSink, void(WebMediaStreamAudioSink*));
  MOCK_METHOD4(AddSink,
               void(WebMediaStreamSink*,
                    const VideoCaptureDeliverFrameCB&,
                    MediaStreamVideoSink::IsSecure,
                    MediaStreamVideoSink::UsesAlpha));
  MOCK_CONST_METHOD0(ToString, String());
};

}  // namespace

class ImageCaptureTest : public testing::Test {
 public:
  ImageCaptureTest()
      : component_(MakeGarbageCollected<MockMediaStreamComponent>()),
        track_(MakeGarbageCollected<MockMediaStreamTrack>()),
        image_capture_(MakeGarbageCollected<ImageCapture>(
            /*execution_context=*/nullptr,
            track_,
            /*pan_tilt_zoom_allowed=*/true,
            base::DoNothing(),
            base::Milliseconds(1))) {
    track_->SetComponent(component_);
  }

  void TearDown() override { WebHeap::CollectAllGarbageForTesting(); }

  void SetupTrackMocks(V8TestingScope& scope,
                       bool produce_frame_on_add_sink = true) {
    produce_frame_on_add_sink_ = produce_frame_on_add_sink;
    source_ = std::make_unique<MediaStreamVideoCapturerSource>(
        scope.GetFrame().GetTaskRunner(TaskType::kInternalMediaRealTime),
        &scope.GetFrame(),
        MediaStreamVideoCapturerSource::SourceStoppedCallback(),
        std::make_unique<NiceMock<MockVideoCapturerSource>>());
    platform_track_ = std::make_unique<MediaStreamVideoTrack>(
        source_.get(), WebPlatformMediaStreamSource::ConstraintsOnceCallback(),
        /*enabled=*/true);
    EXPECT_CALL(*component_, GetPlatformTrack)
        .WillRepeatedly(Return(platform_track_.get()));
    EXPECT_CALL(*component_, GetSourceType)
        .WillRepeatedly(Return(MediaStreamSource::kTypeVideo));

    ON_CALL(*component_, AddSink(_, _, _, _))
        .WillByDefault(Invoke([&](WebMediaStreamSink* sink,
                                  const VideoCaptureDeliverFrameCB& callback,
                                  MediaStreamVideoSink::IsSecure is_secure,
                                  MediaStreamVideoSink::UsesAlpha uses_alpha) {
          platform_track_->AddSink(sink, callback, is_secure, uses_alpha);
          if (produce_frame_on_add_sink_) {
            callback.Run(media::VideoFrame::CreateBlackFrame(gfx::Size(1, 1)),
                         /*estimated_capture_time=*/base::TimeTicks());
          }
        }));
  }

 protected:
  test::TaskEnvironment task_environment_;
  Persistent<MockMediaStreamComponent> component_;
  Persistent<MockMediaStreamTrack> track_;
  Persistent<ImageCapture> image_capture_;
  ScopedTestingPlatformSupport<IOTaskRunnerTestingPlatformSupport> platform_;
  std::unique_ptr<MediaStreamVideoCapturerSource> source_;
  std::unique_ptr<MediaStreamVideoTrack> platform_track_;
  bool produce_frame_on_add_sink_ = true;
};

class ImageCaptureConstraintTest : public ImageCaptureTest {
 public:
  ImageCaptureConstraintTest() {
    all_capabilities_ = MediaTrackCapabilities::Create();
    all_non_capabilities_ = MediaTrackCapabilities::Create();
    all_capabilities_->setWhiteBalanceMode({"continuous", "manual"});
    all_non_capabilities_->setWhiteBalanceMode({"none"});
    all_capabilities_->setExposureMode({"manual", "none"});
    all_non_capabilities_->setExposureMode({"continuous"});
    all_capabilities_->setFocusMode({"none", "continuous"});
    all_non_capabilities_->setFocusMode({"manual"});
    all_capabilities_->setExposureCompensation(CreateMediaSettingsRange("ec"));
```
Response:
Let's break down the thought process to analyze the `periodic_wave.cc` file.

1. **Understand the Goal:** The request asks for the file's functionality, its relationship with web technologies, examples of usage, potential errors, and debugging information.

2. **Initial Scan for Keywords:**  Look for obvious cues:
    * `#include`: Identifies dependencies, hinting at the file's purpose. See `webaudio/periodic_wave.h`, `webaudio/base_audio_context.h`, `webaudio/oscillator_node.h`, `platform/audio/fft_frame.h`. These immediately point to Web Audio API functionality and signal processing (FFT).
    * `namespace blink`: Confirms it's part of the Blink rendering engine.
    * Class names like `PeriodicWave`, `PeriodicWaveImpl`: Indicate core components.
    * Method names like `Create`, `CreateSine`, `CreateSquare`, `CreateBandLimitedTables`, `WaveDataForFundamentalFrequency`: Suggest actions the class performs.

3. **Identify Core Functionality (What does it *do*?):**
    * The file is about `PeriodicWave` objects.
    * The `Create` methods suggest the creation of these waves using various means: providing real and imaginary components, or using predefined shapes (sine, square, etc.).
    * The presence of `PeriodicWaveImpl` suggests an implementation detail, likely handling the heavy lifting of wave generation and manipulation.
    * The `CreateBandLimitedTables` method strongly implies the creation of lookup tables to efficiently generate band-limited waveforms. This is crucial for preventing aliasing in digital audio.
    * `WaveDataForFundamentalFrequency` suggests retrieving pre-computed wave data based on the desired frequency. The presence of lower and higher wave data, and an interpolation factor, points to a technique for smoother frequency transitions.

4. **Relate to Web Technologies (How does it connect to JS/HTML/CSS?):**
    * The file is within the `modules/webaudio` directory. This is the primary link.
    * JavaScript interacts with the Web Audio API. The `PeriodicWave` object is directly accessible through JavaScript.
    * The `PeriodicWaveOptions` parameter in one of the `Create` methods matches how JavaScript users would configure these waves.
    * **Concrete Example:**  Think of the JavaScript code a developer would write to use this: `audioContext.createPeriodicWave(realArray, imagArray, { disableNormalization: true });` or `oscillator.setPeriodicWave(periodicWave);`.

5. **Analyze Logic and Infer Input/Output:**
    * **`Create` with real/imag:**  Input: `real` and `imag` arrays (representing the Fourier series). Output: A `PeriodicWave` object. The code validates the array sizes.
    * **`Create` with options:** Input: `PeriodicWaveOptions` (which can contain `real`, `imag`, and `disableNormalization`). Output: A `PeriodicWave` object. The code handles cases where only `real` or `imag` are provided.
    * **`CreateSine`, `CreateSquare`, etc.:** Input: `sample_rate`. Output: A `PeriodicWave` object representing the specific waveform.
    * **`CreateBandLimitedTables`:** Input: Real and imaginary coefficients, number of components, and a normalization flag. Output: Populated `band_limited_tables_`. This is internal but crucial.
    * **`WaveDataForFundamentalFrequency`:** Input: `fundamental_frequency`. Output: Pointers to lower and higher wave data tables and an interpolation factor. This is where the band-limiting and efficient lookup happen.

6. **Identify Potential User Errors:**
    * **Mismatched `real` and `imag` array sizes:**  The code explicitly checks for this and throws an exception.
    * **Too small `real` or `imag` arrays:** The code enforces a minimum size of 2.
    * **Incorrectly understanding normalization:** Users might not realize the implications of disabling normalization (potentially very loud sounds).

7. **Trace User Operations (Debugging Clues):**
    * The starting point is always a user interacting with a webpage.
    * The user's actions trigger JavaScript code.
    * This JavaScript code uses the Web Audio API, specifically the `createPeriodicWave` method of an `AudioContext`.
    * The parameters passed to `createPeriodicWave` in JavaScript map directly to the C++ `Create` methods in this file.
    * Setting a `PeriodicWave` on an `OscillatorNode` uses the data generated by this file.
    * **Debugging Scenario:**  If a user reports an issue with a custom waveform sounding wrong, a developer would:
        1. Examine the JavaScript code creating the `PeriodicWave`.
        2. Check the values in the `real` and `imag` arrays.
        3. Set breakpoints in the C++ code (e.g., in the `Create` methods or `CreateBandLimitedTables`) to inspect the data being processed.

8. **Refine and Organize:** Structure the information logically, separating functionality, web technology connections, examples, errors, and debugging steps. Use clear and concise language. Emphasize the key concepts like band-limiting and the use of pre-computed tables.

This structured approach allows for a comprehensive understanding of the `periodic_wave.cc` file, covering all aspects requested in the prompt. The key is to start with the big picture (the Web Audio API) and then zoom in on the specific details of the code.
这个文件 `blink/renderer/modules/webaudio/periodic_wave.cc` 是 Chromium Blink 引擎中负责实现 **`PeriodicWave` 接口** 的源代码文件。 `PeriodicWave` 接口是 Web Audio API 的一部分，允许开发者自定义音频振荡器的波形。

以下是该文件的功能列表：

**核心功能：**

1. **创建 `PeriodicWave` 对象:**  提供了多种静态方法 (`Create`) 来创建 `PeriodicWave` 对象。
    * 可以通过指定实部 (real) 和虚部 (imag) 的傅里叶系数来创建自定义波形。
    * 可以通过预定义的波形类型 (sine, square, sawtooth, triangle) 来创建。
    * 可以接收 `PeriodicWaveOptions` 对象作为参数，该对象包含实部、虚部以及是否禁用归一化的选项。

2. **生成带限波形表 (Band-Limited Tables):**  `CreateBandLimitedTables` 方法是核心，它根据提供的傅里叶系数生成一系列带限波形查找表。这些查找表用于在不同频率下播放时避免混叠 (aliasing) 现象。
    * 它会根据不同的频率范围（通过 `kNumberOfOctaveBands` 定义）创建不同的波形表，每个表都过滤掉了高于特定频率的谐波。

3. **提供波形数据:** `WaveDataForFundamentalFrequency` 方法根据给定的基频，从预先生成的带限波形表中选择合适的两个表，并计算插值因子。这样可以在播放不同频率的波形时平滑过渡，并保证音质。

4. **处理不同 CPU 架构的优化:**  针对 x86 和 ARM NEON 架构，提供了优化的 `WaveDataForFundamentalFrequency` 版本，利用 SIMD 指令（如 SSE2 和 NEON）来提升性能。

5. **处理归一化:**  可以选择是否对生成的波形进行归一化，使其峰值幅度为 1。

**与 Javascript, HTML, CSS 的关系：**

这个 C++ 文件是 Web Audio API 的底层实现部分，JavaScript 代码通过 Web Audio API 与其交互。

* **JavaScript:**  JavaScript 代码使用 `AudioContext.createPeriodicWave()` 方法来创建 `PeriodicWave` 对象。该方法在 Blink 引擎中会调用 `PeriodicWave::Create`。

   ```javascript
   const audioContext = new AudioContext();
   const real = new Float32Array([0, 0]);
   const imag = new Float32Array([0, 1]);
   const wave = audioContext.createPeriodicWave(real, imag); // 创建正弦波

   const oscillator = audioContext.createOscillator();
   oscillator.setPeriodicWave(wave); // 将自定义波形应用于振荡器
   oscillator.connect(audioContext.destination);
   oscillator.start();
   ```

* **HTML:** HTML 文件通过 `<script>` 标签引入 JavaScript 代码，而这些 JavaScript 代码可能会使用 Web Audio API 和 `PeriodicWave`。

* **CSS:** CSS 本身不直接与 `PeriodicWave` 交互。`PeriodicWave` 主要负责音频的生成和处理，与视觉呈现无关。

**逻辑推理和假设输入/输出：**

**假设输入：**

* **创建自定义波形:**  `real = [0, 0.5, 0]`, `imag = [0, 0, 0]` (代表一个弱二次谐波的波形)。
* **基频:** `fundamental_frequency = 440` Hz。
* **采样率:**  假设 `sample_rate` 为 44100 Hz。

**逻辑推理：**

1. `PeriodicWave::Create` 会被调用，接收 `real` 和 `imag` 数组。
2. `PeriodicWaveImpl::CreateBandLimitedTables` 会根据 `real` 和 `imag` 生成带限波形表。由于 `imag` 的第二个元素为 0，该波形只有直流分量和二次谐波。带限表会包含这个波形的时域采样数据。
3. 当一个 `OscillatorNode` 使用这个 `PeriodicWave` 并设置基频为 440Hz 时，`PeriodicWaveImpl::WaveDataForFundamentalFrequency` 会被调用。
4. 该方法会计算 440Hz 对应的频率范围，并从带限波形表中选择合适的两个表进行插值。由于 440Hz 可能落在两个相邻的频率范围之间，所以需要插值。

**假设输出：**

* `WaveDataForFundamentalFrequency` 会输出两个指向 `band_limited_tables_` 中不同波形数据的指针 (`lower_wave_data`, `higher_wave_data`) 和一个介于 0 到 1 之间的插值因子 (`table_interpolation_factor`)。这两个波形表代表略低于和略高于 440Hz 的带限波形，插值因子决定了如何将这两个波形混合以获得最终的波形数据。

**用户或编程常见的使用错误：**

1. **`real` 和 `imag` 数组长度不匹配:**  如果传递给 `createPeriodicWave` 的 `real` 和 `imag` 数组的长度不同，会抛出一个 `DOMException` (IndexSizeError)。

   ```javascript
   const real = new Float32Array([0, 1]);
   const imag = new Float32Array([0, 1, 0]);
   audioContext.createPeriodicWave(real, imag); // 抛出错误
   ```

2. **`real` 或 `imag` 数组长度小于 2:** 傅里叶级数至少需要包含直流分量和第一个谐波。如果数组长度小于 2，也会抛出 `DOMException` (IndexSizeError)。

   ```javascript
   const real = new Float32Array([0]);
   audioContext.createPeriodicWave(real, new Float32Array([0])); // 抛出错误
   ```

3. **误解归一化:**  如果用户禁用了归一化 (`disableNormalization: true`)，生成的波形的幅度可能非常大，导致声音过响甚至失真。用户可能期望禁用归一化可以获得原始的傅里叶系数表示的波形，但如果没有正确缩放，可能会出现问题。

   ```javascript
   const real = new Float32Array([0, 10]); // 幅度很大的正弦波
   const imag = new Float32Array([0, 0]);
   const wave = audioContext.createPeriodicWave(real, imag, { disableNormalization: true });
   // 播放时可能会非常响
   ```

**用户操作如何一步步到达这里，作为调试线索：**

1. **用户在浏览器中打开一个网页。**
2. **网页中的 JavaScript 代码创建了一个 `AudioContext` 对象。**
3. **JavaScript 代码调用 `audioContext.createPeriodicWave(real, imag, options)`，传入自定义的 `real` 和 `imag` 数组，或者预定义的波形类型。**
4. **浏览器引擎（Blink）接收到 `createPeriodicWave` 的调用。**
5. **Blink 引擎会调用 `blink/renderer/modules/webaudio/BaseAudioContext.cpp` 中的相应方法，该方法最终会调用到 `blink/renderer/modules/webaudio/periodic_wave.cc` 中的 `PeriodicWave::Create` 静态方法。**
6. **`PeriodicWave::Create` 会根据传入的参数创建 `PeriodicWave` 对象，并调用 `PeriodicWaveImpl::CreateBandLimitedTables` 生成波形查找表。**
7. **稍后，当 JavaScript 代码创建一个 `OscillatorNode` 并调用 `oscillator.setPeriodicWave(wave)` 时，这个 `PeriodicWave` 对象会被关联到振荡器。**
8. **当振荡器开始播放时，音频引擎需要生成实际的音频数据。这会调用 `PeriodicWaveImpl::WaveDataForFundamentalFrequency` 来获取当前频率下的波形数据。**

**调试线索：**

* 如果用户报告自定义波形听起来不对劲，开发者可以：
    * **检查 JavaScript 代码中传递给 `createPeriodicWave` 的 `real` 和 `imag` 数组的值是否正确。**
    * **使用浏览器的开发者工具断点调试 JavaScript 代码，查看 `PeriodicWave` 对象是否被正确创建。**
    * **在 Blink 引擎的源代码中设置断点，例如在 `PeriodicWave::Create` 和 `PeriodicWaveImpl::CreateBandLimitedTables` 中，查看传入的傅里叶系数以及生成的波形表数据。**
    * **检查音频上下文的采样率是否与预期一致。**
    * **如果怀疑是频率相关的错误，可以在 `PeriodicWaveImpl::WaveDataForFundamentalFrequency` 中设置断点，查看选择的波形表和插值因子是否正确。**
    * **如果启用了归一化，检查归一化因子是否符合预期。如果禁用了归一化，需要确认输入的傅里叶系数的幅度是否在合理范围内。**

总而言之，`periodic_wave.cc` 文件是 Web Audio API 中 `PeriodicWave` 功能的核心实现，负责将用户提供的傅里叶系数或者预定义的波形类型转换为可用于音频振荡器播放的带限波形数据。 理解这个文件的功能对于调试和深入理解 Web Audio API 的工作原理至关重要。

Prompt: 
```
这是目录为blink/renderer/modules/webaudio/periodic_wave.cc的chromium blink引擎源代码文件， 请列举一下它的功能, 
如果它与javascript, html, css的功能有关系，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索。

"""
/*
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifdef UNSAFE_BUFFERS_BUILD
// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
#pragma allow_unsafe_buffers
#endif

#include "third_party/blink/renderer/modules/webaudio/periodic_wave.h"

#include <algorithm>
#include <memory>

#include "build/build_config.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_periodic_wave_options.h"
#include "third_party/blink/renderer/modules/webaudio/base_audio_context.h"
#include "third_party/blink/renderer/modules/webaudio/oscillator_node.h"
#include "third_party/blink/renderer/platform/audio/fft_frame.h"
#include "third_party/blink/renderer/platform/audio/vector_math.h"
#include "third_party/blink/renderer/platform/bindings/exception_messages.h"
#include "third_party/blink/renderer/platform/bindings/exception_state.h"
#include "third_party/blink/renderer/platform/bindings/script_wrappable.h"

#if defined(ARCH_CPU_X86_FAMILY)
#include <xmmintrin.h>
#elif defined(CPU_ARM_NEON)
#include <arm_neon.h>
#endif

namespace blink {

namespace {

// The number of bands per octave.  Each octave will have this many entries in
// the wave tables.
constexpr unsigned kNumberOfOctaveBands = 3;

// The max length of a periodic wave. This must be a power of two greater than
// or equal to 2048 and must be supported by the FFT routines.
constexpr unsigned kMaxPeriodicWaveSize = 16384;

constexpr float kCentsPerRange = 1200 / kNumberOfOctaveBands;

}  // namespace

PeriodicWave* PeriodicWave::Create(BaseAudioContext& context,
                                   const Vector<float>& real,
                                   const Vector<float>& imag,
                                   bool disable_normalization,
                                   ExceptionState& exception_state) {
  DCHECK(IsMainThread());

  if (real.size() != imag.size()) {
    exception_state.ThrowDOMException(
        DOMExceptionCode::kIndexSizeError,
        "length of real array (" + String::Number(real.size()) +
            ") and length of imaginary array (" + String::Number(imag.size()) +
            ") must match.");
    return nullptr;
  }

  if (real.size() < 2) {
    exception_state.ThrowDOMException(
        DOMExceptionCode::kIndexSizeError,
        ExceptionMessages::IndexExceedsMinimumBound("length of the real array",
                                                    real.size(), 2u));
    return nullptr;
  }

  if (imag.size() < 2) {
    exception_state.ThrowDOMException(
        DOMExceptionCode::kIndexSizeError,
        ExceptionMessages::IndexExceedsMinimumBound("length of the imag array",
                                                    imag.size(), 2u));
    return nullptr;
  }

  PeriodicWave* periodic_wave =
      MakeGarbageCollected<PeriodicWave>(context.sampleRate());
  periodic_wave->impl()->CreateBandLimitedTables(
      real.data(), imag.data(), real.size(), disable_normalization);
  return periodic_wave;
}

PeriodicWave* PeriodicWave::Create(BaseAudioContext* context,
                                   const PeriodicWaveOptions* options,
                                   ExceptionState& exception_state) {
  bool normalize = options->disableNormalization();

  Vector<float> real_coef;
  Vector<float> imag_coef;

  if (options->hasReal()) {
    real_coef = options->real();
    if (options->hasImag()) {
      imag_coef = options->imag();
    } else {
      imag_coef.resize(real_coef.size());
    }
  } else if (options->hasImag()) {
    // `real()` not given, but we have `imag()`.
    imag_coef = options->imag();
    real_coef.resize(imag_coef.size());
  } else {
    // Neither `real()` nor `imag()` given.  Return an object that would
    // generate a sine wave, which means real = [0,0], and imag = [0, 1]
    real_coef.resize(2);
    imag_coef.resize(2);
    imag_coef[1] = 1;
  }

  return Create(*context, real_coef, imag_coef, normalize, exception_state);
}

PeriodicWave* PeriodicWave::CreateSine(float sample_rate) {
  PeriodicWave* periodic_wave = MakeGarbageCollected<PeriodicWave>(sample_rate);
  periodic_wave->impl()->GenerateBasicWaveform(OscillatorHandler::SINE);
  return periodic_wave;
}

PeriodicWave* PeriodicWave::CreateSquare(float sample_rate) {
  PeriodicWave* periodic_wave = MakeGarbageCollected<PeriodicWave>(sample_rate);
  periodic_wave->impl()->GenerateBasicWaveform(OscillatorHandler::SQUARE);
  return periodic_wave;
}

PeriodicWave* PeriodicWave::CreateSawtooth(float sample_rate) {
  PeriodicWave* periodic_wave = MakeGarbageCollected<PeriodicWave>(sample_rate);
  periodic_wave->impl()->GenerateBasicWaveform(OscillatorHandler::SAWTOOTH);
  return periodic_wave;
}

PeriodicWave* PeriodicWave::CreateTriangle(float sample_rate) {
  PeriodicWave* periodic_wave = MakeGarbageCollected<PeriodicWave>(sample_rate);
  periodic_wave->impl()->GenerateBasicWaveform(OscillatorHandler::TRIANGLE);
  return periodic_wave;
}

PeriodicWave::PeriodicWave(float sample_rate)
    : periodic_wave_impl_(MakeGarbageCollected<PeriodicWaveImpl>(sample_rate)) {
}

void PeriodicWave::Trace(Visitor* visitor) const {
  visitor->Trace(periodic_wave_impl_);
  ScriptWrappable::Trace(visitor);
}

PeriodicWaveImpl::PeriodicWaveImpl(float sample_rate)
    : sample_rate_(sample_rate), cents_per_range_(kCentsPerRange) {
  float nyquist = 0.5 * sample_rate_;
  lowest_fundamental_frequency_ = nyquist / MaxNumberOfPartials();
  rate_scale_ = PeriodicWaveSize() / sample_rate_;
  // Compute the number of ranges needed to cover the entire frequency range,
  // assuming kNumberOfOctaveBands per octave.
  number_of_ranges_ = 0.5 + kNumberOfOctaveBands * log2f(PeriodicWaveSize());
}

PeriodicWaveImpl::~PeriodicWaveImpl() {
  external_memory_accounter_.Clear(v8::Isolate::GetCurrent());
}

unsigned PeriodicWaveImpl::PeriodicWaveSize() const {
  // Choose an appropriate wave size for the given sample rate.  This allows us
  // to use shorter FFTs when possible to limit the complexity.  The breakpoints
  // here are somewhat arbitrary, but we want sample rates around 44.1 kHz or so
  // to have a size of 4096 to preserve backward compatibility.
  if (sample_rate_ <= 24000) {
    return 2048;
  }

  if (sample_rate_ <= 88200) {
    return 4096;
  }

  return kMaxPeriodicWaveSize;
}

unsigned PeriodicWaveImpl::MaxNumberOfPartials() const {
  return PeriodicWaveSize() / 2;
}

void PeriodicWaveImpl::WaveDataForFundamentalFrequency(
    float fundamental_frequency,
    float*& lower_wave_data,
    float*& higher_wave_data,
    float& table_interpolation_factor) {
  // Negative frequencies are allowed, in which case we alias to the positive
  // frequency.
  fundamental_frequency = fabsf(fundamental_frequency);

  // Calculate the pitch range.
  float ratio = fundamental_frequency > 0
                    ? fundamental_frequency / lowest_fundamental_frequency_
                    : 0.5;
  float cents_above_lowest_frequency = log2f(ratio) * 1200;

  // Add one to round-up to the next range just in time to truncate partials
  // before aliasing occurs.
  float pitch_range = 1 + cents_above_lowest_frequency / cents_per_range_;

  pitch_range = std::max(pitch_range, 0.0f);
  pitch_range = std::min(pitch_range, static_cast<float>(NumberOfRanges() - 1));

  // The words "lower" and "higher" refer to the table data having the lower and
  // higher numbers of partials.  It's a little confusing since the range index
  // gets larger the more partials we cull out.  So the lower table data will
  // have a larger range index.
  unsigned range_index1 = static_cast<unsigned>(pitch_range);
  unsigned range_index2 =
      range_index1 < NumberOfRanges() - 1 ? range_index1 + 1 : range_index1;

  lower_wave_data = band_limited_tables_[range_index2]->Data();
  higher_wave_data = band_limited_tables_[range_index1]->Data();

  // Ranges from 0 -> 1 to interpolate between lower -> higher.
  table_interpolation_factor = pitch_range - range_index1;
}

#if defined(ARCH_CPU_X86_FAMILY)
void PeriodicWaveImpl::WaveDataForFundamentalFrequency(
    const float fundamental_frequency[4],
    float* lower_wave_data[4],
    float* higher_wave_data[4],
    float table_interpolation_factor[4]) {
  // Negative frequencies are allowed, in which case we alias to the positive
  // frequency.  SSE2 doesn't have an fabs instruction, so just remove the sign
  // bit of the float numbers, effecitvely taking the absolute value.
  const __m128 frequency =
      _mm_and_ps(_mm_loadu_ps(fundamental_frequency),
                 reinterpret_cast<__m128>(_mm_set1_epi32(0x7fffffff)));

  // pos = 0xffffffff if freq > 0; otherwise 0
  const __m128 pos = _mm_cmpgt_ps(frequency, _mm_set1_ps(0));

  // Calculate the pitch range.
  __m128 v_ratio =
      _mm_div_ps(frequency, _mm_set1_ps(lowest_fundamental_frequency_));

  // Set v_ratio to 0 if freq <= 0; otherwise keep the ratio.
  v_ratio = _mm_and_ps(v_ratio, pos);

  // If pos = 0, set value to 0.5 and 0 otherwise.  Or this into v_ratio so that
  // v_ratio is 0.5 if freq <= 0.  Otherwise preserve v_ratio.
  v_ratio = _mm_or_ps(v_ratio, _mm_andnot_ps(pos, _mm_set1_ps(0.5)));

  const float* ratio = reinterpret_cast<float*>(&v_ratio);

  float cents_above_lowest_frequency[4] __attribute__((aligned(16)));

  for (int k = 0; k < 4; ++k) {
    cents_above_lowest_frequency[k] = log2f(ratio[k]) * 1200;
  }

  __m128 v_pitch_range = _mm_add_ps(
      _mm_set1_ps(1.0), _mm_div_ps(_mm_load_ps(cents_above_lowest_frequency),
                                   _mm_set1_ps((cents_per_range_))));
  v_pitch_range = _mm_max_ps(v_pitch_range, _mm_set1_ps(0.0));
  v_pitch_range = _mm_min_ps(v_pitch_range, _mm_set1_ps(NumberOfRanges() - 1));

  const __m128i v_index1 = _mm_cvttps_epi32(v_pitch_range);
  __m128i v_index2 = _mm_add_epi32(v_index1, _mm_set1_epi32(1));

  // SSE2 deosn't have _mm_min_epi32 (but SSE4.2 does).
  //
  // The following ought to work because the small integers for the index and
  // number of ranges should look like tiny denormals that should compare in the
  // same order as integers.  This doesn't work because we have flush-to-zero
  // enabled.
  //
  //   __m128i v_range = _mm_set1_epi32(NumberOfRanges() - 1);
  //  v_index2 = _mm_min_ps(v_index2, v_range);
  //
  // Instead we convert to float, take the min and convert back. No round off
  // because the integers are small.
  v_index2 = _mm_cvttps_epi32(
      _mm_min_ps(_mm_cvtepi32_ps(v_index2), _mm_set1_ps(NumberOfRanges() - 1)));

  const __m128 table_factor =
      _mm_sub_ps(v_pitch_range, _mm_cvtepi32_ps(v_index1));
  _mm_storeu_ps(table_interpolation_factor, table_factor);

  const unsigned* range_index1 = reinterpret_cast<const unsigned*>(&v_index1);
  const unsigned* range_index2 = reinterpret_cast<const unsigned*>(&v_index2);

  for (int k = 0; k < 4; ++k) {
    lower_wave_data[k] = band_limited_tables_[range_index2[k]]->Data();
    higher_wave_data[k] = band_limited_tables_[range_index1[k]]->Data();
  }
}
#elif defined(CPU_ARM_NEON)
void PeriodicWaveImpl::WaveDataForFundamentalFrequency(
    const float fundamental_frequency[4],
    float* lower_wave_data[4],
    float* higher_wave_data[4],
    float table_interpolation_factor[4]) {
  // Negative frequencies are allowed, in which case we alias to the positive
  // frequency.
  float32x4_t frequency = vabsq_f32(vld1q_f32(fundamental_frequency));

  // pos = 0xffffffff if frequency > 0; otherwise 0.
  uint32x4_t pos = vcgtq_f32(frequency, vdupq_n_f32(0));

  // v_ratio = frequency / lowest_fundamental_frequency_.  But NEON
  // doesn't have a division instruction, so multiply by reciprocal.
  // (Aarch64 does, though).
  float32x4_t v_ratio =
      vmulq_f32(frequency, vdupq_n_f32(1 / lowest_fundamental_frequency_));

  // Select v_ratio or 0.5 depending on whether pos is all ones or all
  // zeroes.
  v_ratio = vbslq_f32(pos, v_ratio, vdupq_n_f32(0.5));

  float ratio[4] __attribute__((aligned(16)));
  vst1q_f32(ratio, v_ratio);

  float cents_above_lowest_frequency[4] __attribute__((aligned(16)));

  for (int k = 0; k < 4; ++k) {
    cents_above_lowest_frequency[k] = log2f(ratio[k]) * 1200;
  }

  float32x4_t v_pitch_range = vaddq_f32(
      vdupq_n_f32(1.0), vmulq_f32(vld1q_f32(cents_above_lowest_frequency),
                                  vdupq_n_f32(1 / cents_per_range_)));

  v_pitch_range = vmaxq_f32(v_pitch_range, vdupq_n_f32(0));
  v_pitch_range = vminq_f32(v_pitch_range, vdupq_n_f32(NumberOfRanges() - 1));

  const uint32x4_t v_index1 = vcvtq_u32_f32(v_pitch_range);
  uint32x4_t v_index2 = vaddq_u32(v_index1, vdupq_n_u32(1));
  v_index2 = vminq_u32(v_index2, vdupq_n_u32(NumberOfRanges() - 1));

  uint32_t range_index1[4] __attribute__((aligned(16)));
  uint32_t range_index2[4] __attribute__((aligned(16)));

  vst1q_u32(range_index1, v_index1);
  vst1q_u32(range_index2, v_index2);

  const float32x4_t table_factor =
      vsubq_f32(v_pitch_range, vcvtq_f32_u32(v_index1));
  vst1q_f32(table_interpolation_factor, table_factor);

  for (int k = 0; k < 4; ++k) {
    lower_wave_data[k] = band_limited_tables_[range_index2[k]]->Data();
    higher_wave_data[k] = band_limited_tables_[range_index1[k]]->Data();
  }
}
#else
void PeriodicWaveImpl::WaveDataForFundamentalFrequency(
    const float fundamental_frequency[4],
    float* lower_wave_data[4],
    float* higher_wave_data[4],
    float table_interpolation_factor[4]) {
  for (int k = 0; k < 4; ++k) {
    WaveDataForFundamentalFrequency(fundamental_frequency[k],
                                    lower_wave_data[k], higher_wave_data[k],
                                    table_interpolation_factor[k]);
  }
}
#endif

unsigned PeriodicWaveImpl::NumberOfPartialsForRange(
    unsigned range_index) const {
  // Number of cents below nyquist where we cull partials.
  float cents_to_cull = range_index * cents_per_range_;

  // A value from 0 -> 1 representing what fraction of the partials to keep.
  float culling_scale = pow(2, -cents_to_cull / 1200);

  // The very top range will have all the partials culled.
  unsigned number_of_partials = culling_scale * MaxNumberOfPartials();

  return number_of_partials;
}

// Convert into time-domain wave buffers.  One table is created for each range
// for non-aliasing playback at different playback rates.  Thus, higher ranges
// have more high-frequency partials culled out.
void PeriodicWaveImpl::CreateBandLimitedTables(const float* real_data,
                                               const float* imag_data,
                                               unsigned number_of_components,
                                               bool disable_normalization) {
  // The default scale factor for when normalization is disabled.
  float normalization_scale = 0.5;

  unsigned fft_size = PeriodicWaveSize();
  unsigned half_size = fft_size / 2;
  unsigned i;

  number_of_components = std::min(number_of_components, half_size);

  band_limited_tables_.reserve(NumberOfRanges());

  FFTFrame frame(fft_size);
  for (unsigned range_index = 0; range_index < NumberOfRanges();
       ++range_index) {
    // This FFTFrame is used to cull partials (represented by frequency bins).
    AudioFloatArray& real = frame.RealData();
    DCHECK_GE(real.size(), number_of_components);
    AudioFloatArray& imag = frame.ImagData();
    DCHECK_GE(imag.size(), number_of_components);

    // Copy from loaded frequency data and generate the complex conjugate
    // because of the way the inverse FFT is defined versus the values in the
    // arrays.  Need to scale the data by fftSize to remove the scaling that the
    // inverse IFFT would do.
    float scale = fft_size;
    vector_math::Vsmul(
        real_data, 1, &scale, real.Data(), 1, number_of_components);
    scale = -scale;
    vector_math::Vsmul(
        imag_data, 1, &scale, imag.Data(), 1, number_of_components);

    // Find the starting bin where we should start culling.  We need to clear
    // out the highest frequencies to band-limit the waveform.
    unsigned number_of_partials = NumberOfPartialsForRange(range_index);

    // If fewer components were provided than 1/2 FFT size, then clear the
    // remaining bins.  We also need to cull the aliasing partials for this
    // pitch range.
    for (i = std::min(number_of_components, number_of_partials + 1);
         i < half_size; ++i) {
      real[i] = 0;
      imag[i] = 0;
    }

    // Clear packed-nyquist and any DC-offset.
    real[0] = 0;
    imag[0] = 0;

    // Create the band-limited table.
    unsigned wave_size = PeriodicWaveSize();
    std::unique_ptr<AudioFloatArray> table =
        std::make_unique<AudioFloatArray>(wave_size);
    external_memory_accounter_.Increase(v8::Isolate::GetCurrent(),
                                        wave_size * sizeof(float));
    band_limited_tables_.push_back(std::move(table));

    // Apply an inverse FFT to generate the time-domain table data.
    float* data = band_limited_tables_[range_index]->Data();
    frame.DoInverseFFT(data);

    // For the first range (which has the highest power), calculate its peak
    // value then compute normalization scale.
    if (!disable_normalization) {
      if (!range_index) {
        float max_value;
        vector_math::Vmaxmgv(data, 1, &max_value, fft_size);

        if (max_value) {
          normalization_scale = 1.0f / max_value;
        }
      }
    }

    // Apply normalization scale.
    vector_math::Vsmul(data, 1, &normalization_scale, data, 1, fft_size);
  }
}

void PeriodicWaveImpl::GenerateBasicWaveform(int shape) {
  unsigned fft_size = PeriodicWaveSize();
  unsigned half_size = fft_size / 2;

  AudioFloatArray real(half_size);
  AudioFloatArray imag(half_size);
  float* real_p = real.Data();
  float* imag_p = imag.Data();

  // Clear DC and Nyquist.
  real_p[0] = 0;
  imag_p[0] = 0;

  for (unsigned n = 1; n < half_size; ++n) {
    float pi_factor = 2 / (n * kPiFloat);

    // All waveforms are odd functions with a positive slope at time 0. Hence
    // the coefficients for cos() are always 0.

    // Fourier coefficients according to standard definition:
    // b = 1/pi*integrate(f(x)*sin(n*x), x, -pi, pi)
    //   = 2/pi*integrate(f(x)*sin(n*x), x, 0, pi)
    // since f(x) is an odd function.

    float b;  // Coefficient for sin().

    // Calculate Fourier coefficients depending on the shape. Note that the
    // overall scaling (magnitude) of the waveforms is normalized in
    // createBandLimitedTables().
    switch (shape) {
      case OscillatorHandler::SINE:
        // Standard sine wave function.
        b = (n == 1) ? 1 : 0;
        break;
      case OscillatorHandler::SQUARE:
        // Square-shaped waveform with the first half its maximum value and the
        // second half its minimum value.
        //
        // See http://mathworld.wolfram.com/FourierSeriesSquareWave.html
        //
        // b[n] = 2/n/pi*(1-(-1)^n)
        //      = 4/n/pi for n odd and 0 otherwise.
        //      = 2*(2/(n*pi)) for n odd
        b = (n & 1) ? 2 * pi_factor : 0;
        break;
      case OscillatorHandler::SAWTOOTH:
        // Sawtooth-shaped waveform with the first half ramping from zero to
        // maximum and the second half from minimum to zero.
        //
        // b[n] = -2*(-1)^n/pi/n
        //      = (2/(n*pi))*(-1)^(n+1)
        b = pi_factor * ((n & 1) ? 1 : -1);
        break;
      case OscillatorHandler::TRIANGLE:
        // Triangle-shaped waveform going from 0 at time 0 to 1 at time pi/2 and
        // back to 0 at time pi.
        //
        // See http://mathworld.wolfram.com/FourierSeriesTriangleWave.html
        //
        // b[n] = 8*sin(pi*k/2)/(pi*k)^2
        //      = 8/pi^2/n^2*(-1)^((n-1)/2) for n odd and 0 otherwise
        //      = 2*(2/(n*pi))^2 * (-1)^((n-1)/2)
        if (n & 1) {
          b = 2 * (pi_factor * pi_factor) * ((((n - 1) >> 1) & 1) ? -1 : 1);
        } else {
          b = 0;
        }
        break;
      default:
        NOTREACHED();
    }

    real_p[n] = 0;
    imag_p[n] = b;
  }

  CreateBandLimitedTables(real_p, imag_p, half_size, false);
}

}  // namespace blink

"""

```
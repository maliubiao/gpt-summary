Response:
Let's break down the thought process for analyzing the provided C++ code snippet. The goal is to understand the functionality of `WebSocketChannelImpl.cc` within the Chromium Blink engine, especially its interactions with JavaScript, HTML, and CSS, common user errors, debugging tips, and a final summary.

**1. Initial Skim and Keyword Identification:**

First, a quick read-through to get a general sense. Keywords like "WebSocket," "channel," "connect," "send," "receive," "close," "handshake," "Blob," "ArrayBuffer," "mojo," and "JavaScript" immediately jump out. This suggests the file is responsible for the low-level implementation of WebSocket communication within the rendering engine.

**2. High-Level Functionality Deduction:**

Based on the keywords and the file path (`blink/renderer/modules/websockets/`), the core function is clearly managing WebSocket connections. This involves:

* **Establishing connections:**  The `Connect` method is a prime indicator.
* **Sending data:**  The various `Send` overloads for strings, Blobs, and ArrayBuffers point to this.
* **Receiving data:**  Methods like `OnDataFrame` suggest handling incoming messages.
* **Closing connections:** The `Close` method.
* **Handling errors:**  `OnFailure`, `TearDownFailedConnection`.
* **Managing state:**  The `State` enum and related logic.
* **Integration with the browser process:** The use of Mojo (inter-process communication).

**3. Relationship to JavaScript, HTML, and CSS:**

* **JavaScript:** This is the primary interface for web developers to use WebSockets. The C++ code implements the underlying mechanisms that JavaScript `WebSocket` objects interact with. Look for callbacks and event handling that would be triggered by JS events (e.g., `onopen`, `onmessage`, `onclose`, `onerror`).
* **HTML:**  HTML triggers WebSocket connections when JavaScript code within the page initiates them. The `<script>` tag and inline JavaScript are the entry points.
* **CSS:**  CSS has no direct relationship with the core functionality of WebSockets. However, CSS might be used to style elements that display information related to WebSocket status or messages.

**4. Detailed Code Examination (Focusing on Key Areas):**

* **`Connect()`:**  This method is crucial. Analyze its steps:
    * Mixed content checks:  Relates to web security and browser behavior.
    * Feature registration for BFCache: Shows interaction with browser optimization.
    * Mojo usage (`WebSocketConnector`):  Highlights the browser process interaction.
    * Throttling (`WebSocketHandshakeThrottle`): Indicates resource management.
    * DevTools integration (`probe::WillCreateWebSocket`):  Shows how debugging tools interact.
* **`Send()` overloads:** Note the different data types handled (string, Blob, ArrayBuffer) and how they are converted for sending over the wire.
* **`OnDataFrame()`:** How incoming data is processed and passed to the client.
* **State Management:** Understand the different states (`kConnecting`, `kOpen`, `kDisconnected`) and how transitions occur.
* **Error Handling:**  How failures are reported and handled.
* **Mojo Interactions:**  Identify the Mojo interfaces used (`WebSocketConnector`, `WebSocket`, `WebSocketClient`) and the flow of communication.
* **Blob Handling:** The `BlobLoader` class is a separate component for handling Blob data sent over the WebSocket.

**5. Logic and Assumptions (Hypothetical Input/Output):**

Consider a simple scenario:

* **Input (JavaScript):** `const ws = new WebSocket('ws://example.com'); ws.send('hello');`
* **Assumptions (Internal):** The browser resolves `example.com`, a network connection is established, the WebSocket handshake succeeds.
* **Output (Internal):** The `Connect` method would be called, a Mojo connection to the browser process would be established, the handshake would proceed, and the `Send` method would queue the "hello" message. Eventually, `MaybeSendSynchronously` or the asynchronous sending mechanism would transmit the data.

**6. Common User Errors:**

Think about what developers might do wrong when using WebSockets:

* Incorrect WebSocket URL (`ws://` vs. `wss://`).
* Trying to send data before the connection is open.
* Not handling close and error events properly.
* Exceeding message size limits (though not explicitly checked in *this* snippet, it's a general WebSocket concern).
* Mixed content issues (connecting from HTTPS to WS).

**7. Debugging Clues:**

Consider how a developer could trace the execution to this code:

* **Browser DevTools Network Tab:** Inspect WebSocket frames.
* **`chrome://net-internals/#websocket`:** More detailed WebSocket logging.
* **Setting breakpoints in the C++ code:**  If the developer has access to the Chromium source.
* **Console messages:** Look for errors or warnings generated by this code.
* **Tracing/Profiling:** More advanced techniques to follow the execution flow.

**8. Structuring the Output:**

Organize the findings logically, addressing each part of the prompt: functionality, JavaScript/HTML/CSS relationships, logical推理 (input/output), user errors, debugging, and the summary. Use clear language and examples.

**9. Iteration and Refinement:**

Review the analysis and ensure accuracy. Fill in any gaps in understanding. For instance, initially, I might not have fully grasped the role of the `WebSocketHandshakeThrottle`. A closer reading of the `Connect` method and the `OnCompletion` callback clarifies its purpose.

By following these steps, we can systematically dissect the C++ code and generate a comprehensive explanation of its functionality and context within the Chromium Blink engine. The process involves a combination of code reading, keyword analysis, logical deduction, and consideration of the developer's perspective.
```
这是目录为blink/renderer/modules/websockets/websocket_channel_impl.cc的chromium blink引擎源代码文件， 请列举一下它的功能,
如果它与javascript, html, css的功能有关系，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索。
这是第1部分，共2部分，请归纳一下它的功能
```

根据提供的代码片段（第一部分），`websocket_channel_impl.cc` 的主要功能是实现 Chromium Blink 引擎中 WebSocket 通道的核心逻辑。 它负责处理 WebSocket 连接的建立、数据发送、数据接收、连接关闭和错误处理等关键步骤。

**主要功能列举：**

1. **WebSocket 连接的建立 (`Connect`):**
   - 接收来自 JavaScript 的连接请求（URL，可选的子协议）。
   - 执行混合内容检查，阻止从安全来源连接到非安全 WebSocket 服务器。
   - 注册 BFCache 特性，可能禁用页面的往返缓存以保证 WebSocket 连接的正常运行。
   - 限制同时打开的 WebSocket 连接数量，防止资源耗尽或 DoS 攻击。
   - 通过 Mojo 与浏览器进程中的 WebSocketConnector 通信，发起连接握手。
   - 使用 `WebSocketHandshakeThrottle` 进行连接节流控制（如果配置）。
   - 发送 DevTools 事件，用于开发者工具的监控。

2. **数据发送 (`Send`):**
   - 接收来自 JavaScript 发送字符串、Blob 或 ArrayBuffer 数据的请求。
   - 将数据封装成消息对象。
   - 尝试同步发送消息以提高效率（如果可能）。
   - 如果无法同步发送，则将消息添加到发送队列。
   - 当 WebSocket 连接可写时，处理发送队列中的消息。
   - 发送 DevTools 事件，用于开发者工具的监控。

3. **连接关闭 (`Close`):**
   - 接收来自 JavaScript 的关闭连接请求（可选的关闭代码和原因）。
   - 将关闭消息添加到发送队列，以便优雅地关闭连接。
   - 清理 BFCache 相关的特性。

4. **连接失败 (`Fail`):**
   - 处理连接建立或运行时发生的错误。
   - 向控制台输出错误信息。
   - 调用 `TearDownFailedConnection` 来断开连接。

5. **连接断开 (`Disconnect`):**
   - 立即终止 WebSocket 连接。
   - 清理资源。
   - 发送 DevTools 事件。

6. **处理服务器发来的消息：**
   - 通过 Mojo 接收来自浏览器进程的 WebSocket 消息（数据帧、关闭帧等）。
   - `OnDataFrame`: 处理接收到的数据帧，并将其传递给 `WebSocketChannelClient`。
   - `OnDropChannel`: 处理连接关闭事件。
   - `OnClosingHandshake`: 处理服务器发起的关闭握手。

7. **处理握手过程：**
   - `OnOpeningHandshakeStarted`: 记录握手请求信息。
   - `OnFailure`: 处理握手失败的情况。
   - `OnConnectionEstablished`: 处理握手成功的情况，绑定 WebSocket 和 WebSocketClient 的 Mojo 接口，开始接收数据。

8. **Backpressure 控制 (`ApplyBackpressure`, `RemoveBackpressure`):**
   - 允许接收端通知发送端减缓发送速度，以防止缓冲区溢出。

9. **Blob 数据处理 (`BlobLoader`):**
   -  对于通过 Blob 发送的数据，使用 `BlobLoader` 读取 Blob 的内容并进行发送。

**与 JavaScript, HTML, CSS 的关系：**

* **JavaScript:** `WebSocketChannelImpl` 是 JavaScript `WebSocket` API 的底层实现。当 JavaScript 代码创建 `WebSocket` 对象并调用 `send()`, `close()` 等方法时，最终会调用到 `WebSocketChannelImpl` 中的相应方法。例如：
    ```javascript
    const ws = new WebSocket('ws://example.com'); // 触发 WebSocketChannelImpl::Connect
    ws.send('Hello, WebSocket!'); // 触发 WebSocketChannelImpl::Send
    ws.close(); // 触发 WebSocketChannelImpl::Close
    ws.onerror = (event) => { /* ... */ }; // 间接关联 WebSocketChannelImpl::Fail 等错误处理
    ws.onmessage = (event) => { /* ... */ }; // 间接关联 WebSocketChannelImpl 处理接收到的数据
    ```

* **HTML:** HTML 本身不直接与 `WebSocketChannelImpl` 交互。但是，HTML 文件中嵌入的 JavaScript 代码可以通过 `WebSocket` API 来触发 `WebSocketChannelImpl` 的功能。例如，HTML 中的 `<script>` 标签内的 JavaScript 代码可以创建和操作 WebSocket 连接。

* **CSS:** CSS 与 `WebSocketChannelImpl` 的功能没有直接关系。CSS 负责页面的样式和布局，而 `WebSocketChannelImpl` 负责网络通信。

**逻辑推理（假设输入与输出）：**

假设 JavaScript 代码执行以下操作：

* **假设输入 (JavaScript):**
  ```javascript
  const ws = new WebSocket('ws://example.com/chat');
  ws.send('User1: Hello');
  ```

* **逻辑推理 (WebSocketChannelImpl 内部流程):**
  1. `Connect('ws://example.com/chat', '')` 被调用。
  2. 进行混合内容检查（假设通过）。
  3. 通过 Mojo 向浏览器进程发送连接请求。
  4. 假设握手成功，`OnConnectionEstablished` 被调用，建立连接。
  5. `Send('User1: Hello', ...)` 被调用。
  6. 消息 "User1: Hello" 被添加到发送队列。
  7. 当连接可写时，该消息通过 Mojo 发送到服务器。

* **假设输出 (网络层或服务器端):**
  一个 WebSocket 帧，包含 "User1: Hello" 的数据被发送到 `ws://example.com/chat` 服务器。

**用户或编程常见的使用错误：**

1. **尝试在连接建立之前发送数据:**
   - **错误示例 (JavaScript):**
     ```javascript
     const ws = new WebSocket('ws://example.com');
     ws.send('This will likely fail or be queued.'); // 在 'onopen' 事件触发前发送
     ws.onopen = () => {
       console.log('WebSocket connected');
     };
     ```
   - **WebSocketChannelImpl 的处理:**  `Send` 方法会将消息添加到队列，等待连接建立后再发送。但如果连接建立失败，消息可能永远无法发送。

2. **连接到不安全的 WebSocket 服务器 (从 HTTPS 页面):**
   - **错误示例 (JavaScript):**
     ```javascript
     const ws = new WebSocket('ws://insecure.example.com'); // 从 HTTPS 页面连接到 WS
     ```
   - **WebSocketChannelImpl 的处理:** `Connect` 方法中的混合内容检查会阻止这种连接，并可能在控制台中输出警告或错误。

3. **未处理 `onerror` 和 `onclose` 事件:**
   - **错误示例 (JavaScript):** 没有为 WebSocket 对象添加 `onerror` 或 `onclose` 事件处理程序。
   - **WebSocketChannelImpl 的处理:**  `Fail` 和 `OnDropChannel` 方法会被调用，但如果 JavaScript 没有监听这些事件，应用程序可能无法正确处理连接错误或关闭。

**用户操作如何一步步到达这里 (调试线索)：**

1. **用户在浏览器地址栏输入或点击一个包含 WebSocket 连接的网页链接。**
2. **浏览器加载 HTML 页面，并解析页面中的 JavaScript 代码。**
3. **JavaScript 代码创建 `WebSocket` 对象，例如 `const ws = new WebSocket('ws://example.com');`。**
4. **`WebSocket` 构造函数在 Blink 引擎中会创建对应的 `WebSocketChannel` 对象，最终会创建 `WebSocketChannelImpl` 对象。**
5. **`WebSocketChannelImpl::Connect` 方法被调用，开始 WebSocket 连接的握手过程。**
6. **如果 JavaScript 代码调用 `ws.send('...')`，则会调用 `WebSocketChannelImpl::Send` 方法。**
7. **如果 WebSocket 连接遇到错误（例如服务器拒绝连接），`WebSocketChannelImpl::Fail` 方法会被调用。**
8. **如果用户关闭页面或 JavaScript 代码调用 `ws.close()`，则会调用 `WebSocketChannelImpl::Close` 方法。**

**总结（第一部分功能归纳）：**

`WebSocketChannelImpl` 的第一部分代码主要负责 WebSocket 连接的 **建立和初始化**，以及 **数据发送的准备和初步处理**。它处理了连接开始时的关键步骤，包括安全性检查、资源管理、与浏览器进程的通信以及初始的握手过程。同时，它也定义了数据发送的基本流程，包括消息的封装和排队。 简而言之，这部分代码是 WebSocket 通信的起点和数据发送的初步通道。

### 提示词
```
这是目录为blink/renderer/modules/websockets/websocket_channel_impl.cc的chromium blink引擎源代码文件， 请列举一下它的功能, 
如果它与javascript, html, css的功能有关系，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索。
这是第1部分，共2部分，请归纳一下它的功能
```

### 源代码
```cpp
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifdef UNSAFE_BUFFERS_BUILD
// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
#pragma allow_unsafe_buffers
#endif

#include "third_party/blink/renderer/modules/websockets/websocket_channel_impl.h"

#include <string.h>

#include <algorithm>
#include <atomic>
#include <limits>
#include <memory>

#include "base/compiler_specific.h"
#include "base/containers/span.h"
#include "base/feature_list.h"
#include "base/functional/callback.h"
#include "base/location.h"
#include "base/memory/ptr_util.h"
#include "base/task/single_thread_task_runner.h"
#include "base/types/strong_alias.h"
#include "third_party/blink/public/mojom/websockets/websocket_connector.mojom-blink.h"
#include "third_party/blink/public/platform/browser_interface_broker_proxy.h"
#include "third_party/blink/public/platform/platform.h"
#include "third_party/blink/public/platform/task_type.h"
#include "third_party/blink/public/platform/web_security_origin.h"
#include "third_party/blink/public/platform/web_url.h"
#include "third_party/blink/public/platform/websocket_handshake_throttle.h"
#include "third_party/blink/renderer/bindings/core/v8/capture_source_location.h"
#include "third_party/blink/renderer/core/execution_context/execution_context.h"
#include "third_party/blink/renderer/core/fileapi/file_error.h"
#include "third_party/blink/renderer/core/fileapi/file_reader_client.h"
#include "third_party/blink/renderer/core/fileapi/file_reader_loader.h"
#include "third_party/blink/renderer/core/frame/local_frame.h"
#include "third_party/blink/renderer/core/inspector/console_message.h"
#include "third_party/blink/renderer/core/loader/base_fetch_context.h"
#include "third_party/blink/renderer/core/loader/mixed_content_checker.h"
#include "third_party/blink/renderer/core/loader/subresource_filter.h"
#include "third_party/blink/renderer/core/page/chrome_client.h"
#include "third_party/blink/renderer/core/page/page.h"
#include "third_party/blink/renderer/core/probe/core_probes.h"
#include "third_party/blink/renderer/core/typed_arrays/dom_array_buffer.h"
#include "third_party/blink/renderer/modules/websockets/inspector_websocket_events.h"
#include "third_party/blink/renderer/modules/websockets/websocket_channel_client.h"
#include "third_party/blink/renderer/platform/bindings/dom_wrapper_world.h"
#include "third_party/blink/renderer/platform/heap/garbage_collected.h"
#include "third_party/blink/renderer/platform/loader/fetch/resource_fetcher.h"
#include "third_party/blink/renderer/platform/loader/fetch/unique_identifier.h"
#include "third_party/blink/renderer/platform/scheduler/public/frame_scheduler.h"
#include "third_party/blink/renderer/platform/weborigin/security_origin.h"
#include "third_party/blink/renderer/platform/wtf/allocator/partitions.h"
#include "third_party/blink/renderer/platform/wtf/functional.h"
#include "third_party/blink/renderer/platform/wtf/shared_buffer.h"
#include "third_party/blink/renderer/platform/wtf/std_lib_extras.h"
#include "third_party/blink/renderer/platform/wtf/text/ascii_ctype.h"
#include "third_party/blink/renderer/platform/wtf/text/string_buffer.h"
#include "third_party/blink/renderer/platform/wtf/text/string_builder.h"
#include "third_party/blink/renderer/platform/wtf/text/string_impl.h"
#include "v8/include/v8.h"

namespace blink {

namespace {

// The number of connecting or connected WebSocketChannelImpl objects that
// currently exist. This needs to be threadsafe because there may also be
// Workers in the same process. This is default-initialised to 0 because it has
// static storage.
std::atomic_size_t g_connection_count;

enum WebSocketOpCode {
  kOpCodeText = 0x1,
  kOpCodeBinary = 0x2,
};

}  // namespace

WebSocketChannelImpl::MessageDataDeleter::MessageDataDeleter(
    v8::Isolate* isolate,
    size_t size)
    : isolate_(isolate), size_(size) {
  external_memory_accounter_.Increase(isolate, size);
}

void WebSocketChannelImpl::MessageDataDeleter::operator()(char* p) const {
  DCHECK(isolate_) << "Cannot call deleter when default constructor was used";
  external_memory_accounter_.Decrease(isolate_.get(), size_);
  WTF::Partitions::FastFree(p);
}

// static
WebSocketChannelImpl::MessageData WebSocketChannelImpl::CreateMessageData(
    v8::Isolate* isolate,
    size_t message_size) {
  return MessageData(
      static_cast<char*>(WTF::Partitions::FastMalloc(
          message_size, "blink::WebSockChannelImpl::MessageData")),
      MessageDataDeleter(isolate, message_size));
}

class WebSocketChannelImpl::BlobLoader final
    : public GarbageCollected<WebSocketChannelImpl::BlobLoader>,
      public FileReaderClient {
 public:
  BlobLoader(scoped_refptr<BlobDataHandle>,
             WebSocketChannelImpl*,
             scoped_refptr<base::SingleThreadTaskRunner>);
  ~BlobLoader() override = default;

  void Cancel();

  // FileReaderClient functions.
  FileErrorCode DidStartLoading(uint64_t) override;
  FileErrorCode DidReceiveData(base::span<const uint8_t> data) override;
  void DidFinishLoading() override;
  void DidFail(FileErrorCode) override;

  void Trace(Visitor* visitor) const override {
    FileReaderClient::Trace(visitor);
    visitor->Trace(channel_);
    visitor->Trace(loader_);
  }

 private:
  Member<WebSocketChannelImpl> channel_;
  Member<FileReaderLoader> loader_;
  // This doesn't use WTF::Vector because it doesn't currently support 64-bit
  // sizes.
  MessageData data_;
  size_t size_ = 0;
  size_t offset_ = 0;

  bool blob_too_large_ = false;
};

WebSocketChannelImpl::BlobLoader::BlobLoader(
    scoped_refptr<BlobDataHandle> blob_data_handle,
    WebSocketChannelImpl* channel,
    scoped_refptr<base::SingleThreadTaskRunner> task_runner)
    : channel_(channel),
      loader_(MakeGarbageCollected<FileReaderLoader>(this,
                                                     std::move(task_runner))) {
  loader_->Start(std::move(blob_data_handle));
}

void WebSocketChannelImpl::BlobLoader::Cancel() {
  loader_->Cancel();
  loader_ = nullptr;
  data_ = nullptr;
}

FileErrorCode WebSocketChannelImpl::BlobLoader::DidStartLoading(uint64_t) {
  const std::optional<uint64_t> size = loader_->TotalBytes();
  DCHECK(size);
  if (size.value() > std::numeric_limits<size_t>::max()) {
    blob_too_large_ = true;
    return FileErrorCode::kAbortErr;
  }
  size_ = static_cast<size_t>(size.value());
  data_ = WebSocketChannelImpl::CreateMessageData(
      channel_->execution_context_->GetIsolate(), size_);
  return FileErrorCode::kOK;
}

FileErrorCode WebSocketChannelImpl::BlobLoader::DidReceiveData(
    base::span<const uint8_t> data) {
  auto remaining_message = base::span(data_.get(), size_).subspan(offset_);
  const size_t data_to_copy = std::min(remaining_message.size(), data.size());
  if (!data_to_copy) {
    return FileErrorCode::kOK;
  }
  remaining_message.copy_prefix_from(base::as_chars(data.first(data_to_copy)));
  offset_ += data_to_copy;
  return FileErrorCode::kOK;
}

void WebSocketChannelImpl::BlobLoader::DidFinishLoading() {
  // This is guaranteed by FileReaderLoader::OnDataPipeReadable.
  DCHECK_EQ(offset_, size_);
  channel_->DidFinishLoadingBlob(std::move(data_), size_);
  loader_ = nullptr;
}

void WebSocketChannelImpl::BlobLoader::DidFail(FileErrorCode error_code) {
  if (error_code == FileErrorCode::kAbortErr && blob_too_large_) {
    blob_too_large_ = false;
    channel_->BlobTooLarge();
  }
  channel_->DidFailLoadingBlob(error_code);
  loader_ = nullptr;
  data_ = nullptr;
}

struct WebSocketChannelImpl::ConnectInfo {
  ConnectInfo(const String& selected_protocol, const String& extensions)
      : selected_protocol(selected_protocol), extensions(extensions) {}

  const String selected_protocol;
  const String extensions;
};

// static
WebSocketChannelImpl* WebSocketChannelImpl::CreateForTesting(
    ExecutionContext* execution_context,
    WebSocketChannelClient* client,
    std::unique_ptr<SourceLocation> location,
    std::unique_ptr<WebSocketHandshakeThrottle> handshake_throttle) {
  auto* channel = MakeGarbageCollected<WebSocketChannelImpl>(
      execution_context, client, std::move(location));
  channel->handshake_throttle_ = std::move(handshake_throttle);
  return channel;
}

// static
WebSocketChannelImpl* WebSocketChannelImpl::Create(
    ExecutionContext* execution_context,
    WebSocketChannelClient* client,
    std::unique_ptr<SourceLocation> location) {
  auto* channel = MakeGarbageCollected<WebSocketChannelImpl>(
      execution_context, client, std::move(location));
  channel->handshake_throttle_ =
      channel->GetBaseFetchContext()->CreateWebSocketHandshakeThrottle();
  return channel;
}

WebSocketChannelImpl::WebSocketChannelImpl(
    ExecutionContext* execution_context,
    WebSocketChannelClient* client,
    std::unique_ptr<SourceLocation> location)
    : client_(client),
      identifier_(CreateUniqueIdentifier()),
      message_chunks_(MakeGarbageCollected<WebSocketMessageChunkAccumulator>(
          execution_context->GetTaskRunner(TaskType::kNetworking))),
      execution_context_(execution_context),
      location_at_construction_(std::move(location)),
      websocket_(execution_context),
      handshake_client_receiver_(this, execution_context),
      client_receiver_(this, execution_context),
      readable_watcher_(
          FROM_HERE,
          mojo::SimpleWatcher::ArmingPolicy::MANUAL,
          execution_context->GetTaskRunner(TaskType::kNetworking)),
      writable_watcher_(
          FROM_HERE,
          mojo::SimpleWatcher::ArmingPolicy::MANUAL,
          execution_context->GetTaskRunner(TaskType::kNetworking)),
      file_reading_task_runner_(
          execution_context->GetTaskRunner(TaskType::kFileReading)) {}

WebSocketChannelImpl::~WebSocketChannelImpl() = default;

bool WebSocketChannelImpl::Connect(const KURL& url, const String& protocol) {
  DVLOG(1) << this << " Connect()";

  if (GetBaseFetchContext()->ShouldBlockWebSocketByMixedContentCheck(url)) {
    has_initiated_opening_handshake_ = false;
    return false;
  }

  if (auto* scheduler = execution_context_->GetScheduler()) {
    // Two features are registered here:
    // - `kWebSocket`: a non-sticky feature that will disable BFCache for any
    // page. It will be reset after the `WebSocketChannel` is closed.
    // - `kWebSocketSticky`: a sticky feature that will only disable BFCache for
    // the page containing "Cache-Control: no-store" header. It won't be reset
    // even if the `WebSocketChannel` is closed.
    feature_handle_for_scheduler_ = scheduler->RegisterFeature(
        SchedulingPolicy::Feature::kWebSocket,
        SchedulingPolicy{SchedulingPolicy::DisableBackForwardCache()});
    scheduler->RegisterStickyFeature(
        SchedulingPolicy::Feature::kWebSocketSticky,
        SchedulingPolicy{SchedulingPolicy::DisableBackForwardCache()});
  }

  if (MixedContentChecker::IsMixedContent(
          execution_context_->GetSecurityOrigin(), url)) {
    String message =
        "Connecting to a non-secure WebSocket server from a secure origin is "
        "deprecated.";
    execution_context_->AddConsoleMessage(MakeGarbageCollected<ConsoleMessage>(
        mojom::blink::ConsoleMessageSource::kJavaScript,
        mojom::blink::ConsoleMessageLevel::kWarning, message));
  }

  url_ = url;
  Vector<String> protocols;
  // Avoid placing an empty token in the Vector when the protocol string is
  // empty.
  if (!protocol.empty()) {
    // Since protocol is already verified and escaped, we can simply split
    // it.
    protocol.Split(", ", true, protocols);
  }

  // If the connection needs to be filtered, asynchronously fail. Synchronous
  // failure blocks the worker thread which should be avoided. Note that
  // returning "true" just indicates that this was not a mixed content error.
  if (ShouldDisallowConnection(url)) {
    execution_context_->GetTaskRunner(TaskType::kNetworking)
        ->PostTask(
            FROM_HERE,
            WTF::BindOnce(&WebSocketChannelImpl::TearDownFailedConnection,
                          WrapPersistent(this)));
    return true;
  }

  // Restrict the number of simultaneous connections to avoid a DoS attack on
  // the browser process. Fail asynchronously, to match the behaviour when we
  // are throttled by the network service.
  if (connection_count_tracker_handle_.IncrementAndCheckStatus() ==
      ConnectionCountTrackerHandle::CountStatus::kShouldNotConnect) {
    StringBuilder message;
    message.Append("WebSocket connection to '");
    message.Append(url.GetString());
    message.Append("' failed: Insufficient resources");
    execution_context_->AddConsoleMessage(MakeGarbageCollected<ConsoleMessage>(
        mojom::blink::ConsoleMessageSource::kNetwork,
        mojom::blink::ConsoleMessageLevel::kError, message.ToString()));
    execution_context_->GetTaskRunner(TaskType::kNetworking)
        ->PostTask(
            FROM_HERE,
            WTF::BindOnce(&WebSocketChannelImpl::TearDownFailedConnection,
                          WrapPersistent(this)));
    return true;
  }

  mojo::Remote<mojom::blink::WebSocketConnector> connector;
  execution_context_->GetBrowserInterfaceBroker().GetInterface(
      connector.BindNewPipeAndPassReceiver(
          execution_context_->GetTaskRunner(TaskType::kWebSocket)));

  std::optional<base::UnguessableToken> devtools_token;
  probe::WillCreateWebSocket(execution_context_, identifier_, url, protocol,
                             &devtools_token);

  connector->Connect(
      url, protocols, GetBaseFetchContext()->GetSiteForCookies(),
      execution_context_->UserAgent(),
      execution_context_->GetStorageAccessApiStatus(),
      handshake_client_receiver_.BindNewPipeAndPassRemote(
          execution_context_->GetTaskRunner(TaskType::kWebSocket)),
      /*throttling_profile_id=*/devtools_token);
  handshake_client_receiver_.set_disconnect_with_reason_handler(
      WTF::BindOnce(&WebSocketChannelImpl::OnConnectionError,
                    WrapWeakPersistent(this), FROM_HERE));
  has_initiated_opening_handshake_ = true;

  if (handshake_throttle_) {
    scoped_refptr<const SecurityOrigin> isolated_security_origin;
    const DOMWrapperWorld* world = execution_context_->GetCurrentWorld();
    // TODO(crbug.com/40511450): Current world can be null because of PPAPI.
    // Null check can be cleaned up once PPAPI support is removed.
    if (world && world->IsIsolatedWorld()) {
      isolated_security_origin = world->IsolatedWorldSecurityOrigin(
          execution_context_->GetAgentClusterID());
    }
    // The use of WrapWeakPersistent is safe and motivated by the fact that if
    // the WebSocket is no longer referenced, there's no point in keeping it
    // alive just to receive the throttling result.
    handshake_throttle_->ThrottleHandshake(
        url, WebSecurityOrigin(execution_context_->GetSecurityOrigin()),
        isolated_security_origin ? WebSecurityOrigin(isolated_security_origin)
                                 : WebSecurityOrigin(),
        WTF::BindOnce(&WebSocketChannelImpl::OnCompletion,
                      WrapWeakPersistent(this)));
  } else {
    // Treat no throttle as success.
    throttle_passed_ = true;
  }

  DEVTOOLS_TIMELINE_TRACE_EVENT_INSTANT(
      "WebSocketCreate", InspectorWebSocketCreateEvent::Data,
      execution_context_.Get(), identifier_, url, protocol);
  return true;
}

WebSocketChannel::SendResult WebSocketChannelImpl::Send(
    const std::string& message,
    base::OnceClosure completion_callback) {
  DVLOG(1) << this << " Send(" << message << ") (std::string argument)";
  probe::DidSendWebSocketMessage(execution_context_, identifier_,
                                 WebSocketOpCode::kOpCodeText, true, message);
  DEVTOOLS_TIMELINE_TRACE_EVENT_INSTANT(
    "WebSocketSend", InspectorWebSocketTransferEvent::Data,
    execution_context_.Get(), identifier_, message.length());

  bool did_attempt_to_send = false;
  base::span<const char> data = message;
  if (messages_.empty() && !wait_for_writable_) {
    did_attempt_to_send = true;
    if (MaybeSendSynchronously(
            network::mojom::blink::WebSocketMessageType::TEXT, &data)) {
      return SendResult::kSentSynchronously;
    }
  }

  messages_.push_back(
      Message(execution_context_->GetIsolate(),
              message.substr(message.size() - data.size(), data.size()),
              std::move(completion_callback),
              Message::DidCallSendMessage(did_attempt_to_send)));

  // ProcessSendQueue() will do nothing when MaybeSendSynchronously() is called.
  ProcessSendQueue();

  // If we managed to flush this message synchronously after all, it would mean
  // that the callback was fired re-entrantly, which would be bad.
  DCHECK(!messages_.empty());

  return SendResult::kCallbackWillBeCalled;
}

void WebSocketChannelImpl::Send(
    scoped_refptr<BlobDataHandle> blob_data_handle) {
  DVLOG(1) << this << " Send(" << blob_data_handle->Uuid() << ", "
           << blob_data_handle->GetType() << ", " << blob_data_handle->size()
           << ") "
           << "(BlobDataHandle argument)";
  // FIXME: We can't access the data here.
  // Since Binary data are not displayed in Inspector, this does not
  // affect actual behavior.
  probe::DidSendWebSocketMessage(execution_context_, identifier_,
                                 WebSocketOpCode::kOpCodeBinary, true,
                                 base::span_from_cstring(""));
  DEVTOOLS_TIMELINE_TRACE_EVENT_INSTANT(
    "WebSocketSend", InspectorWebSocketTransferEvent::Data,
    execution_context_.Get(), identifier_, blob_data_handle->size());
  messages_.push_back(Message(std::move(blob_data_handle)));
  ProcessSendQueue();
}

WebSocketChannel::SendResult WebSocketChannelImpl::Send(
    const DOMArrayBuffer& buffer,
    size_t byte_offset,
    size_t byte_length,
    base::OnceClosure completion_callback) {
  DVLOG(1) << this << " Send(" << buffer.Data() << ", " << byte_offset << ", "
           << byte_length << ") "
           << "(DOMArrayBuffer argument)";
  probe::DidSendWebSocketMessage(
      execution_context_, identifier_, WebSocketOpCode::kOpCodeBinary, true,
      base::as_chars(buffer.ByteSpan().subspan(byte_offset, byte_length)));
  DEVTOOLS_TIMELINE_TRACE_EVENT_INSTANT(
    "WebSocketSend", InspectorWebSocketTransferEvent::Data,
    execution_context_.Get(), identifier_, byte_length);
  bool did_attempt_to_send = false;
  base::span<const char> message = base::make_span(
      static_cast<const char*>(buffer.Data()) + byte_offset, byte_length);
  if (messages_.empty() && !wait_for_writable_) {
    did_attempt_to_send = true;
    if (MaybeSendSynchronously(
            network::mojom::blink::WebSocketMessageType::BINARY, &message)) {
      return SendResult::kSentSynchronously;
    }
  }

  messages_.push_back(Message(
      execution_context_->GetIsolate(), message, std::move(completion_callback),
      Message::DidCallSendMessage(did_attempt_to_send)));

  // ProcessSendQueue() will do nothing when MaybeSendSynchronously() is called.
  ProcessSendQueue();

  // If we managed to flush this message synchronously after all, it would mean
  // that the callback was fired re-entrantly, which would be bad.
  DCHECK(!messages_.empty());

  return SendResult::kCallbackWillBeCalled;
}

void WebSocketChannelImpl::Close(int code, const String& reason) {
  DCHECK_EQ(GetState(), State::kOpen);
  DCHECK(!execution_context_->IsContextDestroyed());
  DVLOG(1) << this << " Close(" << code << ", " << reason << ")";
  uint16_t code_to_send = static_cast<uint16_t>(
      code == kCloseEventCodeNotSpecified ? kCloseEventCodeNoStatusRcvd : code);
  messages_.push_back(Message(code_to_send, reason));
  ProcessSendQueue();
  // Make the page back/forward cache-able.
  feature_handle_for_scheduler_.reset();
}

void WebSocketChannelImpl::Fail(const String& reason,
                                mojom::ConsoleMessageLevel level,
                                std::unique_ptr<SourceLocation> location) {
  DVLOG(1) << this << " Fail(" << reason << ")";
  probe::DidReceiveWebSocketMessageError(execution_context_, identifier_,
                                         reason);
  const String message =
      "WebSocket connection to '" + url_.ElidedString() + "' failed: " + reason;

  std::unique_ptr<SourceLocation> captured_location = CaptureSourceLocation();
  if (!captured_location->IsUnknown()) {
    // If we are in JavaScript context, use the current location instead
    // of passed one - it's more precise.
    location = std::move(captured_location);
  } else if (location->IsUnknown()) {
    // No information is specified by the caller. Use the line number at the
    // connection.
    location = location_at_construction_->Clone();
  }

  execution_context_->AddConsoleMessage(MakeGarbageCollected<ConsoleMessage>(
      mojom::ConsoleMessageSource::kNetwork, level, message,
      std::move(location)));
  // |reason| is only for logging and should not be provided for scripts,
  // hence close reason must be empty in tearDownFailedConnection.
  execution_context_->GetTaskRunner(TaskType::kNetworking)
      ->PostTask(FROM_HERE,
                 WTF::BindOnce(&WebSocketChannelImpl::TearDownFailedConnection,
                               WrapPersistent(this)));
}

void WebSocketChannelImpl::Disconnect() {
  DVLOG(1) << this << " disconnect()";
  if (identifier_) {
    DEVTOOLS_TIMELINE_TRACE_EVENT_INSTANT(
        "WebSocketDestroy", InspectorWebSocketEvent::Data,
        execution_context_.Get(), identifier_);
    probe::DidCloseWebSocket(execution_context_.Get(), identifier_);
  }

  AbortAsyncOperations();
  Dispose();
}

void WebSocketChannelImpl::CancelHandshake() {
  DVLOG(1) << this << " CancelHandshake()";
  if (GetState() != State::kConnecting)
    return;

  // This may still disconnect even if the handshake is complete if we haven't
  // got the message yet.
  // TODO(ricea): Plumb it through to the network stack to fix the race
  // condition.
  Disconnect();
}

void WebSocketChannelImpl::ApplyBackpressure() {
  DVLOG(1) << this << " ApplyBackpressure";
  backpressure_ = true;
}

void WebSocketChannelImpl::RemoveBackpressure() {
  DVLOG(1) << this << " RemoveBackpressure";
  if (backpressure_) {
    backpressure_ = false;
    ConsumePendingDataFrames();
  }
}

void WebSocketChannelImpl::OnOpeningHandshakeStarted(
    network::mojom::blink::WebSocketHandshakeRequestPtr request) {
  DCHECK_EQ(GetState(), State::kConnecting);
  DVLOG(1) << this << " OnOpeningHandshakeStarted(" << request->url.GetString()
           << ")";

  DEVTOOLS_TIMELINE_TRACE_EVENT_INSTANT("WebSocketSendHandshakeRequest",
                                        InspectorWebSocketEvent::Data,
                                        execution_context_, identifier_);
  probe::WillSendWebSocketHandshakeRequest(execution_context_, identifier_,
                                           request.get());
  handshake_request_ = std::move(request);
}

void WebSocketChannelImpl::OnFailure(const WTF::String& message,
                                     int net_error,
                                     int response_code) {
  DVLOG(1) << this << " OnFailure(" << message << ", " << net_error << ", "
           << response_code << ")";
  failure_message_ = message;
}

void WebSocketChannelImpl::OnConnectionEstablished(
    mojo::PendingRemote<network::mojom::blink::WebSocket> websocket,
    mojo::PendingReceiver<network::mojom::blink::WebSocketClient>
        client_receiver,
    network::mojom::blink::WebSocketHandshakeResponsePtr response,
    mojo::ScopedDataPipeConsumerHandle readable,
    mojo::ScopedDataPipeProducerHandle writable) {
  DCHECK_EQ(GetState(), State::kConnecting);
  const String& protocol = response->selected_protocol;
  const String& extensions = response->extensions;
  DVLOG(1) << this << " OnConnectionEstablished(" << protocol << ", "
           << extensions << ")";
  DEVTOOLS_TIMELINE_TRACE_EVENT_INSTANT("WebSocketReceiveHandshakeResponse",
                                        InspectorWebSocketEvent::Data,
                                        execution_context_, identifier_);
  probe::DidReceiveWebSocketHandshakeResponse(execution_context_, identifier_,
                                              handshake_request_.get(),
                                              response.get());
  handshake_request_ = nullptr;

  // From now on, we will detect mojo errors via |client_receiver_|.
  handshake_client_receiver_.reset();
  client_receiver_.Bind(
      std::move(client_receiver),
      execution_context_->GetTaskRunner(TaskType::kNetworking));
  client_receiver_.set_disconnect_with_reason_handler(
      WTF::BindOnce(&WebSocketChannelImpl::OnConnectionError,
                    WrapWeakPersistent(this), FROM_HERE));

  DCHECK(!websocket_.is_bound());
  websocket_.Bind(std::move(websocket),
                  execution_context_->GetTaskRunner(TaskType::kNetworking));
  readable_ = std::move(readable);
  // TODO(suzukikeita): Implement upload via |writable_| instead of SendFrame.
  writable_ = std::move(writable);
  const MojoResult mojo_result = readable_watcher_.Watch(
      readable_.get(), MOJO_HANDLE_SIGNAL_READABLE,
      MOJO_WATCH_CONDITION_SATISFIED,
      WTF::BindRepeating(&WebSocketChannelImpl::OnReadable,
                         WrapWeakPersistent(this)));
  DCHECK_EQ(mojo_result, MOJO_RESULT_OK);

  const MojoResult mojo_writable_result = writable_watcher_.Watch(
      writable_.get(), MOJO_HANDLE_SIGNAL_WRITABLE,
      MOJO_WATCH_CONDITION_SATISFIED,
      WTF::BindRepeating(&WebSocketChannelImpl::OnWritable,
                         WrapWeakPersistent(this)));
  DCHECK_EQ(mojo_writable_result, MOJO_RESULT_OK);

  if (!throttle_passed_) {
    connect_info_ = std::make_unique<ConnectInfo>(protocol, extensions);
    return;
  }

  DCHECK_EQ(GetState(), State::kOpen);
  websocket_->StartReceiving();
  handshake_throttle_.reset();
  client_->DidConnect(protocol, extensions);
}

void WebSocketChannelImpl::OnDataFrame(
    bool fin,
    network::mojom::blink::WebSocketMessageType type,
    uint64_t data_length) {
  DCHECK_EQ(GetState(), State::kOpen);
  DVLOG(1) << this << " OnDataFrame(" << fin << ", " << type << ", "
           << "(data_length = " << data_length << "))";
  pending_data_frames_.push_back(
      DataFrame(fin, type, static_cast<uint32_t>(data_length)));
  ConsumePendingDataFrames();
}

void WebSocketChannelImpl::OnDropChannel(bool was_clean,
                                         uint16_t code,
                                         const String& reason) {
  // TODO(yhirano): This should be DCHECK_EQ(GetState(), State::kOpen).
  DCHECK(GetState() == State::kOpen || GetState() == State::kConnecting);
  DVLOG(1) << this << " OnDropChannel(" << was_clean << ", " << code << ", "
           << reason << ")";

  if (identifier_) {
    DEVTOOLS_TIMELINE_TRACE_EVENT_INSTANT("WebSocketDestroy",
                                          InspectorWebSocketEvent::Data,
                                          execution_context_, identifier_);
    probe::DidCloseWebSocket(execution_context_, identifier_);
    identifier_ = 0;
  }

  HandleDidClose(was_clean, code, reason);
}

void WebSocketChannelImpl::OnClosingHandshake() {
  DCHECK_EQ(GetState(), State::kOpen);
  DVLOG(1) << this << " OnClosingHandshake()";

  client_->DidStartClosingHandshake();
}

void WebSocketChannelImpl::Trace(Visitor* visitor) const {
  visitor->Trace(blob_loader_);
  visitor->Trace(client_);
  visitor->Trace(execution_context_);
  visitor->Trace(websocket_);
  visitor->Trace(handshake_client_receiver_);
  visitor->Trace(client_receiver_);
  visitor->Trace(message_chunks_);
  WebSocketChannel::Trace(visitor);
}

WebSocketChannelImpl::Message::Message(v8::Isolate* isolate,
                                       const std::string& text,
                                       base::OnceClosure completion_callback,
                                       DidCallSendMessage did_call_send_message)
    : message_data_(
          WebSocketChannelImpl::CreateMessageData(isolate, text.length())),
      type_(kMessageTypeText),
      did_call_send_message_(did_call_send_message),
      completion_callback_(std::move(completion_callback)) {
  memcpy(message_data_.get(), text.data(), text.length());
  pending_payload_ = base::make_span(message_data_.get(), text.length());
}

WebSocketChannelImpl::Message::Message(
    scoped_refptr<BlobDataHandle> blob_data_handle)
    : type_(kMessageTypeBlob), blob_data_handle_(std::move(blob_data_handle)) {}

WebSocketChannelImpl::Message::Message(MessageData data, size_t size)
    : message_data_(std::move(data)),
      type_(kMessageTypeArrayBuffer),
      pending_payload_(base::make_span(message_data_.get(), size)) {}

WebSocketChannelImpl::Message::Message(v8::Isolate* isolate,
                                       base::span<const char> message,
                                       base::OnceClosure completion_callback,
                                       DidCallSendMessage did_call_send_message)
    : message_data_(CreateMessageData(isolate, message.size())),
      type_(kMessageTypeArrayBuffer),
      did_call_send_message_(did_call_send_message),
      completion_callback_(std::move(completion_callback)) {
  memcpy(message_data_.get(), message.data(), message.size());
  pending_payload_ = base::make_span(message_data_.get(), message.size());
}

WebSocketChannelImpl::Message::Message(uint16_t code, const String& reason)
    : type_(kMessageTypeClose), code_(code), reason_(reason) {}

WebSocketChannelImpl::Message::Message(MessageType type,
                                       base::span<const char> pending_payload,
                                       base::OnceClosure completion_callback)
    : type_(type),
      pending_payload_(pending_payload),
      completion_callback_(std::move(completion_callback)) {}

WebSocketChannelImpl::Message::Message(Message&&) = default;

WebSocketChannelImpl::Message& WebSocketChannelImpl::Message::operator=(
    Message&&) = default;

WebSocketChannelImpl::State WebSocketChannelImpl::GetState() const {
  if (!has_initiated_opening_handshake_) {
    return State::kConnecting;
  }
  if (client_receiver_.is_bound() && throttle_passed_) {
    return State::kOpen;
  }
  if (handshake_client_receiver_.is_bound() || client_receiver_.is_bound()) {
    return State::kConnecting;
  }
  return State::kDisconnected;
}

WebSocketChannelImpl::MessageType WebSocketChannelImpl::Message::Type() const {
  return type_;
}

scoped_refptr<BlobDataHandle>
WebSocketChannelImpl::Message::GetBlobDataHandle() {
  return blob_data_handle_;
}

base::span<const char>& WebSocketChannelImpl::Message::MutablePendingPayload() {
  return pending_payload_;
}

WebSocketChannelImpl::Message::DidCallSendMessage
WebSocketChannelImpl::Message::GetDidCallSendMessage() const {
  return did_call_send_message_;
}

void WebSocketChannelImpl::Message::SetDidCallSendMessage(
    WebSocketChannelImpl::Message::DidCallSendMessage did_call_send_message) {
  did_call_send_message_ = did_call_send_message;
}

uint16_t WebSocketChannelImpl::Message::Code() const {
  return code_;
}

String WebSocketChannelImpl::M
```
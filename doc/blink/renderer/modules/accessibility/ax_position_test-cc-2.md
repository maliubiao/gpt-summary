Response:
The user wants a summary of the functionality of the provided C++ code snippet. This is the third part of a larger file, so I need to consider the context implied by that. The code is a series of unit tests for accessibility features in the Chromium Blink engine. Specifically, it tests the `AXPosition` class and its ability to create and manipulate positions within the accessibility tree, often in relation to elements manipulated by CSS.

Here's a breakdown of the tests and their functionalities:

1. **`PositionInCSSContent`**: Tests creating positions within pseudo-elements generated by CSS (`::before` and `::after`). It verifies the created `AXPosition` objects point to the correct locations and can be converted to DOM `Position` objects.
2. **`PositionInCSSImageContent`**:  Tests creating a position within a CSS `content` property that is an image.
3. **`PositionInTableWithCSSContent`**:  Similar to `PositionInCSSContent`, but focuses on tables and CSS-generated content within table header cells. It verifies positions before and after the CSS content.
4. **`PositionBeforeAndAfterTable`**: Tests creating `AXPosition` objects before and after a table element in the accessibility tree. It checks the corresponding DOM `Position` and the relationship to the `AXObject`.
5. **`PositionAtStartAndEndOfTable`**: Tests creating `AXPosition` objects at the beginning and end of a table, considering the accessibility-ignored elements like `thead` and `tbody`.
6. **`PositionInTableHeader`**: Tests creating `AXPosition` objects before and after table header cells.
7. **`PositionInTableRow`**: Tests creating `AXPosition` objects before and after cells within a table row.
8. **`PositionInInvalidMapLayout`**: Tests how `AXPosition` handles scenarios with an invalid DOM structure where a `<map>` element is incorrectly placed. It verifies that no `AXObject` is created for the `<map>` and positions relative to the parent are still valid.
9. **`ToPositionWithAffinityWithMultipleInlineTextBoxes`**: Tests the conversion of an `AXPosition` to a DOM `Position` when there are multiple inline text boxes within a text element, ensuring the offset is calculated correctly, considering white-space handling.

Based on these observations, I can formulate a summary covering the core functionality, relationships to web technologies, logical reasoning within the tests, potential user/developer errors, debugging clues, and a final overall summary.
这个文件 `ax_position_test.cc` 是 Chromium Blink 引擎中负责测试 **可访问性（Accessibility）** 模块下 `AXPosition` 类的功能的。`AXPosition` 类用于表示在可访问性树中的一个位置。

**功能归纳:**

这个测试文件的主要目的是验证 `AXPosition` 类在各种场景下创建和操作可访问性树中位置的能力，特别是涉及到以下方面：

* **在由 CSS 生成的内容中的位置：**  测试在 `::before` 和 `::after` 伪元素生成的内容中创建位置，并验证这些位置的正确性。
* **在包含 CSS 内容的表格中的位置：** 测试在表格元素中，特别是表头单元格中，由 CSS 生成的内容（如 `content: "+";`）产生的影响，并验证能否正确地定位到这些内容的前后。
* **在 DOM 树中不存在的可访问性对象周围的位置：** 测试在可访问性树中存在但不在 DOM 树中的对象（例如，表格的列）之前和之后创建位置。
* **在各种表格结构中的位置：** 测试在表格的不同部分（整个表格、表头、表行、单元格）的开始和结束位置的创建。
* **处理无效的 DOM 结构：** 测试在遇到无效的 DOM 结构时，`AXPosition` 的处理方式。
* **与 `Position` 对象之间的转换：**  测试 `AXPosition` 对象与 DOM 中的 `Position` 对象之间的相互转换。
* **处理多行文本和内联文本框：** 测试在包含多行文本和多个内联文本框的元素中，`AXPosition` 如何转换为正确的 DOM `Position`，并考虑空白符的影响。

**与 JavaScript, HTML, CSS 的关系及举例说明:**

* **HTML:**  测试文件通过设置不同的 HTML 结构来模拟各种场景，例如包含伪元素、表格等。例如，`SetBodyInnerHTML(kHTMLTable);`  这行代码就使用了一个预定义的 HTML 表格结构进行测试。
* **CSS:** 测试重点关注 CSS 如何影响可访问性树以及 `AXPosition` 的行为。
    * **`PositionInCSSContent`**: 使用如下 CSS，测试在 `<h2>` 元素的前后伪元素中创建位置：
      ```html
      <style>
      .heading::before {
        content: "before";
      }
      .heading::after {
        content: "after";
      }
      </style>
      <h2 id="heading" class="heading">Heading</h2>
      ```
      这个测试验证了能否在 "before" 和 "after" 这两个由 CSS 生成的文本内容中定位。
    * **`PositionInTableWithCSSContent`**:  使用 CSS 在表头单元格前后添加内容：
      ```css
      th::before {
        content: "+";
      }
      th::after {
        content: ":";
      }
      ```
      测试验证了 `AXPosition` 能否定位到这些 CSS 生成的 "+" 和 ":"。
* **JavaScript:**  虽然这个测试文件本身是用 C++ 编写的，用于测试 Blink 引擎的内部功能，但它测试的可访问性功能最终会影响到 JavaScript 如何与网页进行交互，特别是通过可访问性 API（如 ARIA）。例如，屏幕阅读器等辅助技术会使用这些 API 来获取网页内容和结构信息。

**逻辑推理、假设输入与输出:**

在每个 `TEST_F` 函数中，都包含了逻辑推理，通过设置特定的 HTML 和 CSS 结构作为输入，然后断言 `AXPosition` 对象的状态和转换后的 `Position` 对象的值是否符合预期。

**例如，在 `PositionInCSSContent` 测试中：**

* **假设输入:**  HTML 包含一个 `<h2>` 元素，并且通过 CSS 的 `::before` 和 `::after` 伪元素添加了 "before" 和 "after" 文本。
* **逻辑推理:**  `AXPosition::CreateFirstPositionInObject(*ax_css_before)` 应该创建指向 "before" 文本开始的位置。 `ax_position_before.ToPositionWithAffinity(AXPositionAdjustmentBehavior::kMoveRight)` 应该将这个可访问性位置转换为 DOM 中的 `Position` 对象，其锚点节点是 "Heading" 文本节点，偏移量为 0。
* **预期输出:** `position_before.AnchorNode()` 应该等于 "Heading" 文本节点，`position_before.GetPosition().OffsetInContainerNode()` 应该等于 0。

**用户或编程常见的使用错误及举例说明:**

虽然这个测试是针对引擎内部的，但它所覆盖的场景与开发者在使用 HTML、CSS 构建网页时可能遇到的问题相关。

* **CSS 内容的理解：** 开发者可能不清楚 CSS 的 `::before` 和 `::after` 生成的内容在可访问性树中是如何表示的，以及如何通过可访问性 API 访问这些内容。这个测试验证了 Blink 引擎正确地处理了这些情况。
* **表格结构：**  开发者可能会创建结构不正确的表格，导致可访问性 API 无法正确解析。这个测试覆盖了各种表格结构，确保 `AXPosition` 能够正确工作。
* **JavaScript 操作 DOM 后可访问性更新：**  虽然这里没有直接测试 JavaScript，但理解 `AXPosition` 的行为有助于开发者在编写 JavaScript 代码动态修改 DOM 时，考虑到对可访问性的影响。例如，如果 JavaScript 动态添加或删除带有 CSS 内容的元素，理解 `AXPosition` 如何定位这些内容对于确保可访问性至关重要。

**用户操作是如何一步步的到达这里，作为调试线索:**

虽然用户不会直接“到达”这个 C++ 测试文件，但可以理解为用户与网页的交互触发了 Blink 引擎中可访问性功能的运行，而这个测试文件正是验证这些功能是否正确。

1. **用户访问一个包含复杂结构和 CSS 内容的网页。**
2. **用户的辅助技术（例如屏幕阅读器）尝试读取网页内容和结构。**
3. **屏幕阅读器会调用操作系统的可访问性 API。**
4. **操作系统会与浏览器（例如 Chrome）通信，请求可访问性信息。**
5. **Chrome 的渲染引擎 Blink 会构建可访问性树（Accessibility Tree）。**
6. **在构建可访问性树的过程中，`AXPosition` 类被用来表示树中的位置。**
7. **如果 `AXPosition` 的逻辑有错误，可能会导致屏幕阅读器无法正确读取 CSS 生成的内容或表格结构，从而影响用户体验。**

这个测试文件就是为了确保第 6 步中的 `AXPosition` 类能够正确地表示位置，从而保证整个可访问性流程的正确性。如果开发者在使用 Chrome 的开发者工具中的 "Accessibility" 面板时发现某些元素的可访问性信息不正确，那么就可以怀疑是可访问性树的构建或者 `AXPosition` 的计算出现了问题，这时就可以参考类似的测试用例来帮助定位问题。

**这是第3部分，共3部分，请归纳一下它的功能:**

作为第三部分，这个代码片段延续了前两部分的主题，继续深入测试 `AXPosition` 类在更复杂和特定的场景下的行为。它特别关注了以下几个方面：

* **CSS 生成内容的可访问性：**  这是本部分测试的核心，多个测试用例都围绕着 `::before` 和 `::after` 伪元素生成的内容展开，验证了 `AXPosition` 能否正确地定位到这些内容。
* **表格可访问性的细节：**  测试了在表格的不同层级（表格本身、表头、表行）的起始和结束位置，以及在表头单元格中使用 CSS 生成内容的情况。
* **处理异常情况：**  包含了处理无效 DOM 结构的测试用例，确保 `AXPosition` 在遇到错误时也能有合理的行为。
* **与 DOM `Position` 的精确转换：**  测试了在包含多个内联文本框的情况下，`AXPosition` 到 DOM `Position` 的转换是否精确，考虑了空白符的影响。

总而言之，这第三部分的功能是**对 `AXPosition` 类进行更深入、更细致的测试，特别是在与 CSS 生成内容和复杂表格结构交互时，以及在处理异常情况和进行精确的位置转换时，确保其功能的正确性和健壮性。** 这有助于保证 Chrome 浏览器在处理具有复杂样式和结构的网页时，能够提供准确可靠的可访问性信息。

Prompt: 
```
这是目录为blink/renderer/modules/accessibility/ax_position_test.cc的chromium blink引擎源代码文件， 请列举一下它的功能, 
如果它与javascript, html, css的功能有关系，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索。
这是第3部分，共3部分，请归纳一下它的功能

"""
::mojom::Role::kStaticText, ax_css_after->RoleValue());

  const auto ax_position_before =
      AXPosition::CreateFirstPositionInObject(*ax_css_before);
  EXPECT_TRUE(ax_position_before.IsTextPosition());
  EXPECT_EQ(0, ax_position_before.TextOffset());
  EXPECT_EQ(nullptr, ax_position_before.ChildAfterTreePosition());
  const auto position_before = ax_position_before.ToPositionWithAffinity(
      AXPositionAdjustmentBehavior::kMoveRight);
  EXPECT_EQ(text, position_before.AnchorNode());
  EXPECT_EQ(0, position_before.GetPosition().OffsetInContainerNode());

  const auto ax_position_after =
      AXPosition::CreateLastPositionInObject(*ax_css_after);
  EXPECT_TRUE(ax_position_after.IsTextPosition());
  EXPECT_EQ(2, ax_position_after.TextOffset());
  EXPECT_EQ(nullptr, ax_position_after.ChildAfterTreePosition());
  const auto position_after = ax_position_after.ToPositionWithAffinity(
      AXPositionAdjustmentBehavior::kMoveLeft);
  EXPECT_EQ(text, position_after.AnchorNode());
  EXPECT_EQ(12, position_after.GetPosition().OffsetInContainerNode());
}

// TODO(nektar) Fix test to work with ignored containers of pseudo content.
TEST_F(AccessibilityTest, DISABLED_PositionInCSSImageContent) {
  constexpr char css_content_no_text[] = R"HTML(
   <style>
   .heading::before {
    content: url(data:image/gif;base64,);
   }
   </style>
   <h1 id="heading" class="heading">Heading</h1>)HTML";
  SetBodyInnerHTML(css_content_no_text);

  const Node* heading = GetElementById("heading");
  ASSERT_NE(nullptr, heading);

  const AXObject* ax_heading = GetAXObjectByElementId("heading");
  ASSERT_NE(nullptr, ax_heading);
  ASSERT_EQ(ax::mojom::Role::kHeading, ax_heading->RoleValue());
  ASSERT_EQ(2, ax_heading->ChildCountIncludingIgnored());

  const AXObject* ax_css_before = ax_heading->FirstChildIncludingIgnored();
  ASSERT_NE(nullptr, ax_css_before);
  ASSERT_EQ(ax::mojom::Role::kImage, ax_css_before->RoleValue());

  const auto ax_position_before =
      AXPosition::CreateFirstPositionInObject(*ax_css_before);
  const auto position = ax_position_before.ToPositionWithAffinity(
      AXPositionAdjustmentBehavior::kMoveLeft);
  EXPECT_EQ(GetDocument().body(), position.AnchorNode());
  EXPECT_EQ(3, position.GetPosition().OffsetInContainerNode());
}

// TODO(nektar) Fix test to work with ignored containers of pseudo content.
TEST_F(AccessibilityTest, DISABLED_PositionInTableWithCSSContent) {
  SetBodyInnerHTML(kHTMLTable);

  // Add some CSS content, i.e. a plus symbol before and a colon after each
  // table header cell.
  Element* const style_element =
      GetDocument().CreateRawElement(html_names::kStyleTag);
  ASSERT_NE(nullptr, style_element);
  style_element->setTextContent(R"STYLE(
      th::before {
        content: "+";
      }
      th::after {
        content: ":";
      }
      )STYLE");
  GetDocument().body()->insertBefore(style_element,
                                     GetDocument().body()->firstChild());
  UpdateAllLifecyclePhasesForTest();

  const Node* first_header_cell = GetElementById("firstHeaderCell");
  ASSERT_NE(nullptr, first_header_cell);
  const Node* last_header_cell = GetElementById("lastHeaderCell");
  ASSERT_NE(nullptr, last_header_cell);

  // CSS text nodes are not in the DOM tree.
  const Node* first_header_cell_text = first_header_cell->firstChild();
  ASSERT_NE(nullptr, first_header_cell_text);
  ASSERT_FALSE(first_header_cell_text->IsPseudoElement());
  ASSERT_TRUE(first_header_cell_text->IsTextNode());
  const Node* last_header_cell_text = last_header_cell->firstChild();
  ASSERT_NE(nullptr, last_header_cell_text);
  ASSERT_FALSE(last_header_cell_text->IsPseudoElement());
  ASSERT_TRUE(last_header_cell_text->IsTextNode());

  const AXObject* ax_first_header_cell =
      GetAXObjectByElementId("firstHeaderCell");
  ASSERT_NE(nullptr, ax_first_header_cell);
  ASSERT_EQ(ax::mojom::Role::kColumnHeader, ax_first_header_cell->RoleValue());
  const AXObject* ax_last_header_cell =
      GetAXObjectByElementId("lastHeaderCell");
  ASSERT_NE(nullptr, ax_last_header_cell);
  ASSERT_EQ(ax::mojom::Role::kColumnHeader, ax_last_header_cell->RoleValue());

  ASSERT_EQ(3, ax_first_header_cell->ChildCountIncludingIgnored());
  // Get grandchild text, not the child ignored generic container.
  AXObject* const ax_first_cell_css_before =
      ax_first_header_cell->FirstChildIncludingIgnored()
          ->FirstChildIncludingIgnored();
  ASSERT_NE(nullptr, ax_first_cell_css_before);
  ASSERT_EQ(ax::mojom::Role::kStaticText,
            ax_first_cell_css_before->RoleValue());

  ASSERT_EQ(3, ax_last_header_cell->ChildCountIncludingIgnored());
  // Get grandchild text, not the child ignored generic container.
  AXObject* const ax_last_cell_css_after =
      ax_last_header_cell->FirstChildIncludingIgnored()
          ->LastChildIncludingIgnored();
  ASSERT_NE(nullptr, ax_last_cell_css_after);
  ASSERT_EQ(ax::mojom::Role::kStaticText, ax_last_cell_css_after->RoleValue());

  // The first position inside the first header cell should be before the plus
  // symbol inside the CSS content. It should be valid in the accessibility tree
  // but not valid in the DOM tree.
  auto ax_position_before =
      AXPosition::CreateFirstPositionInObject(*ax_first_header_cell);
  EXPECT_TRUE(ax_position_before.IsTextPosition());
  EXPECT_EQ(0, ax_position_before.TextOffset());
  auto position_before = ax_position_before.ToPositionWithAffinity(
      AXPositionAdjustmentBehavior::kMoveRight);
  EXPECT_EQ(first_header_cell_text, position_before.AnchorNode());
  EXPECT_EQ(0, position_before.GetPosition().OffsetInContainerNode());

  // Same situation as above, but explicitly create a text position inside the
  // CSS content, instead of having it implicitly created by
  // CreateFirstPositionInObject.
  ax_position_before =
      AXPosition::CreateFirstPositionInObject(*ax_first_cell_css_before);
  EXPECT_TRUE(ax_position_before.IsTextPosition());
  EXPECT_EQ(0, ax_position_before.TextOffset());
  position_before = ax_position_before.ToPositionWithAffinity(
      AXPositionAdjustmentBehavior::kMoveRight);
  EXPECT_EQ(first_header_cell_text, position_before.AnchorNode());
  EXPECT_EQ(0, position_before.GetPosition().OffsetInContainerNode());

  // Same situation as above, but now create a text position inside the inline
  // text box representing the CSS content after the last header cell.
  ax_first_cell_css_before->LoadInlineTextBoxes();
  ASSERT_NE(nullptr, ax_first_cell_css_before->FirstChildIncludingIgnored());
  ax_position_before = AXPosition::CreateFirstPositionInObject(
      *ax_first_cell_css_before->FirstChildIncludingIgnored());
  EXPECT_TRUE(ax_position_before.IsTextPosition());
  EXPECT_EQ(0, ax_position_before.TextOffset());
  position_before = ax_position_before.ToPositionWithAffinity(
      AXPositionAdjustmentBehavior::kMoveRight);
  EXPECT_EQ(first_header_cell_text, position_before.AnchorNode());
  EXPECT_EQ(0, position_before.GetPosition().OffsetInContainerNode());

  // An "after children" position inside the last header cell should be after
  // the CSS content that displays a colon. It should be valid in the
  // accessibility tree but not valid in the DOM tree.
  auto ax_position_after =
      AXPosition::CreateLastPositionInObject(*ax_last_header_cell);
  EXPECT_FALSE(ax_position_after.IsTextPosition());
  EXPECT_EQ(3, ax_position_after.ChildIndex());
  auto position_after = ax_position_after.ToPositionWithAffinity(
      AXPositionAdjustmentBehavior::kMoveLeft);
  EXPECT_EQ(last_header_cell_text, position_after.AnchorNode());
  EXPECT_EQ(8, position_after.GetPosition().OffsetInContainerNode());

  // Similar to the last case, but explicitly create a text position inside the
  // CSS content after the last header cell.
  ax_position_after =
      AXPosition::CreateLastPositionInObject(*ax_last_cell_css_after);
  EXPECT_TRUE(ax_position_after.IsTextPosition());
  EXPECT_EQ(1, ax_position_after.TextOffset());
  position_after = ax_position_after.ToPositionWithAffinity(
      AXPositionAdjustmentBehavior::kMoveLeft);
  EXPECT_EQ(last_header_cell_text, position_after.AnchorNode());
  EXPECT_EQ(8, position_after.GetPosition().OffsetInContainerNode());

  // Same situation as above, but now create a text position inside the inline
  // text box representing the CSS content after the last header cell.
  ax_last_cell_css_after->LoadInlineTextBoxes();
  ASSERT_NE(nullptr, ax_last_cell_css_after->FirstChildIncludingIgnored());
  ax_position_after = AXPosition::CreateLastPositionInObject(
      *ax_last_cell_css_after->FirstChildIncludingIgnored());
  EXPECT_TRUE(ax_position_after.IsTextPosition());
  EXPECT_EQ(1, ax_position_after.TextOffset());
  position_after = ax_position_after.ToPositionWithAffinity(
      AXPositionAdjustmentBehavior::kMoveLeft);
  EXPECT_EQ(last_header_cell_text, position_after.AnchorNode());
  EXPECT_EQ(8, position_after.GetPosition().OffsetInContainerNode());
}

//
// Objects deriving from |AXMockObject|, e.g. table columns, are in the
// accessibility tree but are neither in the DOM or layout trees.
//

TEST_F(AccessibilityTest, PositionBeforeAndAfterTable) {
  SetBodyInnerHTML(kHTMLTable);
  const Node* after = GetElementById("after");
  ASSERT_NE(nullptr, after);
  const AXObject* ax_table = GetAXObjectByElementId("table");
  ASSERT_NE(nullptr, ax_table);
  ASSERT_EQ(ax::mojom::Role::kTable, ax_table->RoleValue());
  const AXObject* ax_after = GetAXObjectByElementId("after");
  ASSERT_NE(nullptr, ax_after);
  ASSERT_EQ(ax::mojom::Role::kParagraph, ax_after->RoleValue());

  const auto ax_position_before =
      AXPosition::CreatePositionBeforeObject(*ax_table);
  const auto position_before = ax_position_before.ToPositionWithAffinity();
  EXPECT_EQ(GetDocument().body(), position_before.AnchorNode());
  EXPECT_EQ(3, position_before.GetPosition().OffsetInContainerNode());
  const Node* table = position_before.GetPosition().ComputeNodeAfterPosition();
  ASSERT_NE(nullptr, table);
  EXPECT_EQ(GetElementById("table"), table);

  const auto ax_position_before_from_dom =
      AXPosition::FromPosition(position_before);
  EXPECT_EQ(ax_position_before, ax_position_before_from_dom);

  const auto ax_position_after =
      AXPosition::CreatePositionAfterObject(*ax_table);
  const auto position_after = ax_position_after.ToPositionWithAffinity();
  EXPECT_EQ(GetDocument().body(), position_after.AnchorNode());
  EXPECT_EQ(5, position_after.GetPosition().OffsetInContainerNode());
  const Node* node_after =
      position_after.GetPosition().ComputeNodeAfterPosition();
  EXPECT_EQ(after, node_after);

  const auto ax_position_after_from_dom =
      AXPosition::FromPosition(position_after);
  EXPECT_EQ(ax_position_after, ax_position_after_from_dom);
  EXPECT_EQ(ax_after, ax_position_after_from_dom.ChildAfterTreePosition());
}

TEST_F(AccessibilityTest, PositionAtStartAndEndOfTable) {
  SetBodyInnerHTML(kHTMLTable);

  // In the accessibility tree, the thead and tbody elements are accessibility
  // ignored but included in the AXTree.
  // Calling CreateFirstPositionInObject and CreateLastPositionInObject with the
  // |table| element will create a position anchored to |table| which points to
  // the |thead| element and the last whitespace text node within the table
  // respectively.
  const Node* table = GetElementById("table");
  ASSERT_NE(nullptr, table);
  const Node* thead = GetElementById("thead");
  ASSERT_NE(nullptr, thead);
  const Node* header_row = GetElementById("headerRow");
  ASSERT_NE(nullptr, header_row);
  const Node* tbody = GetElementById("tbody");
  ASSERT_NE(nullptr, tbody);

  const AXObject* ax_table = GetAXObjectByElementId("table");
  ASSERT_NE(nullptr, ax_table);
  ASSERT_EQ(ax::mojom::Role::kTable, ax_table->RoleValue());
  const AXObject* ax_header_row = GetAXObjectByElementId("headerRow");
  ASSERT_NE(nullptr, ax_header_row);
  ASSERT_EQ(ax::mojom::Role::kRow, ax_header_row->RoleValue());

  const AXObject* ax_thead = GetAXObjectByElementId("thead");
  const auto ax_position_at_start =
      AXPosition::CreateFirstPositionInObject(*ax_table);
  const auto position_at_start = ax_position_at_start.ToPositionWithAffinity();
  EXPECT_EQ(table, position_at_start.AnchorNode());
  EXPECT_EQ(1, position_at_start.GetPosition().OffsetInContainerNode());
  EXPECT_EQ(thead, position_at_start.GetPosition().ComputeNodeAfterPosition());

  const auto ax_position_at_start_from_dom =
      AXPosition::FromPosition(position_at_start);
  EXPECT_EQ(ax_position_at_start, ax_position_at_start_from_dom);
  EXPECT_EQ(ax_thead, ax_position_at_start_from_dom.ChildAfterTreePosition());

  const auto ax_position_at_end =
      AXPosition::CreateLastPositionInObject(*ax_table);
  const auto position_at_end = ax_position_at_end.ToPositionWithAffinity();
  EXPECT_EQ(table, position_at_end.AnchorNode());
  // There are three rows and a line break before and after each one.
  EXPECT_EQ(4, position_at_end.GetPosition().OffsetInContainerNode());

  const auto ax_position_at_end_from_dom =
      AXPosition::FromPosition(position_at_end);
  EXPECT_EQ(ax_position_at_end, ax_position_at_end_from_dom);
  EXPECT_EQ(nullptr, ax_position_at_end_from_dom.ChildAfterTreePosition());
}

TEST_F(AccessibilityTest, PositionInTableHeader) {
  SetBodyInnerHTML(kHTMLTable);

  const Node* header_row = GetElementById("headerRow");
  ASSERT_NE(nullptr, header_row);
  const Node* first_header_cell = GetElementById("firstHeaderCell");
  ASSERT_NE(nullptr, first_header_cell);

  const AXObject* ax_first_header_cell =
      GetAXObjectByElementId("firstHeaderCell");
  ASSERT_NE(nullptr, ax_first_header_cell);
  ASSERT_EQ(ax::mojom::Role::kColumnHeader, ax_first_header_cell->RoleValue());
  const AXObject* ax_last_header_cell =
      GetAXObjectByElementId("lastHeaderCell");
  ASSERT_NE(nullptr, ax_last_header_cell);
  ASSERT_EQ(ax::mojom::Role::kColumnHeader, ax_last_header_cell->RoleValue());

  const auto ax_position_before =
      AXPosition::CreatePositionBeforeObject(*ax_first_header_cell);
  const auto position_before = ax_position_before.ToPositionWithAffinity();
  EXPECT_EQ(header_row, position_before.AnchorNode());
  EXPECT_EQ(1, position_before.GetPosition().OffsetInContainerNode());
  EXPECT_EQ(first_header_cell,
            position_before.GetPosition().ComputeNodeAfterPosition());

  const auto ax_position_before_from_dom =
      AXPosition::FromPosition(position_before);
  EXPECT_EQ(ax_position_before, ax_position_before_from_dom);
  EXPECT_EQ(ax_first_header_cell,
            ax_position_before_from_dom.ChildAfterTreePosition());

  const auto ax_position_after =
      AXPosition::CreatePositionAfterObject(*ax_last_header_cell);
  const auto position_after = ax_position_after.ToPositionWithAffinity();
  EXPECT_EQ(header_row, position_after.AnchorNode());
  // There are three header cells and a line break before and after each one.
  EXPECT_EQ(6, position_after.GetPosition().OffsetInContainerNode());

  const auto ax_position_after_from_dom =
      AXPosition::FromPosition(position_after);
  EXPECT_EQ(ax_position_after, ax_position_after_from_dom);
  EXPECT_EQ(nullptr, ax_position_after_from_dom.ChildAfterTreePosition());
}

TEST_F(AccessibilityTest, PositionInTableRow) {
  SetBodyInnerHTML(kHTMLTable);

  const Node* first_row = GetElementById("firstRow");
  ASSERT_NE(nullptr, first_row);
  const Node* first_cell = GetElementById("firstCell");
  ASSERT_NE(nullptr, first_cell);
  const Node* last_row = GetElementById("lastRow");
  ASSERT_NE(nullptr, last_row);

  const AXObject* ax_first_cell = GetAXObjectByElementId("firstCell");
  ASSERT_NE(nullptr, ax_first_cell);
  ASSERT_EQ(ax::mojom::Role::kRowHeader, ax_first_cell->RoleValue());
  const AXObject* ax_last_cell = GetAXObjectByElementId("lastCell");
  ASSERT_NE(nullptr, ax_last_cell);
  ASSERT_EQ(ax::mojom::Role::kCell, ax_last_cell->RoleValue());

  const auto ax_position_before =
      AXPosition::CreatePositionBeforeObject(*ax_first_cell);
  const auto position_before = ax_position_before.ToPositionWithAffinity();
  EXPECT_EQ(first_row, position_before.AnchorNode());
  EXPECT_EQ(1, position_before.GetPosition().OffsetInContainerNode());
  EXPECT_EQ(first_cell,
            position_before.GetPosition().ComputeNodeAfterPosition());

  const auto ax_position_before_from_dom =
      AXPosition::FromPosition(position_before);
  EXPECT_EQ(ax_position_before, ax_position_before_from_dom);
  EXPECT_EQ(ax_first_cell,
            ax_position_before_from_dom.ChildAfterTreePosition());

  const auto ax_position_after =
      AXPosition::CreatePositionAfterObject(*ax_last_cell);
  const auto position_after = ax_position_after.ToPositionWithAffinity();
  EXPECT_EQ(last_row, position_after.AnchorNode());
  // There are three cells on the last row and a line break before and after
  // each one.
  EXPECT_EQ(6, position_after.GetPosition().OffsetInContainerNode());

  const auto ax_position_after_from_dom =
      AXPosition::FromPosition(position_after);
  EXPECT_EQ(ax_position_after, ax_position_after_from_dom);
  EXPECT_EQ(nullptr, ax_position_after_from_dom.ChildAfterTreePosition());
}

TEST_F(AccessibilityTest, PositionInInvalidMapLayout) {
  SetBodyInnerHTML(kMap);

  Node* br = GetElementById("br");
  ASSERT_NE(nullptr, br);
  Node* map = GetElementById("map");
  ASSERT_NE(nullptr, map);

  const AXObject* ax_map = GetAXObjectByElementId("map");
  ASSERT_EQ(nullptr, ax_map);  // No AXObject is created for a <map>.

  // Create an invalid layout by appending a child to the <br>
  br->appendChild(map);
  GetAXObjectCache().UpdateAXForAllDocuments();

  ax_map = GetAXObjectByElementId("map");
  ASSERT_EQ(nullptr, ax_map);

  const AXObject* ax_br = GetAXObjectByElementId("br");
  ASSERT_NE(nullptr, ax_br);

  const auto ax_position_before =
      AXPosition::CreateFirstPositionInObject(*ax_br);
  const auto position_before = ax_position_before.ToPositionWithAffinity();
  EXPECT_EQ(br, position_before.AnchorNode());
  EXPECT_EQ(0, position_before.GetPosition().OffsetInContainerNode());

  const auto ax_position_after = AXPosition::CreateLastPositionInObject(*ax_br);
  const auto position_after = ax_position_after.ToPositionWithAffinity();
  EXPECT_EQ(br, position_after.AnchorNode());
  EXPECT_EQ(0, position_after.GetPosition().OffsetInContainerNode());
}

TEST_F(AccessibilityTest, ToPositionWithAffinityWithMultipleInlineTextBoxes) {
  // This test expects the starting offset of the last InlineTextBox object to
  // equate the sum of the previous inline text boxes' length, without the
  // collapsed white-spaces.
  //
  // "&#10" is a Line Feed ("\n").
  SetBodyInnerHTML(
      R"HTML(<style>p { white-space: pre-line; }</style>
      <p id="paragraph">Hello &#10; world</p>)HTML");

  const Node* text = GetElementById("paragraph")->firstChild();
  ASSERT_NE(nullptr, text);
  ASSERT_TRUE(text->IsTextNode());
  AXObject* ax_static_text =
      GetAXObjectByElementId("paragraph")->FirstChildIncludingIgnored();

  ASSERT_NE(nullptr, ax_static_text);
  ASSERT_EQ(ax::mojom::Role::kStaticText, ax_static_text->RoleValue());

  ax_static_text->LoadInlineTextBoxes();
  ASSERT_EQ(3, ax_static_text->UnignoredChildCount());

  // The last inline text box should be:
  // "InlineTextBox" name="world"
  const AXObject* ax_last_inline_box =
      ax_static_text->LastChildIncludingIgnored();
  const auto ax_position =
      AXPosition::CreatePositionBeforeObject(*ax_last_inline_box);
  const auto position = ax_position.ToPositionWithAffinity();
  // The resulting DOM position should be:
  // DOM position #text "Hello \n world"@offsetInAnchor[8]
  ASSERT_TRUE(position.GetPosition().IsOffsetInAnchor());
  EXPECT_EQ(8, position.GetPosition().OffsetInContainerNode());
}

}  // namespace test
}  // namespace blink

"""


```
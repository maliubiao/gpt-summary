Response:
Let's break down the thought process for analyzing this C++ file.

**1. Initial Understanding - What is the File About?**

The file path `blink/renderer/modules/accessibility/testing/accessibility_selection_test.cc` immediately suggests this is a testing utility for accessibility selection within the Blink rendering engine. The name `AccessibilitySelectionTest` reinforces this.

**2. Core Functionality Identification (High-Level)**

Scanning the code, several key classes and functions jump out:

* `AccessibilitySelectionTest`: The main test fixture.
* `AXSelectionSerializer`:  Clearly responsible for converting an accessibility selection into a string representation. The comments mention '^' and '|' markers, indicating a custom serialization format.
* `AXSelectionDeserializer`: The counterpart to the serializer, taking a string representation (potentially with markers) and creating `AXSelection` objects.
* `GetCurrentSelectionText()`, `GetSelectionText()`:  Functions to get the serialized text of the current or a given selection.
* `SetSelectionText()`:  Functions to set the selection based on a string representation.
* `RunSelectionTest()`: The core test runner that loads HTML, deserializes selections, performs the selections, serializes the results, and compares against expected output.

**3. Deeper Dive into Key Components**

* **`AXSelectionSerializer`:**
    * **Purpose:** Convert `AXSelection` to a string for comparison in tests.
    * **How it works:** It traverses the accessibility tree, adding markers ('^' for anchor, '|' for focus) based on the `AXSelection`'s anchor and focus points. It handles text nodes specially, placing markers within the text. For other objects, it marks positions before or after the object.
    * **Key observations:**  It uses `AXObject::InternalRoleName` for a concise representation of elements. The indentation with '+' helps visualize the tree structure.

* **`AXSelectionDeserializer`:**
    * **Purpose:** Create `AXSelection` objects from HTML with special markers.
    * **How it works:** It parses the HTML, looking for '^' and '|' within text nodes. It records the node and offset of these markers. It then creates `AXSelection` objects based on paired markers. It handles the case of a single '|' representing a caret. It *removes* the markers from the DOM after processing.
    * **Key observations:** It relies heavily on `AXObjectCacheImpl` to access the accessibility tree. The logic for handling non-text selections (markers in whitespace-only text nodes) is interesting.

* **`AccessibilitySelectionTest` Methods:**
    * **`SetUp()`:** Initializes the test environment, specifically disabling noisy inline textboxes for cleaner testing.
    * **Getter/Setter methods:**  Provide an interface to manipulate and retrieve accessibility selections.
    * **`RunSelectionTest()`:** The core test execution logic. It reads test HTML and expected output, uses the deserializer to create selections, applies the selections, uses the serializer to get the actual output, and compares.

**4. Relationships with Web Technologies (JavaScript, HTML, CSS)**

* **HTML:**  The tests work by loading HTML snippets. The deserializer directly manipulates the HTML content to find selection markers. The accessibility tree itself is a representation of the HTML structure.
* **JavaScript:** While this particular file is C++, it tests functionality that's often triggered or observed via JavaScript. JavaScript code interacting with the DOM `Selection` API is what these tests aim to verify from an accessibility perspective. For example, JavaScript might set the selection, and this test verifies the corresponding `AXSelection` and its serialized representation.
* **CSS:** CSS affects the rendering and therefore can influence the structure of the accessibility tree (e.g., `display: none`, `visibility: hidden`). While not directly manipulating CSS in this file, the tests implicitly rely on the CSS applied to the loaded HTML to generate the correct accessibility tree.

**5. Logic and Assumptions**

* **Marker Pairing:** The deserializer assumes '^' and '|' markers are paired. The error handling for mismatched markers is a good point.
* **DOM Order:** The deserializer matches markers in DOM order, which is a reasonable assumption.
* **Accessibility Tree Accuracy:** The tests rely on the correctness of the accessibility tree generated by Blink.
* **Test Data:** The tests assume the existence of `.html` input files and `-ax.txt` expectation files.

**6. User and Programming Errors**

* **Incorrect Markers:** Users writing tests might introduce errors by using the wrong number or placement of '^' and '|' markers. The deserializer's `DCHECK` helps catch this.
* **Expectation Mismatches:**  The most common error is that the actual output doesn't match the expected output in the `-ax.txt` file. This indicates a bug in the accessibility selection logic.
* **Missing Data Dependencies:**  The `ASSERT_TRUE(test_file_data)` check in `RunSelectionTest` highlights a common error: forgetting to list the test data files in the BUILD file.

**7. Debugging Clues - How to Reach This Code**

* **Developer Workflow:** A developer working on accessibility selection features would likely:
    1. Write or modify C++ code related to selection (e.g., in `AXSelection`, `AXPosition`, or core editing code).
    2. Create or update test cases in `accessibility_selection_test.cc` to verify the changes. This involves crafting HTML snippets with selection markers and updating the corresponding `-ax.txt` expectation files.
    3. Run the test suite. If a test fails, they would examine the diff between the expected and actual output.
    4. Use debugging tools (like gdb) to step through the code in `accessibility_selection_test.cc`, particularly the serializer and deserializer, to understand how the `AXSelection` is being created and represented. They might set breakpoints in `SerializeSubtree`, `HandleTextObject`, `Deserialize`, or `FindSelectionMarkers`.

By following this thought process, we can comprehensively understand the functionality, relationships, assumptions, potential errors, and debugging context of the given C++ file.
这个文件 `accessibility_selection_test.cc` 是 Chromium Blink 引擎中用于测试辅助功能（Accessibility）模块中选择（Selection）功能的单元测试文件。它主要用于验证当用户在网页上进行文本或元素选择时，辅助功能树（Accessibility Tree）中对选择的表示是否正确。

以下是它的主要功能及其与 JavaScript、HTML、CSS 的关系，逻辑推理，用户/编程错误，以及调试线索：

**功能:**

1. **序列化 AXSelection 对象:**  `AXSelectionSerializer` 类负责将一个 `AXSelection` 对象（代表辅助功能树中的选择）序列化成一个易于阅读的字符串格式。这个字符串包含了选择的起始位置（用 '^' 标记）和结束位置（用 '|' 标记），以及周围的辅助功能节点信息。
2. **反序列化 HTML 代码中的选择标记:** `AXSelectionDeserializer` 类负责解析包含特殊选择标记（'^' 和 '|'）的 HTML 代码片段，并根据这些标记创建对应的 `AXSelection` 对象。这使得测试可以方便地定义需要测试的初始选择状态。
3. **创建和管理辅助功能上下文:** `AccessibilitySelectionTest` 类作为测试用例的基类，负责创建必要的辅助功能上下文 (`AXContext`)，确保测试环境的正确配置。
4. **获取当前选择的辅助功能表示:** `GetCurrentSelectionText()` 方法获取当前 DOM 树中的选择，并将其转换为辅助功能树中的 `AXSelection` 对象，然后使用 `AXSelectionSerializer` 进行序列化。
5. **设置辅助功能选择:** `SetSelectionText()` 方法使用 `AXSelectionDeserializer` 解析带有选择标记的 HTML 代码，创建 `AXSelection` 对象，并将其应用到 DOM 树中，从而模拟用户的选择操作。
6. **运行选择测试:** `RunSelectionTest()` 方法是核心的测试执行逻辑。它加载包含 HTML 代码的测试文件，解析其中的选择标记，应用选择，获取实际的辅助功能选择表示，并将其与预期的结果（存储在 `-ax.txt` 文件中）进行比较。

**与 JavaScript, HTML, CSS 的关系:**

* **HTML:** 这个测试文件直接处理 HTML 代码。`AXSelectionDeserializer` 需要解析 HTML 结构来定位选择标记并确定选择的起始和结束节点。测试用例也通过加载 HTML 文件来构建需要测试的页面结构。
    * **举例:** 在测试 HTML 文件中，可以使用如下标记来定义选择：
      ```html
      <p>This is some te^xt with a |selection.</p>
      ```
      `AXSelectionDeserializer` 会解析这段 HTML，创建一个 `AXSelection` 对象，其起始位置在 "te" 之后，结束位置在 "selection" 的 "n" 之前。

* **JavaScript:** 虽然这个文件本身是 C++ 代码，但它测试的是浏览器引擎中与 JavaScript 选择 API 相关的辅助功能实现。用户在网页上通过 JavaScript 代码设置或获取选择时，Blink 引擎会同步更新辅助功能树中的选择信息。这个测试文件验证了这种同步的正确性。
    * **举例:**  假设 JavaScript 代码执行了 `window.getSelection().setBaseAndExtent(startNode, startOffset, endNode, endOffset)` 来设置选择。`accessibility_selection_test.cc` 中的测试会验证，在这种情况下，辅助功能树中 `AXSelection` 对象的 `Anchor()` 和 `Focus()` 是否与 JavaScript 设置的选择一致。

* **CSS:** CSS 可以影响页面的布局和渲染，进而影响辅助功能树的结构。虽然这个测试文件不直接解析 CSS，但 CSS 的效果会体现在辅助功能树的构建上，因此间接地影响测试结果。
    * **举例:** 如果一个元素通过 `display: none` 或 `visibility: hidden` 隐藏，它通常不会出现在辅助功能树中，也不会参与选择。这个测试文件可能会包含一些用例来验证在这种情况下，辅助功能选择的行为是否符合预期。

**逻辑推理:**

`AXSelectionDeserializer` 的核心逻辑是根据 '^' 和 '|' 标记推断出 `AXSelection` 对象的起始和结束位置。

* **假设输入:**  HTML 代码片段 `<p>Hel^lo W|orld</p>`
* **输出:** 一个 `AXSelection` 对象，其 `Anchor()` 指向 `<p>` 元素的文本节点 "Hello World" 中 "l" 字符之后的位置，`Focus()` 指向 "o" 字符之后的位置。
* **推理过程:**
    1. `AXSelectionDeserializer` 扫描 HTML 内容，找到 '^' 标记在 "l" 之后，'|' 标记在 "o" 之后。
    2. 它确定这两个标记都在同一个文本节点中。
    3. 它创建一个 `AXPosition` 对象作为 `Anchor()`，指向该文本节点，偏移量为 'l' 之后的索引。
    4. 它创建一个 `AXPosition` 对象作为 `Focus()`，指向该文本节点，偏移量为 'o' 之后的索引。
    5. 它使用这两个 `AXPosition` 对象构建一个 `AXSelection` 对象。

**用户或编程常见的使用错误:**

1. **选择标记不匹配:** 用户在编写测试用例时，可能会忘记添加配对的 '^' 和 '|' 标记，或者标记的数量不一致。
   * **举例:** HTML 代码 `<p>Test ^ selection</p>` 缺少结束标记 '|'，`AXSelectionDeserializer` 会发出断言错误。
2. **标记位置错误:**  标记被放置在不允许的位置，例如 HTML 标签内部或属性值中。
   * **举例:**  `<p a^ria-label="Test | label">Text</p>`  标记在 `aria-label` 属性中是不被允许的，`AXSelectionDeserializer` 不会将其识别为选择标记。
3. **期望文件错误:**  `-ax.txt` 文件中的预期输出与实际的辅助功能选择表示不一致。这可能是因为对代码的更改导致了辅助功能选择行为的改变，而期望文件没有及时更新。
4. **忘记更新测试数据依赖:** 在 BUILD 文件中没有声明对测试 `.html` 和 `-ax.txt` 文件的依赖，导致测试无法找到这些文件。 `RunSelectionTest` 中有相应的断言来检查这种情况。

**用户操作是如何一步步的到达这里，作为调试线索:**

1. **用户交互:** 用户通过鼠标拖拽、键盘快捷键（如 Shift + 箭头键）或者触摸操作在网页上选择文本或元素。
2. **浏览器事件:** 用户的选择操作会触发浏览器引擎中的选择相关的事件。
3. **DOM 选择更新:**  浏览器引擎会更新 DOM 树中的 `Selection` 对象，记录选择的起始和结束节点以及偏移量。
4. **辅助功能树同步:** Blink 引擎的辅助功能模块会监听 DOM 选择的变化，并将这些变化同步到辅助功能树中。这涉及到创建或更新 `AXSelection` 对象，并将其关联到相应的辅助功能节点。
5. **`accessibility_selection_test.cc` 的作用:**  这个测试文件模拟了上述过程，但不是通过真实的 UI 事件，而是通过直接设置带有选择标记的 HTML 代码，并验证辅助功能树中 `AXSelection` 对象的正确性。

**作为调试线索，当辅助功能选择出现问题时，可以按照以下步骤进行调试:**

1. **复现问题:** 尝试通过用户操作或特定的 JavaScript 代码复现导致辅助功能选择错误的场景。
2. **查看辅助功能树:** 使用浏览器的辅助功能检查工具（例如 Chrome 的 Accessibility Inspector）查看辅助功能树的结构，特别是与选择相关的节点和属性。
3. **运行相关的单元测试:**  找到 `accessibility_selection_test.cc` 中与复现场景相似的测试用例，或者创建一个新的测试用例来覆盖该场景。
4. **断点调试:** 在 `AXSelectionSerializer` 和 `AXSelectionDeserializer` 的关键方法中设置断点，例如 `SerializeSubtree`，`HandleTextObject`，`Deserialize`，`FindSelectionMarkers` 等，跟踪 `AXSelection` 对象的创建和序列化过程，查看选择的起始和结束位置是否正确。
5. **比较预期和实际输出:**  比较测试运行的实际输出与预期文件中的内容，找出差异，并根据差异定位问题所在。
6. **检查 DOM 选择:** 确认 DOM 树中的 `Selection` 对象是否与预期的用户选择一致。
7. **排查辅助功能树构建逻辑:** 如果辅助功能树本身构建不正确，那么选择的表示也会出错。需要检查辅助功能树的构建代码，找出问题所在。

总而言之，`accessibility_selection_test.cc` 是一个关键的测试文件，用于确保 Chromium Blink 引擎中辅助功能模块对用户选择的表示是准确可靠的，这对于依赖屏幕阅读器等辅助技术的用户来说至关重要。

### 提示词
```
这是目录为blink/renderer/modules/accessibility/testing/accessibility_selection_test.cc的chromium blink引擎源代码文件， 请列举一下它的功能, 
如果它与javascript, html, css的功能有关系，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索。
```

### 源代码
```cpp
// Copyright 2018 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "third_party/blink/renderer/modules/accessibility/testing/accessibility_selection_test.h"

#include <iterator>
#include <string_view>

#include "base/containers/span.h"
#include "base/memory/scoped_refptr.h"
#include "base/ranges/algorithm.h"
#include "third_party/blink/public/platform/file_path_conversion.h"
#include "third_party/blink/renderer/core/dom/character_data.h"
#include "third_party/blink/renderer/core/dom/container_node.h"
#include "third_party/blink/renderer/core/dom/node.h"
#include "third_party/blink/renderer/core/editing/frame_selection.h"
#include "third_party/blink/renderer/core/editing/position.h"
#include "third_party/blink/renderer/core/editing/selection_template.h"
#include "third_party/blink/renderer/core/frame/local_frame.h"
#include "third_party/blink/renderer/core/html/html_element.h"
#include "third_party/blink/renderer/modules/accessibility/ax_object.h"
#include "third_party/blink/renderer/modules/accessibility/ax_object_cache_impl.h"
#include "third_party/blink/renderer/modules/accessibility/ax_position.h"
#include "third_party/blink/renderer/modules/accessibility/ax_selection.h"
#include "third_party/blink/renderer/platform/heap/garbage_collected.h"
#include "third_party/blink/renderer/platform/testing/unit_test_helpers.h"
#include "third_party/blink/renderer/platform/wtf/shared_buffer.h"
#include "third_party/blink/renderer/platform/wtf/text/string_builder.h"
#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
#include "third_party/blink/renderer/platform/wtf/vector.h"

namespace blink {
namespace {

constexpr char kSelectionTestsRelativePath[] = "selection/";
constexpr char kTestFileSuffix[] = ".html";
constexpr char kAXTestExpectationSuffix[] = "-ax.txt";

// Serialize accessibility subtree to selection text.
// Adds a '^' at the selection anchor offset and a '|' at the focus offset.
class AXSelectionSerializer final {
  STACK_ALLOCATED();

 public:
  explicit AXSelectionSerializer(const AXSelection& selection)
      : tree_level_(0), selection_(selection) {}
  ~AXSelectionSerializer() = default;

  std::string Serialize(const AXObject& subtree) {
    if (!selection_.IsValid())
      return {};
    SerializeSubtree(subtree);
    DCHECK_EQ(tree_level_, 0);
    return builder_.ToString().Utf8();
  }

 private:
  void HandleTextObject(const AXObject& text_object) {
    builder_.Append('<');
    builder_.Append(AXObject::InternalRoleName(text_object.RoleValue()));
    builder_.Append(": ");
    const String name = text_object.ComputedName() + ">\n";
    const AXObject& base_container = *selection_.Anchor().ContainerObject();
    const AXObject& extent_container = *selection_.Focus().ContainerObject();

    if (base_container == text_object && extent_container == text_object) {
      DCHECK(selection_.Anchor().IsTextPosition() &&
             selection_.Focus().IsTextPosition());
      const int base_offset = selection_.Anchor().TextOffset();
      const int extent_offset = selection_.Focus().TextOffset();

      if (base_offset == extent_offset) {
        builder_.Append(name.Left(base_offset));
        builder_.Append('|');
        builder_.Append(name.Substring(base_offset));
        return;
      }

      if (base_offset < extent_offset) {
        builder_.Append(name.Left(base_offset));
        builder_.Append('^');
        builder_.Append(
            name.Substring(base_offset, extent_offset - base_offset));
        builder_.Append('|');
        builder_.Append(name.Substring(extent_offset));
        return;
      }

      builder_.Append(name.Left(extent_offset));
      builder_.Append('|');
      builder_.Append(
          name.Substring(extent_offset, base_offset - extent_offset));
      builder_.Append('^');
      builder_.Append(name.Substring(base_offset));
      return;
    }

    if (base_container == text_object) {
      DCHECK(selection_.Anchor().IsTextPosition());
      const int base_offset = selection_.Anchor().TextOffset();

      builder_.Append(name.Left(base_offset));
      builder_.Append('^');
      builder_.Append(name.Substring(base_offset));
      return;
    }

    if (extent_container == text_object) {
      DCHECK(selection_.Focus().IsTextPosition());
      const int extent_offset = selection_.Focus().TextOffset();

      builder_.Append(name.Left(extent_offset));
      builder_.Append('|');
      builder_.Append(name.Substring(extent_offset));
      return;
    }

    builder_.Append(name);
  }

  void HandleObject(const AXObject& object) {
    builder_.Append('<');
    builder_.Append(AXObject::InternalRoleName(object.RoleValue()));

    String name = object.ComputedName();
    if (name.length()) {
      builder_.Append(": ");
      builder_.Append(name);
    }

    builder_.Append(">\n");
    SerializeSubtree(object);
  }

  void HandleSelection(const AXPosition& position) {
    if (!position.IsValid())
      return;

    if (selection_.Focus() == position) {
      builder_.Append('|');
      return;
    }

    if (selection_.Anchor() != position) {
      return;
    }

    builder_.Append('^');
  }

  void SerializeSubtree(const AXObject& subtree) {
    if (!subtree.ChildCountIncludingIgnored()) {
      // Though they are in this particular case both equivalent to an "after
      // object" position, "Before children" and "after children" positions are
      // still valid within empty subtrees.
      const auto position = AXPosition::CreateFirstPositionInObject(subtree);
      HandleSelection(position);
      return;
    }

    for (const AXObject* child : subtree.ChildrenIncludingIgnored()) {
      DCHECK(child);
      const auto position = AXPosition::CreatePositionBeforeObject(*child);
      HandleSelection(position);
      ++tree_level_;
      builder_.Append(String::FromUTF8(std::string(tree_level_ * 2, '+')));
      if (position.IsTextPosition()) {
        HandleTextObject(*child);
      } else {
        HandleObject(*child);
      }
      --tree_level_;
    }

    // Handle any "after children" positions.
    HandleSelection(AXPosition::CreateLastPositionInObject(subtree));
  }

  StringBuilder builder_;
  int tree_level_;
  AXSelection selection_;
};

// Deserializes an HTML snippet with or without selection markers to an
// |AXSelection| object. A '^' could be present at the selection anchor offset
// and a '|' at the focus offset. If multiple markers are present, the
// deserializer will return multiple |AXSelection| objects. If there are
// multiple markers, the first '|' in DOM order will be matched with the first
// '^' marker, the second '|' with the second '^', and so on. If there are more
// '|'s than '^'s or vice versa, the deserializer will DCHECK. If there are no
// markers, no |AXSelection| objects will be returned. We don't allow '^' and
// '|' markers to appear in anything other than the contents of an HTML node,
// e.g. they are not permitted in aria-labels.
class AXSelectionDeserializer final {
  STACK_ALLOCATED();

 public:
  explicit AXSelectionDeserializer(AXObjectCacheImpl& cache)
      : ax_object_cache_(&cache),
        anchors_(MakeGarbageCollected<VectorOfPairs<Node, int>>()),
        foci_(MakeGarbageCollected<VectorOfPairs<Node, int>>()) {}
  ~AXSelectionDeserializer() = default;

  // Creates an accessibility tree rooted at the given HTML element from the
  // provided HTML snippet and returns |AXSelection| objects that can select the
  // parts of the tree indicated by the selection markers in the snippet.
  const Vector<AXSelection> Deserialize(const std::string_view& html_snippet,
                                        HTMLElement& element) {
    element.setInnerHTML(String::FromUTF8(html_snippet));
    element.GetDocument().View()->UpdateAllLifecyclePhasesForTest();
    AXObject* root = ax_object_cache_->Get(&element);
    if (!root || root->IsDetached())
      return {};

    FindSelectionMarkers(*root);
    DCHECK((foci_->size() == 1 && anchors_->size() == 0) ||
           anchors_->size() == foci_->size())
        << "There should be an equal number of '^'s and '|'s in the HTML that "
           "is being deserialized, or if caret placement is required, only a "
           "single '|'.";
    if (foci_->empty())
      return {};

    Vector<AXSelection> ax_selections;
    if (anchors_->empty()) {
      // Handle the case when there is just a single '|' marker representing the
      // position of the caret.
      DCHECK(foci_->at(0).first);
      const Position caret(foci_->at(0).first, foci_->at(0).second);
      const auto ax_caret = AXPosition::FromPosition(caret);
      AXSelection::Builder builder;
      ax_selections.push_back(
          builder.SetAnchor(ax_caret).SetFocus(ax_caret).Build());
      return ax_selections;
    }

    for (wtf_size_t i = 0; i < foci_->size(); ++i) {
      DCHECK(anchors_->at(i).first);
      const Position base(*anchors_->at(i).first, anchors_->at(i).second);
      const auto ax_base = AXPosition::FromPosition(base);

      DCHECK(foci_->at(i).first);
      const Position extent(*foci_->at(i).first, foci_->at(i).second);
      const auto ax_extent = AXPosition::FromPosition(extent);
      AXSelection::Builder builder;
      ax_selections.push_back(
          builder.SetAnchor(ax_base).SetFocus(ax_extent).Build());
    }

    return ax_selections;
  }

 private:
  void HandleCharacterData(const AXObject& text_object) {
    auto* const node = To<CharacterData>(text_object.GetNode());
    Vector<int> base_offsets;
    Vector<int> extent_offsets;
    unsigned number_of_markers = 0;
    StringBuilder builder;
    for (unsigned i = 0; i < node->length(); ++i) {
      const UChar character = node->data()[i];
      if (character == '^') {
        base_offsets.push_back(static_cast<int>(i - number_of_markers));
        ++number_of_markers;
        continue;
      }

      if (character == '|') {
        extent_offsets.push_back(static_cast<int>(i - number_of_markers));
        ++number_of_markers;
        continue;
      }

      builder.Append(character);
    }

    if (base_offsets.empty() && extent_offsets.empty())
      return;

    // Remove the markers, otherwise they would be duplicated if the AXSelection
    // is re-serialized.
    node->setData(builder.ToString());
    node->GetDocument().View()->UpdateAllLifecyclePhasesForTest();

    //
    // Non-text selection.
    //

    if (node->ContainsOnlyWhitespaceOrEmpty()) {
      // Since the text object contains only selection markers, this indicates
      // that this is a request for a non-text selection.
      Node* const parent = node->ParentOrShadowHostNode();
      int index_in_parent = static_cast<int>(node->NodeIndex());

      for (size_t i = 0; i < base_offsets.size(); ++i)
        anchors_->emplace_back(parent, index_in_parent);

      for (size_t i = 0; i < extent_offsets.size(); ++i)
        foci_->emplace_back(parent, index_in_parent);

      return;
    }

    //
    // Text selection.
    //

    for (int base_offset : base_offsets)
      anchors_->emplace_back(node, base_offset);
    for (int extent_offset : extent_offsets)
      foci_->emplace_back(node, extent_offset);
  }

  void HandleObject(const AXObject& object) {
    // Make a copy of the children, because they may be cleared when a sibling
    // is invalidated and calls SetNeedsToUpdateChildren() on the parent.
    const auto children = object.ChildrenIncludingIgnored();

    for (const AXObject* child : children) {
      DCHECK(child);
      FindSelectionMarkers(*child);
    }
  }

  void FindSelectionMarkers(const AXObject& root) {
    const Node* node = root.GetNode();
    if (node && node->IsCharacterDataNode()) {
      HandleCharacterData(root);
      // |root| will need to be detached and replaced with an updated AXObject.
      return;
    }
    HandleObject(root);
  }

  Persistent<AXObjectCacheImpl> const ax_object_cache_;

  // Pairs of anchor nodes + anchor offsets.
  Persistent<VectorOfPairs<Node, int>> anchors_;

  // Pairs of focus nodes + focus offsets.
  Persistent<VectorOfPairs<Node, int>> foci_;
};

}  // namespace

AccessibilitySelectionTest::AccessibilitySelectionTest(
    LocalFrameClient* local_frame_client)
    : AccessibilityTest(local_frame_client) {}

void AccessibilitySelectionTest::SetUp() {
  RenderingTest::SetUp();
  // Do not include noisy inline textboxes in selection tests.
  ax_context_ =
      std::make_unique<AXContext>(GetDocument(), ui::AXMode::kWebContents);
}

std::string AccessibilitySelectionTest::GetCurrentSelectionText() const {
  const SelectionInDOMTree selection =
      GetFrame().Selection().GetSelectionInDOMTree();
  const auto ax_selection = AXSelection::FromSelection(selection);
  return GetSelectionText(ax_selection);
}

std::string AccessibilitySelectionTest::GetSelectionText(
    const AXSelection& selection) const {
  const AXObject* root = GetAXRootObject();
  if (!root || root->IsDetached())
    return {};
  return AXSelectionSerializer(selection).Serialize(*root);
}

std::string AccessibilitySelectionTest::GetSelectionText(
    const AXSelection& selection,
    const AXObject& subtree) const {
  return AXSelectionSerializer(selection).Serialize(subtree);
}

AXSelection AccessibilitySelectionTest::SetSelectionText(
    const std::string& selection_text) const {
  HTMLElement* body = GetDocument().body();
  if (!body)
    return AXSelection::Builder().Build();
  const Vector<AXSelection> ax_selections =
      AXSelectionDeserializer(GetAXObjectCache())
          .Deserialize(selection_text, *body);
  if (ax_selections.empty())
    return AXSelection::Builder().Build();
  return ax_selections.front();
}

AXSelection AccessibilitySelectionTest::SetSelectionText(
    const std::string& selection_text,
    HTMLElement& element) const {
  const Vector<AXSelection> ax_selections =
      AXSelectionDeserializer(GetAXObjectCache())
          .Deserialize(selection_text, element);
  if (ax_selections.empty())
    return AXSelection::Builder().Build();
  return ax_selections.front();
}

void AccessibilitySelectionTest::RunSelectionTest(
    const std::string& test_name,
    const std::string& suffix) const {
  static const std::string separator_line = '\n' + std::string(80, '=') + '\n';
  const String relative_path = String::FromUTF8(kSelectionTestsRelativePath) +
                               String::FromUTF8(test_name);
  const String test_path = test::AccessibilityTestDataPath(relative_path);

  const String test_file = test_path + String::FromUTF8(kTestFileSuffix);
  std::optional<Vector<char>> test_file_data = test::ReadFromFile(test_file);
  ASSERT_TRUE(test_file_data)
      << "Test file cannot be empty.\n"
      << test_file.Utf8()
      << "\nDid you forget to add a data dependency to the BUILD file?";

  const String ax_file =
      test_path +
      String::FromUTF8(suffix.empty() ? kAXTestExpectationSuffix : suffix);
  std::optional<Vector<char>> ax_file_data = test::ReadFromFile(ax_file);
  ASSERT_TRUE(ax_file_data)
      << "Expectations file cannot be empty.\n"
      << ax_file.Utf8()
      << "\nDid you forget to add a data dependency to the BUILD file?";
  std::string_view ax_file_contents = base::as_string_view(*ax_file_data);

  HTMLElement* body = GetDocument().body();
  ASSERT_NE(nullptr, body);
  Vector<AXSelection> ax_selections =
      AXSelectionDeserializer(GetAXObjectCache())
          .Deserialize(base::as_string_view(*test_file_data), *body);
  std::string actual_ax_file_contents;

  for (auto& ax_selection : ax_selections) {
    ax_selection.Select();
    actual_ax_file_contents += separator_line;
    actual_ax_file_contents += ax_selection.ToString().Utf8();
    actual_ax_file_contents += separator_line;
    actual_ax_file_contents += GetCurrentSelectionText();
  }

  EXPECT_TRUE(ax_file_contents == actual_ax_file_contents)
      << "\nSelection does not match expectations. Legend: ^=selection start  "
         "|=selection end"
      << "\n\nExpected:\n--------\n"
      << ax_file_contents << "\n\nActual:\n------\n"
      << actual_ax_file_contents;

  // Uncomment these lines to write the output to the expectations file.
  // TODO(dmazzoni): make this a command-line parameter.
  // if (ax_file_contents != actual_ax_file_contents)
  //  base::WriteFile(WebStringToFilePath(ax_file), actual_ax_file_contents);
}

}  // namespace blink
```
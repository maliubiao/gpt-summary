Response: Let's break down the thought process for analyzing this C++ test file.

1. **Understand the Goal:** The fundamental goal is to understand the *purpose* of the file and how it achieves that purpose. This involves looking at the filename, directory, and the code itself.

2. **Identify Key Information in Filename and Directory:**
    * `blink/common/interest_group/test/interest_group_test_utils_unittest.cc`: This tells us several things:
        * `blink`:  It's part of the Blink rendering engine.
        * `common`:  Indicates these utilities are likely shared across different parts of Blink.
        * `interest_group`: The utilities are related to the "Interest Group" feature. This immediately brings to mind the Privacy Sandbox's FLEDGE/Protected Audience API, which uses interest groups.
        * `test`:  This confirms it's a testing file.
        * `_unittest`: Specifically, it's a unit test file.
        * `interest_group_test_utils`:  This suggests it tests some *utility functions* specifically for testing interest group functionality.

3. **Scan the Includes:** The included headers provide valuable clues about the file's dependencies and what kind of operations it performs:
    * `"third_party/blink/public/common/interest_group/test/interest_group_test_utils.h"`: This is the header file for the utilities being tested. It's crucial!
    * `"build/build_config.h"`, `"build/buildflag.h"`:  Build system related, likely for platform-specific logic or feature flags.
    * `"testing/gtest/include/gtest/gtest-spi.h"`, `"testing/gtest/include/gtest/gtest.h"`:  Confirms it's using Google Test for unit testing. The `-spi` version suggests testing internal aspects or error reporting of the testing framework itself.
    * `"third_party/blink/public/common/interest_group/test_interest_group_builder.h"`: Indicates the tests are likely creating and manipulating `InterestGroup` objects, potentially using a builder pattern for easier construction.
    * `"url/gurl.h"`, `"url/origin.h"`:  Shows that URLs and Origins are central to the `InterestGroup` concept.

4. **Analyze the `namespace` and Constants:**
    * `namespace { ... }`: The anonymous namespace means the symbols within are only visible within this compilation unit, good for preventing naming conflicts.
    * `constexpr char kTestOriginName[] = ...;`, `constexpr char kTestGroupName[] = ...;`: These define test constants, indicating the basic structure and data used in the tests.

5. **Examine the Test Fixture (`MAYBE_InterestGroupTestUtilsTest`):**
    * `class MAYBE_InterestGroupTestUtilsTest : public testing::Test`:  This sets up a test fixture, providing a common context for multiple test cases.
    * `protected: const GURL kTestUrl = ...; const url::Origin kTestOrigin = ...;`: This initializes common `GURL` and `Origin` objects used in the tests, aligning with the constants. The `MAYBE_` prefix likely handles conditional disabling of tests on certain platforms.

6. **Deep Dive into the Test Cases:** This is where the core functionality is revealed. Look for the `TEST_F` macros, which define individual test cases within the fixture. Analyze what each test case is doing:
    * **`CompareSimple`:** Compares basic fields (like `name`) of `InterestGroup` objects using `IgExpectEqualsForTesting` and `IgExpectNotEqualsForTesting`. Crucially, it also checks the *error messages* generated by the negative assertions. This is a strong indicator the utilities are about providing *better error reporting* during tests.
    * **`CompareOptional`:** Focuses on comparing optional fields (like `bidding_url`). It tests cases where the optional is present in one but not the other, and when both are present and equal.
    * **`CompareOptionalVector` and `CompareOptionalMap`:** Similar to `CompareOptional`, but for optional fields that are vectors and maps. It emphasizes testing the presence/absence of these collections.
    * **`CompareSizeMismatchVector` and `CompareSizeMismatchMap`:** Tests comparisons where the vectors or maps have different sizes, again checking the quality of the error messages.
    * **`CompareElementVector` and `CompareElementMap`:**  Focuses on comparing the *elements* within vectors and maps, highlighting the error reporting when elements differ.
    * **`CompareDeep`:**  Tests comparisons of nested structures (like `size_groups`), demonstrating the utility functions can handle deeper comparisons.

7. **Synthesize the Findings:** Based on the analysis of the test cases,  you can start to form conclusions about the file's purpose. The repeated use of `IgExpectEqualsForTesting` and `IgExpectNotEqualsForTesting` and the focus on error message content are key.

8. **Connect to Broader Concepts:**  Think about how the "Interest Group" feature relates to web technologies:
    * **JavaScript:**  Interest Groups are created and managed through JavaScript APIs in the browser.
    * **HTML:**  While not directly related to rendering HTML, Interest Groups influence ad selection, which affects what content (including HTML) is ultimately displayed.
    * **CSS:** Indirectly related, as the ads selected via Interest Groups might have associated CSS.

9. **Consider Potential Errors:** Think about common mistakes developers might make when working with `InterestGroup` objects and how these test utilities help catch those errors. Mismatched field values, incorrect sizes of collections, and differences in nested structures are all possibilities.

10. **Refine and Organize:** Structure your findings logically, starting with a high-level summary and then providing more specific details and examples. Address each part of the prompt clearly.

**Self-Correction/Refinement During the Process:**

* **Initial thought:** "This just tests InterestGroup objects."  **Correction:**  It's not testing the *functionality* of Interest Groups, but rather *utility functions* specifically designed for *testing* Interest Groups. The focus is on *comparison* and *error reporting*.
* **Realization:** The repeated checking of error message strings is a strong signal. This isn't just about pass/fail tests, but about providing *informative failures*.
* **Connection to FLEDGE/Protected Audience:**  The term "Interest Group" strongly suggests a connection to the Privacy Sandbox. Explicitly mentioning this adds valuable context.

By following this systematic approach, combining code analysis with domain knowledge, and iteratively refining your understanding, you can arrive at a comprehensive and accurate description of the file's functionality.
这个文件 `interest_group_test_utils_unittest.cc` 是 Chromium Blink 引擎中用于测试 **interest_group_test_utils.h** 头文件中定义的测试工具函数的单元测试文件。这些工具函数的主要目的是为了方便和清晰地比较 `blink::InterestGroup` 对象在测试中的相等性和不等性，并提供更详细的失败信息。

**功能概览:**

该文件的主要功能是测试 `IgExpectEqualsForTesting` 和 `IgExpectNotEqualsForTesting` 这两个自定义的断言宏。这些宏的作用是：

1. **深度比较 `blink::InterestGroup` 对象:**  `blink::InterestGroup` 对象可能包含各种类型的成员变量，包括基本类型、可选类型 (optional)、容器类型 (vector, map) 以及嵌套的结构。这两个宏能够递归地比较这些成员，确保即使是深层嵌套的差异也能被检测出来。
2. **提供更清晰的失败信息:** 当比较失败时，这两个宏会生成更易于理解的错误消息，明确指出哪些成员变量的值不一致，从而帮助开发者快速定位问题。  标准的 `EXPECT_EQ` 和 `EXPECT_NE` 在处理复杂对象时可能只能给出简单的“不相等”的结论，而无法清晰地指出具体差异。

**与 JavaScript, HTML, CSS 的关系:**

`blink::InterestGroup` 是 Chromium 中实现 Privacy Sandbox 的 Protected Audience API (以前称为 FLEDGE) 的核心概念之一。Protected Audience API 允许浏览器为用户维护兴趣群体 (Interest Groups)，并在不泄露用户身份的情况下，进行与这些兴趣相关的广告竞价和展示。

虽然这个 C++ 测试文件本身不直接包含 JavaScript、HTML 或 CSS 代码，但它测试的 `InterestGroup` 功能与这些 Web 技术密切相关：

* **JavaScript:**  网站可以使用 JavaScript API（例如 `navigator.joinAdInterestGroup()` 和 `navigator.leaveAdInterestGroup()`）来管理用户的兴趣群体。  测试工具的正确性直接影响到对这些 JavaScript API 实现的测试。例如，如果一个 JavaScript 函数声称成功地添加了一个用户到兴趣群体，那么后端存储的 `blink::InterestGroup` 对象应该与期望的状态一致，而测试工具可以用来验证这一点。
* **HTML:**  当浏览器为一个兴趣群体执行广告竞价时，胜出的广告可能包含 HTML 代码，用于展示给用户。`InterestGroup` 的信息（例如 bidding logic URL）会影响最终展示的 HTML 内容。测试工具可以帮助验证在特定 `InterestGroup` 状态下，竞价逻辑是否正确执行。
* **CSS:** 类似于 HTML，胜出的广告也可能包含 CSS 样式，用于控制广告的呈现。`InterestGroup` 同样会影响最终的 CSS 输出。

**举例说明:**

假设我们有以下 JavaScript 代码将用户添加到一个名为 "shoes" 的兴趣群体：

```javascript
navigator.joinAdInterestGroup({
  owner: 'https://example.com',
  name: 'shoes',
  biddingLogicUrl: 'https://example.com/bidding_logic.js',
  // ... 其他属性
}, 30 * 24 * 60 * 60);
```

在 Chromium 的后端代码中，这个操作会创建一个 `blink::InterestGroup` 对象。为了测试这个操作是否正确，我们可能会在 C++ 单元测试中创建一个期望的 `blink::InterestGroup` 对象，并使用 `IgExpectEqualsForTesting` 来比较实际创建的对象和期望的对象：

```c++
TEST_F(MyInterestGroupTest, JoinInterestGroup) {
  url::Origin expected_owner = url::Origin::UnsafelyCreateFromString("https://example.com");
  std::string expected_name = "shoes";
  GURL expected_bidding_url("https://example.com/bidding_logic.js");

  blink::InterestGroup actual_group = GetInterestGroupFromBackend("https://example.com", "shoes"); // 假设有这样一个函数

  blink::InterestGroup expected_group =
      blink::TestInterestGroupBuilder(expected_owner, expected_name)
          .SetBiddingUrl(expected_bidding_url)
          .Build();

  IgExpectEqualsForTesting(actual_group, expected_group);
}
```

如果 `actual_group` 和 `expected_group` 的 `bidding_url` 不一致，`IgExpectEqualsForTesting` 将会输出类似以下的错误信息：

```
Expected equality of these values:
  actual_group.bidding_url
    Which is: (nullopt)
  expected_group.bidding_url
    Which is: (https://example.com/bidding_logic.js)
```

这样的错误信息比简单的 `EXPECT_EQ` 提供的 "Value of: actual_group == expected_group\n  Actual: false\nExpected: true" 更具指导意义。

**逻辑推理、假设输入与输出:**

考虑 `CompareOptional` 测试用例：

**假设输入:**

* `actual`: 一个 `blink::InterestGroup` 对象，其 `bidding_url` 为空 (nullopt)。
* `expected`: 一个 `blink::InterestGroup` 对象，其 `bidding_url` 设置为 `https://origin.test/`。

**逻辑推理:**

`IgExpectNotEqualsForTesting(actual, expected)` 会比较 `actual` 和 `expected` 对象的每个成员。当比较到 `bidding_url` 成员时，会发现 `actual.bidding_url` 是空的，而 `expected.bidding_url` 有值，因此断言应该成功 (即认为两个对象不相等)。

`EXPECT_NONFATAL_FAILURE(IgExpectEqualsForTesting(actual, expected), ...)` 会尝试比较这两个对象是否相等。由于 `bidding_url` 不同，比较会失败，并且会生成预期的错误消息，包含 `actual.bidding_url` 的值为 `(nullopt)` 和 `expected.bidding_url` 的值为 `(https://origin.test/)`。

**假设输出 (针对 `EXPECT_NONFATAL_FAILURE`):**

```
Value of: IgExpectEqualsForTesting(actual, expected)
  Actual: <error message indicating bidding_url difference>
Expected: (no expectation for the return value, but the side effect is the error message)
```

更具体地，`EXPECT_NONFATAL_FAILURE` 内部会捕获 `IgExpectEqualsForTesting` 产生的 gtest 失败信息，并与预期的字符串进行比较。

**用户或编程常见的使用错误:**

1. **忘记比较可选类型:** 如果只使用标准的 `EXPECT_EQ` 来比较 `InterestGroup` 对象，并且忘记了对可选类型进行特殊处理，那么即使两个对象的其他部分都相同，但一个的可选类型有值而另一个没有，`EXPECT_EQ` 也可能返回“相等”，导致测试遗漏问题。`IgExpectEqualsForTesting` 通过深度比较可以避免这个问题。

   **例子:**

   ```c++
   // 使用 EXPECT_EQ (可能出错)
   EXPECT_EQ(actual_group, expected_group); // 如果 bidding_url 不同但其他相同，可能不会报错

   // 使用 IgExpectEqualsForTesting (更安全)
   IgExpectEqualsForTesting(actual_group, expected_group); // 会明确指出 bidding_url 的差异
   ```

2. **容器类型元素的顺序差异:** 对于包含 `std::vector` 或 `std::map` 的 `InterestGroup` 对象，标准的 `EXPECT_EQ` 可能会因为容器内元素的顺序不同而判断为不相等，即使元素内容相同。`IgExpectEqualsForTesting` 的实现会考虑到这一点，确保在元素内容相同的情况下，即使顺序不同，也会被认为是相等的（对于 `std::vector`，顺序很重要，对于 `std::map`，键值对相同即可）。

   **例子 (针对 `std::vector`):**

   ```c++
   blink::InterestGroup group1;
   group1.trusted_bidding_signals_keys = {"a", "b"};

   blink::InterestGroup group2;
   group2.trusted_bidding_signals_keys = {"b", "a"};

   // EXPECT_EQ(group1, group2); // 会认为不相等

   // IgExpectEqualsForTesting 可能会根据其实现方式，也认为不相等，
   // 但它会提供更详细的错误信息，指出 "a" 和 "b" 的顺序不同。
   IgExpectNotEqualsForTesting(group1, group2);
   ```

3. **深层嵌套结构的比较:** 当 `InterestGroup` 对象包含深层嵌套的结构时，手动比较每个成员非常繁琐且容易出错。`IgExpectEqualsForTesting` 能够递归地比较这些嵌套结构，简化了测试代码并提高了准确性。

   **例子:**

   如果 `InterestGroup` 中有 `size_groups` 这样的 `std::map<std::string, std::vector<std::string>>` 成员，使用 `IgExpectEqualsForTesting` 可以方便地比较深层嵌套的字符串值，而不需要编写复杂的循环来手动比较。

总而言之，`interest_group_test_utils_unittest.cc` 这个文件通过测试自定义的断言宏，确保了用于比较 `blink::InterestGroup` 对象的测试工具的正确性和有效性，这对于验证 Protected Audience API 的相关功能至关重要。这些测试工具能够提供更清晰的错误信息，帮助开发者更快速地定位和修复与兴趣群体功能相关的缺陷。

Prompt: 
```
这是目录为blink/common/interest_group/test/interest_group_test_utils_unittest.cc的chromium blink引擎源代码文件， 请列举一下它的功能, 
如果它与javascript, html, css的功能有关系，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明

"""
// Copyright 2024 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "third_party/blink/public/common/interest_group/test/interest_group_test_utils.h"

#include "build/build_config.h"
#include "build/buildflag.h"
#include "testing/gtest/include/gtest/gtest-spi.h"
#include "testing/gtest/include/gtest/gtest.h"
#include "third_party/blink/public/common/interest_group/test_interest_group_builder.h"
#include "url/gurl.h"
#include "url/origin.h"

// NOTE: There doesn't appear to be a way to easily retrieve SCOPED_TRACE()
// elements -- the SCOPED_TRACE() values could be tested if
// https://github.com/google/googletest/issues/4589 is resolved.

namespace {

constexpr char kTestOriginName[] = "https://origin.test";
constexpr char kTestGroupName[] = "shoes";

#if BUILDFLAG(IS_WIN)
// TODO(crbug.com/41496717): Fix flaky tests on Windows.
#define MAYBE_InterestGroupTestUtilsTest DISABLED_InterestGroupTestUtilsTest
#else
#define MAYBE_InterestGroupTestUtilsTest InterestGroupTestUtilsTest
#endif
class MAYBE_InterestGroupTestUtilsTest : public testing::Test {
 protected:
  const GURL kTestUrl = GURL(kTestOriginName);
  const url::Origin kTestOrigin = url::Origin::Create(kTestUrl);
};

TEST_F(MAYBE_InterestGroupTestUtilsTest, CompareSimple) {
  blink::InterestGroup actual =
      blink::TestInterestGroupBuilder(/*owner=*/kTestOrigin, kTestGroupName)
          .Build();
  blink::InterestGroup expected = actual;
  IgExpectEqualsForTesting(actual, expected);
  EXPECT_NONFATAL_FAILURE(IgExpectNotEqualsForTesting(actual, expected),
                          R"(Value of: found_unequal
  Actual: false
Expected: true)");

  expected.name = "cars";
  IgExpectNotEqualsForTesting(actual, expected);
  EXPECT_NONFATAL_FAILURE(IgExpectEqualsForTesting(actual, expected),
                          R"(Expected equality of these values:
  actual.name
    Which is: "shoes"
  expected.name
    Which is: "cars")");
}

TEST_F(MAYBE_InterestGroupTestUtilsTest, CompareOptional) {
  blink::InterestGroup actual =
      blink::TestInterestGroupBuilder(/*owner=*/kTestOrigin, kTestGroupName)
          .Build();
  blink::InterestGroup expected = actual;

  expected.bidding_url = kTestUrl;
  IgExpectNotEqualsForTesting(actual, expected);
  EXPECT_NONFATAL_FAILURE(IgExpectEqualsForTesting(actual, expected),
                          R"(Expected equality of these values:
  actual.bidding_url
    Which is: (nullopt)
  expected.bidding_url
    Which is: (https://origin.test/))");

  expected = actual;
  actual.bidding_url = kTestUrl;
  IgExpectNotEqualsForTesting(actual, expected);
  EXPECT_NONFATAL_FAILURE(IgExpectEqualsForTesting(actual, expected),
                          R"(Expected equality of these values:
  actual.bidding_url
    Which is: (https://origin.test/)
  expected.bidding_url
    Which is: (nullopt))");

  expected.bidding_url = kTestUrl;
  IgExpectEqualsForTesting(actual, expected);
  EXPECT_NONFATAL_FAILURE(IgExpectNotEqualsForTesting(actual, expected),
                          R"(Value of: found_unequal
  Actual: false
Expected: true)");
}

TEST_F(MAYBE_InterestGroupTestUtilsTest, CompareOptionalVector) {
  blink::InterestGroup actual =
      blink::TestInterestGroupBuilder(/*owner=*/kTestOrigin, kTestGroupName)
          .Build();
  blink::InterestGroup expected = actual;

  expected.trusted_bidding_signals_keys = {"foo"};
  IgExpectNotEqualsForTesting(actual, expected);
  EXPECT_NONFATAL_FAILURE(IgExpectEqualsForTesting(actual, expected),
                          R"(Expected equality of these values:
  actual.has_value()
    Which is: false
  expected.has_value()
    Which is: true)");

  expected = actual;
  actual.trusted_bidding_signals_keys = {"foo"};
  IgExpectNotEqualsForTesting(actual, expected);
  EXPECT_NONFATAL_FAILURE(IgExpectEqualsForTesting(actual, expected),
                          R"(Expected equality of these values:
  actual.has_value()
    Which is: true
  expected.has_value()
    Which is: false)");

  expected.trusted_bidding_signals_keys = {"foo"};
  IgExpectEqualsForTesting(actual, expected);
  EXPECT_NONFATAL_FAILURE(IgExpectNotEqualsForTesting(actual, expected),
                          R"(Value of: found_unequal
  Actual: false
Expected: true)");
}

TEST_F(MAYBE_InterestGroupTestUtilsTest, CompareOptionalMap) {
  blink::InterestGroup actual =
      blink::TestInterestGroupBuilder(/*owner=*/kTestOrigin, kTestGroupName)
          .Build();
  blink::InterestGroup expected = actual;

  expected.priority_vector = {{"foo", 0.0}};
  IgExpectNotEqualsForTesting(actual, expected);
  EXPECT_NONFATAL_FAILURE(IgExpectEqualsForTesting(actual, expected),
                          R"(Expected equality of these values:
  actual.has_value()
    Which is: false
  expected.has_value()
    Which is: true)");

  expected = actual;
  actual.priority_vector = {{"foo", 0.0}};
  IgExpectNotEqualsForTesting(actual, expected);
  EXPECT_NONFATAL_FAILURE(IgExpectEqualsForTesting(actual, expected),
                          R"(Expected equality of these values:
  actual.has_value()
    Which is: true
  expected.has_value()
    Which is: false)");

  expected.priority_vector = {{"foo", 0.0}};
  IgExpectEqualsForTesting(actual, expected);
  EXPECT_NONFATAL_FAILURE(IgExpectNotEqualsForTesting(actual, expected),
                          R"(Value of: found_unequal
  Actual: false
Expected: true)");
}

TEST_F(MAYBE_InterestGroupTestUtilsTest, CompareSizeMismatchVector) {
  blink::InterestGroup actual =
      blink::TestInterestGroupBuilder(/*owner=*/kTestOrigin, kTestGroupName)
          .Build();
  blink::InterestGroup expected = actual;

  actual.trusted_bidding_signals_keys = {"foo"};
  expected.trusted_bidding_signals_keys = {"foo", "bar"};
  IgExpectNotEqualsForTesting(actual, expected);
  EXPECT_NONFATAL_FAILURE(IgExpectEqualsForTesting(actual, expected),
                          R"(Expected equality of these values:
  actual.size()
    Which is: 1
  expected.size()
    Which is: 2)");

  actual.trusted_bidding_signals_keys = {"foo", "bar"};
  expected.trusted_bidding_signals_keys = {"foo"};
  IgExpectNotEqualsForTesting(actual, expected);
  EXPECT_NONFATAL_FAILURE(IgExpectEqualsForTesting(actual, expected),
                          R"(Expected equality of these values:
  actual.size()
    Which is: 2
  expected.size()
    Which is: 1)");

  actual.trusted_bidding_signals_keys = {"foo", "bar"};
  expected.trusted_bidding_signals_keys = {"foo", "bar"};
  IgExpectEqualsForTesting(actual, expected);
  EXPECT_NONFATAL_FAILURE(IgExpectNotEqualsForTesting(actual, expected),
                          R"(Value of: found_unequal
  Actual: false
Expected: true)");
}

TEST_F(MAYBE_InterestGroupTestUtilsTest, CompareSizeMismatchMap) {
  blink::InterestGroup actual =
      blink::TestInterestGroupBuilder(/*owner=*/kTestOrigin, kTestGroupName)
          .Build();
  blink::InterestGroup expected = actual;

  actual.priority_vector = {{"foo", 0.0}};
  expected.priority_vector = {{"foo", 0.0}, {"bar", 1.0}};
  IgExpectNotEqualsForTesting(actual, expected);
  EXPECT_NONFATAL_FAILURE(IgExpectEqualsForTesting(actual, expected),
                          R"(Expected equality of these values:
  actual.size()
    Which is: 1
  expected.size()
    Which is: 2)");

  actual.priority_vector = {{"foo", 0.0}, {"bar", 1.0}};
  expected.priority_vector = {{"foo", 0.0}};
  IgExpectNotEqualsForTesting(actual, expected);
  EXPECT_NONFATAL_FAILURE(IgExpectEqualsForTesting(actual, expected),
                          R"(Expected equality of these values:
  actual.size()
    Which is: 2
  expected.size()
    Which is: 1)");

  actual.priority_vector = {{"foo", 0.0}, {"bar", 1.0}};
  expected.priority_vector = {{"foo", 0.0}, {"bar", 1.0}};
  IgExpectEqualsForTesting(actual, expected);
  EXPECT_NONFATAL_FAILURE(IgExpectNotEqualsForTesting(actual, expected),
                          R"(Value of: found_unequal
  Actual: false
Expected: true)");
}

TEST_F(MAYBE_InterestGroupTestUtilsTest, CompareElementVector) {
  blink::InterestGroup actual =
      blink::TestInterestGroupBuilder(/*owner=*/kTestOrigin, kTestGroupName)
          .Build();
  blink::InterestGroup expected = actual;

  actual.trusted_bidding_signals_keys = {"foo"};
  expected.trusted_bidding_signals_keys = {"bar"};
  IgExpectNotEqualsForTesting(actual, expected);
  EXPECT_NONFATAL_FAILURE(IgExpectEqualsForTesting(actual, expected),
                          R"(Expected equality of these values:
  actual
    Which is: "foo"
  expected
    Which is: "bar")");

  actual.trusted_bidding_signals_keys = {"foo", "bar"};
  expected.trusted_bidding_signals_keys = {"foo", "baz"};
  IgExpectNotEqualsForTesting(actual, expected);
  EXPECT_NONFATAL_FAILURE(IgExpectEqualsForTesting(actual, expected),
                          R"(Expected equality of these values:
  actual
    Which is: "bar"
  expected
    Which is: "baz")");
}

TEST_F(MAYBE_InterestGroupTestUtilsTest, CompareElementMap) {
  blink::InterestGroup actual =
      blink::TestInterestGroupBuilder(/*owner=*/kTestOrigin, kTestGroupName)
          .Build();
  blink::InterestGroup expected = actual;

  actual.priority_vector = {{"foo", 0.0}};
  expected.priority_vector = {{"bar", 0.0}};
  IgExpectNotEqualsForTesting(actual, expected);
  EXPECT_NONFATAL_FAILURE(IgExpectEqualsForTesting(actual, expected),
                          R"(Expected equality of these values:
  a_it->first
    Which is: "foo"
  b_it->first
    Which is: "bar")");

  actual.priority_vector = {{"foo", 0.0}};
  expected.priority_vector = {{"foo", 1.0}};
  IgExpectNotEqualsForTesting(actual, expected);
  EXPECT_NONFATAL_FAILURE(IgExpectEqualsForTesting(actual, expected),
                          R"(Expected equality of these values:
  actual
    Which is: 0
  expected
    Which is: 1)");

  actual.priority_vector = {{"foo", 0.0}, {"bar", 1.0}};
  expected.priority_vector = {{"foo", 1.0}, {"bar", 0.0}};
  IgExpectNotEqualsForTesting(actual, expected);
  // NOTE: IgExpectEqualsForTesting() would yield 2 failures , but
  // EXPECT_NONFATAL_FAILURE() itself will fail if there's more than one
  // failure.
}

TEST_F(MAYBE_InterestGroupTestUtilsTest, CompareDeep) {
  blink::InterestGroup actual =
      blink::TestInterestGroupBuilder(/*owner=*/kTestOrigin, kTestGroupName)
          .Build();
  blink::InterestGroup expected = actual;

  actual.size_groups = {{"foo", {"bar", "baz"}}};
  expected.size_groups = {{"foo", {"bar", "bazz"}}};
  IgExpectNotEqualsForTesting(actual, expected);
  EXPECT_NONFATAL_FAILURE(IgExpectEqualsForTesting(actual, expected),
                          R"(Expected equality of these values:
  actual
    Which is: "baz"
  expected
    Which is: "bazz")");

  expected.size_groups = {{"foo", {"bar", "baz"}}};
  IgExpectEqualsForTesting(actual, expected);
  EXPECT_NONFATAL_FAILURE(IgExpectNotEqualsForTesting(actual, expected),
                          R"(Value of: found_unequal
  Actual: false
Expected: true)");
}

}  // namespace

"""

```
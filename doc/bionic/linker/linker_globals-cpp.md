Response:
Let's break down the thought process for generating the comprehensive answer about `linker_globals.cpp`.

**1. Understanding the Request:**

The request asks for a detailed analysis of `linker_globals.cpp`, specifically focusing on its functionalities, relationship with Android, implementation details, dynamic linking aspects, potential errors, and how it's accessed by Android Framework/NDK, along with a Frida hook example. The key is to be thorough and provide concrete examples where possible.

**2. Initial Code Examination and Keyword Identification:**

The first step is to carefully read the provided code snippet. Keywords and important elements immediately stand out:

* **Includes:** `linker.h`, `linker_globals.h`, `linker_namespaces.h`, `android-base/stringprintf.h`. This tells us the file is central to the linker's operation and interacts with namespaces and string formatting.
* **Global Variables:** `g_argc`, `g_argv`, `g_envp`, `g_default_namespace`, `g_soinfo_handles_map`, `g_platform_properties`. These are the core state managed by this file.
* **Functions:** `linker_get_error_buffer`, `linker_get_error_buffer_size`, `DL_WARN_documented_change`. These are the immediate interfaces provided by this file.
* **Constants:** The string literals in `DL_WARN_documented_change` (`"Warning: "`, the format string, `" and will not work..."`, `kBionicChangesUrl`).

**3. Deconstructing Functionalities and their Android Relevance:**

Now, systematically analyze each element:

* **`g_argc`, `g_argv`, `g_envp`:** These are fundamental to any C/C++ program. Their connection to Android is obvious – when an Android app starts, the Zygote process forks, and the linker is involved in loading the application. These variables store the command-line arguments and environment variables passed to the app. *Example:*  Think about how `adb shell am start -n com.example/.MainActivity` translates into `argv`.
* **`g_default_namespace`:**  Linker namespaces are a key Android security feature. This variable likely represents the default namespace where the application's libraries are loaded. *Example:* Explain the purpose of namespaces – isolating libraries.
* **`g_soinfo_handles_map`:** This is crucial for dynamic linking. It maps memory addresses to `soinfo` structures, which contain information about loaded shared libraries. *Example:*  Imagine loading `libfoo.so`. This map helps the linker find where it's located in memory.
* **`g_platform_properties`:**  This stores platform-specific properties that influence linking behavior. *Example:*  Architecture (ARM, x86), API level, etc. These affect library compatibility.
* **`linker_get_error_buffer` and `linker_get_error_buffer_size`:** These provide a way to retrieve error messages generated by the linker. This is essential for debugging dynamic linking issues. *Example:* If a library cannot be found, the linker will write an error message here.
* **`DL_WARN_documented_change`:** This function is specific to Android. It warns developers about deprecated behavior and its connection to the target API level. *Example:*  Illustrate how this helps with backward compatibility and encourages developers to adopt newer APIs.

**4. Explaining libc Function Implementations:**

The request mentions libc functions. While this specific file *doesn't implement* standard libc functions directly, it interacts *heavily* with the dynamic linker, which is responsible for resolving symbols and loading libraries – a crucial part of *using* libc functions. Therefore, the explanation should focus on how the linker enables the use of libc functions by resolving their addresses in `libc.so`.

**5. Delving into Dynamic Linker Functionality:**

This is a core aspect. Explain the following:

* **SO Layout:**  Provide a simple example of how a shared library (`.so`) is laid out in memory (headers, code, data, symbol tables, etc.).
* **Linking Process:** Detail the steps involved in dynamic linking: loading, symbol resolution, relocation. Explain how `g_soinfo_handles_map` plays a role.
* **Relocation:** Briefly explain how the linker updates addresses in the loaded library.

**6. Anticipating User/Programming Errors:**

Think about common mistakes developers make related to dynamic linking:

* **Missing libraries:** `dlopen("nonexistent.so")`.
* **ABI incompatibility:** Trying to load an ARM library on an x86 device.
* **Symbol conflicts:** Two libraries defining the same symbol.
* **Incorrect library paths:**  The linker not being able to find the library.

**7. Tracing the Path from Android Framework/NDK:**

This requires understanding how applications are launched and how native code is invoked:

* **Framework:** Explain the role of the ActivityManagerService, Zygote, and how `fork()` and `exec()` lead to the dynamic linker being invoked.
* **NDK:** Describe how NDK libraries are built and how `System.loadLibrary()` triggers the dynamic linker.

**8. Crafting the Frida Hook Example:**

Choose a relevant function to hook. `DL_WARN_documented_change` is a good choice because it provides informative warnings. The hook should demonstrate how to intercept the function, inspect arguments, and potentially modify behavior (though in this case, just logging is sufficient for demonstration).

**9. Structuring the Answer:**

Organize the information logically with clear headings and subheadings. Use bullet points and code blocks to enhance readability. Start with a general overview of the file's purpose and then delve into specifics.

**10. Review and Refine:**

After drafting the answer, review it carefully for accuracy, clarity, and completeness. Ensure that the examples are relevant and easy to understand. Double-check the technical details, especially regarding the dynamic linking process. Make sure the Chinese translation is accurate and natural-sounding.

**Self-Correction/Refinement during the process:**

* **Initial thought:** Focus heavily on the C++ code details of the `unordered_map`.
* **Correction:** While implementation details are good, the *functional purpose* and its relation to Android's dynamic linking are more important for the request. Shift focus to the "why" and "how" it's used in the linker.
* **Initial thought:**  Provide a complex diagram of SO layout.
* **Correction:**  A simple, illustrative example is better for understanding. Avoid unnecessary complexity.
* **Initial thought:**  Explain all the nuances of symbol resolution algorithms.
* **Correction:** A high-level overview of symbol lookup and relocation is sufficient for this request. Avoid going into too much low-level detail unless specifically asked.

By following this structured thought process, breaking down the problem into smaller, manageable parts, and iteratively refining the answer, it's possible to generate a comprehensive and accurate response like the example provided in the prompt.
好的，让我们详细分析 `bionic/linker/linker_globals.cpp` 这个文件。

**文件功能概览**

`linker_globals.cpp` 文件在 Android Bionic 的动态链接器中扮演着核心的角色，它主要负责存储和管理全局的链接器状态和数据。这些全局变量和函数为链接器的各个部分提供了共享的访问点，确保了链接过程的协同和一致性。

**具体功能列举与 Android 功能关系**

1. **存储全局参数:**
   - `g_argc`, `g_argv`, `g_envp`:  这些变量分别存储了程序的命令行参数数量、参数值数组以及环境变量数组。
   - **Android 功能关系:** 当一个 Android 应用程序启动时，Zygote 进程会 fork 出新的进程来运行应用。在进程启动的早期阶段，动态链接器会被调用来加载应用程序依赖的共享库。`g_argc`, `g_argv`, `g_envp` 正是传递给新启动的应用程序进程的命令行参数和环境变量。
   - **举例:** 当你通过 `adb shell am start -n com.example/.MainActivity` 启动一个应用时，`com.example` 和 `.MainActivity` 等信息会被解析并存储到 `g_argv` 中，供链接器后续使用。环境变量如 `PATH`, `LD_LIBRARY_PATH` 等也会被存储在 `g_envp` 中，影响链接器查找共享库的路径。

2. **管理默认命名空间:**
   - `android_namespace_t g_default_namespace`:  这个变量存储了默认的链接器命名空间对象。
   - **Android 功能关系:** Android 使用链接器命名空间来实现库的隔离，提高安全性和防止库冲突。每个应用程序（以及某些系统进程）都运行在一个或多个命名空间中。默认命名空间是应用进程最初所在的命名空间。
   - **举例:** 当应用程序加载 `libc.so` 或其他系统库时，这些库通常会加载到默认命名空间中。不同的应用可以拥有不同的命名空间，即使它们依赖相同名称但不同版本的库，也不会发生冲突。

3. **维护 soinfo 句柄映射:**
   - `std::unordered_map<uintptr_t, soinfo*> g_soinfo_handles_map`:  这个哈希表将共享库的加载基址映射到对应的 `soinfo` 结构体指针。`soinfo` 结构体包含了关于已加载共享库的元数据，例如库名、加载地址、符号表等。
   - **Android 功能关系:** 这是动态链接的核心数据结构。当链接器加载一个新的共享库时，会创建一个 `soinfo` 结构体来记录库的信息，并将库的加载地址和 `soinfo` 指针添加到这个映射表中。这样，链接器可以通过库的加载地址快速查找其元数据。
   - **举例:** 当应用调用 `dlopen("libfoo.so")` 加载一个动态库时，链接器会先找到或加载 `libfoo.so`，然后创建一个 `soinfo` 结构体，记录 `libfoo.so` 的加载地址，并将其添加到 `g_soinfo_handles_map` 中。之后，当需要解析 `libfoo.so` 中的符号时，链接器可以通过其加载地址快速找到对应的 `soinfo`。

4. **存储平台属性:**
   - `platform_properties g_platform_properties`:  这个变量存储了与平台相关的属性，这些属性可能会影响链接器的行为。
   - **Android 功能关系:**  不同的 Android 版本、架构（如 ARM, x86）可能具有不同的链接需求和约定。`platform_properties` 存储了这些差异，以便链接器能够根据当前平台正确地执行链接操作。
   - **举例:**  `g_platform_properties` 可能包含当前 Android 系统的 API Level、目标架构等信息。链接器可以根据 API Level 来决定是否启用某些新的链接特性或发出警告。

5. **提供错误缓冲区:**
   - `static char __linker_dl_err_buf[768]`:  这是一个静态字符数组，用作链接器错误信息的缓冲区。
   - `linker_get_error_buffer()`:  返回错误缓冲区的指针。
   - `linker_get_error_buffer_size()`:  返回错误缓冲区的大小。
   - **Android 功能关系:** 当动态链接过程中发生错误时（例如找不到库、符号未定义等），链接器会将错误信息格式化后写入这个缓冲区。应用程序可以使用 `dlerror()` 函数来获取这个错误信息。
   - **举例:** 如果你尝试 `dlopen("nonexistent.so")`，由于库不存在，链接器会将类似 "cannot find library nonexistent.so" 的错误信息写入 `__linker_dl_err_buf`，然后 `dlerror()` 函数会返回这个错误信息的字符串。

6. **处理 API 级别相关的警告:**
   - `DL_WARN_documented_change(int api_level, const char* doc_fragment, const char* fmt, ...)`:  这个函数用于在某些 API 变更时发出警告。当应用程序的目标 API 级别低于某个引入变更的 API 级别时，会发出警告，提示开发者该行为将在更高的 API 级别中失效。
   - **Android 功能关系:**  Android 平台会不断演进，某些旧的行为可能会被废弃或修改。为了帮助开发者平滑过渡，链接器会在检测到可能不兼容的情况时发出警告，并提供相关文档的链接。
   - **举例:** 假设在 API Level 30 中，某个链接器的行为发生了改变。如果你的应用程序的目标 API Level 低于 30，并且链接器检测到你的代码依赖于旧的行为，`DL_WARN_documented_change` 函数会被调用，输出一个警告信息，告诉你这个行为将在 API Level 30 及以上失效，并提供文档链接以便你了解新的行为。

**libc 函数的实现**

`linker_globals.cpp` 本身并不直接实现 libc 函数。它的作用是作为动态链接器的全局状态管理中心，为链接器加载和管理共享库提供支持。而 libc 函数的实现主要位于 `libc.so` 这个共享库中。

当程序调用一个 libc 函数时，例如 `printf`，大致过程如下：

1. **编译阶段:** 编译器会将 `printf` 函数的调用编译成一个对外部符号 `printf` 的引用。
2. **链接阶段:** 静态链接器（在应用构建时）并不解析 `printf` 的具体地址，而是将其标记为一个需要动态链接的符号。
3. **运行时:** 当程序启动后，动态链接器负责加载程序依赖的共享库，包括 `libc.so`。
4. **符号解析:** 动态链接器会查找 `libc.so` 的符号表，找到 `printf` 函数的地址。
5. **重定位:** 动态链接器会修改程序代码中对 `printf` 的引用，将其指向 `libc.so` 中 `printf` 函数的实际地址。

因此，`linker_globals.cpp` 通过管理已加载的共享库信息（例如在 `g_soinfo_handles_map` 中存储 `libc.so` 的信息）来辅助实现 libc 函数的动态链接和调用。

**dynamic linker 的功能与 so 布局样本和链接处理过程**

**Dynamic Linker 功能：**

动态链接器（在 Android 中主要是 `/system/bin/linker64` 或 `/system/bin/linker`）负责在程序运行时加载和链接共享库。其主要功能包括：

1. **加载共享库:**  根据程序的依赖关系，加载所需的 `.so` 文件到内存中。
2. **符号解析:**  查找未定义的符号（例如 libc 函数、其他共享库中的函数），并在已加载的共享库中找到它们的地址。
3. **重定位:**  修改程序和共享库中的代码和数据，使其能够正确地访问加载到内存中的符号地址。
4. **执行初始化代码:**  调用共享库中的初始化函数（通常是 `__attribute__((constructor))` 标记的函数）。

**SO 布局样本:**

一个典型的共享库 `.so` 文件的内存布局大致如下：

```
+----------------------+
| ELF Header           |  // 包含文件类型、目标架构、入口点等信息
+----------------------+
| Program Headers      |  // 描述了如何将文件映射到内存的段信息
+----------------------+
| .text (Code Section) |  // 包含可执行代码
+----------------------+
| .rodata (Read-Only Data)| // 包含只读数据，例如字符串常量
+----------------------+
| .data (Initialized Data)| // 包含已初始化的全局变量和静态变量
+----------------------+
| .bss (Uninitialized Data)| // 包含未初始化的全局变量和静态变量
+----------------------+
| .dynamic            |  // 包含动态链接信息，例如依赖的库、符号表位置等
+----------------------+
| .symtab (Symbol Table)| // 包含库中定义的符号信息，例如函数名、变量名和地址
+----------------------+
| .strtab (String Table)| // 存储符号表中使用的字符串
+----------------------+
| .rel.dyn / .rel.plt  |  // 包含重定位信息，指示哪些位置需要修改
+----------------------+
| ... 其他段 ...        |
+----------------------+
```

**链接的处理过程:**

1. **加载:** 当程序需要加载一个共享库时（例如通过 `dlopen` 或程序启动时的依赖关系），链接器会读取 `.so` 文件的 ELF Header 和 Program Headers，确定如何将文件的各个段映射到内存中。
2. **查找 `soinfo`:** 链接器会在 `g_soinfo_handles_map` 中查找是否已经加载过该共享库。如果已加载，则直接使用已有的 `soinfo`。否则，会创建一个新的 `soinfo` 结构体来存储该库的信息。
3. **符号查找:** 当需要解析一个符号时，链接器会按照一定的顺序搜索已加载的共享库的符号表。这个搜索顺序通常由链接器的命名空间和依赖关系决定。
4. **重定位:** 找到符号的地址后，链接器会根据 `.rel.dyn` 和 `.rel.plt` 段中的重定位信息，修改程序或共享库中引用该符号的位置，将其指向实际的内存地址。
5. **依赖加载:** 如果被加载的共享库还依赖于其他共享库，链接器会递归地加载这些依赖库。

**假设输入与输出（逻辑推理）**

假设我们有一个简单的应用程序 `app`，它依赖于一个名为 `libmylib.so` 的共享库。`libmylib.so` 中定义了一个函数 `my_function`。

**假设输入:**

1. 应用程序 `app` 启动。
2. `app` 的代码中调用了 `libmylib.so` 中的 `my_function`。

**链接处理过程:**

1. 链接器首先加载 `app` 本身。
2. 链接器解析 `app` 的依赖关系，发现它依赖于 `libmylib.so`。
3. 链接器查找 `libmylib.so`，将其加载到内存中，并创建一个 `soinfo` 结构体记录其信息，并将其加载地址和 `soinfo` 指针添加到 `g_soinfo_handles_map`。
4. 当执行到调用 `my_function` 的代码时，链接器会查找 `my_function` 符号。
5. 链接器在 `libmylib.so` 的符号表中找到 `my_function` 的地址。
6. 链接器将 `app` 中调用 `my_function` 的指令中的占位符地址替换为 `my_function` 的实际内存地址。

**假设输出:**

当 `app` 执行到调用 `my_function` 的地方时，程序能够正确地跳转到 `libmylib.so` 中 `my_function` 的代码执行。

**用户或编程常见的使用错误**

1. **找不到共享库:**
   - **错误:** 尝试 `dlopen("nonexistent.so")` 或者应用程序依赖的库没有放在正确的路径下（例如 `LD_LIBRARY_PATH` 未设置或设置错误）。
   - **表现:** `dlopen` 返回 `nullptr`，`dlerror()` 返回 "cannot find library ..."。
   - **示例:**
     ```c++
     void* handle = dlopen("mylib.so", RTLD_LAZY);
     if (!handle) {
       fprintf(stderr, "Error: %s\n", dlerror());
     }
     ```

2. **ABI 不兼容:**
   - **错误:** 尝试加载与当前设备架构不兼容的共享库（例如在 ARM 设备上加载 x86 的 `.so`）。
   - **表现:**  `dlopen` 返回 `nullptr`，`dlerror()` 返回类似的错误信息，指示架构不匹配。

3. **符号未定义:**
   - **错误:** 应用程序或共享库依赖于一个未在任何已加载的共享库中定义的符号。
   - **表现:** 链接器在加载或链接时会报错，提示 "undefined symbol ..."。
   - **示例:**  `liba.so` 调用了 `libb.so` 中的函数 `foo`，但 `libb.so` 没有正确链接或者 `foo` 函数不存在。

4. **符号冲突:**
   - **错误:** 两个或多个已加载的共享库定义了相同的全局符号，导致链接器无法确定使用哪个符号。
   - **表现:** 链接器可能会选择其中一个符号，但行为可能不符合预期，或者链接器会报错。

**Android Framework 或 NDK 如何到达这里**

**Android Framework 到达 `linker_globals.cpp` 的步骤:**

1. **应用启动:** 当用户点击应用图标或通过其他方式启动一个 Android 应用程序时，Android 系统会通过 `ActivityManagerService` 来启动应用进程。
2. **Zygote 进程:** `ActivityManagerService` 会请求 Zygote 进程 fork 出一个新的进程来运行该应用。Zygote 是所有 Android 应用进程的父进程，它预先加载了一些常用的库，包括动态链接器。
3. **`fork()` 和 `exec()`:** Zygote 执行 `fork()` 创建一个新的子进程，然后在新进程中执行 `exec()` 系统调用，加载应用程序的可执行文件（通常是 `app_process` 或 `app_process64`）。
4. **动态链接器启动:**  操作系统的加载器会首先将动态链接器加载到新进程的地址空间。
5. **链接器初始化:** 动态链接器开始初始化自身，包括读取程序的 ELF 头，解析依赖关系，并加载所需的共享库。在这个过程中，`linker_globals.cpp` 中定义的全局变量会被初始化，例如读取命令行参数和环境变量并存储到 `g_argc`, `g_argv`, `g_envp` 中。加载的共享库信息会被记录到 `g_soinfo_handles_map` 中。

**NDK 到达 `linker_globals.cpp` 的步骤:**

1. **NDK 代码编译:** 使用 NDK 编译 C/C++ 代码会生成共享库 (`.so` 文件)。
2. **应用加载 NDK 库:** 在 Android 应用程序的 Java 代码中，可以使用 `System.loadLibrary("mylib")` 来加载 NDK 生成的共享库。
3. **`System.loadLibrary` 调用:**  `System.loadLibrary` 方法最终会调用到 Android Runtime (ART) 或 Dalvik 虚拟机中的 native 方法。
4. **`dlopen` 调用:**  ART 或 Dalvik 虚拟机内部会调用 `dlopen` 函数来加载指定的共享库。
5. **动态链接器执行:** `dlopen` 系统调用会触发动态链接器开始工作，加载 NDK 库，并更新 `linker_globals.cpp` 中维护的全局状态，例如在 `g_soinfo_handles_map` 中添加新加载的库的信息。

**Frida Hook 示例调试步骤**

以下是一个使用 Frida Hook `DL_WARN_documented_change` 函数的示例：

```python
import frida
import sys

package_name = "your.package.name"  # 替换为你的应用包名

session = frida.attach(package_name)

script_code = """
Interceptor.attach(Module.findExportByName(null, "DL_WARN_documented_change"), {
  onEnter: function(args) {
    console.log("DL_WARN_documented_change called!");
    console.log("  API Level:", args[0].toInt32());
    console.log("  Document Fragment:", Memory.readUtf8String(args[1]));
    console.log("  Format String:", Memory.readUtf8String(args[2]));
    // 你可以读取后续的可变参数，但这需要一些额外的处理
  }
});
"""

script = session.create_script(script_code)
script.load()
sys.stdin.read()
```

**调试步骤:**

1. **安装 Frida 和 Python 环境:** 确保你的开发机上安装了 Frida 和 Python。
2. **连接设备或模拟器:** 确保你的 Android 设备或模拟器已连接，并且启用了 USB 调试。
3. **启动目标应用:** 运行你想要调试的 Android 应用程序。
4. **运行 Frida 脚本:** 将上面的 Python 代码保存到一个文件（例如 `hook_linker.py`），并将 `your.package.name` 替换为你应用的实际包名。然后在终端中运行 `python hook_linker.py`。
5. **触发警告:**  在你的应用程序中执行某些可能触发 `DL_WARN_documented_change` 的操作。例如，如果警告与某个特定的 API 调用有关，尝试调用该 API。
6. **查看 Frida 输出:** 当 `DL_WARN_documented_change` 函数被调用时，Frida 会拦截该调用，并打印出相关的参数信息，包括 API Level、文档片段和格式化字符串。

这个示例展示了如何使用 Frida Hook 动态地观察和分析动态链接器的行为，特别是与 API 兼容性相关的警告信息。你可以根据需要修改 Hook 的目标函数和处理逻辑，以调试其他链接器相关的行为。

Prompt: 
```
这是目录为bionic/linker/linker_globals.cppandroid bionic的源代码文件，bionic is Android's C library, math library, and dynamic linker. 
请列举一下它的功能,
如果它与android的功能有关系，请做出对应的举例说明，
详细解释每一个libc函数的功能是如何实现的,
对于涉及dynamic linker的功能，请给对应的so布局样本，以及链接的处理过程，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明android framework or ndk是如何一步步的到达这里，给出frida hook示例调试这些步骤。
用中文回复。

"""
/*
 * Copyright (C) 2016 The Android Open Source Project
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "linker.h"
#include "linker_globals.h"
#include "linker_namespaces.h"

#include "android-base/stringprintf.h"

int g_argc = 0;
char** g_argv = nullptr;
char** g_envp = nullptr;

android_namespace_t g_default_namespace;

std::unordered_map<uintptr_t, soinfo*> g_soinfo_handles_map;

platform_properties g_platform_properties;

static char __linker_dl_err_buf[768];

char* linker_get_error_buffer() {
  return &__linker_dl_err_buf[0];
}

size_t linker_get_error_buffer_size() {
  return sizeof(__linker_dl_err_buf);
}

void DL_WARN_documented_change(int api_level, const char* doc_fragment, const char* fmt, ...) {
  std::string result{"Warning: "};

  va_list ap;
  va_start(ap, fmt);
  android::base::StringAppendV(&result, fmt, ap);
  va_end(ap);

  android::base::StringAppendF(&result,
                               " and will not work when the app moves to API level %d or later "
                               "(%s#%s) (allowing for now because this app's target API level is "
                               "still %d)",
                               api_level, kBionicChangesUrl, doc_fragment,
                               get_application_target_sdk_version());
  DL_WARN("%s", result.c_str());
}

"""

```
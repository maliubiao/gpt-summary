Response:
Let's break down the thought process for analyzing the `defaults.py` file.

**1. Understanding the Goal:**

The core request is to understand the *purpose* and *functionality* of this Python file within the Android Bionic context. The keywords are "defaults" and "generate the cleaned-up uapi headers."  This immediately suggests that the file is involved in preparing kernel headers for userspace consumption.

**2. Deconstructing the File Content (Section by Section):**

The file is structured with Python data structures (lists, dictionaries, sets). The best approach is to go through each one and interpret its meaning.

* **`kernel_dirs`:** This is a simple list of directory names. The comment explicitly states they belong to the kernel tree and are used for finding sources. This points to a process that involves locating and processing kernel header files.

* **`kCppUndefinedMacro`:** This string is clearly a placeholder. The comment clarifies its purpose: indicating a macro that should be undefined during optimization. This hints at a preprocessing or code generation step.

* **`kernel_known_macros`:** This is a dictionary mapping macro names to values. The values are either strings (like `"1"`, `__LP64__`) or `kCppUndefinedMacro`. This suggests a mechanism for defining or undefining macros during header processing. The comments within this dictionary are crucial for understanding *why* certain macros are being manipulated (e.g., `CONFIG_64BIT`, byte-swapping macros).

* **`kernel_structs_to_remove`:** Another dictionary. The keys are struct names, and the values are either filenames or `None`. This clearly indicates a process for removing specific kernel structs from the final headers. The non-empty values suggest that these structs might be replaced with includes from other header files.

* **`kernel_remove_config_macros`:** A boolean flag. The comment explains its function: removing `defined(CONFIG_FOO)` checks. This further reinforces the idea of header cleanup and simplification.

* **`kernel_default_arch_macros`:** A dictionary mapping architectures to dictionaries of macros. This points to architecture-specific adjustments to the macro definitions. The example of removing big-endian junk from ARM headers is a concrete illustration.

* **`kernel_token_replacements`:** A dictionary for replacing strings. The comments explain the rationale behind these replacements, often due to naming conflicts between kernel and userspace conventions (e.g., `__unused`, `class`, `sigaction`).

* **`kernel_known_generic_statics`:** A set of function names. The comment explicitly says these are "static inline functions that we want to keep." This suggests a filtering process where only certain static inline functions are preserved in the output headers. The note about contacting opensource-licensing@ is an interesting detail hinting at legal considerations.

**3. Identifying the High-Level Functionality:**

After analyzing the individual components, the overarching purpose becomes clear: this file defines *rules* and *mappings* for a tool that *cleans up* and *prepares* kernel header files for use by userspace applications in Android. It's about creating a stable and consistent API.

**4. Connecting to Android and Bionic:**

The file is explicitly located within the Bionic directory. Bionic is Android's C library, so these cleaned-up headers are directly used by Bionic's header files. This is how user applications using Bionic interact with the underlying kernel.

**5. Addressing Specific Requirements of the Prompt:**

* **Function Listing:**  Summarize the purpose of each data structure.
* **Android Relevance and Examples:** Explain how the macro and struct manipulations relate to Android's need for a consistent userspace API, even though the kernel might have internal variations. The examples in `kernel_known_macros` and `kernel_token_replacements` provide concrete illustrations.
* **`libc` Function Implementation:** The file *doesn't* implement `libc` functions directly. It *prepares the headers* that `libc` uses. It's crucial to make this distinction.
* **Dynamic Linker:**  The file doesn't directly deal with the dynamic linker. It's about header preparation.
* **Logic Inference/Assumptions:** The assumptions are implicit in the understanding of header file processing. For example, the assumption is that there is a tool that reads this file and uses the defined rules.
* **User/Programming Errors:**  The errors are related to the *need* for this file. Without it, developers might encounter inconsistencies or naming conflicts when using kernel headers directly.
* **Android Framework/NDK Path:** Describe how the NDK uses the headers generated by this process to build applications.
* **Frida Hook Example:** Since the file is configuration, hooking it directly doesn't make sense. Instead, focus on hooking the *tools* that use this configuration, which would likely involve inspecting file reads or function calls related to header processing.

**6. Structuring the Output:**

Organize the information logically, starting with a general overview and then delving into specifics for each section of the file. Use clear headings and bullet points for readability. Provide concrete examples wherever possible.

**Self-Correction/Refinement:**

Initially, one might be tempted to dive into the technical details of header file parsing and manipulation. However, the prompt emphasizes the *purpose* and *functionality* of *this specific file*. It's important to stay focused on the role of `defaults.py` as a configuration file, rather than trying to explain the entire header generation process. Also, explicitly stating what the file *doesn't* do (like implementing `libc` functions or directly dealing with the dynamic linker) is crucial for clarity.
这个Python文件 `defaults.py` 是 Android Bionic 项目中的一个配置文件，用于定义在生成清理后的用户空间应用程序接口 (UAPI) 头文件时所使用的一系列默认设置。 它的主要目的是为了让用户空间的代码能够安全且一致地访问内核提供的接口，同时避免直接暴露内核的内部细节和潜在的兼容性问题。

**它的主要功能可以概括为：**

1. **指定内核头文件目录：**  `kernel_dirs` 变量定义了内核源代码树中包含头文件的目录列表，用于在查找内核源文件时定位。

2. **定义需要优化的宏：** `kernel_known_macros` 字典列出了一系列已知的内核宏，这些宏需要在最终的头文件中被优化掉。这包括将某些宏替换为特定的值（例如 `CONFIG_64BIT` 被替换为 `__LP64__`），或者标记为未定义 (`kCppUndefinedMacro`)。

3. **移除特定的内核数据结构：** `kernel_structs_to_remove` 字典定义了需要从最终头文件中移除的内核数据结构。 字典的值可以是一个头文件名，表示移除该结构的同时需要包含指定的头文件；如果值为 `None`，则仅移除该结构。

4. **控制 `CONFIG_` 宏的移除：** `kernel_remove_config_macros` 布尔值决定是否从清理后的头文件中移除所有 `defined(CONFIG_FOO)` 形式的宏定义测试。

5. **定义架构特定的默认宏：** `kernel_default_arch_macros` 字典允许为不同的架构指定默认的宏定义。这主要用于处理某些架构特有的宏，例如在 32 位 ARM 架构中移除大端相关的宏定义。

6. **进行 Token 替换：** `kernel_token_replacements` 字典定义了一组字符串替换规则，用于修改输出头文件中的特定 Token。这通常是为了解决内核命名与用户空间命名冲突、使用户空间代码更容易理解，或者适应 NDK 的需求。

7. **保留特定的静态内联函数：** `kernel_known_generic_statics` 集合列出了一些希望保留在最终头文件中的内核静态内联函数。

**与 Android 功能的关系及举例说明：**

这个文件直接关系到 Android 系统提供的用户空间接口的稳定性和一致性。 Android 的应用程序和库依赖于这些 UAPI 头文件来与内核进行交互。

* **架构适配：** `kernel_default_arch_macros` 可以确保不同架构的 Android 设备使用正确的宏定义。例如，`CONFIG_64BIT` 被映射到 `__LP64__`，这使得用户空间代码可以根据这个宏来判断当前是 64 位系统。

* **消除命名冲突：** `kernel_token_replacements` 用于解决内核和用户空间可能存在的命名冲突。例如，内核可能使用 `class` 作为结构体成员名，但这在 C++ 中是关键字，因此会被替换为 `__linux_class`。  另一个例子是将内核的 `sigaction` 重命名为 `__kernel_sigaction`，以便用户空间可以使用 POSIX 标准的 `sigaction`。

* **提供必要的类型和结构体定义：** 通过移除多余的或者内部使用的内核数据结构，并可能替换为 `<bits/STRUCT.h>` 的引用，可以提供用户空间需要的精简且必要的类型定义，例如 `sockaddr_storage`，`epoll_event` 等。

* **优化头文件大小和编译时间：**  移除不需要的宏和结构体可以减小最终头文件的大小，并减少编译时间。

**详细解释每一个 `libc` 函数的功能是如何实现的：**

**这个 `defaults.py` 文件本身并不实现任何 `libc` 函数。** 它只是一个配置文件，用于指导如何生成用于编译 `libc` (Bionic) 和其他用户空间程序的头文件。 `libc` 函数的实现代码位于 Bionic 的其他源文件中，通常是用 C 或汇编语言编写的。

**对于涉及 dynamic linker 的功能，请给对应的 so 布局样本，以及链接的处理过程：**

**这个 `defaults.py` 文件也不直接涉及 dynamic linker 的功能。** 它的作用是为编译时提供正确的头文件。 Dynamic linker (如 `linker64` 或 `linker`) 的功能是在程序运行时处理共享库的加载和符号解析。

尽管如此，`defaults.py` 中处理头文件的方式会间接地影响 dynamic linker。 例如，通过重命名某些结构体或宏，可以避免用户空间代码和内核代码在符号上的冲突，这有助于 dynamic linker 正确地加载和链接共享库。

一个典型的 so 文件布局如下：

```
ELF Header
Program Headers (描述内存段的加载信息)
Section Headers (描述各个 section 的信息，如 .text, .data, .bss, .dynamic, .symtab, .strtab 等)

.text         可执行代码段
.rodata       只读数据段
.data         已初始化的可写数据段
.bss          未初始化的数据段
.dynamic      动态链接信息段，包含链接器需要的各种表项的地址和大小
.symtab       符号表，包含全局和局部符号的定义和引用
.strtab       字符串表，存储符号名称和其他字符串
.rel.dyn      动态重定位表，用于在加载时修正代码和数据中的地址
.rel.plt      PLT (Procedure Linkage Table) 重定位表，用于延迟绑定函数
...          其他 section
```

链接的处理过程（简化）：

1. **编译时链接：** 静态链接器 (`ld`) 根据依赖关系将不同的目标文件 `.o` 组合成一个可执行文件或共享库 `.so`。 对于共享库，它会生成 `.dynamic` 段，其中包含动态链接器需要的信息，例如依赖的其他共享库、符号表的位置等。

2. **运行时链接（Dynamic Linker 的工作）：**
   a. 当程序启动时，内核会加载程序的代码和数据段，并将控制权交给 dynamic linker。
   b. Dynamic linker 解析 ELF Header 和 Program Headers，了解程序的内存布局。
   c. Dynamic linker 读取 `.dynamic` 段，获取依赖的共享库列表。
   d. 对于每个依赖的共享库，dynamic linker 会在文件系统中查找并加载它到内存中。
   e. Dynamic linker 解析每个共享库的符号表 (`.symtab`) 和字符串表 (`.strtab`)。
   f. **符号解析 (Symbol Resolution):** Dynamic linker 查找程序和其依赖的共享库中未定义的符号，并在已加载的共享库中找到它们的定义。
   g. **重定位 (Relocation):** Dynamic linker 根据重定位表 (`.rel.dyn` 和 `.rel.plt`) 修改代码和数据段中的地址，使其指向正确的内存位置。 这包括全局变量的地址和函数的地址。
   h. **延迟绑定 (Lazy Binding，通过 PLT 实现):** 对于一些函数调用，dynamic linker 可能不会立即解析其地址，而是在第一次调用时才进行解析，这可以加快程序启动速度。

**如果做了逻辑推理，请给出假设输入与输出：**

`defaults.py` 本身主要是配置信息，没有直接的逻辑推理过程。 它的“输入”是内核的原始头文件，“输出”是指导头文件清理工具生成最终 UAPI 头文件的规则。

例如，假设内核的 `linux/time.h` 中定义了名为 `__kernel_old_timeval` 的结构体，并且在 `defaults.py` 中有如下配置：

```python
kernel_structs_to_remove = {
    "__kernel_old_timeval": "linux/time.h",
    # ...
}
kernel_token_replacements = {
    # ...
    "__kernel_old_timeval": "timeval",
    # ...
}
```

那么，头文件清理工具会执行以下操作：

* **输入：** 包含 `__kernel_old_timeval` 定义的 `linux/time.h`。
* **逻辑推理：** 根据 `kernel_structs_to_remove`，它知道需要移除 `__kernel_old_timeval` 的定义。根据字典的值 `"linux/time.h"`，它知道可能需要包含这个头文件（如果其他地方需要 `timeval` 的定义）。
* **逻辑推理：** 根据 `kernel_token_replacements`，它知道需要将所有出现的 `__kernel_old_timeval` 替换为 `timeval`。
* **输出：**  最终生成的 UAPI 头文件中，不再有 `__kernel_old_timeval` 的定义，而是使用 `timeval`，并且可能包含了 `linux/time.h`（如果需要）。

**如果涉及用户或者编程常见的使用错误，请举例说明：**

* **头文件包含错误：** 如果 `defaults.py` 的配置不正确，导致某些必要的结构体或宏被错误地移除或重命名，用户空间的程序在编译时可能会遇到找不到符号或类型定义的错误。 例如，如果 `epoll_event` 被错误地移除了，而用户程序包含了 `<sys/epoll.h>` 并使用了 `epoll_event`，则会编译失败。

* **宏定义冲突：** 如果 `kernel_token_replacements` 的配置不当，可能会引入新的宏定义冲突。

* **架构不兼容：** 如果 `kernel_default_arch_macros` 的配置有误，可能会导致在特定架构上编译的程序出现问题，因为使用了错误的宏定义。

**说明 android framework or ndk 是如何一步步的到达这里，给出 frida hook 示例调试这些步骤。**

`defaults.py` 是 Bionic 构建过程中的一部分，用于生成 NDK (Native Development Kit) 提供的头文件。

1. **内核头文件获取：** Android 构建系统首先会获取目标设备的内核源代码或预编译的内核头文件。

2. **Bionic 头文件清理工具：** Bionic 项目包含一个或多个工具（通常是 Python 脚本），这些工具会读取 `defaults.py` 中的配置。

3. **头文件预处理和清理：** 这些工具会解析内核头文件，并根据 `defaults.py` 中定义的规则进行预处理和清理操作，例如移除指定的宏和结构体，替换 Token 等。

4. **生成 UAPI 头文件：** 清理后的头文件会被组织并复制到 NDK 的 sysroot 目录下，供 NDK 编译工具链使用。

5. **NDK 使用：** 当开发者使用 NDK 编译 C/C++ 代码时，NDK 的编译器会使用这些清理后的 UAPI 头文件。

6. **Android Framework 间接使用：** Android Framework 本身通常使用 Java 语言编写，但其底层的一些关键组件和库（例如 `libbinder.so`，`libnativewindow.so` 等）是使用 C++ 开发的，并且会使用到 Bionic 提供的头文件。

**Frida Hook 示例调试步骤：**

由于 `defaults.py` 是一个静态配置文件，直接 Hook 它本身没有意义。我们应该 Hook 使用这个配置文件的 Python 脚本或工具。假设用于清理头文件的脚本名为 `header_cleaner.py`。

1. **确定清理工具脚本的路径：**  你需要找到 Bionic 构建系统中实际负责读取和使用 `defaults.py` 的 Python 脚本的路径。这通常在 Bionic 的构建脚本或 Makefile 中定义。

2. **编写 Frida Hook 脚本：**

```python
import frida
import sys

def on_message(message, data):
    if message['type'] == 'send':
        print("[*] {}: {}".format(message['payload']['stage'], message['payload']['data']))
    else:
        print(message)

def main():
    if len(sys.argv) != 2:
        print("Usage: python {} <target_process>".format(sys.argv[0]))
        sys.exit(1)

    target_process = sys.argv[1]
    session = frida.attach(target_process)

    script_content = """
    // 假设 header_cleaner.py 脚本在执行过程中会读取 defaults.py
    // 我们 Hook Python 的 open 函数来观察它是否打开了 defaults.py

    var openPtr = Module.findExportByName(null, "open");
    if (openPtr) {
        Interceptor.attach(openPtr, {
            onEnter: function(args) {
                var path = Memory.readUtf8String(args[0]);
                if (path.endsWith("defaults.py")) {
                    send({ stage: "open", data: path });
                }
            },
            onLeave: function(retval) {
                // 可以检查返回值
            }
        });
    }

    // 可以 Hook 更具体的函数，例如 Python 文件读取的函数
    // 这取决于具体的实现细节

    // 示例：Hook Python 的 dict 访问操作，观察是否访问了 kernel_known_macros
    var pythonLib = Process.enumerateModules().find(m => m.name.startsWith("libpython")); // 替换为实际的 Python 库名
    if (pythonLib) {
        var getitemPtr = pythonLib.base.add(0x12345); // 需要找到 Python dict getitem 的地址
        if (getitemPtr) {
            Interceptor.attach(getitemPtr, {
                onEnter: function(args) {
                    // 检查是否访问了 kernel_known_macros 的 key
                    // 这需要对 Python 的内部实现有一定了解
                    send({ stage: "dict_access", data: "Possible access to kernel_known_macros" });
                },
                onLeave: function(retval) {
                }
            });
        }
    }

    """
    script = session.create_script(script_content)
    script.on('message', on_message)
    script.load()
    print("[!] Ctrl+C to detach from {}".format(target_process))
    sys.stdin.read()
    session.detach()

if __name__ == '__main__':
    main()
```

3. **运行 Hook 脚本：**  在 Bionic 构建过程中，找到执行头文件清理工具的命令，然后使用 Frida attach 到该 Python 进程。

   ```bash
   python your_frida_script.py python  # 假设清理工具是以 python 命令运行的
   ```

**注意：**

* 上述 Frida 脚本只是一个示例，具体的 Hook 逻辑需要根据头文件清理工具的实现细节进行调整。 你可能需要 Hook Python 的文件操作函数 (如 `open`, `read`)，或者更高级的 Python 对象操作函数来观察 `defaults.py` 的读取和使用过程。
* 找到 Python 内部函数的地址可能需要一些逆向工程知识。
* 你需要在 Android 模拟器或 root 过的设备上运行 Frida，并且确保目标 Python 进程正在运行。

通过 Frida Hook，你可以观察清理工具是如何读取 `defaults.py` 的内容，以及如何根据其中的配置来处理内核头文件的。 这可以帮助你理解 `defaults.py` 在 Bionic 构建过程中的实际作用。

Prompt: 
```
这是目录为bionic/libc/kernel/tools/defaults.pyandroid bionic的源代码文件，bionic is Android's C library, math library, and dynamic linker. 
请列举一下它的功能,
如果它与android的功能有关系，请做出对应的举例说明，
详细解释每一个libc函数的功能是如何实现的,
对于涉及dynamic linker的功能，请给对应的so布局样本，以及链接的处理过程，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明android framework or ndk是如何一步步的到达这里，给出frida hook示例调试这些步骤。
用中文回复。

"""
# All the defaults used to generate the cleaned-up uapi headers for bionic.

# the list of include directories that belong to the kernel
# tree. used when looking for sources...
kernel_dirs = [ "linux", "asm", "asm-generic", "mtd" ]

# a special value that is used to indicate that a given macro is known to be
# undefined during optimization
kCppUndefinedMacro = "<<<undefined>>>"

# this is the set of known macros we want to totally optimize out from the
# final headers
kernel_known_macros = {
    "__KERNEL__": kCppUndefinedMacro,
    "__KERNEL_STRICT_NAMES":"1",
    "__CHECKER__": kCppUndefinedMacro,
    "__CHECK_ENDIAN__": kCppUndefinedMacro,
    "CONFIG_64BIT": "__LP64__",
    "CONFIG_X86_32": "__i386__",
    "__EXPORTED_HEADERS__": "1",
    "__HAVE_BUILTIN_BSWAP16__": "1",
    "__HAVE_BUILTIN_BSWAP32__": "1",
    "__HAVE_BUILTIN_BSWAP64__": "1",
    # Use this to remove the struct __kernel_old_timeval definition.
    # Otherwise, there will be two struct timeval definitions when
    # __kernel_old_timeval is renamed to timeval.
    "__kernel_old_timeval": "1",
    # Drop the custom byte swap functions and just use the clang builtins.
    # https://github.com/android/ndk/issues/2107
    "__arch_swab16": kCppUndefinedMacro,
    "__arch_swab16p": kCppUndefinedMacro,
    "__arch_swab16s": kCppUndefinedMacro,
    "__arch_swab32": kCppUndefinedMacro,
    "__arch_swab32p": kCppUndefinedMacro,
    "__arch_swab32s": kCppUndefinedMacro,
    "__arch_swab64": kCppUndefinedMacro,
    "__arch_swab64p": kCppUndefinedMacro,
    "__arch_swab64s": kCppUndefinedMacro,
    "__arch_swahb32": kCppUndefinedMacro,
    "__arch_swahb32p": kCppUndefinedMacro,
    "__arch_swahb32s": kCppUndefinedMacro,
    "__arch_swahw32": kCppUndefinedMacro,
    "__arch_swahw32p": kCppUndefinedMacro,
    "__arch_swahw32s": kCppUndefinedMacro,
    }

# This is the set of known kernel data structures we want to remove from
# the final headers. If the map value is non-empty, that means that in
# addition to removing the structure, add a #include to the file.
kernel_structs_to_remove = {
    # Remove these structures since they are still the same as
    # timeval, itimerval. Also, add an include of linux/time.h
    # since __kernel_old_timeval is being changed to timeval, and
    # is only present in linux/time.h.
    "__kernel_old_timeval": "linux/time.h",
    "__kernel_old_itimerval": None,
    # Replace all of the below structures with #include <bits/STRUCT.h>
    "__kernel_sockaddr_storage": "bits/sockaddr_storage.h",
    "epoll_event": "bits/epoll_event.h",
    "flock": "bits/flock.h",
    "flock64": "bits/flock64.h",
    "in_addr": "bits/in_addr.h",
    "ip_mreq_source": "bits/ip_mreq_source.h",
    "ip_msfilter": "bits/ip_msfilter.h",
    "tcphdr": "bits/tcphdr.h",
    "timespec": "bits/timespec.h",
    }

# define to true if you want to remove all defined(CONFIG_FOO) tests
# from the clean headers. testing shows that this is not strictly necessary
# but just generates cleaner results
kernel_remove_config_macros = True

# Maps an architecture to a set of default macros that would be provided by
# the toolchain's preprocessor. Currently only used to remove confusing
# big-endian junk from the 32-bit arm headers.
kernel_default_arch_macros = {
    "arm": {"__ARMEB__": kCppUndefinedMacro, "__ARM_EABI__": "1"},
    }

# Replace tokens in the output according to this mapping.
kernel_token_replacements = {
    # The kernel usage of __unused for unused struct fields conflicts with the macro defined in <sys/cdefs.h>.
    "__unused": "__linux_unused",
    # The kernel usage of C++ keywords causes problems for C++ code so rename.
    "class": "__linux_class",
    "private": "__linux_private",
    "virtual": "__linux_virtual",
    # The non-64 stuff is legacy; msqid64_ds/ipc64_perm is what userspace wants.
    "msqid_ds": "__kernel_legacy_msqid_ds",
    "semid_ds": "__kernel_legacy_semid_ds",
    "shmid_ds": "__kernel_legacy_shmid_ds",
    "ipc_perm": "__kernel_legacy_ipc_perm",
    # The kernel semun isn't usable (https://github.com/android-ndk/ndk/issues/400).
    "semun": "__kernel_legacy_semun",
    # The kernel's _NSIG/NSIG are one less than the userspace value, so we need to move them aside.
    "_NSIG": "_KERNEL__NSIG",
    "NSIG": "_KERNEL_NSIG",
    # The kernel's SIGRTMIN/SIGRTMAX are absolute limits; userspace steals a few.
    "SIGRTMIN": "__SIGRTMIN",
    "SIGRTMAX": "__SIGRTMAX",
    # We want to support both BSD and Linux member names in struct udphdr.
    "udphdr": "__kernel_udphdr",
    # This causes problems when trying to export the headers for the ndk.
    "__attribute_const__": "__attribute__((__const__))",
    # The kernel started using struct __kernel_old_timeval in some places,
    # which is the exact same as struct timeval. Replace that name with
    # timeval so that kernel structures all use the same named structure.
    # If struct __kernel_old_timeval and struct timeval become different,
    # then a different solution needs to be implemented.
    "__kernel_old_timeval": "timeval",
    # Do the same for __kernel_old_itimerval as for timeval.
    "__kernel_old_itimerval": "itimerval",
    # Do the same for __kernel_sockaddr_storage.
    "__kernel_sockaddr_storage": "sockaddr_storage",
    # Replace __packed with __attribute__((__packed__)) to avoid depending
    # on sys/cdefs.h
    "__packed": "__attribute__((__packed__))",
    # Remove unused macros (http://b/262917450).
    "__force": "",
    "__user": "",
    # Rename the kernel's sigaction so we can expose our POSIX one publicly,
    # but translate to the kernel's one internally.
    "sigaction": "__kernel_sigaction",
    }


# Static inline functions that we want to keep.
kernel_known_generic_statics = set(
        [
          "ipt_get_target",  # uapi/linux/netfilter_ipv4/ip_tables.h
          "ip6t_get_target", # uapi/linux/netfilter_ipv6/ip6_tables.h
          # Byte swapping inlines from uapi/linux/swab.h
          # The below functions are the ones we are guaranting we export.
          "__swab16",
          "__swab32",
          "__swab64",
          "__swab16p",
          "__swab32p",
          "__swab64p",
          "__swab16s",
          "__swab32s",
          "__swab64s",
          "__swahw32",
          "__swahb32",
          "__swahw32p",
          "__swahb32p",
          "__swahw32s",
          "__swahb32s",
          # These are required to support the above functions.
          "__fswahw32",
          "__fswahb32",
          # This is used by various macros in <linux/ioprio.h>.
          "ioprio_value",

          # Contact opensource-licensing@ before adding to this set.
        ]
    )

"""

```
Response:
Let's break down the thought process for analyzing the provided C header file and fulfilling the request.

**1. Understanding the Context and Objective:**

The request clearly states the file's location within the Android Bionic library and asks for its functionalities, relationship to Android, implementation details (where applicable), dynamic linking aspects, usage errors, and how Android framework/NDK interacts with it, along with a Frida hook example. The core objective is to understand the purpose and usage of `rio_mport_cdev.h`.

**2. Initial Scan and Keyword Recognition:**

A quick scan of the header file reveals several key terms and patterns:

* **`rio_` prefix:** This strongly suggests that the file deals with a specific technology or subsystem named "RIO."  This is the most crucial clue to start further investigation.
* **`mport`:** Likely refers to a memory port or a similar concept for data transfer.
* **`cdev`:**  A strong indicator that this header defines the interface for a character device in the Linux kernel.
* **`ioctl.h`:**  Confirms that the interface is controlled via ioctl calls.
* **Structures (`struct`)**:  Numerous structures define data layouts for communication with the driver.
* **Macros (`#define`)**:  Constants and definitions for flags, magic numbers, and ioctl commands.
* **`DMA`:**  Suggests Direct Memory Access capabilities.
* **`doorbell` and `portwrite`:**  Indicate mechanisms for inter-device communication.
* **`transfer`:**  Points to data transfer operations.
* **`MAP_INBOUND`/`MAP_OUTBOUND`:**  Suggests memory mapping.

**3. Inferring Functionality from the Structure and Keywords:**

Based on the initial scan, I can start forming hypotheses about the file's purpose:

* **Character Device Driver Interface:**  The "cdev" and ioctl calls strongly suggest this. The driver likely manages communication with a hardware component.
* **Memory Management:** The presence of `rio_mmap`, `rio_dma_mem`, `MAP_INBOUND`, `MAP_OUTBOUND`, and `ALLOC_DMA`/`FREE_DMA` clearly indicate memory management functionalities, likely related to the RIO subsystem.
* **Inter-Device Communication:** `rio_doorbell` and `rio_portwrite` suggest mechanisms for sending signals or data between devices.
* **Data Transfer:** The `rio_transfer_io` and `rio_transaction` structures point to functionalities for initiating and managing data transfers.
* **Device Discovery/Management:** `rio_rdev_info`, `RIO_DEV_ADD`, `RIO_DEV_DEL` suggest the ability to add and remove RIO devices.

**4. Connecting to Android (High-Level):**

Since this file is in the Bionic library under `kernel/uapi/linux/`, it represents a *user-space* interface to a *kernel* driver. This means Android's user-space processes (including framework components or NDK applications) could potentially interact with RIO hardware via this interface.

**5. Detailed Analysis of Structures and Macros:**

Now, I'll go through each structure and macro, trying to understand its specific purpose:

* **`rio_mport_maint_io`:**  Looks like a general structure for performing maintenance operations (read/write) to RIO devices. The `rioid`, `hopcount`, `offset`, `length`, and `buffer` fields are common in memory access operations.
* **Transfer Mode and Capabilities (`RIO_TRANSFER_MODE_*`, `RIO_CAP_*`):**  Define different modes and capabilities of the RIO interface.
* **`rio_mport_properties`:** Describes the characteristics of a RIO port.
* **Doorbell and Portwrite Structures (`rio_doorbell`, `rio_portwrite`, filters):**  Clearly defined structures for sending and filtering doorbell and portwrite messages.
* **Memory Mapping Structures (`rio_mmap`, `rio_dma_mem`):** Define how memory regions are mapped between the RIO device and the host system.
* **Event Structure (`rio_event`):**  Defines the format of events generated by the RIO device.
* **Transfer Structures (`rio_transfer_io`, `rio_transaction`):**  Contain parameters for initiating and managing data transfers.
* **Device Information (`rio_rdev_info`):** Holds information about a RIO device.
* **IOCTL Definitions (`RIO_MPORT_DRV_MAGIC`, `_IOW`, `_IOR`, `_IOWR`):** Define the ioctl commands used to interact with the RIO driver. The magic number helps identify the driver, and the direction and size macros specify the data flow.

**6. Addressing Specific Requirements:**

* **Libc Function Explanation:** Since this is a header file, it doesn't *implement* libc functions. It *defines* the interface used by user-space programs (which *might* use libc functions like `ioctl`). Therefore, the explanation focuses on the *ioctl* system call used with these definitions.
* **Dynamic Linker:** This header file itself doesn't directly involve the dynamic linker. However, if user-space libraries were to provide wrappers around these ioctl calls, those libraries would be subject to dynamic linking. The example focuses on this indirect relationship.
* **Logical Reasoning and Examples:**  For each structure and ioctl, I considered potential usage scenarios and provided examples of how the data might be interpreted and used.
* **Common Usage Errors:**  I thought about typical mistakes developers might make when interacting with device drivers via ioctl, such as incorrect data sizes or invalid command codes.
* **Android Framework/NDK Interaction:** I traced the path from higher-level Android components down to the kernel driver, emphasizing the role of system calls and the NDK.
* **Frida Hook Example:**  I crafted a basic Frida script to demonstrate how to intercept and inspect ioctl calls related to the RIO driver.

**7. Structuring the Response:**

Finally, I organized the information into logical sections as requested:

* **功能 (Functionality):**  Summarizing the key capabilities.
* **与 Android 的关系 (Relationship with Android):** Explaining how this interface fits into the Android ecosystem.
* **Libc 函数的实现 (Libc Function Implementation):** Focusing on `ioctl`.
* **Dynamic Linker 功能 (Dynamic Linker Functionality):** Providing a simplified SO layout and outlining the linking process for a hypothetical user-space library.
* **逻辑推理 (Logical Reasoning):** Giving examples for the `rio_mport_maint_io` structure.
* **常见的使用错误 (Common Usage Errors):** Listing potential pitfalls.
* **Android Framework/NDK 到达路径 (Path from Android Framework/NDK):** Describing the call stack.
* **Frida Hook 示例 (Frida Hook Example):**  Providing a practical demonstration of how to debug this interface.

**Self-Correction/Refinement during the process:**

* Initially, I might have focused too much on the *implementation* of the RIO driver, but then realized the request was specifically about the *header file*, which defines the *interface*.
* I made sure to clarify that the dynamic linker is involved indirectly through user-space libraries, not directly with the header file itself.
* I tried to provide concrete examples for each aspect, making the explanation more accessible.

By following this structured approach, combining keyword analysis, logical deduction, and an understanding of the Android architecture, I could effectively analyze the provided header file and address all the requirements of the request.
这是一个定义了Linux内核中用于与RIO（RapidIO）多端口字符设备进行交互的应用程序接口（API）的头文件。它位于Android Bionic库中，意味着Android的底层系统和驱动程序可能会使用这个接口来与RapidIO硬件进行通信。

**功能列举:**

这个头文件定义了以下功能，这些功能通常通过 `ioctl` 系统调用与相应的内核驱动程序进行交互：

1. **维护操作 (Maintenance Operations):**
   - 读取和写入本地或远程RIO设备的配置空间或内存空间 (`RIO_MPORT_MAINT_READ_LOCAL`, `RIO_MPORT_WRITE_LOCAL`, `RIO_MPORT_MAINT_READ_REMOTE`, `RIO_MPORT_MAINT_WRITE_REMOTE`)。
   - 设置主设备ID (`RIO_MPORT_MAINT_HDID_SET`) 和完成标签 (`RIO_MPORT_MAINT_COMPTAG_SET`)。
   - 获取端口索引 (`RIO_MPORT_MAINT_PORT_IDX_GET`)。

2. **获取端口属性 (Get Port Properties):**
   - 获取RIO端口的各种属性，例如硬件ID、索引、标志、系统大小、链路速度和宽度、DMA限制等 (`RIO_MPORT_GET_PROPERTIES`)。

3. **门铃和端口写 (Doorbell and Port Write):**
   - 启用和禁用特定目标ID范围内的门铃中断 (`RIO_ENABLE_DOORBELL_RANGE`, `RIO_DISABLE_DOORBELL_RANGE`)。
   - 启用和禁用特定掩码和值范围内的端口写中断 (`RIO_ENABLE_PORTWRITE_RANGE`, `RIO_DISABLE_PORTWRITE_RANGE`)。
   - 设置事件掩码 (`RIO_SET_EVENT_MASK`) 和获取事件掩码 (`RIO_GET_EVENT_MASK`)，用于控制哪些RIO事件会通知用户空间。

4. **内存映射 (Memory Mapping):**
   - 将RIO设备的内存区域映射到用户空间 (`RIO_MAP_OUTBOUND`, `RIO_MAP_INBOUND`)。
   - 取消映射已映射的RIO设备内存区域 (`RIO_UNMAP_OUTBOUND`, `RIO_UNMAP_INBOUND`)。

5. **DMA 操作 (DMA Operations):**
   - 分配用于DMA传输的内存 (`RIO_ALLOC_DMA`)。
   - 释放已分配的DMA内存 (`RIO_FREE_DMA`)。

6. **数据传输 (Data Transfer):**
   - 执行RIO设备之间的数据传输操作 (`RIO_TRANSFER`)，可以设置同步或异步模式。
   - 等待异步传输完成 (`RIO_WAIT_FOR_ASYNC`)。

7. **设备管理 (Device Management):**
   - 添加和删除RIO设备 (`RIO_DEV_ADD`, `RIO_DEV_DEL`)。

**与 Android 功能的关系及举例说明:**

RapidIO 是一种高性能的互连技术，通常用于嵌入式系统和高性能计算领域。在 Android 的上下文中，如果底层硬件包含 RapidIO 设备，Android 系统可能需要与这些设备进行交互。

**举例说明:**

假设 Android 设备中集成了一个使用 RapidIO 互连的加速器硬件（例如，用于图像处理或人工智能计算）。

- **驱动加载和设备发现:** 当 Android 系统启动时，RapidIO 的驱动程序可能会使用 `RIO_DEV_ADD` 将 RapidIO 设备注册到系统中。
- **内存映射:** Android 的一个服务进程（例如，负责硬件加速的进程）可能使用 `RIO_MAP_INBOUND` 将加速器设备的内存映射到自己的地址空间，以便直接访问加速器的内存。
- **数据传输:**  当需要将数据发送到加速器进行处理时，该服务进程可能会使用 `RIO_TRANSFER` 将数据传输到加速器的内存。
- **中断/事件通知:** 加速器完成计算后，可能会通过门铃中断或端口写事件通知 Android 系统。驱动程序会处理这些事件，并通过文件描述符通知用户空间进程。用户空间进程可以通过 `select` 或 `poll` 等机制监听这些事件。
- **维护和配置:**  可能存在一些系统级别的工具或服务，用于读取加速器的配置寄存器（使用 `RIO_MPORT_MAINT_READ_LOCAL` 或 `RIO_MPORT_MAINT_READ_REMOTE`）或设置其工作模式（使用 `RIO_MPORT_MAINT_WRITE_LOCAL` 或 `RIO_MPORT_MAINT_WRITE_REMOTE`）。

**libc 函数的功能实现:**

这个头文件本身并不实现任何 libc 函数。它定义了与内核驱动程序通信所需的常量、结构体和宏。用户空间的应用程序会使用 libc 提供的 `ioctl` 函数来与内核驱动程序进行交互。

`ioctl` 函数的原型通常如下：

```c
#include <sys/ioctl.h>

int ioctl(int fd, unsigned long request, ...);
```

- `fd`:  要操作的设备的文件描述符。这个文件描述符是通过 `open` 系统调用打开 RapidIO 字符设备文件（例如 `/dev/рио_mport0`）获得的。
- `request`:  一个与驱动程序定义的特定操作相对应的请求码。这个头文件中定义的 `RIO_MPORT_MAINT_HDID_SET` 等宏就是这样的请求码。
- `...`:  可选的参数，其类型取决于 `request`。通常是一个指向结构体的指针，用于向驱动程序传递数据或从驱动程序接收数据。

**例如，使用 `RIO_MPORT_GET_PROPERTIES` 获取端口属性的步骤可能如下:**

1. 使用 `open()` 系统调用打开 RapidIO 字符设备文件，获得文件描述符 `fd`。
2. 声明一个 `rio_mport_properties` 结构体变量 `props`。
3. 调用 `ioctl(fd, RIO_MPORT_GET_PROPERTIES, &props)`。
4. 如果 `ioctl` 调用成功，`props` 结构体中将包含从内核驱动程序获取的端口属性信息。
5. 使用 `close()` 系统调用关闭文件描述符。

**对于涉及 dynamic linker 的功能:**

这个头文件本身并不直接涉及 dynamic linker 的功能。Dynamic linker (如 `linker64` 或 `linker`) 的作用是在程序启动时加载和链接共享库。

然而，如果用户空间有一个共享库（`.so` 文件）提供了对 RapidIO 硬件进行操作的接口，那么这个共享库会使用这个头文件中定义的常量和结构体，并通过 `ioctl` 与内核驱动程序交互。

**SO 布局样本:**

假设有一个名为 `librio.so` 的共享库，它提供了操作 RapidIO 硬件的接口。其布局可能如下：

```
librio.so:
    .init       // 初始化段
    .plt        // 程序链接表 (Procedure Linkage Table)
    .text       // 代码段，包含实现 RapidIO 操作的函数
        rio_init()
        rio_get_port_properties()
        rio_transfer_data()
        ...
    .rodata     // 只读数据段，可能包含一些常量
    .data       // 可读写数据段
    .bss        // 未初始化数据段
    .dynsym     // 动态符号表
    .dynstr     // 动态字符串表
    .rel.dyn    // 动态重定位表
    ...
```

**链接的处理过程:**

1. **编译时:** 当应用程序或另一个共享库需要使用 `librio.so` 提供的功能时，编译器会生成对 `librio.so` 中函数的未解析引用。
2. **链接时:** 链接器（`ld`）会将应用程序或共享库与 `librio.so` 链接在一起，创建可执行文件或最终的共享库。链接器会记录下需要动态链接的信息，例如需要解析的符号和依赖的共享库。
3. **运行时:** 当应用程序启动时，dynamic linker 会执行以下操作：
   - 加载应用程序本身。
   - 检查应用程序依赖的共享库列表（通常在 ELF 头的 `DT_NEEDED` 标签中指定）。
   - 加载所有依赖的共享库，包括 `librio.so`。
   - 解析应用程序和所有加载的共享库中的符号引用。这包括找到 `librio.so` 中定义的函数地址，并将其填充到应用程序的 PLT 表中。
   - 执行共享库的初始化代码（`.init` 段中的代码）。

在 `librio.so` 的实现中，可能会包含类似以下的代码来使用这个头文件中定义的接口：

```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include "bionic/libc/kernel/uapi/linux/rio_mport_cdev.handroid"

int rio_get_port_properties(const char *dev_path, struct rio_mport_properties *props) {
    int fd = open(dev_path, O_RDWR);
    if (fd < 0) {
        perror("open");
        return -1;
    }

    if (ioctl(fd, RIO_MPORT_GET_PROPERTIES, props) < 0) {
        perror("ioctl RIO_MPORT_GET_PROPERTIES");
        close(fd);
        return -1;
    }

    close(fd);
    return 0;
}
```

**逻辑推理、假设输入与输出:**

考虑 `RIO_MPORT_MAINT_READ_LOCAL` 这个 ioctl 命令。

**假设输入:**

- `fd`: 打开 RapidIO 字符设备的文件描述符（例如，通过 `open("/dev/rio_mport0", O_RDWR)` 获得）。
- `request`: `RIO_MPORT_MAINT_READ_LOCAL`。
- `argp`: 指向 `rio_mport_maint_io` 结构体的指针，该结构体包含了要读取的信息：
    - `rioid`:  目标 RapidIO 设备 ID，假设为 `0x10`。
    - `hopcount`:  跳数，假设为 `0`（本地设备）。
    - `offset`:  要读取的寄存器或内存地址，假设为 `0x1000`。
    - `length`:  要读取的字节数，假设为 `4`。
    - `buffer`:  指向用于接收读取数据的用户空间缓冲区的指针。

**预期输出:**

- 如果 `ioctl` 调用成功，返回值为 `0`。
- `buffer` 指向的内存区域将被填充从 RapidIO 设备地址 `0x1000` 读取的 4 个字节的数据。
- 如果 `ioctl` 调用失败（例如，设备不存在、权限不足、地址无效），返回值将为 `-1`，并且 `errno` 会被设置为相应的错误码。

**用户或编程常见的使用错误:**

1. **错误的文件描述符:** 传递给 `ioctl` 的文件描述符不是一个有效的 RapidIO 设备文件描述符。
2. **错误的 ioctl 请求码:** 使用了错误的 `request` 值，导致内核驱动程序无法识别要执行的操作。
3. **`rio_mport_maint_io` 结构体字段设置错误:**
   - `rioid` 设置为不存在的设备 ID。
   - `offset` 或 `length` 超出设备允许的范围。
   - `buffer` 指向的内存区域无效或太小，无法容纳读取的数据。
4. **权限问题:** 用户进程没有足够的权限打开 RapidIO 设备文件或执行特定的 ioctl 操作。
5. **竞态条件:**  多个进程或线程同时尝试访问和操作同一个 RapidIO 设备，可能导致数据不一致或操作失败。
6. **忘记检查 `ioctl` 的返回值:**  `ioctl` 调用可能会失败，但如果没有检查返回值，程序可能会继续执行，导致不可预测的行为。
7. **内存映射错误:**  使用 `RIO_MAP_OUTBOUND` 或 `RIO_MAP_INBOUND` 时，提供的地址或长度与设备的实际内存布局不符。

**Frida Hook 示例调试步骤:**

可以使用 Frida hook `ioctl` 系统调用，并过滤出与 RapidIO 相关的调用，以观察应用程序如何与内核驱动程序交互。

**假设要 hook `RIO_MPORT_GET_PROPERTIES` 这个 ioctl 命令。**

1. **找到目标进程:**  确定要调试的 Android 进程的进程 ID 或进程名称。

2. **编写 Frida 脚本:**

```python
import frida
import sys

def on_message(message, data):
    if message['type'] == 'send':
        print("[*] {}".format(message['payload']))
    else:
        print(message)

def main():
    if len(sys.argv) != 2:
        print("Usage: python {} <process name or PID>".format(sys.argv[0]))
        sys.exit(1)

    target = sys.argv[1]
    try:
        session = frida.attach(target)
    except frida.ProcessNotFoundError:
        print("Process not found: {}".format(target))
        sys.exit(1)

    script_code = """
    Interceptor.attach(Module.findExportByName(null, "ioctl"), {
        onEnter: function(args) {
            const fd = args[0].toInt32();
            const request = args[1].toInt32();

            // 定义 RIO_MPORT_DRV_MAGIC 和 ioctl 命令值
            const RIO_MPORT_DRV_MAGIC = 'm'.charCodeAt(0);
            const RIO_MPORT_GET_PROPERTIES = _IOR(RIO_MPORT_DRV_MAGIC, 4, 0); // 假设第三个参数类型不重要

            function _IOR(type, nr, size) {
                return (type << 0) | (size << 8) | (nr << 16) | (2 << 30);
            }

            if (request === RIO_MPORT_GET_PROPERTIES) {
                console.log("[RIO_MPORT_GET_PROPERTIES] ioctl called with fd:", fd);
                this.propsPtr = args[2]; // 保存指向 rio_mport_properties 结构体的指针
            }
        },
        onLeave: function(retval) {
            const request = this.context.r1; // 在 ARM64 上，ioctl 的 request 参数通常在 r1 寄存器中
            const RIO_MPORT_DRV_MAGIC = 'm'.charCodeAt(0);
            const RIO_MPORT_GET_PROPERTIES = _IOR(RIO_MPORT_DRV_MAGIC, 4, 0);

            function _IOR(type, nr, size) {
                return (type << 0) | (size << 8) | (nr << 16) | (2 << 30);
            }

            if (retval.toInt32() === 0 && request === RIO_MPORT_GET_PROPERTIES) {
                console.log("[RIO_MPORT_GET_PROPERTIES] ioctl returned successfully!");
                const props = Memory.readByteArray(this.propsPtr, 64); // 假设结构体大小不超过 64 字节
                console.log("[RIO_MPORT_GET_PROPERTIES] rio_mport_properties:", hexdump(props, { ansi: true }));
            }
        }
    });
    """

    script = session.create_script(script_code)
    script.on('message', on_message)
    script.load()
    input("Press Enter to detach...\n")
    session.detach()

if __name__ == '__main__':
    main()
```

3. **运行 Frida 脚本:**  使用以下命令运行脚本，替换 `<process name or PID>` 为目标进程的名称或 ID：

   ```bash
   frida -l your_script.py <process name or PID>
   ```

4. **分析输出:** 当目标进程调用 `ioctl` 且 `request` 为 `RIO_MPORT_GET_PROPERTIES` 时，Frida 脚本会在控制台上打印相关信息，包括文件描述符和 `rio_mport_properties` 结构体的内容（以十六进制形式显示）。

**Android Framework or NDK 是如何一步步的到达这里:**

1. **NDK 应用:**
   - NDK 应用可以通过标准 C/C++ 库函数（例如 `open`, `ioctl`）直接与设备驱动程序交互。
   - 应用会 `open()`  `/dev/rio_mportX` 这样的设备文件。
   - 应用会填充相应的结构体（例如 `rio_mport_properties`）并调用 `ioctl()`，使用头文件中定义的宏作为 `request` 参数。

2. **Android Framework (Java/Kotlin):**
   - Android Framework 通常不会直接调用底层的 `ioctl`。
   - Framework 会通过 JNI (Java Native Interface) 调用 Native 代码（C/C++ 代码）。
   - 这些 Native 代码可能位于 Android 的系统服务或硬件抽象层 (HAL) 中。
   - HAL 或系统服务会负责与内核驱动程序交互。

   **示例路径:**

   - **Java Framework 代码:** 可能会调用某个 Manager 类的函数，例如 `RapidIOManager.getPortProperties()`.
   - **JNI 调用:** `RapidIOManager` 的 Java 代码会通过 JNI 调用对应的 Native 函数，例如 `native_get_port_properties()`.
   - **Native 代码 (HAL 或 System Service):** `native_get_port_properties()` 函数会：
     - `open()` RapidIO 设备文件。
     - 填充 `rio_mport_properties` 结构体。
     - 调用 `ioctl(fd, RIO_MPORT_GET_PROPERTIES, &props)`.
     - 将获取的属性转换回 Java 对象，并通过 JNI 返回给 Framework。

**总结:**

`bionic/libc/kernel/uapi/linux/rio_mport_cdev.handroid` 是一个关键的头文件，定义了用户空间应用程序与 Linux 内核中 RapidIO 多端口字符设备驱动程序进行通信的接口。它允许用户空间程序执行各种操作，包括维护、属性获取、门铃和端口写、内存映射、DMA 传输和设备管理。理解这个头文件对于开发和调试与 RapidIO 硬件交互的 Android 系统组件至关重要。

Prompt: 
```
这是目录为bionic/libc/kernel/uapi/linux/rio_mport_cdev.handroid bionic的源代码文件，bionic is Android's C library, math library, and dynamic linker. 
请列举一下它的功能,
如果它与android的功能有关系，请做出对应的举例说明，
详细解释每一个libc函数的功能是如何实现的,
对于涉及dynamic linker的功能，请给对应的so布局样本，以及链接的处理过程，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明android framework or ndk是如何一步步的到达这里，给出frida hook示例调试这些步骤。
用中文回复。

"""
/*
 * This file is auto-generated. Modifications will be lost.
 *
 * See https://android.googlesource.com/platform/bionic/+/master/libc/kernel/
 * for more information.
 */
#ifndef _RIO_MPORT_CDEV_H_
#define _RIO_MPORT_CDEV_H_
#include <linux/ioctl.h>
#include <linux/types.h>
struct rio_mport_maint_io {
  __u16 rioid;
  __u8 hopcount;
  __u8 pad0[5];
  __u32 offset;
  __u32 length;
  __u64 buffer;
};
#define RIO_TRANSFER_MODE_MAPPED (1 << 0)
#define RIO_TRANSFER_MODE_TRANSFER (1 << 1)
#define RIO_CAP_DBL_SEND (1 << 2)
#define RIO_CAP_DBL_RECV (1 << 3)
#define RIO_CAP_PW_SEND (1 << 4)
#define RIO_CAP_PW_RECV (1 << 5)
#define RIO_CAP_MAP_OUTB (1 << 6)
#define RIO_CAP_MAP_INB (1 << 7)
struct rio_mport_properties {
  __u16 hdid;
  __u8 id;
  __u8 index;
  __u32 flags;
  __u32 sys_size;
  __u8 port_ok;
  __u8 link_speed;
  __u8 link_width;
  __u8 pad0;
  __u32 dma_max_sge;
  __u32 dma_max_size;
  __u32 dma_align;
  __u32 transfer_mode;
  __u32 cap_sys_size;
  __u32 cap_addr_size;
  __u32 cap_transfer_mode;
  __u32 cap_mport;
};
#define RIO_DOORBELL (1 << 0)
#define RIO_PORTWRITE (1 << 1)
struct rio_doorbell {
  __u16 rioid;
  __u16 payload;
};
struct rio_doorbell_filter {
  __u16 rioid;
  __u16 low;
  __u16 high;
  __u16 pad0;
};
struct rio_portwrite {
  __u32 payload[16];
};
struct rio_pw_filter {
  __u32 mask;
  __u32 low;
  __u32 high;
  __u32 pad0;
};
#define RIO_MAP_ANY_ADDR (__u64) (~((__u64) 0))
struct rio_mmap {
  __u16 rioid;
  __u16 pad0[3];
  __u64 rio_addr;
  __u64 length;
  __u64 handle;
  __u64 address;
};
struct rio_dma_mem {
  __u64 length;
  __u64 dma_handle;
  __u64 address;
};
struct rio_event {
  __u32 header;
  union {
    struct rio_doorbell doorbell;
    struct rio_portwrite portwrite;
  } u;
  __u32 pad0;
};
enum rio_transfer_sync {
  RIO_TRANSFER_SYNC,
  RIO_TRANSFER_ASYNC,
  RIO_TRANSFER_FAF,
};
enum rio_transfer_dir {
  RIO_TRANSFER_DIR_READ,
  RIO_TRANSFER_DIR_WRITE,
};
enum rio_exchange {
  RIO_EXCHANGE_DEFAULT,
  RIO_EXCHANGE_NWRITE,
  RIO_EXCHANGE_SWRITE,
  RIO_EXCHANGE_NWRITE_R,
  RIO_EXCHANGE_SWRITE_R,
  RIO_EXCHANGE_NWRITE_R_ALL,
};
struct rio_transfer_io {
  __u64 rio_addr;
  __u64 loc_addr;
  __u64 handle;
  __u64 offset;
  __u64 length;
  __u16 rioid;
  __u16 method;
  __u32 completion_code;
};
struct rio_transaction {
  __u64 block;
  __u32 count;
  __u32 transfer_mode;
  __u16 sync;
  __u16 dir;
  __u32 pad0;
};
struct rio_async_tx_wait {
  __u32 token;
  __u32 timeout;
};
#define RIO_MAX_DEVNAME_SZ 20
struct rio_rdev_info {
  __u16 destid;
  __u8 hopcount;
  __u8 pad0;
  __u32 comptag;
  char name[RIO_MAX_DEVNAME_SZ + 1];
};
#define RIO_MPORT_DRV_MAGIC 'm'
#define RIO_MPORT_MAINT_HDID_SET _IOW(RIO_MPORT_DRV_MAGIC, 1, __u16)
#define RIO_MPORT_MAINT_COMPTAG_SET _IOW(RIO_MPORT_DRV_MAGIC, 2, __u32)
#define RIO_MPORT_MAINT_PORT_IDX_GET _IOR(RIO_MPORT_DRV_MAGIC, 3, __u32)
#define RIO_MPORT_GET_PROPERTIES _IOR(RIO_MPORT_DRV_MAGIC, 4, struct rio_mport_properties)
#define RIO_MPORT_MAINT_READ_LOCAL _IOR(RIO_MPORT_DRV_MAGIC, 5, struct rio_mport_maint_io)
#define RIO_MPORT_MAINT_WRITE_LOCAL _IOW(RIO_MPORT_DRV_MAGIC, 6, struct rio_mport_maint_io)
#define RIO_MPORT_MAINT_READ_REMOTE _IOR(RIO_MPORT_DRV_MAGIC, 7, struct rio_mport_maint_io)
#define RIO_MPORT_MAINT_WRITE_REMOTE _IOW(RIO_MPORT_DRV_MAGIC, 8, struct rio_mport_maint_io)
#define RIO_ENABLE_DOORBELL_RANGE _IOW(RIO_MPORT_DRV_MAGIC, 9, struct rio_doorbell_filter)
#define RIO_DISABLE_DOORBELL_RANGE _IOW(RIO_MPORT_DRV_MAGIC, 10, struct rio_doorbell_filter)
#define RIO_ENABLE_PORTWRITE_RANGE _IOW(RIO_MPORT_DRV_MAGIC, 11, struct rio_pw_filter)
#define RIO_DISABLE_PORTWRITE_RANGE _IOW(RIO_MPORT_DRV_MAGIC, 12, struct rio_pw_filter)
#define RIO_SET_EVENT_MASK _IOW(RIO_MPORT_DRV_MAGIC, 13, __u32)
#define RIO_GET_EVENT_MASK _IOR(RIO_MPORT_DRV_MAGIC, 14, __u32)
#define RIO_MAP_OUTBOUND _IOWR(RIO_MPORT_DRV_MAGIC, 15, struct rio_mmap)
#define RIO_UNMAP_OUTBOUND _IOW(RIO_MPORT_DRV_MAGIC, 16, struct rio_mmap)
#define RIO_MAP_INBOUND _IOWR(RIO_MPORT_DRV_MAGIC, 17, struct rio_mmap)
#define RIO_UNMAP_INBOUND _IOW(RIO_MPORT_DRV_MAGIC, 18, __u64)
#define RIO_ALLOC_DMA _IOWR(RIO_MPORT_DRV_MAGIC, 19, struct rio_dma_mem)
#define RIO_FREE_DMA _IOW(RIO_MPORT_DRV_MAGIC, 20, __u64)
#define RIO_TRANSFER _IOWR(RIO_MPORT_DRV_MAGIC, 21, struct rio_transaction)
#define RIO_WAIT_FOR_ASYNC _IOW(RIO_MPORT_DRV_MAGIC, 22, struct rio_async_tx_wait)
#define RIO_DEV_ADD _IOW(RIO_MPORT_DRV_MAGIC, 23, struct rio_rdev_info)
#define RIO_DEV_DEL _IOW(RIO_MPORT_DRV_MAGIC, 24, struct rio_rdev_info)
#endif

"""

```
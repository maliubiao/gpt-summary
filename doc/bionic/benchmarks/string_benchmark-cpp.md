Response:
Let's break down the thought process for answering the user's request about the `string_benchmark.cpp` file.

**1. Understanding the Core Request:**

The user wants to understand the functionality of the provided C++ source code, its relation to Android, details about the libc functions used, insights into the dynamic linker, potential errors, and how the code is reached during Android execution.

**2. Initial Code Scan - Identifying Key Elements:**

The first step is to quickly skim the code to identify the main components. I see:

* **Includes:**  `<err.h>`, `<stdint.h>`, `<string.h>`, `<benchmark/benchmark.h>`, `<util.h>`. These indicate the file is doing benchmarking of string functions.
* **`BM_string_*` Functions:**  A series of functions with names starting with `BM_string_`. The `BM_` prefix strongly suggests these are benchmark functions. The names clearly correspond to standard C string manipulation functions (e.g., `memcmp`, `memcpy`, `strlen`).
* **`BIONIC_BENCHMARK_WITH_ARG` Macro:** This is a strong indicator that the file uses a benchmarking framework and is likely specific to the Bionic library.
* **`GetAlignedPtrFilled` and `GetAlignedPtr`:** These utility functions suggest that memory alignment is a key concern in these benchmarks.
* **`state.range(0)`, `state.range(1)`, `state.range(2)`:**  These are used to access parameters within the benchmark functions, likely representing buffer sizes and alignments.
* **`benchmark::DoNotOptimize`:** This is a crucial element for accurate benchmarking, preventing the compiler from optimizing away the function calls being measured.
* **`state.SetBytesProcessed`:** This is used to track the amount of data processed during the benchmark.

**3. Deconstructing the Functionality:**

Based on the initial scan, it's clear the primary function of this file is to benchmark various C string manipulation functions. Each `BM_string_*` function sets up test data (often aligned buffers) and then repeatedly calls the corresponding `libc` function within a loop managed by the `benchmark` framework.

**4. Connecting to Android (Bionic):**

The file path (`bionic/benchmarks/`) and the `BIONIC_BENCHMARK_WITH_ARG` macro strongly tie this to Android's Bionic library. Bionic is Android's C library. Therefore, this code is benchmarking *Bionic's implementation* of the standard C string functions. This answers the "relation to Android" part.

**5. Explaining libc Functions:**

For each `BM_string_*` function, I need to explain the corresponding `libc` function's purpose:

* `memcmp`: Compares memory regions.
* `memcpy`: Copies memory regions.
* `memmove`: Copies memory regions, handling overlaps.
* `memset`: Fills a memory region with a constant byte.
* `strlen`: Calculates the length of a string.
* `strcat`: Appends one string to another.
* `strcpy`: Copies a string.
* `strcmp`: Compares two strings.
* `strncmp`: Compares the first `n` characters of two strings.
* `strstr`: Finds the first occurrence of a substring within a string.
* `strchr`: Finds the first occurrence of a character within a string.

For the "how it's implemented" part, it's important to note that this benchmark *uses* these functions. The source code *doesn't implement* them. The actual implementation resides within the Bionic library itself. Therefore, the explanation focuses on the standard behavior and potential optimizations (like alignment).

**6. Dynamic Linker Aspects:**

The provided code doesn't directly demonstrate dynamic linking. However, because it's part of Bionic, it *implicitly* depends on the dynamic linker. To address this part of the request:

* **SO Layout:** Describe the basic structure of a shared object (`.so`) file, including sections like `.text`, `.data`, `.bss`, `.symtab`, `.rel.dyn`, etc.
* **Symbol Resolution:** Explain how the dynamic linker resolves symbols during the loading and linking process. Differentiate between global and local symbols and how relocation entries are processed. Provide a simplified example to illustrate.

**7. Logic, Assumptions, Inputs/Outputs:**

The "logic" here is the benchmarking framework itself. The assumptions are that the input buffers are correctly allocated and potentially aligned. The "inputs" are the sizes and alignments provided to the benchmark functions. The "outputs" are the benchmark results (not directly visible in the source code but generated by the benchmarking framework).

**8. Common User Errors:**

Think about common mistakes when using these string functions:

* Buffer overflows with `strcpy` and `strcat`.
* Off-by-one errors with `strlen`.
* Incorrectly assuming non-overlapping memory with `memcpy` when `memmove` is needed.
* Forgetting null termination.

**9. Android Framework/NDK Debugging:**

Trace the path from a high-level Android application to this code:

* **Java code using JNI:** The app calls a native function.
* **NDK:**  The native code is compiled using the NDK.
* **Bionic:** The native code links against Bionic.
* **`string.h`:**  The native code includes `string.h`, which provides declarations for the string functions.
* **Bionic's implementation:** When the native code calls a string function (e.g., `memcpy`), the execution jumps to Bionic's implementation of that function.

This benchmark is a *test* of Bionic's implementation, so it's a lower-level step in the overall chain.

**10. Structuring the Answer:**

Organize the information logically using headings and bullet points for clarity. Address each part of the user's request explicitly.

**Self-Correction/Refinement During the Process:**

* **Initial thought:** Should I try to guess the exact implementation details of the libc functions? **Correction:** No, the benchmark *uses* them, it doesn't define them. Focus on the *purpose* and potential high-level optimizations.
* **Initial thought:**  Should I provide very detailed information about the dynamic linker? **Correction:** Provide a concise overview relevant to the context of a C library benchmark. Avoid getting lost in the weeds of dynamic linking internals.
* **Initial thought:** Should I include a complex example of NDK usage? **Correction:** A simplified explanation of the path from Java to native code using JNI is sufficient. The goal is to provide context, not an exhaustive explanation of the Android build system.

By following these steps and engaging in some self-correction, I can construct a comprehensive and accurate answer to the user's request.
好的，让我们详细分析一下 `bionic/benchmarks/string_benchmark.cpp` 这个文件。

**文件功能概述**

这个 `string_benchmark.cpp` 文件的主要功能是**对 Android Bionic C 库中的字符串操作函数进行性能基准测试 (benchmarking)**。它使用 Google Benchmark 框架来测量各种字符串函数的执行效率，例如 `memcmp`, `memcpy`, `memmove`, `memset`, `strlen`, `strcat`, `strcpy`, `strcmp`, `strncmp`, `strstr`, 和 `strchr`。

**与 Android 功能的关系及举例**

这个文件直接关系到 Android 系统的性能和稳定性。Bionic 是 Android 的基础 C 库，所有 Android 应用（包括 Java 代码通过 JNI 调用的 native 代码）都会使用到 Bionic 提供的这些字符串函数。

* **性能优化:** 通过基准测试，可以了解 Bionic 中字符串函数的性能瓶颈，从而进行优化，提高整个 Android 系统的性能。例如，如果 `memcpy` 的基准测试结果显示在特定对齐方式下性能较差，Bionic 的开发者可能会针对这些情况改进 `memcpy` 的实现。
* **回归测试:** 在修改 Bionic 的代码后，可以运行这些基准测试来确保修改没有引入性能下降。
* **对比不同实现:** 可能会存在不同的字符串函数实现方式（例如，使用 SIMD 指令进行加速），基准测试可以帮助选择更高效的实现。

**举例说明:**

假设在某个版本的 Android 中，开发者修改了 `memcpy` 的实现以利用 ARM 处理器的 NEON 指令集进行加速。为了验证这个修改的有效性，就可以运行 `BM_string_memcpy` 这个基准测试，比较修改前后的性能数据。如果修改后的性能明显提升，则说明这次优化是成功的。

**详细解释每一个 libc 函数的功能是如何实现的**

需要强调的是，这个 `string_benchmark.cpp` 文件 **本身并没有实现这些 libc 函数**。它只是 *调用* 这些函数并测量它们的执行时间。这些函数的实际实现位于 Bionic 库的其他源文件中（例如，`bionic/libc/bionic/string.c` 或架构相关的优化版本）。

以下简要解释这些 libc 函数的功能和常见的实现思路：

* **`memcmp(const void *s1, const void *s2, size_t n)`:**
    * **功能:** 比较 `s1` 和 `s2` 指向的内存区域的前 `n` 个字节。
    * **实现:** 通常逐字节比较，直到找到不同的字节或者比较完 `n` 个字节。为了提高效率，可能会按字 (word) 或更大的单位进行比较。
* **`memcpy(void *dest, const void *src, size_t n)`:**
    * **功能:** 将 `src` 指向的内存区域的前 `n` 个字节复制到 `dest` 指向的内存区域。**不处理内存区域重叠的情况。**
    * **实现:**  最简单的实现是逐字节复制。为了提高效率，通常会按字 (word) 或更大的单位进行复制，并可能针对不同的内存对齐情况进行优化。现代实现常常会使用 CPU 的 DMA (Direct Memory Access) 或其他硬件加速机制。
* **`memmove(void *dest, const void *src, size_t n)`:**
    * **功能:** 将 `src` 指向的内存区域的前 `n` 个字节复制到 `dest` 指向的内存区域。**可以处理内存区域重叠的情况。**
    * **实现:**  为了处理重叠，实现会检查 `src` 和 `dest` 的地址。如果 `dest` 在 `src` 之后且有重叠，则从后往前复制；如果 `src` 在 `dest` 之后且有重叠，则从前往后复制。如果没有重叠，行为类似于 `memcpy`。
* **`memset(void *s, int c, size_t n)`:**
    * **功能:** 将 `s` 指向的内存区域的前 `n` 个字节设置为 `c` 的值。
    * **实现:** 最简单的实现是逐字节设置。为了提高效率，通常会按字 (word) 或更大的单位进行设置，并将 `c` 扩展到对应的大小。
* **`strlen(const char *s)`:**
    * **功能:** 计算以空字符 `\0` 结尾的字符串 `s` 的长度（不包括空字符）。
    * **实现:** 从字符串的起始地址开始，逐字节遍历，直到遇到空字符。
* **`strcat(char *dest, const char *src)`:**
    * **功能:** 将 `src` 指向的字符串追加到 `dest` 指向的字符串末尾。`dest` 必须有足够的空间容纳追加后的字符串。
    * **实现:** 首先找到 `dest` 字符串的末尾（即空字符的位置），然后将 `src` 字符串的内容复制到 `dest` 的末尾，最后在末尾添加空字符。
* **`strcpy(char *dest, const char *src)`:**
    * **功能:** 将 `src` 指向的字符串（包括空字符）复制到 `dest` 指向的内存区域。`dest` 必须有足够的空间容纳 `src`。
    * **实现:** 从 `src` 的起始地址开始，逐字节复制到 `dest`，直到遇到 `src` 的空字符，并将空字符也复制过去。
* **`strcmp(const char *s1, const char *s2)`:**
    * **功能:** 比较字符串 `s1` 和 `s2`。
    * **实现:** 逐字符比较 `s1` 和 `s2`，直到遇到不同的字符或者其中一个字符串的空字符。返回值指示两个字符串的字典序关系。
* **`strncmp(const char *s1, const char *s2, size_t n)`:**
    * **功能:** 比较字符串 `s1` 和 `s2` 的前 `n` 个字符。
    * **实现:** 类似于 `strcmp`，但最多比较 `n` 个字符。
* **`strstr(const char *haystack, const char *needle)`:**
    * **功能:** 在字符串 `haystack` 中查找第一次出现字符串 `needle` 的位置。
    * **实现:** 常见的实现是使用滑动窗口的方法，在 `haystack` 中依次比较长度与 `needle` 相同的子串是否与 `needle` 相等。可能会使用更高效的算法，例如 KMP 算法。
* **`strchr(const char *s, int c)`:**
    * **功能:** 在字符串 `s` 中查找字符 `c` 第一次出现的位置。
    * **实现:** 从字符串的起始地址开始，逐字符遍历，直到找到字符 `c` 或者到达字符串末尾。

**对于 dynamic linker 的功能，请给 so 布局样本，以及每种符号如何的处理过程**

这个 `string_benchmark.cpp` 文件本身并不直接涉及动态链接器的操作，因为它是一个可执行文件，而非共享库。但是，它所测试的 libc 函数是由动态链接器加载到进程空间的。

**SO 布局样本 (简化)**

一个典型的 `.so` (Shared Object) 文件（在 Android 上通常是 `.so`）布局大致如下：

```
ELF Header:
    ... (包含文件类型、架构等信息)

Program Headers:
    LOAD: 可加载段的描述 (例如 .text, .rodata, .data)
    DYNAMIC: 动态链接信息表

Section Headers:
    .text:  可执行代码段
    .rodata: 只读数据段 (例如字符串常量)
    .data:  已初始化的可写数据段
    .bss:   未初始化的可写数据段
    .symtab: 符号表 (包含全局和局部符号)
    .strtab: 字符串表 (存储符号名称等字符串)
    .dynsym: 动态符号表 (用于动态链接)
    .dynstr: 动态字符串表
    .rel.dyn: 动态重定位表 (用于在加载时修正地址)
    .rel.plt: PLT (Procedure Linkage Table) 的重定位表
    ...

Section Data:
    (各个段的实际数据)
```

**每种符号的处理过程**

动态链接器 (在 Android 上主要是 `linker64` 或 `linker`) 在加载共享库时，主要处理以下几种符号：

1. **未定义的符号 (Undefined Symbols):**
   * 这些符号在当前 SO 中被引用，但其定义不在当前 SO 中。
   * 动态链接器需要在其他已加载的 SO 或主程序中找到这些符号的定义。
   * 例如，在某个 SO 中调用了 `memcpy`，但 `memcpy` 的实现在 `libc.so` 中，那么 `memcpy` 就是该 SO 的一个未定义符号。

   **处理过程:**
   * 动态链接器会遍历已加载的共享库的动态符号表 (`.dynsym`) 来查找匹配的符号。
   * 如果找到匹配的符号，则将该符号的地址记录下来，并在运行时修正调用该符号的指令地址（重定位）。
   * 如果找不到，则会报错，导致加载失败。

2. **已定义的全局符号 (Defined Global Symbols):**
   * 这些符号在当前 SO 中被定义，并且可以被其他 SO 或主程序引用。
   * 例如，`libc.so` 中定义的 `memcpy` 函数就是一个全局符号。

   **处理过程:**
   * 动态链接器会将这些全局符号及其地址添加到全局符号表中，以便其他 SO 查找。
   * 遵循一定的符号可见性规则（例如，`visibility` 属性）来决定哪些全局符号可以被外部访问。

3. **局部符号 (Local Symbols):**
   * 这些符号在当前 SO 中被定义，但仅限于当前 SO 内部使用，对外部不可见。
   * 例如，一个 `.c` 文件中的 `static` 函数。

   **处理过程:**
   * 局部符号主要用于链接器进行符号解析和重定位。
   * 动态链接器在运行时通常不会处理局部符号。

**PLT (Procedure Linkage Table) 和 GOT (Global Offset Table)**

对于函数调用，动态链接通常使用 PLT 和 GOT 机制来实现延迟绑定 (lazy binding)：

* **PLT:**  包含一系列小的代码片段，用于跳转到实际的函数地址。
* **GOT:**  包含函数地址的表项。

**处理过程 (以调用 `memcpy` 为例):**

1. 第一次调用 `memcpy` 时，会跳转到 PLT 中 `memcpy` 对应的条目。
2. PLT 条目中的代码会查找 GOT 中 `memcpy` 对应的条目。最初，GOT 条目包含的是 PLT 中下一条指令的地址。
3. PLT 代码会将 `memcpy` 的符号信息压栈，并跳转到动态链接器的解析函数 (`_dl_runtime_resolve` 或类似名称)。
4. 动态链接器查找 `memcpy` 的实际地址，并更新 GOT 中 `memcpy` 对应的条目。
5. 动态链接器跳转到 `memcpy` 的实际地址。
6. 后续对 `memcpy` 的调用会直接跳转到 PLT，然后从 GOT 中获取 `memcpy` 的实际地址，实现高效的调用。

**假设输入与输出 (针对基准测试)**

这个文件是一个基准测试程序，它的“输入”是通过 `benchmark::State` 对象提供的，包括要操作的字节数 (`nbytes`) 和内存对齐方式 (`src_alignment`, `dst_alignment`)。

**假设输入:**

* `nbytes`: 1024 (1KB)
* `src_alignment`: 16 (字节对齐)
* `dst_alignment`: 8 (字节对齐)

**预期输出:**

基准测试框架会输出类似以下的性能数据：

```
Benchmark                      Time             CPU   Iterations
-----------------------------------------------------------------
BM_string_memcpy/1024/16/8    XX.XX ns       YY.YY ns          ZZZZ
```

* `Time`: 函数执行的平均时间（纳秒）。
* `CPU`: CPU 消耗的平均时间（纳秒）。
* `Iterations`: 执行的迭代次数。

这些输出会根据具体的硬件、编译选项和 Bionic 的实现而有所不同。

**涉及用户或者编程常见的使用错误，请举例说明**

使用这些 C 字符串函数时，常见的错误包括：

1. **缓冲区溢出 (Buffer Overflow):**
   * **错误示例:** 使用 `strcpy` 或 `strcat` 时，目标缓冲区 `dest` 的空间不足以容纳源字符串 `src`，导致覆盖了 `dest` 缓冲区后面的内存。
   ```c
   char buffer[10];
   strcpy(buffer, "This is a long string"); // 缓冲区溢出
   ```
   * **后果:** 可能导致程序崩溃、数据损坏，甚至安全漏洞。

2. **忘记空字符终止 (Missing Null Termination):**
   * **错误示例:** 手动复制字符串时，忘记在末尾添加空字符。
   ```c
   char buffer[10];
   strncpy(buffer, "hello", 5); // buffer 内容为 "hello" 但未以 '\0' 结尾
   printf("%s\n", buffer);      // 可能读取到 buffer 之外的内存
   ```
   * **后果:** 使用 `strlen` 等函数处理该字符串时，可能会读取到无效内存。

3. **内存区域重叠时使用 `memcpy`:**
   * **错误示例:** 当源和目标内存区域重叠时，使用 `memcpy` 可能导致未定义的行为。
   ```c
   char buffer[] = "abcdefgh";
   memcpy(buffer + 2, buffer, 6); // 内存区域重叠
   ```
   * **解决方法:** 应该使用 `memmove` 来处理重叠的内存区域。

4. **`strlen` 的返回值未考虑空字符串:**
   * **错误示例:**  假设一个字符串总是非空的，直接使用 `strlen` 的返回值作为索引。
   ```c
   char *str = get_string();
   char last_char = str[strlen(str) - 1]; // 如果 str 是空字符串，strlen(str) 为 0，导致访问越界
   ```
   * **解决方法:** 在访问前检查字符串是否为空。

5. **对未初始化的内存使用字符串函数:**
   * **错误示例:** 对未初始化的 `char` 数组使用 `strlen`。
   ```c
   char buffer[10]; // buffer 内容未定义
   size_t len = strlen(buffer); // 行为未定义，可能崩溃或返回错误的值
   ```

**说明 android framework or ndk 是如何一步步的到达这里，作为调试线索。**

1. **Android Framework (Java 代码):**
   * Android 应用通常从 Java 代码开始执行。
   * Framework 层提供了各种 API，例如 `android.os`, `android.app`, `android.view` 等。

2. **调用 Native 代码 (JNI):**
   * 如果需要在 Java 代码中执行性能敏感或平台特定的操作，可以使用 JNI (Java Native Interface) 调用 Native 代码（C/C++）。
   * Java 代码会声明 Native 方法，并在 Native 代码中实现。

   ```java
   // Java 代码
   public class MyClass {
       public native String stringFromJNI();
       static {
           System.loadLibrary("mynativelib"); // 加载 Native 库
       }
   }
   ```

3. **NDK (Native Development Kit):**
   * Android NDK 是一套工具，允许开发者使用 C 和 C++ 编写 Native 代码。
   * 使用 NDK 编译的 Native 代码会被打包成共享库 (`.so` 文件)。

4. **Bionic (Android C Library):**
   * Native 代码在执行过程中，通常会调用标准 C 库提供的函数，例如 `memcpy`, `strlen` 等。
   * 在 Android 上，这些函数的实现位于 Bionic 库中。
   * 当 Native 代码调用 `memcpy` 时，实际上会调用 `bionic/libc/bionic/memcpy.c` 或其优化版本中的实现。

5. **`string_benchmark.cpp` 的作用:**
   * `string_benchmark.cpp` 是 Bionic 库自身的一部分，用于测试 Bionic 提供的字符串函数的性能。
   * 它不是 Android 应用直接调用的代码。
   * Bionic 的开发者会定期运行这些基准测试，以监控性能变化并进行优化。

**调试线索:**

如果在使用 NDK 开发时遇到与字符串操作相关的性能问题或错误，可以按照以下思路进行调试：

1. **检查 JNI 调用:** 确保 Java 代码正确地调用了 Native 方法，并且传递了正确的参数。
2. **Native 代码逻辑:** 仔细检查 Native 代码中字符串操作的逻辑，例如缓冲区大小、空字符处理等。
3. **使用 Valgrind 或 AddressSanitizer:** 这些工具可以帮助检测内存错误，例如缓冲区溢出、内存泄漏等。
4. **性能分析工具:** 使用 Android Profiler 或其他性能分析工具，可以查看 Native 代码中各个函数的执行时间，找出性能瓶颈。如果发现某些字符串函数的执行时间过长，可能需要进一步分析 Bionic 的实现或考虑优化算法。
5. **阅读 Bionic 源代码:** 如果怀疑 Bionic 的实现存在问题，可以查阅 Bionic 的源代码，了解函数的具体实现方式。虽然通常不需要这样做，但在某些情况下可以帮助理解问题的根源。

总而言之，`string_benchmark.cpp` 是 Bionic 库内部的测试工具，它间接地影响着所有使用 Bionic 字符串函数的 Android 应用的性能和稳定性。理解它的作用可以帮助我们更好地理解 Android 系统的底层工作原理，并在进行 Native 开发时提供一些调试思路。

### 提示词
```
这是目录为bionic/benchmarks/string_benchmark.cppandroid bionic的源代码文件，bionic is Android's C library, math library, and dynamic linker. 
请列举一下它的功能,
如果它与android的功能有关系，请做出对应的举例说明，
详细解释每一个libc函数的功能是如何实现的,
对于dynamic linker的功能，请给so布局样本，以及每种符号如何的处理过程，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明android framework or ndk是如何一步步的到达这里，作为调试线索。
```

### 源代码
```cpp
/*
 * Copyright (C) 2012 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <err.h>
#include <stdint.h>
#include <string.h>

#include <benchmark/benchmark.h>
#include <util.h>

static void BM_string_memcmp(benchmark::State& state) {
  const size_t nbytes = state.range(0);
  const size_t src_alignment = state.range(1);
  const size_t dst_alignment = state.range(2);

  std::vector<char> src;
  std::vector<char> dst;
  char* src_aligned = GetAlignedPtrFilled(&src, src_alignment, nbytes, 'x');
  char* dst_aligned = GetAlignedPtrFilled(&dst, dst_alignment, nbytes, 'x');

  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(memcmp(dst_aligned, src_aligned, nbytes));
  }

  state.SetBytesProcessed(uint64_t(state.iterations()) * uint64_t(nbytes));
}
BIONIC_BENCHMARK_WITH_ARG(BM_string_memcmp, "AT_ALIGNED_TWOBUF");

static void BM_string_memcpy(benchmark::State& state) {
  const size_t nbytes = state.range(0);
  const size_t src_alignment = state.range(1);
  const size_t dst_alignment = state.range(2);

  std::vector<char> src;
  std::vector<char> dst;
  char* src_aligned = GetAlignedPtrFilled(&src, src_alignment, nbytes, 'x');
  char* dst_aligned = GetAlignedPtr(&dst, dst_alignment, nbytes);

  while (state.KeepRunning()) {
    memcpy(dst_aligned, src_aligned, nbytes);
  }

  state.SetBytesProcessed(uint64_t(state.iterations()) * uint64_t(nbytes));
}
BIONIC_BENCHMARK_WITH_ARG(BM_string_memcpy, "AT_ALIGNED_TWOBUF");

static void BM_string_memmove_non_overlapping(benchmark::State& state) {
  const size_t nbytes = state.range(0);
  const size_t src_alignment = state.range(1);
  const size_t dst_alignment = state.range(2);

  std::vector<char> src;
  std::vector<char> dst;
  char* src_aligned = GetAlignedPtrFilled(&src, src_alignment, nbytes, 'x');
  char* dst_aligned = GetAlignedPtrFilled(&dst, dst_alignment, nbytes, 'y');

  while (state.KeepRunning()) {
    memmove(dst_aligned, src_aligned, nbytes);
  }

  state.SetBytesProcessed(uint64_t(state.iterations()) * uint64_t(nbytes));
}
BIONIC_BENCHMARK_WITH_ARG(BM_string_memmove_non_overlapping, "AT_ALIGNED_TWOBUF");

static void BM_string_memmove_overlap_dst_before_src(benchmark::State& state) {
  const size_t nbytes = state.range(0);
  const size_t alignment = state.range(1);

  std::vector<char> buf(3 * alignment + nbytes + 1, 'x');
  char* buf_aligned = GetAlignedPtrFilled(&buf, alignment, nbytes + 1, 'x');

  while (state.KeepRunning()) {
    memmove(buf_aligned, buf_aligned + 1, nbytes);  // Worst-case overlap.
  }

  state.SetBytesProcessed(uint64_t(state.iterations()) * uint64_t(nbytes));
}
BIONIC_BENCHMARK_WITH_ARG(BM_string_memmove_overlap_dst_before_src, "AT_ALIGNED_ONEBUF");

static void BM_string_memmove_overlap_src_before_dst(benchmark::State& state) {
  const size_t nbytes = state.range(0);
  const size_t alignment = state.range(1);

  std::vector<char> buf;
  char* buf_aligned = GetAlignedPtrFilled(&buf, alignment, nbytes + 1, 'x');

  while (state.KeepRunning()) {
    memmove(buf_aligned + 1, buf_aligned, nbytes);  // Worst-case overlap.
  }

  state.SetBytesProcessed(uint64_t(state.iterations()) * uint64_t(nbytes));
}
BIONIC_BENCHMARK_WITH_ARG(BM_string_memmove_overlap_src_before_dst, "AT_ALIGNED_ONEBUF");

static void BM_string_memset(benchmark::State& state) {
  const size_t nbytes = state.range(0);
  const size_t alignment = state.range(1);

  std::vector<char> buf;
  char* buf_aligned = GetAlignedPtr(&buf, alignment, nbytes + 1);

  while (state.KeepRunning()) {
    memset(buf_aligned, 0, nbytes);
  }

  state.SetBytesProcessed(uint64_t(state.iterations()) * uint64_t(nbytes));
}
BIONIC_BENCHMARK_WITH_ARG(BM_string_memset, "AT_ALIGNED_ONEBUF");

static void BM_string_strlen(benchmark::State& state) {
  const size_t nbytes = state.range(0);
  const size_t alignment = state.range(1);

  std::vector<char> buf;
  char* buf_aligned = GetAlignedPtrFilled(&buf, alignment, nbytes + 1, 'x');
  buf_aligned[nbytes - 1] = '\0';

  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(strlen(buf_aligned));
  }

  state.SetBytesProcessed(uint64_t(state.iterations()) * uint64_t(nbytes));
}
BIONIC_BENCHMARK_WITH_ARG(BM_string_strlen, "AT_ALIGNED_ONEBUF");

static void BM_string_strcat_copy_only(benchmark::State& state) {
  const size_t nbytes = state.range(0);
  const size_t src_alignment = state.range(1);
  const size_t dst_alignment = state.range(2);

  std::vector<char> src;
  std::vector<char> dst;
  char* src_aligned = GetAlignedPtrFilled(&src, src_alignment, nbytes, 'x');
  char* dst_aligned = GetAlignedPtr(&dst, dst_alignment, nbytes + 2);
  src_aligned[nbytes - 1] = '\0';
  dst_aligned[0] = 'y';
  dst_aligned[1] = 'y';
  dst_aligned[2] = '\0';

  while (state.KeepRunning()) {
    strcat(dst_aligned, src_aligned);
    dst_aligned[2] = '\0';
  }

  state.SetBytesProcessed(uint64_t(state.iterations()) * uint64_t(nbytes));
}
BIONIC_BENCHMARK_WITH_ARG(BM_string_strcat_copy_only, "AT_ALIGNED_TWOBUF");

static void BM_string_strcat_seek_only(benchmark::State& state) {
  const size_t nbytes = state.range(0);
  const size_t src_alignment = state.range(1);
  const size_t dst_alignment = state.range(2);

  std::vector<char> src;
  std::vector<char> dst;
  char* src_aligned = GetAlignedPtrFilled(&src, src_alignment, 3, 'x');
  char* dst_aligned = GetAlignedPtrFilled(&dst, dst_alignment, nbytes + 2, 'y');
  src_aligned[2] = '\0';
  dst_aligned[nbytes - 1] = '\0';

  while (state.KeepRunning()) {
    strcat(dst_aligned, src_aligned);
    dst_aligned[nbytes - 1] = '\0';
  }

  state.SetBytesProcessed(uint64_t(state.iterations()) * uint64_t(nbytes));
}
BIONIC_BENCHMARK_WITH_ARG(BM_string_strcat_seek_only, "AT_ALIGNED_TWOBUF");

static void BM_string_strcat_half_copy_half_seek(benchmark::State& state) {
  const size_t nbytes = state.range(0);
  const size_t src_alignment = state.range(1);
  const size_t dst_alignment = state.range(2);

  // Skip sizes that don't make sense.
  if ((nbytes / 2) == 0) {
    return;
  }

  std::vector<char> src;
  std::vector<char> dst;
  char* src_aligned = GetAlignedPtrFilled(&src, src_alignment, nbytes / 2, 'x');
  char* dst_aligned = GetAlignedPtrFilled(&dst, dst_alignment, nbytes, 'y');
  src_aligned[nbytes / 2 - 1] = '\0';
  dst_aligned[nbytes / 2 - 1] = '\0';

  while (state.KeepRunning()) {
    strcat(dst_aligned, src_aligned);
    dst_aligned[nbytes / 2 - 1] = '\0';
  }

  state.SetBytesProcessed(uint64_t(state.iterations()) * uint64_t(nbytes));
}
BIONIC_BENCHMARK_WITH_ARG(BM_string_strcat_half_copy_half_seek, "AT_ALIGNED_TWOBUF");

static void BM_string_strcpy(benchmark::State& state) {
  const size_t nbytes = state.range(0);
  const size_t src_alignment = state.range(1);
  const size_t dst_alignment = state.range(2);

  std::vector<char> src;
  std::vector<char> dst;
  char* src_aligned = GetAlignedPtrFilled(&src, src_alignment, nbytes, 'x');
  char* dst_aligned = GetAlignedPtr(&dst, dst_alignment, nbytes);
  src_aligned[nbytes - 1] = '\0';

  while (state.KeepRunning()) {
    strcpy(dst_aligned, src_aligned);
  }

  state.SetBytesProcessed(uint64_t(state.iterations()) * uint64_t(nbytes));
}
BIONIC_BENCHMARK_WITH_ARG(BM_string_strcpy, "AT_ALIGNED_TWOBUF");

static void BM_string_strcmp(benchmark::State& state) {
  const size_t nbytes = state.range(0);
  const size_t s1_alignment = state.range(1);
  const size_t s2_alignment = state.range(2);

  std::vector<char> s1;
  std::vector<char> s2;
  char* s1_aligned = GetAlignedPtrFilled(&s1, s1_alignment, nbytes, 'x');
  char* s2_aligned = GetAlignedPtrFilled(&s2, s2_alignment, nbytes, 'x');
  s1_aligned[nbytes - 1] = '\0';
  s2_aligned[nbytes - 1] = '\0';

  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(strcmp(s1_aligned, s2_aligned));
  }

  state.SetBytesProcessed(uint64_t(state.iterations()) * uint64_t(nbytes));
}
BIONIC_BENCHMARK_WITH_ARG(BM_string_strcmp, "AT_ALIGNED_TWOBUF");

static void BM_string_strncmp(benchmark::State& state) {
  const size_t nbytes = state.range(0);
  const size_t s1_alignment = state.range(1);
  const size_t s2_alignment = state.range(2);

  std::vector<char> s1;
  std::vector<char> s2;
  char* s1_aligned = GetAlignedPtrFilled(&s1, s1_alignment, nbytes, 'x');
  char* s2_aligned = GetAlignedPtrFilled(&s2, s2_alignment, nbytes, 'x');

  for (auto _ : state) {
    benchmark::DoNotOptimize(strncmp(s1_aligned, s2_aligned, nbytes));
  }

  state.SetBytesProcessed(uint64_t(state.iterations()) * uint64_t(nbytes));
}
BIONIC_BENCHMARK_WITH_ARG(BM_string_strncmp, "AT_ALIGNED_TWOBUF");

static void BM_string_strstr(benchmark::State& state) {
  const size_t nbytes = state.range(0);
  const size_t haystack_alignment = state.range(1);
  const size_t needle_alignment = state.range(2);

  std::vector<char> haystack;
  std::vector<char> needle;
  char* haystack_aligned = GetAlignedPtrFilled(&haystack, haystack_alignment, nbytes, 'x');
  char* needle_aligned = GetAlignedPtrFilled(&needle, needle_alignment,
                                             std::min(nbytes, static_cast<size_t>(5)), 'x');

  if (nbytes / 4 > 2) {
    for (size_t i = 0; nbytes / 4 >= 2 && i < nbytes / 4 - 2; i++) {
      haystack_aligned[4 * i + 3] = 'y';
    }
  }
  haystack_aligned[nbytes - 1] = '\0';
  needle_aligned[needle.size() - 1] = '\0';

  while (state.KeepRunning()) {
    if (strstr(haystack_aligned, needle_aligned) == nullptr) {
      errx(1, "ERROR: strstr failed to find valid substring.");
    }
  }

  state.SetBytesProcessed(uint64_t(state.iterations()) * uint64_t(nbytes));
}
BIONIC_BENCHMARK_WITH_ARG(BM_string_strstr, "AT_ALIGNED_TWOBUF");

static void BM_string_strchr(benchmark::State& state) {
  const size_t nbytes = state.range(0);
  const size_t haystack_alignment = state.range(1);

  std::vector<char> haystack;
  char* haystack_aligned = GetAlignedPtrFilled(&haystack, haystack_alignment, nbytes, 'x');
  haystack_aligned[nbytes-1] = '\0';

  while (state.KeepRunning()) {
    if (strchr(haystack_aligned, 'y') != nullptr) {
      errx(1, "ERROR: strchr found a chr where it should have failed.");
    }
  }

  state.SetBytesProcessed(uint64_t(state.iterations()) * uint64_t(nbytes));
}
BIONIC_BENCHMARK_WITH_ARG(BM_string_strchr, "AT_ALIGNED_ONEBUF");
```
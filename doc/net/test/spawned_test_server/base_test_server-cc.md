Response:
Let's break down the thought process for analyzing this C++ code and answering the prompt's questions.

**1. Understanding the Goal:**

The core request is to understand the functionality of `base_test_server.cc` within the Chromium network stack. This includes its purpose, potential interactions with JavaScript, logical reasoning (input/output), common usage errors, and how a user might trigger its use (debugging).

**2. Initial Code Scan and Identification of Key Elements:**

The first step is to quickly read through the code to identify the major components and their roles. I'm looking for:

* **Class Definition:** `BaseTestServer` is the central class.
* **Headers Included:** These give hints about the functionality. `net/base/...`, `net/cert/...`, `url/gurl.h`, `base/files/...`, `base/json/...`, etc., all suggest network testing, file handling, JSON parsing, and URL manipulation.
* **Constructors:** How is the server initialized? The different constructors for `BaseTestServer` and `SSLOptions` are important.
* **Key Methods:** `Start`, `GetURL`, `GetAddressList`, `SetResourcePath`, `GenerateArguments`, etc., point to core functionalities.
* **Data Members:** `type_`, `ssl_options_`, `host_port_pair_`, `document_root_`, `certificates_dir_`, etc., store the server's state.
* **Helper Functions:**  Functions like `GetHostname`, `GetLocalCertificatesDir` provide supporting logic.
* **Error Handling:** Look for `DCHECK`, `LOG(ERROR)`, and return values indicating success/failure.

**3. Determining the Core Functionality:**

Based on the identified elements, the central purpose of `BaseTestServer` is clear: it's a **test server** used for network-related testing within Chromium. It allows simulating various HTTP/HTTPS/WebSocket server behaviors. Specifically, it:

* **Spawns a server:** The name "spawned_test_server" and the `Start` method confirm this.
* **Handles different protocols:**  The `Type` enum and logic around SSL options indicate support for HTTP, HTTPS, WS, and WSS.
* **Manages SSL/TLS:** The `SSLOptions` struct allows configuring server certificates for testing different scenarios (valid, expired, mismatched names, etc.).
* **Serves files:** `document_root_` suggests serving static content.
* **Provides URLs:**  `GetURL` methods construct URLs for accessing the server.
* **Configures server behavior:** Methods like `SetResourcePath` and `GenerateArguments` allow customizing the server's setup.

**4. Addressing the JavaScript Relationship:**

Now, I need to consider how this *C++ test server* relates to JavaScript. The key connection is that JavaScript code running within a Chromium browser (or a test environment simulating a browser) will likely *interact* with this server during testing. JavaScript can:

* **Fetch resources:**  `fetch()` or `XMLHttpRequest` in JavaScript can make requests to URLs provided by `BaseTestServer`.
* **Establish WebSocket connections:** JavaScript can use the `WebSocket` API to connect to WS/WSS servers created by `BaseTestServer`.
* **Simulate user interactions:** Test frameworks might use JavaScript to trigger actions that cause the browser to make network requests to the test server.

**Example Construction:** To illustrate the JavaScript relationship, I'll create a simple scenario: a JavaScript `fetch` request to a URL generated by `BaseTestServer`. This will show the direct interaction.

**5. Logical Reasoning (Input/Output):**

For this, I need to pick a specific method and think about what input it takes and what output it produces. `GetURL` is a good candidate because it's straightforward.

* **Input:** A path string.
* **Assumptions:** The server has been started and `host_port_pair_` is initialized.
* **Output:** A `GURL` object representing the full URL.

I can then create a simple example with a hypothetical path and demonstrate the resulting URL.

**6. Common Usage Errors:**

I'll think about common mistakes developers might make when using this class:

* **Forgetting to start the server:**  Trying to get the URL before starting the server will lead to errors.
* **Incorrect path:**  Providing a path that doesn't exist on the server.
* **SSL certificate issues:**  Mismatched SSL configurations or not loading test certificates properly.

I can then create examples of these scenarios and describe the expected outcome.

**7. Debugging Clues (User Operations):**

Here, I need to connect user actions in the browser to the test server's involvement. I'll consider scenarios where network requests are made:

* **Navigating to a URL:** Typing an address in the address bar.
* **Clicking a link:**  Following a hyperlink.
* **Submitting a form:** Sending data to a server.
* **JavaScript making requests:**  `fetch`, `XMLHttpRequest`, `WebSocket`.

I'll then explain how these actions, in a testing context, might lead to interaction with `BaseTestServer` and provide steps for debugging (e.g., network panel in DevTools).

**8. Structuring the Answer:**

Finally, I'll organize the information into the requested categories:

* **Functionality:** A concise summary of the class's purpose and key features.
* **JavaScript Relationship:** Explain how JavaScript interacts with the server, providing concrete examples.
* **Logical Reasoning:** Present a specific method, assumptions, input, and output.
* **Common Usage Errors:** List potential mistakes with examples.
* **Debugging Clues:** Describe user actions and how they relate to the test server, offering debugging tips.

**Self-Correction/Refinement:**

During this process, I might realize I need to go back and look at the code more carefully. For example, I might initially focus too much on just HTTP and then realize the code also handles WebSockets. I'd then adjust my explanations accordingly. Similarly, if I can't immediately think of a JavaScript example, I'd revisit the code to see what kind of server behaviors it supports and then connect that to corresponding JavaScript APIs. The key is to iterate and refine the understanding based on the code details.
`net/test/spawned_test_server/base_test_server.cc` 是 Chromium 网络栈中用于创建和管理测试服务器的基础类。它的主要功能是：

**功能列表:**

1. **启动和停止测试服务器:**
   - 提供 `Start()` 和相关方法来启动一个在后台运行的测试服务器。
   - 提供方法来阻塞直到服务器成功启动 (`BlockUntilStarted()`).
   - 提供方法在服务器停止时进行清理 (`CleanUpWhenStoppingServer()`).

2. **管理服务器地址和端口:**
   - 允许指定服务器监听的主机名（默认为 "127.0.0.1" 或 "localhost" 对于 SSL 测试）。
   - 自动选择一个可用的端口，或者允许设置指定的端口。
   - 提供方法获取服务器的 `HostPortPair` (`host_port_pair()`).
   - 提供方法获取服务器的端口号 (`GetPort()`).
   - 提供方法设置服务器的端口号 (`SetPort()`).

3. **生成测试 URL:**
   - 提供多种方法根据不同的需求生成测试 URL (`GetURL()`, `GetURLWithUser()`, `GetURLWithUserAndPassword()`).
   - 支持生成带有用户认证信息的 URL。

4. **支持不同的协议:**
   - 通过 `Type` 枚举支持创建不同的测试服务器类型，例如 HTTP, HTTPS, WebSocket (WS), Secure WebSocket (WSS)。

5. **SSL/TLS 配置:**
   - 通过 `SSLOptions` 结构体支持配置 HTTPS 服务器的 SSL 证书。
   - 可以使用预定义的证书 (`CERT_OK`, `CERT_MISMATCHED_NAME`, `CERT_EXPIRED` 等) 或者自定义证书文件。
   - 支持配置客户端证书认证。

6. **文件服务:**
   - 允许设置服务器的文档根目录 (`SetResourcePath()`)，用于提供静态文件服务。

7. **动态路径替换:**
   - 提供 `GetFilePathWithReplacements()` 方法，允许在请求路径中动态替换文本，这在测试中模拟各种参数组合很有用。

8. **日志记录:**
   - 包含用于调试的日志记录功能 (`VLOG`, `LOG`)。

9. **与测试证书集成:**
   - 提供加载和注册测试根证书的功能 (`LoadTestRootCert()`, `RegisterTestCerts()`)，方便 HTTPS 测试。

10. **生成服务器启动参数:**
    - 提供 `GenerateArguments()` 方法，生成启动服务器进程所需的命令行参数。这些参数包括主机、端口、数据目录、证书文件等。

**与 JavaScript 的关系及举例说明:**

`BaseTestServer` 本身是用 C++ 编写的，并不直接执行 JavaScript 代码。然而，它在 Chromium 的网络栈测试中扮演着关键角色，而这些测试经常涉及到与网页（包含 JavaScript）的交互。

**举例说明:**

假设有一个 JavaScript 代码需要从一个 HTTPS 服务器获取数据：

```javascript
fetch('https://127.0.0.1:<动态端口>/data.json')
  .then(response => response.json())
  .then(data => console.log(data));
```

为了测试这段 JavaScript 代码，可以使用 `BaseTestServer` 启动一个本地 HTTPS 服务器，并配置相应的路由来响应 `/data.json` 请求。

**具体步骤 (C++ 代码中使用 `BaseTestServer`):**

```c++
#include "net/test/spawned_test_server/base_test_server.h"
#include "net/test/embedded_test_server/embedded_test_server.h" // 或者其他更具体的服务器实现
#include "testing/gtest/include/gtest/gtest.h"

namespace net {

TEST(MyNetworkTest, FetchData) {
  // 创建一个 HTTPS 测试服务器
  net::EmbeddedTestServer server(net::EmbeddedTestServer::TYPE_HTTPS);

  // 设置服务器的文档根目录，或者添加自定义的请求处理器
  server.RegisterRequestHandler([](const net::HttpRequest& request) {
    if (request.relative_url == "/data.json") {
      net::test_server::HttpResponse::Builder builder;
      builder.SetBody("{\"message\": \"Hello from test server\"}");
      builder.AddCustomHeader("Content-Type", "application/json");
      return builder.Build();
    }
    return std::make_unique<net::test_server::BasicHttpResponse>(
        net::HttpStatusCode::HTTP_404_NOT_FOUND);
  });

  ASSERT_TRUE(server.Start());

  // 获取服务器的 URL
  GURL data_url = server.GetURL("/data.json");

  // 在测试中使用 data_url 去驱动 JavaScript 代码的执行
  // 例如，通过 content::WebContents 执行 JavaScript 代码，并验证结果
  // ... (此处省略具体的 JavaScript 执行和结果验证代码)

  server.Stop();
}

} // namespace net
```

在这个例子中，`BaseTestServer`（通常通过更具体的子类如 `EmbeddedTestServer` 使用）为 JavaScript 代码提供了一个实际的网络环境，使得可以测试 JavaScript 的网络请求逻辑。

**逻辑推理 (假设输入与输出):**

**假设输入:**

1. 创建一个 `BaseTestServer` 实例，类型为 `TYPE_HTTP`。
2. 调用 `Start()` 方法启动服务器。

**输出:**

1. 服务器成功启动，并监听在一个可用的端口上。
2. 可以通过 `GetURL("/some/path")` 获取到类似于 `http://127.0.0.1:<动态端口>/some/path` 的 URL。
3. 可以通过浏览器或网络请求工具访问该 URL，如果服务器配置了相应的处理器或文件，则会得到相应的响应。

**假设输入 (SSL 场景):**

1. 创建一个 `BaseTestServer` 实例，类型为 `TYPE_HTTPS`，并指定使用 `CERT_OK` 证书。
2. 调用 `Start()` 方法启动服务器。

**输出:**

1. 服务器成功启动，并监听在一个可用的端口上，使用预定义的有效 SSL 证书。
2. 可以通过 `GetURL("/secure/data")` 获取到类似于 `https://127.0.0.1:<动态端口>/secure/data` 的 URL。
3. 使用支持 HTTPS 的客户端访问该 URL，连接应该成功建立，没有证书错误。

**涉及用户或者编程常见的使用错误，请举例说明:**

1. **忘记调用 `Start()`:**
   - 错误示例: 创建了 `BaseTestServer` 对象后，直接调用 `GetURL()` 尝试获取 URL。
   - 结果: `host_port_pair_` 还没有被初始化，可能导致程序崩溃或者返回不正确的 URL。

2. **端口冲突:**
   - 错误示例: 在另一个进程已经占用了某个端口的情况下，尝试启动 `BaseTestServer` 并使用该端口。
   - 结果: `Start()` 方法可能会失败，因为无法绑定到指定的端口。

3. **SSL 证书配置错误:**
   - 错误示例: 创建 HTTPS 服务器时，指定了不存在的证书文件路径。
   - 结果: `Start()` 方法可能会失败，因为无法加载 SSL 证书。

4. **在服务器启动前获取端口:**
   - 错误示例: 在调用 `Start()` 之前，尝试调用 `GetPort()` 获取端口号。
   - 结果: 端口号在服务器启动时才会确定，此时获取到的值可能是 0 或者未定义。

**说明用户操作是如何一步步的到达这里，作为调试线索:**

`BaseTestServer` 通常不会被最终用户直接操作。它主要用于 Chromium 开发者的网络栈测试。以下是一些可能的操作路径，最终会间接地涉及到 `BaseTestServer` 的使用：

1. **开发者编写网络功能相关的单元测试:**
   - 开发者需要测试 Chromium 网络栈的某个功能，例如 HTTP 请求、WebSocket 连接、SSL 处理等。
   - 他们会编写 C++ 单元测试，使用 `BaseTestServer` 或其子类（如 `EmbeddedTestServer`）来模拟服务器行为。
   - 测试代码会创建 `BaseTestServer` 实例，配置服务器的行为（例如，响应特定的 URL），然后启动服务器。
   - 测试代码会使用 Chromium 的网络 API（例如 `URLLoader`）向测试服务器发送请求，并验证服务器的响应是否符合预期。

2. **开发者运行网络相关的集成测试:**
   - 更高层次的集成测试可能涉及到多个组件的交互，包括渲染进程、网络进程等。
   - 这些测试可能会启动一个真实的浏览器实例或者一个模拟的浏览器环境。
   - 在测试过程中，JavaScript 代码可能会发起网络请求。
   - 底层测试框架会使用 `BaseTestServer` 或类似的机制来提供测试所需的服务器环境。

3. **开发者调试网络相关问题:**
   - 当 Chromium 的网络功能出现 bug 时，开发者可能会编写或运行一些特定的测试用例来重现问题。
   - 这些测试用例很可能会用到 `BaseTestServer` 来创建一个可控的网络环境，方便开发者隔离和分析问题。
   - 调试时，开发者可能会查看 `BaseTestServer` 的日志输出，或者在 `BaseTestServer` 的相关代码中设置断点，来理解服务器的行为。

**调试线索:**

如果开发者在调试网络相关的问题，并怀疑是服务器端的问题，他们可能会：

1. **查看测试代码:** 确定是否使用了 `BaseTestServer`，以及如何配置的。
2. **检查服务器日志:** `BaseTestServer` 可以配置为输出日志到控制台，这些日志可以帮助理解服务器收到了哪些请求，以及如何响应的。
3. **在 `BaseTestServer` 相关代码中设置断点:** 如果需要深入了解服务器的运行逻辑，可以在 `Start()`, 请求处理函数等关键位置设置断点。
4. **使用网络抓包工具:** 例如 Wireshark，来观察客户端和测试服务器之间的网络通信，验证请求和响应是否符合预期。
5. **修改测试服务器的行为:**  为了隔离问题，开发者可能会修改测试服务器的代码，例如修改响应头、响应体等，来观察客户端的行为变化。

总而言之，`net/test/spawned_test_server/base_test_server.cc` 是 Chromium 网络栈测试的重要基础设施，它为各种网络相关的测试提供了一个可配置、可控的本地测试服务器环境。虽然最终用户不会直接接触它，但它是保证 Chromium 网络功能稳定性和正确性的基石。

### 提示词
```
这是目录为net/test/spawned_test_server/base_test_server.cc的chromium 网络栈的源代码文件， 请列举一下它的功能, 
如果它与javascript的功能有关系，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索。
```

### 源代码
```cpp
// Copyright 2013 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "net/test/spawned_test_server/base_test_server.h"

#include <stdint.h>
#include <limits>
#include <memory>
#include <string>
#include <utility>
#include <vector>

#include "base/base64.h"
#include "base/files/file_util.h"
#include "base/json/json_reader.h"
#include "base/logging.h"
#include "base/notreached.h"
#include "base/path_service.h"
#include "base/strings/string_util.h"
#include "base/values.h"
#include "net/base/address_list.h"
#include "net/base/host_port_pair.h"
#include "net/base/net_errors.h"
#include "net/base/network_isolation_key.h"
#include "net/base/port_util.h"
#include "net/cert/x509_certificate.h"
#include "net/dns/public/dns_query_type.h"
#include "net/log/net_log_with_source.h"
#include "net/test/cert_test_util.h"
#include "net/test/test_data_directory.h"
#include "url/gurl.h"

namespace net {

namespace {

std::string GetHostname(BaseTestServer::Type type,
                        const BaseTestServer::SSLOptions& options) {
  if (BaseTestServer::UsingSSL(type)) {
    if (options.server_certificate ==
            BaseTestServer::SSLOptions::CERT_MISMATCHED_NAME ||
        options.server_certificate ==
            BaseTestServer::SSLOptions::CERT_COMMON_NAME_IS_DOMAIN) {
      // For |CERT_MISMATCHED_NAME|, return a different hostname string
      // that resolves to the same hostname. For
      // |CERT_COMMON_NAME_IS_DOMAIN|, the certificate is issued for
      // "localhost" instead of "127.0.0.1".
      return "localhost";
    }
  }

  return "127.0.0.1";
}

bool GetLocalCertificatesDir(const base::FilePath& certificates_dir,
                             base::FilePath* local_certificates_dir) {
  if (certificates_dir.IsAbsolute()) {
    *local_certificates_dir = certificates_dir;
    return true;
  }

  base::FilePath src_dir;
  if (!base::PathService::Get(base::DIR_SRC_TEST_DATA_ROOT, &src_dir)) {
    return false;
  }

  *local_certificates_dir = src_dir.Append(certificates_dir);
  return true;
}

}  // namespace

BaseTestServer::SSLOptions::SSLOptions() = default;
BaseTestServer::SSLOptions::SSLOptions(ServerCertificate cert)
    : server_certificate(cert) {}
BaseTestServer::SSLOptions::SSLOptions(base::FilePath cert)
    : custom_certificate(std::move(cert)) {}
BaseTestServer::SSLOptions::SSLOptions(const SSLOptions& other) = default;

BaseTestServer::SSLOptions::~SSLOptions() = default;

base::FilePath BaseTestServer::SSLOptions::GetCertificateFile() const {
  if (!custom_certificate.empty())
    return custom_certificate;

  switch (server_certificate) {
    case CERT_OK:
    case CERT_MISMATCHED_NAME:
      return base::FilePath(FILE_PATH_LITERAL("ok_cert.pem"));
    case CERT_COMMON_NAME_IS_DOMAIN:
      return base::FilePath(FILE_PATH_LITERAL("localhost_cert.pem"));
    case CERT_EXPIRED:
      return base::FilePath(FILE_PATH_LITERAL("expired_cert.pem"));
    case CERT_CHAIN_WRONG_ROOT:
      // This chain uses its own dedicated test root certificate to avoid
      // side-effects that may affect testing.
      return base::FilePath(FILE_PATH_LITERAL("redundant-server-chain.pem"));
    case CERT_BAD_VALIDITY:
      return base::FilePath(FILE_PATH_LITERAL("bad_validity.pem"));
    case CERT_KEY_USAGE_RSA_ENCIPHERMENT:
      return base::FilePath(
          FILE_PATH_LITERAL("key_usage_rsa_keyencipherment.pem"));
    case CERT_KEY_USAGE_RSA_DIGITAL_SIGNATURE:
      return base::FilePath(
          FILE_PATH_LITERAL("key_usage_rsa_digitalsignature.pem"));
    case CERT_TEST_NAMES:
      return base::FilePath(FILE_PATH_LITERAL("test_names.pem"));
    default:
      NOTREACHED();
  }
}

BaseTestServer::BaseTestServer(Type type) : type_(type) {
  Init(GetHostname(type, ssl_options_));
}

BaseTestServer::BaseTestServer(Type type, const SSLOptions& ssl_options)
    : ssl_options_(ssl_options), type_(type) {
  DCHECK(UsingSSL(type));
  Init(GetHostname(type, ssl_options));
}

BaseTestServer::~BaseTestServer() = default;

bool BaseTestServer::Start() {
  return StartInBackground() && BlockUntilStarted();
}

const HostPortPair& BaseTestServer::host_port_pair() const {
  DCHECK(started_);
  return host_port_pair_;
}

std::string BaseTestServer::GetScheme() const {
  switch (type_) {
    case TYPE_WS:
      return "ws";
    case TYPE_WSS:
      return "wss";
    default:
      NOTREACHED();
  }
}

bool BaseTestServer::GetAddressList(AddressList* address_list) const {
  // Historically, this function did a DNS lookup because `host_port_pair_`
  // could specify something other than localhost. Now it is always localhost.
  DCHECK(host_port_pair_.host() == "127.0.0.1" ||
         host_port_pair_.host() == "localhost");
  DCHECK(address_list);
  *address_list = AddressList(
      IPEndPoint(IPAddress::IPv4Localhost(), host_port_pair_.port()));
  return true;
}

uint16_t BaseTestServer::GetPort() {
  return host_port_pair_.port();
}

void BaseTestServer::SetPort(uint16_t port) {
  host_port_pair_.set_port(port);
}

GURL BaseTestServer::GetURL(const std::string& path) const {
  return GURL(GetScheme() + "://" + host_port_pair_.ToString() + "/" + path);
}

GURL BaseTestServer::GetURL(const std::string& hostname,
                            const std::string& relative_url) const {
  GURL local_url = GetURL(relative_url);
  GURL::Replacements replace_host;
  replace_host.SetHostStr(hostname);
  return local_url.ReplaceComponents(replace_host);
}

GURL BaseTestServer::GetURLWithUser(const std::string& path,
                                const std::string& user) const {
  return GURL(GetScheme() + "://" + user + "@" + host_port_pair_.ToString() +
              "/" + path);
}

GURL BaseTestServer::GetURLWithUserAndPassword(const std::string& path,
                                           const std::string& user,
                                           const std::string& password) const {
  return GURL(GetScheme() + "://" + user + ":" + password + "@" +
              host_port_pair_.ToString() + "/" + path);
}

// static
bool BaseTestServer::GetFilePathWithReplacements(
    const std::string& original_file_path,
    const std::vector<StringPair>& text_to_replace,
    std::string* replacement_path) {
  std::string new_file_path = original_file_path;
  bool first_query_parameter = true;
  const std::vector<StringPair>::const_iterator end = text_to_replace.end();
  for (auto it = text_to_replace.begin(); it != end; ++it) {
    const std::string& old_text = it->first;
    const std::string& new_text = it->second;
    std::string base64_old = base::Base64Encode(old_text);
    std::string base64_new = base::Base64Encode(new_text);
    if (first_query_parameter) {
      new_file_path += "?";
      first_query_parameter = false;
    } else {
      new_file_path += "&";
    }
    new_file_path += "replace_text=";
    new_file_path += base64_old;
    new_file_path += ":";
    new_file_path += base64_new;
  }

  *replacement_path = new_file_path;
  return true;
}

ScopedTestRoot BaseTestServer::RegisterTestCerts() {
  auto root = ImportCertFromFile(GetTestCertsDirectory(), "root_ca_cert.pem");
  if (!root)
    return ScopedTestRoot();
  return ScopedTestRoot(CertificateList{root});
}

bool BaseTestServer::LoadTestRootCert() {
  scoped_test_root_ = RegisterTestCerts();
  return !scoped_test_root_.IsEmpty();
}

scoped_refptr<X509Certificate> BaseTestServer::GetCertificate() const {
  base::FilePath certificate_path;
  if (!GetLocalCertificatesDir(certificates_dir_, &certificate_path))
    return nullptr;

  base::FilePath certificate_file(ssl_options_.GetCertificateFile());
  if (certificate_file.value().empty())
    return nullptr;

  certificate_path = certificate_path.Append(certificate_file);

  std::string cert_data;
  if (!base::ReadFileToString(certificate_path, &cert_data))
    return nullptr;

  CertificateList certs_in_file =
      X509Certificate::CreateCertificateListFromBytes(
          base::as_byte_span(cert_data),
          X509Certificate::FORMAT_PEM_CERT_SEQUENCE);
  if (certs_in_file.empty())
    return nullptr;
  return certs_in_file[0];
}

void BaseTestServer::Init(const std::string& host) {
  host_port_pair_ = HostPortPair(host, 0);

  // TODO(battre) Remove this after figuring out why the TestServer is flaky.
  // http://crbug.com/96594
  log_to_console_ = true;
}

void BaseTestServer::SetResourcePath(const base::FilePath& document_root,
                                     const base::FilePath& certificates_dir) {
  // This method shouldn't get called twice.
  DCHECK(certificates_dir_.empty());
  document_root_ = document_root;
  certificates_dir_ = certificates_dir;
  DCHECK(!certificates_dir_.empty());
}

bool BaseTestServer::SetAndParseServerData(const std::string& server_data,
                                           int* port) {
  VLOG(1) << "Server data: " << server_data;
  auto parsed_json = base::JSONReader::ReadAndReturnValueWithError(server_data);
  if (!parsed_json.has_value()) {
    LOG(ERROR) << "Could not parse server data: "
               << parsed_json.error().message;
    return false;
  } else if (!parsed_json->is_dict()) {
    LOG(ERROR) << "Could not parse server data: expecting a dictionary";
    return false;
  }

  std::optional<int> port_value = parsed_json->GetDict().FindInt("port");
  if (!port_value) {
    LOG(ERROR) << "Could not find port value";
    return false;
  }

  *port = *port_value;
  if ((*port <= 0) || (*port > std::numeric_limits<uint16_t>::max())) {
    LOG(ERROR) << "Invalid port value: " << port;
    return false;
  }

  return true;
}

bool BaseTestServer::SetupWhenServerStarted() {
  DCHECK(host_port_pair_.port());
  DCHECK(!started_);

  if (UsingSSL(type_) && !LoadTestRootCert()) {
    LOG(ERROR) << "Could not load test root certificate.";
    return false;
  }

  started_ = true;
  allowed_port_ = std::make_unique<ScopedPortException>(host_port_pair_.port());
  return true;
}

void BaseTestServer::CleanUpWhenStoppingServer() {
  scoped_test_root_.Reset({});
  host_port_pair_.set_port(0);
  allowed_port_.reset();
  started_ = false;
}

std::optional<base::Value::Dict> BaseTestServer::GenerateArguments() const {
  base::Value::Dict arguments;
  arguments.Set("host", host_port_pair_.host());
  arguments.Set("port", host_port_pair_.port());
  arguments.Set("data-dir", document_root_.AsUTF8Unsafe());

  if (VLOG_IS_ON(1) || log_to_console_)
    arguments.Set("log-to-console", base::Value());

  if (ws_basic_auth_) {
    DCHECK(type_ == TYPE_WS || type_ == TYPE_WSS);
    arguments.Set("ws-basic-auth", base::Value());
  }

  if (redirect_connect_to_localhost_) {
    DCHECK(type_ == TYPE_BASIC_AUTH_PROXY || type_ == TYPE_PROXY);
    arguments.Set("redirect-connect-to-localhost", base::Value());
  }

  if (UsingSSL(type_)) {
    // Check the certificate arguments of the HTTPS server.
    base::FilePath certificate_path(certificates_dir_);
    base::FilePath certificate_file(ssl_options_.GetCertificateFile());
    if (!certificate_file.value().empty()) {
      certificate_path = certificate_path.Append(certificate_file);
      if (certificate_path.IsAbsolute() &&
          !base::PathExists(certificate_path)) {
        LOG(ERROR) << "Certificate path " << certificate_path.value()
                   << " doesn't exist. Can't launch https server.";
        return std::nullopt;
      }
      arguments.Set("cert-and-key-file", certificate_path.AsUTF8Unsafe());
    }

    // Check the client certificate related arguments.
    if (ssl_options_.request_client_certificate)
      arguments.Set("ssl-client-auth", base::Value());

    base::Value::List ssl_client_certs;

    std::vector<base::FilePath>::const_iterator it;
    for (it = ssl_options_.client_authorities.begin();
         it != ssl_options_.client_authorities.end(); ++it) {
      if (it->IsAbsolute() && !base::PathExists(*it)) {
        LOG(ERROR) << "Client authority path " << it->value()
                   << " doesn't exist. Can't launch https server.";
        return std::nullopt;
      }
      ssl_client_certs.Append(it->AsUTF8Unsafe());
    }

    if (ssl_client_certs.size()) {
      arguments.Set("ssl-client-ca", std::move(ssl_client_certs));
    }
  }

  return std::make_optional(std::move(arguments));
}

}  // namespace net
```
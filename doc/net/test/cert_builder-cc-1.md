Response:
The user wants to understand the functionality of the provided C++ code snippet, which is a part of the `net/test/cert_builder.cc` file in the Chromium project. They are particularly interested in:

1. **Overall Functionality**: A summary of what this code does.
2. **Relation to JavaScript**:  If and how this C++ code interacts with JavaScript.
3. **Logical Reasoning (with examples)**: How the functions work with specific inputs and outputs.
4. **Common Usage Errors**: Potential mistakes developers might make when using this code.
5. **Debugging**: How a user might end up interacting with this code during debugging.
6. **Summary of Functionality (Part 2)**: A concise description of the functionality covered in this specific code block.

Let's break down the code and address each point:

**1. Overall Functionality (considering the previous part as well):**

Based on the provided code and the context from Part 1, the `CertBuilder` class is designed to facilitate the creation of X.509 certificates for testing purposes within the Chromium network stack. It provides a fluent interface to set various attributes of a certificate (like subject, validity, public key, extensions, etc.) and then generates the actual certificate in DER or PEM format. It also supports building certificate chains.

**2. Relation to JavaScript:**

This C++ code is part of the Chromium browser's internal implementation. It's used in the network stack, which handles secure connections (like HTTPS). While JavaScript running in a web page interacts with these secure connections, it doesn't directly interact with the `CertBuilder` class. The certificates generated by this class are used behind the scenes to establish secure connections.

**3. Logical Reasoning (with examples):**

Let's analyze the functions in the provided snippet:

*   **`SetOuterSignatureAlgorithmTLV(std::string_view signature_algorithm_tlv)` and `SetTBSSignatureAlgorithmTLV(std::string_view signature_algorithm_tlv)`**: These functions set the raw ASN.1 representation of the signature algorithm.
    *   **Hypothetical Input**: `signature_algorithm_tlv` could be a string representing the DER encoding of the SHA256 with RSA encryption algorithm.
    *   **Output**: The internal `outer_signature_algorithm_tlv_` or `tbs_signature_algorithm_tlv_` member will be updated with this string. The `Invalidate()` call will mark the existing certificate as outdated, forcing a regeneration if `GetCertBuffer()` is called later.
*   **`SetSerialNumber(uint64_t serial_number)`**: Sets the certificate's serial number.
    *   **Hypothetical Input**: `serial_number = 12345`.
    *   **Output**: The `serial_number_` member will be set to 12345. `Invalidate()` is called.
*   **`SetRandomSerialNumber()`**: Generates a random 64-bit serial number.
    *   **Hypothetical Input**: None (it generates internally).
    *   **Output**: The `serial_number_` member will be set to a randomly generated number. `Invalidate()` is called.
*   **`SetSctConfig(std::vector<CertBuilder::SctConfig> sct_configs)`**: Sets the Signed Certificate Timestamp (SCT) configurations.
    *   **Hypothetical Input**: A vector of `SctConfig` objects, each containing log ID, timestamp, and log key information.
    *   **Output**: The `sct_configs_` member will be updated with the provided vector. `Invalidate()` is called.
*   **`GetCertBuffer()`**: Returns a `CRYPTO_BUFFER` containing the DER-encoded certificate.
    *   **Hypothetical Input**:  If the certificate hasn't been generated yet (`!cert_`), it will call `GenerateCertificate()`.
    *   **Output**: A pointer to a `CRYPTO_BUFFER` holding the certificate data.
*   **`DupCertBuffer()`**: Returns a duplicated `CRYPTO_BUFFER` of the certificate.
    *   **Hypothetical Input**: Calls `GetCertBuffer()`.
    *   **Output**: A unique pointer to a copy of the certificate's `CRYPTO_BUFFER`.
*   **`GetSubject()`**: Returns the certificate's subject in ASN.1 DER format.
    *   **Hypothetical Input**: If `subject_tlv_` is empty, it calls `GenerateSubject()`.
    *   **Output**: A string containing the DER-encoded subject.
*   **`GetSerialNumber()`**: Returns the certificate's serial number.
    *   **Hypothetical Input**: If `serial_number_` is 0, it calls `SetRandomSerialNumber()`.
    *   **Output**: The certificate's serial number.
*   **`GetSubjectKeyIdentifier()`**: Returns the Subject Key Identifier (SKI) extension value.
    *   **Hypothetical Input**: Checks the `extensions_` map for the SKI OID. If present, parses its value.
    *   **Output**: The SKI as a string, or an empty string if not found or parsing fails.
*   **`GetValidity(base::Time* not_before, base::Time* not_after)`**: Retrieves the certificate's validity period.
    *   **Hypothetical Input**: Parses the `validity_tlv_` (ASN.1 DER encoded validity).
    *   **Output**: Returns `true` if parsing succeeds and sets `not_before` and `not_after` accordingly, `false` otherwise.
*   **`GetKey()`**: Returns the certificate's private key.
    *   **Hypothetical Input**: If `key_` is null, it generates a new key based on `default_pkey_id_`.
    *   **Output**: A pointer to the `EVP_PKEY`.
*   **`GetX509Certificate()`**: Creates an `X509Certificate` object from the generated certificate.
    *   **Hypothetical Input**: Calls `DupCertBuffer()`.
    *   **Output**: A `scoped_refptr` to the `X509Certificate`.
*   **`GetX509CertificateChain()`**: Creates an `X509Certificate` object including the intermediate certificates.
    *   **Hypothetical Input**: Traverses the `issuer_` chain.
    *   **Output**: A `scoped_refptr` to the `X509Certificate` with intermediates.
*   **`GetX509CertificateFullChain()`**: Creates an `X509Certificate` object including the full chain (intermediates and root).
    *   **Hypothetical Input**: Traverses the `issuer_` chain until the root.
    *   **Output**: A `scoped_refptr` to the `X509Certificate` with the full chain.
*   **`GetDER()`**: Returns the certificate in DER format as a string.
    *   **Hypothetical Input**: Calls `GetCertBuffer()`.
    *   **Output**: A string containing the DER-encoded certificate.
*   **`GetPEM()`**: Returns the certificate in PEM format as a string.
    *   **Hypothetical Input**: Calls `GetCertBuffer()`.
    *   **Output**: A string containing the PEM-encoded certificate.
*   **`GetPEMFullChain()`**: Returns the full certificate chain in PEM format.
    *   **Hypothetical Input**: Traverses the `issuer_` chain.
    *   **Output**: A string containing the PEM-encoded certificates joined by newlines.
*   **`GetPrivateKeyPEM()`**: Returns the private key in PEM format.
    *   **Hypothetical Input**: Calls `GetKey()`.
    *   **Output**: A string containing the PEM-encoded private key.
*   **`CertBuilder(CRYPTO_BUFFER* orig_cert, CertBuilder* issuer, bool unique_subject_key_identifier)`**: Constructor.
    *   **Hypothetical Input**: A pre-existing certificate (`orig_cert`), an issuer `CertBuilder`, and a boolean indicating whether to generate a unique SKI.
    *   **Output**: Initializes the `CertBuilder` object, potentially copying data from `orig_cert` and setting the issuer.
*   **`Invalidate()`**: Marks the current certificate as invalid, forcing regeneration.
    *   **Hypothetical Input**: None.
    *   **Output**: Sets `cert_` to null.
*   **`GenerateECKey()`**: Generates an Elliptic Curve private key.
    *   **Hypothetical Input**: None.
    *   **Output**: Creates an EC private key and calls `SetKey()`.
*   **`GenerateRSAKey()`**: Generates an RSA private key.
    *   **Hypothetical Input**: None.
    *   **Output**: Creates an RSA private key and calls `SetKey()`.
*   **`UseKeyFromFile(const base::FilePath& key_file)`**: Loads a private key from a PEM file.
    *   **Hypothetical Input**: A `base::FilePath` pointing to a PEM file.
    *   **Output**: If successful, loads the key and calls `SetKey()`, returns `true`. Otherwise, returns `false`.
*   **`SetKey(bssl::UniquePtr<EVP_PKEY> key)`**: Sets the certificate's private key.
    *   **Hypothetical Input**: A unique pointer to an `EVP_PKEY`.
    *   **Output**: Sets the `key_` member and calls `Invalidate()`.
*   **`GenerateSubjectKeyIdentifier()`**: Generates a random Subject Key Identifier.
    *   **Hypothetical Input**: None.
    *   **Output**: Generates a 20-byte random string and calls `SetSubjectKeyIdentifier()`.
*   **`GenerateSubject()`**: Generates a random Common Name for the subject.
    *   **Hypothetical Input**: None.
    *   **Output**: Generates a random hex string and calls `SetSubjectCommonName()`.
*   **`InitFromCert(const bssl::der::Input& cert)`**: Initializes the `CertBuilder` from an existing certificate.
    *   **Hypothetical Input**:  The DER encoding of an existing certificate.
    *   **Output**: Parses the certificate and populates the `CertBuilder`'s internal state.
*   **`BuildTBSCertificate(std::string_view signature_algorithm_tlv, std::string* out)`**: Builds the "To Be Signed" part of the certificate.
    *   **Hypothetical Input**: A signature algorithm TLV and a pointer to a string.
    *   **Output**: Writes the DER-encoded TBS certificate to the output string.
*   **`BuildSctListExtension(const std::string& pre_tbs_certificate, std::string* out)`**: Builds the SCT list extension.
    *   **Hypothetical Input**: The DER-encoded pre-TBS certificate and a pointer to a string.
    *   **Output**: Writes the DER-encoded SCT list extension to the output string.
*   **`GenerateCertificate()`**: Generates the final certificate.
    *   **Hypothetical Input**:  Internal state of the `CertBuilder`.
    *   **Output**: Creates the DER-encoded certificate and stores it in `cert_`.

**4. Common Usage Errors:**

*   **Incorrectly setting the issuer:** Forgetting to set the `issuer_` when building a certificate chain or setting the wrong issuer can lead to invalid certificate chains.
    *   **Example:** Creating an intermediate certificate without setting the root certificate as the issuer.
*   **Mismatched signature algorithms:** Specifying a signature algorithm that doesn't match the key type of the issuer.
    *   **Example:** Trying to sign with an RSA key using an ECDSA signature algorithm.
*   **Forgetting to set necessary extensions:** Some applications or protocols require specific extensions to be present.
    *   **Example:** Creating a certificate for a TLS server without the Subject Alternative Name (SAN) extension.
*   **Not invalidating after changing attributes:** Modifying certificate attributes and expecting the changes to be reflected without calling `Invalidate()` or generating a new certificate.
    *   **Example:** Changing the validity period and then calling `GetDER()` without calling `Invalidate()` first.
*   **Providing malformed TLV data:** Manually setting TLV data for certain fields (like signature algorithms) with incorrect DER encoding.

**5. User Operation to Reach This Code (Debugging Scenario):**

Imagine a developer is working on a feature in Chromium that requires testing secure connections with custom certificates. Here's how they might interact with this code:

1. **Writing a Network Test:** The developer writes a C++ unit test within the Chromium `net/` directory.
2. **Needing a Test Certificate:** The test requires a specific type of certificate (e.g., with a particular extension or validity period).
3. **Using `CertBuilder`:** The developer includes `net/test/cert_builder.h` and uses the `CertBuilder` class to create the necessary test certificate.
    ```c++
    #include "net/test/cert_builder.h"
    #include "testing/gtest/include/gtest/gtest.h"

    namespace net {
    namespace {

    TEST(MySecureConnectionTest, CustomCertificate) {
      CertBuilder builder(PKCS8PrivateKeySource::CreateRSA(2048));
      builder.SetSubjectCommonName("test.example.com");
      base::Time now = base::Time::Now();
      builder.SetValidity(now, now + base::Days(30));
      scoped_refptr<X509Certificate> cert = builder.GetX509Certificate();
      // ... use the certificate in the test ...
    }

    } // namespace
    } // namespace net
    ```
4. **Debugging the Test:** If the test fails, the developer might step through the test code using a debugger (like gdb or lldb).
5. **Stepping into `CertBuilder` methods:**  The debugger will allow the developer to step into the `CertBuilder` methods like `SetSubjectCommonName`, `SetValidity`, `GetX509Certificate`, and potentially even deeper into the certificate generation logic within `GenerateCertificate` and `BuildTBSCertificate`.
6. **Inspecting Internal State:** The developer can inspect the internal state of the `CertBuilder` object (e.g., the `subject_tlv_`, `validity_tlv_`, `extensions_`) to understand how the certificate is being constructed.
7. **Identifying Issues:** By stepping through the code, the developer can identify if the certificate is being built correctly, if extensions are missing, or if there are any errors in the certificate generation process.

**6. Summary of Functionality (Part 2):**

This part of the `CertBuilder` class focuses on:

*   **Setting signature algorithms**: Allowing the specification of signature algorithms for the outer certificate and the TBS (To Be Signed) part.
*   **Setting serial numbers**: Providing methods to set a specific serial number or generate a random one.
*   **Setting SCT configurations**:  Enabling the inclusion of Signed Certificate Timestamps (SCTs) in the certificate.
*   **Retrieving certificate components**: Offering methods to get the raw certificate buffer, subject, serial number, Subject Key Identifier, and validity period.
*   **Accessing keys**: Providing a way to get the private key associated with the certificate.
*   **Creating `X509Certificate` objects**:  Generating `X509Certificate` objects from the built certificate, including support for certificate chains.
*   **Getting certificate in various formats**: Offering methods to retrieve the certificate in DER and PEM formats, including the full chain.
*   **Accessing the private key in PEM format**.
*   **Initialization from an existing certificate**: Allowing the creation of a `CertBuilder` based on a pre-existing certificate.
*   **Marking the certificate as invalid**:  A mechanism to force the regeneration of the certificate after changes.
*   **Key generation**: Providing methods to generate new EC and RSA key pairs.
*   **Loading keys from files**: Enabling the use of existing private keys stored in PEM files.
*   **Generating Subject Key Identifiers and Subjects**:  Convenience methods for setting these common attributes.
*   **Building the TBS certificate and SCT list extension**:  Internal methods used in the certificate generation process.
*   **Generating the final certificate**: The core logic for combining the TBS certificate, signature algorithm, and signature to produce the complete certificate.

这是`net/test/cert_builder.cc` Chromium网络栈源代码文件的第二部分。延续第一部分的功能，这一部分主要负责完成证书构建的剩余步骤以及提供获取构建好的证书及其相关信息的方法。

**功能归纳 (基于提供的代码片段):**

1. **设置签名算法 (Signature Algorithm):**
    *   `SetOuterSignatureAlgorithmTLV`: 允许设置证书外部（整个证书结构）的签名算法的原始 TLV (Tag-Length-Value) 数据。
    *   `SetTBSSignatureAlgorithmTLV`: 允许设置证书 TBS (To Be Signed) 部分的签名算法的原始 TLV 数据。这两个方法主要用于更精细地控制证书的签名结构，通常用于测试特定的签名算法或格式。

2. **设置和获取序列号 (Serial Number):**
    *   `SetSerialNumber`: 设置证书的序列号。
    *   `SetRandomSerialNumber`: 生成一个随机的序列号。
    *   `GetSerialNumber`: 获取证书的序列号，如果尚未设置则生成一个随机的。

3. **设置 SCT 配置 (Signed Certificate Timestamp Configuration):**
    *   `SetSctConfig`: 设置证书的 SCT (Signed Certificate Timestamp) 配置，用于测试证书透明度功能。

4. **获取证书缓冲区 (Certificate Buffer):**
    *   `GetCertBuffer`: 返回包含 DER 编码证书的 `CRYPTO_BUFFER`。如果证书尚未生成，则会先调用 `GenerateCertificate` 生成。
    *   `DupCertBuffer`: 返回一个指向证书缓冲区的拷贝的智能指针。

5. **获取证书主题 (Subject):**
    *   `GetSubject`: 返回证书的主题信息，以 TLV 格式存储。如果尚未生成，则会先调用 `GenerateSubject` 生成。

6. **获取主体密钥标识符 (Subject Key Identifier):**
    *   `GetSubjectKeyIdentifier`: 获取证书的主体密钥标识符 (SKI) 扩展的值。

7. **获取证书有效期 (Validity):**
    *   `GetValidity`: 获取证书的生效时间 (notBefore) 和过期时间 (notAfter)。

8. **获取证书密钥 (Key):**
    *   `GetKey`: 返回证书的私钥。如果尚未生成，则会根据默认的密钥类型生成。

9. **获取 X509 证书对象:**
    *   `GetX509Certificate`: 从生成的证书缓冲区创建一个 `X509Certificate` 对象。
    *   `GetX509CertificateChain`: 创建包含当前证书及其所有中间证书的证书链的 `X509Certificate` 对象。
    *   `GetX509CertificateFullChain`: 创建包含当前证书及其所有中间证书和根证书的完整证书链的 `X509Certificate` 对象。

10. **获取证书的 DER 和 PEM 编码:**
    *   `GetDER`: 获取证书的 DER 编码字符串。
    *   `GetPEM`: 获取证书的 PEM 编码字符串。
    *   `GetPEMFullChain`: 获取包含完整证书链的 PEM 编码字符串，每个证书之间用换行符分隔。
    *   `GetPrivateKeyPEM`: 获取私钥的 PEM 编码字符串。

11. **构造函数:**
    *   `CertBuilder(CRYPTO_BUFFER* orig_cert, CertBuilder* issuer, bool unique_subject_key_identifier)`: 构造函数，可以从现有的证书复制信息，并设置证书的签发者。

12. **使证书失效:**
    *   `Invalidate`: 使当前生成的证书缓冲区失效，下次需要时会重新生成。

13. **生成密钥:**
    *   `GenerateECKey`: 生成一个椭圆曲线 (EC) 私钥。
    *   `GenerateRSAKey`: 生成一个 RSA 私钥。
    *   `UseKeyFromFile`: 从文件中加载私钥。
    *   `SetKey`: 设置证书的私钥。

14. **生成主体密钥标识符和主题:**
    *   `GenerateSubjectKeyIdentifier`: 生成一个随机的主体密钥标识符。
    *   `GenerateSubject`: 生成一个随机的主题名称。

15. **从现有证书初始化:**
    *   `InitFromCert`: 从现有的证书数据初始化 `CertBuilder` 对象。

16. **构建 TBS 证书和 SCT 扩展:**
    *   `BuildTBSCertificate`: 构建证书的 TBS (To Be Signed) 部分。
    *   `BuildSctListExtension`: 构建用于包含 SCT 列表的扩展。

17. **生成证书:**
    *   `GenerateCertificate`: 生成最终的证书，包括构建 TBS 部分、添加签名算法和使用签发者的私钥进行签名。

**与 JavaScript 的关系:**

这段 C++ 代码主要用于 Chromium 内部的网络栈测试，它不直接与 JavaScript 代码交互。但是，由 `CertBuilder` 生成的证书会被 Chromium 用于建立安全的网络连接 (如 HTTPS)。当 JavaScript 代码通过浏览器发起 HTTPS 请求时，底层的 C++ 网络栈会使用类似的机制来验证服务器证书。因此，`CertBuilder` 间接地影响了 JavaScript 在安全环境下的行为。

**逻辑推理与假设输入输出:**

*   **假设输入:** 调用 `SetSerialNumber(12345)`，然后调用 `GetSerialNumber()`。
    *   **输出:** `GetSerialNumber()` 将返回 `12345`。
*   **假设输入:** 首次调用 `GetCertBuffer()`，此前未进行任何设置。
    *   **输出:** `GenerateCertificate()` 将会被调用，生成一个使用默认设置的证书，并返回指向该证书缓冲区的指针。
*   **假设输入:** 调用 `SetSctConfig` 设置了 SCT 配置，然后调用 `GetCertBuffer()`。
    *   **输出:** 生成的证书将会包含 SCT 列表扩展。

**用户或编程常见的使用错误:**

*   **忘记设置签发者 (issuer):** 在构建证书链时，如果忘记设置中间证书的签发者，会导致证书链验证失败。
    *   **示例:** 创建一个 `CertBuilder` 用于中间证书，但没有使用 `SetIssuer` 方法将其签发者设置为根证书的 `CertBuilder` 实例。
*   **签名算法不匹配:** 设置的签名算法与使用的密钥类型不兼容。
    *   **示例:** 使用 RSA 私钥但设置了 ECDSA 的签名算法。
*   **未调用 `Invalidate` 导致更改未生效:** 修改了证书的某些属性后，如果没有调用 `Invalidate`，后续获取证书时可能仍然是旧的版本。
    *   **示例:** 先调用 `SetSerialNumber(1)`，然后调用 `GetCertBuffer()`，再调用 `SetSerialNumber(2)`，再次调用 `GetCertBuffer()`，第二次获取的证书可能仍然是序列号为 1 的证书，除非在设置序列号后调用了 `Invalidate`。

**用户操作到达此处的调试线索:**

作为一个开发者，你可能会在以下情况下逐步到达 `GenerateCertificate` 或其他 `CertBuilder` 的方法：

1. **编写网络测试:** 你正在编写一个涉及 TLS 或其他需要证书认证的网络测试用例。
2. **使用 `CertBuilder` 创建测试证书:** 你使用 `CertBuilder` 类来动态生成用于测试的证书，以模拟各种场景（例如，不同的签名算法、特定的扩展、证书链等）。
3. **调试测试失败:** 你的测试用例失败，怀疑是测试证书的配置问题。
4. **设置断点并单步执行:** 你在 `CertBuilder` 的方法（例如 `GenerateCertificate`、`BuildTBSCertificate`、`SetExtension` 等）中设置断点，然后单步执行代码，查看证书的构建过程和内部状态，以确定哪里出现了错误。
5. **检查变量和调用栈:** 你会查看 `extensions_` 成员变量，确认是否添加了预期的扩展，检查 `signature_algorithm_` 的值是否正确，以及查看调用栈，了解证书构建的流程。

**功能归纳 (第 2 部分):**

总而言之，这部分 `CertBuilder` 的代码主要负责完成证书构建的最后阶段，包括设置签名算法、序列号、SCT 配置，并提供各种方法来获取构建好的证书的二进制数据 (`CRYPTO_BUFFER`, DER, PEM)、结构化对象 (`X509Certificate`) 及其组成部分（主题、有效期、密钥等）。它还提供了从现有证书初始化以及生成不同类型密钥的能力，是 Chromium 网络栈测试中生成和管理测试证书的关键组成部分。

### 提示词
```
这是目录为net/test/cert_builder.cc的chromium 网络栈的源代码文件， 请列举一下它的功能, 
如果它与javascript的功能有关系，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索。
这是第2部分，共2部分，请归纳一下它的功能
```

### 源代码
```cpp
rithmTLV(
    std::string_view signature_algorithm_tlv) {
  outer_signature_algorithm_tlv_ = std::string(signature_algorithm_tlv);
  Invalidate();
}

void CertBuilder::SetTBSSignatureAlgorithmTLV(
    std::string_view signature_algorithm_tlv) {
  tbs_signature_algorithm_tlv_ = std::string(signature_algorithm_tlv);
  Invalidate();
}

void CertBuilder::SetSerialNumber(uint64_t serial_number) {
  serial_number_ = serial_number;
  Invalidate();
}

void CertBuilder::SetRandomSerialNumber() {
  serial_number_ = base::RandUint64();
  Invalidate();
}

void CertBuilder::SetSctConfig(
    std::vector<CertBuilder::SctConfig> sct_configs) {
  sct_configs_ = std::move(sct_configs);
  Invalidate();
}

CRYPTO_BUFFER* CertBuilder::GetCertBuffer() {
  if (!cert_)
    GenerateCertificate();
  return cert_.get();
}

bssl::UniquePtr<CRYPTO_BUFFER> CertBuilder::DupCertBuffer() {
  return bssl::UpRef(GetCertBuffer());
}

const std::string& CertBuilder::GetSubject() {
  if (subject_tlv_.empty())
    GenerateSubject();
  return subject_tlv_;
}

uint64_t CertBuilder::GetSerialNumber() {
  if (!serial_number_)
    serial_number_ = base::RandUint64();
  return serial_number_;
}

std::string CertBuilder::GetSubjectKeyIdentifier() {
  std::string ski_oid =
      bssl::der::Input(bssl::kSubjectKeyIdentifierOid).AsString();
  if (extensions_.find(ski_oid) == extensions_.end()) {
    // If no SKI is present, this means that the certificate was either
    // created by FromStaticCert() and lacked one, or it was explicitly
    // deleted as an extension.
    return std::string();
  }

  auto& extension_value = extensions_[ski_oid];
  bssl::der::Input ski_value;
  if (!bssl::ParseSubjectKeyIdentifier(bssl::der::Input(extension_value.value),
                                       &ski_value)) {
    return std::string();
  }
  return ski_value.AsString();
}

bool CertBuilder::GetValidity(base::Time* not_before,
                              base::Time* not_after) const {
  bssl::der::GeneralizedTime not_before_generalized_time;
  bssl::der::GeneralizedTime not_after_generalized_time;
  if (!bssl::ParseValidity(bssl::der::Input(validity_tlv_),
                           &not_before_generalized_time,
                           &not_after_generalized_time) ||
      !GeneralizedTimeToTime(not_before_generalized_time, not_before) ||
      !GeneralizedTimeToTime(not_after_generalized_time, not_after)) {
    return false;
  }
  return true;
}

EVP_PKEY* CertBuilder::GetKey() {
  if (!key_) {
    switch (default_pkey_id_) {
      case EVP_PKEY_RSA:
        GenerateRSAKey();
        break;
      case EVP_PKEY_EC:
        GenerateECKey();
        break;
    }
  }
  return key_.get();
}

scoped_refptr<X509Certificate> CertBuilder::GetX509Certificate() {
  return X509Certificate::CreateFromBuffer(DupCertBuffer(), {});
}

scoped_refptr<X509Certificate> CertBuilder::GetX509CertificateChain() {
  std::vector<bssl::UniquePtr<CRYPTO_BUFFER>> intermediates;
  // Add intermediates, not including the self-signed root.
  for (CertBuilder* cert = issuer_; cert && cert != cert->issuer_;
       cert = cert->issuer_) {
    intermediates.push_back(cert->DupCertBuffer());
  }
  return X509Certificate::CreateFromBuffer(DupCertBuffer(),
                                           std::move(intermediates));
}

scoped_refptr<X509Certificate> CertBuilder::GetX509CertificateFullChain() {
  std::vector<bssl::UniquePtr<CRYPTO_BUFFER>> intermediates;
  // Add intermediates and the self-signed root.
  for (CertBuilder* cert = issuer_; cert; cert = cert->issuer_) {
    intermediates.push_back(cert->DupCertBuffer());
    if (cert == cert->issuer_)
      break;
  }
  return X509Certificate::CreateFromBuffer(DupCertBuffer(),
                                           std::move(intermediates));
}

std::string CertBuilder::GetDER() {
  return std::string(x509_util::CryptoBufferAsStringPiece(GetCertBuffer()));
}

std::string CertBuilder::GetPEM() {
  std::string pem_encoded;
  EXPECT_TRUE(X509Certificate::GetPEMEncoded(GetCertBuffer(), &pem_encoded));
  return pem_encoded;
}

std::string CertBuilder::GetPEMFullChain() {
  std::vector<std::string> pems;
  CertBuilder* cert = this;
  while (cert) {
    pems.push_back(cert->GetPEM());
    if (cert == cert->issuer_)
      break;
    cert = cert->issuer_;
  }
  return base::JoinString(pems, "\n");
}

std::string CertBuilder::GetPrivateKeyPEM() {
  std::string pem_encoded = key_util::PEMFromPrivateKey(GetKey());
  EXPECT_FALSE(pem_encoded.empty());
  return pem_encoded;
}

CertBuilder::CertBuilder(CRYPTO_BUFFER* orig_cert,
                         CertBuilder* issuer,
                         bool unique_subject_key_identifier)
    : issuer_(issuer) {
  if (!issuer_)
    issuer_ = this;

  if (orig_cert)
    InitFromCert(
        bssl::der::Input(x509_util::CryptoBufferAsStringPiece(orig_cert)));

  if (unique_subject_key_identifier) {
    GenerateSubjectKeyIdentifier();
    SetAuthorityKeyIdentifier(issuer_->GetSubjectKeyIdentifier());
  }
}

void CertBuilder::Invalidate() {
  cert_.reset();
}

void CertBuilder::GenerateECKey() {
  auto private_key = crypto::ECPrivateKey::Create();
  SetKey(bssl::UpRef(private_key->key()));
}

void CertBuilder::GenerateRSAKey() {
  auto private_key = crypto::RSAPrivateKey::Create(2048);
  SetKey(bssl::UpRef(private_key->key()));
}

bool CertBuilder::UseKeyFromFile(const base::FilePath& key_file) {
  bssl::UniquePtr<EVP_PKEY> private_key(
      key_util::LoadEVP_PKEYFromPEM(key_file));
  if (!private_key)
    return false;
  SetKey(std::move(private_key));
  return true;
}

void CertBuilder::SetKey(bssl::UniquePtr<EVP_PKEY> key) {
  key_ = std::move(key);
  Invalidate();
}

void CertBuilder::GenerateSubjectKeyIdentifier() {
  // 20 bytes are chosen here for no other reason than it's compatible with
  // systems that assume the SKI is SHA-1(SPKI), which RFC 5280 notes as one
  // mechanism for generating an SKI, while also noting that random/unique
  // SKIs are also fine.
  std::string random_ski = base::RandBytesAsString(20);
  SetSubjectKeyIdentifier(random_ski);
}

void CertBuilder::GenerateSubject() {
  ASSERT_TRUE(subject_tlv_.empty());

  // Use a random common name comprised of 12 bytes in hex.
  std::string common_name = MakeRandomHexString(12);

  SetSubjectCommonName(common_name);
}

void CertBuilder::InitFromCert(const bssl::der::Input& cert) {
  extensions_.clear();
  Invalidate();

  // From RFC 5280, section 4.1
  //    Certificate  ::=  SEQUENCE  {
  //      tbsCertificate       TBSCertificate,
  //      signatureAlgorithm   AlgorithmIdentifier,
  //      signatureValue       BIT STRING  }

  // TBSCertificate  ::=  SEQUENCE  {
  //      version         [0]  EXPLICIT Version DEFAULT v1,
  //      serialNumber         CertificateSerialNumber,
  //      signature            AlgorithmIdentifier,
  //      issuer               Name,
  //      validity             Validity,
  //      subject              Name,
  //      subjectPublicKeyInfo SubjectPublicKeyInfo,
  //      issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,
  //                           -- If present, version MUST be v2 or v3
  //      subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,
  //                           -- If present, version MUST be v2 or v3
  //      extensions      [3]  EXPLICIT Extensions OPTIONAL
  //                           -- If present, version MUST be v3
  //      }
  bssl::der::Parser parser(cert);
  bssl::der::Parser certificate;
  bssl::der::Parser tbs_certificate;
  ASSERT_TRUE(parser.ReadSequence(&certificate));
  ASSERT_TRUE(certificate.ReadSequence(&tbs_certificate));

  // version
  bool has_version;
  ASSERT_TRUE(tbs_certificate.SkipOptionalTag(
      CBS_ASN1_CONSTRUCTED | CBS_ASN1_CONTEXT_SPECIFIC | 0, &has_version));
  if (has_version) {
    // TODO(mattm): could actually parse the version here instead of assuming
    // V3.
    version_ = bssl::CertificateVersion::V3;
  } else {
    version_ = bssl::CertificateVersion::V1;
  }

  // serialNumber
  ASSERT_TRUE(tbs_certificate.SkipTag(CBS_ASN1_INTEGER));

  // signature
  bssl::der::Input signature_algorithm_tlv;
  ASSERT_TRUE(tbs_certificate.ReadRawTLV(&signature_algorithm_tlv));
  auto signature_algorithm =
      bssl::ParseSignatureAlgorithm(signature_algorithm_tlv);
  ASSERT_TRUE(signature_algorithm);
  signature_algorithm_ = *signature_algorithm;

  // issuer
  ASSERT_TRUE(tbs_certificate.SkipTag(CBS_ASN1_SEQUENCE));

  // validity
  bssl::der::Input validity_tlv;
  ASSERT_TRUE(tbs_certificate.ReadRawTLV(&validity_tlv));
  validity_tlv_ = validity_tlv.AsString();

  // subject
  ASSERT_TRUE(tbs_certificate.SkipTag(CBS_ASN1_SEQUENCE));

  // subjectPublicKeyInfo
  bssl::der::Input spki_tlv;
  ASSERT_TRUE(tbs_certificate.ReadRawTLV(&spki_tlv));
  bssl::UniquePtr<EVP_PKEY> public_key;
  ASSERT_TRUE(bssl::ParsePublicKey(spki_tlv, &public_key));
  default_pkey_id_ = EVP_PKEY_id(public_key.get());

  // issuerUniqueID
  bool unused;
  ASSERT_TRUE(
      tbs_certificate.SkipOptionalTag(CBS_ASN1_CONTEXT_SPECIFIC | 1, &unused));
  // subjectUniqueID
  ASSERT_TRUE(
      tbs_certificate.SkipOptionalTag(CBS_ASN1_CONTEXT_SPECIFIC | 2, &unused));

  // extensions
  std::optional<bssl::der::Input> extensions_tlv;
  ASSERT_TRUE(tbs_certificate.ReadOptionalTag(
      CBS_ASN1_CONTEXT_SPECIFIC | CBS_ASN1_CONSTRUCTED | 3, &extensions_tlv));
  if (extensions_tlv) {
    std::map<bssl::der::Input, bssl::ParsedExtension> parsed_extensions;
    ASSERT_TRUE(ParseExtensions(extensions_tlv.value(), &parsed_extensions));

    for (const auto& parsed_extension : parsed_extensions) {
      SetExtension(parsed_extension.second.oid,
                   parsed_extension.second.value.AsString(),
                   parsed_extension.second.critical);
    }
  }
}

void CertBuilder::BuildTBSCertificate(std::string_view signature_algorithm_tlv,
                                      std::string* out) {
  bssl::ScopedCBB cbb;
  CBB tbs_cert, version, extensions_context, extensions;

  ASSERT_TRUE(CBB_init(cbb.get(), 64));
  ASSERT_TRUE(CBB_add_asn1(cbb.get(), &tbs_cert, CBS_ASN1_SEQUENCE));
  if (version_ != bssl::CertificateVersion::V1) {
    ASSERT_TRUE(
        CBB_add_asn1(&tbs_cert, &version,
                     CBS_ASN1_CONTEXT_SPECIFIC | CBS_ASN1_CONSTRUCTED | 0));
    switch (version_) {
      case bssl::CertificateVersion::V2:
        ASSERT_TRUE(CBB_add_asn1_uint64(&version, 1));
        break;
      case bssl::CertificateVersion::V3:
        ASSERT_TRUE(CBB_add_asn1_uint64(&version, 2));
        break;
      case bssl::CertificateVersion::V1:
        NOTREACHED();
    }
  }
  ASSERT_TRUE(CBB_add_asn1_uint64(&tbs_cert, GetSerialNumber()));
  ASSERT_TRUE(CBBAddBytes(&tbs_cert, signature_algorithm_tlv));
  ASSERT_TRUE(CBBAddBytes(&tbs_cert, issuer_tlv_.has_value()
                                         ? *issuer_tlv_
                                         : issuer_->GetSubject()));
  ASSERT_TRUE(CBBAddBytes(&tbs_cert, validity_tlv_));
  ASSERT_TRUE(CBBAddBytes(&tbs_cert, GetSubject()));
  ASSERT_TRUE(GetKey());
  ASSERT_TRUE(EVP_marshal_public_key(&tbs_cert, GetKey()));

  // Serialize all the extensions.
  if (!extensions_.empty()) {
    ASSERT_TRUE(
        CBB_add_asn1(&tbs_cert, &extensions_context,
                     CBS_ASN1_CONTEXT_SPECIFIC | CBS_ASN1_CONSTRUCTED | 3));
    ASSERT_TRUE(
        CBB_add_asn1(&extensions_context, &extensions, CBS_ASN1_SEQUENCE));

    //   Extension  ::=  SEQUENCE  {
    //        extnID      OBJECT IDENTIFIER,
    //        critical    BOOLEAN DEFAULT FALSE,
    //        extnValue   OCTET STRING
    //                    -- contains the DER encoding of an ASN.1 value
    //                    -- corresponding to the extension type identified
    //                    -- by extnID
    //        }
    for (const auto& extension_it : extensions_) {
      CBB extension_seq, oid, extn_value;
      ASSERT_TRUE(CBB_add_asn1(&extensions, &extension_seq, CBS_ASN1_SEQUENCE));
      ASSERT_TRUE(CBB_add_asn1(&extension_seq, &oid, CBS_ASN1_OBJECT));
      ASSERT_TRUE(CBBAddBytes(&oid, extension_it.first));
      if (extension_it.second.critical) {
        ASSERT_TRUE(CBB_add_asn1_bool(&extension_seq, true));
      }

      ASSERT_TRUE(
          CBB_add_asn1(&extension_seq, &extn_value, CBS_ASN1_OCTETSTRING));
      ASSERT_TRUE(CBBAddBytes(&extn_value, extension_it.second.value));
      ASSERT_TRUE(CBB_flush(&extensions));
    }
  }

  *out = FinishCBB(cbb.get());
}

void CertBuilder::BuildSctListExtension(const std::string& pre_tbs_certificate,
                                        std::string* out) {
  std::vector<std::string> encoded_scts;
  for (const SctConfig& sct_config : sct_configs_) {
    ct::SignedEntryData entry;
    entry.type = ct::SignedEntryData::LOG_ENTRY_TYPE_PRECERT;
    bssl::ScopedCBB issuer_spki_cbb;
    ASSERT_TRUE(CBB_init(issuer_spki_cbb.get(), 32));
    ASSERT_TRUE(
        EVP_marshal_public_key(issuer_spki_cbb.get(), issuer_->GetKey()));
    crypto::SHA256HashString(FinishCBB(issuer_spki_cbb.get()),
                             entry.issuer_key_hash.data,
                             sizeof(entry.issuer_key_hash.data));
    entry.tbs_certificate = pre_tbs_certificate;

    std::string serialized_log_entry;
    std::string serialized_data;
    ASSERT_TRUE(ct::EncodeSignedEntry(entry, &serialized_log_entry));
    ASSERT_TRUE(ct::EncodeV1SCTSignedData(sct_config.timestamp,
                                          serialized_log_entry,
                                          /*extensions=*/"", &serialized_data));

    scoped_refptr<ct::SignedCertificateTimestamp> sct =
        base::MakeRefCounted<ct::SignedCertificateTimestamp>();
    sct->log_id = sct_config.log_id;
    sct->timestamp = sct_config.timestamp;
    sct->signature.hash_algorithm = ct::DigitallySigned::HASH_ALGO_SHA256;
    sct->signature.signature_algorithm = ct::DigitallySigned::SIG_ALGO_ECDSA;

    bssl::ScopedCBB sct_signature_cbb;
    ASSERT_TRUE(CBB_init(sct_signature_cbb.get(), 0));
    ASSERT_TRUE(SignData(bssl::SignatureAlgorithm::kEcdsaSha256,
                         serialized_data, sct_config.log_key.get(),
                         sct_signature_cbb.get()));
    sct->signature.signature_data = FinishCBB(sct_signature_cbb.get());

    sct->origin = ct::SignedCertificateTimestamp::SCT_EMBEDDED;

    std::string encoded_sct;
    ASSERT_TRUE(ct::EncodeSignedCertificateTimestamp(sct, &encoded_sct));
    encoded_scts.push_back(std::move(encoded_sct));
  }
  std::string encoded_sct_list;
  ASSERT_TRUE(ct::EncodeSCTListForTesting(encoded_scts, &encoded_sct_list));

  bssl::ScopedCBB sct_extension_cbb;
  ASSERT_TRUE(CBB_init(sct_extension_cbb.get(), 32));
  ASSERT_TRUE(CBB_add_asn1_octet_string(
      sct_extension_cbb.get(),
      reinterpret_cast<const uint8_t*>(encoded_sct_list.data()),
      encoded_sct_list.size()));

  *out = FinishCBB(sct_extension_cbb.get());
}

void CertBuilder::GenerateCertificate() {
  ASSERT_FALSE(cert_);

  std::optional<bssl::SignatureAlgorithm> signature_algorithm =
      signature_algorithm_;
  if (!signature_algorithm)
    signature_algorithm = DefaultSignatureAlgorithmForKey(issuer_->GetKey());
  ASSERT_TRUE(signature_algorithm.has_value());

  std::string signature_algorithm_tlv =
      !outer_signature_algorithm_tlv_.empty()
          ? outer_signature_algorithm_tlv_
          : SignatureAlgorithmToDer(*signature_algorithm);
  ASSERT_FALSE(signature_algorithm_tlv.empty());

  std::string tbs_signature_algorithm_tlv =
      !tbs_signature_algorithm_tlv_.empty()
          ? tbs_signature_algorithm_tlv_
          : SignatureAlgorithmToDer(*signature_algorithm);
  ASSERT_FALSE(tbs_signature_algorithm_tlv.empty());

  if (!sct_configs_.empty()) {
    EraseExtension(bssl::der::Input(ct::kEmbeddedSCTOid));
    std::string pre_tbs_certificate;
    BuildTBSCertificate(tbs_signature_algorithm_tlv, &pre_tbs_certificate);
    std::string sct_extension;
    BuildSctListExtension(pre_tbs_certificate, &sct_extension);
    SetExtension(bssl::der::Input(ct::kEmbeddedSCTOid), sct_extension,
                 /*critical=*/false);
  }

  std::string tbs_cert;
  BuildTBSCertificate(tbs_signature_algorithm_tlv, &tbs_cert);

  // Sign the TBSCertificate and write the entire certificate.
  bssl::ScopedCBB cbb;
  CBB cert, signature;

  ASSERT_TRUE(CBB_init(cbb.get(), tbs_cert.size()));
  ASSERT_TRUE(CBB_add_asn1(cbb.get(), &cert, CBS_ASN1_SEQUENCE));
  ASSERT_TRUE(CBBAddBytes(&cert, tbs_cert));
  ASSERT_TRUE(CBBAddBytes(&cert, signature_algorithm_tlv));
  ASSERT_TRUE(CBB_add_asn1(&cert, &signature, CBS_ASN1_BITSTRING));
  ASSERT_TRUE(CBB_add_u8(&signature, 0 /* no unused bits */));
  ASSERT_TRUE(
      SignData(*signature_algorithm, tbs_cert, issuer_->GetKey(), &signature));

  auto cert_der = FinishCBB(cbb.get());
  cert_ = x509_util::CreateCryptoBuffer(base::as_byte_span(cert_der));
}

}  // namespace net
```
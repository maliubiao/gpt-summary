Response:
The user wants a summary of the functionality of a C++ test file for the Chromium network stack, specifically for parsing structured headers.

Here's a breakdown of the thought process:

1. **Identify the core purpose:** The file name `structured_headers_generated_test.cc` and the provided data structures (like `ListTestCase` and `DictionaryTestCase`) strongly suggest this file contains *test cases* for parsing structured HTTP headers. The "generated" part likely implies these test cases might be automatically generated or follow a specific pattern.

2. **Analyze the data structures:**
    * `ListTestCase`: Each entry defines a test with:
        * `name`: A descriptive name for the test.
        * `raw`: The raw input string for the header value.
        * `raw_len`: The length of the raw input.
        * `expected`: The expected parsed output, represented by nested `std::vector<ParameterizedItem>` or `std::nullopt` if parsing is expected to fail.
        * `canonical`: An optional canonical representation of the parsed header, used for verifying serialization.
    * `DictionaryTestCase`: Similar structure to `ListTestCase`, but the `expected` output is a `Dictionary` (a map-like structure).

3. **Infer functionality based on test cases:**  The test cases cover various scenarios:
    * **Basic lists:** Simple lists of integers, strings, and tokens.
    * **Lists of lists:** Nested list structures.
    * **Parameterized items:** Items with associated parameters (key-value pairs or boolean flags).
    * **Dictionaries:** Key-value pairs where values can be items or lists.
    * **Whitespace variations:** Testing how the parser handles different whitespace arrangements.
    * **Error cases:** Inputs that are expected to fail parsing due to syntax errors (e.g., missing parentheses, invalid characters).
    * **Edge cases:**  Testing specific character ranges in keys (especially in the `DictionaryTestCase`).
    * **Canonicalization:** Some tests verify that the parsed representation can be serialized back into a canonical form.

4. **Identify potential connections to JavaScript:**  JavaScript is often used in web development to interact with HTTP headers. The parsed structured headers in C++ would likely be used to provide data to JavaScript through some API. Examples would involve:
    * Accessing header values in `fetch` API responses.
    * Modifying headers in `XMLHttpRequest`.
    * Service Workers manipulating headers.

5. **Formulate examples of interaction with JavaScript:**  Based on the above, construct concrete examples of how JavaScript might access the parsed header information.

6. **Consider common usage errors:**  Think about what mistakes developers might make when working with structured headers, both on the server-side (generating headers) and the client-side (consuming them in JavaScript). Examples include incorrect syntax, assuming specific order of parameters, or not handling parsing errors.

7. **Relate to debugging:** Explain how encountering this test file might be relevant during debugging. It would be useful when investigating parsing issues, discrepancies between expected and actual header values, or understanding why a particular header is not being interpreted correctly. The steps to reach this file during debugging would involve tracing the code execution from the point where the header is received and parsed.

8. **Summarize the functionality for Part 4:**  Focus on the specific types of tests included in the provided snippet, which are mainly related to lists (including lists of lists and parameterized lists) and the beginning of dictionary tests.

9. **Structure the answer:** Organize the information logically with clear headings and examples. Use the terminology from the code (e.g., "ParameterizedItem", "Dictionary").

10. **Refine and iterate:** Review the answer for clarity, accuracy, and completeness. Ensure all parts of the prompt are addressed. For instance, explicitly state the file tests the *parsing* of structured headers.
Based on the provided code snippet, which represents a section of the `structured_headers_generated_test.cc` file, here's a breakdown of its functionality:

**Functionality of the Test File (Part 4):**

This section of the test file is dedicated to testing the parsing and potentially the canonicalization of **Structured Headers** as defined in [RFC 8941](https://datatracker.ietf.org/doc/html/rfc8941). It uses a table-driven approach to verify the correctness of the parsing logic for various header field values.

Specifically, this part of the file focuses on testing:

* **Lists:**
    * **Basic Lists:** Parsing simple lists of integers, including cases with extra whitespace.
    * **Lists of Lists:** Parsing nested list structures, including empty inner lists, extra whitespace, and error conditions like missing closing parentheses.
* **Parameterized Lists:**
    * Parsing lists where individual items can have associated parameters (key-value pairs or boolean flags).
    * Testing various whitespace scenarios around separators, equal signs, and semicolons within parameterized lists.
    * Testing cases with missing parameter values.
    * Testing combinations of parameterized items within inner lists.
* **Dictionaries (Beginning):**
    * The snippet transitions into testing the parsing of **Dictionaries**, which are key-value pairs.
    * It includes tests for basic dictionaries with string and byte sequence values.
    * It tests dictionaries with list values.
    * It covers whitespace variations within dictionaries.
    * It starts to explore the handling of "missing values" in dictionaries (where a key exists without an explicit value, implying a boolean `true`).
    * It touches upon error handling in dictionaries, such as trailing commas and empty items.
    * It starts to test for duplicate keys in dictionaries, showing the expected behavior of the parser (keeping the last occurrence).
    * **Extensive Testing of Dictionary Keys:**  A significant portion of this section is dedicated to testing the validity of characters allowed in dictionary keys, systematically checking various ASCII characters and their combinations. This suggests a focus on ensuring strict adherence to the key syntax rules.

**Relationship to JavaScript Functionality:**

Structured Headers are designed to provide a more robust and unambiguous way to represent complex data in HTTP headers compared to traditional string-based headers. JavaScript running in a browser or Node.js environment interacts with HTTP headers extensively. This test file ensures that the Chromium networking stack can correctly parse these structured headers, making the data available to JavaScript.

**Examples of Interaction with JavaScript:**

1. **Fetching a resource with a Structured Header:**
   ```javascript
   fetch('https://example.com', {
       headers: {
           'Accept-CH': 'Sec-CH-UA-Arch, Sec-CH-UA-Platform; v="4"', // Example Structured Header
       }
   })
   .then(response => {
       const acceptCH = response.headers.get('Accept-CH');
       // The JavaScript engine relies on the browser's C++ networking stack
       // (which this test file validates) to correctly parse 'Accept-CH'.
       console.log(acceptCH); // JavaScript gets the parsed representation
   });
   ```
   In this example, the `Accept-CH` header is a structured header. This C++ test ensures the browser correctly parses this header so that JavaScript can access the individual client hints like `Sec-CH-UA-Arch` and `Sec-CH-UA-Platform` along with their parameters.

2. **Accessing a Dictionary Header:**
   Consider a custom header like `My-Preferences`:
   ```
   My-Preferences: en="English", theme=("dark" "blue"); weight=0.8
   ```
   The corresponding JavaScript code might access this header:
   ```javascript
   fetch('/api/data')
   .then(response => {
       const prefsHeader = response.headers.get('My-Preferences');
       // The browser's C++ code (tested by this file) has already parsed
       // this into a dictionary-like structure.
       // (The exact JavaScript API for accessing this might vary based on
       //  how the browser exposes structured headers.)
       console.log(prefsHeader); // Would ideally show something like:
                                  // { en: "English", theme: ["dark", "blue"], weight: 0.8 }
   });
   ```

**Logical Reasoning with Assumptions, Inputs, and Outputs:**

Let's take the test case:

```c++
{"single item list of lists",
 "(42)",
 4,
 {{{{{Integer(42), {}}}, {}}}},
 nullptr},
```

* **Assumption:** The parser correctly implements the rules for parsing lists and inner lists.
* **Input (raw string):** `"(42)"`
* **Expected Output (parsed structure):** A list containing a single item, which is itself a list containing a single integer with the value 42 and no parameters. This is represented by the nested `std::vector<ParameterizedItem>` structure.

Another example with an error case:

```c++
{"no trailing parenthesis list of lists", "(1 42", 5, std::nullopt,
 nullptr},
```

* **Assumption:** The parser detects malformed list syntax.
* **Input (raw string):** `"(1 42"`
* **Expected Output:** `std::nullopt`, indicating that the parsing should fail.

**Common User or Programming Errors and Examples:**

1. **Incorrect Syntax when Generating Headers:** A server-side application might generate a structured header with incorrect syntax, which this test file aims to catch on the client-side (browser).
   * **Example of Incorrect Syntax:**  `My-List: item1, item2;param1=value1;param2` (missing value for `param2`)
   * This test file would have cases that ensure the parser either correctly interprets or rejects such malformed headers.

2. **Assuming Specific Order of Parameters:** While the parsing should be robust, relying on a specific order of parameters in JavaScript after parsing might be a mistake, as the order might not be guaranteed.

3. **Not Handling Parsing Errors in JavaScript:** If a server sends a malformed structured header, the browser's parsing might fail. JavaScript code needs to be prepared to handle cases where `response.headers.get()` returns `null` or throws an error when trying to access a structured header.

**User Operations to Reach This Code as a Debugging Line:**

Imagine a user reports an issue where a website feature relying on a specific HTTP header isn't working correctly in Chrome. A developer might follow these steps to potentially reach this test file:

1. **Reproduce the Issue:**  The developer would first try to reproduce the user's problem in their own Chrome browser.
2. **Inspect Network Requests:** Using Chrome DevTools (Network tab), the developer would examine the HTTP headers being exchanged between the browser and the server.
3. **Identify a Suspicious Header:** They might notice a header that is not being interpreted correctly or has an unexpected format. Let's say it's a structured header.
4. **Check Chromium's Networking Code:**  Knowing that Chrome uses the Chromium network stack, the developer might start investigating the code responsible for parsing HTTP headers.
5. **Locate Structured Header Parsing Code:** They would likely navigate to the `net/` directory and search for code related to "structured headers." This would lead them to the `quiche/` directory (which handles HTTP/3 and related protocols, including structured headers).
6. **Find the Test File:**  Within the `quiche/common/` directory, they would find `structured_headers_generated_test.cc`.
7. **Examine Test Cases:** By looking at the test cases in this file, the developer can:
    * **Understand the Expected Parsing Logic:** See how different valid and invalid header values are supposed to be parsed.
    * **Potentially Identify a Bug:**  If a test case matches the problematic header, and the expected output is different from what's happening in the browser, it indicates a potential bug in the parsing logic.
    * **Step Through the C++ Code:**  Using a debugger, the developer could then step through the actual C++ parsing code to pinpoint the source of the error, using the test cases as reference points.

**Summary of Functionality (Part 4):**

This section of `structured_headers_generated_test.cc` primarily functions as a comprehensive suite of unit tests for the structured header parsing logic in Chromium's network stack. It covers various valid and invalid syntax scenarios for **lists**, **lists of lists**, **parameterized lists**, and the beginning of **dictionaries**, with a strong emphasis on validating the allowed characters in dictionary keys. These tests ensure the robustness and correctness of the parser, which is crucial for JavaScript and other parts of the browser to correctly interpret and utilize information conveyed through structured HTTP headers.

Prompt: 
```
这是目录为net/third_party/quiche/src/quiche/common/structured_headers_generated_test.cc的chromium 网络栈的源代码文件， 请列举一下它的功能, 
如果它与javascript的功能有关系，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索。
这是第4部分，共5部分，请归纳一下它的功能

"""
    14,
     {{{{{Integer(1), {}}, {Integer(2), {}}}, {}},
       {{{Integer(42), {}}, {Integer(43), {}}}, {}}}},
     nullptr},
    {"single item list of lists",
     "(42)",
     4,
     {{{{{Integer(42), {}}}, {}}}},
     nullptr},
    {"empty item list of lists",
     "()",
     2,
     {{{std::vector<ParameterizedItem>(), {}}}},
     nullptr},
    {"empty middle item list of lists",
     "(1),(),(42)",
     11,
     {{{{{Integer(1), {}}}, {}},
       {std::vector<ParameterizedItem>(), {}},
       {{{Integer(42), {}}}, {}}}},
     "(1), (), (42)"},
    {"extra whitespace list of lists",
     "(  1  42  )",
     11,
     {{{{{Integer(1), {}}, {Integer(42), {}}}, {}}}},
     "(1 42)"},
    {"wrong whitespace list of lists", "(1\t 42)", 7, std::nullopt, nullptr},
    {"no trailing parenthesis list of lists", "(1 42", 5, std::nullopt,
     nullptr},
    {"no trailing parenthesis middle list of lists", "(1 2, (42 43)", 13,
     std::nullopt, nullptr},
    {"no spaces in inner-list", "(abc\"def\"?0123*dXZ3*xyz)", 24, std::nullopt,
     nullptr},
    {"no closing parenthesis", "(", 1, std::nullopt, nullptr},
    // param-list.json
    {"basic parameterised list",
     "abc_123;a=1;b=2; cdef_456, ghi;q=9;r=\"+w\"",
     41,
     {{{Item("abc_123", Item::kTokenType),
        {Param("a", 1), Param("b", 2), BooleanParam("cdef_456", true)}},
       {Item("ghi", Item::kTokenType), {Param("q", 9), Param("r", "+w")}}}},
     "abc_123;a=1;b=2;cdef_456, ghi;q=9;r=\"+w\""},
    {"single item parameterised list",
     "text/html;q=1.0",
     15,
     {{{Item("text/html", Item::kTokenType), {DoubleParam("q", 1.000000)}}}},
     nullptr},
    {"missing parameter value parameterised list",
     "text/html;a;q=1.0",
     17,
     {{{Item("text/html", Item::kTokenType),
        {BooleanParam("a", true), DoubleParam("q", 1.000000)}}}},
     nullptr},
    {"missing terminal parameter value parameterised list",
     "text/html;q=1.0;a",
     17,
     {{{Item("text/html", Item::kTokenType),
        {DoubleParam("q", 1.000000), BooleanParam("a", true)}}}},
     nullptr},
    {"no whitespace parameterised list",
     "text/html,text/plain;q=0.5",
     26,
     {{{Item("text/html", Item::kTokenType), {}},
       {Item("text/plain", Item::kTokenType), {DoubleParam("q", 0.500000)}}}},
     "text/html, text/plain;q=0.5"},
    {"whitespace before = parameterised list", "text/html, text/plain;q =0.5",
     28, std::nullopt, nullptr},
    {"whitespace after = parameterised list", "text/html, text/plain;q= 0.5",
     28, std::nullopt, nullptr},
    {"whitespace before ; parameterised list", "text/html, text/plain ;q=0.5",
     28, std::nullopt, nullptr},
    {"whitespace after ; parameterised list",
     "text/html, text/plain; q=0.5",
     28,
     {{{Item("text/html", Item::kTokenType), {}},
       {Item("text/plain", Item::kTokenType), {DoubleParam("q", 0.500000)}}}},
     "text/html, text/plain;q=0.5"},
    {"extra whitespace parameterised list",
     "text/html  ,  text/plain;  q=0.5;  charset=utf-8",
     48,
     {{{Item("text/html", Item::kTokenType), {}},
       {Item("text/plain", Item::kTokenType),
        {DoubleParam("q", 0.500000), TokenParam("charset", "utf-8")}}}},
     "text/html, text/plain;q=0.5;charset=utf-8"},
    {"two lines parameterised list",
     "text/html, text/plain;q=0.5",
     27,
     {{{Item("text/html", Item::kTokenType), {}},
       {Item("text/plain", Item::kTokenType), {DoubleParam("q", 0.500000)}}}},
     "text/html, text/plain;q=0.5"},
    {"trailing comma parameterised list", "text/html,text/plain;q=0.5,", 27,
     std::nullopt, nullptr},
    {"empty item parameterised list", "text/html,,text/plain;q=0.5,", 28,
     std::nullopt, nullptr},
    // param-listlist.json
    {"parameterised inner list",
     "(abc_123);a=1;b=2, cdef_456",
     27,
     {{{{{Item("abc_123", Item::kTokenType), {}}},
        {Param("a", 1), Param("b", 2)}},
       {Item("cdef_456", Item::kTokenType), {}}}},
     nullptr},
    {"parameterised inner list item",
     "(abc_123;a=1;b=2;cdef_456)",
     26,
     {{{{{Item("abc_123", Item::kTokenType),
          {Param("a", 1), Param("b", 2), BooleanParam("cdef_456", true)}}},
        {}}}},
     nullptr},
    {"parameterised inner list with parameterised item",
     "(abc_123;a=1;b=2);cdef_456",
     26,
     {{{{{Item("abc_123", Item::kTokenType), {Param("a", 1), Param("b", 2)}}},
        {BooleanParam("cdef_456", true)}}}},
     nullptr},
    // token.json
    {"basic token - list",
     "a_b-c3/*",
     8,
     {{{Item("a_b-c3/*", Item::kTokenType), {}}}},
     nullptr},
    {"token with capitals - list",
     "fooBar",
     6,
     {{{Item("fooBar", Item::kTokenType), {}}}},
     nullptr},
    {"token starting with capitals - list",
     "FooBar",
     6,
     {{{Item("FooBar", Item::kTokenType), {}}}},
     nullptr},
};

const struct DictionaryTestCase {
  const char* name;
  const char* raw;
  size_t raw_len;
  const std::optional<Dictionary>
      expected;           // nullopt if parse error is expected.
  const char* canonical;  // nullptr if parse error is expected, or if canonical
                          // format is identical to raw.
} dictionary_test_cases[] = {
    // dictionary.json
    {"basic dictionary",
     "en=\"Applepie\", da=:w4ZibGV0w6ZydGUK:",
     36,
     {Dictionary{
         {{"en", {Item("Applepie"), {}}},
          {"da",
           {Item("\303\206blet\303\246rte\n", Item::kByteSequenceType), {}}}}}},
     nullptr},
    {"empty dictionary", "", 0, {Dictionary{{}}}, nullptr},
    {"single item dictionary",
     "a=1",
     3,
     {Dictionary{{{"a", {Integer(1), {}}}}}},
     nullptr},
    {"list item dictionary",
     "a=(1 2)",
     7,
     {Dictionary{{{"a", {{{Integer(1), {}}, {Integer(2), {}}}, {}}}}}},
     nullptr},
    {"single list item dictionary",
     "a=(1)",
     5,
     {Dictionary{{{"a", {{{Integer(1), {}}}, {}}}}}},
     nullptr},
    {"empty list item dictionary",
     "a=()",
     4,
     {Dictionary{{{"a", {std::vector<ParameterizedItem>(), {}}}}}},
     nullptr},
    {"no whitespace dictionary",
     "a=1,b=2",
     7,
     {Dictionary{{{"a", {Integer(1), {}}}, {"b", {Integer(2), {}}}}}},
     "a=1, b=2"},
    {"extra whitespace dictionary",
     "a=1 ,  b=2",
     10,
     {Dictionary{{{"a", {Integer(1), {}}}, {"b", {Integer(2), {}}}}}},
     "a=1, b=2"},
    {"tab separated dictionary",
     "a=1\t,\tb=2",
     9,
     {Dictionary{{{"a", {Integer(1), {}}}, {"b", {Integer(2), {}}}}}},
     "a=1, b=2"},
    {"leading whitespace dictionary",
     "     a=1 ,  b=2",
     15,
     {Dictionary{{{"a", {Integer(1), {}}}, {"b", {Integer(2), {}}}}}},
     "a=1, b=2"},
    {"whitespace before = dictionary", "a =1, b=2", 9, std::nullopt, nullptr},
    {"whitespace after = dictionary", "a=1, b= 2", 9, std::nullopt, nullptr},
    {"two lines dictionary",
     "a=1, b=2",
     8,
     {Dictionary{{{"a", {Integer(1), {}}}, {"b", {Integer(2), {}}}}}},
     "a=1, b=2"},
    {"missing value dictionary",
     "a=1, b, c=3",
     11,
     {Dictionary{{{"a", {Integer(1), {}}},
                  {"b", {Item(true), {}}},
                  {"c", {Integer(3), {}}}}}},
     nullptr},
    {"all missing value dictionary",
     "a, b, c",
     7,
     {Dictionary{{{"a", {Item(true), {}}},
                  {"b", {Item(true), {}}},
                  {"c", {Item(true), {}}}}}},
     nullptr},
    {"start missing value dictionary",
     "a, b=2",
     6,
     {Dictionary{{{"a", {Item(true), {}}}, {"b", {Integer(2), {}}}}}},
     nullptr},
    {"end missing value dictionary",
     "a=1, b",
     6,
     {Dictionary{{{"a", {Integer(1), {}}}, {"b", {Item(true), {}}}}}},
     nullptr},
    {"missing value with params dictionary",
     "a=1, b;foo=9, c=3",
     17,
     {Dictionary{{{"a", {Integer(1), {}}},
                  {"b", {Item(true), {Param("foo", 9)}}},
                  {"c", {Integer(3), {}}}}}},
     nullptr},
    {"explicit true value with params dictionary",
     "a=1, b=?1;foo=9, c=3",
     20,
     {Dictionary{{{"a", {Integer(1), {}}},
                  {"b", {Item(true), {Param("foo", 9)}}},
                  {"c", {Integer(3), {}}}}}},
     "a=1, b;foo=9, c=3"},
    {"trailing comma dictionary", "a=1, b=2,", 9, std::nullopt, nullptr},
    {"empty item dictionary", "a=1,,b=2,", 9, std::nullopt, nullptr},
    {"duplicate key dictionary",
     "a=1,b=2,a=3",
     11,
     {Dictionary{{{"a", {Integer(3), {}}}, {"b", {Integer(2), {}}}}}},
     "a=3, b=2"},
    {"numeric key dictionary", "a=1,1b=2,a=1", 12, std::nullopt, nullptr},
    {"uppercase key dictionary", "a=1,B=2,a=1", 11, std::nullopt, nullptr},
    {"bad key dictionary", "a=1,b!=2,a=1", 12, std::nullopt, nullptr},
    // examples.json
    {"Example-DictHeader",
     "en=\"Applepie\", da=:w4ZibGV0w6ZydGU=:",
     36,
     {Dictionary{
         {{"en", {Item("Applepie"), {}}},
          {"da",
           {Item("\303\206blet\303\246rte", Item::kByteSequenceType), {}}}}}},
     nullptr},
    {"Example-DictHeader (boolean values)",
     "a=?0, b, c; foo=bar",
     19,
     {Dictionary{{{"a", {Item(false), {}}},
                  {"b", {Item(true), {}}},
                  {"c", {Item(true), {TokenParam("foo", "bar")}}}}}},
     "a=?0, b, c;foo=bar"},
    {"Example-DictListHeader",
     "rating=1.5, feelings=(joy sadness)",
     34,
     {Dictionary{{{"rating", {Item(1.500000), {}}},
                  {"feelings",
                   {{{Item("joy", Item::kTokenType), {}},
                     {Item("sadness", Item::kTokenType), {}}},
                    {}}}}}},
     nullptr},
    {"Example-MixDict",
     "a=(1 2), b=3, c=4;aa=bb, d=(5 6);valid",
     38,
     {Dictionary{{{"a", {{{Integer(1), {}}, {Integer(2), {}}}, {}}},
                  {"b", {Integer(3), {}}},
                  {"c", {Integer(4), {TokenParam("aa", "bb")}}},
                  {"d",
                   {{{Integer(5), {}}, {Integer(6), {}}},
                    {BooleanParam("valid", true)}}}}}},
     "a=(1 2), b=3, c=4;aa=bb, d=(5 6);valid"},
    {"Example-Hdr (dictionary on one line)",
     "foo=1, bar=2",
     12,
     {Dictionary{{{"foo", {Integer(1), {}}}, {"bar", {Integer(2), {}}}}}},
     nullptr},
    {"Example-Hdr (dictionary on two lines)",
     "foo=1, bar=2",
     12,
     {Dictionary{{{"foo", {Integer(1), {}}}, {"bar", {Integer(2), {}}}}}},
     "foo=1, bar=2"},
    // key-generated.json
    {"0x00 as a single-character dictionary key", "\000=1", 3, std::nullopt,
     nullptr},
    {"0x01 as a single-character dictionary key", "\001=1", 3, std::nullopt,
     nullptr},
    {"0x02 as a single-character dictionary key", "\002=1", 3, std::nullopt,
     nullptr},
    {"0x03 as a single-character dictionary key", "\003=1", 3, std::nullopt,
     nullptr},
    {"0x04 as a single-character dictionary key", "\004=1", 3, std::nullopt,
     nullptr},
    {"0x05 as a single-character dictionary key", "\005=1", 3, std::nullopt,
     nullptr},
    {"0x06 as a single-character dictionary key", "\006=1", 3, std::nullopt,
     nullptr},
    {"0x07 as a single-character dictionary key", "\a=1", 3, std::nullopt,
     nullptr},
    {"0x08 as a single-character dictionary key", "\b=1", 3, std::nullopt,
     nullptr},
    {"0x09 as a single-character dictionary key", "\t=1", 3, std::nullopt,
     nullptr},
    {"0x0a as a single-character dictionary key", "\n=1", 3, std::nullopt,
     nullptr},
    {"0x0b as a single-character dictionary key", "\v=1", 3, std::nullopt,
     nullptr},
    {"0x0c as a single-character dictionary key", "\f=1", 3, std::nullopt,
     nullptr},
    {"0x0d as a single-character dictionary key", "\r=1", 3, std::nullopt,
     nullptr},
    {"0x0e as a single-character dictionary key", "\016=1", 3, std::nullopt,
     nullptr},
    {"0x0f as a single-character dictionary key", "\017=1", 3, std::nullopt,
     nullptr},
    {"0x10 as a single-character dictionary key", "\020=1", 3, std::nullopt,
     nullptr},
    {"0x11 as a single-character dictionary key", "\021=1", 3, std::nullopt,
     nullptr},
    {"0x12 as a single-character dictionary key", "\022=1", 3, std::nullopt,
     nullptr},
    {"0x13 as a single-character dictionary key", "\023=1", 3, std::nullopt,
     nullptr},
    {"0x14 as a single-character dictionary key", "\024=1", 3, std::nullopt,
     nullptr},
    {"0x15 as a single-character dictionary key", "\025=1", 3, std::nullopt,
     nullptr},
    {"0x16 as a single-character dictionary key", "\026=1", 3, std::nullopt,
     nullptr},
    {"0x17 as a single-character dictionary key", "\027=1", 3, std::nullopt,
     nullptr},
    {"0x18 as a single-character dictionary key", "\030=1", 3, std::nullopt,
     nullptr},
    {"0x19 as a single-character dictionary key", "\031=1", 3, std::nullopt,
     nullptr},
    {"0x1a as a single-character dictionary key", "\032=1", 3, std::nullopt,
     nullptr},
    {"0x1b as a single-character dictionary key", "\033=1", 3, std::nullopt,
     nullptr},
    {"0x1c as a single-character dictionary key", "\034=1", 3, std::nullopt,
     nullptr},
    {"0x1d as a single-character dictionary key", "\035=1", 3, std::nullopt,
     nullptr},
    {"0x1e as a single-character dictionary key", "\036=1", 3, std::nullopt,
     nullptr},
    {"0x1f as a single-character dictionary key", "\037=1", 3, std::nullopt,
     nullptr},
    {"0x20 as a single-character dictionary key", "=1", 2, std::nullopt,
     nullptr},
    {"0x21 as a single-character dictionary key", "!=1", 3, std::nullopt,
     nullptr},
    {"0x22 as a single-character dictionary key", "\"=1", 3, std::nullopt,
     nullptr},
    {"0x23 as a single-character dictionary key", "#=1", 3, std::nullopt,
     nullptr},
    {"0x24 as a single-character dictionary key", "$=1", 3, std::nullopt,
     nullptr},
    {"0x25 as a single-character dictionary key", "%=1", 3, std::nullopt,
     nullptr},
    {"0x26 as a single-character dictionary key", "&=1", 3, std::nullopt,
     nullptr},
    {"0x27 as a single-character dictionary key", "'=1", 3, std::nullopt,
     nullptr},
    {"0x28 as a single-character dictionary key", "(=1", 3, std::nullopt,
     nullptr},
    {"0x29 as a single-character dictionary key", ")=1", 3, std::nullopt,
     nullptr},
    {"0x2a as a single-character dictionary key",
     "*=1",
     3,
     {Dictionary{{{"*", {Integer(1), {}}}}}},
     nullptr},
    {"0x2b as a single-character dictionary key", "+=1", 3, std::nullopt,
     nullptr},
    {"0x2c as a single-character dictionary key", ",=1", 3, std::nullopt,
     nullptr},
    {"0x2d as a single-character dictionary key", "-=1", 3, std::nullopt,
     nullptr},
    {"0x2e as a single-character dictionary key", ".=1", 3, std::nullopt,
     nullptr},
    {"0x2f as a single-character dictionary key", "/=1", 3, std::nullopt,
     nullptr},
    {"0x30 as a single-character dictionary key", "0=1", 3, std::nullopt,
     nullptr},
    {"0x31 as a single-character dictionary key", "1=1", 3, std::nullopt,
     nullptr},
    {"0x32 as a single-character dictionary key", "2=1", 3, std::nullopt,
     nullptr},
    {"0x33 as a single-character dictionary key", "3=1", 3, std::nullopt,
     nullptr},
    {"0x34 as a single-character dictionary key", "4=1", 3, std::nullopt,
     nullptr},
    {"0x35 as a single-character dictionary key", "5=1", 3, std::nullopt,
     nullptr},
    {"0x36 as a single-character dictionary key", "6=1", 3, std::nullopt,
     nullptr},
    {"0x37 as a single-character dictionary key", "7=1", 3, std::nullopt,
     nullptr},
    {"0x38 as a single-character dictionary key", "8=1", 3, std::nullopt,
     nullptr},
    {"0x39 as a single-character dictionary key", "9=1", 3, std::nullopt,
     nullptr},
    {"0x3a as a single-character dictionary key", ":=1", 3, std::nullopt,
     nullptr},
    {"0x3b as a single-character dictionary key", ";=1", 3, std::nullopt,
     nullptr},
    {"0x3c as a single-character dictionary key", "<=1", 3, std::nullopt,
     nullptr},
    {"0x3d as a single-character dictionary key", "==1", 3, std::nullopt,
     nullptr},
    {"0x3e as a single-character dictionary key", ">=1", 3, std::nullopt,
     nullptr},
    {"0x3f as a single-character dictionary key", "?=1", 3, std::nullopt,
     nullptr},
    {"0x40 as a single-character dictionary key", "@=1", 3, std::nullopt,
     nullptr},
    {"0x41 as a single-character dictionary key", "A=1", 3, std::nullopt,
     nullptr},
    {"0x42 as a single-character dictionary key", "B=1", 3, std::nullopt,
     nullptr},
    {"0x43 as a single-character dictionary key", "C=1", 3, std::nullopt,
     nullptr},
    {"0x44 as a single-character dictionary key", "D=1", 3, std::nullopt,
     nullptr},
    {"0x45 as a single-character dictionary key", "E=1", 3, std::nullopt,
     nullptr},
    {"0x46 as a single-character dictionary key", "F=1", 3, std::nullopt,
     nullptr},
    {"0x47 as a single-character dictionary key", "G=1", 3, std::nullopt,
     nullptr},
    {"0x48 as a single-character dictionary key", "H=1", 3, std::nullopt,
     nullptr},
    {"0x49 as a single-character dictionary key", "I=1", 3, std::nullopt,
     nullptr},
    {"0x4a as a single-character dictionary key", "J=1", 3, std::nullopt,
     nullptr},
    {"0x4b as a single-character dictionary key", "K=1", 3, std::nullopt,
     nullptr},
    {"0x4c as a single-character dictionary key", "L=1", 3, std::nullopt,
     nullptr},
    {"0x4d as a single-character dictionary key", "M=1", 3, std::nullopt,
     nullptr},
    {"0x4e as a single-character dictionary key", "N=1", 3, std::nullopt,
     nullptr},
    {"0x4f as a single-character dictionary key", "O=1", 3, std::nullopt,
     nullptr},
    {"0x50 as a single-character dictionary key", "P=1", 3, std::nullopt,
     nullptr},
    {"0x51 as a single-character dictionary key", "Q=1", 3, std::nullopt,
     nullptr},
    {"0x52 as a single-character dictionary key", "R=1", 3, std::nullopt,
     nullptr},
    {"0x53 as a single-character dictionary key", "S=1", 3, std::nullopt,
     nullptr},
    {"0x54 as a single-character dictionary key", "T=1", 3, std::nullopt,
     nullptr},
    {"0x55 as a single-character dictionary key", "U=1", 3, std::nullopt,
     nullptr},
    {"0x56 as a single-character dictionary key", "V=1", 3, std::nullopt,
     nullptr},
    {"0x57 as a single-character dictionary key", "W=1", 3, std::nullopt,
     nullptr},
    {"0x58 as a single-character dictionary key", "X=1", 3, std::nullopt,
     nullptr},
    {"0x59 as a single-character dictionary key", "Y=1", 3, std::nullopt,
     nullptr},
    {"0x5a as a single-character dictionary key", "Z=1", 3, std::nullopt,
     nullptr},
    {"0x5b as a single-character dictionary key", "[=1", 3, std::nullopt,
     nullptr},
    {"0x5c as a single-character dictionary key", "\\=1", 3, std::nullopt,
     nullptr},
    {"0x5d as a single-character dictionary key", "]=1", 3, std::nullopt,
     nullptr},
    {"0x5e as a single-character dictionary key", "^=1", 3, std::nullopt,
     nullptr},
    {"0x5f as a single-character dictionary key", "_=1", 3, std::nullopt,
     nullptr},
    {"0x60 as a single-character dictionary key", "`=1", 3, std::nullopt,
     nullptr},
    {"0x61 as a single-character dictionary key",
     "a=1",
     3,
     {Dictionary{{{"a", {Integer(1), {}}}}}},
     nullptr},
    {"0x62 as a single-character dictionary key",
     "b=1",
     3,
     {Dictionary{{{"b", {Integer(1), {}}}}}},
     nullptr},
    {"0x63 as a single-character dictionary key",
     "c=1",
     3,
     {Dictionary{{{"c", {Integer(1), {}}}}}},
     nullptr},
    {"0x64 as a single-character dictionary key",
     "d=1",
     3,
     {Dictionary{{{"d", {Integer(1), {}}}}}},
     nullptr},
    {"0x65 as a single-character dictionary key",
     "e=1",
     3,
     {Dictionary{{{"e", {Integer(1), {}}}}}},
     nullptr},
    {"0x66 as a single-character dictionary key",
     "f=1",
     3,
     {Dictionary{{{"f", {Integer(1), {}}}}}},
     nullptr},
    {"0x67 as a single-character dictionary key",
     "g=1",
     3,
     {Dictionary{{{"g", {Integer(1), {}}}}}},
     nullptr},
    {"0x68 as a single-character dictionary key",
     "h=1",
     3,
     {Dictionary{{{"h", {Integer(1), {}}}}}},
     nullptr},
    {"0x69 as a single-character dictionary key",
     "i=1",
     3,
     {Dictionary{{{"i", {Integer(1), {}}}}}},
     nullptr},
    {"0x6a as a single-character dictionary key",
     "j=1",
     3,
     {Dictionary{{{"j", {Integer(1), {}}}}}},
     nullptr},
    {"0x6b as a single-character dictionary key",
     "k=1",
     3,
     {Dictionary{{{"k", {Integer(1), {}}}}}},
     nullptr},
    {"0x6c as a single-character dictionary key",
     "l=1",
     3,
     {Dictionary{{{"l", {Integer(1), {}}}}}},
     nullptr},
    {"0x6d as a single-character dictionary key",
     "m=1",
     3,
     {Dictionary{{{"m", {Integer(1), {}}}}}},
     nullptr},
    {"0x6e as a single-character dictionary key",
     "n=1",
     3,
     {Dictionary{{{"n", {Integer(1), {}}}}}},
     nullptr},
    {"0x6f as a single-character dictionary key",
     "o=1",
     3,
     {Dictionary{{{"o", {Integer(1), {}}}}}},
     nullptr},
    {"0x70 as a single-character dictionary key",
     "p=1",
     3,
     {Dictionary{{{"p", {Integer(1), {}}}}}},
     nullptr},
    {"0x71 as a single-character dictionary key",
     "q=1",
     3,
     {Dictionary{{{"q", {Integer(1), {}}}}}},
     nullptr},
    {"0x72 as a single-character dictionary key",
     "r=1",
     3,
     {Dictionary{{{"r", {Integer(1), {}}}}}},
     nullptr},
    {"0x73 as a single-character dictionary key",
     "s=1",
     3,
     {Dictionary{{{"s", {Integer(1), {}}}}}},
     nullptr},
    {"0x74 as a single-character dictionary key",
     "t=1",
     3,
     {Dictionary{{{"t", {Integer(1), {}}}}}},
     nullptr},
    {"0x75 as a single-character dictionary key",
     "u=1",
     3,
     {Dictionary{{{"u", {Integer(1), {}}}}}},
     nullptr},
    {"0x76 as a single-character dictionary key",
     "v=1",
     3,
     {Dictionary{{{"v", {Integer(1), {}}}}}},
     nullptr},
    {"0x77 as a single-character dictionary key",
     "w=1",
     3,
     {Dictionary{{{"w", {Integer(1), {}}}}}},
     nullptr},
    {"0x78 as a single-character dictionary key",
     "x=1",
     3,
     {Dictionary{{{"x", {Integer(1), {}}}}}},
     nullptr},
    {"0x79 as a single-character dictionary key",
     "y=1",
     3,
     {Dictionary{{{"y", {Integer(1), {}}}}}},
     nullptr},
    {"0x7a as a single-character dictionary key",
     "z=1",
     3,
     {Dictionary{{{"z", {Integer(1), {}}}}}},
     nullptr},
    {"0x7b as a single-character dictionary key", "{=1", 3, std::nullopt,
     nullptr},
    {"0x7c as a single-character dictionary key", "|=1", 3, std::nullopt,
     nullptr},
    {"0x7d as a single-character dictionary key", "}=1", 3, std::nullopt,
     nullptr},
    {"0x7e as a single-character dictionary key", "~=1", 3, std::nullopt,
     nullptr},
    {"0x7f as a single-character dictionary key", "\177=1", 3, std::nullopt,
     nullptr},
    {"0x00 in dictionary key", "a\000a=1", 5, std::nullopt, nullptr},
    {"0x01 in dictionary key", "a\001a=1", 5, std::nullopt, nullptr},
    {"0x02 in dictionary key", "a\002a=1", 5, std::nullopt, nullptr},
    {"0x03 in dictionary key", "a\003a=1", 5, std::nullopt, nullptr},
    {"0x04 in dictionary key", "a\004a=1", 5, std::nullopt, nullptr},
    {"0x05 in dictionary key", "a\005a=1", 5, std::nullopt, nullptr},
    {"0x06 in dictionary key", "a\006a=1", 5, std::nullopt, nullptr},
    {"0x07 in dictionary key", "a\aa=1", 5, std::nullopt, nullptr},
    {"0x08 in dictionary key", "a\ba=1", 5, std::nullopt, nullptr},
    {"0x09 in dictionary key", "a\ta=1", 5, std::nullopt, nullptr},
    {"0x0a in dictionary key", "a\na=1", 5, std::nullopt, nullptr},
    {"0x0b in dictionary key", "a\va=1", 5, std::nullopt, nullptr},
    {"0x0c in dictionary key", "a\fa=1", 5, std::nullopt, nullptr},
    {"0x0d in dictionary key", "a\ra=1", 5, std::nullopt, nullptr},
    {"0x0e in dictionary key", "a\016a=1", 5, std::nullopt, nullptr},
    {"0x0f in dictionary key", "a\017a=1", 5, std::nullopt, nullptr},
    {"0x10 in dictionary key", "a\020a=1", 5, std::nullopt, nullptr},
    {"0x11 in dictionary key", "a\021a=1", 5, std::nullopt, nullptr},
    {"0x12 in dictionary key", "a\022a=1", 5, std::nullopt, nullptr},
    {"0x13 in dictionary key", "a\023a=1", 5, std::nullopt, nullptr},
    {"0x14 in dictionary key", "a\024a=1", 5, std::nullopt, nullptr},
    {"0x15 in dictionary key", "a\025a=1", 5, std::nullopt, nullptr},
    {"0x16 in dictionary key", "a\026a=1", 5, std::nullopt, nullptr},
    {"0x17 in dictionary key", "a\027a=1", 5, std::nullopt, nullptr},
    {"0x18 in dictionary key", "a\030a=1", 5, std::nullopt, nullptr},
    {"0x19 in dictionary key", "a\031a=1", 5, std::nullopt, nullptr},
    {"0x1a in dictionary key", "a\032a=1", 5, std::nullopt, nullptr},
    {"0x1b in dictionary key", "a\033a=1", 5, std::nullopt, nullptr},
    {"0x1c in dictionary key", "a\034a=1", 5, std::nullopt, nullptr},
    {"0x1d in dictionary key", "a\035a=1", 5, std::nullopt, nullptr},
    {"0x1e in dictionary key", "a\036a=1", 5, std::nullopt, nullptr},
    {"0x1f in dictionary key", "a\037a=1", 5, std::nullopt, nullptr},
    {"0x20 in dictionary key", "a a=1", 5, std::nullopt, nullptr},
    {"0x21 in dictionary key", "a!a=1", 5, std::nullopt, nullptr},
    {"0x22 in dictionary key", "a\"a=1", 5, std::nullopt, nullptr},
    {"0x23 in dictionary key", "a#a=1", 5, std::nullopt, nullptr},
    {"0x24 in dictionary key", "a$a=1", 5, std::nullopt, nullptr},
    {"0x25 in dictionary key", "a%a=1", 5, std::nullopt, nullptr},
    {"0x26 in dictionary key", "a&a=1", 5, std::nullopt, nullptr},
    {"0x27 in dictionary key", "a'a=1", 5, std::nullopt, nullptr},
    {"0x28 in dictionary key", "a(a=1", 5, std::nullopt, nullptr},
    {"0x29 in dictionary key", "a)a=1", 5, std::nullopt, nullptr},
    {"0x2a in dictionary key",
     "a*a=1",
     5,
     {Dictionary{{{"a*a", {Integer(1), {}}}}}},
     nullptr},
    {"0x2b in dictionary key", "a+a=1", 5, std::nullopt, nullptr},
    {"0x2c in dictionary key",
     "a,a=1",
     5,
     {Dictionary{{{"a", {Integer(1), {}}}}}},
     "a=1"},
    {"0x2d in dictionary key",
     "a-a=1",
     5,
     {Dictionary{{{"a-a", {Integer(1), {}}}}}},
     nullptr},
    {"0x2e in dictionary key",
     "a.a=1",
     5,
     {Dictionary{{{"a.a", {Integer(1), {}}}}}},
     nullptr},
    {"0x2f in dictionary key", "a/a=1", 5, std::nullopt, nullptr},
    {"0x30 in dictionary key",
     "a0a=1",
     5,
     {Dictionary{{{"a0a", {Integer(1), {}}}}}},
     nullptr},
    {"0x31 in dictionary key",
     "a1a=1",
     5,
     {Dictionary{{{"a1a", {Integer(1), {}}}}}},
     nullptr},
    {"0x32 in dictionary key",
     "a2a=1",
     5,
     {Dictionary{{{"a2a", {Integer(1), {}}}}}},
     nullptr},
    {"0x33 in dictionary key",
     "a3a=1",
     5,
     {Dictionary{{{"a3a", {Integer(1), {}}}}}},
     nullptr},
    {"0x34 in dictionary key",
     "a4a=1",
     5,
     {Dictionary{{{"a4a", {Integer(1), {}}}}}},
     nullptr},
    {"0x35 in dictionary key",
     "a5a=1",
     5,
     {Dictionary{{{"a5a", {Integer(1), {}}}}}},
     nullptr},
    {"0x36 in dictionary key",
     "a6a=1",
     5,
     {Dictionary{{{"a6a", {Integer(1), {}}}}}},
     nullptr},
    {"0x37 in dictionary key",
     "a7a=1",
     5,
     {Dictionary{{{"a7a", {Integer(1), {}}}}}},
     nullptr},
    {"0x38 in dictionary key",
     "a8a=1",
     5,
     {Dictionary{{{"a8a", {Integer(1), {}}}}}},
     nullptr},
    {"0x39 in dictionary key",
     "a9a=1",
     5,
     {Dictionary{{{"a9a", {Integer(1), {}}}}}},
     nullptr},
    {"0x3a in dictionary key", "a:a=1", 5, std::nullopt, nullptr},
    {"0x3b in dictionary key",
     "a;a=1",
     5,
     {Dictionary{{{"a", {Item(true), {Param("a", 1)}}}}}},
     nullptr},
    {"0x3c in dictionary key", "a<a=1", 5, std::nullopt, nullptr},
    {"0x3d in dictionary key", "a=a=1", 5, std::nullopt, nullptr},
    {"0x3e in dictionary key", "a>a=1", 5, std::nullopt, nullptr},
    {"0x3f in dictionary key", "a?a=1", 5, std::nullopt, nullptr},
    {"0x40 in dictionary key", "a@a=1", 5, std::nullopt, nullptr},
    {"0x41 in dictionary key", "aAa=1", 5, std::nullopt, nullptr},
    {"0x42 in dictionary key", "aBa=1", 5, std::nullopt, nullptr},
    {"0x43 in dictionary key", "aCa=1", 5, std::nullopt, nullptr},
    {"0x44 in dictionary key", "aDa=1", 5, std::nullopt, nullptr},
    {"0x45 in dictionary key", "aEa=1", 5, std::nullopt, nullptr},
    {"0x46 in dictionary key", "aFa=1", 5, std::nullopt, nullptr},
    {"0x47 in dictionary key", "aGa=1", 5, std::nullopt, nullptr},
    {"0x48 in dictionary key", "aHa=1", 5, std::nullopt, nullptr},
    {"0x49 in dictionary key", "aIa=1", 5, std::nullopt, nullptr},
    {"0x4a in dictionary key", "aJa=1", 5, std::nullopt, nullptr},
    {"0x4b in dictionary key", "aKa=1", 5, std::nullopt, nullptr},
    {"0x4c in dictionary key", "aLa=1", 5, std::nullopt, nullptr},
    {"0x4d in dictionary key", "aMa=1", 5, std::nullopt, nullptr},
    {"0x4e in dictionary key", "aNa=1", 5, std::nullopt, nullptr},
    {"0x4f in dictionary key", "aOa=1", 5, std::nullopt, nullptr},
    {"0x50 in dictionary key", "aPa=1", 5, std::nullopt, nullptr},
    {"0x51 in dictionary key", "aQa=1", 5, std::nullopt, nullptr},
    {"0x52 in dictionary key", "aRa=1", 5, std::nullopt, nullptr},
    {"0x53 in dictionary key", "aSa=1", 5, std::nullopt, nullptr},
    {"0x54 in dictionary key", "aTa=1", 5, std::nullopt, nullptr},
    {"0x55 in dictionary key", "aUa=1", 5, std::nullopt, nullptr},
    {"0x56 in dictionary key", "aVa=1", 5, std::nullopt, nullptr},
    {"0x57 in dictionary key", "aWa=1", 5, std::nullopt, nullptr},
    {"0x58 in dictionary key", "aXa=1", 5, std::nullopt, nullptr},
    {"0x59 in dictionary key", "aYa=1", 5, std::nullopt, nullptr},
    {"0x5a in dictionary key", "aZa=1", 5, std::nullopt, nullptr},
    {"0x5b in dictionary key", "a[a=1", 5, std::nullopt, nullptr},
    {"0x5c in dictionary key", "a\\a=1", 5, std::nullopt, nullptr},
    {"0x5d in dictionary key", "a]a=1", 5, std::nullopt, nullptr},
    {"0x5e in dictionary key", "a^a=1", 5, std::nullopt, nullptr},
    {"0x5f in dictionary key",
     "a_a=1",
     5,
     {Dictionary{{{"a_a", {Integer(1), {}}}}}},
     nullptr},
    {"0x60 in dictionary key", "a`a=1", 5, std::nullopt, nullptr},
    {"0x61 in dictionary key",
     "aaa=1",
     5,
     {Dictionary{{{"aaa", {Integer(1), {}}}}}},
     nullptr},
    {"0x62 in dictionary key",
     "aba=1",
     5,
     {Dictionary{{{"aba", {Integer(1), {}}}}}},
     nullptr},
    {"0x63 in dictionary key",
     "aca=1",
     5,
     {Dictionary{{{"aca", {Integer(1), {}}}}}},
     nullptr},
    {"0x64 in dictionary key",
     "ada=1",
     5,
     {Dictionary{{{"ada", {Integer(1), {}}}}}},
     nullptr},
    {"0x65 in dictionary key",
     "aea=1",
     5,
     {Dictionary{{{"aea", {Integer(1), {}}}}}},
     nullptr},
    {"0x66 in dictionary key",
     "afa=1",
     5,
     {Dictionary{{{"afa", {Integer(1), {}}}}}},
     nullptr},
    {"0x67 in dictionary key",
     "aga=1",
     5,
     {Dictionary{{{"aga", {Integer(1), {}}}}}},
     nullptr},
    {"0x68 in dictionary key",
     "aha=1",
     5,
     {Dictionary{{{"aha", {Integer(1), {}}}}}},
     nullptr},
    {"0x69 in dictionary key",
     "aia=1",
     5,
     {Dictionary{{{"aia", {Integer(1), {}}}}}},
     nullptr},
    {"0x6a in dictionary key",
     "aja=1",
     5,
     {Dictionary{{{"aja", {Integer(1), {}}}}}},
     nullptr},
    {"0x6b in dictionary key",
     "aka=1",
     5,
     {Dictionary{{{"aka", {Integer(1), {}}}}}},
     nullptr},
    {"0x6c in dictionary key",
     "ala=1",
     5,
     {Dictionary{{{"ala", {Integer(1), {}}}}}},
     nullptr},
    {"0x6d in dictionary key",
     "ama=1",
     5,
     {Dictionary{{{"ama", {Integer(1), {}}}}}},
     nullptr},
    {"0x6e in dictionary key",
     "ana=1",
     5,
     {Dictionary{{{"ana", {Integer(1), {}}}}}},
     nullptr},
    {"0x6f in dictionary key",
     "aoa=1",
     5,
     {Dictionary{{{"aoa", {Integer(1), {}}}}}},
     nullptr},
    {"0x70 in dictionary key",
     "apa=1",
     5,
     {Dictionary{{{"apa", {Integer(1), {}}}}}},
     nullptr},
    {"0x71 in dictionary key",
     "aqa=1",
     5,
     {Dictionary{{{"aqa", {Integer(1), {}}}}}},
     nullptr},
    {"0x72 in dictionary key",
     "ara=1",
     5,
     {Dictionary{{{"ara", {Integer(1), {}}}}}},
     nullptr},
    {"0x73 in dictionary key",
     "asa=1",
     5,
     {Dictionary{{{"asa", {Integer(1), {}}}}}},
     nullptr},
    {"0x74 in dictionary key",
     "ata=1",
     5,
     {Dictionary{{{"ata", {Integer(1), {}}}}}},
     nullptr},
    {"0x75 in dictionary key",
     "aua=1",
     5,
     {Dictionary{{{"aua", {Integ
"""


```
Response:
The user wants a summary of the functionality of the provided C++ code snippet.
The code is part of a test file (`spdy_framer_test.cc`) for a SPDY/HTTP2 framer.
The primary function of the code is to test the serialization of various HTTP/2 frame types.
It creates different frame objects (like DATA, RST_STREAM, SETTINGS, etc.) with specific parameters and then serializes them into byte arrays.
These serialized byte arrays are then compared against expected byte arrays to ensure the serialization is correct.

Here's a breakdown of the tested frame types and their associated functionalities:

- **DATA frames**: Sending data payloads, including empty payloads, payloads with FIN flag, and padding.
- **RST_STREAM frames**: Resetting a stream with different error codes.
- **SETTINGS frames**: Sending configuration parameters for the HTTP/2 connection.
- **PING frames**: Sending and acknowledging PING frames for keep-alive or latency measurement.
- **GOAWAY frames**: Gracefully shutting down the HTTP/2 connection.
- **HEADERS frames**: Sending HTTP headers, including variations with FIN flag, priority, and padding.
- **WINDOW_UPDATE frames**: Updating the flow control window for a stream or the connection.
- **PUSH_PROMISE frames**:  Initiating a server-initiated push stream.
- **CONTINUATION frames**: Continuing a header block that doesn't fit in a single HEADERS or PUSH_PROMISE frame.

The code uses Google Test framework (`TEST_P`) for parameterized testing, allowing it to run the same tests with different configurations (e.g., with and without output buffering).

Regarding JavaScript: This code is C++ and part of the Chromium network stack, which handles the underlying network communication for web browsers and other applications. While JavaScript interacts with network requests, it doesn't directly manipulate the raw HTTP/2 frames. However, the correct functionality of this C++ code is crucial for JavaScript's ability to communicate with web servers using HTTP/2.

Regarding user errors: The tests implicitly demonstrate potential errors in the framing process. For example, if the serialization logic is faulty, the generated byte arrays won't match the expected ones. This could lead to parsing errors on the receiving end.

Regarding debugging: These tests serve as a crucial debugging tool for developers working on the HTTP/2 implementation. If an issue arises with HTTP/2 communication, examining the serialized frames can help pinpoint the problem.
这是 Chromium 网络栈中 `net/third_party/quiche/src/quiche/http2/core/spdy_framer_test.cc` 文件的第三部分代码。

**功能归纳:**

这部分代码主要测试了 `SpdyFramer` 类生成（序列化）各种 HTTP/2 帧的功能。具体来说，它测试了以下几种帧的创建和序列化：

1. **DATA 帧**:  测试了创建包含不同数据的 DATA 帧，包括：
    *   带有填充的 DATA 帧
    *   带有负字节数据的 DATA 帧
    *   带有 FIN 标志的 DATA 帧
    *   空的 DATA 帧
    *   带有最大流 ID 的 DATA 帧

2. **RST_STREAM 帧**: 测试了创建 RST\_STREAM 帧，用于终止流，包括：
    *   带有默认错误码的 RST\_STREAM 帧
    *   带有最大流 ID 的 RST\_STREAM 帧
    *   带有最大错误码的 RST\_STREAM 帧

3. **SETTINGS 帧**: 测试了创建 SETTINGS 帧，用于设置连接级别的参数，包括：
    *   带有网络字节序的 SETTINGS 帧
    *   包含多个设置项的 SETTINGS 帧
    *   空的 SETTINGS 帧

4. **PING 帧**: 测试了创建 PING 帧，用于测量 RTT 或保持连接，包括：
    *   普通的 PING 帧
    *   带有 ACK 标志的 PING 帧

5. **GOAWAY 帧**: 测试了创建 GOAWAY 帧，用于优雅地关闭连接，包括：
    *   带有默认参数的 GOAWAY 帧
    *   带有最大流 ID 和错误码的 GOAWAY 帧

6. **HEADERS 帧 (未压缩)**: 测试了创建未压缩的 HEADERS 帧，用于发送 HTTP 头部，包括各种情况：
    *   不带 FIN 标志
    *   带有 0 长度头部名称，带 FIN 标志，最大流 ID
    *   带有 0 长度头部值，带 FIN 标志，最大流 ID
    *   带有 0 长度头部值，带 FIN 标志，最大流 ID，带优先级
    *   带有 0 长度头部值，带 FIN 标志，最大流 ID，带优先级，独占 Parent Stream 为 0
    *   带有 0 长度头部值，带 FIN 标志，最大流 ID，带优先级，非独占 Parent Stream 为最大流 ID
    *   带有 0 长度头部名称，带 FIN 标志，最大流 ID，带填充

7. **WINDOW_UPDATE 帧**: 测试了创建 WINDOW\_UPDATE 帧，用于控制流，包括：
    *   带有默认增量的 WINDOW\_UPDATE 帧
    *   带有最大流 ID 的 WINDOW\_UPDATE 帧
    *   带有最大窗口增量的 WINDOW\_UPDATE 帧

8. **PUSH_PROMISE 帧 (未压缩)**: 测试了创建未压缩的 PUSH\_PROMISE 帧，用于服务器发起推送，包括：
    *   不带填充
    *   带一个字节填充
    *   带 177 个字节填充

9. **CONTINUATION 帧 (未压缩)**: 测试了创建未压缩的 CONTINUATION 帧，用于继续发送 HEADERS 或 PUSH\_PROMISE 帧的数据。

**与 JavaScript 的关系：**

虽然这段 C++ 代码本身不是 JavaScript，但它直接影响着浏览器中 JavaScript 的网络请求功能。当 JavaScript 代码发起一个 HTTP/2 请求时，Chromium 的网络栈会使用类似 `SpdyFramer` 这样的类将 JavaScript 的请求信息（例如 URL、头部等）序列化成符合 HTTP/2 协议的帧格式。服务器返回的 HTTP/2 帧也会被类似的模块解析成 JavaScript 可以理解的数据结构。

**举例说明:**

假设一个 JavaScript 代码发起一个简单的 GET 请求：

```javascript
fetch('https://example.com/data');
```

Chromium 的网络栈会将这个请求转换成一系列 HTTP/2 帧，其中可能包括一个 HEADERS 帧。`SpdyFramer` 的相关代码就负责生成这个 HEADERS 帧，确保它包含了请求方法 (GET)、URL (encoded in headers like `:path`, `:authority`) 等信息，并设置了 `END_HEADERS` 标志。

**逻辑推理与假设输入输出:**

以 DATA 帧的测试为例：

**假设输入:** `SpdyDataIR data_ir(/* stream_id = */ 1, "hello"); data_ir.set_fin(true);`

**逻辑推理:**  `framer_.SerializeData(data_ir)`  会根据 `data_ir` 中的信息，包括流 ID (1)，数据内容 ("hello") 和 FIN 标志 (true)，将这些信息编码成符合 HTTP/2 DATA 帧格式的字节流。

**预期输出:**  `kH2FrameData` 数组所定义的字节序列: `0x00, 0x00, 0x05, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x68, 0x65, 0x6c, 0x6c, 0x6f`。这个字节序列包含了帧长度，帧类型 (DATA)，标志位 (END_STREAM)，流 ID 以及数据负载 "hello"。

**用户或编程常见的使用错误:**

*   **错误地设置帧的长度:** 手动构建 HTTP/2 帧时，可能会错误计算帧的长度，导致接收方解析错误。例如，DATA 帧的长度字段不包含帧头部的 9 个字节。
*   **忘记设置必要的标志位:** 例如，发送完最后一个 DATA 帧时，忘记设置 `END_STREAM` 标志，接收方会认为数据传输还没有结束。
*   **流 ID 使用错误:**  HTTP/2 的流 ID 有特定的规则，例如 0 号流用于连接级别的控制帧。错误地使用流 ID 会导致协议错误。
*   **设置了超出允许范围的参数值:** 例如，在 SETTINGS 帧中设置了超出允许范围的窗口大小或并发流数量。

**用户操作如何一步步到达这里 (调试线索):**

1. **用户在浏览器中访问一个使用 HTTP/2 协议的网站。**
2. **浏览器 (Chromium) 的网络栈开始与服务器建立 HTTP/2 连接。**
3. **JavaScript 代码通过 `fetch` 或 `XMLHttpRequest` 发起网络请求。**
4. **网络栈中的 HTTP/2 实现需要将这些请求信息编码成 HTTP/2 帧。**  这时，`SpdyFramer` 类就会被调用，根据请求类型 (例如 GET, POST) 和头部信息，创建对应的 HEADERS 帧和 DATA 帧。
5. **如果服务器需要推送资源，`SpdyFramer` 会被用来创建 PUSH\_PROMISE 帧。**
6. **在调试网络问题时，开发者可能会抓取网络包，查看实际发送和接收的 HTTP/2 帧的内容。**  如果发现帧的格式有问题，就需要查看 `SpdyFramer` 的代码，例如这个测试文件，来理解帧是如何被序列化的，并找出错误的原因。

**总结这部分代码的功能：**

这部分 `spdy_framer_test.cc` 代码是 `SpdyFramer` 类的单元测试，它详细验证了 `SpdyFramer` 能否正确地将各种类型的 HTTP/2 帧从内部表示 (例如 `SpdyDataIR`, `SpdyHeadersIR`) 序列化成符合协议规范的二进制数据。这些测试覆盖了不同帧类型的各种参数组合和边界情况，确保了 HTTP/2 帧生成逻辑的正确性和健壮性。

### 提示词
```
这是目录为net/third_party/quiche/src/quiche/http2/core/spdy_framer_test.cc的chromium 网络栈的源代码文件， 请列举一下它的功能, 
如果它与javascript的功能有关系，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索。
这是第3部分，共7部分，请归纳一下它的功能
```

### 源代码
```cpp
ta_ir(/* stream_id = */ 1, bytes);
    // The pad length field itself is used for the 1-byte padding and no padding
    // payload is needed.
    data_ir.set_padding_len(1);
    SpdySerializedFrame frame(framer_.SerializeData(data_ir));
    CompareFrame(kDescription, frame, kH2FrameData,
                 ABSL_ARRAYSIZE(kH2FrameData));

    frame = framer_.SerializeDataFrameHeaderWithPaddingLengthField(data_ir);
    CompareCharArraysWithHexError(
        kDescription, reinterpret_cast<const unsigned char*>(frame.data()),
        kDataFrameMinimumSize, kH2FrameData, kDataFrameMinimumSize);
  }

  {
    const char kDescription[] = "Data frame with negative data byte, no FIN";
    const unsigned char kH2FrameData[] = {
        0x00, 0x00, 0x01,        // Length: 1
        0x00,                    //   Type: DATA
        0x00,                    //  Flags: none
        0x00, 0x00, 0x00, 0x01,  // Stream: 1
        0xff,                    // Payload
    };
    SpdyDataIR data_ir(/* stream_id = */ 1, "\xff");
    SpdySerializedFrame frame(framer_.SerializeData(data_ir));
    CompareFrame(kDescription, frame, kH2FrameData,
                 ABSL_ARRAYSIZE(kH2FrameData));
  }

  {
    const char kDescription[] = "'hello' data frame, with FIN";
    const unsigned char kH2FrameData[] = {
        0x00, 0x00, 0x05,        // Length: 5
        0x00,                    //   Type: DATA
        0x01,                    //  Flags: END_STREAM
        0x00, 0x00, 0x00, 0x01,  // Stream: 1
        0x68, 0x65, 0x6c, 0x6c,  // Payload
        0x6f,                    //
    };
    SpdyDataIR data_ir(/* stream_id = */ 1, "hello");
    data_ir.set_fin(true);
    SpdySerializedFrame frame(framer_.SerializeData(data_ir));
    CompareFrame(kDescription, frame, kH2FrameData,
                 ABSL_ARRAYSIZE(kH2FrameData));
  }

  {
    const char kDescription[] = "Empty data frame";
    const unsigned char kH2FrameData[] = {
        0x00, 0x00, 0x00,        // Length: 0
        0x00,                    //   Type: DATA
        0x00,                    //  Flags: none
        0x00, 0x00, 0x00, 0x01,  // Stream: 1
    };
    SpdyDataIR data_ir(/* stream_id = */ 1, "");
    SpdySerializedFrame frame(framer_.SerializeData(data_ir));
    CompareFrame(kDescription, frame, kH2FrameData,
                 ABSL_ARRAYSIZE(kH2FrameData));

    frame = framer_.SerializeDataFrameHeaderWithPaddingLengthField(data_ir);
    CompareCharArraysWithHexError(
        kDescription, reinterpret_cast<const unsigned char*>(frame.data()),
        kDataFrameMinimumSize, kH2FrameData, kDataFrameMinimumSize);
  }

  {
    const char kDescription[] = "Data frame with max stream ID";
    const unsigned char kH2FrameData[] = {
        0x00, 0x00, 0x05,        // Length: 5
        0x00,                    //   Type: DATA
        0x01,                    //  Flags: END_STREAM
        0x7f, 0xff, 0xff, 0xff,  // Stream: 0x7fffffff
        0x68, 0x65, 0x6c, 0x6c,  // Payload
        0x6f,                    //
    };
    SpdyDataIR data_ir(/* stream_id = */ 0x7fffffff, "hello");
    data_ir.set_fin(true);
    SpdySerializedFrame frame(framer_.SerializeData(data_ir));
    CompareFrame(kDescription, frame, kH2FrameData,
                 ABSL_ARRAYSIZE(kH2FrameData));
  }
}

TEST_P(SpdyFramerTest, CreateRstStream) {
  {
    const char kDescription[] = "RST_STREAM frame";
    const unsigned char kH2FrameData[] = {
        0x00, 0x00, 0x04,        // Length: 4
        0x03,                    //   Type: RST_STREAM
        0x00,                    //  Flags: none
        0x00, 0x00, 0x00, 0x01,  // Stream: 1
        0x00, 0x00, 0x00, 0x01,  //  Error: PROTOCOL_ERROR
    };
    SpdyRstStreamIR rst_stream(/* stream_id = */ 1, ERROR_CODE_PROTOCOL_ERROR);
    SpdySerializedFrame frame(framer_.SerializeRstStream(rst_stream));
    if (use_output_) {
      ASSERT_TRUE(framer_.SerializeRstStream(rst_stream, &output_));
      frame = MakeSerializedFrame(output_.Begin(), output_.Size());
    }
    CompareFrame(kDescription, frame, kH2FrameData,
                 ABSL_ARRAYSIZE(kH2FrameData));
  }

  {
    const char kDescription[] = "RST_STREAM frame with max stream ID";
    const unsigned char kH2FrameData[] = {
        0x00, 0x00, 0x04,        // Length: 4
        0x03,                    //   Type: RST_STREAM
        0x00,                    //  Flags: none
        0x7f, 0xff, 0xff, 0xff,  // Stream: 0x7fffffff
        0x00, 0x00, 0x00, 0x01,  //  Error: PROTOCOL_ERROR
    };
    SpdyRstStreamIR rst_stream(/* stream_id = */ 0x7FFFFFFF,
                               ERROR_CODE_PROTOCOL_ERROR);
    SpdySerializedFrame frame(framer_.SerializeRstStream(rst_stream));
    if (use_output_) {
      output_.Reset();
      ASSERT_TRUE(framer_.SerializeRstStream(rst_stream, &output_));
      frame = MakeSerializedFrame(output_.Begin(), output_.Size());
    }
    CompareFrame(kDescription, frame, kH2FrameData,
                 ABSL_ARRAYSIZE(kH2FrameData));
  }

  {
    const char kDescription[] = "RST_STREAM frame with max status code";
    const unsigned char kH2FrameData[] = {
        0x00, 0x00, 0x04,        // Length: 4
        0x03,                    //   Type: RST_STREAM
        0x00,                    //  Flags: none
        0x7f, 0xff, 0xff, 0xff,  // Stream: 0x7fffffff
        0x00, 0x00, 0x00, 0x02,  //  Error: INTERNAL_ERROR
    };
    SpdyRstStreamIR rst_stream(/* stream_id = */ 0x7FFFFFFF,
                               ERROR_CODE_INTERNAL_ERROR);
    SpdySerializedFrame frame(framer_.SerializeRstStream(rst_stream));
    if (use_output_) {
      output_.Reset();
      ASSERT_TRUE(framer_.SerializeRstStream(rst_stream, &output_));
      frame = MakeSerializedFrame(output_.Begin(), output_.Size());
    }
    CompareFrame(kDescription, frame, kH2FrameData,
                 ABSL_ARRAYSIZE(kH2FrameData));
  }
}

TEST_P(SpdyFramerTest, CreateSettings) {
  {
    const char kDescription[] = "Network byte order SETTINGS frame";
    const unsigned char kH2FrameData[] = {
        0x00, 0x00, 0x06,        // Length: 6
        0x04,                    //   Type: SETTINGS
        0x00,                    //  Flags: none
        0x00, 0x00, 0x00, 0x00,  // Stream: 0
        0x00, 0x04,              //  Param: INITIAL_WINDOW_SIZE
        0x0a, 0x0b, 0x0c, 0x0d,  //  Value: 168496141
    };

    uint32_t kValue = 0x0a0b0c0d;
    SpdySettingsIR settings_ir;

    SpdyKnownSettingsId kId = SETTINGS_INITIAL_WINDOW_SIZE;
    settings_ir.AddSetting(kId, kValue);

    SpdySerializedFrame frame(framer_.SerializeSettings(settings_ir));
    if (use_output_) {
      ASSERT_TRUE(framer_.SerializeSettings(settings_ir, &output_));
      frame = MakeSerializedFrame(output_.Begin(), output_.Size());
    }
    CompareFrame(kDescription, frame, kH2FrameData,
                 ABSL_ARRAYSIZE(kH2FrameData));
  }

  {
    const char kDescription[] = "Basic SETTINGS frame";
    // These end up seemingly out of order because of the way that our internal
    // ordering for settings_ir works. HTTP2 has no requirement on ordering on
    // the wire.
    const unsigned char kH2FrameData[] = {
        0x00, 0x00, 0x18,        // Length: 24
        0x04,                    //   Type: SETTINGS
        0x00,                    //  Flags: none
        0x00, 0x00, 0x00, 0x00,  // Stream: 0
        0x00, 0x01,              //  Param: HEADER_TABLE_SIZE
        0x00, 0x00, 0x00, 0x05,  //  Value: 5
        0x00, 0x02,              //  Param: ENABLE_PUSH
        0x00, 0x00, 0x00, 0x06,  //  Value: 6
        0x00, 0x03,              //  Param: MAX_CONCURRENT_STREAMS
        0x00, 0x00, 0x00, 0x07,  //  Value: 7
        0x00, 0x04,              //  Param: INITIAL_WINDOW_SIZE
        0x00, 0x00, 0x00, 0x08,  //  Value: 8
    };

    SpdySettingsIR settings_ir;
    settings_ir.AddSetting(SETTINGS_HEADER_TABLE_SIZE, 5);
    settings_ir.AddSetting(SETTINGS_ENABLE_PUSH, 6);
    settings_ir.AddSetting(SETTINGS_MAX_CONCURRENT_STREAMS, 7);
    settings_ir.AddSetting(SETTINGS_INITIAL_WINDOW_SIZE, 8);
    SpdySerializedFrame frame(framer_.SerializeSettings(settings_ir));
    if (use_output_) {
      output_.Reset();
      ASSERT_TRUE(framer_.SerializeSettings(settings_ir, &output_));
      frame = MakeSerializedFrame(output_.Begin(), output_.Size());
    }

    CompareFrame(kDescription, frame, kH2FrameData,
                 ABSL_ARRAYSIZE(kH2FrameData));
  }

  {
    const char kDescription[] = "Empty SETTINGS frame";
    const unsigned char kH2FrameData[] = {
        0x00, 0x00, 0x00,        // Length: 0
        0x04,                    //   Type: SETTINGS
        0x00,                    //  Flags: none
        0x00, 0x00, 0x00, 0x00,  // Stream: 0
    };
    SpdySettingsIR settings_ir;
    SpdySerializedFrame frame(framer_.SerializeSettings(settings_ir));
    if (use_output_) {
      output_.Reset();
      ASSERT_TRUE(framer_.SerializeSettings(settings_ir, &output_));
      frame = MakeSerializedFrame(output_.Begin(), output_.Size());
    }

    CompareFrame(kDescription, frame, kH2FrameData,
                 ABSL_ARRAYSIZE(kH2FrameData));
  }
}

TEST_P(SpdyFramerTest, CreatePingFrame) {
  {
    const char kDescription[] = "PING frame";
    const unsigned char kH2FrameData[] = {
        0x00, 0x00, 0x08,        // Length: 8
        0x06,                    //   Type: PING
        0x00,                    //  Flags: none
        0x00, 0x00, 0x00, 0x00,  // Stream: 0
        0x12, 0x34, 0x56, 0x78,  // Opaque
        0x9a, 0xbc, 0xde, 0xff,  //     Data
    };
    const unsigned char kH2FrameDataWithAck[] = {
        0x00, 0x00, 0x08,        // Length: 8
        0x06,                    //   Type: PING
        0x01,                    //  Flags: ACK
        0x00, 0x00, 0x00, 0x00,  // Stream: 0
        0x12, 0x34, 0x56, 0x78,  // Opaque
        0x9a, 0xbc, 0xde, 0xff,  //     Data
    };
    const SpdyPingId kPingId = 0x123456789abcdeffULL;
    SpdyPingIR ping_ir(kPingId);
    // Tests SpdyPingIR when the ping is not an ack.
    ASSERT_FALSE(ping_ir.is_ack());
    SpdySerializedFrame frame(framer_.SerializePing(ping_ir));
    if (use_output_) {
      ASSERT_TRUE(framer_.SerializePing(ping_ir, &output_));
      frame = MakeSerializedFrame(output_.Begin(), output_.Size());
    }
    CompareFrame(kDescription, frame, kH2FrameData,
                 ABSL_ARRAYSIZE(kH2FrameData));

    // Tests SpdyPingIR when the ping is an ack.
    ping_ir.set_is_ack(true);
    frame = framer_.SerializePing(ping_ir);
    if (use_output_) {
      output_.Reset();
      ASSERT_TRUE(framer_.SerializePing(ping_ir, &output_));
      frame = MakeSerializedFrame(output_.Begin(), output_.Size());
    }
    CompareFrame(kDescription, frame, kH2FrameDataWithAck,
                 ABSL_ARRAYSIZE(kH2FrameDataWithAck));
  }
}

TEST_P(SpdyFramerTest, CreateGoAway) {
  {
    const char kDescription[] = "GOAWAY frame";
    const unsigned char kH2FrameData[] = {
        0x00, 0x00, 0x0a,        // Length: 10
        0x07,                    //   Type: GOAWAY
        0x00,                    //  Flags: none
        0x00, 0x00, 0x00, 0x00,  // Stream: 0
        0x00, 0x00, 0x00, 0x00,  //   Last: 0
        0x00, 0x00, 0x00, 0x00,  //  Error: NO_ERROR
        0x47, 0x41,              // Description
    };
    SpdyGoAwayIR goaway_ir(/* last_good_stream_id = */ 0, ERROR_CODE_NO_ERROR,
                           "GA");
    SpdySerializedFrame frame(framer_.SerializeGoAway(goaway_ir));
    if (use_output_) {
      ASSERT_TRUE(framer_.SerializeGoAway(goaway_ir, &output_));
      frame = MakeSerializedFrame(output_.Begin(), output_.Size());
    }
    CompareFrame(kDescription, frame, kH2FrameData,
                 ABSL_ARRAYSIZE(kH2FrameData));
  }

  {
    const char kDescription[] = "GOAWAY frame with max stream ID, status";
    const unsigned char kH2FrameData[] = {
        0x00, 0x00, 0x0a,        // Length: 10
        0x07,                    //   Type: GOAWAY
        0x00,                    //  Flags: none
        0x00, 0x00, 0x00, 0x00,  // Stream: 0
        0x7f, 0xff, 0xff, 0xff,  //   Last: 0x7fffffff
        0x00, 0x00, 0x00, 0x02,  //  Error: INTERNAL_ERROR
        0x47, 0x41,              // Description
    };
    SpdyGoAwayIR goaway_ir(/* last_good_stream_id = */ 0x7FFFFFFF,
                           ERROR_CODE_INTERNAL_ERROR, "GA");
    SpdySerializedFrame frame(framer_.SerializeGoAway(goaway_ir));
    if (use_output_) {
      output_.Reset();
      ASSERT_TRUE(framer_.SerializeGoAway(goaway_ir, &output_));
      frame = MakeSerializedFrame(output_.Begin(), output_.Size());
    }
    CompareFrame(kDescription, frame, kH2FrameData,
                 ABSL_ARRAYSIZE(kH2FrameData));
  }
}

TEST_P(SpdyFramerTest, CreateHeadersUncompressed) {
  SpdyFramer framer(SpdyFramer::DISABLE_COMPRESSION);

  {
    const char kDescription[] = "HEADERS frame, no FIN";
    // frame-format off
    const unsigned char kH2FrameData[] = {
        0x00, 0x00, 0x12,        // Length: 18
        0x01,                    //   Type: HEADERS
        0x04,                    //  Flags: END_HEADERS
        0x00, 0x00, 0x00, 0x01,  // Stream: 1

        0x00,              // Unindexed Entry
        0x03,              // Name Len: 3
        0x62, 0x61, 0x72,  // bar
        0x03,              // Value Len: 3
        0x66, 0x6f, 0x6f,  // foo

        0x00,              // Unindexed Entry
        0x03,              // Name Len: 3
        0x66, 0x6f, 0x6f,  // foo
        0x03,              // Value Len: 3
        0x62, 0x61, 0x72,  // bar
    };
    // frame-format on
    SpdyHeadersIR headers(/* stream_id = */ 1);
    headers.SetHeader("bar", "foo");
    headers.SetHeader("foo", "bar");
    SpdySerializedFrame frame(SpdyFramerPeer::SerializeHeaders(
        &framer, headers, use_output_ ? &output_ : nullptr));
    CompareFrame(kDescription, frame, kH2FrameData,
                 ABSL_ARRAYSIZE(kH2FrameData));
  }

  {
    const char kDescription[] =
        "HEADERS frame with a 0-length header name, FIN, max stream ID";
    // frame-format off
    const unsigned char kH2FrameData[] = {
        0x00, 0x00, 0x0f,        // Length: 15
        0x01,                    //   Type: HEADERS
        0x05,                    //  Flags: END_STREAM|END_HEADERS
        0x7f, 0xff, 0xff, 0xff,  // Stream: 2147483647

        0x00,              // Unindexed Entry
        0x00,              // Name Len: 0
        0x03,              // Value Len: 3
        0x66, 0x6f, 0x6f,  // foo

        0x00,              // Unindexed Entry
        0x03,              // Name Len: 3
        0x66, 0x6f, 0x6f,  // foo
        0x03,              // Value Len: 3
        0x62, 0x61, 0x72,  // bar
    };
    // frame-format on
    SpdyHeadersIR headers(/* stream_id = */ 0x7fffffff);
    headers.set_fin(true);
    headers.SetHeader("", "foo");
    headers.SetHeader("foo", "bar");
    SpdySerializedFrame frame(SpdyFramerPeer::SerializeHeaders(
        &framer, headers, use_output_ ? &output_ : nullptr));
    CompareFrame(kDescription, frame, kH2FrameData,
                 ABSL_ARRAYSIZE(kH2FrameData));
  }

  {
    const char kDescription[] =
        "HEADERS frame with a 0-length header val, FIN, max stream ID";
    // frame-format off
    const unsigned char kH2FrameData[] = {
        0x00, 0x00, 0x0f,        // Length: 15
        0x01,                    //   Type: HEADERS
        0x05,                    //  Flags: END_STREAM|END_HEADERS
        0x7f, 0xff, 0xff, 0xff,  // Stream: 2147483647

        0x00,              // Unindexed Entry
        0x03,              // Name Len: 3
        0x62, 0x61, 0x72,  // bar
        0x03,              // Value Len: 3
        0x66, 0x6f, 0x6f,  // foo

        0x00,              // Unindexed Entry
        0x03,              // Name Len: 3
        0x66, 0x6f, 0x6f,  // foo
        0x00,              // Value Len: 0
    };
    // frame-format on
    SpdyHeadersIR headers_ir(/* stream_id = */ 0x7fffffff);
    headers_ir.set_fin(true);
    headers_ir.SetHeader("bar", "foo");
    headers_ir.SetHeader("foo", "");
    SpdySerializedFrame frame(SpdyFramerPeer::SerializeHeaders(
        &framer, headers_ir, use_output_ ? &output_ : nullptr));
    CompareFrame(kDescription, frame, kH2FrameData,
                 ABSL_ARRAYSIZE(kH2FrameData));
  }

  {
    const char kDescription[] =
        "HEADERS frame with a 0-length header val, FIN, max stream ID, pri";

    // frame-format off
    const unsigned char kH2FrameData[] = {
        0x00, 0x00, 0x14,        // Length: 20
        0x01,                    //   Type: HEADERS
        0x25,                    //  Flags: END_STREAM|END_HEADERS|PRIORITY
        0x7f, 0xff, 0xff, 0xff,  // Stream: 2147483647
        0x00, 0x00, 0x00, 0x00,  // Parent: 0
        0xdb,                    // Weight: 220

        0x00,              // Unindexed Entry
        0x03,              // Name Len: 3
        0x62, 0x61, 0x72,  // bar
        0x03,              // Value Len: 3
        0x66, 0x6f, 0x6f,  // foo

        0x00,              // Unindexed Entry
        0x03,              // Name Len: 3
        0x66, 0x6f, 0x6f,  // foo
        0x00,              // Value Len: 0
    };
    // frame-format on
    SpdyHeadersIR headers_ir(/* stream_id = */ 0x7fffffff);
    headers_ir.set_fin(true);
    headers_ir.set_has_priority(true);
    headers_ir.set_weight(220);
    headers_ir.SetHeader("bar", "foo");
    headers_ir.SetHeader("foo", "");
    SpdySerializedFrame frame(SpdyFramerPeer::SerializeHeaders(
        &framer, headers_ir, use_output_ ? &output_ : nullptr));
    CompareFrame(kDescription, frame, kH2FrameData,
                 ABSL_ARRAYSIZE(kH2FrameData));
  }

  {
    const char kDescription[] =
        "HEADERS frame with a 0-length header val, FIN, max stream ID, pri, "
        "exclusive=true, parent_stream=0";

    // frame-format off
    const unsigned char kV4FrameData[] = {
        0x00, 0x00, 0x14,        // Length: 20
        0x01,                    //   Type: HEADERS
        0x25,                    //  Flags: END_STREAM|END_HEADERS|PRIORITY
        0x7f, 0xff, 0xff, 0xff,  // Stream: 2147483647
        0x80, 0x00, 0x00, 0x00,  // Parent: 0 (Exclusive)
        0xdb,                    // Weight: 220

        0x00,              // Unindexed Entry
        0x03,              // Name Len: 3
        0x62, 0x61, 0x72,  // bar
        0x03,              // Value Len: 3
        0x66, 0x6f, 0x6f,  // foo

        0x00,              // Unindexed Entry
        0x03,              // Name Len: 3
        0x66, 0x6f, 0x6f,  // foo
        0x00,              // Value Len: 0
    };
    // frame-format on
    SpdyHeadersIR headers_ir(/* stream_id = */ 0x7fffffff);
    headers_ir.set_fin(true);
    headers_ir.set_has_priority(true);
    headers_ir.set_weight(220);
    headers_ir.set_exclusive(true);
    headers_ir.set_parent_stream_id(0);
    headers_ir.SetHeader("bar", "foo");
    headers_ir.SetHeader("foo", "");
    SpdySerializedFrame frame(SpdyFramerPeer::SerializeHeaders(
        &framer, headers_ir, use_output_ ? &output_ : nullptr));
    CompareFrame(kDescription, frame, kV4FrameData,
                 ABSL_ARRAYSIZE(kV4FrameData));
  }

  {
    const char kDescription[] =
        "HEADERS frame with a 0-length header val, FIN, max stream ID, pri, "
        "exclusive=false, parent_stream=max stream ID";

    // frame-format off
    const unsigned char kV4FrameData[] = {
        0x00, 0x00, 0x14,        // Length: 20
        0x01,                    //   Type: HEADERS
        0x25,                    //  Flags: END_STREAM|END_HEADERS|PRIORITY
        0x7f, 0xff, 0xff, 0xff,  // Stream: 2147483647
        0x7f, 0xff, 0xff, 0xff,  // Parent: 2147483647
        0xdb,                    // Weight: 220

        0x00,              // Unindexed Entry
        0x03,              // Name Len: 3
        0x62, 0x61, 0x72,  // bar
        0x03,              // Value Len: 3
        0x66, 0x6f, 0x6f,  // foo

        0x00,              // Unindexed Entry
        0x03,              // Name Len: 3
        0x66, 0x6f, 0x6f,  // foo
        0x00,              // Value Len: 0
    };
    // frame-format on
    SpdyHeadersIR headers_ir(/* stream_id = */ 0x7fffffff);
    headers_ir.set_fin(true);
    headers_ir.set_has_priority(true);
    headers_ir.set_weight(220);
    headers_ir.set_exclusive(false);
    headers_ir.set_parent_stream_id(0x7fffffff);
    headers_ir.SetHeader("bar", "foo");
    headers_ir.SetHeader("foo", "");
    SpdySerializedFrame frame(SpdyFramerPeer::SerializeHeaders(
        &framer, headers_ir, use_output_ ? &output_ : nullptr));
    CompareFrame(kDescription, frame, kV4FrameData,
                 ABSL_ARRAYSIZE(kV4FrameData));
  }

  {
    const char kDescription[] =
        "HEADERS frame with a 0-length header name, FIN, max stream ID, padded";

    // frame-format off
    const unsigned char kH2FrameData[] = {
        0x00, 0x00, 0x15,        // Length: 21
        0x01,                    //   Type: HEADERS
        0x0d,                    //  Flags: END_STREAM|END_HEADERS|PADDED
        0x7f, 0xff, 0xff, 0xff,  // Stream: 2147483647
        0x05,                    // PadLen: 5 trailing bytes

        0x00,              // Unindexed Entry
        0x00,              // Name Len: 0
        0x03,              // Value Len: 3
        0x66, 0x6f, 0x6f,  // foo

        0x00,              // Unindexed Entry
        0x03,              // Name Len: 3
        0x66, 0x6f, 0x6f,  // foo
        0x03,              // Value Len: 3
        0x62, 0x61, 0x72,  // bar

        0x00, 0x00, 0x00, 0x00,  // Padding
        0x00,                    // Padding
    };
    // frame-format on
    SpdyHeadersIR headers_ir(/* stream_id = */ 0x7fffffff);
    headers_ir.set_fin(true);
    headers_ir.SetHeader("", "foo");
    headers_ir.SetHeader("foo", "bar");
    headers_ir.set_padding_len(6);
    SpdySerializedFrame frame(SpdyFramerPeer::SerializeHeaders(
        &framer, headers_ir, use_output_ ? &output_ : nullptr));
    CompareFrame(kDescription, frame, kH2FrameData,
                 ABSL_ARRAYSIZE(kH2FrameData));
  }
}

TEST_P(SpdyFramerTest, CreateWindowUpdate) {
  {
    const char kDescription[] = "WINDOW_UPDATE frame";
    const unsigned char kH2FrameData[] = {
        0x00, 0x00, 0x04,        // Length: 4
        0x08,                    //   Type: WINDOW_UPDATE
        0x00,                    //  Flags: none
        0x00, 0x00, 0x00, 0x01,  // Stream: 1
        0x00, 0x00, 0x00, 0x01,  // Increment: 1
    };
    SpdySerializedFrame frame(framer_.SerializeWindowUpdate(
        SpdyWindowUpdateIR(/* stream_id = */ 1, /* delta = */ 1)));
    if (use_output_) {
      output_.Reset();
      ASSERT_TRUE(framer_.SerializeWindowUpdate(
          SpdyWindowUpdateIR(/* stream_id = */ 1, /* delta = */ 1), &output_));
      frame = MakeSerializedFrame(output_.Begin(), output_.Size());
    }
    CompareFrame(kDescription, frame, kH2FrameData,
                 ABSL_ARRAYSIZE(kH2FrameData));
  }

  {
    const char kDescription[] = "WINDOW_UPDATE frame with max stream ID";
    const unsigned char kH2FrameData[] = {
        0x00, 0x00, 0x04,        // Length: 4
        0x08,                    //   Type: WINDOW_UPDATE
        0x00,                    //  Flags: none
        0x7f, 0xff, 0xff, 0xff,  // Stream: 0x7fffffff
        0x00, 0x00, 0x00, 0x01,  // Increment: 1
    };
    SpdySerializedFrame frame(framer_.SerializeWindowUpdate(
        SpdyWindowUpdateIR(/* stream_id = */ 0x7FFFFFFF, /* delta = */ 1)));
    if (use_output_) {
      output_.Reset();
      ASSERT_TRUE(framer_.SerializeWindowUpdate(
          SpdyWindowUpdateIR(/* stream_id = */ 0x7FFFFFFF, /* delta = */ 1),
          &output_));
      frame = MakeSerializedFrame(output_.Begin(), output_.Size());
    }
    CompareFrame(kDescription, frame, kH2FrameData,
                 ABSL_ARRAYSIZE(kH2FrameData));
  }

  {
    const char kDescription[] = "WINDOW_UPDATE frame with max window delta";
    const unsigned char kH2FrameData[] = {
        0x00, 0x00, 0x04,        // Length: 4
        0x08,                    //   Type: WINDOW_UPDATE
        0x00,                    //  Flags: none
        0x00, 0x00, 0x00, 0x01,  // Stream: 1
        0x7f, 0xff, 0xff, 0xff,  // Increment: 0x7fffffff
    };
    SpdySerializedFrame frame(framer_.SerializeWindowUpdate(
        SpdyWindowUpdateIR(/* stream_id = */ 1, /* delta = */ 0x7FFFFFFF)));
    if (use_output_) {
      output_.Reset();
      ASSERT_TRUE(framer_.SerializeWindowUpdate(
          SpdyWindowUpdateIR(/* stream_id = */ 1, /* delta = */ 0x7FFFFFFF),
          &output_));
      frame = MakeSerializedFrame(output_.Begin(), output_.Size());
    }
    CompareFrame(kDescription, frame, kH2FrameData,
                 ABSL_ARRAYSIZE(kH2FrameData));
  }
}

TEST_P(SpdyFramerTest, CreatePushPromiseUncompressed) {
  {
    // Test framing PUSH_PROMISE without padding.
    SpdyFramer framer(SpdyFramer::DISABLE_COMPRESSION);
    const char kDescription[] = "PUSH_PROMISE frame without padding";

    // frame-format off
    const unsigned char kFrameData[] = {
        0x00, 0x00, 0x16,        // Length: 22
        0x05,                    //   Type: PUSH_PROMISE
        0x04,                    //  Flags: END_HEADERS
        0x00, 0x00, 0x00, 0x29,  // Stream: 41
        0x00, 0x00, 0x00, 0x3a,  // Promise: 58

        0x00,              // Unindexed Entry
        0x03,              // Name Len: 3
        0x62, 0x61, 0x72,  // bar
        0x03,              // Value Len: 3
        0x66, 0x6f, 0x6f,  // foo

        0x00,              // Unindexed Entry
        0x03,              // Name Len: 3
        0x66, 0x6f, 0x6f,  // foo
        0x03,              // Value Len: 3
        0x62, 0x61, 0x72,  // bar
    };
    // frame-format on

    SpdyPushPromiseIR push_promise(/* stream_id = */ 41,
                                   /* promised_stream_id = */ 58);
    push_promise.SetHeader("bar", "foo");
    push_promise.SetHeader("foo", "bar");
    SpdySerializedFrame frame(SpdyFramerPeer::SerializePushPromise(
        &framer, push_promise, use_output_ ? &output_ : nullptr));
    CompareFrame(kDescription, frame, kFrameData, ABSL_ARRAYSIZE(kFrameData));
  }

  {
    // Test framing PUSH_PROMISE with one byte of padding.
    SpdyFramer framer(SpdyFramer::DISABLE_COMPRESSION);
    const char kDescription[] = "PUSH_PROMISE frame with one byte of padding";

    // frame-format off
    const unsigned char kFrameData[] = {
        0x00, 0x00, 0x17,        // Length: 23
        0x05,                    //   Type: PUSH_PROMISE
        0x0c,                    //  Flags: END_HEADERS|PADDED
        0x00, 0x00, 0x00, 0x29,  // Stream: 41
        0x00,                    // PadLen: 0 trailing bytes
        0x00, 0x00, 0x00, 0x3a,  // Promise: 58

        0x00,              // Unindexed Entry
        0x03,              // Name Len: 3
        0x62, 0x61, 0x72,  // bar
        0x03,              // Value Len: 3
        0x66, 0x6f, 0x6f,  // foo

        0x00,              // Unindexed Entry
        0x03,              // Name Len: 3
        0x66, 0x6f, 0x6f,  // foo
        0x03,              // Value Len: 3
        0x62, 0x61, 0x72,  // bar
    };
    // frame-format on

    SpdyPushPromiseIR push_promise(/* stream_id = */ 41,
                                   /* promised_stream_id = */ 58);
    push_promise.set_padding_len(1);
    push_promise.SetHeader("bar", "foo");
    push_promise.SetHeader("foo", "bar");
    output_.Reset();
    SpdySerializedFrame frame(SpdyFramerPeer::SerializePushPromise(
        &framer, push_promise, use_output_ ? &output_ : nullptr));

    CompareFrame(kDescription, frame, kFrameData, ABSL_ARRAYSIZE(kFrameData));
  }

  {
    // Test framing PUSH_PROMISE with 177 bytes of padding.
    SpdyFramer framer(SpdyFramer::DISABLE_COMPRESSION);
    const char kDescription[] = "PUSH_PROMISE frame with 177 bytes of padding";

    // frame-format off
    // clang-format off
    const unsigned char kFrameData[] = {
        0x00, 0x00, 0xc7,        // Length: 199
        0x05,                    //   Type: PUSH_PROMISE
        0x0c,                    //  Flags: END_HEADERS|PADDED
        0x00, 0x00, 0x00, 0x2a,  // Stream: 42
        0xb0,                    // PadLen: 176 trailing bytes
        0x00, 0x00, 0x00, 0x39,  // Promise: 57

        0x00,                    // Unindexed Entry
        0x03,                    // Name Len: 3
        0x62, 0x61, 0x72,        // bar
        0x03,                    // Value Len: 3
        0x66, 0x6f, 0x6f,        // foo

        0x00,                    // Unindexed Entry
        0x03,                    // Name Len: 3
        0x66, 0x6f, 0x6f,        // foo
        0x03,                    // Value Len: 3
        0x62, 0x61, 0x72,        // bar

      // Padding of 176 0x00(s).
      0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00, 0x00,  0x00,  0x00,
      0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00, 0x00,  0x00,  0x00,
      0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00, 0x00,  0x00,  0x00,
      0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00, 0x00,  0x00,  0x00,
      0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00, 0x00,  0x00,  0x00,
      0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00, 0x00,  0x00,  0x00,
      0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00, 0x00,  0x00,  0x00,
      0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00, 0x00,  0x00,  0x00,
      0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00, 0x00,  0x00,  0x00,
      0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00, 0x00,  0x00,  0x00,
      0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00, 0x00,  0x00,  0x00,
      0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00, 0x00,  0x00,  0x00,
      0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00, 0x00,  0x00,  0x00,
      0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00, 0x00,  0x00,  0x00,
      0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00, 0x00,  0x00,  0x00,
      0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00, 0x00,  0x00,  0x00,
    };
    // clang-format on
    // frame-format on

    SpdyPushPromiseIR push_promise(/* stream_id = */ 42,
                                   /* promised_stream_id = */ 57);
    push_promise.set_padding_len(177);
    push_promise.SetHeader("bar", "foo");
    push_promise.SetHeader("foo", "bar");
    output_.Reset();
    SpdySerializedFrame frame(SpdyFramerPeer::SerializePushPromise(
        &framer, push_promise, use_output_ ? &output_ : nullptr));

    CompareFrame(kDescription, frame, kFrameData, ABSL_ARRAYSIZE(kFrameData));
  }
}

// Regression test for https://crbug.com/464748.
TEST_P(SpdyFramerTest, GetNumberRequiredContinuationFrames) {
  EXPECT_EQ(1u, GetNumberRequiredContinuationFrames(16383 + 16374));
  EXPECT_EQ(2u, GetNumberRequiredContinuationFrames(16383 + 16374 + 1));
  EXPECT_EQ(2u, GetNumberRequiredContinuationFrames(16383 + 2 * 16374));
  EXPECT_EQ(3u, GetNumberRequiredContinuationFrames(16383 + 2 * 16374 + 1));
}

TEST_P(SpdyFramerTest, CreateContinuationUncompressed) {
  SpdyFramer framer(SpdyFramer::DISABLE_COMPRESSION);
  const char kDescription[] = "CONTINUATION frame";

  // frame-format off
  const unsigned char kFrameData[] = {
      0x00, 0x00, 0x12,        // Length: 18
      0x09,                    //   Type: CONTINUATION
      0x04,                    //  Flags: END_HEADERS
      0x00, 0x00, 0x00, 0x2a,  // Stream: 42

      0x00,              // Unindexed Entry
      0x03,              // Name Len: 3
      0x62, 0x61, 0x72,  // bar
      0x03,              // Value Len: 3
      0x66, 0x6f, 0x6f,  // foo

      0x00,              // Unindexed Entry
      0x03,              // Name Len: 3
      0x66, 0x6f, 0x6f,  // foo
      0x03,              // Value Len: 3
      0x62, 0x61, 0x72,  // bar
  };
  // frame-format on

  quiche::HttpHeaderBlock header_block;
  header_block["bar"] = "foo";
  header_block["foo"] = "bar";
  HpackEncoder encoder;
  encoder.DisableCompression();
  std::string buffer = encoder.EncodeHeaderBlock(header_block);

  SpdyContinuationIR continuation(/* stream_id = */ 42);
  continuation.take_encoding(std::move(buffer));
  continuation.set_end_headers(true);

  SpdySerializedFrame frame(framer.SerializeContinuation(continuation));
  if (use_output_) {
    ASSERT_TRUE(framer.SerializeContinuation(continuation, &output_));
    frame = MakeSerializedFrame(output_.Begin(), output_.Size());
  }
  CompareFrame(kDescription, frame, kFrameData, ABSL_ARRAYSIZE(kFrameData));
}

// Test that if we send an unexpected CONTINUATION
// we signal an error (but don't crash).
TEST_P(SpdyFramerTest, SendUnexpectedContinuation) {
  testing::StrictMock<test::MockSpdyFramerVisitor> visitor;

  deframer_->set_visitor(&visitor);

  /
```
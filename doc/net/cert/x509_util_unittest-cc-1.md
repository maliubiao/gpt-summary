Response:
The user is asking for a summary of the functionality of the provided C++ code snippet, which is part of a unit test file for X.509 certificate utilities in the Chromium network stack.

I need to analyze the code and identify the key functionalities being tested. Specifically, the code seems to be testing:

1. **Channel Binding Token Generation:**  The `CreateChannelBindings_GetServerEndPoint` test verifies the ability to extract the TLS server endpoint channel binding token from a certificate.
2. **Handling of Unsupported Signature Algorithms:** The `CreateChannelBindings_Unsupported_MD4` test checks the behavior when attempting to generate channel bindings for a certificate signed with an unsupported algorithm (MD4).
3. **Signature Verification with Certificates:** The `SignatureVerifierInitWithCertificate` test verifies the initialization and usage of a `crypto::SignatureVerifier` using a certificate. It covers various key usages and signature algorithms (RSA PKCS#1, RSA PSS, ECDSA).
4. **Detection of RSA PKCS#1 SHA-1 Signatures:** The `HasRsaPkcs1Sha1Signature` test checks if a certificate's signature algorithm is RSA PKCS#1 with SHA-1.

I should also address the specific questions about JavaScript relevance, logical reasoning (with input/output), common user errors, and debugging steps.
这是 Chromium 网络栈中 `net/cert/x509_util_unittest.cc` 文件的一部分，主要功能是**测试与 X.509 证书相关的实用工具函数**。 这部分代码着重测试了以下几个方面的功能：

**1. 生成 TLS 服务器端点通道绑定 (TLS Server End-Point Channel Binding):**

*   **功能:**  测试了从 X.509 证书中提取 TLS 服务器端点通道绑定 token 的功能。
*   **代码示例:** `TEST(X509UtilTest, CreateChannelBindings_GetServerEndPoint)`
*   **假设输入:** 一个包含特定 Subject Public Key Info (SPKI) 的有效 X.509 证书 (以 `kCertificateDataDER` 数组形式提供)。
*   **预期输出:** 一个包含预期的服务器端点通道绑定 token 的字符串 (与 `kExpectedServerEndPointToken` 数组内容一致)。
*   **用户操作到达此处的调试线索:** 当浏览器或 Chromium 内核尝试建立 HTTPS 连接时，为了增强安全性，可能会需要获取服务器证书的通道绑定信息。如果在这个过程中出现问题，开发者可能会查看 `x509_util::GetTLSServerEndPointChannelBinding` 函数的调用情况，从而定位到这个单元测试相关的代码。

**2. 处理不支持的签名算法:**

*   **功能:** 测试了当尝试为一个使用不支持的签名算法（如 MD4）签名的证书生成通道绑定时，程序的行为。
*   **代码示例:** `TEST(X509UtilTest, CreateChannelBindings_Unsupported_MD4)`
*   **假设输入:** 一个使用 MD4WithRSAEncryption 签名的 X.509 证书 (以 `kCertificateDataDER` 数组形式提供)。
*   **预期输出:** `x509_util::GetTLSServerEndPointChannelBinding` 函数返回 `false`，并且输出的通道绑定字符串为空。
*   **用户操作到达此处的调试线索:** 如果用户在访问某个网站时遇到证书相关的错误，并且错误信息指示证书使用了不被支持的签名算法，开发者可能会检查 Chromium 中处理通道绑定的逻辑，并可能触发到这个单元测试来验证相关功能的正确性。

**3. 使用证书初始化签名验证器 (Signature Verifier):**

*   **功能:** 测试了使用 X.509 证书初始化 `crypto::SignatureVerifier` 对象的功能。这包括验证证书的密钥用途 (Key Usage) 扩展是否允许数字签名，以及验证使用证书公钥进行签名校验的正确性。
*   **代码示例:** `TEST(X509UtilTest, SignatureVerifierInitWithCertificate)`
*   **逻辑推理 (假设输入与输出):**
    *   **假设输入 1:** 一个 `key_usage_p256_digitalsignature.pem` 证书，使用 ECDSA_SHA256 算法，以及对应的签名 `p256Signature` 和消息 `kMessage`。
    *   **预期输出 1:** `SignatureVerifierInitWithCertificate` 返回 `true`，并且 `verifier.VerifyFinal()` 返回 `true`。
    *   **假设输入 2:**  一个 `key_usage_p256_keyagreement.pem` 证书 (没有 digitalSignature 密钥用途)，使用 ECDSA_SHA256 算法，以及对应的签名 `p256Signature`。
    *   **预期输出 2:** `SignatureVerifierInitWithCertificate` 返回 `false`。
    *   **假设输入 3:** 一个 `key_usage_p256_digitalsignature.pem` 证书，使用 RSA_PKCS1_SHA256 算法（算法不匹配），以及对应的签名 `p256Signature`。
    *   **预期输出 3:** `SignatureVerifierInitWithCertificate` 返回 `false`。
*   **用户或编程常见的使用错误:**
    *   **错误 1:** 使用了密钥用途扩展中没有 `digitalSignature` 标志的证书来初始化签名验证器。这将导致验证失败。
    *   **错误 2:** 使用了与证书公钥不匹配的签名算法进行初始化。
    *   **错误 3:** 提供的签名数据与待验证的消息不匹配。
*   **用户操作到达此处的调试线索:** 当浏览器需要验证服务器发送的签名数据（例如，在 TLS 握手过程中或在下载内容时），并且验证失败时，开发者可能会检查 `crypto::SignatureVerifier` 的使用情况，从而追踪到这个单元测试。

**4. 检查是否使用 RSA PKCS#1 SHA-1 签名:**

*   **功能:** 测试了判断一个证书的签名算法是否为 RSA PKCS#1 搭配 SHA-1 的功能。
*   **代码示例:** `TEST(X509UtilTest, HasRsaPkcs1Sha1Signature)`
*   **假设输入 1:** 一个使用 RSA PKCS#1 SHA-1 签名的证书 (`sha1_leaf.pem`)。
*   **预期输出 1:** `HasRsaPkcs1Sha1Signature` 返回 `true`。
*   **假设输入 2:** 一个使用其他签名算法的证书 (`ok_cert.pem`)。
*   **预期输出 2:** `HasRsaPkcs1Sha1Signature` 返回 `false`。
*   **用户操作到达此处的调试线索:** 考虑到 SHA-1 的安全性问题，浏览器可能会对使用 SHA-1 签名的证书进行特殊处理（例如，显示警告）。当涉及到这类处理逻辑时，开发者可能会查看 `HasRsaPkcs1Sha1Signature` 函数的调用情况。

**与 JavaScript 的关系:**

虽然这段 C++ 代码本身不是 JavaScript，但它所测试的功能与 Web 浏览器的安全特性息息相关，而这些特性会直接影响到 JavaScript 在网页中的行为。

*   **HTTPS 连接的安全性:**  通道绑定确保了 TLS 连接的安全，防止中间人攻击。JavaScript 代码可以通过浏览器提供的 API (如 `fetch` 或 `XMLHttpRequest`) 发起 HTTPS 请求，而浏览器底层会依赖像这里测试的 `x509_util::GetTLSServerEndPointChannelBinding` 这样的功能来建立安全的连接。
*   **Web 身份验证:**  签名验证是 Web 身份验证的基础。例如，Web Authentication API (WebAuthn) 可能会使用到类似 `crypto::SignatureVerifier` 的机制来验证用户的身份。JavaScript 代码可以使用 WebAuthn API 与用户的身份验证器交互，而浏览器会使用底层的签名验证功能。

**举例说明 (JavaScript 角度):**

假设一个 JavaScript 网站使用了 `fetch` API 发起一个 HTTPS 请求：

```javascript
fetch('https://example.com/api/data')
  .then(response => {
    // 处理响应
  })
  .catch(error => {
    console.error('请求失败:', error);
  });
```

在这个过程中，Chromium 浏览器的网络栈会使用 `x509_util` 中的函数来验证 `example.com` 服务器提供的证书。如果证书使用了不支持的签名算法 (正如 `CreateChannelBindings_Unsupported_MD4` 测试的那样)，或者证书的密钥用途不允许数字签名 (正如 `SignatureVerifierInitWithCertificate` 测试的那样)，那么浏览器可能会拒绝建立连接，`fetch` 请求会失败，JavaScript 的 `catch` 代码块会被执行，用户会在控制台看到错误信息。

**总结 (针对第2部分):**

这部分 `x509_util_unittest.cc` 的主要功能是**测试 X.509 证书相关的关键安全特性**，包括：

*   **安全通道的建立:**  验证从证书中提取用于建立安全通道的必要信息（通道绑定 token）的功能。
*   **对不安全或不支持的配置的处理:** 确保程序能够正确处理使用不安全签名算法的证书。
*   **证书的正确使用:**  验证签名验证器能够根据证书的密钥用途正确地进行初始化和签名验证。
*   **对旧的不安全算法的识别:** 检测使用了过时且不安全的签名算法的证书。

这些测试对于确保 Chromium 浏览器在处理 HTTPS 连接和各种 Web 安全协议时的安全性和可靠性至关重要。

### 提示词
```
这是目录为net/cert/x509_util_unittest.cc的chromium 网络栈的源代码文件， 请列举一下它的功能, 
如果它与javascript的功能有关系，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索。
这是第2部分，共2部分，请归纳一下它的功能
```

### 源代码
```cpp
c7, 0x84, 0x3d, 0xc7, 0x9e, 0x51, 0xee, 0xbc,
      0x23, 0x33, 0xfd, 0xeb, 0x20, 0x78, 0x3b, 0x93, 0xe8, 0xe6, 0x78,
      0x10, 0xd7, 0x5e, 0x37, 0x48, 0x04, 0x07, 0x5f, 0x57, 0xe6, 0x16,
      0xe2, 0x45, 0x44, 0xa3, 0x71, 0x8c, 0xef, 0x95, 0x08, 0x6b, 0x0c,
      0xaa, 0x65, 0x51, 0x51, 0x60, 0x4f, 0x58, 0x28,
  };

  scoped_refptr<X509Certificate> cert =
      X509Certificate::CreateFromBytes(kCertificateDataDER);
  ASSERT_TRUE(cert);

  std::string channel_bindings;
  ASSERT_TRUE(
      x509_util::GetTLSServerEndPointChannelBinding(*cert, &channel_bindings));

  std::string expected_channel_bindings(
      std::begin(kExpectedServerEndPointToken),
      std::end(kExpectedServerEndPointToken));
  EXPECT_EQ(expected_channel_bindings, channel_bindings);
}

TEST(X509UtilTest, CreateChannelBindings_Unsupported_MD4) {
  // Certificate:
  //  Data:
  //      Version: 3 (0x2)
  //      Serial Number: 12629177056471137087 (0xaf43d99ee079bb3f)
  //  Signature Algorithm: md4WithRSAEncryption
  //  ...
  const uint8_t kCertificateDataDER[] = {
      0x30, 0x82, 0x03, 0x87, 0x30, 0x82, 0x02, 0x6f, 0xa0, 0x03, 0x02, 0x01,
      0x02, 0x02, 0x09, 0x00, 0xaf, 0x43, 0xd9, 0x9e, 0xe0, 0x79, 0xbb, 0x3f,
      0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,
      0x03, 0x05, 0x00, 0x30, 0x5a, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55,
      0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03,
      0x55, 0x04, 0x08, 0x0c, 0x02, 0x4d, 0x41, 0x31, 0x12, 0x30, 0x10, 0x06,
      0x03, 0x55, 0x04, 0x07, 0x0c, 0x09, 0x43, 0x61, 0x6d, 0x62, 0x72, 0x69,
      0x64, 0x67, 0x65, 0x31, 0x10, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x04, 0x0a,
      0x0c, 0x07, 0x45, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x31, 0x18, 0x30,
      0x16, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x0f, 0x77, 0x77, 0x77, 0x2e,
      0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x30,
      0x1e, 0x17, 0x0d, 0x31, 0x36, 0x30, 0x33, 0x31, 0x37, 0x32, 0x30, 0x31,
      0x39, 0x35, 0x39, 0x5a, 0x17, 0x0d, 0x31, 0x36, 0x30, 0x34, 0x31, 0x36,
      0x32, 0x30, 0x31, 0x39, 0x35, 0x39, 0x5a, 0x30, 0x5a, 0x31, 0x0b, 0x30,
      0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x0b,
      0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x08, 0x0c, 0x02, 0x4d, 0x41, 0x31,
      0x12, 0x30, 0x10, 0x06, 0x03, 0x55, 0x04, 0x07, 0x0c, 0x09, 0x43, 0x61,
      0x6d, 0x62, 0x72, 0x69, 0x64, 0x67, 0x65, 0x31, 0x10, 0x30, 0x0e, 0x06,
      0x03, 0x55, 0x04, 0x0a, 0x0c, 0x07, 0x45, 0x78, 0x61, 0x6d, 0x70, 0x6c,
      0x65, 0x31, 0x18, 0x30, 0x16, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x0f,
      0x77, 0x77, 0x77, 0x2e, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x2e,
      0x63, 0x6f, 0x6d, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a,
      0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82,
      0x01, 0x0f, 0x00, 0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01, 0x00,
      0xaf, 0xf8, 0xa5, 0xba, 0x20, 0x40, 0xcd, 0x60, 0x88, 0x1f, 0x27, 0x34,
      0x57, 0x2f, 0x1b, 0xc9, 0xfc, 0xf3, 0x0b, 0x9f, 0xb3, 0xb8, 0x26, 0x67,
      0x78, 0x79, 0x2b, 0xfe, 0x68, 0xa3, 0x95, 0x8c, 0x40, 0x6f, 0x80, 0x8b,
      0x15, 0x8f, 0x0b, 0x4c, 0x66, 0x8d, 0x17, 0x32, 0x6a, 0xa0, 0x57, 0x74,
      0x2d, 0x31, 0xc4, 0x8e, 0xa4, 0x76, 0x6b, 0xff, 0x93, 0x05, 0x44, 0x9b,
      0xe9, 0xf2, 0x81, 0x1e, 0x3b, 0x2e, 0x05, 0x67, 0x01, 0x85, 0x5a, 0xed,
      0xad, 0xc8, 0x55, 0x4b, 0x8e, 0x80, 0x1e, 0x7a, 0x5a, 0xbd, 0xc2, 0x8e,
      0x5f, 0x4f, 0x3a, 0x52, 0xda, 0x2d, 0x86, 0x0d, 0x6b, 0xaf, 0xe2, 0x12,
      0xd1, 0x6e, 0x15, 0x78, 0xb5, 0x06, 0x1c, 0xa2, 0xb4, 0xda, 0x3c, 0xfe,
      0x8b, 0x4c, 0x70, 0x5c, 0xc5, 0x5c, 0x86, 0xf6, 0x95, 0x01, 0x88, 0x44,
      0x99, 0xd2, 0x97, 0x47, 0xdb, 0xdb, 0x4f, 0x6d, 0x1a, 0xd1, 0x1d, 0x74,
      0x0b, 0x89, 0x5c, 0x05, 0x19, 0xe7, 0xe7, 0x17, 0xee, 0xb5, 0xf8, 0x75,
      0x96, 0x95, 0x5a, 0xfd, 0x37, 0x4d, 0xa1, 0xda, 0x5c, 0xf6, 0x5c, 0x60,
      0xa1, 0x04, 0x92, 0xa5, 0x42, 0x02, 0xbd, 0x40, 0xb3, 0x1e, 0xab, 0x28,
      0x0b, 0x28, 0x79, 0x92, 0xdc, 0x23, 0xde, 0xad, 0x28, 0x06, 0xba, 0x93,
      0x28, 0x3f, 0xf4, 0x6a, 0x10, 0x11, 0xf1, 0xe4, 0x92, 0x5b, 0x65, 0xce,
      0x0f, 0x13, 0x34, 0x87, 0xb6, 0xa4, 0x1d, 0xe3, 0x4a, 0xea, 0xc8, 0xcf,
      0x4e, 0x21, 0xf2, 0x70, 0x18, 0x9f, 0x3a, 0x62, 0x43, 0x70, 0x89, 0xb9,
      0xca, 0xab, 0xa6, 0xb1, 0x55, 0x42, 0x3d, 0x25, 0x35, 0xd6, 0xa2, 0x77,
      0x0f, 0x66, 0x88, 0xd2, 0x43, 0x6b, 0xfa, 0x3c, 0xa3, 0xcf, 0xa1, 0x56,
      0x84, 0xe5, 0x9b, 0x25, 0xff, 0x02, 0xb6, 0x9d, 0xaf, 0x6a, 0x4d, 0x8c,
      0xf8, 0x3e, 0xf7, 0xe5, 0x02, 0x03, 0x01, 0x00, 0x01, 0xa3, 0x50, 0x30,
      0x4e, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14,
      0x62, 0xf2, 0x1f, 0xd6, 0x29, 0xfa, 0x61, 0x88, 0x4c, 0x36, 0x39, 0xed,
      0x9f, 0x8e, 0xcf, 0x3b, 0xdc, 0x90, 0x04, 0xa5, 0x30, 0x1f, 0x06, 0x03,
      0x55, 0x1d, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0x62, 0xf2, 0x1f,
      0xd6, 0x29, 0xfa, 0x61, 0x88, 0x4c, 0x36, 0x39, 0xed, 0x9f, 0x8e, 0xcf,
      0x3b, 0xdc, 0x90, 0x04, 0xa5, 0x30, 0x0c, 0x06, 0x03, 0x55, 0x1d, 0x13,
      0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xff, 0x30, 0x0d, 0x06, 0x09, 0x2a,
      0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x03, 0x05, 0x00, 0x03, 0x82,
      0x01, 0x01, 0x00, 0x9e, 0x36, 0xff, 0xf5, 0x77, 0x46, 0x80, 0x22, 0xc4,
      0x01, 0x05, 0x69, 0x84, 0xd1, 0xdc, 0x0c, 0xce, 0xda, 0x2f, 0x21, 0x11,
      0x9a, 0x80, 0x24, 0x81, 0xea, 0x1b, 0x1a, 0xb9, 0x5d, 0x70, 0x60, 0xaf,
      0xbc, 0xca, 0xdb, 0xc4, 0x10, 0x6e, 0x17, 0xdb, 0x58, 0x11, 0x0c, 0xec,
      0x0e, 0xdd, 0xf8, 0xbf, 0x42, 0x27, 0x2d, 0x06, 0x75, 0x25, 0xc0, 0xdb,
      0xb0, 0x35, 0x0c, 0x66, 0xfb, 0xfd, 0x0e, 0xb9, 0x16, 0x9e, 0x34, 0xaf,
      0xdb, 0x72, 0x6e, 0xb3, 0x6d, 0x5e, 0xb2, 0xf0, 0x6d, 0x46, 0x32, 0xba,
      0x35, 0xb5, 0x3b, 0xc5, 0x72, 0xb7, 0x1c, 0x88, 0x6a, 0x84, 0xc2, 0xde,
      0x1d, 0x45, 0x30, 0x41, 0x3d, 0xc5, 0xbb, 0x0a, 0x78, 0xe9, 0xef, 0x59,
      0xc6, 0xbc, 0x0c, 0x9d, 0x36, 0x1f, 0xc8, 0xb1, 0x1b, 0xd3, 0x1c, 0xec,
      0x57, 0x69, 0x8b, 0xcb, 0x1b, 0x93, 0x99, 0x2e, 0xab, 0x8d, 0xd7, 0x63,
      0xc5, 0x1f, 0x58, 0x9d, 0x06, 0x8e, 0xf1, 0x47, 0x64, 0xc5, 0xf3, 0x03,
      0x8d, 0x2c, 0x8a, 0x99, 0x2c, 0xe6, 0x89, 0x87, 0xb2, 0x42, 0xdd, 0x18,
      0xf0, 0xc9, 0xdb, 0x6c, 0xee, 0x3e, 0x5e, 0xc5, 0x75, 0xc7, 0x45, 0xd3,
      0xd0, 0xaa, 0xf7, 0x0d, 0xac, 0xaa, 0x4c, 0xb4, 0xa4, 0xa2, 0xb7, 0xfc,
      0x65, 0xb0, 0x2e, 0x83, 0xbd, 0x7a, 0x65, 0xfb, 0x1b, 0x92, 0x3f, 0x8d,
      0x47, 0x0c, 0xbb, 0x4a, 0x38, 0xc5, 0x67, 0x87, 0x8e, 0x79, 0xd6, 0x48,
      0xc7, 0xf2, 0x92, 0xdb, 0x6e, 0xf9, 0x54, 0x01, 0xed, 0xdb, 0xbd, 0xe0,
      0x12, 0x18, 0xd9, 0xcf, 0x36, 0x5d, 0x7e, 0xe9, 0xb9, 0x27, 0x09, 0x80,
      0x1a, 0x2f, 0xb9, 0x58, 0xc6, 0x6f, 0xa2, 0x42, 0x7a, 0x7b, 0x20, 0xf2,
      0xc9, 0x85, 0x54, 0x11, 0xa2, 0xe3, 0x31, 0x0f, 0x71, 0x6a, 0xea, 0x0e,
      0xef, 0xba, 0x6d, 0x5e, 0x88, 0x01, 0xaf,
  };

  scoped_refptr<X509Certificate> cert =
      X509Certificate::CreateFromBytes(kCertificateDataDER);
  ASSERT_TRUE(cert);

  std::string channel_bindings;
  ASSERT_FALSE(
      x509_util::GetTLSServerEndPointChannelBinding(*cert, &channel_bindings));
  EXPECT_TRUE(channel_bindings.empty());
}

namespace {

bool DigestSign(EVP_PKEY* key,
                const EVP_MD* md,
                base::span<const uint8_t> data,
                bool is_pss,
                std::vector<uint8_t>* digest) {
  bssl::ScopedEVP_MD_CTX ctx;
  EVP_PKEY_CTX* pctx;
  if (!EVP_DigestSignInit(ctx.get(), &pctx, md, nullptr, key)) {
    return false;
  }

  if (is_pss) {
    if (!EVP_PKEY_CTX_set_rsa_padding(pctx, RSA_PKCS1_PSS_PADDING) ||
        !EVP_PKEY_CTX_set_rsa_pss_saltlen(pctx, -1 /* hash length */)) {
      return false;
    }
  }

  // Determine the maximum length of the signature.
  size_t len = 0;
  if (!EVP_DigestSign(ctx.get(), nullptr, &len, data.data(), data.size())) {
    return false;
  }
  digest->resize(len);

  // Sign it.
  if (!EVP_DigestSign(ctx.get(), digest->data(), &len, data.data(),
                      data.size())) {
    return false;
  }
  digest->resize(len);
  return true;
}

}  // namespace

TEST(X509UtilTest, SignatureVerifierInitWithCertificate) {
  static const uint8_t kMessage[] = {'h', 'e', 'l', 'l', 'o'};
  static const uint8_t kWrongMessage[] = {'n', 'o', 'p', 'e'};

  bssl::UniquePtr<EVP_PKEY> rsaKey =
      net::key_util::LoadEVP_PKEYFromPEM(net::GetTestCertsDirectory().Append(
          FILE_PATH_LITERAL("key_usage_rsa.key")));
  ASSERT_NE(rsaKey, nullptr);
  bssl::UniquePtr<EVP_PKEY> p256Key =
      net::key_util::LoadEVP_PKEYFromPEM(net::GetTestCertsDirectory().Append(
          FILE_PATH_LITERAL("key_usage_p256.key")));
  ASSERT_NE(p256Key, nullptr);

  std::vector<uint8_t> rsaSignaturePKCS1;
  ASSERT_TRUE(DigestSign(rsaKey.get(), EVP_sha256(), kMessage, false,
                         &rsaSignaturePKCS1));
  std::vector<uint8_t> rsaSignaturePSS;
  ASSERT_TRUE(
      DigestSign(rsaKey.get(), EVP_sha256(), kMessage, true, &rsaSignaturePSS));
  std::vector<uint8_t> p256Signature;
  ASSERT_TRUE(
      DigestSign(p256Key.get(), EVP_sha256(), kMessage, false, &p256Signature));

  struct Test {
    const char* cert;
    crypto::SignatureVerifier::SignatureAlgorithm algorithm;
    base::raw_span<const uint8_t> signature;
    bool ok;
  } kTests[] = {
      // The certificate must support the digitalSignature key usage.
      {"key_usage_p256_digitalsignature.pem",
       crypto::SignatureVerifier::ECDSA_SHA256, p256Signature, true},
      {"key_usage_p256_both.pem", crypto::SignatureVerifier::ECDSA_SHA256,
       p256Signature, true},
      {"key_usage_rsa_digitalsignature.pem",
       crypto::SignatureVerifier::RSA_PKCS1_SHA256, rsaSignaturePKCS1, true},
      {"key_usage_rsa_digitalsignature.pem",
       crypto::SignatureVerifier::RSA_PSS_SHA256, rsaSignaturePSS, true},
      {"key_usage_rsa_both.pem", crypto::SignatureVerifier::RSA_PKCS1_SHA256,
       rsaSignaturePKCS1, true},
      {"key_usage_rsa_both.pem", crypto::SignatureVerifier::RSA_PSS_SHA256,
       rsaSignaturePSS, true},

      // Omitting the extension entirely is also accepted.
      {"key_usage_p256_no_extension.pem",
       crypto::SignatureVerifier::ECDSA_SHA256, p256Signature, true},
      {"key_usage_rsa_no_extension.pem",
       crypto::SignatureVerifier::RSA_PKCS1_SHA256, rsaSignaturePKCS1, true},
      {"key_usage_rsa_no_extension.pem",
       crypto::SignatureVerifier::RSA_PSS_SHA256, rsaSignaturePSS, true},

      // If the extension is present but digitalSignature is missing, the
      // signature is rejected.
      {"key_usage_p256_keyagreement.pem",
       crypto::SignatureVerifier::ECDSA_SHA256, p256Signature, false},
      {"key_usage_rsa_keyencipherment.pem",
       crypto::SignatureVerifier::RSA_PKCS1_SHA256, rsaSignaturePKCS1, false},
      {"key_usage_rsa_keyencipherment.pem",
       crypto::SignatureVerifier::RSA_PSS_SHA256, rsaSignaturePSS, false},

      // The key and signature must match, rather than only extracting the hash
      // function.
      {"key_usage_p256_digitalsignature.pem",
       crypto::SignatureVerifier::RSA_PKCS1_SHA256, p256Signature, false},
      {"key_usage_rsa_digitalsignature.pem",
       crypto::SignatureVerifier::ECDSA_SHA256, rsaSignaturePKCS1, false},
  };

  for (const auto& test : kTests) {
    SCOPED_TRACE(test.cert);
    scoped_refptr<X509Certificate> cert =
        ImportCertFromFile(GetTestCertsDirectory(), test.cert);
    ASSERT_TRUE(cert);

    crypto::SignatureVerifier verifier;
    bool ok = SignatureVerifierInitWithCertificate(
        &verifier, test.algorithm, test.signature, cert->cert_buffer());
    EXPECT_EQ(ok, test.ok);
    if (ok) {
      verifier.VerifyUpdate(kMessage);
      EXPECT_TRUE(verifier.VerifyFinal());

      ASSERT_TRUE(SignatureVerifierInitWithCertificate(
          &verifier, test.algorithm, test.signature, cert->cert_buffer()));
      verifier.VerifyUpdate(kWrongMessage);
      EXPECT_FALSE(verifier.VerifyFinal());
    }
  }
}

TEST(X509UtilTest, HasRsaPkcs1Sha1Signature) {
  base::FilePath certs_dir = GetTestCertsDirectory();

  scoped_refptr<X509Certificate> sha1_leaf =
      ImportCertFromFile(certs_dir, "sha1_leaf.pem");
  ASSERT_TRUE(sha1_leaf);
  EXPECT_TRUE(HasRsaPkcs1Sha1Signature(sha1_leaf->cert_buffer()));

  scoped_refptr<X509Certificate> ok_cert =
      ImportCertFromFile(certs_dir, "ok_cert.pem");
  ASSERT_TRUE(ok_cert);
  EXPECT_FALSE(HasRsaPkcs1Sha1Signature(ok_cert->cert_buffer()));
}

}  // namespace net::x509_util
```
Response:
Let's break down the thought process for analyzing this C++ code.

1. **Understand the Goal:** The request asks for the functionality of `quic_event_logger.cc`, its relationship to JavaScript (if any), examples with hypothetical inputs and outputs, common usage errors, and debugging information.

2. **Initial Code Scan (Keywords and Structure):**  Quickly scan the code for keywords and overall structure. Notice `#include`, namespaces (`net`), class definition (`QuicEventLogger`), methods, and function-like constructs inside the namespace (which turn out to be helper functions for logging parameters).

3. **Identify the Core Class:** The central piece is clearly `QuicEventLogger`. Its constructor takes `quic::QuicSession*` and `NetLogWithSource&`. This immediately suggests its purpose is to log events related to a QUIC session.

4. **Analyze Member Functions:**  Go through each method of `QuicEventLogger`. The names are very descriptive:
    * `OnFrameAddedToPacket`:  Logs when a QUIC frame is added to a packet being sent.
    * `OnStreamFrameCoalesced`: Logs when stream frames are combined in a packet.
    * `OnPacketSent`: Logs when a QUIC packet is sent.
    * `OnIncomingAck`: Logs when an ACK packet is received.
    * `OnPacketLoss`: Logs when a packet is detected as lost.
    * ...and so on. The pattern is consistent: `On[Event]` indicates logging when a specific QUIC event occurs.

5. **Focus on the Helper Functions:** Notice the functions defined *before* the `QuicEventLogger` class (e.g., `NetLogQuicPacketParams`, `NetLogQuicStreamFrameParams`). These functions all return `base::Value::Dict`. This strongly suggests they are constructing structured data (dictionaries/objects) for logging. The names of these functions clearly indicate the type of QUIC event data they are handling.

6. **Connect `QuicEventLogger` and Helper Functions:** Observe how the `QuicEventLogger` methods use these helper functions. For example, in `OnPacketSent`, the code calls `NetLogQuicPacketSentParams` to generate the parameters for the log event.

7. **Infer Overall Functionality:**  Combine the observations. The `QuicEventLogger` listens for various QUIC events within a session. When an event occurs, it uses helper functions to create structured data representing the event's details. This data is then passed to `net_log_` (a `NetLogWithSource` object), which is part of Chrome's network logging system. Therefore, the primary function is to record detailed information about QUIC connection events for debugging and analysis.

8. **JavaScript Relationship (or Lack Thereof):**  Look for any direct interaction with JavaScript. The code uses C++ standard library features, Chromium's base library (`base/`), and QUIC-specific types. There's no indication of direct JavaScript interaction. However, *indirectly*, the logs generated by this class can be viewed in Chrome's `chrome://net-export/` tool, which runs in a browser environment and uses JavaScript to display the data. This is the crucial distinction.

9. **Hypothetical Inputs and Outputs:**  Choose a few representative methods and imagine scenarios. For `OnPacketSent`, think about sending a packet. What information is available?  The packet number, length, transmission type, etc. The output would be a `base::Value::Dict` containing these fields. Similarly, for `OnStreamFrameReceived`, consider a stream frame's properties (stream ID, offset, length, fin).

10. **Common Usage Errors:** Think about how a *developer* might misuse this class. Since it's primarily for logging, direct misuse might be less common. However, consider scenarios like:
    * Incorrectly instantiating `QuicEventLogger` without a valid session or `NetLogWithSource`.
    * Expecting real-time updates in JavaScript based on these logs (the logs are typically for post-hoc analysis).
    * Not enabling network logging to see any output.

11. **Debugging Information (User Actions):**  Consider how a user's actions lead to these events being logged. A user browsing a website over HTTPS (which might use QUIC) will trigger network activity. Each step of the QUIC handshake, data transfer, and connection management generates events that this logger captures. Think about specific user actions and trace them down to network events. For example:
    * Typing a URL -> DNS lookup -> Connection establishment (potentially QUIC) -> TLS handshake -> Data transfer.

12. **Structure the Answer:** Organize the findings logically, addressing each part of the request:
    * Functionality: Clearly state the primary purpose.
    * JavaScript Relationship: Explain the *indirect* link via Chrome's logging tools.
    * Hypothetical Examples: Provide concrete input and output examples for key methods.
    * Common Errors:  Focus on developer-related issues.
    * Debugging:  Outline the user action flow.

13. **Refine and Review:**  Read through the answer, ensuring clarity, accuracy, and completeness. Are there any ambiguities?  Is the language precise?  For instance, initially, I might have just said "JavaScript can view these logs."  Refining it to "Chrome's network logging tool, which uses JavaScript, can display these logs" is more accurate.
好的，让我们来分析一下 `net/quic/quic_event_logger.cc` 这个文件。

**功能列举:**

`QuicEventLogger` 类的主要功能是：**记录和报告 QUIC 协议会话期间发生的各种事件，用于调试、性能分析和网络监控。**  它通过 Chrome 的 `net_log` 系统将这些事件以结构化的格式记录下来。

具体来说，它负责监听和记录以下类型的事件：

1. **帧的发送和接收:**
   - 各种 QUIC 帧类型（STREAM, ACK, RST_STREAM, CONNECTION_CLOSE, GOAWAY, WINDOW_UPDATE, BLOCKED, PING, CRYPTO, NEW_CONNECTION_ID 等）的发送和接收。
   - 记录帧的详细信息，例如 stream_id, offset, length, error code 等。
2. **数据包的发送和接收:**
   - 记录数据包的发送和接收，包括源地址、目标地址、大小、发送时间、加密级别等。
3. **连接状态变化:**
   - 连接建立、关闭、版本协商、握手完成等事件。
4. **拥塞控制和流量控制事件:**
   - 记录拥塞控制算法的配置、数据包丢失、RTT 更新等信息。
   - 窗口更新和流阻塞事件。
5. **加密和安全相关事件:**
   - 记录加密握手消息的发送和接收。
   - 记录证书验证结果。
   - 记录传输参数的发送和接收。
   - 记录 0-RTT 连接被拒绝的原因。
6. **连接ID管理:**
   - 记录新的连接 ID 的创建和退休。
7. **路径验证:**
   - 记录路径挑战和路径响应帧的发送和接收。
8. **其他 QUIC 特有事件:**
   - 记录重复数据包的接收。
   - 记录无法解密的包。
   - 记录合并数据包的发送。

**与 JavaScript 功能的关系 (间接):**

`QuicEventLogger` 本身是用 C++ 编写的，直接与 JavaScript 没有交互。然而，它记录的事件可以通过 Chrome 的网络日志系统 (`net_log`) 在开发者工具中查看。Chrome 的开发者工具是用 JavaScript 构建的，因此可以**间接地**通过 JavaScript 来访问和展示这些 QUIC 事件日志。

**举例说明:**

假设一个用户通过 Chrome 浏览器访问一个使用 QUIC 协议的网站。

1. **C++ (quic_event_logger.cc):** 当 QUIC 连接发送一个包含网页数据的 STREAM 帧时，`QuicEventLogger::OnFrameAddedToPacket` 方法会被调用，并记录类似以下的事件（格式可能略有不同，这里是概念性的）：

   ```
   {
     "phase": "event",
     "time": "12345.678",
     "type": "QUIC_SESSION_STREAM_FRAME_SENT",
     "params": {
       "stream_id": 3,
       "fin": false,
       "offset": 0,
       "length": 1024
     },
     "source": {
       "id": 234,
       "type": "quic_session"
     }
   }
   ```

2. **JavaScript (Chrome 开发者工具):**  开发者打开 Chrome 的开发者工具 -> Network 面板，并启用了 "Preserve log" 或导出了网络日志。JavaScript 代码会解析这些由 C++ 生成的日志数据，并将其以用户友好的方式展示在界面上，例如在 "QuicFrames" 或 "Events" 标签页中，开发者可以看到发送了哪个流 ID 的数据，偏移量和长度是多少。

**逻辑推理 - 假设输入与输出:**

假设输入是 `QuicEventLogger::OnStreamFrame` 方法接收到一个 `quic::QuicStreamFrame` 对象，其内容如下：

```c++
quic::QuicStreamFrame frame;
frame.stream_id = 5;
frame.fin = true;
frame.offset = 2048;
frame.data_length = 512;
// frame.data 包含 512 字节的数据
```

**假设输入:**  一个包含了上述信息的 `quic::QuicStreamFrame` 对象传递给 `QuicEventLogger::OnStreamFrame`。

**逻辑推理:**  `OnStreamFrame` 方法内部会调用 `net_log_.AddEvent`，并使用 `NetLogQuicStreamFrameParams(frame)` 生成日志参数。

**假设输出 (NetLog 事件):**  会生成一个类似于以下的 NetLog 事件：

```json
{
  "phase": "event",
  "time": "some_timestamp",
  "type": "QUIC_SESSION_STREAM_FRAME_RECEIVED",
  "params": {
    "stream_id": 5,
    "fin": true,
    "offset": 2048,
    "length": 512
  },
  "source": {
    "id": "some_id",
    "type": "quic_session"
  }
}
```

**用户或编程常见的使用错误:**

1. **忘记初始化 NetLog:**  `QuicEventLogger` 依赖于 `NetLogWithSource` 来记录事件。如果在创建 `QuicEventLogger` 时没有提供有效的 `NetLogWithSource`，或者 NetLog 没有正确初始化，则不会有任何日志输出。

   ```c++
   // 错误示例：没有关联 NetLog
   // NetLogWithSource net_log;  // 缺少初始化
   quic::QuicSession* session = ...;
   QuicEventLogger logger(session, NetLogWithSource()); // 使用默认构造函数，可能未初始化
   ```

2. **过度依赖日志进行实时决策:**  `QuicEventLogger` 主要用于事后分析和调试。虽然日志是按事件发生的顺序记录的，但它不是一个实时的通信通道，不应该依赖日志来进行实时的控制逻辑。

3. **日志级别配置不当:**  Chrome 的 `net_log` 系统有不同的日志级别。如果配置的日志级别太低，可能不会捕获某些类型的 QUIC 事件。用户需要确保启用了足够的日志级别才能看到他们感兴趣的事件。

4. **在性能敏感的代码路径中进行过多的日志记录:**  虽然 `QuicEventLogger` 的设计尽量避免性能开销（只有在 NetLog 处于捕获状态时才会记录），但在极高吞吐量的场景下，过多的日志记录仍然可能引入轻微的性能影响。应该根据需要选择性地记录。

**用户操作是如何一步步的到达这里，作为调试线索:**

假设用户在 Chrome 浏览器中访问一个使用 QUIC 协议的网站时遇到了连接问题。作为调试线索，`QuicEventLogger` 记录的事件可以帮助开发者追踪问题。以下是一个可能的用户操作流程以及相关的 `QuicEventLogger` 日志事件：

1. **用户在地址栏输入网址并按下回车:**
   -  可能触发 DNS 查询，但 `QuicEventLogger` 不直接记录 DNS 事件。
   -  Chrome 尝试与服务器建立连接，可能会尝试 QUIC 协议。

2. **Chrome 发起 QUIC 连接握手:**
   -  `OnFrameAddedToPacket` / `OnPacketSent`:  记录发送的 Initial 握手包（包含 CRYPTO 帧）。
   -  `OnCryptoHandshakeMessageSent`: 记录发送的 ClientHello 消息。

3. **服务器响应握手:**
   -  `OnPacketReceived`: 记录接收到的数据包。
   -  `OnUnauthenticatedHeader`: 记录数据包头信息。
   -  `OnCryptoFrame`: 记录接收到的 CRYPTO 帧。
   -  `OnCryptoHandshakeMessageReceived`: 记录接收到的 ServerHello, Certificate, ServerKeyExchange 等消息。

4. **连接建立完成:**
   -  `OnSuccessfulVersionNegotiation`:  记录最终协商的 QUIC 版本。
   -  `OnCertificateVerified`: 记录服务器证书验证结果。
   -  `OnTransportParametersReceived` / `OnTransportParametersSent`: 记录传输参数的交换。

5. **数据传输:**
   -  `OnFrameAddedToPacket` / `OnPacketSent`: 记录发送的包含网页数据的 STREAM 帧。
   -  `OnStreamFrame`: 记录接收到的包含网页数据的 STREAM 帧。
   -  `OnIncomingAck`: 记录收到的 ACK 帧，确认数据包已送达。

6. **出现问题 (例如，连接中断):**
   -  `OnPacketLoss`:  记录检测到的数据包丢失。
   -  `OnRstStreamFrame` / `OnConnectionCloseFrame`: 记录收到的 RST_STREAM 或 CONNECTION_CLOSE 帧，指示连接终止的原因。
   -  `OnConnectionClosed`: 记录连接关闭事件，包括错误代码和详细信息。

**如何利用日志进行调试:**

开发者可以通过以下步骤使用 `QuicEventLogger` 记录的日志进行调试：

1. **启用 Chrome 的网络日志记录:**  访问 `chrome://net-export/` 并开始记录。
2. **复现用户操作:**  在启用日志记录的情况下，让用户重新执行导致问题的操作。
3. **停止日志记录并保存日志文件。**
4. **在 `chrome://net-internals/#events` 中加载日志文件，或者使用其他工具分析日志。**
5. **分析日志事件:**
   -  查看事件的时间戳顺序，了解事件发生的先后顺序。
   -  关注错误相关的事件，例如 `QUIC_SESSION_PACKET_LOST`, `QUIC_SESSION_RST_STREAM_FRAME_RECEIVED`, `QUIC_SESSION_CONNECTION_CLOSE_FRAME_RECEIVED`。
   -  检查 `params` 字段，获取事件的详细信息，例如哪个 stream_id 出了问题，连接关闭的原因是什么。
   -  对比发送和接收的帧和数据包，检查是否有异常。
   -  分析拥塞控制相关的事件，例如窗口大小的变化，判断是否是拥塞导致的问题。

总而言之，`net/quic/quic_event_logger.cc` 是 Chrome QUIC 实现中一个关键的组件，它提供了详细的事件记录功能，极大地帮助开发者理解 QUIC 连接的行为，诊断网络问题，并进行性能优化。 虽然它本身是 C++ 代码，但其输出可以通过 JavaScript 构建的开发者工具进行查看和分析。

Prompt: 
```
这是目录为net/quic/quic_event_logger.cc的chromium 网络栈的源代码文件， 请列举一下它的功能, 
如果它与javascript的功能有关系，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索。

"""
// Copyright 2020 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "net/quic/quic_event_logger.h"

#include "base/containers/span.h"
#include "base/strings/string_number_conversions.h"
#include "net/cert/x509_certificate.h"
#include "net/log/net_log_values.h"
#include "net/quic/address_utils.h"
#include "net/third_party/quiche/src/quiche/quic/core/quic_socket_address_coder.h"
#include "third_party/boringssl/src/include/openssl/ssl.h"

namespace net {

namespace {

base::Value::Dict NetLogQuicPacketParams(
    const quic::QuicSocketAddress& self_address,
    const quic::QuicSocketAddress& peer_address,
    size_t packet_size) {
  return base::Value::Dict()
      .Set("self_address", self_address.ToString())
      .Set("peer_address", peer_address.ToString())
      .Set("size", static_cast<int>(packet_size));
}

base::Value::Dict NetLogQuicPacketSentParams(
    quic::QuicPacketNumber packet_number,
    quic::QuicPacketLength packet_length,
    quic::TransmissionType transmission_type,
    quic::EncryptionLevel encryption_level,
    quic::QuicTime sent_time,
    uint32_t batch_id) {
  return base::Value::Dict()
      .Set("transmission_type",
           quic::TransmissionTypeToString(transmission_type))
      .Set("packet_number", NetLogNumberValue(packet_number.ToUint64()))
      .Set("size", packet_length)
      .Set("sent_time_us", NetLogNumberValue(sent_time.ToDebuggingValue()))
      .Set("encryption_level", quic::EncryptionLevelToString(encryption_level))
      .Set("batch_id", NetLogNumberValue(batch_id));
}

base::Value::Dict NetLogQuicPacketLostParams(
    quic::QuicPacketNumber packet_number,
    quic::TransmissionType transmission_type,
    quic::QuicTime detection_time) {
  return base::Value::Dict()
      .Set("transmission_type",
           quic::TransmissionTypeToString(transmission_type))
      .Set("packet_number", NetLogNumberValue(packet_number.ToUint64()))
      .Set("detection_time_us",
           NetLogNumberValue(detection_time.ToDebuggingValue()));
}

base::Value::Dict NetLogQuicConfigProcessed(
    const quic::QuicSentPacketManager::DebugDelegate::SendParameters&
        parameters) {
  return base::Value::Dict()
      .Set("congestion_control_type", quic::CongestionControlTypeToString(
                                          parameters.congestion_control_type))
      .Set("use_pacing", parameters.use_pacing)
      .Set("initial_congestion_window",
           NetLogNumberValue(parameters.initial_congestion_window));
}

base::Value::Dict NetLogQuicDuplicatePacketParams(
    quic::QuicPacketNumber packet_number) {
  return base::Value::Dict().Set("packet_number",
                                 NetLogNumberValue(packet_number.ToUint64()));
}

base::Value::Dict NetLogReceivedQuicPacketHeaderParams(
    const quic::QuicPacketHeader& header,
    const quic::ParsedQuicVersion& session_version,
    const quic::QuicConnectionId& connection_id,
    const quic::QuicConnectionId& client_connection_id) {
  base::Value::Dict dict;
  quic::ParsedQuicVersion version = session_version;
  if (header.version_flag &&
      header.version != quic::ParsedQuicVersion::Unsupported()) {
    version = header.version;
    if (version != session_version) {
      dict.Set("version", quic::ParsedQuicVersionToString(version));
    }
  }
  dict.Set("connection_id", connection_id.ToString());
  if (!client_connection_id.IsEmpty()) {
    dict.Set("client_connection_id", client_connection_id.ToString());
  }
  if (header.destination_connection_id_included ==
          quic::CONNECTION_ID_PRESENT &&
      header.destination_connection_id != client_connection_id &&
      !header.destination_connection_id.IsEmpty()) {
    dict.Set("destination_connection_id",
             header.destination_connection_id.ToString());
  }
  if (header.source_connection_id_included == quic::CONNECTION_ID_PRESENT &&
      header.source_connection_id != connection_id &&
      !header.source_connection_id.IsEmpty()) {
    dict.Set("source_connection_id", header.source_connection_id.ToString());
  }
  dict.Set("packet_number", NetLogNumberValue(header.packet_number.ToUint64()));
  dict.Set("header_format", quic::PacketHeaderFormatToString(header.form));
  if (header.form == quic::IETF_QUIC_LONG_HEADER_PACKET) {
    dict.Set("long_header_type",
             quic::QuicLongHeaderTypeToString(header.long_packet_type));
  }
  return dict;
}

base::Value::Dict NetLogQuicStreamFrameParams(
    const quic::QuicStreamFrame& frame) {
  return base::Value::Dict()
      .Set("stream_id", static_cast<int>(frame.stream_id))
      .Set("fin", frame.fin)
      .Set("offset", NetLogNumberValue(frame.offset))
      .Set("length", frame.data_length);
}

base::Value::Dict NetLogQuicAckFrameParams(const quic::QuicAckFrame* frame) {
  base::Value::List missing;
  quic::QuicPacketNumber smallest_observed;
  if (!frame->packets.Empty()) {
    // V34 and above express acked packets, but only print
    // missing packets, because it's typically a shorter list.
    smallest_observed = frame->packets.Min();
    for (quic::QuicPacketNumber packet = smallest_observed;
         packet < frame->largest_acked; ++packet) {
      if (!frame->packets.Contains(packet)) {
        missing.Append(NetLogNumberValue(packet.ToUint64()));
      }
    }
  } else {
    smallest_observed = frame->largest_acked;
  }

  base::Value::List received;
  for (const auto& packet_time : frame->received_packet_times) {
    received.Append(
        base::Value::Dict()
            .Set("packet_number",
                 NetLogNumberValue(packet_time.first.ToUint64()))
            .Set("received",
                 NetLogNumberValue(packet_time.second.ToDebuggingValue())));
  }

  base::Value::Dict rv;
  rv.Set("largest_observed",
         NetLogNumberValue(frame->largest_acked.ToUint64()));
  rv.Set("delta_time_largest_observed_us",
         NetLogNumberValue(frame->ack_delay_time.ToMicroseconds()));
  rv.Set("smallest_observed", NetLogNumberValue(smallest_observed.ToUint64()));
  rv.Set("missing_packets", std::move(missing));
  rv.Set("received_packet_times", std::move(received));
  if (frame->ecn_counters.has_value()) {
    rv.Set("ECT0", NetLogNumberValue(frame->ecn_counters->ect0));
    rv.Set("ECT1", NetLogNumberValue(frame->ecn_counters->ect1));
    rv.Set("CE", NetLogNumberValue(frame->ecn_counters->ce));
  }
  return rv;
}

base::Value::Dict NetLogQuicRstStreamFrameParams(
    const quic::QuicRstStreamFrame* frame) {
  return base::Value::Dict()
      .Set("stream_id", static_cast<int>(frame->stream_id))
      .Set("quic_rst_stream_error", static_cast<int>(frame->error_code))
      .Set("ietf_error_code", static_cast<int>(frame->ietf_error_code))
      .Set("offset", NetLogNumberValue(frame->byte_offset));
}

base::Value::Dict NetLogQuicConnectionCloseFrameParams(
    const quic::QuicConnectionCloseFrame* frame) {
  base::Value::Dict dict;
  dict.Set("quic_error", static_cast<int>(frame->quic_error_code));
  if (frame->wire_error_code != frame->quic_error_code) {
    dict.Set("quic_wire_error", static_cast<int>(frame->wire_error_code));
  }
  std::string close_type;
  switch (frame->close_type) {
    case quic::GOOGLE_QUIC_CONNECTION_CLOSE:
      close_type = "gQUIC";
      break;
    case quic::IETF_QUIC_TRANSPORT_CONNECTION_CLOSE:
      close_type = "Transport";
      break;
    case quic::IETF_QUIC_APPLICATION_CONNECTION_CLOSE:
      close_type = "Application";
      break;
  }
  dict.Set("close_type", close_type);
  if (frame->transport_close_frame_type != 0) {
    dict.Set("transport_close_frame_type",
             NetLogNumberValue(frame->transport_close_frame_type));
  }
  dict.Set("details", frame->error_details);
  return dict;
}

base::Value::Dict NetLogQuicWindowUpdateFrameParams(
    const quic::QuicWindowUpdateFrame& frame) {
  return base::Value::Dict()
      .Set("stream_id", static_cast<int>(frame.stream_id))
      .Set("byte_offset", NetLogNumberValue(frame.max_data));
}

base::Value::Dict NetLogQuicBlockedFrameParams(
    const quic::QuicBlockedFrame& frame) {
  return base::Value::Dict().Set("stream_id",
                                 static_cast<int>(frame.stream_id));
}

base::Value::Dict NetLogQuicGoAwayFrameParams(
    const quic::QuicGoAwayFrame* frame) {
  return base::Value::Dict()
      .Set("quic_error", static_cast<int>(frame->error_code))
      .Set("last_good_stream_id", static_cast<int>(frame->last_good_stream_id))
      .Set("reason_phrase", frame->reason_phrase);
}

base::Value::Dict NetLogQuicStopWaitingFrameParams(
    const quic::QuicStopWaitingFrame* frame) {
  return base::Value::Dict().Set(
      "least_unacked", NetLogNumberValue(frame->least_unacked.ToUint64()));
}

base::Value::Dict NetLogQuicVersionNegotiationPacketParams(
    const quic::QuicVersionNegotiationPacket* packet) {
  base::Value::List versions;
  for (const auto& version : packet->versions) {
    versions.Append(ParsedQuicVersionToString(version));
  }
  return base::Value::Dict().Set("versions", std::move(versions));
}

base::Value::Dict NetLogQuicPathData(const quic::QuicPathFrameBuffer& buffer) {
  return base::Value::Dict().Set("data", NetLogBinaryValue(buffer));
}

base::Value::Dict NetLogQuicCryptoHandshakeMessageParams(
    const quic::CryptoHandshakeMessage* message) {
  return base::Value::Dict().Set("quic_crypto_handshake_message",
                                 message->DebugString());
}

base::Value::Dict NetLogQuicTransportParametersParams(
    const quic::TransportParameters& transport_parameters) {
  return base::Value::Dict().Set("quic_transport_parameters",
                                 transport_parameters.ToString());
}

base::Value::Dict NetLogQuicZeroRttRejectReason(int reason) {
  base::Value::Dict dict;
  const char* reason_detail = SSL_early_data_reason_string(
      static_cast<ssl_early_data_reason_t>(reason));
  if (reason_detail) {
    dict.Set("reason", reason_detail);
  } else {
    dict.Set("reason", "Unknown reason " + base::NumberToString(reason));
  }
  return dict;
}

base::Value::Dict NetLogQuicOnConnectionClosedParams(
    quic::QuicErrorCode error,
    std::string error_details,
    quic::ConnectionCloseSource source) {
  return base::Value::Dict()
      .Set("quic_error", static_cast<int>(error))
      .Set("details", error_details)
      .Set("from_peer",
           source == quic::ConnectionCloseSource::FROM_PEER ? true : false);
}

base::Value::Dict NetLogQuicCertificateVerifiedParams(
    scoped_refptr<X509Certificate> cert) {
  // Only the subjects are logged so that we can investigate connection pooling.
  // More fields could be logged in the future.
  std::vector<std::string> dns_names;
  cert->GetSubjectAltName(&dns_names, nullptr);
  base::Value::List subjects;
  for (auto& dns_name : dns_names) {
    subjects.Append(std::move(dns_name));
  }
  return base::Value::Dict().Set("subjects", std::move(subjects));
}

base::Value::Dict NetLogQuicCryptoFrameParams(
    const quic::QuicCryptoFrame* frame,
    bool has_buffer) {
  auto dict =
      base::Value::Dict()
          .Set("encryption_level", quic::EncryptionLevelToString(frame->level))
          .Set("data_length", frame->data_length)
          .Set("offset", NetLogNumberValue(frame->offset));
  if (has_buffer) {
    dict.Set("bytes", NetLogBinaryValue(
                          reinterpret_cast<const void*>(frame->data_buffer),
                          frame->data_length));
  }
  return dict;
}

base::Value::Dict NetLogQuicStopSendingFrameParams(
    const quic::QuicStopSendingFrame& frame) {
  return base::Value::Dict()
      .Set("stream_id", static_cast<int>(frame.stream_id))
      .Set("quic_rst_stream_error", static_cast<int>(frame.error_code))
      .Set("ietf_error_code", static_cast<int>(frame.ietf_error_code));
}

base::Value::Dict NetLogQuicStreamsBlockedFrameParams(
    const quic::QuicStreamsBlockedFrame& frame) {
  return base::Value::Dict()
      .Set("stream_count", static_cast<int>(frame.stream_count))
      .Set("is_unidirectional", frame.unidirectional);
}

base::Value::Dict NetLogQuicMaxStreamsFrameParams(
    const quic::QuicMaxStreamsFrame& frame) {
  return base::Value::Dict()
      .Set("stream_count", static_cast<int>(frame.stream_count))
      .Set("is_unidirectional", frame.unidirectional);
}

base::Value::Dict NetLogQuicNewConnectionIdFrameParams(
    const quic::QuicNewConnectionIdFrame* frame) {
  return base::Value::Dict()
      .Set("connection_id", frame->connection_id.ToString())
      .Set("sequence_number", NetLogNumberValue(frame->sequence_number))
      .Set("retire_prior_to", NetLogNumberValue(frame->retire_prior_to));
}

base::Value::Dict NetLogQuicRetireConnectionIdFrameParams(
    const quic::QuicRetireConnectionIdFrame* frame) {
  return base::Value::Dict().Set("sequence_number",
                                 NetLogNumberValue(frame->sequence_number));
}

base::Value::Dict NetLogQuicNewTokenFrameParams(
    const quic::QuicNewTokenFrame* frame) {
  return base::Value::Dict().Set(
      "token",
      NetLogBinaryValue(reinterpret_cast<const void*>(frame->token.data()),
                        frame->token.length()));
}

}  // namespace

QuicEventLogger::QuicEventLogger(quic::QuicSession* session,
                                 const NetLogWithSource& net_log)
    : session_(session), net_log_(net_log) {}

void QuicEventLogger::OnFrameAddedToPacket(const quic::QuicFrame& frame) {
  if (!net_log_.IsCapturing())
    return;
  switch (frame.type) {
    case quic::PADDING_FRAME:
      net_log_.AddEventWithIntParams(
          NetLogEventType::QUIC_SESSION_PADDING_FRAME_SENT, "num_padding_bytes",
          frame.padding_frame.num_padding_bytes);
      break;
    case quic::STREAM_FRAME:
      net_log_.AddEvent(NetLogEventType::QUIC_SESSION_STREAM_FRAME_SENT, [&] {
        return NetLogQuicStreamFrameParams(frame.stream_frame);
      });
      break;
    case quic::ACK_FRAME: {
      net_log_.AddEvent(NetLogEventType::QUIC_SESSION_ACK_FRAME_SENT, [&] {
        return NetLogQuicAckFrameParams(frame.ack_frame);
      });
      break;
    }
    case quic::RST_STREAM_FRAME:
      net_log_.AddEvent(
          NetLogEventType::QUIC_SESSION_RST_STREAM_FRAME_SENT, [&] {
            return NetLogQuicRstStreamFrameParams(frame.rst_stream_frame);
          });
      break;
    case quic::CONNECTION_CLOSE_FRAME:
      net_log_.AddEvent(
          NetLogEventType::QUIC_SESSION_CONNECTION_CLOSE_FRAME_SENT, [&] {
            return NetLogQuicConnectionCloseFrameParams(
                frame.connection_close_frame);
          });
      break;
    case quic::GOAWAY_FRAME:
      net_log_.AddEvent(NetLogEventType::QUIC_SESSION_GOAWAY_FRAME_SENT, [&] {
        return NetLogQuicGoAwayFrameParams(frame.goaway_frame);
      });
      break;
    case quic::WINDOW_UPDATE_FRAME:
      net_log_.AddEvent(
          NetLogEventType::QUIC_SESSION_WINDOW_UPDATE_FRAME_SENT, [&] {
            return NetLogQuicWindowUpdateFrameParams(frame.window_update_frame);
          });
      break;
    case quic::BLOCKED_FRAME:
      net_log_.AddEvent(NetLogEventType::QUIC_SESSION_BLOCKED_FRAME_SENT, [&] {
        return NetLogQuicBlockedFrameParams(frame.blocked_frame);
      });
      break;
    case quic::STOP_WAITING_FRAME:
      net_log_.AddEvent(
          NetLogEventType::QUIC_SESSION_STOP_WAITING_FRAME_SENT, [&] {
            return NetLogQuicStopWaitingFrameParams(&frame.stop_waiting_frame);
          });
      break;
    case quic::PING_FRAME:
      // PingFrame has no contents to log, so just record that it was sent.
      net_log_.AddEvent(NetLogEventType::QUIC_SESSION_PING_FRAME_SENT);
      break;
    case quic::MTU_DISCOVERY_FRAME:
      // MtuDiscoveryFrame is PingFrame on wire, it does not have any payload.
      net_log_.AddEvent(NetLogEventType::QUIC_SESSION_MTU_DISCOVERY_FRAME_SENT);
      break;
    case quic::NEW_CONNECTION_ID_FRAME:
      net_log_.AddEvent(
          NetLogEventType::QUIC_SESSION_NEW_CONNECTION_ID_FRAME_SENT, [&] {
            return NetLogQuicNewConnectionIdFrameParams(
                frame.new_connection_id_frame);
          });
      break;
    case quic::MAX_STREAMS_FRAME:
      net_log_.AddEvent(
          NetLogEventType::QUIC_SESSION_MAX_STREAMS_FRAME_SENT, [&] {
            return NetLogQuicMaxStreamsFrameParams(frame.max_streams_frame);
          });
      break;
    case quic::STREAMS_BLOCKED_FRAME:
      net_log_.AddEvent(
          NetLogEventType::QUIC_SESSION_STREAMS_BLOCKED_FRAME_SENT, [&] {
            return NetLogQuicStreamsBlockedFrameParams(
                frame.streams_blocked_frame);
          });
      break;
    case quic::PATH_RESPONSE_FRAME:
      net_log_.AddEvent(
          NetLogEventType::QUIC_SESSION_PATH_RESPONSE_FRAME_SENT, [&] {
            return NetLogQuicPathData(frame.path_response_frame.data_buffer);
          });
      break;
    case quic::PATH_CHALLENGE_FRAME:
      net_log_.AddEvent(
          NetLogEventType::QUIC_SESSION_PATH_CHALLENGE_FRAME_SENT, [&] {
            return NetLogQuicPathData(frame.path_challenge_frame.data_buffer);
          });
      break;
    case quic::STOP_SENDING_FRAME:
      net_log_.AddEvent(
          NetLogEventType::QUIC_SESSION_STOP_SENDING_FRAME_SENT, [&] {
            return NetLogQuicStopSendingFrameParams(frame.stop_sending_frame);
          });
      break;
    case quic::MESSAGE_FRAME:
      net_log_.AddEventWithIntParams(
          NetLogEventType::QUIC_SESSION_MESSAGE_FRAME_SENT, "message_length",
          frame.message_frame->message_length);
      break;
    case quic::CRYPTO_FRAME:
      net_log_.AddEvent(NetLogEventType::QUIC_SESSION_CRYPTO_FRAME_SENT, [&] {
        return NetLogQuicCryptoFrameParams(frame.crypto_frame,
                                           /*has_buffer = */ false);
      });
      break;
    case quic::NEW_TOKEN_FRAME:
      net_log_.AddEvent(
          NetLogEventType::QUIC_SESSION_NEW_TOKEN_FRAME_SENT,
          [&] { return NetLogQuicNewTokenFrameParams(frame.new_token_frame); });
      break;
    case quic::RETIRE_CONNECTION_ID_FRAME:
      net_log_.AddEvent(
          NetLogEventType::QUIC_SESSION_RETIRE_CONNECTION_ID_FRAME_SENT, [&] {
            return NetLogQuicRetireConnectionIdFrameParams(
                frame.retire_connection_id_frame);
          });
      break;
    default:
      DCHECK(false) << "Illegal frame type: " << frame.type;
  }
}

void QuicEventLogger::OnStreamFrameCoalesced(
    const quic::QuicStreamFrame& frame) {
  net_log_.AddEvent(NetLogEventType::QUIC_SESSION_STREAM_FRAME_COALESCED,
                    [&] { return NetLogQuicStreamFrameParams(frame); });
}

void QuicEventLogger::OnPacketSent(
    quic::QuicPacketNumber packet_number,
    quic::QuicPacketLength packet_length,
    bool /*has_crypto_handshake*/,
    quic::TransmissionType transmission_type,
    quic::EncryptionLevel encryption_level,
    const quic::QuicFrames& /*retransmittable_frames*/,
    const quic::QuicFrames& /*nonretransmittable_frames*/,
    quic::QuicTime sent_time,
    uint32_t batch_id) {
  net_log_.AddEvent(NetLogEventType::QUIC_SESSION_PACKET_SENT, [&] {
    return NetLogQuicPacketSentParams(packet_number, packet_length,
                                      transmission_type, encryption_level,
                                      sent_time, batch_id);
  });
}

void QuicEventLogger::OnIncomingAck(
    quic::QuicPacketNumber ack_packet_number,
    quic::EncryptionLevel /*ack_decrypted_level*/,
    const quic::QuicAckFrame& frame,
    quic::QuicTime ack_receive_time,
    quic::QuicPacketNumber largest_observed,
    bool rtt_updated,
    quic::QuicPacketNumber least_unacked_sent_packet) {
  net_log_.AddEvent(NetLogEventType::QUIC_SESSION_ACK_FRAME_RECEIVED,
                    [&] { return NetLogQuicAckFrameParams(&frame); });
}

void QuicEventLogger::OnPacketLoss(quic::QuicPacketNumber lost_packet_number,
                                   quic::EncryptionLevel /*encryption_level*/,
                                   quic::TransmissionType transmission_type,
                                   quic::QuicTime detection_time) {
  net_log_.AddEvent(NetLogEventType::QUIC_SESSION_PACKET_LOST, [&] {
    return NetLogQuicPacketLostParams(lost_packet_number, transmission_type,
                                      detection_time);
  });
}

void QuicEventLogger::OnConfigProcessed(
    const quic::QuicSentPacketManager::DebugDelegate::SendParameters&
        parameters) {
  net_log_.AddEvent(NetLogEventType::QUIC_CONGESTION_CONTROL_CONFIGURED,
                    [&] { return NetLogQuicConfigProcessed(parameters); });
}

void QuicEventLogger::OnPacketReceived(
    const quic::QuicSocketAddress& self_address,
    const quic::QuicSocketAddress& peer_address,
    const quic::QuicEncryptedPacket& packet) {
  net_log_.AddEvent(NetLogEventType::QUIC_SESSION_PACKET_RECEIVED, [&] {
    return NetLogQuicPacketParams(self_address, peer_address, packet.length());
  });
}

void QuicEventLogger::OnUnauthenticatedHeader(
    const quic::QuicPacketHeader& header) {
  net_log_.AddEvent(
      NetLogEventType::QUIC_SESSION_UNAUTHENTICATED_PACKET_HEADER_RECEIVED,
      [&] {
        return NetLogReceivedQuicPacketHeaderParams(
            header, session_->version(),
            session_->connection()->connection_id(),
            session_->connection()->client_connection_id());
      });
}

void QuicEventLogger::OnUndecryptablePacket(
    quic::EncryptionLevel decryption_level,
    bool dropped) {
  if (dropped) {
    net_log_.AddEventWithStringParams(
        NetLogEventType::QUIC_SESSION_DROPPED_UNDECRYPTABLE_PACKET,
        "encryption_level", quic::EncryptionLevelToString(decryption_level));
    return;
  }
  net_log_.AddEventWithStringParams(
      NetLogEventType::QUIC_SESSION_BUFFERED_UNDECRYPTABLE_PACKET,
      "encryption_level", quic::EncryptionLevelToString(decryption_level));
}

void QuicEventLogger::OnAttemptingToProcessUndecryptablePacket(
    quic::EncryptionLevel decryption_level) {
  net_log_.AddEventWithStringParams(
      NetLogEventType::QUIC_SESSION_ATTEMPTING_TO_PROCESS_UNDECRYPTABLE_PACKET,
      "encryption_level", quic::EncryptionLevelToString(decryption_level));
}

void QuicEventLogger::OnDuplicatePacket(quic::QuicPacketNumber packet_number) {
  net_log_.AddEvent(
      NetLogEventType::QUIC_SESSION_DUPLICATE_PACKET_RECEIVED,
      [&] { return NetLogQuicDuplicatePacketParams(packet_number); });
}

void QuicEventLogger::OnPacketHeader(const quic::QuicPacketHeader& header,
                                     quic::QuicTime /*receive_time*/,
                                     quic::EncryptionLevel /*level*/) {
  net_log_.AddEvent(NetLogEventType::QUIC_SESSION_PACKET_AUTHENTICATED);
}

void QuicEventLogger::OnStreamFrame(const quic::QuicStreamFrame& frame) {
  net_log_.AddEvent(NetLogEventType::QUIC_SESSION_STREAM_FRAME_RECEIVED,
                    [&] { return NetLogQuicStreamFrameParams(frame); });
}

void QuicEventLogger::OnPathChallengeFrame(
    const quic::QuicPathChallengeFrame& frame) {
  net_log_.AddEvent(NetLogEventType::QUIC_SESSION_PATH_CHALLENGE_FRAME_RECEIVED,
                    [&] { return NetLogQuicPathData(frame.data_buffer); });
}

void QuicEventLogger::OnPathResponseFrame(
    const quic::QuicPathResponseFrame& frame) {
  net_log_.AddEvent(NetLogEventType::QUIC_SESSION_PATH_RESPONSE_FRAME_RECEIVED,
                    [&] { return NetLogQuicPathData(frame.data_buffer); });
}

void QuicEventLogger::OnCryptoFrame(const quic::QuicCryptoFrame& frame) {
  net_log_.AddEvent(NetLogEventType::QUIC_SESSION_CRYPTO_FRAME_RECEIVED, [&] {
    return NetLogQuicCryptoFrameParams(&frame, /*has_buffer = */ true);
  });
}

void QuicEventLogger::OnStopSendingFrame(
    const quic::QuicStopSendingFrame& frame) {
  net_log_.AddEvent(NetLogEventType::QUIC_SESSION_STOP_SENDING_FRAME_RECEIVED,
                    [&] { return NetLogQuicStopSendingFrameParams(frame); });
}

void QuicEventLogger::OnStreamsBlockedFrame(
    const quic::QuicStreamsBlockedFrame& frame) {
  net_log_.AddEvent(
      NetLogEventType::QUIC_SESSION_STREAMS_BLOCKED_FRAME_RECEIVED,
      [&] { return NetLogQuicStreamsBlockedFrameParams(frame); });
}

void QuicEventLogger::OnMaxStreamsFrame(
    const quic::QuicMaxStreamsFrame& frame) {
  net_log_.AddEvent(NetLogEventType::QUIC_SESSION_MAX_STREAMS_FRAME_RECEIVED,
                    [&] { return NetLogQuicMaxStreamsFrameParams(frame); });
}

void QuicEventLogger::OnRstStreamFrame(const quic::QuicRstStreamFrame& frame) {
  net_log_.AddEvent(NetLogEventType::QUIC_SESSION_RST_STREAM_FRAME_RECEIVED,
                    [&] { return NetLogQuicRstStreamFrameParams(&frame); });
}

void QuicEventLogger::OnConnectionCloseFrame(
    const quic::QuicConnectionCloseFrame& frame) {
  net_log_.AddEvent(
      NetLogEventType::QUIC_SESSION_CONNECTION_CLOSE_FRAME_RECEIVED,
      [&] { return NetLogQuicConnectionCloseFrameParams(&frame); });
}

void QuicEventLogger::OnWindowUpdateFrame(
    const quic::QuicWindowUpdateFrame& frame,
    const quic::QuicTime& receive_time) {
  net_log_.AddEvent(NetLogEventType::QUIC_SESSION_WINDOW_UPDATE_FRAME_RECEIVED,
                    [&] { return NetLogQuicWindowUpdateFrameParams(frame); });
}

void QuicEventLogger::OnBlockedFrame(const quic::QuicBlockedFrame& frame) {
  net_log_.AddEvent(NetLogEventType::QUIC_SESSION_BLOCKED_FRAME_RECEIVED,
                    [&] { return NetLogQuicBlockedFrameParams(frame); });
}

void QuicEventLogger::OnGoAwayFrame(const quic::QuicGoAwayFrame& frame) {
  net_log_.AddEvent(NetLogEventType::QUIC_SESSION_GOAWAY_FRAME_RECEIVED,
                    [&] { return NetLogQuicGoAwayFrameParams(&frame); });
}

void QuicEventLogger::OnPingFrame(
    const quic::QuicPingFrame& frame,
    quic::QuicTime::Delta /*ping_received_delay*/) {
  // PingFrame has no contents to log, so just record that it was received.
  net_log_.AddEvent(NetLogEventType::QUIC_SESSION_PING_FRAME_RECEIVED);
}

void QuicEventLogger::OnPaddingFrame(const quic::QuicPaddingFrame& frame) {
  net_log_.AddEventWithIntParams(
      NetLogEventType::QUIC_SESSION_PADDING_FRAME_RECEIVED, "num_padding_bytes",
      frame.num_padding_bytes);
}

void QuicEventLogger::OnNewConnectionIdFrame(
    const quic::QuicNewConnectionIdFrame& frame) {
  net_log_.AddEvent(
      NetLogEventType::QUIC_SESSION_NEW_CONNECTION_ID_FRAME_RECEIVED,
      [&] { return NetLogQuicNewConnectionIdFrameParams(&frame); });
}

void QuicEventLogger::OnNewTokenFrame(const quic::QuicNewTokenFrame& frame) {
  net_log_.AddEvent(NetLogEventType::QUIC_SESSION_NEW_TOKEN_FRAME_RECEIVED,
                    [&] { return NetLogQuicNewTokenFrameParams(&frame); });
}

void QuicEventLogger::OnRetireConnectionIdFrame(
    const quic::QuicRetireConnectionIdFrame& frame) {
  net_log_.AddEvent(
      NetLogEventType::QUIC_SESSION_RETIRE_CONNECTION_ID_FRAME_RECEIVED,
      [&] { return NetLogQuicRetireConnectionIdFrameParams(&frame); });
}

void QuicEventLogger::OnMessageFrame(const quic::QuicMessageFrame& frame) {
  net_log_.AddEventWithIntParams(
      NetLogEventType::QUIC_SESSION_MESSAGE_FRAME_RECEIVED, "message_length",
      frame.message_length);
}

void QuicEventLogger::OnHandshakeDoneFrame(
    const quic::QuicHandshakeDoneFrame& frame) {
  net_log_.AddEvent(
      NetLogEventType::QUIC_SESSION_HANDSHAKE_DONE_FRAME_RECEIVED);
}

void QuicEventLogger::OnCoalescedPacketSent(
    const quic::QuicCoalescedPacket& coalesced_packet,
    size_t length) {
  net_log_.AddEventWithStringParams(
      NetLogEventType::QUIC_SESSION_COALESCED_PACKET_SENT, "info",
      coalesced_packet.ToString(length));
}

void QuicEventLogger::OnVersionNegotiationPacket(
    const quic::QuicVersionNegotiationPacket& packet) {
  net_log_.AddEvent(
      NetLogEventType::QUIC_SESSION_VERSION_NEGOTIATION_PACKET_RECEIVED,
      [&] { return NetLogQuicVersionNegotiationPacketParams(&packet); });
}

void QuicEventLogger::OnCryptoHandshakeMessageReceived(
    const quic::CryptoHandshakeMessage& message) {
  if (message.tag() == quic::kSHLO) {
    std::string_view address;
    quic::QuicSocketAddressCoder decoder;
    if (message.GetStringPiece(quic::kCADR, &address) &&
        decoder.Decode(address.data(), address.size())) {
      local_address_from_shlo_ =
          IPEndPoint(ToIPAddress(decoder.ip()), decoder.port());
    }
  }

  net_log_.AddEvent(
      NetLogEventType::QUIC_SESSION_CRYPTO_HANDSHAKE_MESSAGE_RECEIVED,
      [&] { return NetLogQuicCryptoHandshakeMessageParams(&message); });
}

void QuicEventLogger::OnCryptoHandshakeMessageSent(
    const quic::CryptoHandshakeMessage& message) {
  net_log_.AddEvent(
      NetLogEventType::QUIC_SESSION_CRYPTO_HANDSHAKE_MESSAGE_SENT,
      [&] { return NetLogQuicCryptoHandshakeMessageParams(&message); });
}

void QuicEventLogger::OnConnectionClosed(
    const quic::QuicConnectionCloseFrame& frame,
    quic::ConnectionCloseSource source) {
  net_log_.AddEvent(NetLogEventType::QUIC_SESSION_CLOSED, [&] {
    return NetLogQuicOnConnectionClosedParams(frame.quic_error_code,
                                              frame.error_details, source);
  });
}

void QuicEventLogger::OnSuccessfulVersionNegotiation(
    const quic::ParsedQuicVersion& version) {
  if (!net_log_.IsCapturing())
    return;
  std::string quic_version = quic::ParsedQuicVersionToString(version);
  net_log_.AddEventWithStringParams(
      NetLogEventType::QUIC_SESSION_VERSION_NEGOTIATED, "version",
      quic_version);
}

void QuicEventLogger::OnCertificateVerified(const CertVerifyResult& result) {
  if (result.cert_status == CERT_STATUS_INVALID) {
    net_log_.AddEvent(NetLogEventType::QUIC_SESSION_CERTIFICATE_VERIFY_FAILED);
    return;
  }
  net_log_.AddEvent(NetLogEventType::QUIC_SESSION_CERTIFICATE_VERIFIED, [&] {
    return NetLogQuicCertificateVerifiedParams(result.verified_cert);
  });
}

void QuicEventLogger::OnTransportParametersSent(
    const quic::TransportParameters& transport_parameters) {
  net_log_.AddEvent(
      NetLogEventType::QUIC_SESSION_TRANSPORT_PARAMETERS_SENT, [&] {
        return NetLogQuicTransportParametersParams(transport_parameters);
      });
}

void QuicEventLogger::OnTransportParametersReceived(
    const quic::TransportParameters& transport_parameters) {
  net_log_.AddEvent(
      NetLogEventType::QUIC_SESSION_TRANSPORT_PARAMETERS_RECEIVED, [&] {
        return NetLogQuicTransportParametersParams(transport_parameters);
      });
}

void QuicEventLogger::OnTransportParametersResumed(
    const quic::TransportParameters& transport_parameters) {
  net_log_.AddEvent(
      NetLogEventType::QUIC_SESSION_TRANSPORT_PARAMETERS_RESUMED, [&] {
        return NetLogQuicTransportParametersParams(transport_parameters);
      });
}

void QuicEventLogger::OnZeroRttRejected(int reason) {
  net_log_.AddEvent(NetLogEventType::QUIC_SESSION_ZERO_RTT_REJECTED,
                    [reason] { return NetLogQuicZeroRttRejectReason(reason); });
}

void QuicEventLogger::OnEncryptedClientHelloSent(
    std::string_view client_hello) {
  net_log_.AddEvent(NetLogEventType::SSL_ENCRYPTED_CLIENT_HELLO, [&] {
    return base::Value::Dict().Set(
        "bytes", NetLogBinaryValue(base::as_byte_span(client_hello)));
  });
}

}  // namespace net

"""

```
Response:
Let's break down the thought process for analyzing this Chromium source code.

1. **Understand the Goal:** The request asks for a breakdown of the file `websocket_basic_handshake_stream.cc`, focusing on its functionality, relationship to JavaScript, logical reasoning (input/output), common errors, and debugging.

2. **Initial Skim and Identification of Key Classes/Namespaces:**  A quick scan reveals the namespace `net`, and the class `WebSocketBasicHandshakeStream`. The name strongly suggests it handles the initial handshake for WebSocket connections. Other related names like `WebSocketStream`, `HttpRequestHeaders`, `HttpResponseHeaders`, and `HttpStreamParser` point towards network communication and HTTP concepts. The presence of `kSecWebSocketAccept`, `kSecWebSocketKey`, `kUpgrade` reinforces the WebSocket handshake theme.

3. **Functionality - Core Purpose:** The primary goal is to establish a WebSocket connection. This involves sending an HTTP upgrade request and validating the server's response. Keywords like "handshake," "upgrade," "challenge," and "accept" are central. I'd formulate a high-level summary like: "This file implements the client-side logic for performing the basic WebSocket handshake, which upgrades an HTTP connection to a WebSocket connection."

4. **Functionality - Detailed Breakdown (Method by Method):**  Now, go through the class methods. For each method, understand its purpose and how it contributes to the handshake process:

    * **Constructor/Destructor:**  Initialization and cleanup, recording the handshake result.
    * **`RegisterRequest`:** Stores the HTTP request information.
    * **`InitializeStream`:** Sets up the initial state, potentially handling early data.
    * **`SendRequest`:**  Crucial – constructs and sends the HTTP upgrade request, including the `Sec-WebSocket-Key`. This is where the client's challenge is generated.
    * **`ReadResponseHeaders`:**  Reads the server's HTTP response headers.
    * **`ReadResponseBody`:**  Reads the response body (though for successful handshakes, this might be empty or minimal).
    * **`Close`:**  Closes the underlying connection.
    * **`IsResponseBodyComplete`:** Checks if the response body has been fully read.
    * **Connection Reuse Methods:** `IsConnectionReused`, `SetConnectionReused`, `CanReuseConnection`. These relate to HTTP keep-alive and connection pooling.
    * **`GetTotalReceivedBytes`/`GetTotalSentBytes`:**  Metrics (likely unused at this stage of the handshake).
    * **`GetAlternativeService`/`GetLoadTimingInfo`/`GetSSLInfo`/`GetRemoteEndpoint`/`PopulateNetErrorDetails`:**  Information retrieval about the underlying connection.
    * **`Drain`:** Handles draining the response body in case of errors or redirects.
    * **`SetPriority`:**  Sets the request priority.
    * **`RenewStreamForAuth`:** Creates a new handshake stream for authentication retries.
    * **`GetDnsAliases`/`GetAcceptChViaAlps`:**  Additional connection information.
    * **`Upgrade`:**  The success path! Transforms the handshake stream into a `WebSocketBasicStream` for actual data transfer. Handles extensions like deflate.
    * **`CanReadFromStream`:** Checks if the underlying socket is ready for reading.
    * **`GetWeakPtr`:**  For managing object lifetime.
    * **`SetWebSocketKeyForTesting`:**  A testing utility.
    * **`ReadResponseHeadersCallback`:**  Handles the result of reading response headers.
    * **`ValidateResponse`:**  The core validation logic for the HTTP response status code.
    * **`ValidateUpgradeResponse`:**  Detailed validation of WebSocket-specific headers.
    * **`OnFailure`:** Handles handshake failures, logging and informing the delegate.
    * **Helper Functions:** `GenerateHandshakeChallenge`, `ComputeSecWebSocketAccept`, validation helper functions.

5. **Relationship to JavaScript:** Think about how a web page initiates a WebSocket connection. The `WebSocket` API in JavaScript is the starting point. The browser (using code like this C++ file) implements the underlying mechanics. Key connections:

    * **`new WebSocket(url)`:** This JavaScript initiates the process that eventually leads to this C++ code.
    * **`Sec-WebSocket-Key`:** The JavaScript API doesn't expose this directly, but the browser generates it internally.
    * **`Sec-WebSocket-Accept`:** The server's response header, validated by this C++ code, confirms the handshake.
    * **Subprotocols and Extensions:**  JavaScript's `WebSocket` constructor allows specifying these. This C++ code handles sending and validating them.
    * **Error Handling:**  If the handshake fails in the C++ code (e.g., due to validation errors), the JavaScript `onerror` event is triggered.

6. **Logical Reasoning (Input/Output):** Focus on the `SendRequest` and `ValidateUpgradeResponse` methods.

    * **Input to `SendRequest`:** The HTTP headers generated by the browser (including `Origin`, `Upgrade`, `Connection`, `Sec-WebSocket-Version`) and the target URL.
    * **Output of `SendRequest`:** The HTTP upgrade request sent to the server, containing the generated `Sec-WebSocket-Key`.
    * **Input to `ValidateUpgradeResponse`:** The HTTP response headers received from the server (including `Upgrade`, `Connection`, `Sec-WebSocket-Accept`, potentially `Sec-WebSocket-Protocol`, `Sec-WebSocket-Extensions`).
    * **Output of `ValidateUpgradeResponse`:**  Either `OK` (handshake success) or an error code (handshake failure). If successful, it also populates `sub_protocol_` and `extensions_`.

7. **Common User/Programming Errors:** Consider what could go wrong from both a web developer's and a browser's perspective:

    * **JavaScript:** Incorrect URL, trying to connect to a non-WebSocket server, mismatch in subprotocols or extensions.
    * **Browser/Network:** Network issues, server not supporting WebSockets, incorrect server implementation of the handshake.

8. **Debugging:** Trace a typical user action leading to this code:

    1. User opens a web page in Chrome.
    2. JavaScript on the page executes `new WebSocket("ws://example.com/socket")`.
    3. Chrome's network stack initiates a connection to `example.com`.
    4. This `WebSocketBasicHandshakeStream` object is created.
    5. `SendRequest` sends the upgrade request.
    6. The server responds.
    7. `ReadResponseHeaders` and `ValidateResponse`/`ValidateUpgradeResponse` process the response.
    8. If successful, `Upgrade` creates the data stream. If not, `OnFailure` is called.

9. **Refine and Organize:** Structure the information logically with clear headings and examples. Use bullet points for lists of functionalities, errors, etc. Ensure the language is clear and concise. Double-check for accuracy and completeness. For example, initially, I might forget to explicitly mention the generation of `Sec-WebSocket-Key` – a review step would catch this. Similarly, ensuring that the JavaScript API connections are clearly articulated is important.

This systematic approach allows for a comprehensive understanding of the code's purpose and its role in the larger WebSocket connection process.
This C++ source code file, `websocket_basic_handshake_stream.cc`, which is part of the Chromium network stack, is responsible for handling the **client-side of the WebSocket basic handshake process**. This is the initial phase of establishing a WebSocket connection, where the client sends an HTTP upgrade request and verifies the server's response to confirm the upgrade.

Here's a breakdown of its functionality:

**Core Functionality:**

1. **Initiating the Handshake Request:**
   - It constructs and sends an HTTP GET request with specific headers required for the WebSocket handshake.
   - This includes headers like `Upgrade: websocket`, `Connection: Upgrade`, `Sec-WebSocket-Version`, `Sec-WebSocket-Key`, and optionally `Sec-WebSocket-Protocol` and `Sec-WebSocket-Extensions`.
   - The `Sec-WebSocket-Key` is a randomly generated Base64-encoded value used to verify the server's response.

2. **Validating the Handshake Response:**
   - It parses and validates the HTTP response headers from the server.
   - It checks for the presence and correctness of mandatory headers like:
     - `HTTP/101 Switching Protocols` status code.
     - `Upgrade: websocket`
     - `Connection: Upgrade`
     - `Sec-WebSocket-Accept`: This header's value is derived from the client's `Sec-WebSocket-Key` using a specific algorithm (SHA-1 and Base64 encoding). The client verifies if the server's `Sec-WebSocket-Accept` matches the expected value.
   - It also validates optional headers like `Sec-WebSocket-Protocol` and `Sec-WebSocket-Extensions` if they were requested by the client.

3. **Upgrading to a WebSocket Stream:**
   - If the handshake is successful, it transitions the underlying network socket from an HTTP stream to a `WebSocketBasicStream` (or potentially a `WebSocketDeflateStream` if compression extensions are negotiated). This new stream is used for the actual WebSocket data transfer.

4. **Handling Handshake Failures:**
   - If the server's response is invalid (e.g., incorrect status code, missing or incorrect headers), it reports the failure and does not proceed with the WebSocket connection.

**Relationship with JavaScript:**

This C++ code directly supports the `WebSocket` API available in JavaScript within web browsers. Here's how they relate:

* **JavaScript `new WebSocket(url, protocols)`:** When JavaScript code executes `new WebSocket("ws://example.com/socket", ["chat", "superchat"])`, the browser's network stack (including this C++ file) is invoked.
* **Handshake Initiation:** The JavaScript `WebSocket` constructor triggers the creation of a `WebSocketBasicHandshakeStream` object in the browser's C++ code.
* **`Sec-WebSocket-Key` Generation:** The C++ code in this file (specifically the `GenerateHandshakeChallenge` function) is responsible for generating the random `Sec-WebSocket-Key` that is sent in the handshake request. JavaScript doesn't handle this directly.
* **Handshake Header Construction:**  The C++ code builds the necessary HTTP headers for the upgrade request based on the URL and the optional `protocols` and `extensions` provided in the JavaScript `WebSocket` constructor.
* **`Sec-WebSocket-Accept` Validation:**  The server's `Sec-WebSocket-Accept` header, which is crucial for security, is validated by the C++ code in this file. If the validation fails, the JavaScript `onerror` event for the WebSocket object will be triggered.
* **Subprotocol and Extension Negotiation:** If the JavaScript code specified subprotocols or extensions, this C++ code handles adding the corresponding headers to the request and validating the server's acceptance in the response. The negotiated subprotocol and extensions are then made available for use by the `WebSocketBasicStream`.
* **Error Reporting:** If the C++ handshake process encounters an error, it informs the higher-level WebSocket implementation, which in turn will trigger the `onerror` event in the JavaScript `WebSocket` object.

**Example of JavaScript Interaction:**

```javascript
const websocket = new WebSocket("ws://example.com/socket", ["chat"]);

websocket.onopen = function(event) {
  console.log("WebSocket connection opened!");
  websocket.send("Hello from JavaScript!");
};

websocket.onmessage = function(event) {
  console.log("Received message:", event.data);
};

websocket.onerror = function(event) {
  console.error("WebSocket error:", event);
};

websocket.onclose = function(event) {
  console.log("WebSocket connection closed.");
};
```

In this example, when `new WebSocket(...)` is called, the Chromium network stack uses `websocket_basic_handshake_stream.cc` to perform the initial handshake with the server at `ws://example.com/socket`. The `["chat"]` array specifies a requested subprotocol. This C++ code will include a `Sec-WebSocket-Protocol: chat` header in the handshake request and verify if the server responds with the same header.

**Logical Reasoning (Hypothetical Input & Output):**

**Scenario:** A JavaScript client attempts to connect to a WebSocket server.

**Hypothetical Input (from higher layers):**

* **URL:** `ws://example.com/chat`
* **Requested Subprotocols:** `["chat", "superchat"]`
* **Requested Extensions:** `["permessage-deflate"]`
* **Underlying Socket:** A TCP connection to `example.com:80`.

**Logical Processing within `websocket_basic_handshake_stream.cc`:**

1. **Generate `Sec-WebSocket-Key`:** A random 16-byte value is generated (e.g., `bXkgaCIkc2hhbGtleXM=`), which is then Base64 encoded.
2. **Construct Handshake Request:**
   ```
   GET /chat HTTP/1.1
   Host: example.com
   Upgrade: websocket
   Connection: Upgrade
   Sec-WebSocket-Version: 13
   Sec-WebSocket-Key: bXkgaCIkc2hhbGtleXM=
   Origin: http://yourdomain.com
   Sec-WebSocket-Protocol: chat, superchat
   Sec-WebSocket-Extensions: permessage-deflate
   ```
3. **Send Request to Server.**
4. **Receive Response from Server:**
   ```
   HTTP/1.1 101 Switching Protocols
   Upgrade: websocket
   Connection: Upgrade
   Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
   Sec-WebSocket-Protocol: chat
   Sec-WebSocket-Extensions: permessage-deflate
   ```
5. **Validate Response:**
   - Check status code: `101`.
   - Check `Upgrade` and `Connection` headers.
   - Calculate the expected `Sec-WebSocket-Accept` based on the generated `Sec-WebSocket-Key`. If the client's `Sec-WebSocket-Key` was `bXkgaCIkc2hhbGtleXM=`, the expected `Sec-WebSocket-Accept` would be the SHA-1 hash of `bXkgaCIkc2hhbGtleXM=258EAFA5-E914-47DA-95CA-C5ABB0DC811B` (the magic GUID), Base64 encoded, which is `s3pPLMBiTxaQ9kYGzzhZRbK+xOo=`.
   - Verify the server's `Sec-WebSocket-Protocol` matches one of the requested ones (`chat`).
   - Verify the server's `Sec-WebSocket-Extensions`.

**Hypothetical Output (if successful):**

* **`OK` (success code)** is returned to the calling layer.
* The underlying socket is upgraded to a `WebSocketBasicStream` (or `WebSocketDeflateStream` in this case).
* The negotiated subprotocol (`chat`) and extensions (`permessage-deflate`) are stored for later use.

**Hypothetical Output (if failure - e.g., incorrect `Sec-WebSocket-Accept`):**

* **`ERR_INVALID_RESPONSE`** is returned.
* An error message is logged (e.g., "Error during WebSocket handshake: Incorrect 'Sec-WebSocket-Accept' header value").
* The underlying connection is likely closed.

**User or Programming Common Usage Errors:**

1. **Incorrect WebSocket URL:** If a user (or the JavaScript code) provides an incorrect URL that doesn't point to a WebSocket endpoint, the server will likely respond with a non-101 status code (e.g., 404 Not Found), causing the handshake to fail.
   ```javascript
   // Error: Connecting to an HTTP endpoint, not a WebSocket endpoint
   const websocket = new WebSocket("http://example.com/");
   ```
   **Consequence:** The `ValidateResponse` function will detect the non-101 status code and trigger the `OnFailure` path, reporting an error to the JavaScript `onerror` handler.

2. **Server Not Supporting WebSockets:** If the server doesn't understand the WebSocket upgrade request, it might return a 400 Bad Request or other error codes.
   **Consequence:** Similar to the incorrect URL case, `ValidateResponse` will handle this.

3. **Mismatched Subprotocols or Extensions:** If the client requests specific subprotocols or extensions, and the server doesn't support or doesn't agree to them, the handshake will fail if the server doesn't include the agreed-upon values in its response.
   ```javascript
   const websocket = new WebSocket("ws://example.com/socket", ["custom-protocol"]);
   // If the server doesn't send back 'Sec-WebSocket-Protocol: custom-protocol'
   ```
   **Consequence:** The `ValidateSubProtocol` or `ValidateExtensions` functions will detect the mismatch and `ValidateUpgradeResponse` will return an error.

4. **Network Issues:** General network connectivity problems will prevent the handshake from completing successfully.
   **Consequence:** The underlying socket operations will return errors (like `ERR_CONNECTION_REFUSED`, `ERR_TIMED_OUT`), which will be propagated up and likely result in a WebSocket error in JavaScript.

**How User Operations Reach This Code (Debugging Clues):**

1. **User Opens a Web Page:** The user navigates to a web page in Chrome.
2. **JavaScript Execution:** The web page's JavaScript code contains `new WebSocket(...)`.
3. **Browser Network Stack Initialization:** Chrome's rendering engine interprets the JavaScript and calls into the browser's network stack to initiate the WebSocket connection.
4. **`WebSocketStream::Connect` (or similar):**  A higher-level component within the network stack (like `WebSocketStream::Connect`) is responsible for creating and managing the WebSocket connection attempt.
5. **`WebSocketBasicHandshakeStream` Creation:**  As part of the connection process, a `WebSocketBasicHandshakeStream` object is created to handle the handshake. This is where the code in this file comes into play.
6. **`InitializeStream` and `SendRequest`:** The `InitializeStream` method is called to set up the initial state, and then `SendRequest` is invoked to send the HTTP upgrade request to the server.
7. **Socket I/O:** The underlying socket performs the actual network communication. You can use network debugging tools (like Chrome DevTools' Network tab with "WS" filter) to observe the HTTP handshake request and response.
8. **`ReadResponseHeaders` and Validation:** Upon receiving a response, `ReadResponseHeaders` is called, followed by the various validation functions (`ValidateResponse`, `ValidateUpgradeResponse`, etc.).
9. **Success or Failure:** Based on the validation results, either the connection is upgraded, or an error is reported.

**Debugging Tips:**

* **Chrome DevTools (Network Tab):** Inspect the "Frames" section of a WebSocket connection to see the raw WebSocket messages after the handshake. Look at the "Headers" section during the initial request to see the handshake headers being exchanged.
* **`chrome://net-internals/#sockets` and `chrome://net-internals/#events`:** These internal Chrome pages provide detailed information about network events, including socket connections and WebSocket handshakes. You can filter by the relevant domain or connection ID.
* **Logging:** Chromium's network stack has extensive logging capabilities. While you might not have direct access to these logs as a user, developers working on Chromium can use these logs to trace the execution flow and identify issues during the handshake.
* **Breakpoints (for Chromium Developers):** Developers can set breakpoints in this `websocket_basic_handshake_stream.cc` file to step through the code and understand the exact sequence of operations and the values of variables during the handshake process.

In summary, `websocket_basic_handshake_stream.cc` is a critical component for establishing WebSocket connections in Chromium, responsible for the client-side logic of the initial handshake, ensuring the secure and correct transition from HTTP to the WebSocket protocol. It directly interacts with the JavaScript `WebSocket` API and handles potential errors during the handshake process.

### 提示词
```
这是目录为net/websockets/websocket_basic_handshake_stream.cc的chromium 网络栈的源代码文件， 请列举一下它的功能, 
如果它与javascript的功能有关系，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索。
```

### 源代码
```cpp
// Copyright 2013 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "net/websockets/websocket_basic_handshake_stream.h"

#include <stddef.h>

#include <array>
#include <set>
#include <string_view>
#include <type_traits>
#include <utility>

#include "base/base64.h"
#include "base/check.h"
#include "base/check_op.h"
#include "base/functional/bind.h"
#include "base/functional/callback.h"
#include "base/memory/scoped_refptr.h"
#include "base/metrics/histogram_functions.h"
#include "base/strings/strcat.h"
#include "base/strings/string_util.h"
#include "base/strings/stringprintf.h"
#include "base/time/time.h"
#include "base/values.h"
#include "crypto/random.h"
#include "net/base/net_errors.h"
#include "net/http/http_network_session.h"
#include "net/http/http_request_headers.h"
#include "net/http/http_request_info.h"
#include "net/http/http_response_body_drainer.h"
#include "net/http/http_response_headers.h"
#include "net/http/http_response_info.h"
#include "net/http/http_status_code.h"
#include "net/http/http_stream_parser.h"
#include "net/http/http_version.h"
#include "net/log/net_log_event_type.h"
#include "net/socket/client_socket_handle.h"
#include "net/socket/stream_socket.h"
#include "net/socket/websocket_transport_client_socket_pool.h"
#include "net/ssl/ssl_cert_request_info.h"
#include "net/ssl/ssl_info.h"
#include "net/traffic_annotation/network_traffic_annotation.h"
#include "net/websockets/websocket_basic_stream.h"
#include "net/websockets/websocket_basic_stream_adapters.h"
#include "net/websockets/websocket_deflate_predictor_impl.h"
#include "net/websockets/websocket_deflate_stream.h"
#include "net/websockets/websocket_handshake_challenge.h"
#include "net/websockets/websocket_handshake_constants.h"
#include "net/websockets/websocket_handshake_request_info.h"
#include "net/websockets/websocket_stream.h"

namespace net {
class HttpStream;
class IOBuffer;
class IPEndPoint;
struct AlternativeService;
struct LoadTimingInfo;
struct NetErrorDetails;

namespace {

constexpr char kConnectionErrorStatusLine[] = "HTTP/1.1 503 Connection Error";

}  // namespace

namespace {

enum GetHeaderResult {
  GET_HEADER_OK,
  GET_HEADER_MISSING,
  GET_HEADER_MULTIPLE,
};

std::string MissingHeaderMessage(const std::string& header_name) {
  return base::StrCat({"'", header_name, "' header is missing"});
}

std::string GenerateHandshakeChallenge() {
  std::array<uint8_t, websockets::kRawChallengeLength> raw_challenge = {};
  crypto::RandBytes(raw_challenge);
  return base::Base64Encode(raw_challenge);
}

GetHeaderResult GetSingleHeaderValue(const HttpResponseHeaders* headers,
                                     std::string_view name,
                                     std::string* value) {
  size_t iter = 0;
  bool found_value = false;
  while (std::optional<std::string_view> maybe_value =
             headers->EnumerateHeader(&iter, name)) {
    if (found_value) {
      return GET_HEADER_MULTIPLE;
    }
    found_value = true;
    *value = *maybe_value;
  }
  return found_value ? GET_HEADER_OK : GET_HEADER_MISSING;
}

bool ValidateHeaderHasSingleValue(GetHeaderResult result,
                                  const std::string& header_name,
                                  std::string* failure_message) {
  if (result == GET_HEADER_MISSING) {
    *failure_message = MissingHeaderMessage(header_name);
    return false;
  }
  if (result == GET_HEADER_MULTIPLE) {
    *failure_message =
        WebSocketHandshakeStreamBase::MultipleHeaderValuesMessage(header_name);
    return false;
  }
  DCHECK_EQ(result, GET_HEADER_OK);
  return true;
}

bool ValidateUpgrade(const HttpResponseHeaders* headers,
                     std::string* failure_message) {
  std::string value;
  GetHeaderResult result =
      GetSingleHeaderValue(headers, websockets::kUpgrade, &value);
  if (!ValidateHeaderHasSingleValue(result,
                                    websockets::kUpgrade,
                                    failure_message)) {
    return false;
  }

  if (!base::EqualsCaseInsensitiveASCII(value,
                                        websockets::kWebSocketLowercase)) {
    *failure_message =
        "'Upgrade' header value is not 'WebSocket': " + value;
    return false;
  }
  return true;
}

bool ValidateSecWebSocketAccept(const HttpResponseHeaders* headers,
                                const std::string& expected,
                                std::string* failure_message) {
  std::string actual;
  GetHeaderResult result =
      GetSingleHeaderValue(headers, websockets::kSecWebSocketAccept, &actual);
  if (!ValidateHeaderHasSingleValue(result,
                                    websockets::kSecWebSocketAccept,
                                    failure_message)) {
    return false;
  }

  if (expected != actual) {
    *failure_message = "Incorrect 'Sec-WebSocket-Accept' header value";
    return false;
  }
  return true;
}

bool ValidateConnection(const HttpResponseHeaders* headers,
                        std::string* failure_message) {
  // Connection header is permitted to contain other tokens.
  if (!headers->HasHeader(HttpRequestHeaders::kConnection)) {
    *failure_message = MissingHeaderMessage(HttpRequestHeaders::kConnection);
    return false;
  }
  if (!headers->HasHeaderValue(HttpRequestHeaders::kConnection,
                               websockets::kUpgrade)) {
    *failure_message = "'Connection' header value must contain 'Upgrade'";
    return false;
  }
  return true;
}

base::Value::Dict NetLogFailureParam(int net_error,
                                     const std::string& message) {
  base::Value::Dict dict;
  dict.Set("net_error", net_error);
  dict.Set("message", message);
  return dict;
}

}  // namespace

WebSocketBasicHandshakeStream::WebSocketBasicHandshakeStream(
    std::unique_ptr<StreamSocketHandle> connection,
    WebSocketStream::ConnectDelegate* connect_delegate,
    bool is_for_get_to_http_proxy,
    std::vector<std::string> requested_sub_protocols,
    std::vector<std::string> requested_extensions,
    WebSocketStreamRequestAPI* request,
    WebSocketEndpointLockManager* websocket_endpoint_lock_manager)
    : state_(std::move(connection), is_for_get_to_http_proxy),
      connect_delegate_(connect_delegate),
      requested_sub_protocols_(std::move(requested_sub_protocols)),
      requested_extensions_(std::move(requested_extensions)),
      stream_request_(request),
      websocket_endpoint_lock_manager_(websocket_endpoint_lock_manager) {
  DCHECK(connect_delegate);
  DCHECK(request);
}

WebSocketBasicHandshakeStream::~WebSocketBasicHandshakeStream() {
  // Some members are "stolen" by RenewStreamForAuth() and should not be touched
  // here. Particularly |connect_delegate_|, |stream_request_|, and
  // |websocket_endpoint_lock_manager_|.

  // TODO(ricea): What's the right thing to do here if we renewed the stream for
  // auth? Currently we record it as INCOMPLETE.
  RecordHandshakeResult(result_);
}

void WebSocketBasicHandshakeStream::RegisterRequest(
    const HttpRequestInfo* request_info) {
  DCHECK(request_info);
  DCHECK(request_info->traffic_annotation.is_valid());
  request_info_ = request_info;
}

int WebSocketBasicHandshakeStream::InitializeStream(
    bool can_send_early,
    RequestPriority priority,
    const NetLogWithSource& net_log,
    CompletionOnceCallback callback) {
  url_ = request_info_->url;
  net_log_ = net_log;
  // The WebSocket may receive a socket in the early data state from
  // HttpNetworkTransaction, which means it must call ConfirmHandshake() for
  // requests that need replay protection. However, the first request on any
  // WebSocket stream is a GET with an idempotent request
  // (https://tools.ietf.org/html/rfc6455#section-1.3), so there is no need to
  // call ConfirmHandshake().
  //
  // Data after the WebSockets handshake may not be replayable, but the
  // handshake is guaranteed to be confirmed once the HTTP response is received.
  DCHECK(can_send_early);
  state_.Initialize(request_info_, priority, net_log);
  // RequestInfo is no longer needed after this point.
  request_info_ = nullptr;
  return OK;
}

int WebSocketBasicHandshakeStream::SendRequest(
    const HttpRequestHeaders& headers,
    HttpResponseInfo* response,
    CompletionOnceCallback callback) {
  DCHECK(!headers.HasHeader(websockets::kSecWebSocketKey));
  DCHECK(!headers.HasHeader(websockets::kSecWebSocketProtocol));
  DCHECK(!headers.HasHeader(websockets::kSecWebSocketExtensions));
  DCHECK(headers.HasHeader(HttpRequestHeaders::kOrigin));
  DCHECK(headers.HasHeader(websockets::kUpgrade));
  DCHECK(headers.HasHeader(HttpRequestHeaders::kConnection));
  DCHECK(headers.HasHeader(websockets::kSecWebSocketVersion));
  DCHECK(parser());

  http_response_info_ = response;

  // Create a copy of the headers object, so that we can add the
  // Sec-WebSocket-Key header.
  HttpRequestHeaders enriched_headers = headers;
  std::string handshake_challenge;
  if (handshake_challenge_for_testing_.has_value()) {
    handshake_challenge = handshake_challenge_for_testing_.value();
    handshake_challenge_for_testing_.reset();
  } else {
    handshake_challenge = GenerateHandshakeChallenge();
  }
  enriched_headers.SetHeader(websockets::kSecWebSocketKey, handshake_challenge);

  AddVectorHeaders(requested_extensions_, requested_sub_protocols_,
                   &enriched_headers);

  handshake_challenge_response_ =
      ComputeSecWebSocketAccept(handshake_challenge);

  DCHECK(connect_delegate_);
  auto request =
      std::make_unique<WebSocketHandshakeRequestInfo>(url_, base::Time::Now());
  request->headers = enriched_headers;
  connect_delegate_->OnStartOpeningHandshake(std::move(request));

  return parser()->SendRequest(
      state_.GenerateRequestLine(), enriched_headers,
      NetworkTrafficAnnotationTag(state_.traffic_annotation()), response,
      std::move(callback));
}

int WebSocketBasicHandshakeStream::ReadResponseHeaders(
    CompletionOnceCallback callback) {
  // HttpStreamParser uses a weak pointer when reading from the
  // socket, so it won't be called back after being destroyed. The
  // HttpStreamParser is owned by HttpBasicState which is owned by this object,
  // so this use of base::Unretained() is safe.
  int rv = parser()->ReadResponseHeaders(base::BindOnce(
      &WebSocketBasicHandshakeStream::ReadResponseHeadersCallback,
      base::Unretained(this), std::move(callback)));
  if (rv == ERR_IO_PENDING)
    return rv;
  return ValidateResponse(rv);
}

int WebSocketBasicHandshakeStream::ReadResponseBody(
    IOBuffer* buf,
    int buf_len,
    CompletionOnceCallback callback) {
  return parser()->ReadResponseBody(buf, buf_len, std::move(callback));
}

void WebSocketBasicHandshakeStream::Close(bool not_reusable) {
  // This class ignores the value of `not_reusable` and never lets the socket be
  // re-used.
  state_.Close(/*not_reusable=*/true);
}

bool WebSocketBasicHandshakeStream::IsResponseBodyComplete() const {
  return parser()->IsResponseBodyComplete();
}

bool WebSocketBasicHandshakeStream::IsConnectionReused() const {
  return state_.IsConnectionReused();
}

void WebSocketBasicHandshakeStream::SetConnectionReused() {
  state_.SetConnectionReused();
}

bool WebSocketBasicHandshakeStream::CanReuseConnection() const {
  return state_.CanReuseConnection();
}

int64_t WebSocketBasicHandshakeStream::GetTotalReceivedBytes() const {
  return 0;
}

int64_t WebSocketBasicHandshakeStream::GetTotalSentBytes() const {
  return 0;
}

bool WebSocketBasicHandshakeStream::GetAlternativeService(
    AlternativeService* alternative_service) const {
  return false;
}

bool WebSocketBasicHandshakeStream::GetLoadTimingInfo(
    LoadTimingInfo* load_timing_info) const {
  return state_.GetLoadTimingInfo(load_timing_info);
}

void WebSocketBasicHandshakeStream::GetSSLInfo(SSLInfo* ssl_info) {
  state_.GetSSLInfo(ssl_info);
}

int WebSocketBasicHandshakeStream::GetRemoteEndpoint(IPEndPoint* endpoint) {
  return state_.GetRemoteEndpoint(endpoint);
}

void WebSocketBasicHandshakeStream::PopulateNetErrorDetails(
    NetErrorDetails* /*details*/) {
  return;
}

void WebSocketBasicHandshakeStream::Drain(HttpNetworkSession* session) {
  session->StartResponseDrainer(
      std::make_unique<HttpResponseBodyDrainer>(this));
  // |drainer| will delete itself.
}

void WebSocketBasicHandshakeStream::SetPriority(RequestPriority priority) {
  // TODO(ricea): See TODO comment in HttpBasicStream::SetPriority(). If it is
  // gone, then copy whatever has happened there over here.
}

std::unique_ptr<HttpStream>
WebSocketBasicHandshakeStream::RenewStreamForAuth() {
  DCHECK(IsResponseBodyComplete());
  DCHECK(!parser()->IsMoreDataBuffered());

  auto handshake_stream = std::make_unique<WebSocketBasicHandshakeStream>(
      state_.ReleaseConnection(), connect_delegate_,
      state_.is_for_get_to_http_proxy(), std::move(requested_sub_protocols_),
      std::move(requested_extensions_), stream_request_,
      websocket_endpoint_lock_manager_);

  stream_request_->OnBasicHandshakeStreamCreated(handshake_stream.get());

  return handshake_stream;
}

const std::set<std::string>& WebSocketBasicHandshakeStream::GetDnsAliases()
    const {
  return state_.GetDnsAliases();
}

std::string_view WebSocketBasicHandshakeStream::GetAcceptChViaAlps() const {
  return {};
}

std::unique_ptr<WebSocketStream> WebSocketBasicHandshakeStream::Upgrade() {
  WebSocketTransportClientSocketPool::UnlockEndpoint(
      state_.connection(), websocket_endpoint_lock_manager_);
  std::unique_ptr<WebSocketStream> basic_stream =
      std::make_unique<WebSocketBasicStream>(
          std::make_unique<WebSocketClientSocketHandleAdapter>(
              state_.ReleaseConnection()),
          state_.read_buf(), sub_protocol_, extensions_, net_log_);
  DCHECK(extension_params_.get());
  if (extension_params_->deflate_enabled) {
    return std::make_unique<WebSocketDeflateStream>(
        std::move(basic_stream), extension_params_->deflate_parameters,
        std::make_unique<WebSocketDeflatePredictorImpl>());
  }

  return basic_stream;
}

bool WebSocketBasicHandshakeStream::CanReadFromStream() const {
  auto* connection = state_.connection();
  if (!connection) {
    return false;
  }
  return connection->socket();
}

base::WeakPtr<WebSocketHandshakeStreamBase>
WebSocketBasicHandshakeStream::GetWeakPtr() {
  return weak_ptr_factory_.GetWeakPtr();
}

void WebSocketBasicHandshakeStream::SetWebSocketKeyForTesting(
    const std::string& key) {
  handshake_challenge_for_testing_ = key;
}

void WebSocketBasicHandshakeStream::ReadResponseHeadersCallback(
    CompletionOnceCallback callback,
    int result) {
  std::move(callback).Run(ValidateResponse(result));
}

int WebSocketBasicHandshakeStream::ValidateResponse(int rv) {
  DCHECK(http_response_info_);
  // Most net errors happen during connection, so they are not seen by this
  // method. The histogram for error codes is created in
  // Delegate::OnResponseStarted in websocket_stream.cc instead.
  if (rv >= 0) {
    const HttpResponseHeaders* headers = http_response_info_->headers.get();
    const int response_code = headers->response_code();
    base::UmaHistogramSparse("Net.WebSocket.ResponseCode", response_code);
    switch (response_code) {
      case HTTP_SWITCHING_PROTOCOLS:
        return ValidateUpgradeResponse(headers);

      // We need to pass these through for authentication to work.
      case HTTP_UNAUTHORIZED:
      case HTTP_PROXY_AUTHENTICATION_REQUIRED:
        return OK;

      // Other status codes are potentially risky (see the warnings in the
      // WHATWG WebSocket API spec) and so are dropped by default.
      default:
        // A WebSocket server cannot be using HTTP/0.9, so if we see version
        // 0.9, it means the response was garbage.
        // Reporting "Unexpected response code: 200" in this case is not
        // helpful, so use a different error message.
        if (headers->GetHttpVersion() == HttpVersion(0, 9)) {
          OnFailure("Error during WebSocket handshake: Invalid status line",
                    ERR_FAILED, std::nullopt);
        } else {
          OnFailure(base::StringPrintf("Error during WebSocket handshake: "
                                       "Unexpected response code: %d",
                                       headers->response_code()),
                    ERR_FAILED, headers->response_code());
        }
        result_ = HandshakeResult::INVALID_STATUS;
        return ERR_INVALID_RESPONSE;
    }
  } else {
    if (rv == ERR_EMPTY_RESPONSE) {
      OnFailure("Connection closed before receiving a handshake response", rv,
                std::nullopt);
      result_ = HandshakeResult::EMPTY_RESPONSE;
      return rv;
    }
    OnFailure(
        base::StrCat({"Error during WebSocket handshake: ", ErrorToString(rv)}),
        rv, std::nullopt);
    // Some error codes (for example ERR_CONNECTION_CLOSED) get changed to OK at
    // higher levels. To prevent an unvalidated connection getting erroneously
    // upgraded, don't pass through the status code unchanged if it is
    // HTTP_SWITCHING_PROTOCOLS.
    if (http_response_info_->headers &&
        http_response_info_->headers->response_code() ==
            HTTP_SWITCHING_PROTOCOLS) {
      http_response_info_->headers->ReplaceStatusLine(
          kConnectionErrorStatusLine);
      result_ = HandshakeResult::FAILED_SWITCHING_PROTOCOLS;
      return rv;
    }
    result_ = HandshakeResult::FAILED;
    return rv;
  }
}

int WebSocketBasicHandshakeStream::ValidateUpgradeResponse(
    const HttpResponseHeaders* headers) {
  extension_params_ = std::make_unique<WebSocketExtensionParams>();
  std::string failure_message;
  if (!ValidateUpgrade(headers, &failure_message)) {
    result_ = HandshakeResult::FAILED_UPGRADE;
  } else if (!ValidateSecWebSocketAccept(headers, handshake_challenge_response_,
                                         &failure_message)) {
    result_ = HandshakeResult::FAILED_ACCEPT;
  } else if (!ValidateConnection(headers, &failure_message)) {
    result_ = HandshakeResult::FAILED_CONNECTION;
  } else if (!ValidateSubProtocol(headers, requested_sub_protocols_,
                                  &sub_protocol_, &failure_message)) {
    result_ = HandshakeResult::FAILED_SUBPROTO;
  } else if (!ValidateExtensions(headers, &extensions_, &failure_message,
                                 extension_params_.get())) {
    result_ = HandshakeResult::FAILED_EXTENSIONS;
  } else {
    result_ = HandshakeResult::CONNECTED;
    return OK;
  }
  OnFailure("Error during WebSocket handshake: " + failure_message, ERR_FAILED,
            std::nullopt);
  return ERR_INVALID_RESPONSE;
}

void WebSocketBasicHandshakeStream::OnFailure(
    const std::string& message,
    int net_error,
    std::optional<int> response_code) {
  net_log_.AddEvent(net::NetLogEventType::WEBSOCKET_UPGRADE_FAILURE,
                    [&] { return NetLogFailureParam(net_error, message); });
  // Avoid connection reuse if auth did not happen.
  state_.connection()->socket()->Disconnect();
  stream_request_->OnFailure(message, net_error, response_code);
}

}  // namespace net
```
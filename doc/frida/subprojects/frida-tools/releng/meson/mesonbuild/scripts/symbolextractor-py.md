Response:
Let's break down the thought process for analyzing this Python script.

**1. Understanding the Goal:**

The initial comments and the script's name ("symbolextractor.py") immediately suggest its primary function: extracting symbols from shared libraries. The key motivation mentioned is to optimize the build process by skipping unnecessary relinking if the library's ABI (Application Binary Interface) hasn't changed. This gives us the high-level purpose.

**2. Deconstructing the Code - Top-Down and Bottom-Up:**

* **Entry Point (`if __name__ == '__main__':`)**:  Start here. This tells us how the script is invoked from the command line. It uses `argparse` to handle command-line arguments: the shared library file, the import library (Windows specific), and the output file for the symbols.

* **Core Function (`gen_symbols`)**: This is the central logic. It dispatches to platform-specific functions based on `mesonlib.is_linux()`, `mesonlib.is_osx()`, etc. This immediately highlights the platform-dependent nature of symbol extraction. The `cross_host` parameter also hints at cross-compilation handling.

* **Platform-Specific Functions (`gnu_syms`, `osx_syms`, `windows_syms`, etc.)**: Dive into these. Notice the consistent pattern:
    * Use external tools (`readelf`, `nm`, `otool`, `dlltool`, `dumpbin`) to get symbol information.
    * Parse the output of these tools to extract relevant data (symbol names, types, sizes, SONAME).
    * Handle potential errors (tool not found, permission issues) and print warnings.
    * Use `dummy_syms` as a fallback to force relinking when symbol extraction fails.

* **Utility Functions (`write_if_changed`, `dummy_syms`, `get_tool`, `call_tool`, `call_tool_nowarn`, `print_tool_warning`)**: These handle common tasks:
    * `write_if_changed`:  Crucial for the optimization goal. Avoids unnecessary writes if the symbols haven't changed.
    * `dummy_syms`:  Forces relinking.
    * `get_tool`:  Handles finding the correct path to external tools, respecting environment variables.
    * `call_tool`, `call_tool_nowarn`:  Wrappers around `Popen_safe` for executing external commands and handling errors.
    * `print_tool_warning`:  Provides informative warnings to the user.

**3. Connecting to Reverse Engineering and Low-Level Concepts:**

* **Symbols and Reverse Engineering:**  Think about *why* symbols are important in reverse engineering. They provide names for functions and variables, making code analysis significantly easier. The script's purpose is to extract this very information. This connection becomes clear when analyzing how tools like `nm` are used.

* **Binary Format and System Calls:** The script directly interacts with binary files (shared libraries). Tools like `readelf` inspect the ELF (Executable and Linkable Format) structure on Linux. On macOS, `otool` does something similar for Mach-O. The very act of extracting symbols is tied to understanding these binary formats. The script's use of external commands implies underlying system calls to execute these tools.

* **Linux/Android Kernel and Framework:**  Consider how shared libraries are fundamental in these environments. Shared libraries are the building blocks of applications and the operating system itself. Frameworks like Android's rely heavily on them. The concept of `SONAME` (Shared Object Name) is critical in dynamic linking, a cornerstone of these systems.

**4. Inferring Logic and Examples:**

* **Logic:** The core logic is straightforward: execute platform-specific tools, parse their output, and compare the new symbol list with the old one. The `write_if_changed` function is the key to the optimization.

* **Input/Output Examples:**  Think about the *inputs* the script takes (paths to libraries) and the *output* it produces (a text file containing the extracted symbols). Imagine the content of the output file for a simple shared library.

* **User Errors:**  Consider common mistakes a developer might make that would lead to this script being executed. For example, modifying the source code of a shared library and then triggering a build process.

**5. Debugging Perspective:**

Imagine you are debugging a build issue. How does this script fit into the process? If relinking isn't happening when it should, you might examine the output file generated by this script to see if the symbols have been correctly updated. The warnings generated by the script provide valuable clues.

**Self-Correction/Refinement:**

Initially, one might focus too much on the details of each platform-specific function. It's important to step back and see the common patterns and the overall goal. Recognizing the reliance on external tools is key. Also, ensuring the connection to the *why* – the optimization goal – is important for a complete understanding. Thinking about the debugging context adds another layer of understanding.
这个Python脚本 `symbolextractor.py` 的主要功能是从共享库中提取符号信息，并将其保存到文件中。其目的是为了在构建过程中优化链接步骤，只有当共享库的符号（即其公开的接口）发生变化时才触发重新链接。

下面是对其功能的详细列举，并结合逆向、底层、内核、框架知识以及可能的错误进行说明：

**主要功能:**

1. **提取共享库符号:**  脚本的核心功能是从指定的共享库文件中提取导出的符号。这些符号通常包括函数名、变量名等，构成了共享库的公共接口。

2. **平台特定处理:**  脚本针对不同的操作系统（Linux, macOS, Windows, BSD等）使用不同的工具和方法来提取符号。这是因为不同平台使用的二进制文件格式（如ELF, Mach-O, PE）和符号表结构不同，相应的工具也不同（如`readelf`, `nm`, `otool`, `dumpbin`, `dlltool`）。

3. **比较符号变化:**  脚本会将提取到的符号信息写入一个输出文件。在后续构建中，如果再次运行此脚本，它会比较新提取的符号与文件中已有的符号。如果两者没有变化，脚本就不会修改输出文件。

4. **跳过不必要的链接:**  构建系统（如Meson）利用这个输出来判断共享库的ABI（Application Binary Interface）是否发生了变化。如果符号没有变化，则认为ABI没有变化，可以跳过重新链接依赖于该共享库的其他组件，从而加快构建速度。

**与逆向方法的关系及举例:**

* **理解共享库接口:** 在逆向工程中，了解目标共享库导出了哪些函数和变量是至关重要的第一步。这个脚本的功能与逆向工程师使用工具（如IDA Pro, Ghidra, `nm`, `objdump`等）来分析共享库的导出符号信息是类似的。
    * **举例:**  假设你要逆向一个名为 `libexample.so` 的共享库，了解其提供的功能。你可以使用 `nm -D libexample.so` 命令来查看其导出的动态符号。 `symbolextractor.py` 实际上就是在自动化执行类似的操作，并将结果保存下来。

* **ABI 分析:** 逆向工程师有时需要分析不同版本的共享库之间的ABI兼容性。这个脚本通过比较符号信息来判断ABI是否变化，这与逆向分析中手动比较不同版本库的导出符号列表有异曲同工之妙。
    * **举例:** 如果你发现一个程序在新版本的 `libexample.so` 下崩溃了，你可能会想知道新版本是否修改了某个关键函数的签名或删除了某个函数。`symbolextractor.py` 的输出可以帮助快速判断符号层面是否存在差异。

**涉及到的二进制底层、Linux、Android内核及框架的知识及举例:**

* **二进制文件格式 (ELF, Mach-O, PE):**  脚本需要根据不同的操作系统调用相应的工具来解析不同格式的二进制文件，提取符号信息。例如，在Linux上使用 `readelf` 解析ELF文件头，使用 `nm` 解析符号表。
    * **举例:**  `gnu_syms` 函数中调用 `readelf -d libfilename` 来获取共享对象的 SONAME (Shared Object Name)，这是ELF文件的一个重要字段，用于动态链接器在运行时查找共享库。

* **动态链接:** 脚本的目的是优化链接过程，这直接涉及到动态链接的概念。共享库在程序运行时被加载和链接，符号信息是链接器解析和重定位符号的关键。
    * **举例:**  脚本提取的符号信息用于判断共享库的接口是否稳定。如果接口发生变化，依赖于该库的其他模块需要重新链接，以确保正确的符号引用。

* **Linux 工具 (`nm`, `readelf`):** 脚本在 Linux 环境下大量使用了 `nm` 和 `readelf` 这两个命令行工具。`nm` 用于列出目标文件中的符号，`readelf` 用于显示ELF格式文件的信息。
    * **举例:** `gnu_syms` 函数使用 `nm --dynamic --extern-only --defined-only --format=posix libfilename` 命令来获取导出的动态符号。

* **macOS 工具 (`otool`, `nm`):** 在 macOS 环境下，脚本使用 `otool` 来获取动态库的 ID 信息 (`LC_ID_DYLIB`)，并使用 `nm` 来获取符号。
    * **举例:** `osx_syms` 函数调用 `otool -l libfilename` 来查找 `LC_ID_DYLIB` 加载命令，其中包含了动态库的安装名。

* **Windows 工具 (`dumpbin`, `dlltool`, `lib.exe`, `llvm-lib.exe`):** 在 Windows 环境下，脚本使用 `dumpbin` 查看导出表，使用 `dlltool` 处理导入库，使用 `lib.exe` 或 `llvm-lib.exe` 列出导入库中的 DLL 名称。
    * **举例:** `windows_syms` 函数使用 `dumpbin -exports impfilename` 来获取导入库导出的符号。

* **Android 框架 (间接相关):** 虽然脚本本身不直接操作 Android 特有的组件，但其优化的链接过程对于构建 Android 系统和应用中大量的共享库是有益的。Android 底层也基于 Linux 内核，使用了类似的动态链接机制。

**逻辑推理、假设输入与输出:**

**假设输入:**

* `libfilename`: `/path/to/libmylib.so` (Linux共享库)
* `impfilename`:  在Linux下通常为空或不使用。
* `outfilename`: `/path/to/meson-private/libmylib.so.symbols`
* 首次运行，`/path/to/meson-private/libmylib.so.symbols` 文件不存在。

**脚本逻辑推理:**

1. `gen_symbols` 函数会根据 `mesonlib.is_linux()` 判断是 Linux 环境。
2. 调用 `gnu_syms` 函数。
3. `gnu_syms` 调用 `readelf -d /path/to/libmylib.so` 获取 SONAME。
4. `gnu_syms` 调用 `nm --dynamic --extern-only --defined-only --format=posix /path/to/libmylib.so` 获取导出符号。
5. 将 SONAME 和导出的符号列表格式化成文本。
6. 由于 `/path/to/meson-private/libmylib.so.symbols` 不存在，`write_if_changed` 会将格式化后的文本写入该文件。

**预期输出 (`/path/to/meson-private/libmylib.so.symbols` 的内容):**

```
 0x000000000000000e (SONAME)             Library soname: [libmylib.so.1]
my_function T 0000000000001234
my_variable D 0000000000004567 8
```

**假设输入 (第二次运行，假设符号没有变化):**

* `libfilename`: `/path/to/libmylib.so`
* `impfilename`:  (同上)
* `outfilename`: `/path/to/meson-private/libmylib.so.symbols` (已存在，内容如上)

**脚本逻辑推理:**

1. 同上，最终调用 `gnu_syms`。
2. `gnu_syms` 再次提取符号，得到与之前相同的内容。
3. `write_if_changed` 读取 `/path/to/meson-private/libmylib.so.symbols` 的内容。
4. 比较新提取的符号与文件内容，两者相同。
5. `write_if_changed` 不会修改文件。

**涉及用户或编程常见的使用错误及举例:**

1. **缺少必要的工具:** 如果用户的系统上没有安装 `nm`, `readelf` 等工具，脚本会报错或发出警告，并回退到总是重新链接。
    * **举例:** 用户在一个精简的 Linux 环境中构建，但没有安装 `binutils` 包，导致 `nm` 命令找不到，脚本会打印类似 `['nm'] not found. Relinking will always happen on source changes.` 的警告。

2. **权限问题:** 如果脚本没有执行 `nm` 或 `readelf` 等工具的权限，也会导致提取符号失败。
    * **举例:** 用户在一个受限的环境中运行构建，`nm` 命令没有执行权限，脚本会打印类似 `['nm'] not usable. Relinking will always happen on source changes.` 的警告。

3. **交叉编译环境配置错误:** 在交叉编译时，如果 `--cross-host` 参数设置不正确，或者交叉编译工具链没有正确配置，脚本可能会使用主机环境的工具来提取目标平台的符号，导致错误的结果。
    * **举例:** 用户在为 ARM 架构编译时，但 Meson 的交叉编译配置文件中 `binutils` 的路径指向了主机 x86_64 架构的 `nm`，这会导致提取的符号信息与目标平台不符。

**用户操作如何一步步到达这里作为调试线索:**

1. **修改了共享库的源代码:** 用户修改了 `libmylib.c` 或 `libmylib.cpp` 等源文件，这些文件被编译链接成共享库 `libmylib.so`。

2. **运行构建系统 (如 Meson):** 用户执行 `meson compile` 或 `ninja` 命令来触发构建过程。

3. **Meson 判断需要更新共享库:** Meson 会检测到 `libmylib.so` 的源文件发生了变化，需要重新编译和链接。

4. **Meson 执行符号提取脚本:** 在链接 `libmylib.so` 之后，Meson 会调用 `symbolextractor.py` 脚本，目的是为了记录当前 `libmylib.so` 的符号信息，以便后续依赖它的库可以判断是否需要重新链接。  Meson 会将共享库文件路径、可能的导入库路径（Windows 下使用）、以及输出符号文件的路径作为参数传递给 `symbolextractor.py`。

5. **脚本执行并保存符号信息:** `symbolextractor.py` 按照其逻辑执行，提取符号并将其保存到输出文件中。

**调试线索:**

如果构建过程中出现意外的重新链接，或者链接错误，可以检查以下内容：

* **符号文件内容:** 查看 `meson-private` 目录下对应的 `.symbols` 文件，确认其内容是否符合预期，是否包含了期望的符号。
* **构建日志:** 查看构建系统的日志，确认 `symbolextractor.py` 是否被正确调用，以及是否有警告或错误信息。
* **工具版本:** 确认 `nm`, `readelf` 等工具的版本是否与预期一致，不同版本的工具输出格式可能有所不同。
* **交叉编译配置:** 如果是交叉编译，检查交叉编译配置文件中工具链的路径是否正确。

总而言之，`symbolextractor.py` 是 Frida 构建系统中的一个关键组件，它通过自动化提取和比较共享库的符号信息，实现了构建过程的优化，避免了不必要的重新链接，提高了构建效率。理解其功能和涉及的技术细节有助于进行构建问题的调试和分析。

Prompt: 
```
这是目录为frida/subprojects/frida-tools/releng/meson/mesonbuild/scripts/symbolextractor.py的fridaDynamic instrumentation tool的源代码文件， 请列举一下它的功能, 
如果它与逆向的方法有关系，请做出对应的举例说明，
如果涉及到二进制底层，linux, android内核及框架的知识，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索。

"""
# SPDX-License-Identifier: Apache-2.0
# Copyright 2013-2016 The Meson development team

# This script extracts the symbols of a given shared library
# into a file. If the symbols have not changed, the file is not
# touched. This information is used to skip link steps if the
# ABI has not changed.

# This file is basically a reimplementation of
# http://cgit.freedesktop.org/libreoffice/core/commit/?id=3213cd54b76bc80a6f0516aac75a48ff3b2ad67c
from __future__ import annotations

import typing as T
import os, sys
from .. import mesonlib
from .. import mlog
from ..mesonlib import Popen_safe
import argparse

parser = argparse.ArgumentParser()

parser.add_argument('--cross-host', default=None, dest='cross_host',
                    help='cross compilation host platform')
parser.add_argument('args', nargs='+')

TOOL_WARNING_FILE = None
RELINKING_WARNING = 'Relinking will always happen on source changes.'

def dummy_syms(outfilename: str) -> None:
    """Just touch it so relinking happens always."""
    with open(outfilename, 'w', encoding='utf-8'):
        pass

def write_if_changed(text: str, outfilename: str) -> None:
    try:
        with open(outfilename, encoding='utf-8') as f:
            oldtext = f.read()
        if text == oldtext:
            return
    except FileNotFoundError:
        pass
    with open(outfilename, 'w', encoding='utf-8') as f:
        f.write(text)

def print_tool_warning(tools: T.List[str], msg: str, stderr: T.Optional[str] = None) -> None:
    if os.path.exists(TOOL_WARNING_FILE):
        return
    m = f'{tools!r} {msg}. {RELINKING_WARNING}'
    if stderr:
        m += '\n' + stderr
    mlog.warning(m)
    # Write it out so we don't warn again
    with open(TOOL_WARNING_FILE, 'w', encoding='utf-8'):
        pass

def get_tool(name: str) -> T.List[str]:
    evar = name.upper()
    if evar in os.environ:
        import shlex
        return shlex.split(os.environ[evar])
    return [name]

def call_tool(name: str, args: T.List[str], **kwargs: T.Any) -> str:
    tool = get_tool(name)
    try:
        p, output, e = Popen_safe(tool + args, **kwargs)
    except FileNotFoundError:
        print_tool_warning(tool, 'not found')
        return None
    except PermissionError:
        print_tool_warning(tool, 'not usable')
        return None
    if p.returncode != 0:
        print_tool_warning(tool, 'does not work', e)
        return None
    return output

def call_tool_nowarn(tool: T.List[str], **kwargs: T.Any) -> T.Tuple[str, str]:
    try:
        p, output, e = Popen_safe(tool, **kwargs)
    except FileNotFoundError:
        return None, '{!r} not found\n'.format(tool[0])
    except PermissionError:
        return None, '{!r} not usable\n'.format(tool[0])
    if p.returncode != 0:
        return None, e
    return output, None

def gnu_syms(libfilename: str, outfilename: str) -> None:
    # Get the name of the library
    output = call_tool('readelf', ['-d', libfilename])
    if not output:
        dummy_syms(outfilename)
        return
    result = [x for x in output.split('\n') if 'SONAME' in x]
    assert len(result) <= 1
    # Get a list of all symbols exported
    output = call_tool('nm', ['--dynamic', '--extern-only', '--defined-only',
                              '--format=posix', libfilename])
    if not output:
        dummy_syms(outfilename)
        return
    for line in output.split('\n'):
        if not line:
            continue
        line_split = line.split()
        entry = line_split[0:2]
        # Store the size of symbols pointing to data objects so we relink
        # when those change, which is needed because of copy relocations
        # https://github.com/mesonbuild/meson/pull/7132#issuecomment-628353702
        if line_split[1].upper() in {'B', 'G', 'D'} and len(line_split) >= 4:
            entry += [line_split[3]]
        result += [' '.join(entry)]
    write_if_changed('\n'.join(result) + '\n', outfilename)

def solaris_syms(libfilename: str, outfilename: str) -> None:
    # gnu_syms() works with GNU nm & readelf, not Solaris nm & elfdump
    origpath = os.environ['PATH']
    try:
        os.environ['PATH'] = '/usr/gnu/bin:' + origpath
        gnu_syms(libfilename, outfilename)
    finally:
        os.environ['PATH'] = origpath

def osx_syms(libfilename: str, outfilename: str) -> None:
    # Get the name of the library
    output = call_tool('otool', ['-l', libfilename])
    if not output:
        dummy_syms(outfilename)
        return
    arr = output.split('\n')
    for (i, val) in enumerate(arr):
        if 'LC_ID_DYLIB' in val:
            match = i
            break
    result = [arr[match + 2], arr[match + 5]] # Libreoffice stores all 5 lines but the others seem irrelevant.
    # Get a list of all symbols exported
    output = call_tool('nm', ['--extern-only', '--defined-only',
                              '--format=posix', libfilename])
    if not output:
        dummy_syms(outfilename)
        return
    result += [' '.join(x.split()[0:2]) for x in output.split('\n')]
    write_if_changed('\n'.join(result) + '\n', outfilename)

def openbsd_syms(libfilename: str, outfilename: str) -> None:
    # Get the name of the library
    output = call_tool('readelf', ['-d', libfilename])
    if not output:
        dummy_syms(outfilename)
        return
    result = [x for x in output.split('\n') if 'SONAME' in x]
    assert len(result) <= 1
    # Get a list of all symbols exported
    output = call_tool('nm', ['-D', '-P', '-g', libfilename])
    if not output:
        dummy_syms(outfilename)
        return
    # U = undefined (cope with the lack of --defined-only option)
    result += [' '.join(x.split()[0:2]) for x in output.split('\n') if x and not x.endswith('U ')]
    write_if_changed('\n'.join(result) + '\n', outfilename)

def freebsd_syms(libfilename: str, outfilename: str) -> None:
    # Get the name of the library
    output = call_tool('readelf', ['-d', libfilename])
    if not output:
        dummy_syms(outfilename)
        return
    result = [x for x in output.split('\n') if 'SONAME' in x]
    assert len(result) <= 1
    # Get a list of all symbols exported
    output = call_tool('nm', ['--dynamic', '--extern-only', '--defined-only',
                              '--format=posix', libfilename])
    if not output:
        dummy_syms(outfilename)
        return

    result += [' '.join(x.split()[0:2]) for x in output.split('\n')]
    write_if_changed('\n'.join(result) + '\n', outfilename)

def cygwin_syms(impfilename: str, outfilename: str) -> None:
    # Get the name of the library
    output = call_tool('dlltool', ['-I', impfilename])
    if not output:
        dummy_syms(outfilename)
        return
    result = [output]
    # Get the list of all symbols exported
    output = call_tool('nm', ['--extern-only', '--defined-only',
                              '--format=posix', impfilename])
    if not output:
        dummy_syms(outfilename)
        return
    for line in output.split('\n'):
        if ' T ' not in line:
            continue
        result.append(line.split(maxsplit=1)[0])
    write_if_changed('\n'.join(result) + '\n', outfilename)

def _get_implib_dllname(impfilename: str) -> T.Tuple[T.List[str], str]:
    all_stderr = ''
    # First try lib.exe, which is provided by MSVC. Then llvm-lib.exe, by LLVM
    # for clang-cl.
    #
    # We cannot call get_tool on `lib` because it will look at the `LIB` env
    # var which is the list of library paths MSVC will search for import
    # libraries while linking.
    for lib in (['lib'], get_tool('llvm-lib')):
        output, e = call_tool_nowarn(lib + ['-list', impfilename])
        if output:
            # The output is a list of DLLs that each symbol exported by the import
            # library is available in. We only build import libraries that point to
            # a single DLL, so we can pick any of these. Pick the last one for
            # simplicity. Also skip the last line, which is empty.
            return output.split('\n')[-2:-1], None
        all_stderr += e
    # Next, try dlltool.exe which is provided by MinGW
    output, e = call_tool_nowarn(get_tool('dlltool') + ['-I', impfilename])
    if output:
        return [output], None
    all_stderr += e
    return ([], all_stderr)

def _get_implib_exports(impfilename: str) -> T.Tuple[T.List[str], str]:
    all_stderr = ''
    # Force dumpbin.exe to use en-US so we can parse its output
    env = os.environ.copy()
    env['VSLANG'] = '1033'
    output, e = call_tool_nowarn(get_tool('dumpbin') + ['-exports', impfilename], env=env)
    if output:
        lines = output.split('\n')
        start = lines.index('File Type: LIBRARY')
        end = lines.index('  Summary')
        return lines[start:end], None
    all_stderr += e
    # Next, try llvm-nm.exe provided by LLVM, then nm.exe provided by MinGW
    for nm in ('llvm-nm', 'nm'):
        output, e = call_tool_nowarn(get_tool(nm) + ['--extern-only', '--defined-only',
                                                     '--format=posix', impfilename])
        if output:
            result = []
            for line in output.split('\n'):
                if ' T ' not in line or line.startswith('.text'):
                    continue
                result.append(line.split(maxsplit=1)[0])
            return result, None
        all_stderr += e
    return ([], all_stderr)

def windows_syms(impfilename: str, outfilename: str) -> None:
    # Get the name of the library
    result, e = _get_implib_dllname(impfilename)
    if not result:
        print_tool_warning(['lib', 'llvm-lib', 'dlltool'], 'do not work or were not found', e)
        dummy_syms(outfilename)
        return
    # Get a list of all symbols exported
    symbols, e = _get_implib_exports(impfilename)
    if not symbols:
        print_tool_warning(['dumpbin', 'llvm-nm', 'nm'], 'do not work or were not found', e)
        dummy_syms(outfilename)
        return
    result += symbols
    write_if_changed('\n'.join(result) + '\n', outfilename)

def gen_symbols(libfilename: str, impfilename: str, outfilename: str, cross_host: str) -> None:
    if cross_host is not None:
        # In case of cross builds just always relink. In theory we could
        # determine the correct toolset, but we would need to use the correct
        # `nm`, `readelf`, etc, from the cross info which requires refactoring.
        dummy_syms(outfilename)
    elif mesonlib.is_linux() or mesonlib.is_hurd():
        gnu_syms(libfilename, outfilename)
    elif mesonlib.is_osx():
        osx_syms(libfilename, outfilename)
    elif mesonlib.is_openbsd():
        openbsd_syms(libfilename, outfilename)
    elif mesonlib.is_freebsd():
        freebsd_syms(libfilename, outfilename)
    elif mesonlib.is_netbsd():
        freebsd_syms(libfilename, outfilename)
    elif mesonlib.is_windows():
        if os.path.isfile(impfilename):
            windows_syms(impfilename, outfilename)
        else:
            # No import library. Not sure how the DLL is being used, so just
            # rebuild everything that links to it every time.
            dummy_syms(outfilename)
    elif mesonlib.is_cygwin():
        if os.path.isfile(impfilename):
            cygwin_syms(impfilename, outfilename)
        else:
            # No import library. Not sure how the DLL is being used, so just
            # rebuild everything that links to it every time.
            dummy_syms(outfilename)
    elif mesonlib.is_sunos():
        solaris_syms(libfilename, outfilename)
    else:
        if not os.path.exists(TOOL_WARNING_FILE):
            mlog.warning('Symbol extracting has not been implemented for this '
                         'platform. ' + RELINKING_WARNING)
            # Write it out so we don't warn again
            with open(TOOL_WARNING_FILE, 'w', encoding='utf-8'):
                pass
        dummy_syms(outfilename)

def run(args: T.List[str]) -> int:
    global TOOL_WARNING_FILE  # pylint: disable=global-statement
    options = parser.parse_args(args)
    if len(options.args) != 4:
        print('symbolextractor.py <shared library file> <import library> <output file>')
        sys.exit(1)
    privdir = os.path.join(options.args[0], 'meson-private')
    TOOL_WARNING_FILE = os.path.join(privdir, 'symbolextractor_tool_warning_printed')
    libfile = options.args[1]
    impfile = options.args[2] # Only used on Windows
    outfile = options.args[3]
    gen_symbols(libfile, impfile, outfile, options.cross_host)
    return 0

if __name__ == '__main__':
    sys.exit(run(sys.argv[1:]))

"""

```
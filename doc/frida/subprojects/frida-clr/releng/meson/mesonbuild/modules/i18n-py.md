Response:
Let's break down the thought process for analyzing this Python code.

1. **Understand the Goal:** The request asks for an analysis of the `i18n.py` file within the Frida project. The focus is on its functionality, relevance to reverse engineering, interaction with low-level systems, logical reasoning, potential user errors, and how a user might trigger this code.

2. **Initial Skim for Structure and Key Components:**  A quick scan reveals the file imports standard Python libraries (`os`, `shlex`, `typing`) and then imports from the `mesonbuild` project itself. This immediately suggests the file is part of Meson's build system, specifically dealing with internationalization (i18n). The class `I18nModule` and its methods (`merge_file`, `gettext`, `itstool_join`) are the core functionalities.

3. **Analyze Each Function:**

   * **`merge_file`:**
      * **Purpose:**  The name suggests merging multiple translation files into a single output. The docstring and type hints confirm this. It uses `msgfmt` from the GNU gettext tools.
      * **Reverse Engineering Relevance:**  While not directly reverse engineering *code*, it's related to localizing reverse-engineered tools or presenting output in different languages. Imagine a reverse engineering tool showing error messages in the user's locale.
      * **Low-Level/OS:**  It interacts with the operating system by executing `msgfmt`. The specific version check of `msgfmt` might relate to differences in binary output formats.
      * **Logic/Assumptions:**  It assumes the presence of `msgfmt`. It uses specific command-line arguments for `msgfmt` based on the `type` (xml or desktop).
      * **User Errors:** Missing `install_dir` when `install` is true is a clear user error. Providing incorrect input file paths would also be an issue.
      * **Triggering:** The user would use the `i18n.merge_file` function in their `meson.build` file, configuring the inputs, output, and other parameters.

   * **`gettext`:**
      * **Purpose:**  This function appears to handle the core gettext workflow: extracting translatable strings, managing `.po` files, and compiling them into `.mo` files.
      * **Reverse Engineering Relevance:**  Crucial for making reverse engineering tools multilingual. Tools often have user interfaces or output messages that need translation. Frida itself might use this for its own UI or command-line output.
      * **Low-Level/OS:** Heavily relies on gettext tools (`msgfmt`, `msginit`, `msgmerge`, `xgettext`). These tools interact directly with file systems and potentially system locales. The installation of `.mo` files places them in standard locale directories.
      * **Logic/Assumptions:** Assumes the presence of gettext tools. The "presets" for `glib` show specific knowledge of how the GLib library handles internationalization.
      * **User Errors:**  Not specifying a package name, incorrect language codes, or problems with the structure of source files leading to extraction errors are potential issues.
      * **Triggering:** The user would call `i18n.gettext` in `meson.build`, specifying the package name and potentially other options like languages and presets.

   * **`itstool_join`:**
      * **Purpose:**  Deals with merging translation files specifically for XML using `itstool`.
      * **Reverse Engineering Relevance:** Could be used for translating documentation or UI elements embedded in XML files within a reverse-engineered application.
      * **Low-Level/OS:** Relies on the `itstool` external program. It manipulates file paths.
      * **Logic/Assumptions:** Assumes `itstool` is installed. It correctly handles dependencies on the `.mo` files generated by `gettext`.
      * **User Errors:**  Forgetting to provide the `mo_targets`, incorrect paths to ITS files, or issues with the XML structure are possible errors.
      * **Triggering:** The user would invoke `i18n.itstool_join` in their `meson.build` file, providing input XML files, the output file, and the list of compiled `.mo` files.

4. **Identify Common Themes and Connections:**

   * **External Tool Dependency:** All three functions heavily rely on external command-line tools from the gettext suite or `itstool`.
   * **File Manipulation:** They create and manipulate files related to translation (`.po`, `.mo`).
   * **Build System Integration:** They are part of Meson and use Meson's constructs like `CustomTarget` and `RunTarget` to define build actions.
   * **Configuration via `meson.build`:** Users interact with these functions by declaring them in their `meson.build` file.

5. **Consider the "Why Frida?" Context:**  While the code itself is generic Meson i18n functionality, within Frida, it would be used to translate Frida's own tools, documentation, or any user-facing messages. This makes Frida more accessible to a wider range of users.

6. **Address Specific Request Points:**  Go back through the request and ensure each point is addressed with specific examples and explanations drawn from the code analysis.

7. **Refine and Organize:** Structure the answer logically, using headings and bullet points for clarity. Provide concrete examples for user errors and how they might arise.

8. **Review:** Read through the answer to ensure accuracy, completeness, and clarity. Check for any logical gaps or areas where further explanation might be helpful. For instance, explicitly connecting the version check of `msgfmt` to potential binary incompatibility is important.

This structured approach helps break down the code into manageable parts and ensures that all aspects of the request are addressed comprehensively. It involves understanding the code's purpose, its dependencies, its interactions with the system, and how it fits into the larger context of the Frida project and the Meson build system.
这是 `frida/subprojects/frida-clr/releng/meson/mesonbuild/modules/i18n.py` 文件的源代码，它是 Frida 项目中负责国际化 (i18n) 功能的 Meson 模块。这个模块提供了一组函数，用于在构建过程中处理软件的本地化和翻译。

以下是该文件的功能列表，并根据要求进行了详细说明：

**主要功能:**

1. **`merge_file` 函数:**
   - **功能:**  将多个翻译文件（例如 `.po` 文件）合并成一个二进制消息目录文件（通常是 `.mo` 文件）。它使用 `msgfmt` 工具完成这个任务。
   - **与逆向的关系:**
     - 在逆向工程中，如果需要本地化逆向工具自身的界面或输出信息，可以使用此功能。例如，你可能开发了一个 Frida 脚本或工具，并希望将其界面翻译成多种语言。
     - **举例:** 假设你编写了一个 Frida 脚本，用于分析 Android 应用的特定行为。你希望这个脚本的输出信息（例如，检测到的敏感 API 调用）能够以英文和中文显示。你可以使用 `merge_file` 将英文和中文的 `.po` 文件合并成对应的 `.mo` 文件，然后在你的 Frida 脚本中根据用户的语言设置加载相应的 `.mo` 文件。
   - **涉及底层/内核/框架知识:**
     - 该函数依赖于 `msgfmt` 工具，这是一个 GNU gettext 工具集的一部分。`msgfmt` 的工作原理是将文本格式的翻译文件编译成二进制格式，以便程序可以快速加载和使用。这涉及到文件 I/O 和二进制数据的处理。
     - 在 Android 上，本地化框架（如 Android Resource Framework）使用类似的机制来加载不同语言的资源。`merge_file` 生成的 `.mo` 文件可以被视为一种跨平台的本地化资源格式。
   - **逻辑推理:**
     - **假设输入:**  一个包含多个 `.po` 文件的列表 (`input`)，以及一个输出 `.mo` 文件的路径 (`output`)。
     - **输出:**  生成一个 Meson `CustomTarget`，该目标在构建时会执行 `msgfmt` 命令，将输入的 `.po` 文件合并成指定的 `.mo` 文件。
   - **用户使用错误:**
     - **错误示例:** 用户在调用 `merge_file` 时设置了 `install=True`，但忘记设置 `install_dir` 参数。
     - **说明:**  当 `install` 设置为 `True` 时，Meson 会尝试将生成的文件安装到指定的位置。如果没有提供 `install_dir`，Meson 将不知道安装到哪里，从而导致构建错误。
   - **调试线索 (用户操作):**
     1. 用户编辑 `meson.build` 文件。
     2. 用户调用 `i18n.merge_file` 函数。
     3. 用户在 `merge_file` 中设置 `install=True`。
     4. 用户忘记或错误地省略了 `install_dir` 参数。
     5. Meson 在解析 `meson.build` 时会抛出 `InvalidArguments` 异常。

2. **`gettext` 函数:**
   - **功能:**  用于处理更完整的 gettext 工作流程。它可以生成 POT 文件 (Portable Object Template)，更新 PO 文件，并将 PO 文件编译成 MO 文件。
   - **与逆向的关系:**
     - 对于需要本地化的逆向工具（如 Frida 本身或基于 Frida 构建的工具），`gettext` 是核心功能。它可以帮助开发者提取需要翻译的字符串，管理翻译文件，并将其集成到构建过程中。
     - **举例:** Frida 框架的开发者可能使用 `gettext` 来管理 Frida CLI 工具的翻译。他们会使用 `xgettext` 或类似的工具提取源代码中的可翻译字符串，然后将这些字符串交给翻译人员生成不同语言的 `.po` 文件。最后，使用 `gettext` 函数将这些 `.po` 文件编译成 `.mo` 文件，并在 Frida 启动时根据用户的语言设置加载相应的翻译。
   - **涉及底层/内核/框架知识:**
     - `gettext` 涉及到与操作系统本地化设置的交互。程序在运行时会根据用户的语言环境加载相应的 `.mo` 文件。
     - 在 Linux 和 Android 等系统中，都存在标准的本地化目录结构（例如 `/usr/share/locale` 或 `/system/usr/share/locale`），用于存放 `.mo` 文件。`gettext` 函数的 `install_dir` 参数就涉及到将生成的 `.mo` 文件安装到这些标准位置。
   - **逻辑推理:**
     - **假设输入:**  一个包名 (`packagename`)。
     - **输出:**
       - 生成一个 POT 文件。
       - 为指定的语言生成或更新 PO 文件。
       - 将 PO 文件编译成 MO 文件 (`CustomTarget`)。
       - 创建用于更新 PO 文件的 `RunTarget`。
   - **用户使用错误:**
     - **错误示例:** 用户在 `meson.build` 文件中调用 `i18n.gettext` 时，指定的 `languages` 列表中包含了一个不存在的语言代码（例如 "zz"）。
     - **说明:**  如果指定的语言代码没有对应的翻译文件，或者 `msgfmt` 等工具无法处理该语言代码，可能会导致构建失败或运行时无法正确加载翻译。
   - **调试线索 (用户操作):**
     1. 用户编辑 `meson.build` 文件。
     2. 用户调用 `i18n.gettext` 函数。
     3. 用户在 `languages` 参数中输入了无效的语言代码。
     4. 在构建过程中，`msgfmt` 可能会报错，或者生成的 `.mo` 文件可能不完整。

3. **`itstool_join` 函数:**
   - **功能:**  专门用于处理基于 XML 的翻译文件，通常用于文档翻译。它使用 `itstool` 工具将翻译合并到 XML 文件中。
   - **与逆向的关系:**
     - 如果逆向目标包含 XML 格式的资源或文档（例如 Android 应用的布局文件或字符串资源），并且需要对其进行本地化，可以使用 `itstool_join`。
     - **举例:** 假设你正在逆向一个 Android 应用，并希望翻译其用户界面字符串。这些字符串可能存储在 XML 资源文件中。你可以使用 `itstool_join` 将翻译后的 `.po` 文件合并回原始的 XML 文件，生成本地化版本的应用资源。
   - **涉及底层/内核/框架知识:**
     - `itstool` 工具理解 XML 结构，并能够将翻译内容正确地插入到 XML 标签中。这涉及到 XML 解析和操作的知识。
     - 在 Android 框架中，资源管理机制负责加载不同语言的 XML 资源。`itstool_join` 生成的本地化 XML 文件会被 Android 系统在运行时加载。
   - **逻辑推理:**
     - **假设输入:**  一个或多个 XML 文件 (`input`)，以及与之相关的已编译的 MO 文件 (`mo_targets`)。
     - **输出:**  生成一个新的 XML 文件 (`output`)，其中包含了从 MO 文件中提取的翻译。
   - **用户使用错误:**
     - **错误示例:** 用户在调用 `itstool_join` 时，提供的 `mo_targets` 列表与输入的 XML 文件不匹配，或者 MO 文件中缺少某些需要的翻译。
     - **说明:**  `itstool_join` 依赖于 MO 文件中包含与 XML 文件中可翻译字符串对应的翻译。如果 MO 文件不完整或不正确，合并过程可能会失败或产生不正确的输出。
   - **调试线索 (用户操作):**
     1. 用户编辑 `meson.build` 文件。
     2. 用户调用 `i18n.itstool_join` 函数。
     3. 用户提供的 `mo_targets` 列表不正确，或者与 `input` 中的 XML 文件不对应。
     4. 构建过程中，`itstool` 可能会报错，或者生成的 XML 文件可能包含未翻译的字符串。

**通用功能和概念:**

* **外部程序依赖:**  这些函数都依赖于外部的命令行工具，如 `msgfmt`, `msginit`, `msgmerge`, `xgettext`, 和 `itstool`。Meson 会负责查找这些工具。
* **构建系统集成:**  这些函数是 Meson 构建系统的一部分，它们返回 `CustomTarget` 和 `RunTarget` 对象，这些对象定义了构建过程中需要执行的步骤。
* **类型提示:**  代码使用了 Python 的类型提示 (typing) 来提高代码的可读性和可维护性。

**用户如何一步步到达这里 (调试线索):**

1. **Frida 项目的开发者或贡献者** 想要为 Frida 的工具或组件添加或更新本地化支持。
2. **他们编辑 Frida 项目的 `meson.build` 文件**，该文件描述了如何构建 Frida 项目。
3. **他们需要在 `meson.build` 文件中调用 `i18n` 模块提供的函数** (`merge_file`, `gettext`, 或 `itstool_join`) 来配置国际化相关的构建步骤。
4. **在调用这些函数时，他们会提供相应的参数**，例如输入文件、输出文件、语言代码等。
5. **如果参数配置不正确，Meson 在解析 `meson.build` 文件时或在构建过程中会抛出错误**。查看错误信息和相关的 `meson.build` 代码，就能定位到 `i18n.py` 模块中导致问题的函数调用。

**总结:**

`i18n.py` 是 Frida 项目中用于处理软件国际化的关键模块。它利用 GNU gettext 工具集和 `itstool` 来管理翻译文件，并将翻译集成到构建过程中。这使得 Frida 能够被本地化成不同的语言，提升用户体验。对于逆向工程师来说，理解这个模块的功能可以帮助他们本地化自己开发的逆向工具，或者理解目标软件的本地化机制。

### 提示词
```
这是目录为frida/subprojects/frida-clr/releng/meson/mesonbuild/modules/i18n.py的fridaDynamic instrumentation tool的源代码文件， 请列举一下它的功能, 
如果它与逆向的方法有关系，请做出对应的举例说明，
如果涉及到二进制底层，linux, android内核及框架的知识，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索。
```

### 源代码
```python
# SPDX-License-Identifier: Apache-2.0
# Copyright 2016 The Meson development team

from __future__ import annotations

from os import path
import shlex
import typing as T

from . import ExtensionModule, ModuleReturnValue, ModuleInfo
from .. import build
from .. import mesonlib
from .. import mlog
from ..interpreter.type_checking import CT_BUILD_BY_DEFAULT, CT_INPUT_KW, INSTALL_TAG_KW, OUTPUT_KW, INSTALL_DIR_KW, INSTALL_KW, NoneType, in_set_validator
from ..interpreterbase import FeatureNew, InvalidArguments
from ..interpreterbase.decorators import ContainerTypeInfo, KwargInfo, noPosargs, typed_kwargs, typed_pos_args
from ..programs import ExternalProgram
from ..scripts.gettext import read_linguas

if T.TYPE_CHECKING:
    from typing_extensions import Literal, TypedDict

    from . import ModuleState
    from ..build import Target
    from ..interpreter import Interpreter
    from ..interpreterbase import TYPE_var

    class MergeFile(TypedDict):

        input: T.List[T.Union[
            str, build.BuildTarget, build.CustomTarget, build.CustomTargetIndex,
            build.ExtractedObjects, build.GeneratedList, ExternalProgram,
            mesonlib.File]]
        output: str
        build_by_default: bool
        install: bool
        install_dir: T.Optional[str]
        install_tag: T.Optional[str]
        args: T.List[str]
        data_dirs: T.List[str]
        po_dir: str
        type: Literal['xml', 'desktop']

    class Gettext(TypedDict):

        args: T.List[str]
        data_dirs: T.List[str]
        install: bool
        install_dir: T.Optional[str]
        languages: T.List[str]
        preset: T.Optional[str]

    class ItsJoinFile(TypedDict):

        input: T.List[T.Union[
            str, build.BuildTarget, build.CustomTarget, build.CustomTargetIndex,
            build.ExtractedObjects, build.GeneratedList, ExternalProgram,
            mesonlib.File]]
        output: str
        build_by_default: bool
        install: bool
        install_dir: T.Optional[str]
        install_tag: T.Optional[str]
        its_files: T.List[str]
        mo_targets: T.List[T.Union[build.BuildTarget, build.CustomTarget, build.CustomTargetIndex]]


_ARGS: KwargInfo[T.List[str]] = KwargInfo(
    'args',
    ContainerTypeInfo(list, str),
    default=[],
    listify=True,
)

_DATA_DIRS: KwargInfo[T.List[str]] = KwargInfo(
    'data_dirs',
    ContainerTypeInfo(list, str),
    default=[],
    listify=True
)

PRESET_ARGS = {
    'glib': [
        '--from-code=UTF-8',
        '--add-comments',

        # https://developer.gnome.org/glib/stable/glib-I18N.html
        '--keyword=_',
        '--keyword=N_',
        '--keyword=C_:1c,2',
        '--keyword=NC_:1c,2',
        '--keyword=g_dcgettext:2',
        '--keyword=g_dngettext:2,3',
        '--keyword=g_dpgettext2:2c,3',

        '--flag=N_:1:pass-c-format',
        '--flag=C_:2:pass-c-format',
        '--flag=NC_:2:pass-c-format',
        '--flag=g_dngettext:2:pass-c-format',
        '--flag=g_strdup_printf:1:c-format',
        '--flag=g_string_printf:2:c-format',
        '--flag=g_string_append_printf:2:c-format',
        '--flag=g_error_new:3:c-format',
        '--flag=g_set_error:4:c-format',
        '--flag=g_markup_printf_escaped:1:c-format',
        '--flag=g_log:3:c-format',
        '--flag=g_print:1:c-format',
        '--flag=g_printerr:1:c-format',
        '--flag=g_printf:1:c-format',
        '--flag=g_fprintf:2:c-format',
        '--flag=g_sprintf:2:c-format',
        '--flag=g_snprintf:3:c-format',
    ]
}


class I18nModule(ExtensionModule):

    INFO = ModuleInfo('i18n')

    def __init__(self, interpreter: 'Interpreter'):
        super().__init__(interpreter)
        self.methods.update({
            'merge_file': self.merge_file,
            'gettext': self.gettext,
            'itstool_join': self.itstool_join,
        })
        self.tools: T.Dict[str, T.Optional[T.Union[ExternalProgram, build.Executable]]] = {
            'itstool': None,
            'msgfmt': None,
            'msginit': None,
            'msgmerge': None,
            'xgettext': None,
        }

    @staticmethod
    def _get_data_dirs(state: 'ModuleState', dirs: T.Iterable[str]) -> T.List[str]:
        """Returns source directories of relative paths"""
        src_dir = path.join(state.environment.get_source_dir(), state.subdir)
        return [path.join(src_dir, d) for d in dirs]

    @FeatureNew('i18n.merge_file', '0.37.0')
    @noPosargs
    @typed_kwargs(
        'i18n.merge_file',
        CT_BUILD_BY_DEFAULT,
        CT_INPUT_KW,
        KwargInfo('install_dir', (str, NoneType)),
        INSTALL_TAG_KW,
        OUTPUT_KW,
        INSTALL_KW,
        _ARGS.evolve(since='0.51.0'),
        _DATA_DIRS.evolve(since='0.41.0'),
        KwargInfo('po_dir', str, required=True),
        KwargInfo('type', str, default='xml', validator=in_set_validator({'xml', 'desktop'})),
    )
    def merge_file(self, state: 'ModuleState', args: T.List['TYPE_var'], kwargs: 'MergeFile') -> ModuleReturnValue:
        if kwargs['install'] and not kwargs['install_dir']:
            raise InvalidArguments('i18n.merge_file: "install_dir" keyword argument must be set when "install" is true.')

        if self.tools['msgfmt'] is None or not self.tools['msgfmt'].found():
            self.tools['msgfmt'] = state.find_program('msgfmt', for_machine=mesonlib.MachineChoice.BUILD)
        if isinstance(self.tools['msgfmt'], ExternalProgram):
            try:
                have_version = self.tools['msgfmt'].get_version()
            except mesonlib.MesonException as e:
                raise mesonlib.MesonException('i18n.merge_file requires GNU msgfmt') from e
            want_version = '>=0.19' if kwargs['type'] == 'desktop' else '>=0.19.7'
            if not mesonlib.version_compare(have_version, want_version):
                msg = f'i18n.merge_file requires GNU msgfmt {want_version} to produce files of type: ' + kwargs['type'] + f' (got: {have_version})'
                raise mesonlib.MesonException(msg)
        podir = path.join(state.build_to_src, state.subdir, kwargs['po_dir'])

        ddirs = self._get_data_dirs(state, kwargs['data_dirs'])
        datadirs = '--datadirs=' + ':'.join(ddirs) if ddirs else None

        command: T.List[T.Union[str, build.BuildTarget, build.CustomTarget,
                                build.CustomTargetIndex, 'ExternalProgram', mesonlib.File]] = []
        command.extend(state.environment.get_build_command())
        command.extend([
            '--internal', 'msgfmthelper',
            '--msgfmt=' + self.tools['msgfmt'].get_path(),
        ])
        if datadirs:
            command.append(datadirs)
        command.extend(['@INPUT@', '@OUTPUT@', kwargs['type'], podir])
        if kwargs['args']:
            command.append('--')
            command.extend(kwargs['args'])

        build_by_default = kwargs['build_by_default']
        if build_by_default is None:
            build_by_default = kwargs['install']

        install_tag = [kwargs['install_tag']] if kwargs['install_tag'] is not None else None

        ct = build.CustomTarget(
            '',
            state.subdir,
            state.subproject,
            state.environment,
            command,
            kwargs['input'],
            [kwargs['output']],
            state.is_build_only_subproject,
            build_by_default=build_by_default,
            install=kwargs['install'],
            install_dir=[kwargs['install_dir']] if kwargs['install_dir'] is not None else None,
            install_tag=install_tag,
            description='Merging translations for {}',
        )

        return ModuleReturnValue(ct, [ct])

    @typed_pos_args('i18n.gettext', str)
    @typed_kwargs(
        'i18n.gettext',
        _ARGS,
        _DATA_DIRS.evolve(since='0.36.0'),
        INSTALL_KW.evolve(default=True),
        INSTALL_DIR_KW.evolve(since='0.50.0'),
        KwargInfo('languages', ContainerTypeInfo(list, str), default=[], listify=True),
        KwargInfo(
            'preset',
            (str, NoneType),
            validator=in_set_validator(set(PRESET_ARGS)),
            since='0.37.0',
        ),
    )
    def gettext(self, state: 'ModuleState', args: T.Tuple[str], kwargs: 'Gettext') -> ModuleReturnValue:
        for tool, strict in [('msgfmt', True), ('msginit', False), ('msgmerge', False), ('xgettext', False)]:
            if self.tools[tool] is None:
                self.tools[tool] = state.find_program(tool, required=False, for_machine=mesonlib.MachineChoice.BUILD)
            # still not found?
            if not self.tools[tool].found():
                if strict:
                    mlog.warning('Gettext not found, all translation (po) targets will be ignored.',
                                 once=True, location=state.current_node)
                    return ModuleReturnValue(None, [])
                else:
                    mlog.warning(f'{tool!r} not found, maintainer targets will not work',
                                 once=True, fatal=False, location=state.current_node)
        packagename = args[0]
        pkg_arg = f'--pkgname={packagename}'

        languages = kwargs['languages']
        lang_arg = '--langs=' + '@@'.join(languages) if languages else None

        _datadirs = ':'.join(self._get_data_dirs(state, kwargs['data_dirs']))
        datadirs = f'--datadirs={_datadirs}' if _datadirs else None

        extra_args = kwargs['args']
        targets: T.List['Target'] = []
        gmotargets: T.List['build.CustomTarget'] = []

        preset = kwargs['preset']
        if preset:
            preset_args = PRESET_ARGS[preset]
            extra_args = list(mesonlib.OrderedSet(preset_args + extra_args))

        extra_arg = '--extra-args=' + '@@'.join(extra_args) if extra_args else None

        source_root = path.join(state.source_root, state.root_subdir)
        subdir = path.relpath(state.subdir, start=state.root_subdir) if state.subdir else None

        potargs = state.environment.get_build_command() + ['--internal', 'gettext', 'pot', pkg_arg]
        potargs.append(f'--source-root={source_root}')
        if subdir:
            potargs.append(f'--subdir={subdir}')
        if datadirs:
            potargs.append(datadirs)
        if extra_arg:
            potargs.append(extra_arg)
        if self.tools['xgettext'].found():
            potargs.append('--xgettext=' + self.tools['xgettext'].get_path())
        pottarget = build.RunTarget(packagename + '-pot', potargs, [], state.subdir, state.subproject,
                                    state.environment, default_env=False)
        targets.append(pottarget)

        install = kwargs['install']
        install_dir = kwargs['install_dir'] or state.environment.coredata.get_option(mesonlib.OptionKey('localedir'))
        assert isinstance(install_dir, str), 'for mypy'
        if not languages:
            languages = read_linguas(path.join(state.environment.source_dir, state.subdir))
        for l in languages:
            po_file = mesonlib.File.from_source_file(state.environment.source_dir,
                                                     state.subdir, l+'.po')
            gmotarget = build.CustomTarget(
                f'{packagename}-{l}.mo',
                path.join(state.subdir, l, 'LC_MESSAGES'),
                state.subproject,
                state.environment,
                [self.tools['msgfmt'], '-o', '@OUTPUT@', '@INPUT@'],
                [po_file],
                [f'{packagename}.mo'],
                state.is_build_only_subproject,
                install=install,
                # We have multiple files all installed as packagename+'.mo' in different install subdirs.
                # What we really wanted to do, probably, is have a rename: kwarg, but that's not available
                # to custom_targets. Crude hack: set the build target's subdir manually.
                # Bonus: the build tree has something usable as an uninstalled bindtextdomain() target dir.
                install_dir=[path.join(install_dir, l, 'LC_MESSAGES')],
                install_tag=['i18n'],
                description='Building translation {}',
            )
            targets.append(gmotarget)
            gmotargets.append(gmotarget)

        allgmotarget = build.AliasTarget(packagename + '-gmo', gmotargets, state.subdir, state.subproject,
                                         state.environment)
        targets.append(allgmotarget)

        updatepoargs = state.environment.get_build_command() + ['--internal', 'gettext', 'update_po', pkg_arg]
        updatepoargs.append(f'--source-root={source_root}')
        if subdir:
            updatepoargs.append(f'--subdir={subdir}')
        if lang_arg:
            updatepoargs.append(lang_arg)
        if datadirs:
            updatepoargs.append(datadirs)
        if extra_arg:
            updatepoargs.append(extra_arg)
        for tool in ['msginit', 'msgmerge']:
            if self.tools[tool].found():
                updatepoargs.append(f'--{tool}=' + self.tools[tool].get_path())
        updatepotarget = build.RunTarget(packagename + '-update-po', updatepoargs, [], state.subdir, state.subproject,
                                         state.environment, default_env=False)
        targets.append(updatepotarget)

        return ModuleReturnValue([gmotargets, pottarget, updatepotarget], targets)

    @FeatureNew('i18n.itstool_join', '0.62.0')
    @noPosargs
    @typed_kwargs(
        'i18n.itstool_join',
        CT_BUILD_BY_DEFAULT,
        CT_INPUT_KW,
        KwargInfo('install_dir', (str, NoneType)),
        INSTALL_TAG_KW,
        OUTPUT_KW,
        INSTALL_KW,
        _ARGS.evolve(),
        KwargInfo('its_files', ContainerTypeInfo(list, str)),
        KwargInfo('mo_targets', ContainerTypeInfo(list, build.CustomTarget), required=True),
    )
    def itstool_join(self, state: 'ModuleState', args: T.List['TYPE_var'], kwargs: 'ItsJoinFile') -> ModuleReturnValue:
        if kwargs['install'] and not kwargs['install_dir']:
            raise InvalidArguments('i18n.itstool_join: "install_dir" keyword argument must be set when "install" is true.')

        if self.tools['itstool'] is None:
            self.tools['itstool'] = state.find_program('itstool', for_machine=mesonlib.MachineChoice.BUILD)
        mo_targets = kwargs['mo_targets']
        its_files = kwargs.get('its_files', [])

        mo_fnames = []
        for target in mo_targets:
            mo_fnames.append(path.join(target.get_source_subdir(), target.get_outputs()[0]))

        command: T.List[T.Union[str, build.BuildTarget, build.CustomTarget,
                                build.CustomTargetIndex, 'ExternalProgram', mesonlib.File]] = []
        command.extend(state.environment.get_build_command())

        itstool_cmd = self.tools['itstool'].get_command()
        # TODO: python 3.8 can use shlex.join()
        command.extend([
            '--internal', 'itstool', 'join',
            '-i', '@INPUT@',
            '-o', '@OUTPUT@',
            '--itstool=' + ' '.join(shlex.quote(c) for c in itstool_cmd),
        ])
        if its_files:
            for fname in its_files:
                if not path.isabs(fname):
                    fname = path.join(state.environment.source_dir, state.subdir, fname)
                command.extend(['--its', fname])
        command.extend(mo_fnames)

        build_by_default = kwargs['build_by_default']
        if build_by_default is None:
            build_by_default = kwargs['install']

        install_tag = [kwargs['install_tag']] if kwargs['install_tag'] is not None else None

        ct = build.CustomTarget(
            '',
            state.subdir,
            state.subproject,
            state.environment,
            command,
            kwargs['input'],
            [kwargs['output']],
            state.is_build_only_subproject,
            build_by_default=build_by_default,
            extra_depends=mo_targets,
            install=kwargs['install'],
            install_dir=[kwargs['install_dir']] if kwargs['install_dir'] is not None else None,
            install_tag=install_tag,
            description='Merging translations for {}',
        )

        return ModuleReturnValue(ct, [ct])


def initialize(interp: 'Interpreter') -> I18nModule:
    return I18nModule(interp)
```
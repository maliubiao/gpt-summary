Response:
The user wants to understand the functionality of the `interpreter.py` file within the Frida dynamic instrumentation tool. This file seems to be part of the Meson build system integration for Frida.

Here's a breakdown of the thought process to analyze the provided code snippet:

1. **Identify the Core Functionality:** The filename `interpreter.py` and the context of a build system suggest this file is responsible for interpreting and executing build definitions. The presence of functions like `func_add_languages`, `func_message`, `func_find_program`, `func_executable`, etc., strongly indicates this is a central component for processing build instructions.

2. **Analyze Key Functions:**  Go through the most prominent functions to understand their purpose:
    * `__init__`: Initializes the interpreter, setting up the environment, compiler information, and project details.
    * `func_add_languages`:  Handles the addition of programming language support to the build.
    * `func_message`, `func_warning`, `func_error`, `func_debug`:  Implement logging and error reporting mechanisms.
    * `func_summary`: Collects and displays build summaries.
    * `func_find_program`:  Locates external programs needed for the build.
    * `func_dependency`:  Manages external dependencies required by the project.
    * `func_executable`, `func_static_lib`, `func_shared_lib`, `func_library`, `func_shared_module`, `func_jar`, `func_build_target`: Define how different types of build targets (executables, libraries, etc.) are created.

3. **Look for Connections to Reverse Engineering:** Frida is a reverse engineering tool. Consider how the build process defined by this interpreter might interact with reverse engineering tasks:
    * **Dynamic Instrumentation:**  The file is part of Frida. The build process is likely setting up the infrastructure needed for Frida to perform dynamic instrumentation. This could involve building the core Frida engine, the user-facing tools, and any necessary libraries or plugins.
    * **Target Environment:**  The code mentions `MachineChoice.HOST` and `MachineChoice.BUILD`. This hints at cross-compilation, a common scenario in reverse engineering where you might develop tools on one platform to analyze applications on a different target (e.g., analyzing an Android app from a Linux desktop).
    * **External Programs:**  `func_find_program` suggests the build process might need external tools. These could be debuggers, disassemblers, or other utilities often used in reverse engineering.

4. **Identify Interactions with Binary/Low-Level Concepts:** Look for clues related to lower-level aspects:
    * **Compilers:**  The heavy emphasis on language handling and compiler detection (`add_languages`, `detect_compiler_for`) is a direct link to binary code generation.
    * **Linkers:** The code explicitly mentions linkers and static linkers, fundamental tools in creating executable binaries and libraries.
    * **Shared Libraries/Modules:**  Functions for building shared libraries and modules are related to how code is organized and loaded at runtime, crucial for understanding how applications and operating systems work.
    * **Target Types:** The different build target types (`executable`, `static_library`, `shared_library`, etc.) represent different forms of binary output.

5. **Infer Logical Reasoning and Assumptions:** Analyze how the interpreter makes decisions:
    * **Conditional Logic:** `if` statements (e.g., checking for disabled features, native keyword, cross-compilation) show how the interpreter adapts its behavior based on build configurations.
    * **Error Handling:** `try...except` blocks indicate how the interpreter handles potential issues during the build process.
    * **Option Processing:** The code retrieves and uses build options, demonstrating how user-defined settings influence the build.

6. **Consider User Errors:**  Think about common mistakes users might make when using a build system like Meson:
    * **Missing Dependencies:**  The `func_dependency` and `func_find_program` functions are areas where users might encounter errors if required libraries or executables are not found.
    * **Incorrect Language Settings:**  Users might try to build code without specifying the necessary language support.
    * **Invalid Build Options:**  Providing incorrect or incompatible options to build functions can lead to errors.

7. **Trace User Operations:** Imagine a developer using Frida and how their actions might lead to this code being executed:
    * **Configuration:** The user runs a Meson command (e.g., `meson setup builddir`). This would trigger the interpreter to parse the `meson.build` files and execute the instructions within them, including the code in `interpreter.py`.
    * **Building:** The user then runs a build command (e.g., `ninja -C builddir`). This relies on the configuration generated by the interpreter.
    * **Dependency Management:** The user might need to install development packages or specify custom locations for dependencies, which would interact with the `func_dependency` and `func_find_program` logic.

8. **Synthesize and Summarize:** Combine the observations into a concise description of the file's functionality, addressing the user's specific questions about reverse engineering, low-level details, logical reasoning, user errors, and the path to this code.

**Self-Correction/Refinement:**

* **Initial thought:** Focus solely on the code snippet.
* **Correction:** Realize the need to consider the context of Frida and Meson to provide a more comprehensive explanation.
* **Initial thought:** List functions without explaining their higher-level purpose.
* **Correction:** Group functions by their roles (e.g., language handling, dependency management, target creation) for better clarity.
* **Initial thought:** Provide generic examples of user errors.
* **Correction:**  Tailor examples to the context of building Frida and dealing with its dependencies.
这是 `frida/subprojects/frida-clr/releng/meson/mesonbuild/interpreter/interpreter.py` 文件的一部分，它属于 Frida 工具中用于处理 .NET CLR 相关功能的子项目，并且是 Meson 构建系统的解释器模块的一部分。

**功能归纳 (基于提供的代码片段):**

这段代码的主要功能是实现了 Meson 构建系统中解释器的一部分核心功能，用于处理构建定义文件（通常是 `meson.build` 文件）中的指令。它涵盖了以下几个关键方面：

1. **语言支持管理 (`func_add_languages`, `add_languages`, `add_languages_for`):**
   - 负责添加项目所需的编程语言支持。
   - 检测系统中是否安装了指定语言的编译器。
   - 处理可选或必需的语言依赖。
   - 支持针对不同机器架构（主机和构建机器）添加语言。

2. **消息、警告、错误和调试输出 (`func_message`, `message_impl`, `func_warning`, `func_error`, `func_debug`):**
   - 提供了在构建过程中输出不同级别消息的函数，用于向用户反馈信息、警告或错误。
   - `func_message` 用于输出普通消息。
   - `func_warning` 用于输出警告信息。
   - `func_error` 用于输出错误信息并终止构建过程。
   - `func_debug` 用于输出调试信息。

3. **构建概要信息 (`func_summary`, `summary_impl`, `_print_subprojects`, `_print_summary`):**
   - 允许在构建过程中收集和展示概要信息。
   - 可以添加自定义的概要部分，包含键值对信息。
   - 自动添加子项目和用户定义选项的概要信息。
   - 在构建结束时打印所有收集到的概要信息。

4. **错误预期处理 (`func_expect_error`):**
   - 提供了一种上下文管理器，用于测试代码块是否会抛出预期的错误。
   - 可以指定错误消息的匹配方式（字面匹配或正则表达式匹配）。

5. **编译器检测和配置 (`add_languages_for`):**
   -  当需要某种语言的支持时，会尝试检测该语言的编译器。
   -  可以配置编译器的选项。
   -  支持交叉编译场景下的编译器检测。

6. **外部程序查找 (`program_from_file_for`, `program_from_system`, `program_from_overrides`, `find_program_impl`, `program_lookup`, `check_program_version`, `find_program_fallback`, `func_find_program`):**
   - 提供了查找系统中可执行程序的机制。
   - 可以从预定义的位置、系统路径或用户指定的目录中查找。
   - 支持覆盖默认的程序查找行为。
   - 可以检查找到的程序的版本是否符合要求。
   - 允许在找不到程序时回退到子项目提供的程序。

7. **依赖项管理 (`func_dependency`):**
   - 用于声明项目依赖的外部库或软件包。
   - 可以指定查找依赖项的不同方法（例如，使用 pkg-config、CMake 等）。
   - 可以处理找不到依赖项的情况，并提供自定义的错误消息。

8. **构建目标定义 (`func_executable`, `func_static_lib`, `func_shared_lib`, `func_both_lib`, `func_shared_module`, `func_library`, `func_jar`, `func_build_target`):**
   - 提供了定义不同类型构建目标的函数，例如可执行文件、静态库、共享库、共享模块和 JAR 文件。
   - 这些函数会创建相应的构建对象，并添加到构建图中。

9. **禁用器 (`func_disabler`):**
   - 提供了一种机制来禁用某些构建功能或目标。

**与逆向方法的关系：**

虽然这段代码本身是构建系统的一部分，但它直接参与了 Frida 工具的构建过程，而 Frida 本身是一个强大的动态插桩工具，广泛应用于逆向工程。

* **构建 Frida 核心组件:** 这段代码负责构建 Frida 的核心组件和相关模块，包括用于与 .NET CLR 交互的部分 (`frida-clr`)。逆向工程师会使用编译好的 Frida 核心来插桩和分析目标进程。
* **依赖外部逆向工具:** `func_find_program` 可能会被用来查找逆向工程中常用的工具，例如 `dumpbin` (Windows) 或 `objdump` (Linux)，以便在构建过程中执行一些额外的操作，例如提取符号信息。
* **处理特定平台依赖:**  在构建 Frida 时，可能需要处理不同操作系统和架构的依赖关系。这段代码中的语言和编译器管理机制可以确保在目标平台上正确地构建 Frida。
* **构建测试工具:** Frida 的构建过程可能包含构建用于测试插桩功能的工具。这些工具本身可能是用于逆向分析的示例或实用程序。

**举例说明 (逆向相关):**

假设 `meson.build` 文件中使用了 `find_program` 来查找 `ilasm.exe`（.NET 的汇编器），用于将 IL 代码编译成 PE 文件：

```python
ilasm = self.find_program('ilasm.exe', native=True, required=True)
```

这里，`self.find_program` 的调用就会进入 `interpreter.py` 的 `func_find_program` 方法。Meson 会尝试在系统的 PATH 环境变量中查找 `ilasm.exe`。如果找到，`ilasm` 变量将被赋值为表示该可执行文件的对象，后续可以用于构建 .NET 相关的组件。如果找不到，并且 `required=True`，构建过程将会报错。

**涉及二进制底层、Linux、Android 内核及框架的知识：**

* **二进制底层:**  编译器和链接器的使用是直接与二进制代码生成相关的。`add_languages_for` 函数负责检测和配置编译器，最终生成的 Frida 库和工具都是二进制文件。构建共享库 (`func_shared_lib`) 和静态库 (`func_static_lib`) 也直接涉及到二进制文件的组织和链接。
* **Linux:** 在 Linux 平台上构建 Frida 时，这段代码会处理 Linux 特有的编译器（例如 GCC、Clang）和链接器（例如 `ld`）。`func_find_program` 在 Linux 上会搜索 PATH 环境变量，这与 Linux 的可执行文件查找机制相关。
* **Android 内核及框架:** 虽然提供的代码片段没有直接涉及 Android 内核，但作为 `frida-clr` 子项目的一部分，它间接与 Android 框架有关。Frida 可以用来插桩 Android 上的 Dalvik/ART 虚拟机，而 `frida-clr` 专门处理 .NET CLR，这在某些 Android 环境中也可能存在（例如使用 Xamarin 构建的应用）。构建过程需要确保生成的 Frida 组件能在 Android 上运行，可能涉及到交叉编译和针对 Android 特定 API 的处理。

**逻辑推理 (假设输入与输出):**

假设 `meson.build` 文件中有以下代码：

```python
if host_machine.system() == 'windows':
    message('Building on Windows')
    my_compiler = find_program('cl.exe', required=True)
else:
    message('Building on non-Windows')
    my_compiler = find_program('gcc', required=True)
```

**假设输入:** 当前构建环境的操作系统是 Windows。

**输出:**

1. `func_add_languages` 可能在初始化时被调用，用于添加 C/C++ 语言支持。
2. `func_message` 会被调用，输出 "Building on Windows"。
3. `func_find_program` 会被调用，尝试查找名为 `cl.exe` 的程序。
4. 如果在 PATH 中找到 `cl.exe`，`func_find_program` 将返回表示 `cl.exe` 的 `ExternalProgram` 对象。
5. 如果找不到 `cl.exe`，由于 `required=True`，`func_find_program` 将抛出 `InterpreterException`，导致构建失败。

**涉及用户或编程常见的使用错误：**

1. **拼写错误：** 用户在 `meson.build` 文件中错误地拼写了函数名或参数名，例如 `find_progran` 而不是 `find_program`，会导致 Meson 解释器无法识别，从而抛出语法错误或 `AttributeError`。
2. **缺少必要的依赖：** 如果 `meson.build` 文件中使用了 `find_program('some-tool', required=True)`，但用户没有安装 `some-tool`，那么构建过程会因为找不到该程序而失败。
3. **错误的 `native` 参数：** 在交叉编译场景下，如果用户错误地设置了 `native` 参数，例如在构建主机工具时忘记设置 `native=True`，可能会导致 Meson 尝试查找目标平台的工具，从而失败。
4. **未安装编译器：** 如果 `meson.build` 中要求使用某种编程语言，但系统中没有安装相应的编译器，`add_languages` 或后续的编译步骤会失败。
5. **传递错误类型的参数：** Meson 的函数通常对参数类型有要求。如果用户传递了错误类型的参数（例如，期望字符串却传递了列表），会导致 `TypeError` 或 `InvalidArguments` 异常。

**用户操作如何一步步到达这里 (调试线索):**

1. **编写 `meson.build` 文件：** 用户首先需要编写一个 `meson.build` 文件，其中定义了 Frida 项目的构建规则，包括需要编译的源代码、依赖的库、要执行的外部程序等。例如，文件中可能包含 `project('frida-core', 'cpp')` 来声明项目名称和使用的语言，以及调用 `executable()`、`shared_library()` 或 `find_program()` 等函数。
2. **运行 `meson setup` 命令：** 用户在项目源代码的根目录下打开终端，并执行 `meson setup <build_directory>` 命令。这个命令会启动 Meson 构建系统的配置阶段。
3. **Meson 解析 `meson.build`：** Meson 会读取并解析 `meson.build` 文件。在这个过程中，会创建 `interpreter.py` 的实例，并逐行解释和执行 `meson.build` 文件中的代码。
4. **执行到相关函数调用：** 当 Meson 解析到例如 `add_languages(['cpp'])` 或 `find_program('gcc')` 这样的语句时，就会调用 `interpreter.py` 中对应的 `func_add_languages` 或 `func_find_program` 函数。
5. **`interpreter.py` 执行逻辑：**  `interpreter.py` 中的代码会执行相应的逻辑，例如检测编译器是否存在、查找外部程序、记录构建信息等。如果遇到错误，例如找不到编译器或程序，就会抛出异常，导致配置失败。
6. **查看构建日志：** 如果构建过程中出现问题，用户可以查看 Meson 生成的构建日志（通常在 `<build_directory>/meson-log.txt` 中），日志会记录 Meson 的执行过程，包括调用的函数、输出的消息、警告和错误信息，从而帮助用户定位问题。例如，如果 `find_program` 找不到指定的程序，日志中会包含相关的错误信息。

总而言之，`interpreter.py` 是 Meson 构建系统的核心组件，负责解释构建定义文件，管理构建过程中的各种任务，包括语言支持、依赖管理、外部程序查找和构建目标定义。对于 Frida 这样的复杂项目，它确保了项目能够正确地构建出可执行的工具和库，而这些工具和库正是逆向工程师进行动态插桩和分析的基础。

### 提示词
```
这是目录为frida/subprojects/frida-clr/releng/meson/mesonbuild/interpreter/interpreter.py的fridaDynamic instrumentation tool的源代码文件， 请列举一下它的功能, 
如果它与逆向的方法有关系，请做出对应的举例说明，
如果涉及到二进制底层，linux, android内核及框架的知识，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索。
这是第3部分，共6部分，请归纳一下它的功能
```

### 源代码
```python
'backend'))
            vsenv = self.coredata.get_option(OptionKey('vsenv'))
            force_vsenv = vsenv or backend.startswith('vs')
            mesonlib.setup_vsenv(force_vsenv)

        self.add_languages(proj_langs, True, MachineChoice.HOST)
        self.add_languages(proj_langs, False, MachineChoice.BUILD)

        self.set_backend()
        if not self.is_subproject():
            self.check_stdlibs()

    @typed_kwargs('add_languages', KwargInfo('native', (bool, NoneType), since='0.54.0'), REQUIRED_KW)
    @typed_pos_args('add_languages', varargs=str)
    def func_add_languages(self, node: mparser.FunctionNode, args: T.Tuple[T.List[str]], kwargs: 'kwtypes.FuncAddLanguages') -> bool:
        langs = args[0]
        disabled, required, feature = extract_required_kwarg(kwargs, self.subproject)
        native = kwargs['native']

        if disabled:
            for lang in sorted(langs, key=compilers.sort_clink):
                mlog.log('Compiler for language', mlog.bold(lang), 'skipped: feature', mlog.bold(feature), 'disabled')
            return False
        if native is not None:
            return self.add_languages(langs, required, self.machine_from_native_kwarg(kwargs))
        else:
            # absent 'native' means 'both' for backwards compatibility
            tv = FeatureNew.get_target_version(self.subproject)
            if FeatureNew.check_version(tv, '0.54.0'):
                mlog.warning('add_languages is missing native:, assuming languages are wanted for both host and build.',
                             location=node)

            success = self.add_languages(langs, False, MachineChoice.BUILD)
            success &= self.add_languages(langs, required, MachineChoice.HOST)
            return success

    def _stringify_user_arguments(self, args: T.List[TYPE_var], func_name: str) -> T.List[str]:
        try:
            return [stringifyUserArguments(i, self.subproject) for i in args]
        except InvalidArguments as e:
            raise InvalidArguments(f'{func_name}(): {str(e)}')

    @noArgsFlattening
    @noKwargs
    def func_message(self, node: mparser.BaseNode, args, kwargs):
        if len(args) > 1:
            FeatureNew.single_use('message with more than one argument', '0.54.0', self.subproject, location=node)
        args_str = self._stringify_user_arguments(args, 'message')
        self.message_impl(args_str)

    def message_impl(self, args):
        mlog.log(mlog.bold('Message:'), *args)

    @noArgsFlattening
    @FeatureNew('summary', '0.53.0')
    @typed_pos_args('summary', (str, dict), optargs=[object])
    @typed_kwargs(
        'summary',
        KwargInfo('section', str, default=''),
        KwargInfo('bool_yn', bool, default=False),
        KwargInfo('list_sep', (str, NoneType), since='0.54.0')
    )
    def func_summary(self, node: mparser.BaseNode, args: T.Tuple[T.Union[str, T.Dict[str, T.Any]], T.Optional[T.Any]],
                     kwargs: 'kwtypes.Summary') -> None:
        if self.coredata.is_build_only:
            return
        if args[1] is None:
            if not isinstance(args[0], dict):
                raise InterpreterException('Summary first argument must be dictionary.')
            values = args[0]
        else:
            if not isinstance(args[0], str):
                raise InterpreterException('Summary first argument must be string.')
            values = {args[0]: args[1]}
        self.summary_impl(kwargs['section'], values, kwargs)

    def summary_impl(self, section: str, values, kwargs: 'kwtypes.Summary') -> None:
        if self.subproject not in self.summary:
            self.summary[self.subproject] = Summary(self.active_projectname, self.project_version)
        self.summary[self.subproject].add_section(
            section, values, kwargs['bool_yn'], kwargs['list_sep'], self.subproject)

    def _print_subprojects(self, for_machine: MachineChoice) -> None:
        # Add automatic 'Subprojects' section in main project.
        all_subprojects = collections.OrderedDict()
        for name, subp in sorted(self.subprojects[for_machine].items()):
            value = [subp.found()]
            if subp.disabled_feature:
                value += [f'Feature {subp.disabled_feature!r} disabled']
            elif subp.exception:
                value += [str(subp.exception)]
            elif subp.warnings > 0:
                value += [f'{subp.warnings} warnings']
            if subp.callstack:
                stack = ' => '.join(subp.callstack)
                value += [f'(from {stack})']
            all_subprojects[name] = value
        if all_subprojects:
            self.summary_impl(f'Subprojects (for {for_machine.get_lower_case_name()} machine)', all_subprojects,
                              {'bool_yn': True,
                               'list_sep': ' ',
                               })

    def _print_summary(self) -> None:
        self._print_subprojects(MachineChoice.HOST)
        if self.environment.is_cross_build():
            self._print_subprojects(MachineChoice.BUILD)
        # Add automatic section with all user defined options
        if self.user_defined_options:
            values = collections.OrderedDict()
            if self.user_defined_options.cross_file:
                values['Cross files'] = self.user_defined_options.cross_file
            if self.user_defined_options.native_file:
                values['Native files'] = self.user_defined_options.native_file
            sorted_options = sorted(self.user_defined_options.cmd_line_options.items())
            values.update({str(k): v for k, v in sorted_options})
            if values:
                self.summary_impl('User defined options', values, {'bool_yn': False, 'list_sep': None})
        # Print all summaries, main project last.
        mlog.log('')  # newline
        main_summary = self.summary.pop('', None)
        for subp_name, summary in sorted(self.summary.items()):
            if self.subprojects.host[subp_name].found():
                summary.dump()
        if main_summary:
            main_summary.dump()

    @noArgsFlattening
    @FeatureNew('warning', '0.44.0')
    @noKwargs
    def func_warning(self, node, args, kwargs):
        if len(args) > 1:
            FeatureNew.single_use('warning with more than one argument', '0.54.0', self.subproject, location=node)
        args_str = self._stringify_user_arguments(args, 'warning')
        mlog.warning(*args_str, location=node)

    @noArgsFlattening
    @noKwargs
    def func_error(self, node, args, kwargs):
        if len(args) > 1:
            FeatureNew.single_use('error with more than one argument', '0.58.0', self.subproject, location=node)
        args_str = self._stringify_user_arguments(args, 'error')
        raise InterpreterException('Problem encountered: ' + ' '.join(args_str))

    @noArgsFlattening
    @FeatureNew('debug', '0.63.0')
    @noKwargs
    def func_debug(self, node, args, kwargs):
        args_str = self._stringify_user_arguments(args, 'debug')
        mlog.debug('Debug:', *args_str)

    @noKwargs
    @noPosargs
    def func_exception(self, node, args, kwargs):
        raise RuntimeError('unit test traceback :)')

    @typed_pos_args('expect_error', str)
    @typed_kwargs(
        'expect_error',
        KwargInfo('how', str, default='literal', validator=in_set_validator({'literal', 're'})),
    )
    def func_expect_error(self, node: mparser.BaseNode, args: T.Tuple[str], kwargs: TYPE_kwargs) -> ContextManagerObject:
        class ExpectErrorObject(ContextManagerObject):
            def __init__(self, msg: str, how: str, subproject: str) -> None:
                super().__init__(subproject)
                self.msg = msg
                self.how = how

            def __exit__(self, exc_type, exc_val, exc_tb):
                if exc_val is None:
                    raise InterpreterException('Expecting an error but code block succeeded')
                if isinstance(exc_val, mesonlib.MesonException):
                    msg = str(exc_val)
                    if (self.how == 'literal' and self.msg != msg) or \
                       (self.how == 're' and not re.match(self.msg, msg)):
                        raise InterpreterException(f'Expecting error {self.msg!r} but got {msg!r}')
                    return True
        return ExpectErrorObject(args[0], kwargs['how'], self.subproject)

    def add_languages(self, args: T.List[str], required: bool, for_machine: MachineChoice) -> bool:
        success = self.add_languages_for(args, required, for_machine)
        if not self.coredata.is_cross_build():
            self.coredata.copy_build_options_from_regular_ones()
        self._redetect_machines()
        return success

    def should_skip_sanity_check(self, for_machine: MachineChoice) -> bool:
        should = self.environment.properties.host.get('skip_sanity_check', False)
        if not isinstance(should, bool):
            raise InterpreterException('Option skip_sanity_check must be a boolean.')
        if for_machine != MachineChoice.HOST and not should:
            return False
        if not self.environment.is_cross_build() and not should:
            return False
        return should

    def add_languages_for(self, args: T.List[str], required: bool, for_machine: MachineChoice) -> bool:
        args = [a.lower() for a in args]
        langs = set(self.compilers[for_machine].keys())
        langs.update(args)
        # We'd really like to add cython's default language here, but it can't
        # actually be done because the cython compiler hasn't been initialized,
        # so we can't actually get the option yet. Because we can't know what
        # compiler to add by default, and we don't want to add unnecessary
        # compilers we don't add anything for cython here, and instead do it
        # When the first cython target using a particular language is used.
        if 'vala' in langs and 'c' not in langs:
            FeatureNew.single_use('Adding Vala language without C', '0.59.0', self.subproject, location=self.current_node)
            args.append('c')
        if 'nasm' in langs:
            FeatureNew.single_use('Adding NASM language', '0.64.0', self.subproject, location=self.current_node)

        success = True
        for lang in sorted(args, key=compilers.sort_clink):
            if lang in self.compilers[for_machine]:
                continue
            machine_name = 'build' if self.coredata.is_build_only else for_machine.get_lower_case_name()
            comp = self.coredata.compilers[for_machine].get(lang)
            if not comp:
                try:
                    skip_sanity_check = self.should_skip_sanity_check(for_machine)
                    if skip_sanity_check:
                        mlog.log('Cross compiler sanity tests disabled via the cross file.', once=True)
                    comp = compilers.detect_compiler_for(self.environment, lang, for_machine, skip_sanity_check, self.subproject)
                    if comp is None:
                        raise InvalidArguments(f'Tried to use unknown language "{lang}".')
                except mesonlib.MesonException:
                    if not required:
                        mlog.log('Compiler for language',
                                 mlog.bold(lang), 'for the', machine_name,
                                 'machine not found.')
                        success = False
                        continue
                    else:
                        raise
            else:
                # update new values from commandline, if it applies
                self.coredata.process_compiler_options(lang, comp, self.environment, self.subproject)

            # Add per-subproject compiler options. They inherit value from main project.
            if self.subproject:
                options = {}
                for k in comp.get_options():
                    v = copy.copy(self.coredata.options[k])
                    k = k.evolve(subproject=self.subproject)
                    options[k] = v
                self.coredata.add_compiler_options(options, lang, for_machine, self.environment, self.subproject)

            if for_machine == MachineChoice.HOST or self.environment.is_cross_build():
                logger_fun = mlog.log
            else:
                logger_fun = mlog.debug
            logger_fun(comp.get_display_language(), 'compiler for the', machine_name, 'machine:',
                       mlog.bold(' '.join(comp.get_exelist())), comp.get_version_string())
            if comp.linker is not None:
                logger_fun(comp.get_display_language(), 'linker for the', machine_name, 'machine:',
                           mlog.bold(' '.join(comp.linker.get_exelist())), comp.linker.id, comp.linker.version)
            self.build.ensure_static_linker(comp)
            self.compilers[for_machine][lang] = comp

        return success

    def program_from_file_for(self, for_machine: MachineChoice, prognames: T.List[mesonlib.FileOrString]
                              ) -> T.Optional[ExternalProgram]:
        for p in prognames:
            if isinstance(p, mesonlib.File):
                continue # Always points to a local (i.e. self generated) file.
            if not isinstance(p, str):
                raise InterpreterException('Executable name must be a string')
            prog = ExternalProgram.from_bin_list(self.environment, for_machine, p)
            # if the machine file specified something, it may be a regular
            # not-found program but we still want to return that
            if not isinstance(prog, NonExistingExternalProgram):
                return prog
        return None

    def program_from_system(self, args: T.List[mesonlib.FileOrString], search_dirs: T.List[str],
                            extra_info: T.List[mlog.TV_Loggable]) -> T.Optional[ExternalProgram]:
        # Search for scripts relative to current subdir.
        # Do not cache found programs because find_program('foobar')
        # might give different results when run from different source dirs.
        source_dir = os.path.join(self.environment.get_source_dir(), self.subdir)
        for exename in args:
            if isinstance(exename, mesonlib.File):
                if exename.is_built:
                    search_dir = os.path.join(self.environment.get_build_dir(),
                                              exename.subdir)
                else:
                    search_dir = os.path.join(self.environment.get_source_dir(),
                                              exename.subdir)
                exename = exename.fname
                extra_search_dirs = []
            elif isinstance(exename, str):
                search_dir = source_dir
                extra_search_dirs = search_dirs
            else:
                raise InvalidArguments(f'find_program only accepts strings and files, not {exename!r}')
            extprog = ExternalProgram(exename, search_dir=search_dir,
                                      extra_search_dirs=extra_search_dirs,
                                      silent=True)
            if extprog.found():
                extra_info.append(f"({' '.join(extprog.get_command())})")
                return extprog
        return None

    def program_from_overrides(self, command_names: T.List[mesonlib.FileOrString],
                               extra_info: T.List['mlog.TV_Loggable'], for_machine: MachineChoice,
                               ) -> T.Optional[T.Union[ExternalProgram, OverrideProgram, build.Executable]]:
        for name in command_names:
            if not isinstance(name, str):
                continue
            if name in self.build.find_overrides[for_machine]:
                exe = self.build.find_overrides[for_machine][name]
                extra_info.append(mlog.blue('(overridden)'))
                return exe
        return None

    def store_name_lookups(self, command_names: T.List[mesonlib.FileOrString], for_machine: MachineChoice) -> None:
        for name in command_names:
            if isinstance(name, str):
                self.build.searched_programs[for_machine].add(name)

    def add_find_program_override(self, name: str, exe: T.Union[build.Executable, ExternalProgram, 'OverrideProgram'],
                                  for_machine: MachineChoice = MachineChoice.HOST) -> None:
        if name in self.build.searched_programs[for_machine]:
            raise InterpreterException(f'Tried to override finding of executable "{name}" which has already been found.')
        if name in self.build.find_overrides[for_machine]:
            raise InterpreterException(f'Tried to override executable "{name}" which has already been overridden.')
        self.build.find_overrides[for_machine][name] = exe

    def notfound_program(self, args: T.List[mesonlib.FileOrString]) -> ExternalProgram:
        return NonExistingExternalProgram(' '.join(
            [a if isinstance(a, str) else a.absolute_path(self.environment.source_dir, self.environment.build_dir)
             for a in args]))

    # TODO update modules to always pass `for_machine`. It is bad-form to assume
    # the host machine.
    def find_program_impl(self, args: T.List[mesonlib.FileOrString],
                          for_machine: MachineChoice = MachineChoice.HOST,
                          default_options: T.Optional[T.Dict[OptionKey, T.Union[str, int, bool, T.List[str]]]] = None,
                          required: bool = True, silent: bool = True,
                          wanted: T.Union[str, T.List[str]] = '',
                          search_dirs: T.Optional[T.List[str]] = None,
                          version_func: T.Optional[ProgramVersionFunc] = None
                          ) -> T.Union['ExternalProgram', 'build.Executable', 'OverrideProgram']:
        args = mesonlib.listify(args)

        extra_info: T.List[mlog.TV_Loggable] = []
        progobj = self.program_lookup(args, for_machine, default_options, required, search_dirs, wanted, version_func, extra_info)
        if progobj is None or not self.check_program_version(progobj, wanted, version_func, for_machine, extra_info):
            progobj = self.notfound_program(args)

        if isinstance(progobj, ExternalProgram) and not progobj.found():
            if not silent:
                mlog.log('Program', mlog.bold(progobj.get_name()), 'found:', mlog.red('NO'), *extra_info)
            if required:
                m = 'Program {!r} not found or not executable'
                raise InterpreterException(m.format(progobj.get_name()))
            return progobj

        # Only store successful lookups
        self.store_name_lookups(args, for_machine)
        if not silent:
            mlog.log('Program', mlog.bold(progobj.name), 'found:', mlog.green('YES'), *extra_info)
        if isinstance(progobj, build.Executable):
            progobj.was_returned_by_find_program = True
        return progobj

    def program_lookup(self, args: T.List[mesonlib.FileOrString], for_machine: MachineChoice,
                       default_options: T.Optional[T.Dict[OptionKey, T.Union[str, int, bool, T.List[str]]]],
                       required: bool,
                       search_dirs: T.List[str],
                       wanted: T.Union[str, T.List[str]],
                       version_func: T.Optional[ProgramVersionFunc],
                       extra_info: T.List[mlog.TV_Loggable]
                       ) -> T.Optional[T.Union[ExternalProgram, build.Executable, OverrideProgram]]:
        progobj = self.program_from_overrides(args, extra_info, for_machine)
        if progobj:
            return progobj

        if args[0] == 'meson':
            # Override find_program('meson') to return what we were invoked with
            return ExternalProgram('meson', self.environment.get_build_command(), silent=True)

        fallback = None
        wrap_mode = self.coredata.get_option(OptionKey('wrap_mode'))
        if wrap_mode != WrapMode.nofallback and self.environment.wrap_resolver:
            fallback = self.environment.wrap_resolver.find_program_provider(args)
        if fallback and wrap_mode == WrapMode.forcefallback:
            return self.find_program_fallback(fallback, args, default_options, required, extra_info, for_machine)

        progobj = self.program_from_file_for(for_machine, args)
        if progobj is None:
            progobj = self.program_from_system(args, search_dirs, extra_info)
        if progobj is None and args[0].endswith('python3'):
            prog = ExternalProgram('python3', mesonlib.python_command, silent=True)
            progobj = prog if prog.found() else None

        if progobj and not self.check_program_version(progobj, wanted, version_func, for_machine, extra_info):
            progobj = None

        if progobj is None and fallback and required:
            progobj = self.notfound_program(args)
            mlog.log('Program', mlog.bold(progobj.get_name()), 'found:', mlog.red('NO'), *extra_info)
            extra_info.clear()
            progobj = self.find_program_fallback(fallback, args, default_options, required, extra_info, for_machine)

        return progobj

    def check_program_version(self, progobj: T.Union[ExternalProgram, build.Executable, OverrideProgram],
                              wanted: T.Union[str, T.List[str]],
                              version_func: T.Optional[ProgramVersionFunc],
                              for_machine: MachineChoice,
                              extra_info: T.List[mlog.TV_Loggable]) -> bool:
        if wanted:
            if version_func:
                version = version_func(progobj)
            elif isinstance(progobj, build.Executable):
                if progobj.subproject:
                    interp = self.subprojects[for_machine][progobj.subproject].held_object
                else:
                    interp = self
                assert isinstance(interp, Interpreter)
                version = interp.project_version
            else:
                version = progobj.get_version(self)
            is_found, not_found, _ = mesonlib.version_compare_many(version, wanted)
            if not is_found:
                extra_info[:0] = ['found', mlog.normal_cyan(version), 'but need:',
                                  mlog.bold(', '.join([f"'{e}'" for e in not_found]))]
                return False
            extra_info.insert(0, mlog.normal_cyan(version))
        return True

    def find_program_fallback(self, fallback: str, args: T.List[mesonlib.FileOrString],
                              default_options: T.Dict[OptionKey, T.Union[str, int, bool, T.List[str]]],
                              required: bool, extra_info: T.List[mlog.TV_Loggable],
                              for_machine: MachineChoice
                              ) -> T.Optional[T.Union[ExternalProgram, build.Executable, OverrideProgram]]:
        mlog.log('Fallback to subproject', mlog.bold(fallback), 'which provides program',
                 mlog.bold(' '.join(args)))
        sp_kwargs: kwtypes.DoSubproject = {
            'required': required,
            'default_options': default_options or {},
            'version': [],
            'cmake_options': [],
            'options': None,
            'for_machine': for_machine,
        }
        self.do_subproject(fallback, sp_kwargs)
        return self.program_from_overrides(args, extra_info, for_machine)

    @typed_pos_args('find_program', varargs=(str, mesonlib.File), min_varargs=1)
    @typed_kwargs(
        'find_program',
        DISABLER_KW.evolve(since='0.49.0'),
        NATIVE_KW,
        REQUIRED_KW,
        KwargInfo('dirs', ContainerTypeInfo(list, str), default=[], listify=True, since='0.53.0'),
        KwargInfo('version', ContainerTypeInfo(list, str), default=[], listify=True, since='0.52.0'),
        DEFAULT_OPTIONS.evolve(since='1.3.0')
    )
    @disablerIfNotFound
    def func_find_program(self, node: mparser.BaseNode, args: T.Tuple[T.List[mesonlib.FileOrString]],
                          kwargs: 'kwtypes.FindProgram',
                          ) -> T.Union['build.Executable', ExternalProgram, 'OverrideProgram']:
        disabled, required, feature = extract_required_kwarg(kwargs, self.subproject)
        if disabled:
            mlog.log('Program', mlog.bold(' '.join(args[0])), 'skipped: feature', mlog.bold(feature), 'disabled')
            return self.notfound_program(args[0])

        search_dirs = extract_search_dirs(kwargs)
        default_options = kwargs['default_options']
        return self.find_program_impl(args[0], kwargs['native'], default_options=default_options, required=required,
                                      silent=False, wanted=kwargs['version'],
                                      search_dirs=search_dirs)

    # When adding kwargs, please check if they make sense in dependencies.get_dep_identifier()
    @FeatureNewKwargs('dependency', '0.57.0', ['cmake_package_version'])
    @FeatureNewKwargs('dependency', '0.56.0', ['allow_fallback'])
    @FeatureNewKwargs('dependency', '0.54.0', ['components'])
    @FeatureNewKwargs('dependency', '0.52.0', ['include_type'])
    @FeatureNewKwargs('dependency', '0.50.0', ['not_found_message', 'cmake_module_path', 'cmake_args'])
    @FeatureNewKwargs('dependency', '0.49.0', ['disabler'])
    @FeatureNewKwargs('dependency', '0.40.0', ['method'])
    @disablerIfNotFound
    @permittedKwargs(permitted_dependency_kwargs)
    @typed_pos_args('dependency', varargs=str, min_varargs=1)
    @typed_kwargs('dependency', DEFAULT_OPTIONS.evolve(since='0.38.0'), allow_unknown=True)
    def func_dependency(self, node: mparser.BaseNode, args: T.Tuple[T.List[str]], kwargs) -> Dependency:
        # Replace '' by empty list of names
        names = [n for n in args[0] if n]
        if len(names) > 1:
            FeatureNew('dependency with more than one name', '0.60.0').use(self.subproject)
        allow_fallback = kwargs.get('allow_fallback')
        if allow_fallback is not None and not isinstance(allow_fallback, bool):
            raise InvalidArguments('"allow_fallback" argument must be boolean')
        fallback = kwargs.get('fallback')
        default_options = kwargs.get('default_options')
        for_machine = MachineChoice.BUILD if self.coredata.is_build_only else self.machine_from_native_kwarg(kwargs)
        df = DependencyFallbacksHolder(self, names, for_machine, allow_fallback, default_options)
        df.set_fallback(fallback)
        not_found_message = kwargs.get('not_found_message', '')
        if not isinstance(not_found_message, str):
            raise InvalidArguments('The not_found_message must be a string.')
        try:
            d = df.lookup(kwargs)
        except Exception:
            if not_found_message:
                self.message_impl([not_found_message])
            raise
        assert isinstance(d, Dependency)
        if not d.found() and not_found_message:
            self.message_impl([not_found_message])
        # Ensure the correct include type
        if 'include_type' in kwargs:
            wanted = kwargs['include_type']
            if not isinstance(wanted, str):
                raise InvalidArguments('The `include_type` kwarg must be a string')
            actual = d.get_include_type()
            if wanted != actual:
                mlog.debug(f'Current include type of {args[0]} is {actual}. Converting to requested {wanted}')
                d = d.generate_system_dependency(wanted)
        if d.feature_since is not None:
            version, extra_msg = d.feature_since
            FeatureNew.single_use(f'dep {d.name!r} custom lookup', version, self.subproject, extra_msg, node)
        for f in d.featurechecks:
            f.use(self.subproject, node)
        return d

    @FeatureNew('disabler', '0.44.0')
    @noKwargs
    @noPosargs
    def func_disabler(self, node, args, kwargs):
        return Disabler()

    @permittedKwargs(build.known_exe_kwargs)
    @typed_pos_args('executable', str, varargs=SOURCES_VARARGS)
    @typed_kwargs('executable', *EXECUTABLE_KWS, allow_unknown=True)
    def func_executable(self, node: mparser.BaseNode,
                        args: T.Tuple[str, SourcesVarargsType],
                        kwargs: kwtypes.Executable) -> build.Executable:
        return self.build_target(node, args, kwargs, build.Executable)

    @permittedKwargs(build.known_stlib_kwargs)
    @typed_pos_args('static_library', str, varargs=SOURCES_VARARGS)
    @typed_kwargs('static_library', *STATIC_LIB_KWS, allow_unknown=True)
    def func_static_lib(self, node: mparser.BaseNode,
                        args: T.Tuple[str, SourcesVarargsType],
                        kwargs: kwtypes.StaticLibrary) -> build.StaticLibrary:
        return self.build_target(node, args, kwargs, build.StaticLibrary)

    @permittedKwargs(build.known_shlib_kwargs)
    @typed_pos_args('shared_library', str, varargs=SOURCES_VARARGS)
    @typed_kwargs('shared_library', *SHARED_LIB_KWS, allow_unknown=True)
    def func_shared_lib(self, node: mparser.BaseNode,
                        args: T.Tuple[str, SourcesVarargsType],
                        kwargs: kwtypes.SharedLibrary) -> build.SharedLibrary:
        holder = self.build_target(node, args, kwargs, build.SharedLibrary)
        holder.shared_library_only = True
        return holder

    @permittedKwargs(known_library_kwargs)
    @typed_pos_args('both_libraries', str, varargs=SOURCES_VARARGS)
    @typed_kwargs('both_libraries', *LIBRARY_KWS, allow_unknown=True)
    def func_both_lib(self, node: mparser.BaseNode,
                      args: T.Tuple[str, SourcesVarargsType],
                      kwargs: kwtypes.Library) -> build.BothLibraries:
        return self.build_both_libraries(node, args, kwargs)

    @FeatureNew('shared_module', '0.37.0')
    @permittedKwargs(build.known_shmod_kwargs)
    @typed_pos_args('shared_module', str, varargs=SOURCES_VARARGS)
    @typed_kwargs('shared_module', *SHARED_MOD_KWS, allow_unknown=True)
    def func_shared_module(self, node: mparser.BaseNode,
                           args: T.Tuple[str, SourcesVarargsType],
                           kwargs: kwtypes.SharedModule) -> build.SharedModule:
        return self.build_target(node, args, kwargs, build.SharedModule)

    @permittedKwargs(known_library_kwargs)
    @typed_pos_args('library', str, varargs=SOURCES_VARARGS)
    @typed_kwargs('library', *LIBRARY_KWS, allow_unknown=True)
    def func_library(self, node: mparser.BaseNode,
                     args: T.Tuple[str, SourcesVarargsType],
                     kwargs: kwtypes.Library) -> build.Executable:
        return self.build_library(node, args, kwargs)

    @permittedKwargs(build.known_jar_kwargs)
    @typed_pos_args('jar', str, varargs=(str, mesonlib.File, build.CustomTarget, build.CustomTargetIndex, build.GeneratedList, build.ExtractedObjects, build.BuildTarget))
    @typed_kwargs('jar', *JAR_KWS, allow_unknown=True)
    def func_jar(self, node: mparser.BaseNode,
                 args: T.Tuple[str, T.List[T.Union[str, mesonlib.File, build.GeneratedTypes]]],
                 kwargs: kwtypes.Jar) -> build.Jar:
        return self.build_target(node, args, kwargs, build.Jar)

    @FeatureNewKwargs('build_target', '0.40.0', ['link_whole', 'override_options'])
    @permittedKwargs(known_build_target_kwargs)
    @typed_pos_args('build_target', str, varargs=SOURCES_VARARGS)
    @typed_kwargs('build_target', *BUILD_TARGET_KWS, allow_unknown=True)
    def func_build_target(self, node: mparser.BaseNode,
                          args: T.Tuple[str, SourcesVarargsType],
                          kwargs: kwtypes.BuildTarget
                          ) -> T.Union[build.Executable, build.StaticLibrary, build.SharedLibrary,
                                       build.SharedModule, build.BothLibraries, build.Jar]:
        target_type = kwargs['target_type']
        if target_type == 'executable':
            return self.build_target(node, args, kwargs, build.Executable)
        elif target_type == 'shared_library':
            return self.build_target(node, args, kwargs, build.SharedLibrary)
        elif target_type == 'shared_module':
            return self.build_target(node, args, kwargs, build.SharedModule)
        elif target_type == 'static_library':
            return self.build_target(node, args, kwargs, build.StaticLibrary)
        elif target_type == 'both_libraries':
            return self.build_both_libraries(node, args, kwargs)
        elif target_type == 'library':
            return self.build_library(node, args, kwargs)
        return self.build_target(node, args, kwargs, build.Jar)

    @noPosargs
    @typed_kwargs(
        'vcs_tag',
        CT_INPUT_KW.evolve(required
```
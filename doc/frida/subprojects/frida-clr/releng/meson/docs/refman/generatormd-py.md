Response:
Let's break down the thought process for analyzing this Python script.

**1. Initial Understanding - What is the script's purpose?**

The first lines are crucial: `# SPDX-License-Identifier: Apache-2.0` and `# Copyright 2021 The Meson development team`. This immediately tells us it's open-source and part of the Meson build system project. The filename `generatormd.py` and the directory structure `frida/subprojects/frida-clr/releng/meson/docs/refman/` strongly suggest it's responsible for generating Markdown documentation for the Frida CLR (Common Language Runtime) integration, specifically the "reference manual".

**2. Core Class Identification - The `GeneratorMD` Class:**

The core of the script is the `GeneratorMD` class, inheriting from `GeneratorBase`. This signifies a pattern: `GeneratorBase` likely provides common functionality for different documentation generators, and `GeneratorMD` specializes in generating Markdown.

**3. Key Data Structures and Models:**

The import statements under "from .model import ..." are vital. They tell us about the *data being processed*: `ReferenceManual`, `Function`, `Method`, `Object`, `ObjectType`, `Type`, `DataTypeInfo`, `ArgBase`, `PosArg`, `VarArgs`, `Kwarg`. These represent the structure of the documentation source. We can infer that the script reads this structured data and transforms it.

**4. File I/O and Templating:**

The `__init__` method reveals the input and output files/directories: `sitemap_out`, `sitemap_in`, `link_def_out`, and `out_dir`. This confirms the script's role in generating files. The methods `_write_file` and `_write_template` indicate the mechanisms for generating the output. The use of `chevron` for templating is a key detail.

**5. Markdown Generation Logic:**

Looking at methods like `_gen_filename`, `_gen_object_file_id`, `_link_to_object`, `_gen_func_or_method`, and `_write_object` reveals how the Markdown is structured and linked. The use of `[[...]]` as placeholder tags, later replaced by a "hotdoc plugin," is a significant piece of information. The meticulous formatting in `_gen_func_or_method` (handling arguments, signatures) points to generating detailed API documentation.

**6. Sitemap and Link Definitions:**

The methods `_configure_sitemap` and `_generate_link_def` explain how the generated Markdown files are organized and how links between them are managed. The sitemap ensures navigability, and the link definition file allows the "hotdoc plugin" to resolve the placeholders.

**7. Connections to Reverse Engineering, Binaries, Kernels, etc.:**

Now, we start connecting the dots to the specific questions in the prompt.

* **Reverse Engineering:** The script itself isn't *directly* performing reverse engineering. However, it's *documenting* the API of Frida, a dynamic instrumentation toolkit used *for* reverse engineering. The documentation makes Frida's capabilities accessible to those doing reverse engineering.

* **Binary/Low-Level:**  While the Python script is high-level, it's documenting tools that operate at a low level. Frida interacts with process memory, function calls, etc. The documentation generated by this script describes *how to use* Frida for these low-level tasks. The mention of CLR indicates interaction with a runtime environment that deals with compiled code.

* **Linux/Android Kernel/Framework:**  Frida is commonly used on Linux and Android. The documentation will likely describe how Frida interacts with processes and the operating system on these platforms. The CLR part points to Android's use of .NET technology in some contexts.

**8. Logical Inference and Examples:**

We look for places where the script makes decisions or transforms data. The `_gen_object_file_id` method, for example, creates a deterministic file ID based on the object's type and name. We can provide examples of input (an `Object` instance) and the resulting output (a file ID string).

**9. Common Usage Errors:**

We consider how a user might interact with this script or the broader documentation generation process. If the input data (`ReferenceManual`) is malformed or incomplete, the generated documentation might be incorrect or missing. Incorrectly configuring the sitemap paths could lead to broken links.

**10. Debugging Clues - How to Reach This Code:**

We trace the execution flow. A developer working on Frida documentation would likely run a Meson command to build the documentation. Meson, in turn, would execute this `generatormd.py` script as part of the documentation generation process. The file path itself is a strong clue about where this script fits within the project.

**Self-Correction/Refinement During the Process:**

* **Initial thought:** Maybe this script directly interacts with Frida's internals.
* **Correction:**  No, it's generating *documentation* about Frida. It processes a higher-level representation of Frida's API.
* **Initial thought:** Focus only on the Python code itself.
* **Correction:**  Consider the broader context of Frida and its use in reverse engineering.

By following these steps, we can systematically analyze the script, understand its purpose, and answer the specific questions in the prompt. The key is to move from the concrete (the Python code) to the abstract (its role in the larger system and its connection to reverse engineering and low-level concepts).
这个Python脚本 `generatormd.py` 的主要功能是 **为 Frida 动态 instrumentation 工具生成 Markdown 格式的参考手册文档**。它属于 Meson 构建系统的一部分，用于处理文档生成流程。

下面详细列举其功能，并结合你的问题进行分析：

**1. 功能概述:**

* **读取结构化数据:**  脚本接收一个 `ReferenceManual` 对象作为输入，这个对象包含了 Frida CLR API 的结构化信息，例如模块、类、方法、函数、参数、返回值等。这些信息可能来自其他地方（例如解析源代码或其他定义文件）。
* **生成 Markdown 文件:**  根据 `ReferenceManual` 中的数据，脚本生成一系列 Markdown (`.md`) 文件，每个文件对应 API 的一部分，例如一个模块、一个类或一组函数。
* **生成链接占位符:** 在生成的 Markdown 文件中使用特殊的占位符 (例如 `[[@ObjectName]]`, `[[FunctionName]]`) 来表示对其他 API 元素的引用。这些占位符在后续的文档处理步骤中会被替换为实际的链接。
* **生成站点地图 (Sitemap):**  脚本根据生成的 Markdown 文件结构生成一个站点地图文件，用于组织文档的层次结构和导航。
* **生成链接定义文件:**  脚本生成一个 JSON 格式的链接定义文件 (`link_def_out`)，这个文件映射了占位符 (例如 `@ObjectName`, `FunctionName`) 到对应的 Markdown 文件路径和锚点。这个文件会被一个自定义的 hotdoc 插件使用，用于将占位符替换为正确的 HTML 链接。
* **使用模板:**  脚本使用 Mustache 模板引擎来生成 Markdown 内容，这使得文档结构和内容分离，方便维护和修改。
* **处理不同类型的 API 元素:**  脚本能够处理不同类型的 API 元素，包括模块、内置对象、返回对象、函数和方法，并为它们生成相应的 Markdown 文档。

**2. 与逆向方法的联系 (举例说明):**

Frida 本身就是一个强大的逆向工程工具，用于动态分析和修改正在运行的进程。`generatormd.py` 生成的参考手册文档，正是为了帮助用户理解和使用 Frida 的 API，从而进行更有效的逆向操作。

**举例说明:**

假设你想使用 Frida hook 一个 Android 应用中的某个 Java 方法 `com.example.app.MainActivity.onCreate()`, 你需要查找 Frida 提供的相关 API。 通过 `generatormd.py` 生成的文档，你可能会找到以下信息：

* **`Java.use()` 函数:**  文档会详细描述 `Java.use()` 函数的用法，例如：
    ```markdown
    ### `Java.use(className)`
    ...
    **参数:**
    * `className` (字符串):  要使用的 Java 类的完整名称。
    ...
    ```
* **`Java.perform()` 函数:**  文档会说明 `Java.perform()` 的作用，例如：
    ```markdown
    ### `Java.perform(fn)`
    ...
    **参数:**
    * `fn` (函数):  要在 Java 虚拟机上下文中执行的函数。
    ...
    ```
* **`Method.implementation` 属性:** 文档会解释如何修改方法的实现，例如：
    ```markdown
    ### `Method.implementation`
    ...
    设置或获取方法的实现。可以设置为一个 JavaScript 函数。
    ...
    ```

结合这些文档信息，逆向工程师可以编写 Frida 脚本来 hook `onCreate()` 方法：

```javascript
Java.perform(function() {
  var MainActivity = Java.use('com.example.app.MainActivity');
  MainActivity.onCreate.implementation = function() {
    console.log("MainActivity.onCreate() is called!");
    this.onCreate(); // 调用原始的 onCreate() 方法
  };
});
```

**3. 涉及二进制底层、Linux、Android 内核及框架的知识 (举例说明):**

虽然 `generatormd.py` 本身是一个高层 Python 脚本，但它生成的文档描述的 Frida API 涉及到与底层系统交互的功能。

**举例说明:**

* **内存操作:** Frida 提供了诸如 `Process.getModuleByName()`, `Module.base`, `Module.size`, `Memory.read*()`, `Memory.write*()` 等 API，这些 API 允许用户访问和修改进程的内存空间。生成的文档会描述这些 API 的用法，这直接关联到二进制程序的内存布局和操作。
* **系统调用:** Frida 可以 hook 系统调用，例如 `Interceptor.attach()` 可以拦截对特定地址的调用，这通常用于分析程序与操作系统内核的交互。文档会描述如何使用 `Interceptor` API，这涉及到操作系统底层的系统调用机制。
* **Android 框架:** 对于 Frida 在 Android 上的应用，文档会描述与 Android Runtime (ART) 交互的 API，例如 `Java.use()`, `Java.perform()`, `Java.cast()`, 以及如何 hook Java 方法和类。这需要理解 Android 框架的结构和 Java 虚拟机的工作原理。
* **Linux 内核:**  Frida 在 Linux 上可以用于分析用户态程序和内核模块。文档中关于进程操作、内存操作、信号处理等 API 的描述，与 Linux 内核的相应概念密切相关。

**4. 逻辑推理 (假设输入与输出):**

脚本的主要逻辑在于将结构化的 API 数据转换为 Markdown 格式。

**假设输入:**  一个 `Function` 对象，表示 Frida 的一个函数 `send()`, 包含以下属性：

```python
Function(
    name='send',
    description='发送数据到 Frida 客户端。',
    returns=Type(names=['void']),
    posargs=[
        PosArg(name='data', type=Type(names=['any']), description='要发送的数据。'),
        PosArg(name='description', type=Type(names=['str']), description='数据的描述。', default=None)
    ]
)
```

**预期输出 (片段):**  生成的 Markdown 文件中关于 `send()` 函数的部分可能如下所示：

```markdown
### `send(data, [description])`

发送数据到 Frida 客户端。

**参数:**

* `data`: 要发送的数据。
* `description` (可选): 数据的描述。

```

**5. 涉及用户或编程常见的使用错误 (举例说明):**

由于 `generatormd.py` 是文档生成工具，它本身不太会产生用户直接的操作错误。但是，它生成的文档质量直接影响用户对 Frida API 的理解和使用，因此如果文档生成有误，就会导致用户在使用 Frida 时犯错。

**举例说明:**

* **参数类型错误:** 如果文档中 `send()` 函数的 `data` 参数类型被错误地标记为 `str` 而不是 `any`，用户可能会误以为只能发送字符串，导致尝试发送其他类型数据时出现错误。
* **遗漏重要信息:** 如果文档中没有说明 `send()` 函数的调用时机或限制，用户可能会在不恰当的时候调用，导致程序行为异常。
* **链接错误:** 如果生成的 Markdown 文件之间的链接占位符没有被正确替换，用户在阅读文档时可能会遇到断链，无法获取相关信息。

**6. 用户操作如何一步步到达这里 (调试线索):**

通常情况下，普通 Frida 用户不会直接运行 `generatormd.py`。这个脚本是 Frida 开发流程的一部分，用于生成官方文档。

**调试线索 (开发人员角度):**

1. **修改 Frida 源代码或文档定义文件:**  Frida 的开发人员可能会修改 Frida 的 C++ 源代码、Python 绑定代码或者定义 API 结构的元数据文件（这些文件会被解析成 `ReferenceManual` 对象）。
2. **运行 Meson 构建命令:**  为了更新文档，开发人员会运行 Meson 提供的构建命令，例如 `meson compile -C builddir` 或类似的命令。
3. **Meson 执行文档生成步骤:** Meson 的配置文件（通常是 `meson.build`）会定义文档生成的步骤，其中就包括执行 `generatormd.py` 脚本。
4. **`generatormd.py` 被调用:**  Meson 会根据配置调用 `generatormd.py`，并将 `ReferenceManual` 对象以及其他必要的参数传递给它。
5. **脚本生成 Markdown 文件:**  `generatormd.py` 读取 `ReferenceManual` 数据，并按照模板生成 Markdown 文件。
6. **后续文档处理:**  生成的 Markdown 文件会被进一步处理，例如使用 hotdoc 插件替换链接占位符，生成最终的 HTML 文档。

因此，要调试 `generatormd.py`，开发人员需要了解 Frida 的文档生成流程，并从修改源代码或文档定义文件开始，跟踪构建系统的执行过程。查看 Meson 的构建日志可以帮助定位问题是否出在 `generatormd.py` 脚本的执行过程中。

Prompt: 
```
这是目录为frida/subprojects/frida-clr/releng/meson/docs/refman/generatormd.py的fridaDynamic instrumentation tool的源代码文件， 请列举一下它的功能, 
如果它与逆向的方法有关系，请做出对应的举例说明，
如果涉及到二进制底层，linux, android内核及框架的知识，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索。

"""
# SPDX-License-Identifier: Apache-2.0
# Copyright 2021 The Meson development team

from .generatorbase import GeneratorBase
import re
import json

from .model import (
    ReferenceManual,
    Function,
    Method,
    Object,
    ObjectType,
    Type,
    DataTypeInfo,
    ArgBase,
    PosArg,
    VarArgs,
    Kwarg,
)

from pathlib import Path
from textwrap import dedent
import typing as T

from mesonbuild import mlog

PlaceholderTypes = T.Union[None, str, bool]
FunctionDictType = T.Dict[
    str,
    T.Union[
        PlaceholderTypes,
        T.Dict[str, PlaceholderTypes],
        T.Dict[str, T.Dict[str, PlaceholderTypes]],
        T.Dict[str, T.List[T.Dict[str, PlaceholderTypes]]],
        T.List[T.Dict[str, PlaceholderTypes]],
        T.List[str],
    ]
]

_ROOT_BASENAME = 'Reference-manual'

_OBJ_ID_MAP = {
    ObjectType.ELEMENTARY: 'elementary',
    ObjectType.BUILTIN: 'builtin',
    ObjectType.MODULE: 'module',
    ObjectType.RETURNED: 'returned',
}

# Indent all but the first line with 4*depth spaces.
# This function is designed to be used with `dedent`
# and fstrings where multiline strings are used during
# the string interpolation.
def smart_indent(raw: str, depth: int = 3) -> str:
    lines = raw.split('\n')
    first_line = lines[0]
    lines = [' ' * (4 * depth) + x for x in lines]
    lines[0] = first_line  # Do not indent the first line
    return '\n'.join(lines)

def code_block(code: str) -> str:
    code = dedent(code)
    return f'<pre><code class="language-meson">{code}</code></pre>'

class GeneratorMD(GeneratorBase):
    def __init__(self, manual: ReferenceManual, sitemap_out: Path, sitemap_in: Path, link_def_out: Path, enable_modules: bool) -> None:
        super().__init__(manual)
        self.sitemap_out = sitemap_out.resolve()
        self.sitemap_in = sitemap_in.resolve()
        self.link_def_out = link_def_out.resolve()
        self.out_dir = self.sitemap_out.parent
        self.enable_modules = enable_modules
        self.generated_files: T.Dict[str, str] = {}

    # Utility functions
    def _gen_filename(self, file_id: str, *, extension: str = 'md') -> str:
        parts = file_id.split('.')
        assert parts[0] == 'root'
        assert all([x for x in parts])
        parts[0] = _ROOT_BASENAME
        parts = [re.sub(r'[0-9]+_', '', x) for x in parts]
        return f'{"_".join(parts)}.{extension}'

    def _gen_object_file_id(self, obj: Object) -> str:
        '''
            Deterministically generate a unique file ID for the Object.

            This ID determines where the object will be inserted in the sitemap.
        '''
        if obj.obj_type == ObjectType.RETURNED and obj.defined_by_module is not None:
            base = self._gen_object_file_id(obj.defined_by_module)
            return f'{base}.{obj.name}'
        return f'root.{_OBJ_ID_MAP[obj.obj_type]}.{obj.name}'

    def _link_to_object(self, obj: T.Union[Function, Object], in_code_block: bool = False) -> str:
        '''
            Generate a palaceholder tag for the function/method/object documentation.
            This tag is then replaced in the custom hotdoc plugin.
        '''
        prefix = '#' if in_code_block else ''
        if isinstance(obj, Object):
            return f'[[{prefix}@{obj.name}]]'
        elif isinstance(obj, Method):
            return f'[[{prefix}{obj.obj.name}.{obj.name}]]'
        elif isinstance(obj, Function):
            return f'[[{prefix}{obj.name}]]'
        else:
            raise RuntimeError(f'Invalid argument {obj}')

    def _write_file(self, data: str, file_id: str) -> None:#
        ''' Write the data to disk and store the id for the generated data '''

        self.generated_files[file_id] = self._gen_filename(file_id)
        out_file = self.out_dir / self.generated_files[file_id]
        out_file.write_text(data, encoding='ascii')
        mlog.log('Generated', mlog.bold(out_file.name))

    def _write_template(self, data: T.Dict[str, T.Any], file_id: str, template_name: T.Optional[str] = None) -> None:
        ''' Render the template mustache files and write the result '''
        template_dir = Path(__file__).resolve().parent / 'templates'
        template_name = template_name or file_id
        template_name = f'{template_name}.mustache'
        template_file = template_dir / template_name

        # Import here, so that other generators don't also depend on it
        import chevron
        result = chevron.render(
            template=template_file.read_text(encoding='utf-8'),
            data=data,
            partials_path=template_dir.as_posix(),
            warn=True,
        )

        self._write_file(result, file_id)


    # Actual generator functions
    def _gen_func_or_method(self, func: Function) -> FunctionDictType:
        def render_type(typ: Type, in_code_block: bool = False) -> str:
            def data_type_to_str(dt: DataTypeInfo) -> str:
                base = self._link_to_object(dt.data_type, in_code_block)
                if dt.holds:
                    return f'{base}[{render_type(dt.holds, in_code_block)}]'
                return base
            assert typ.resolved
            return ' | '.join([data_type_to_str(x) for x in typ.resolved])

        def len_stripped(s: str) -> int:
            s = s.replace(']]', '')
            # I know, this regex is ugly but it works.
            return len(re.sub(r'\[\[(#|@)*([^\[])', r'\2', s))

        def arg_anchor(arg: ArgBase) -> str:
            return f'{func.name}_{arg.name.replace("<", "_").replace(">", "_")}'

        def render_signature() -> str:
            # Skip a lot of computations if the function does not take any arguments
            if not any([func.posargs, func.optargs, func.kwargs, func.varargs]):
                return f'{render_type(func.returns, True)} {func.name}()'

            signature = dedent(f'''\
                # {self.brief(func)}
                {render_type(func.returns, True)} {func.name}(
            ''')

            # Calculate maximum lengths of the type and name
            all_args: T.List[ArgBase] = []
            all_args += func.posargs
            all_args += func.optargs
            all_args += [func.varargs] if func.varargs else []

            max_type_len = 0
            max_name_len = 0
            if all_args:
                max_type_len = max([len_stripped(render_type(x.type)) for x in all_args])
                max_name_len = max([len(x.name) for x in all_args])

            # Generate some common strings
            def prepare(arg: ArgBase, link: bool = True) -> T.Tuple[str, str, str, str]:
                type_str = render_type(arg.type, True)
                type_len = len_stripped(type_str)
                type_space = ' ' * (max_type_len - type_len)
                name_space = ' ' * (max_name_len - len(arg.name))
                name_str = f'<b>{arg.name.replace("<", "&lt;").replace(">", "&gt;")}</b>'
                if link:
                    name_str = f'<a href="#{arg_anchor(arg)}">{name_str}</a>'

                return type_str, type_space, name_str, name_space

            for i in func.posargs:
                type_str, type_space, name_str, name_space = prepare(i)
                signature += f'  {type_str}{type_space} {name_str},{name_space}     # {self.brief(i)}\n'

            for i in func.optargs:
                type_str, type_space, name_str, name_space = prepare(i)
                signature += f'  {type_str}{type_space} [{name_str}],{name_space}   # {self.brief(i)}\n'

            if func.varargs:
                type_str, type_space, name_str, name_space = prepare(func.varargs, link=False)
                signature += f'  {type_str}{type_space} {name_str}...,{name_space}  # {self.brief(func.varargs)}\n'

            # Abort if there are no kwargs
            if not func.kwargs:
                return signature + ')'

            # Only add this separator if there are any posargs
            if all_args:
                signature += '\n  # Keyword arguments:\n'

            # Recalculate lengths for kwargs
            all_args = list(func.kwargs.values())
            max_type_len = max([len_stripped(render_type(x.type)) for x in all_args])
            max_name_len = max([len(x.name) for x in all_args])

            for kwarg in self.sorted_and_filtered(list(func.kwargs.values())):
                type_str, type_space, name_str, name_space = prepare(kwarg)
                required = ' <i>[required]</i> ' if kwarg.required else '            '
                required = required if any([x.required for x in func.kwargs.values()]) else ''
                signature += f'  {name_str}{name_space} : {type_str}{type_space} {required} # {self.brief(kwarg)}\n'

            return signature + ')'

        def gen_arg_data(arg: T.Union[PosArg, Kwarg, VarArgs], *, optional: bool = False) -> T.Dict[str, PlaceholderTypes]:
            data: T.Dict[str, PlaceholderTypes] = {
                'row-id': arg_anchor(arg),
                'name': arg.name,
                'type': render_type(arg.type),
                'description': arg.description,
                'since': arg.since or None,
                'deprecated': arg.deprecated or None,
                'optional': optional,
                'default': None,
            }

            if isinstance(arg, VarArgs):
                data.update({
                    'min': str(arg.min_varargs) if arg.min_varargs > 0 else '0',
                    'max': str(arg.max_varargs) if arg.max_varargs > 0 else 'infinity',
                })
            if isinstance(arg, (Kwarg, PosArg)):
                data.update({'default': arg.default or None})
            if isinstance(arg, Kwarg):
                data.update({'required': arg.required})
            return data

        mname = f'\\{func.name}' if func.name == '[index]' else func.name

        data: FunctionDictType = {
            'name': f'{func.obj.name}.{mname}' if isinstance(func, Method) else func.name,
            'base_level': '##' if isinstance(func, Method) else '#',
            'type_name_upper': 'Method' if isinstance(func, Method) else 'Function',
            'type_name': 'method' if isinstance(func, Method) else 'function',
            'description': func.description,
            'notes': func.notes,
            'warnings': func.warnings,
            'example': func.example or None,
            'signature_level': 'h4' if isinstance(func, Method) else 'h3',
            'signature': render_signature(),
            'has_args': bool(func.posargs or func.optargs or func.kwargs or func.varargs),
            # Merge posargs and optargs by generating the *[optional]* tag for optargs
            'posargs': {
                'args': [gen_arg_data(x) for x in func.posargs] + [gen_arg_data(x, optional=True) for x in func.optargs]
            } if func.posargs or func.optargs else None,
            'kwargs':  {'args': [gen_arg_data(x) for x in self.sorted_and_filtered(list(func.kwargs.values()))]} if func.kwargs else None,
            'varargs': gen_arg_data(func.varargs) if func.varargs else None,
            'arg_flattening': func.arg_flattening,

            # For the feature taggs template
            'since': func.since or None,
            'deprecated': func.deprecated or None,
            'optional': False,
            'default': None
        }

        return data

    def _write_object(self, obj: Object) -> None:
        data = {
            'name': obj.name,
            'title': obj.long_name if obj.obj_type == ObjectType.RETURNED else obj.name,
            'description': obj.description,
            'notes': obj.notes,
            'warnings': obj.warnings,
            'long_name': obj.long_name,
            'obj_type_name': _OBJ_ID_MAP[obj.obj_type].capitalize(),
            'example': obj.example or None,
            'has_methods': bool(obj.methods),
            'has_inherited_methods': bool(obj.inherited_methods),
            'has_subclasses': bool(obj.extended_by),
            'is_returned': bool(obj.returned_by),
            'extends': obj.extends_obj.name if obj.extends_obj else None,
            'returned_by': [self._link_to_object(x) for x in self.sorted_and_filtered(obj.returned_by)],
            'extended_by': [self._link_to_object(x) for x in self.sorted_and_filtered(obj.extended_by)],
            'methods': [self._gen_func_or_method(m) for m in self.sorted_and_filtered(obj.methods)],
            'inherited_methods': [self._gen_func_or_method(m) for m in self.sorted_and_filtered(obj.inherited_methods)],
        }

        self._write_template(data, self._gen_object_file_id(obj), 'object')

    def _write_functions(self) -> None:
        data = {'functions': [self._gen_func_or_method(x) for x in self.functions]}
        self._write_template(data, 'root.functions')

    def _root_refman_docs(self) -> None:
        def gen_obj_links(objs: T.List[Object]) -> T.List[T.Dict[str, str]]:
            ret: T.List[T.Dict[str, str]] = []
            for o in objs:
                ret += [{'indent': '', 'link': self._link_to_object(o), 'brief': self.brief(o)}]
                for m in self.sorted_and_filtered(o.methods):
                    ret += [{'indent': '  ', 'link': self._link_to_object(m), 'brief': self.brief(m)}]
                if o.obj_type == ObjectType.MODULE and self.extract_returned_by_module(o):
                    tmp = gen_obj_links(self.extract_returned_by_module(o))
                    tmp = [{**x, 'indent': '  ' + x['indent']} for x in tmp]
                    ret += [{'indent': '  ', 'link': '**New objects:**', 'brief': ''}]
                    ret += [*tmp]
            return ret

        data = {
            'root': self._gen_filename('root'),
            'elementary': gen_obj_links(self.elementary),
            'returned': gen_obj_links(self.returned),
            'builtins': gen_obj_links(self.builtins),
            'modules': gen_obj_links(self.modules),
            'functions': [{'indent': '', 'link': self._link_to_object(x), 'brief': self.brief(x)} for x in self.functions],
            'enable_modules': self.enable_modules,
        }

        dummy = {'root': self._gen_filename('root')}

        self._write_template(data, 'root')
        self._write_template({**dummy, 'name': 'Elementary types'}, f'root.{_OBJ_ID_MAP[ObjectType.ELEMENTARY]}', 'dummy')
        self._write_template({**dummy, 'name': 'Builtin objects'},  f'root.{_OBJ_ID_MAP[ObjectType.BUILTIN]}',    'dummy')
        self._write_template({**dummy, 'name': 'Returned objects'}, f'root.{_OBJ_ID_MAP[ObjectType.RETURNED]}',   'dummy')

        if self.enable_modules:
            self._write_template({**dummy, 'name': 'Modules'},          f'root.{_OBJ_ID_MAP[ObjectType.MODULE]}',     'dummy')


    def generate(self) -> None:
        mlog.log('Generating markdown files...')
        with mlog.nested():
            self._write_functions()
            for obj in self.objects:
                if not self.enable_modules and (obj.obj_type == ObjectType.MODULE or obj.defined_by_module is not None):
                    continue
                self._write_object(obj)
            self._root_refman_docs()
            self._configure_sitemap()
            self._generate_link_def()

    def _configure_sitemap(self) -> None:
        '''
            Replaces the `@REFMAN_PLACEHOLDER@` placeholder with the reference
            manual sitemap. The structure of the sitemap is derived from the
            file IDs.
        '''
        raw = self.sitemap_in.read_text(encoding='utf-8')
        out = ''
        for l in raw.split('\n'):
            if '@REFMAN_PLACEHOLDER@' not in l:
                out += f'{l}\n'
                continue
            mlog.log('Generating', mlog.bold(self.sitemap_out.as_posix()))
            base_indent = l.replace('@REFMAN_PLACEHOLDER@', '')
            for k in sorted(self.generated_files.keys()):
                indent = base_indent + '\t' * k.count('.')
                out += f'{indent}{self.generated_files[k]}\n'
        self.sitemap_out.write_text(out, encoding='utf-8')

    def _generate_link_def(self) -> None:
        '''
            Generate the link definition file for the refman_links hotdoc
            plugin. The plugin is then responsible for replacing the [[tag]]
            tags with custom HTML elements.
        '''
        data: T.Dict[str, str] = {}

        # Objects and methods
        for obj in self.objects:
            obj_file = self._gen_filename(self._gen_object_file_id(obj), extension='html')
            data[f'@{obj.name}'] = obj_file
            for m in obj.methods:
                data[f'{obj.name}.{m.name}'] = f'{obj_file}#{obj.name}{m.name}'

        # Functions
        funcs_file = self._gen_filename('root.functions', extension='html')
        for fn in self.functions:
            data[fn.name] = f'{funcs_file}#{fn.name}'

        self.link_def_out.write_text(json.dumps(data, indent=2), encoding='utf-8')

"""

```
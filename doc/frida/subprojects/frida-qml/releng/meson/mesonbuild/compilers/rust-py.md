Response:
Let's break down the thought process for analyzing the Python code provided.

**1. Understanding the Goal:**

The primary goal is to analyze the given Python code (a module for a Rust compiler within the Meson build system) and explain its functionalities in the context of reverse engineering, low-level operations, and potential user errors, along with tracing how a user might end up using this code.

**2. Initial Code Scan and High-Level Understanding:**

The first step is to read through the code to grasp its overall purpose. Keywords like "RustCompiler," "compilers," "linker," "optimization," "debug," and "sanity_check" immediately suggest that this code defines how the Meson build system interacts with the Rust compiler (`rustc`). The presence of `ClippyRustCompiler` suggests support for the Clippy linter.

**3. Deeper Dive into Functionalities:**

Now, go through the code function by function, paying attention to what each function does.

* **`RustCompiler` class:**  This is the core class. Identify its methods and their roles. Constructor (`__init__`), sanity checks (`sanity_check`), getting compiler flags (`get_debug_args`, `get_optimization_args`, `get_output_args`, etc.), dependency handling (`get_dependency_gen_args`, `get_dependency_compile_args`), and option handling (`get_options`, `get_option_compile_args`). Notice the interaction with the `Popen_safe_logged` function, indicating the execution of external commands.

* **`ClippyRustCompiler` class:** This seems like a specialized version, inheriting from `RustCompiler`, primarily for identification purposes.

**4. Connecting to Reverse Engineering:**

Think about how the actions performed by this code relate to reverse engineering.

* **Compilation process:**  Reverse engineers often need to compile code (or understand how it's compiled) to analyze it. The flags generated by this code (`-g` for debug symbols, optimization levels) directly impact the resulting binary, which is a prime target for reverse engineering.
* **Linking:** Understanding linking is crucial. The code mentions static libraries and how Rust interacts with C/C++ linkers. This is relevant because reverse engineers need to understand how different parts of a binary are combined.
* **Debugging information:** The `get_debug_args` function is a direct link. Debug symbols are invaluable for reverse engineering.

**5. Identifying Low-Level/Kernel/Framework Connections:**

Look for mentions of concepts that touch the low level.

* **Sysroot:** This points to the base directory for system libraries, a core concept in OS development and understanding how programs interact with the system.
* **Static vs. Dynamic Linking:** The code explicitly deals with static libraries (`native_static_libs`) and how Rust interfaces with C/C++ dynamic linking.
* **PIC/PIE:** These are security features related to memory layout, crucial for understanding binary security and exploitation, often explored in reverse engineering.
* **`crt-static`:**  This refers to the C runtime library linking, a fundamental concept in system programming.
* **Machine Choice (cross-compilation):** The code handles cross-compilation, a scenario where you compile code for a different architecture, which is relevant in reverse engineering of embedded systems or mobile devices.

**6. Logical Reasoning (Hypothetical Inputs/Outputs):**

Consider the flow of data. What inputs would lead to specific outputs?

* **Optimization Levels:**  If the user selects `-Db_optimize=2`, the `get_optimization_args` function will return `['-C', 'opt-level=2']`.
* **Debug Mode:** If `-Db_debug=true`, `get_debug_args` will return `['-g']`.
* **Target Architecture:**  While not explicitly shown in this snippet, the `for_machine` parameter hints at how this code could be used for cross-compilation (e.g., compiling for Android from a Linux host).

**7. Common User Errors:**

Think about how a user might misuse the system or make mistakes that relate to this code.

* **Incorrect Optimization/Debug Settings:**  Users might compile in release mode when they need debug symbols for reverse engineering.
* **Missing Dependencies:** Although this code doesn't directly handle dependency *resolution*, the fact that it generates linker flags suggests that users could encounter linking errors if dependencies are missing.
* **Incorrect `b_vscrt` setting:** This is specific to Windows and could lead to runtime errors if the wrong C runtime library is selected.

**8. Tracing User Actions:**

Imagine a user trying to build a Frida module. How do they get here?

* **Using the `meson` command:**  The user initiates the build process with `meson setup builddir`.
* **Meson configuration:** Meson reads `meson.build` files, which likely specify that the project uses Rust.
* **Compiler selection:** Meson identifies `rustc` as the compiler.
* **Invoking compiler modules:** Meson then uses the `rust.py` module to generate the correct commands for `rustc`.
* **Configuration options:** The user might have set options like debug mode or optimization level, influencing the flags generated by this code.

**9. Structuring the Output:**

Finally, organize the findings into the requested categories: functionalities, relation to reverse engineering, low-level details, logical reasoning, user errors, and debugging clues. Use clear and concise language, providing specific examples where possible. Use markdown formatting for readability.

**Self-Correction/Refinement during the process:**

* **Initial thought:** "This is just about compiling Rust code."
* **Correction:** "No, it's about *how* Meson handles the Rust compiler, which involves more than just a simple compilation. It handles linking, dependencies, and various build options."
* **Initial thought:**  "The user doesn't directly interact with this Python file."
* **Correction:** "While not directly, their build configuration and command-line options *indirectly* trigger the execution of this code."

By following this structured approach, you can effectively analyze the code and extract the relevant information to answer the prompt comprehensively.
这个 Python 源代码文件 `rust.py` 是 Frida 动态 instrumentation工具中，Meson 构建系统中用于处理 Rust 语言编译器的模块。它定义了如何使用 Rust 编译器 (`rustc`) 来构建 Frida 的 QML 组件。

让我们分解一下它的功能以及与你提出的几个方面的关联：

**主要功能:**

1. **定义 Rust 编译器类 (`RustCompiler`):**  这个类封装了与 Rust 编译器交互所需的所有信息和方法。
    * **编译器标识 (`id`):**  明确标识这是一个 Rust 编译器 (`rustc`).
    * **语言 (`language`):**  指定该编译器处理的语言是 Rust。
    * **可执行文件列表 (`exelist`):**  存储 Rust 编译器的可执行文件路径。
    * **版本信息 (`version`, `full_version`):**  保存 Rust 编译器的版本信息。
    * **支持的选项 (`base_options`):**  列出该编译器支持的基本构建选项，例如颜色输出 (`b_colorout`) 和禁用调试断言 (`b_ndebug`).
    * **MSVCRT 参数 (`MSVCRT_ARGS`):**  定义了在 Windows 平台上链接时，根据不同的 C 运行时库 (MSVCRT) 版本需要添加的链接参数。
    * **优化级别参数 (`rust_optimization_args`):**  定义了不同优化级别对应的 Rust 编译器参数 (`-C opt-level=...`).
    * **警告级别参数 (`_WARNING_LEVELS`):**  定义了不同警告级别对应的 Rust 编译器参数。

2. **提供与构建系统交互的方法:**
    * **`sanity_check()`:**  执行基本的健全性检查，确保 Rust 编译器可以正常工作，能够编译和运行简单的程序。
    * **`needs_static_linker()`:**  指示 Rust 编译器是否需要静态链接器 (通常为 False，因为 `rustc` 本身处理链接)。
    * **`get_dependency_gen_args()`:**  返回生成依赖关系文件的命令行参数 (`--dep-info`).
    * **`get_sysroot()`:**  获取 Rust 工具链的 sysroot 路径。
    * **`get_crt_static()`:**  检查是否使用了静态链接的 C 运行时库。
    * **`get_debug_args()`:**  返回用于生成调试信息的命令行参数 (`-g`).
    * **`get_optimization_args()`:**  根据优化级别返回相应的命令行参数。
    * **`get_output_args()`:**  返回指定输出文件名的命令行参数 (`-o`).
    * **`use_linker_args()`:**  返回指定链接器的命令行参数 (`-C linker=...`).
    * **`get_options()`:**  返回该编译器支持的用户可配置选项，例如 Rust 的 edition 版本。
    * **`get_dependency_compile_args()`:**  返回处理依赖项编译所需的参数 (Rust 通常通过链接器标志处理依赖，所以这里返回空列表)。
    * **`get_option_compile_args()`:**  返回根据用户选项生成的编译参数，例如选择 Rust edition (`--edition=...`).
    * **`get_crt_compile_args()`/`get_crt_link_args()`:**  返回与 C 运行时库相关的编译和链接参数。
    * **`get_colorout_args()`:**  返回控制颜色输出的命令行参数 (`--color=...`).
    * **`get_linker_always_args()`:**  返回始终传递给链接器的参数。
    * **`get_werror_args()`:**  返回将所有警告视为错误的命令行参数 (`-D warnings`).
    * **`get_warn_args()`:**  返回设置警告级别的命令行参数.
    * **`get_pic_args()`/`get_pie_args()`:**  返回与位置无关代码 (PIC) 和位置无关可执行文件 (PIE) 相关的命令行参数。
    * **`get_assert_args()`:**  返回控制断言和溢出检查的命令行参数。

3. **定义 Clippy Rust 编译器类 (`ClippyRustCompiler`):**  这个类继承自 `RustCompiler`，用于指定使用 `clippy-driver` 这个 Rust 代码静态分析工具。

**与逆向方法的关系:**

* **编译选项对逆向的影响:**  该文件生成的编译选项直接影响最终生成的可执行文件或库。例如：
    * **调试信息 (`-g`):**  如果启用了调试信息，逆向工程师可以使用调试器 (如 GDB 或 LLDB) 来单步执行代码、查看变量值，大大方便了逆向分析。
    * **优化级别 (`-C opt-level=...`):**  不同的优化级别会改变代码的结构和执行流程。高优化级别可能会使代码更加难以理解，因为编译器会进行各种内联、循环展开等优化。逆向工程师可能需要理解这些优化才能还原代码的逻辑。
    * **位置无关代码 (`-C relocation-model=pic`):**  生成 PIC 的代码可以加载到内存的任意位置，这在动态库和某些安全上下文中非常重要。理解 PIC 的机制对于逆向分析动态库至关重要。
    * **禁用断言 (`-C debug-assertions=no`):**  在 release 版本中通常会禁用断言。如果逆向目标是 release 版本，可能无法依赖断言来理解代码的预期行为。

* **示例:** 假设逆向工程师想要分析 Frida 如何处理某个特定的 Rust 组件。他们可能会尝试修改构建配置，强制启用调试信息 (`-Db_debug=true`)，然后重新编译 Frida。这将使得他们可以使用调试器来跟踪 Frida 代码的执行，观察 Rust 组件的内部状态。

**涉及二进制底层、Linux、Android 内核及框架的知识:**

* **二进制底层:**
    * **链接器 (`-C linker=...`):**  该文件允许指定使用的链接器，链接器负责将编译后的目标文件组合成最终的可执行文件或库。不同的链接器 (如 `lld`, `gold`) 可能有不同的行为和优化策略，理解链接过程是理解二进制文件结构的基础。
    * **C 运行时库 (MSVCRT):**  在 Windows 上，程序通常依赖于 C 运行时库。该文件处理了选择合适的 MSVCRT 版本，这关系到二进制文件的兼容性和运行环境。
    * **静态库和动态库:**  `native_static_libs` 属性表明 Rust 代码可能需要链接一些操作系统的原生静态库。理解静态链接和动态链接的区别对于理解程序的依赖关系至关重要。

* **Linux:**
    * **Sysroot:** `get_sysroot()` 获取的 sysroot 路径指向 Linux 系统库的根目录。理解 sysroot 对于交叉编译和理解程序如何与操作系统交互非常重要。
    * **PIC/PIE:**  PIC 和 PIE 是 Linux 上常用的安全特性，用于防止地址空间布局随机化 (ASLR) 被绕过。该文件处理了相关的编译选项。

* **Android 内核及框架:**
    * **交叉编译 (`for_machine`):**  Frida 经常用于 Android 平台的逆向和动态分析。该文件中的 `for_machine` 参数表明 Meson 可以使用这个模块来为不同的目标平台 (包括 Android) 编译 Rust 代码。
    * **动态链接:**  Android 应用和 Frida Agent 通常以动态库的形式加载。理解 Android 的动态链接机制对于理解 Frida 如何注入到目标进程至关重要。

**逻辑推理 (假设输入与输出):**

* **假设输入:** 用户在 Meson 构建配置中设置了优化级别为 2 (`-Db_optimize=2`).
* **输出:** `get_optimization_args('2')` 方法将返回 `['-C', 'opt-level=2']`. Rust 编译器在编译时将会应用二级优化。

* **假设输入:** 用户在 Meson 构建配置中启用了调试信息 (`-Db_debug=true`).
* **输出:** `get_debug_args(True)` 方法将返回 `['-g']`. Rust 编译器在编译时将会生成调试符号。

* **假设输入:** 目标平台是 Windows，且用户指定使用动态链接的调试版 C 运行时库 (`-Db_vscrt=mdd`).
* **输出:** `get_crt_link_args('mdd', ...)` 方法将返回 `['-l', 'dylib=msvcrtd']`. 链接器将会链接 `msvcrtd.dll`。

**涉及用户或者编程常见的使用错误:**

* **C 运行时库不匹配 (Windows):**  如果用户在 Windows 上使用了错误的 `-Db_vscrt` 值，例如，编译时使用了 `mtd` (静态链接的 release 版本)，但程序依赖于动态链接的调试版本，可能会导致运行时错误。
* **缺少依赖:** 如果 Rust 代码依赖于某些外部 C 库，但这些库没有正确安装或链接，编译过程可能会失败。虽然这个文件本身不直接处理依赖查找，但它生成的链接器参数会影响链接结果。
* **Rust Edition 不兼容:** 如果用户尝试使用与项目代码不兼容的 Rust Edition 进行编译，可能会遇到编译错误。例如，尝试使用 2015 Edition 编译使用了 2021 Edition 特性的代码。

**说明用户操作是如何一步步的到达这里，作为调试线索:**

1. **用户尝试构建 Frida:** 用户在 Frida 项目的根目录下执行 `meson setup build` (或者其他类似的 Meson 构建命令)。
2. **Meson 解析构建文件:** Meson 读取 `meson.build` 文件，该文件定义了项目的构建规则，包括使用的编译器。
3. **识别 Rust 组件:** Meson 发现需要编译 Rust 代码（例如，位于 `frida/subprojects/frida-qml`）。
4. **查找 Rust 编译器处理模块:** Meson 根据语言类型 (Rust) 查找对应的编译器处理模块，找到了 `frida/subprojects/frida-qml/releng/meson/mesonbuild/compilers/rust.py`。
5. **实例化 `RustCompiler`:** Meson 会根据用户的配置和系统环境，实例化 `RustCompiler` 类，传入 Rust 编译器的路径、版本等信息。
6. **调用 `RustCompiler` 的方法:** 在编译过程中，Meson 会调用 `RustCompiler` 的各种方法，例如：
    * `sanity_check()` 来确保编译器可用。
    * `get_option_compile_args()` 获取用户配置的编译选项。
    * `get_output_args()` 获取输出文件名。
    * `get_debug_args()` 或 `get_optimization_args()` 获取调试或优化相关的编译参数。
7. **生成 `rustc` 命令:**  Meson 最终会根据 `RustCompiler` 返回的参数，构建出完整的 `rustc` 命令行，并执行该命令来编译 Rust 代码。

**作为调试线索:**

如果用户在构建 Frida 的过程中遇到与 Rust 编译相关的问题，例如编译错误、链接错误等，他们可以：

* **查看 Meson 的构建日志:**  日志中会包含 Meson 执行的 `rustc` 命令，可以检查生成的编译参数是否正确。
* **检查 Meson 的配置:**  确认用户设置的构建选项 (例如调试模式、优化级别、目标平台) 是否与预期一致。
* **检查 Rust 编译器的版本:**  有时问题可能与 Rust 编译器本身的版本有关。
* **查看 `rust.py` 的代码:**  理解 `rust.py` 中各个方法的功能，可以帮助分析 Meson 是如何生成 `rustc` 命令的，从而定位问题所在。例如，如果链接时缺少某个库，可能需要检查 `get_linker_always_args()` 或其他与链接相关的代码。

总而言之，`rust.py` 文件在 Frida 的构建过程中扮演着关键角色，它定义了 Meson 如何与 Rust 编译器进行交互，并根据用户的配置和目标平台生成相应的编译和链接参数。理解这个文件的功能对于调试 Frida 的构建问题以及深入理解 Frida 的构建流程都非常有帮助。

Prompt: 
```
这是目录为frida/subprojects/frida-qml/releng/meson/mesonbuild/compilers/rust.py的fridaDynamic instrumentation tool的源代码文件， 请列举一下它的功能, 
如果它与逆向的方法有关系，请做出对应的举例说明，
如果涉及到二进制底层，linux, android内核及框架的知识，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索。

"""
# SPDX-License-Identifier: Apache-2.0
# Copyright 2012-2022 The Meson development team

from __future__ import annotations

import functools
import subprocess, os.path
import textwrap
import re
import typing as T

from .. import coredata
from ..mesonlib import EnvironmentException, MesonException, Popen_safe_logged, OptionKey
from .compilers import Compiler, clike_debug_args

if T.TYPE_CHECKING:
    from ..coredata import MutableKeyedOptionDictType, KeyedOptionDictType
    from ..envconfig import MachineInfo
    from ..environment import Environment  # noqa: F401
    from ..linkers.linkers import DynamicLinker
    from ..mesonlib import MachineChoice
    from ..dependencies import Dependency


rust_optimization_args: T.Dict[str, T.List[str]] = {
    'plain': [],
    '0': [],
    'g': ['-C', 'opt-level=0'],
    '1': ['-C', 'opt-level=1'],
    '2': ['-C', 'opt-level=2'],
    '3': ['-C', 'opt-level=3'],
    's': ['-C', 'opt-level=s'],
}

class RustCompiler(Compiler):

    # rustc doesn't invoke the compiler itself, it doesn't need a LINKER_PREFIX
    language = 'rust'
    id = 'rustc'

    _WARNING_LEVELS: T.Dict[str, T.List[str]] = {
        '0': ['-A', 'warnings'],
        '1': [],
        '2': [],
        '3': ['-W', 'warnings'],
    }

    # Those are static libraries, but we use dylib= here as workaround to avoid
    # rust --tests to use /WHOLEARCHIVE.
    # https://github.com/rust-lang/rust/issues/116910
    MSVCRT_ARGS: T.Mapping[str, T.List[str]] = {
        'none': [],
        'md': [], # this is the default, no need to inject anything
        'mdd': ['-l', 'dylib=msvcrtd'],
        'mt': ['-l', 'dylib=libcmt'],
        'mtd': ['-l', 'dylib=libcmtd'],
    }

    def __init__(self, exelist: T.List[str], version: str, for_machine: MachineChoice,
                 is_cross: bool, info: 'MachineInfo',
                 full_version: T.Optional[str] = None,
                 linker: T.Optional['DynamicLinker'] = None):
        super().__init__([], exelist, version, for_machine, info,
                         is_cross=is_cross, full_version=full_version,
                         linker=linker)
        self.base_options.update({OptionKey(o) for o in ['b_colorout', 'b_ndebug']})
        if 'link' in self.linker.id:
            self.base_options.add(OptionKey('b_vscrt'))
        self.native_static_libs: T.List[str] = []

    def needs_static_linker(self) -> bool:
        return False

    def sanity_check(self, work_dir: str, environment: 'Environment') -> None:
        source_name = os.path.join(work_dir, 'sanity.rs')
        output_name = os.path.join(work_dir, 'rusttest')
        with open(source_name, 'w', encoding='utf-8') as ofile:
            ofile.write(textwrap.dedent(
                '''fn main() {
                }
                '''))

        cmdlist = self.exelist + ['-o', output_name, source_name]
        pc, stdo, stde = Popen_safe_logged(cmdlist, cwd=work_dir)
        if pc.returncode != 0:
            raise EnvironmentException(f'Rust compiler {self.name_string()} cannot compile programs.')
        self._native_static_libs(work_dir, source_name)
        if environment.need_exe_wrapper(self.for_machine):
            if not environment.has_exe_wrapper():
                # Can't check if the binaries run so we have to assume they do
                return
            cmdlist = environment.exe_wrapper.get_command() + [output_name]
        else:
            cmdlist = [output_name]
        pe = subprocess.Popen(cmdlist, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        pe.wait()
        if pe.returncode != 0:
            raise EnvironmentException(f'Executables created by Rust compiler {self.name_string()} are not runnable.')

    def _native_static_libs(self, work_dir: str, source_name: str) -> None:
        # Get libraries needed to link with a Rust staticlib
        cmdlist = self.exelist + ['--crate-type', 'staticlib', '--print', 'native-static-libs', source_name]
        p, stdo, stde = Popen_safe_logged(cmdlist, cwd=work_dir)
        if p.returncode != 0:
            raise EnvironmentException('Rust compiler cannot compile staticlib.')
        match = re.search('native-static-libs: (.*)$', stde, re.MULTILINE)
        if not match:
            raise EnvironmentException('Failed to find native-static-libs in Rust compiler output.')
        # Exclude some well known libraries that we don't need because they
        # are always part of C/C++ linkers. Rustc probably should not print
        # them, pkg-config for example never specify them.
        # FIXME: https://github.com/rust-lang/rust/issues/55120
        exclude = {'-lc', '-lgcc_s', '-lkernel32', '-ladvapi32'}
        self.native_static_libs = [i for i in match.group(1).split() if i not in exclude]

    def get_dependency_gen_args(self, outtarget: str, outfile: str) -> T.List[str]:
        return ['--dep-info', outfile]

    def get_sysroot(self) -> str:
        cmd = self.get_exelist(ccache=False) + ['--print', 'sysroot']
        p, stdo, stde = Popen_safe_logged(cmd)
        return stdo.split('\n', maxsplit=1)[0]

    @functools.lru_cache(maxsize=None)
    def get_crt_static(self) -> bool:
        cmd = self.get_exelist(ccache=False) + ['--print', 'cfg']
        p, stdo, stde = Popen_safe_logged(cmd)
        return bool(re.search('^target_feature="crt-static"$', stdo, re.MULTILINE))

    def get_debug_args(self, is_debug: bool) -> T.List[str]:
        return clike_debug_args[is_debug]

    def get_optimization_args(self, optimization_level: str) -> T.List[str]:
        return rust_optimization_args[optimization_level]

    def compute_parameters_with_absolute_paths(self, parameter_list: T.List[str],
                                               build_dir: str) -> T.List[str]:
        for idx, i in enumerate(parameter_list):
            if i[:2] == '-L':
                for j in ['dependency', 'crate', 'native', 'framework', 'all']:
                    combined_len = len(j) + 3
                    if i[:combined_len] == f'-L{j}=':
                        parameter_list[idx] = i[:combined_len] + os.path.normpath(os.path.join(build_dir, i[combined_len:]))
                        break

        return parameter_list

    def get_output_args(self, outputname: str) -> T.List[str]:
        return ['-o', outputname]

    @classmethod
    def use_linker_args(cls, linker: str, version: str) -> T.List[str]:
        return ['-C', f'linker={linker}']

    # Rust does not have a use_linker_args because it dispatches to a gcc-like
    # C compiler for dynamic linking, as such we invoke the C compiler's
    # use_linker_args method instead.

    def get_options(self) -> MutableKeyedOptionDictType:
        return dict((self.create_option(coredata.UserComboOption,
                                        OptionKey('std', machine=self.for_machine, lang=self.language),
                                        'Rust edition to use',
                                        ['none', '2015', '2018', '2021'],
                                        'none'),))

    def get_dependency_compile_args(self, dep: 'Dependency') -> T.List[str]:
        # Rust doesn't have dependency compile arguments so simply return
        # nothing here. Dependencies are linked and all required metadata is
        # provided by the linker flags.
        return []

    def get_option_compile_args(self, options: 'KeyedOptionDictType') -> T.List[str]:
        args = []
        key = OptionKey('std', machine=self.for_machine, lang=self.language)
        std = options[key]
        if std.value != 'none':
            args.append('--edition=' + std.value)
        return args

    def get_crt_compile_args(self, crt_val: str, buildtype: str) -> T.List[str]:
        # Rust handles this for us, we don't need to do anything
        return []

    def get_crt_link_args(self, crt_val: str, buildtype: str) -> T.List[str]:
        if self.linker.id not in {'link', 'lld-link'}:
            return []
        return self.MSVCRT_ARGS[self.get_crt_val(crt_val, buildtype)]

    def get_colorout_args(self, colortype: str) -> T.List[str]:
        if colortype in {'always', 'never', 'auto'}:
            return [f'--color={colortype}']
        raise MesonException(f'Invalid color type for rust {colortype}')

    def get_linker_always_args(self) -> T.List[str]:
        args: T.List[str] = []
        for a in super().get_linker_always_args():
            args.extend(['-C', f'link-arg={a}'])
        return args

    def get_werror_args(self) -> T.List[str]:
        # Use -D warnings, which makes every warning not explicitly allowed an
        # error
        return ['-D', 'warnings']

    def get_warn_args(self, level: str) -> T.List[str]:
        # TODO: I'm not really sure what to put here, Rustc doesn't have warning
        return self._WARNING_LEVELS[level]

    def get_pic_args(self) -> T.List[str]:
        # relocation-model=pic is rustc's default already.
        return []

    def get_pie_args(self) -> T.List[str]:
        # Rustc currently has no way to toggle this, it's controlled by whether
        # pic is on by rustc
        return []

    def get_assert_args(self, disable: bool) -> T.List[str]:
        action = "no" if disable else "yes"
        return ['-C', f'debug-assertions={action}', '-C', 'overflow-checks=no']


class ClippyRustCompiler(RustCompiler):

    """Clippy is a linter that wraps Rustc.

    This just provides us a different id
    """

    id = 'clippy-driver rustc'

"""

```
Response:
My thinking process to analyze the Python code snippet and fulfill the user's request goes through these stages:

1. **Understanding the Request:** I first break down the user's request into its core components:
    * Analyze the Python code provided.
    * List its functions.
    * Identify relationships with reverse engineering.
    * Point out connections to binary, Linux, Android kernel/framework concepts.
    * Explain logical reasoning with input/output examples.
    * Give examples of common usage errors.
    * Describe the user's path to this code (debugging context).
    * Summarize the overall function.
    * Note that this is part 3 of 5.

2. **Initial Code Scan and Class Identification:** I quickly scan the code, looking for `class` and `def` keywords to identify the main building blocks. I see classes like `BuildTarget`, `FileInTargetPrivateDir`, `FileMaybeInTargetPrivateDir`, `Generator`, `GeneratedList`, and `Executable`.

3. **Focusing on Key Classes (Based on Context Clues):** The filename `build.py` and the presence of `BuildTarget` strongly suggest this code is related to the build system of Frida. The `Executable` class further reinforces this, as it represents a buildable executable. Other classes seem to be supporting structures for managing files and build processes.

4. **Analyzing Functionality within Key Classes:** I go through the methods within the identified classes, trying to understand their purpose. For example, in `BuildTarget`:
    * `link_with`, `link_whole`: Indicate linking functionality, core to building executables and libraries.
    * `add_pch`, `add_include_dirs`:  Relate to compiler configuration.
    * `get_clink_dynamic_linker_and_stdlibs`: Suggests handling different language linkers.
    * `uses_rust`, `uses_rust_abi`:  Shows support for Rust.
    * `process_vs_module_defs_kw`: Implies interaction with Visual Studio build systems.

5. **Connecting to Reverse Engineering (Instruction #2):** I look for keywords and concepts related to reverse engineering. The presence of `frida` in the file path is a strong indicator. The concepts of linking (`link_with`, `link_whole`), especially with the considerations for shared libraries and static libraries, are fundamental in reverse engineering because understanding how binaries are built is crucial for analyzing them. Dynamic linking is particularly relevant to Frida's functionality.

6. **Identifying Binary, Linux, Android Kernel/Framework Aspects (Instruction #3):** I look for clues pointing to lower-level system interactions:
    * The handling of shared and static libraries is inherently related to binary structure and linking.
    * `get_clink_dynamic_linker_and_stdlibs` implies awareness of how linkers work on Linux-like systems.
    * The mention of Android and the handling of shared modules (`SharedModule`) points to Android's framework. The comment about `dlopen()` reinforces this.
    * The considerations for PIC (Position Independent Code) are vital for shared libraries on Linux and Android.

7. **Inferring Logical Reasoning (Instruction #4):**  I try to understand the conditional logic and how different inputs would lead to different outcomes. For instance:
    * The `link_with` method checks for various conditions (external libraries, target types, PIC status) and raises exceptions accordingly. I can construct example scenarios where these conditions are met or not.
    * The `get_clink_dynamic_linker_and_stdlibs` method has a priority order for selecting the linker based on language, demonstrating logical decision-making.

8. **Spotting Potential User Errors (Instruction #5):**  I look for code sections that explicitly raise exceptions based on incorrect user input:
    * The checks in `link_with` and `link_whole` for invalid target types or linking incompatible libraries.
    * The `add_pch` function's validation of header and source file combinations.
    * The `Generator.process_files` function's check for `preserve_path_from`.

9. **Constructing the User's Path (Instruction #6):** I imagine a developer using Frida and its build system. They would likely be:
    * Configuring the build using `meson`.
    * Defining targets (executables, libraries).
    * Specifying dependencies (`link_with`).
    * Potentially encountering linking errors, leading them to examine the `build.py` code.

10. **Summarizing the Function (Instruction #7):** Based on the analysis, I synthesize a concise description of the code's purpose, focusing on build target management, linking, and compiler configuration within the Frida project.

11. **Considering the "Part 3 of 5" Context:**  This reminds me that this is just one component of a larger build system. The code likely interacts with other parts of the Meson build process and Frida's specific build requirements. This helps to frame the scope of the current file.

By following these steps, I can systematically analyze the code, address each part of the user's request, and generate a comprehensive and informative response. The process involves a combination of code reading, domain knowledge (build systems, reverse engineering, operating systems), and logical deduction.
This Python code snippet is a part of the Meson build system configuration for the Frida QML component. Specifically, it defines the behavior of building various types of targets (like libraries and executables) within the Frida project. Let's break down its functionality:

**Core Functionality:**

This code defines classes (`BuildTarget`, `Executable`, `SharedLibrary`, `StaticLibrary`, `CustomTarget`, `Generator`, `GeneratedList`, etc.) that represent different build artifacts and the processes to create them. It focuses on the linking stage of the build process, ensuring dependencies between different parts of the Frida project are correctly managed.

Here's a breakdown of key functionalities within the provided snippet:

* **Linking Management (`link_with`, `link_whole`):**
    * These methods handle how different build targets are linked together. They ensure that the dependencies between libraries and executables are correctly specified.
    * **`link_with`**:  Links other build targets as regular dependencies.
    * **`link_whole`**:  Links static libraries in a way that includes all their object code into the current target. This is often necessary when dealing with static libraries that might not have all their symbols directly referenced.
    * **Error Handling:**  These methods include checks to prevent common linking errors, such as linking external libraries incorrectly or linking incompatible library types (e.g., non-PIC static libraries into shared libraries).

* **Internal Static Library Bundling (`_bundle_static_library`):**  When a static library depends on other internal static libraries, this method handles the process of including the object files from those dependencies into the final static library.

* **Dependency Tracking (`get_internal_static_libraries`, `get_internal_static_libraries_recurse`):** These methods are used to recursively find all internal static library dependencies of a given build target. This is important for ensuring that all necessary code is included during linking.

* **Precompiled Headers (`add_pch`):**  Allows specifying precompiled headers to speed up compilation. The code validates the provided header and source file combinations.

* **Include Directories (`add_include_dirs`):**  Manages the include directories that the compiler will search for header files.

* **Language Handling (`get_langs_used_by_deps`, `get_clink_dynamic_linker_and_stdlibs`, `get_used_stdlib_args`):**  Frida can be built with multiple languages (C, C++, Rust, etc.). These methods determine which linker and standard libraries should be used based on the languages involved in the current target and its dependencies.

* **Rust Integration (`uses_rust`, `uses_rust_abi`):**  Specific handling for Rust libraries and ensuring compatibility when linking with non-Rust code.

* **MSVC Compatibility (`get_using_msvc`):**  Detects if the Microsoft Visual C++ compiler/linker is being used, which affects file naming conventions and debug information generation.

* **Shared Module Handling (`check_module_linking`):**  Includes checks and adjustments for linking shared modules, particularly on macOS and Android, to avoid issues with symbol resolution at runtime.

* **Visual Studio Module Definition Files (`process_vs_module_defs_kw`):**  Handles the specification of `.def` files for controlling symbol visibility in Windows builds.

* **Code Generation (`Generator`, `GeneratedList`):**  Provides mechanisms for running external programs to generate source code or other files as part of the build process.

**Relationship to Reverse Engineering:**

This code is directly related to reverse engineering because Frida is a dynamic instrumentation toolkit used extensively for reverse engineering tasks. The correct building and linking of Frida itself is a prerequisite for using it.

* **Dynamic Linking and Libraries:** The code heavily deals with shared libraries (`SharedLibrary`) and how they are linked. Understanding dynamic linking is crucial in reverse engineering, as it's the mechanism by which Frida injects into and interacts with target processes. The functions managing `link_with` and `link_whole` are vital for building Frida correctly so that its core functionalities can be loaded and executed within target processes.

* **Binary Structure:**  Concepts like Position Independent Code (PIC), handled within the linking logic, are fundamental to understanding the structure of compiled binaries, particularly shared libraries, which is a key aspect of reverse engineering.

* **Platform Specifics:** The code handles platform-specific nuances (Windows, macOS, Android) in linking and module loading. This is important for Frida to function correctly across different operating systems, which are often targets of reverse engineering efforts.

**Examples and Relationships to Binary, Linux, Android:**

* **Binary Level:**
    * **PIC Check:** The code explicitly checks `if isinstance(self, SharedLibrary) and isinstance(t, StaticLibrary) and not t.pic:`. This is a low-level concern. On Linux and Android, shared libraries must be compiled with Position Independent Code (`-fPIC`) so they can be loaded at arbitrary memory addresses. This code prevents linking a non-PIC static library into a shared library, which would lead to runtime errors.
    * **Import Libraries (Windows):** The handling of `self.import_filename` in the `Executable` class is specific to Windows. When creating a DLL (which can be achieved through `export_dynamic` on an executable), a corresponding import library (`.lib`) is generated, which other Windows executables use to link against the DLL.

* **Linux Kernel/Framework:**
    * **Dynamic Linker:** The function `get_clink_dynamic_linker_and_stdlibs` interacts with the concept of the dynamic linker (`ld-linux.so` on Linux). It needs to select the correct linker based on the languages used in the build.
    * **Shared Library Suffixes:**  The code implicitly handles the `.so` suffix for shared libraries on Linux-like systems.

* **Android Kernel/Framework:**
    * **Shared Modules (`SharedModule`):** The `check_module_linking` function has specific logic for Android. It mentions the need to potentially force a `soname` (Shared Object Name) for shared modules on Android to ensure they are linked in the correct order when using `dlopen()`. This is a direct interaction with the Android runtime environment.

**Logical Reasoning (Hypothetical Input and Output):**

Let's say you have two internal libraries, `libA` (a static library) and `libB` (another static library), and you're building a shared library `libC`.

* **Input:**  You specify in your Meson build definition that `libC` should `link_with` `libA`. `libA` internally `link_whole`s `libB`.
* **Reasoning in `link_with`:** When processing `libC`, the code will encounter `libA` in the `link_targets`. Since `libA` is a static library, and `libC` is a shared library, the code in `link_with` won't directly include `libB`.
* **Reasoning in `_bundle_static_library` (indirectly):** When `libA` was built, the `_bundle_static_library` function (called potentially from `link_whole` within `libA`'s build definition) would have taken all the object files from `libB` and included them within `libA`.
* **Output:** The final `libC` will be linked against `libA`, and since `libA` already contains the object code from `libB`, all the necessary code will be present for `libC` to function correctly.

**User/Programming Errors:**

* **Incorrectly Linking External Libraries:**
    * **Error:** A user might try to use `link_with` to link against a library that is not built within the current Frida project (e.g., a system library).
    * **Code Section:** The `if not isinstance(t, BuildTarget):` check in `link_with` would trigger this.
    * **Example:** `libC.link_with(dependency('external_lib'))` would raise the `MesonException` because `dependency()` returns an external dependency object, not a `BuildTarget`.

* **Linking Non-PIC Static Library into a Shared Library:**
    * **Error:** A user might define a static library without the `pic: true` option and then try to link it into a shared library.
    * **Code Section:** The `if isinstance(self, SharedLibrary) and isinstance(t, StaticLibrary) and not t.pic:` check in `link_with` would catch this.
    * **Example:**
        ```meson
        static_library('mylib_static', 'mylib.c') # Missing 'pic: true'
        shared_library('mylib_shared', 'myshared.c', link_with: mylib_static)
        ```
        This would raise an `InvalidArguments` exception.

* **Incorrect PCH Usage:**
    * **Error:** Providing an incorrect number of files or file types to `add_pch`.
    * **Code Section:** The checks within the `add_pch` function would identify these errors.
    * **Example:** `executable('myexe', 'myexe.c', pch: ['myheader.h', 'mysource.c', 'another.c'])` would raise an `InvalidArguments` because more than two files are provided for PCH.

**User Operations Leading to This Code (Debugging Context):**

1. **Developer Modifies Frida's Build System:** A developer might be adding a new library or modifying the dependencies between existing components within Frida. They would edit the `meson.build` files in the relevant subprojects.
2. **Meson Configuration:** The developer runs `meson setup build` to configure the build. Meson parses the `meson.build` files.
3. **Target Processing:** Meson processes the definitions of each build target (executable, library). When it encounters a target that needs to link against other targets, it will call the `link_with` or `link_whole` methods within the appropriate `BuildTarget` subclass (e.g., `Executable` or `SharedLibrary`).
4. **Error Encountered:** If the developer has made a mistake in defining the dependencies (e.g., trying to link an external library with `link_with`), the checks within these methods will raise an exception, stopping the build process.
5. **Debugging:** The developer might then examine the Meson output or even step through the `build.py` code (this file) to understand why the linking is failing. The error messages generated by the checks in this code would provide clues about the problem.

**Summary of Functionality (Part 3 of 5):**

This specific part of the Frida build system (`frida/subprojects/frida-qml/releng/meson/mesonbuild/build.py`) is primarily responsible for **managing the linking process of build targets**. It defines how different components of Frida (libraries, executables) are connected, ensuring that dependencies are handled correctly and preventing common linking errors. It incorporates logic for handling different programming languages, platform-specific requirements, and code generation during the build. Its role is crucial in ensuring that the final Frida binaries are correctly assembled and can function as intended.

### 提示词
```
这是目录为frida/subprojects/frida-qml/releng/meson/mesonbuild/build.py的fridaDynamic instrumentation tool的源代码文件， 请列举一下它的功能, 
如果它与逆向的方法有关系，请做出对应的举例说明，
如果涉及到二进制底层，linux, android内核及框架的知识，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索。
这是第3部分，共5部分，请归纳一下它的功能
```

### 源代码
```python
raise MesonException(textwrap.dedent('''\
                        An external library was used in link_with keyword argument, which
                        is reserved for libraries built as part of this project. External
                        libraries must be passed using the dependencies keyword argument
                        instead, because they are conceptually "external dependencies",
                        just like those detected with the dependency() function.
                    '''))
                raise InvalidArguments(f'{t!r} is not a target.')
            if not t.is_linkable_target():
                raise InvalidArguments(f"Link target '{t!s}' is not linkable.")
            if isinstance(self, StaticLibrary) and self.install and t.is_internal():
                # When we're a static library and we link_with to an
                # internal/convenience library, promote to link_whole.
                self.link_whole([t], promoted=True)
                continue
            if isinstance(self, SharedLibrary) and isinstance(t, StaticLibrary) and not t.pic:
                msg = f"Can't link non-PIC static library {t.name!r} into shared library {self.name!r}. "
                msg += "Use the 'pic' option to static_library to build with PIC."
                raise InvalidArguments(msg)
            self.check_can_link_together(t)
            self.link_targets.append(t)

    def link_whole(self, targets: T.List[BuildTargetTypes], promoted: bool = False) -> None:
        for t in targets:
            if isinstance(t, (CustomTarget, CustomTargetIndex)):
                if not t.is_linkable_target():
                    raise InvalidArguments(f'Custom target {t!r} is not linkable.')
                if t.links_dynamically():
                    raise InvalidArguments('Can only link_whole custom targets that are static archives.')
            elif not isinstance(t, StaticLibrary):
                raise InvalidArguments(f'{t!r} is not a static library.')
            elif isinstance(self, SharedLibrary) and not t.pic:
                msg = f"Can't link non-PIC static library {t.name!r} into shared library {self.name!r}. "
                msg += "Use the 'pic' option to static_library to build with PIC."
                raise InvalidArguments(msg)
            self.check_can_link_together(t)
            if isinstance(self, StaticLibrary):
                # When we're a static library and we link_whole: to another static
                # library, we need to add that target's objects to ourselves.
                self._bundle_static_library(t, promoted)
                # If we install this static library we also need to include objects
                # from all uninstalled static libraries it depends on.
                if self.install:
                    for lib in t.get_internal_static_libraries():
                        self._bundle_static_library(lib, True)
            self.link_whole_targets.append(t)

    @lru_cache(maxsize=None)
    def get_internal_static_libraries(self) -> OrderedSet[BuildTargetTypes]:
        result: OrderedSet[BuildTargetTypes] = OrderedSet()
        self.get_internal_static_libraries_recurse(result)
        return result

    def get_internal_static_libraries_recurse(self, result: OrderedSet[BuildTargetTypes]) -> None:
        for t in self.link_targets:
            if t.is_internal() and t not in result:
                result.add(t)
                t.get_internal_static_libraries_recurse(result)
        for t in self.link_whole_targets:
            if t.is_internal():
                t.get_internal_static_libraries_recurse(result)

    def _bundle_static_library(self, t: T.Union[BuildTargetTypes], promoted: bool = False) -> None:
        if self.uses_rust():
            # Rustc can bundle static libraries, no need to extract objects.
            self.link_whole_targets.append(t)
        elif isinstance(t, (CustomTarget, CustomTargetIndex)) or t.uses_rust():
            # To extract objects from a custom target we would have to extract
            # the archive, WIP implementation can be found in
            # https://github.com/mesonbuild/meson/pull/9218.
            # For Rust C ABI we could in theory have access to objects, but there
            # are several meson issues that need to be fixed:
            # https://github.com/mesonbuild/meson/issues/10722
            # https://github.com/mesonbuild/meson/issues/10723
            # https://github.com/mesonbuild/meson/issues/10724
            m = (f'Cannot link_whole a custom or Rust target {t.name!r} into a static library {self.name!r}. '
                 'Instead, pass individual object files with the "objects:" keyword argument if possible.')
            if promoted:
                m += (f' Meson had to promote link to link_whole because {self.name!r} is installed but not {t.name!r},'
                      f' and thus has to include objects from {t.name!r} to be usable.')
            raise InvalidArguments(m)
        else:
            self.objects.append(t.extract_all_objects())

    def check_can_link_together(self, t: BuildTargetTypes) -> None:
        links_with_rust_abi = isinstance(t, BuildTarget) and t.uses_rust_abi()
        if not self.uses_rust() and links_with_rust_abi:
            raise InvalidArguments(f'Try to link Rust ABI library {t.name!r} with a non-Rust target {self.name!r}')
        if self.for_machine is not t.for_machine and (not links_with_rust_abi or t.rust_crate_type != 'proc-macro'):
            msg = f'Tried to tied to mix a {t.for_machine} library ("{t.name}") with a {self.for_machine} target "{self.name}"'
            if self.environment.is_cross_build():
                raise InvalidArguments(msg + ' This is not possible in a cross build.')
            else:
                mlog.warning(msg + ' This will fail in cross build.')

    def add_pch(self, language: str, pchlist: T.List[str]) -> None:
        if not pchlist:
            return
        elif len(pchlist) == 1:
            if not is_header(pchlist[0]):
                raise InvalidArguments(f'PCH argument {pchlist[0]} is not a header.')
        elif len(pchlist) == 2:
            if is_header(pchlist[0]):
                if not is_source(pchlist[1]):
                    raise InvalidArguments('PCH definition must contain one header and at most one source.')
            elif is_source(pchlist[0]):
                if not is_header(pchlist[1]):
                    raise InvalidArguments('PCH definition must contain one header and at most one source.')
                pchlist = [pchlist[1], pchlist[0]]
            else:
                raise InvalidArguments(f'PCH argument {pchlist[0]} is of unknown type.')

            if os.path.dirname(pchlist[0]) != os.path.dirname(pchlist[1]):
                raise InvalidArguments('PCH files must be stored in the same folder.')

            FeatureDeprecated.single_use('PCH source files', '0.50.0', self.subproject,
                                         'Only a single header file should be used.')
        elif len(pchlist) > 2:
            raise InvalidArguments('PCH definition may have a maximum of 2 files.')
        for f in pchlist:
            if not isinstance(f, str):
                raise MesonException('PCH arguments must be strings.')
            if not os.path.isfile(os.path.join(self.environment.source_dir, self.get_source_subdir(), f)):
                raise MesonException(f'File {f} does not exist.')
        self.pch[language] = pchlist

    def add_include_dirs(self, args: T.Sequence['IncludeDirs'], set_is_system: T.Optional[str] = None) -> None:
        ids: T.List['IncludeDirs'] = []
        for a in args:
            if not isinstance(a, IncludeDirs):
                raise InvalidArguments('Include directory to be added is not an include directory object.')
            ids.append(a)
        if set_is_system is None:
            set_is_system = 'preserve'
        if set_is_system != 'preserve':
            is_system = set_is_system == 'system'
            ids = [IncludeDirs(x.get_curdir(), x.get_incdirs(), is_system, x.get_extra_build_dirs(), x.is_build_only_subproject) for x in ids]
        self.include_dirs += ids

    def get_aliases(self) -> T.List[T.Tuple[str, str, str]]:
        return []

    def get_langs_used_by_deps(self) -> T.List[str]:
        '''
        Sometimes you want to link to a C++ library that exports C API, which
        means the linker must link in the C++ stdlib, and we must use a C++
        compiler for linking. The same is also applicable for objc/objc++, etc,
        so we can keep using clink_langs for the priority order.

        See: https://github.com/mesonbuild/meson/issues/1653
        '''
        langs: T.List[str] = []

        # Check if any of the external libraries were written in this language
        for dep in self.external_deps:
            if dep.language is None:
                continue
            if dep.language not in langs:
                langs.append(dep.language)
        # Check if any of the internal libraries this target links to were
        # written in this language
        for link_target in itertools.chain(self.link_targets, self.link_whole_targets):
            if isinstance(link_target, (CustomTarget, CustomTargetIndex)):
                continue
            for language in link_target.compilers:
                if language not in langs:
                    langs.append(language)

        return langs

    def get_prelinker(self):
        if self.link_language:
            comp = self.all_compilers[self.link_language]
            return comp
        for l in clink_langs:
            if l in self.compilers:
                try:
                    prelinker = self.all_compilers[l]
                except KeyError:
                    raise MesonException(
                        f'Could not get a prelinker linker for build target {self.name!r}. '
                        f'Requires a compiler for language "{l}", but that is not '
                        'a project language.')
                return prelinker
        raise MesonException(f'Could not determine prelinker for {self.name!r}.')

    def get_clink_dynamic_linker_and_stdlibs(self) -> T.Tuple['Compiler', T.List[str]]:
        '''
        We use the order of languages in `clink_langs` to determine which
        linker to use in case the target has sources compiled with multiple
        compilers. All languages other than those in this list have their own
        linker.
        Note that Vala outputs C code, so Vala sources can use any linker
        that can link compiled C. We don't actually need to add an exception
        for Vala here because of that.
        '''
        # If the user set the link_language, just return that.
        if self.link_language:
            comp = self.all_compilers[self.link_language]
            return comp, comp.language_stdlib_only_link_flags(self.environment)

        # Since dependencies could come from subprojects, they could have
        # languages we don't have in self.all_compilers. Use the global list of
        # all compilers here.
        all_compilers = self.environment.coredata.compilers[self.for_machine]

        # Languages used by dependencies
        dep_langs = self.get_langs_used_by_deps()

        # Pick a compiler based on the language priority-order
        for l in clink_langs:
            if l in self.compilers or l in dep_langs:
                try:
                    linker = all_compilers[l]
                except KeyError:
                    raise MesonException(
                        f'Could not get a dynamic linker for build target {self.name!r}. '
                        f'Requires a linker for language "{l}", but that is not '
                        'a project language.')
                stdlib_args: T.List[str] = self.get_used_stdlib_args(linker.language)
                # Type of var 'linker' is Compiler.
                # Pretty hard to fix because the return value is passed everywhere
                return linker, stdlib_args

        # None of our compilers can do clink, this happens for example if the
        # target only has ASM sources. Pick the first capable compiler.
        for l in clink_langs:
            try:
                comp = self.all_compilers[l]
                return comp, comp.language_stdlib_only_link_flags(self.environment)
            except KeyError:
                pass

        raise AssertionError(f'Could not get a dynamic linker for build target {self.name!r}')

    def get_used_stdlib_args(self, link_language: str) -> T.List[str]:
        all_compilers = self.environment.coredata.compilers[self.for_machine]
        all_langs = set(self.compilers).union(self.get_langs_used_by_deps())
        stdlib_args: T.List[str] = []
        for dl in all_langs:
            if dl != link_language and (dl, link_language) not in self._MASK_LANGS:
                # We need to use all_compilers here because
                # get_langs_used_by_deps could return a language from a
                # subproject
                stdlib_args.extend(all_compilers[dl].language_stdlib_only_link_flags(self.environment))
        return stdlib_args

    def uses_rust(self) -> bool:
        return 'rust' in self.compilers

    def uses_rust_abi(self) -> bool:
        return self.uses_rust() and self.rust_crate_type in {'dylib', 'rlib', 'proc-macro'}

    def uses_fortran(self) -> bool:
        return 'fortran' in self.compilers

    def get_using_msvc(self) -> bool:
        '''
        Check if the dynamic linker is MSVC. Used by Executable, StaticLibrary,
        and SharedLibrary for deciding when to use MSVC-specific file naming
        and debug filenames.

        If at least some code is built with MSVC and the final library is
        linked with MSVC, we can be sure that some debug info will be
        generated. We only check the dynamic linker here because the static
        linker is guaranteed to be of the same type.

        Interesting cases:
        1. The Vala compiler outputs C code to be compiled by whatever
           C compiler we're using, so all objects will still be created by the
           MSVC compiler.
        2. If the target contains only objects, process_compilers guesses and
           picks the first compiler that smells right.
        '''
        # Rustc can use msvc style linkers
        if self.uses_rust():
            compiler = self.all_compilers['rust']
        else:
            compiler, _ = self.get_clink_dynamic_linker_and_stdlibs()
        # Mixing many languages with MSVC is not supported yet so ignore stdlibs.
        return compiler and compiler.get_linker_id() in {'link', 'lld-link', 'xilink', 'optlink'}

    def check_module_linking(self):
        '''
        Warn if shared modules are linked with target: (link_with) #2865
        '''
        for link_target in self.link_targets:
            if isinstance(link_target, SharedModule) and not link_target.force_soname:
                if self.environment.machines[self.for_machine].is_darwin():
                    raise MesonException(
                        f'target {self.name} links against shared module {link_target.name}. This is not permitted on OSX')
                elif self.environment.machines[self.for_machine].is_android() and isinstance(self, SharedModule):
                    # Android requires shared modules that use symbols from other shared modules to
                    # be linked before they can be dlopen()ed in the correct order. Not doing so
                    # leads to a missing symbol error: https://github.com/android/ndk/issues/201
                    link_target.force_soname = True
                else:
                    mlog.deprecation(f'target {self.name} links against shared module {link_target.name}, which is incorrect.'
                                     '\n             '
                                     f'This will be an error in the future, so please use shared_library() for {link_target.name} instead.'
                                     '\n             '
                                     f'If shared_module() was used for {link_target.name} because it has references to undefined symbols,'
                                     '\n             '
                                     'use shared_library() with `override_options: [\'b_lundef=false\']` instead.')
                    link_target.force_soname = True

    def process_vs_module_defs_kw(self, kwargs: T.Dict[str, T.Any]) -> None:
        if kwargs.get('vs_module_defs') is None:
            return

        path: T.Union[str, File, CustomTarget, CustomTargetIndex] = kwargs['vs_module_defs']
        if isinstance(path, str):
            if os.path.isabs(path):
                self.vs_module_defs = File.from_absolute_file(path)
            else:
                self.vs_module_defs = File.from_source_file(self.environment.source_dir, self.subdir, path)
        elif isinstance(path, File):
            # When passing a generated file.
            self.vs_module_defs = path
        elif isinstance(path, (CustomTarget, CustomTargetIndex)):
            # When passing output of a Custom Target
            self.vs_module_defs = File.from_built_file(path.get_output_subdir(), path.get_filename())
        else:
            raise InvalidArguments(
                'vs_module_defs must be either a string, '
                'a file object, a Custom Target, or a Custom Target Index')
        self.process_link_depends(path)

class FileInTargetPrivateDir:
    """Represents a file with the path '/path/to/build/target_private_dir/fname'.
       target_private_dir is the return value of get_target_private_dir which is e.g. 'subdir/target.p'.
    """

    def __init__(self, fname: str):
        self.fname = fname

    def __str__(self) -> str:
        return self.fname

class FileMaybeInTargetPrivateDir:
    """Union between 'File' and 'FileInTargetPrivateDir'"""

    def __init__(self, inner: T.Union[File, FileInTargetPrivateDir]):
        self.inner = inner

    @property
    def fname(self) -> str:
        return self.inner.fname

    def rel_to_builddir(self, build_to_src: str, target_private_dir: str) -> str:
        if isinstance(self.inner, FileInTargetPrivateDir):
            return os.path.join(target_private_dir, self.inner.fname)
        return self.inner.rel_to_builddir(build_to_src)

    def absolute_path(self, srcdir: str, builddir: str) -> str:
        if isinstance(self.inner, FileInTargetPrivateDir):
            raise RuntimeError('Unreachable code')
        return self.inner.absolute_path(srcdir, builddir)

    def __str__(self) -> str:
        return self.fname

class Generator(HoldableObject):
    def __init__(self, exe: T.Union['Executable', programs.ExternalProgram],
                 arguments: T.List[str],
                 output: T.List[str],
                 # how2dataclass
                 *,
                 depfile: T.Optional[str] = None,
                 capture: bool = False,
                 depends: T.Optional[T.List[T.Union[BuildTarget, 'CustomTarget', 'CustomTargetIndex']]] = None,
                 name: str = 'Generator'):
        self.exe = exe
        self.depfile = depfile
        self.capture = capture
        self.depends: T.List[T.Union[BuildTarget, 'CustomTarget', 'CustomTargetIndex']] = depends or []
        self.arglist = arguments
        self.outputs = output
        self.name = name

    def __repr__(self) -> str:
        repr_str = "<{0}: {1}>"
        return repr_str.format(self.__class__.__name__, self.exe)

    def get_exe(self) -> T.Union['Executable', programs.ExternalProgram]:
        return self.exe

    def get_base_outnames(self, inname: str) -> T.List[str]:
        plainname = os.path.basename(inname)
        basename = os.path.splitext(plainname)[0]
        bases = [x.replace('@BASENAME@', basename).replace('@PLAINNAME@', plainname) for x in self.outputs]
        return bases

    def get_dep_outname(self, inname: str) -> T.List[str]:
        if self.depfile is None:
            raise InvalidArguments('Tried to get dep name for rule that does not have dependency file defined.')
        plainname = os.path.basename(inname)
        basename = os.path.splitext(plainname)[0]
        return self.depfile.replace('@BASENAME@', basename).replace('@PLAINNAME@', plainname)

    def get_arglist(self, inname: str) -> T.List[str]:
        plainname = os.path.basename(inname)
        basename = os.path.splitext(plainname)[0]
        return [x.replace('@BASENAME@', basename).replace('@PLAINNAME@', plainname) for x in self.arglist]

    @staticmethod
    def is_parent_path(parent: str, trial: str) -> bool:
        try:
            common = os.path.commonpath((parent, trial))
        except ValueError: # Windows on different drives
            return False
        return pathlib.PurePath(common) == pathlib.PurePath(parent)

    def process_files(self, files: T.Iterable[T.Union[str, File, 'CustomTarget', 'CustomTargetIndex', 'GeneratedList']],
                      state: T.Union['Interpreter', 'ModuleState'],
                      preserve_path_from: T.Optional[str] = None,
                      extra_args: T.Optional[T.List[str]] = None,
                      env: T.Optional[EnvironmentVariables] = None) -> 'GeneratedList':
        # TODO: need a test for a generator in a build-only subproject
        is_build_only: T.Optional[bool] = getattr(state, 'is_build_only_subproject', None)
        if is_build_only is None:
            is_build_only = T.cast('Interpreter', state).coredata.is_build_only
        output = GeneratedList(
            self,
            state.subdir,
            preserve_path_from,
            extra_args=extra_args if extra_args is not None else [],
            env=env if env is not None else EnvironmentVariables(),
            is_build_only_subproject=is_build_only,
        )

        for e in files:
            if isinstance(e, CustomTarget):
                output.depends.add(e)
            if isinstance(e, CustomTargetIndex):
                output.depends.add(e.target)
            if isinstance(e, (CustomTarget, CustomTargetIndex)):
                output.depends.add(e)
                fs = [File.from_built_file(e.get_output_subdir(), f) for f in e.get_outputs()]
            elif isinstance(e, GeneratedList):
                if preserve_path_from:
                    raise InvalidArguments("generator.process: 'preserve_path_from' is not allowed if one input is a 'generated_list'.")
                output.depends.add(e)
                fs = [FileInTargetPrivateDir(f) for f in e.get_outputs()]
            elif isinstance(e, str):
                fs = [File.from_source_file(state.environment.source_dir, state.subdir, e)]
            else:
                fs = [e]

            for f in fs:
                if preserve_path_from:
                    abs_f = f.absolute_path(state.environment.source_dir, state.environment.build_dir)
                    if not self.is_parent_path(preserve_path_from, abs_f):
                        raise InvalidArguments('generator.process: When using preserve_path_from, all input files must be in a subdirectory of the given dir.')
                f = FileMaybeInTargetPrivateDir(f)
                output.add_file(f, state)
        return output


@dataclass(eq=False)
class GeneratedList(HoldableObject):

    """The output of generator.process."""

    generator: Generator
    subdir: str
    preserve_path_from: T.Optional[str]
    extra_args: T.List[str]
    env: T.Optional[EnvironmentVariables]
    is_build_only_subproject: bool

    def __post_init__(self) -> None:
        self.name = self.generator.exe
        self.depends: T.Set[GeneratedTypes] = set()
        self.infilelist: T.List[FileMaybeInTargetPrivateDir] = []
        self.outfilelist: T.List[str] = []
        self.outmap: T.Dict[FileMaybeInTargetPrivateDir, T.List[str]] = {}
        self.extra_depends = []  # XXX: Doesn't seem to be used?
        self.depend_files: T.List[File] = []

        if self.extra_args is None:
            self.extra_args: T.List[str] = []

        if self.env is None:
            self.env: EnvironmentVariables = EnvironmentVariables()

        if isinstance(self.generator.exe, programs.ExternalProgram):
            if not self.generator.exe.found():
                raise InvalidArguments('Tried to use not-found external program as generator')
            path = self.generator.exe.get_path()
            if os.path.isabs(path):
                # Can only add a dependency on an external program which we
                # know the absolute path of
                self.depend_files.append(File.from_absolute_file(path))

    def add_preserved_path_segment(self, infile: FileMaybeInTargetPrivateDir, outfiles: T.List[str], state: T.Union['Interpreter', 'ModuleState']) -> T.List[str]:
        result: T.List[str] = []
        in_abs = infile.absolute_path(state.environment.source_dir, state.environment.build_dir)
        assert os.path.isabs(self.preserve_path_from)
        rel = os.path.relpath(in_abs, self.preserve_path_from)
        path_segment = os.path.dirname(rel)
        for of in outfiles:
            result.append(os.path.join(path_segment, of))
        return result

    def add_file(self, newfile: FileMaybeInTargetPrivateDir, state: T.Union['Interpreter', 'ModuleState']) -> None:
        self.infilelist.append(newfile)
        outfiles = self.generator.get_base_outnames(newfile.fname)
        if self.preserve_path_from:
            outfiles = self.add_preserved_path_segment(newfile, outfiles, state)
        self.outfilelist += outfiles
        self.outmap[newfile] = outfiles

    def get_inputs(self) -> T.List[FileMaybeInTargetPrivateDir]:
        return self.infilelist

    def get_outputs(self) -> T.List[str]:
        return self.outfilelist

    def get_outputs_for(self, filename: FileMaybeInTargetPrivateDir) -> T.List[str]:
        return self.outmap[filename]

    def get_generator(self) -> 'Generator':
        return self.generator

    def get_extra_args(self) -> T.List[str]:
        return self.extra_args

    def get_source_subdir(self) -> str:
        return self.subdir

    def get_output_subdir(self) -> str:
        return compute_build_subdir(self.subdir, self.is_build_only_subproject)


class Executable(BuildTarget):
    known_kwargs = known_exe_kwargs

    typename = 'executable'

    def __init__(
            self,
            name: str,
            subdir: str,
            subproject: SubProject,
            for_machine: MachineChoice,
            sources: T.List['SourceOutputs'],
            structured_sources: T.Optional[StructuredSources],
            objects: T.List[ObjectTypes],
            environment: environment.Environment,
            compilers: T.Dict[str, 'Compiler'],
            build_only_subproject: bool,
            kwargs):
        key = OptionKey('b_pie')
        if 'pie' not in kwargs and key in environment.coredata.options:
            kwargs['pie'] = environment.coredata.options[key].value
        super().__init__(name, subdir, subproject, for_machine, sources, structured_sources, objects,
                         environment, compilers, build_only_subproject, kwargs)
        self.win_subsystem = kwargs.get('win_subsystem') or 'console'
        # Check for export_dynamic
        self.export_dynamic = kwargs.get('export_dynamic', False)
        if not isinstance(self.export_dynamic, bool):
            raise InvalidArguments('"export_dynamic" keyword argument must be a boolean')
        self.implib = kwargs.get('implib')
        if not isinstance(self.implib, (bool, str, type(None))):
            raise InvalidArguments('"export_dynamic" keyword argument must be a boolean or string')
        # Only linkwithable if using export_dynamic
        self.is_linkwithable = self.export_dynamic
        # Remember that this exe was returned by `find_program()` through an override
        self.was_returned_by_find_program = False

        self.vs_module_defs: T.Optional[File] = None
        self.process_vs_module_defs_kw(kwargs)

    def post_init(self) -> None:
        super().post_init()
        machine = self.environment.machines[self.for_machine]
        # Unless overridden, executables have no suffix or prefix. Except on
        # Windows and with C#/Mono executables where the suffix is 'exe'
        if not hasattr(self, 'prefix'):
            self.prefix = ''
        if not hasattr(self, 'suffix'):
            # Executable for Windows or C#/Mono
            if machine.is_windows() or machine.is_cygwin() or 'cs' in self.compilers:
                self.suffix = 'exe'
            elif machine.system.startswith('wasm') or machine.system == 'emscripten':
                self.suffix = 'js'
            elif ('c' in self.compilers and self.compilers['c'].get_id().startswith('armclang') or
                  'cpp' in self.compilers and self.compilers['cpp'].get_id().startswith('armclang')):
                self.suffix = 'axf'
            elif ('c' in self.compilers and self.compilers['c'].get_id().startswith('ccrx') or
                  'cpp' in self.compilers and self.compilers['cpp'].get_id().startswith('ccrx')):
                self.suffix = 'abs'
            elif ('c' in self.compilers and self.compilers['c'].get_id().startswith('xc16')):
                self.suffix = 'elf'
            elif ('c' in self.compilers and self.compilers['c'].get_id() in {'ti', 'c2000', 'c6000'} or
                  'cpp' in self.compilers and self.compilers['cpp'].get_id() in {'ti', 'c2000', 'c6000'}):
                self.suffix = 'out'
            elif ('c' in self.compilers and self.compilers['c'].get_id() in {'mwccarm', 'mwcceppc'} or
                  'cpp' in self.compilers and self.compilers['cpp'].get_id() in {'mwccarm', 'mwcceppc'}):
                self.suffix = 'nef'
            else:
                self.suffix = machine.get_exe_suffix()
        self.filename = self.name
        if self.suffix:
            self.filename += '.' + self.suffix
        self.outputs[0] = self.filename

        # The import library this target will generate
        self.import_filename = None
        # The debugging information file this target will generate
        self.debug_filename = None

        # If using export_dynamic, set the import library name
        if self.export_dynamic:
            implib_basename = self.name + '.exe'
            if isinstance(self.implib, str):
                implib_basename = self.implib
            if machine.is_windows() or machine.is_cygwin():
                if self.get_using_msvc():
                    self.import_filename = f'{implib_basename}.lib'
                else:
                    self.import_filename = f'lib{implib_basename}.a'

        create_debug_file = (
            machine.is_windows()
            and ('cs' in self.compilers or self.uses_rust() or self.get_using_msvc())
            # .pdb file is created only when debug symbols are enabled
            and self.environment.coredata.get_option(OptionKey("debug"))
        )
        if create_debug_file:
            # If the target is has a standard exe extension (i.e. 'foo.exe'),
            # then the pdb name simply becomes 'foo.pdb'. If the extension is
            # something exotic, then include that in the name for uniqueness
            # reasons (e.g. 'foo_com.pdb').
            name = self.name
            if getattr(self, 'suffix', 'exe') != 'exe':
                name += '_' + self.suffix
            self.debug_filename = name + '.pdb'

    def process_kwargs(self, kwargs):
        super().process_kwargs(kwargs)

        self.rust_crate_type = kwargs.get('rust_crate_type') or 'bin'
        if self.rust_crate_type != 'bin':
            raise InvalidArguments('Invalid rust_crate_type: must be "bin" for executables.')

    def get_default_install_dir(self) -> T.Union[T.Tuple[str, str], T.Tuple[None, None]]:
        return self.environment.get_bindir(), '{bindir}'

    def description(self):
        '''Human friendly description of the executable'''
        return self.name

    def type_suffix(self):
        return "@exe"

    def get_import_filename(self) -> T.Optional[str]:
        """
        The name of the import library that will be outputted by the compiler

        Returns None if there is no import library required for this platform
        """
        return self.import_filename

    def get_debug_filename(self) -> T.Optional[str]:
        """
        The name of debuginfo file that will be created by the compiler

        Returns None if the build won't create any debuginfo file
        """
        return self.debug_filename

    def is_linkable_tar
```
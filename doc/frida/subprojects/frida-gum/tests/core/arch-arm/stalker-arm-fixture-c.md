Response:
Let's break down the thought process for analyzing this C code and fulfilling the request.

**1. Initial Understanding of the Context:**

The first step is to recognize the provided path: `frida/subprojects/frida-gum/tests/core/arch-arm/stalker-arm-fixture.c`. This immediately tells us several things:

* **Frida:** This is related to the Frida dynamic instrumentation toolkit.
* **frida-gum:** This is a core component of Frida, likely the instrumentation engine itself.
* **tests:** This is a test file, meaning it's designed to verify the functionality of other code.
* **core/arch-arm:** This narrows the focus to the ARM architecture.
* **stalker-arm-fixture.c:** The "stalker" part suggests this file is specifically testing the "stalker" component of Frida-gum on ARM. A "fixture" in testing often means a setup and teardown mechanism for creating a consistent testing environment.

**2. High-Level Code Overview:**

Next, I'd quickly scan the code for key elements:

* **Includes:** `gumstalker.h`, `fakeeventsink.h`, `gumarmwriter.h`, etc. These headers hint at the functionalities being tested:  stalker, event tracking, ARM code generation, memory management.
* **Macros:** `TESTCASE`, `TESTENTRY`, `NTH_EVENT_AS_CALL`, `TESTCODE`, etc. These are testing-specific helpers for defining and structuring test cases.
* **Structs:** `TestArmStalkerFixture`, `UnfollowTransformContext`, `InvalidationTransformContext`, `InvalidationTarget`. `TestArmStalkerFixture` is clearly the main fixture structure, holding the stalker, transformer, sink, and code. The other structs seem related to specific testing scenarios.
* **Functions:** `test_arm_stalker_fixture_setup`, `teardown`, `dup_code`, `invoke_arm_expecting_return_value`, `follow_and_invoke`, etc. These are the core functions for setting up the test environment, executing code under the stalker, and verifying the results.

**3. Identifying Key Components and Their Interactions:**

Based on the includes and function names, I would start to connect the dots:

* **`GumStalker`:** This is the central component being tested. It's responsible for tracking and intercepting code execution.
* **`GumStalkerTransformer`:** This is used to modify the code being stalked.
* **`GumFakeEventSink`:** This is a mock object used to capture the events generated by the stalker (e.g., function calls, returns, block executions). This is a classic testing pattern for isolating the component under test.
* **`GumArmWriter`:** This is a utility for generating ARM assembly code dynamically. It's used to create the "invoker" code.

**4. Analyzing `test_arm_stalker_fixture_setup` and `teardown`:**

These functions clearly define the lifecycle of the test fixture:

* **`setup`:** Initializes the `GumStalker`, creates a `GumFakeEventSink`, and sets the event mask to 0 (initially no events are being monitored).
* **`teardown`:**  Performs cleanup, including garbage collecting the stalker, unreferencing objects, and freeing allocated memory. This is crucial to avoid resource leaks in tests.

**5. Deep Dive into Key Functions:**

* **`test_arm_stalker_fixture_dup_code`:** This function allocates memory near the `gum_stalker_follow_me` function (important for how the stalker works) and copies the provided test code into it. It also marks the memory as executable. This is a common pattern in dynamic instrumentation –  injecting and executing code.
* **`invoke_arm_expecting_return_value` and `invoke_thumb_expecting_return_value`:** These functions:
    * Duplicate the test code using `dup_code`.
    * Set the event mask on the `fakeeventsink` to specify which events to capture.
    * Call `follow_and_invoke` to execute the code under the stalker.
    * Assert that the return value of the invoked code matches the expected value. The difference between the two is handling ARM and Thumb mode (hence the `+ 1` to the address for Thumb).
* **`test_arm_stalker_fixture_follow_and_invoke`:** This is a core function that orchestrates the stalking process:
    * Allocates memory for the "invoker" code.
    * Uses `GumArmWriter` to generate a sequence of ARM assembly instructions:
        * Saves the Link Register (LR) to return to the caller.
        * Loads addresses of `gum_stalker_follow_me`, the stalker instance, transformer, and sink into registers.
        * Calls `gum_stalker_follow_me` to start stalking.
        * Loads the address of the target function (`addr`) and calls it.
        * Loads the address of `gum_stalker_unfollow_me` and the stalker instance into registers.
        * Calls `gum_stalker_unfollow_me` to stop stalking.
        * Restores the LR and returns.
    * Marks the generated invoker code as executable.
    * Executes the invoker code.
    * Frees the invoker code.
    * Returns the return value of the invoked function.

**6. Addressing the Specific Questions:**

With a good understanding of the code, I can now systematically address the questions:

* **Functionality:** List the purpose of each key function and the overall goal of the fixture (testing the stalker).
* **Relationship to Reversing:** Explain how the stalker's ability to intercept and analyze code execution is directly relevant to reverse engineering. Give examples like tracing function calls, inspecting arguments, and analyzing control flow.
* **Binary/Kernel/Framework:** Identify areas where the code interacts with low-level concepts: memory allocation (`gum_alloc_n_pages_near`), code execution (`gum_memory_mark_code`), ARM assembly (`GumArmWriter`), and mentions of Linux kernel concepts (like `prctl`).
* **Logical Inference:**  Analyze `follow_and_invoke` and trace the execution flow, noting the setup, stalking, execution, unstalking, and return value propagation. Create a simple hypothetical input and output scenario to illustrate its behavior.
* **User/Programming Errors:**  Think about common mistakes when using a dynamic instrumentation framework like Frida: incorrect memory management, issues with ARM/Thumb mode, forgetting to unfollow, and incorrect event filtering.
* **User Steps to Reach Here:** Imagine a developer using Frida to debug or analyze an ARM application. Outline the steps they might take that would lead to the execution of the stalker and thus the relevance of this test fixture.

**7. Structuring the Answer:**

Finally, organize the information into a clear and logical structure, addressing each part of the prompt with specific examples and explanations from the code. Use clear headings and bullet points for readability. Emphasize the connections between the code and the concepts of dynamic instrumentation, reverse engineering, and low-level system details.
这是一个名为 `stalker-arm-fixture.c` 的 C 源代码文件，它属于 Frida 动态 instrumentation 工具的 frida-gum 子项目中的测试套件。更具体地说，它位于 `tests/core/arch-arm/` 目录下，这表明它是用于测试 Frida-gum 的核心功能，并且是针对 ARM 架构的。该文件的主要目的是提供一个用于编写和执行针对 Frida Stalker 组件的 ARM 架构相关测试的“fixture”。

**它的功能：**

1. **提供测试环境:**  该文件定义了一个名为 `TestArmStalkerFixture` 的结构体，用于存储测试所需的状态，包括 `GumStalker` 实例（Stalker 是 Frida-gum 中用于跟踪代码执行的核心组件），`GumStalkerTransformer` 实例（用于修改被跟踪的代码），`GumFakeEventSink` 实例（一个模拟的事件接收器，用于捕获 Stalker 产生的事件），以及用于存储测试代码的内存。

2. **代码注入和执行:**  该文件提供了 `test_arm_stalker_fixture_dup_code` 函数，用于在内存中分配空间并复制给定的 ARM 代码。这个函数模拟了将代码注入到目标进程的过程。

3. **模拟 Stalker 的跟踪和事件捕获:**  `GumFakeEventSink` 允许测试用例捕获 Stalker 生成的事件，例如代码块的执行、函数调用和返回等。

4. **辅助执行被跟踪代码:**  `test_arm_stalker_fixture_follow_and_invoke` 函数创建了一段临时的“调用者”代码，该代码会调用 `gum_stalker_follow_me` 来启动 Stalker 对指定地址代码的跟踪，然后执行目标地址的代码，最后调用 `gum_stalker_unfollow_me` 停止跟踪。这模拟了 Frida 在目标进程中启动和停止跟踪的流程。

5. **便捷的测试宏:**  该文件定义了许多宏，例如 `TESTCASE`、`TESTENTRY`、`NTH_EVENT_AS_CALL`、`TESTCODE` 等，这些宏简化了编写测试用例的过程。它们封装了常用的测试操作，例如定义测试函数、注册测试用例、断言捕获到的事件类型和内容等。

6. **支持 ARM 和 Thumb 指令集:**  该文件提供了 `invoke_arm_expecting_return_value` 和 `invoke_thumb_expecting_return_value` 两个函数，分别用于执行 ARM 和 Thumb 指令集的代码，并断言其返回值。

**与逆向方法的关系及举例说明：**

Frida 本身就是一个强大的动态逆向工具，而 Stalker 是 Frida 中用于代码跟踪的核心组件。这个 fixture 就是用于测试 Stalker 在 ARM 架构上的工作是否符合预期。

* **代码跟踪和分析:**  Stalker 的核心功能是跟踪代码的执行流程。在逆向工程中，了解程序的执行路径对于理解其行为至关重要。例如，你可以使用 Frida 和 Stalker 来跟踪一个函数被调用的顺序，或者观察特定代码块是否被执行。这个 fixture 通过 `gum_stalker_follow_me` 和 `gum_stalker_unfollow_me` 模拟了启动和停止跟踪的过程，并通过 `GumFakeEventSink` 验证是否产生了预期的跟踪事件。

   **举例:**  一个逆向工程师想要分析一个加密算法的实现。他可以使用 Frida 启动 Stalker，跟踪加密函数的执行，并记录下执行过的指令地址和寄存器状态。这个 fixture 中的 `GumFakeEventSink` 就像是逆向工程师记录跟踪信息的工具。

* **动态插桩和代码修改:**  虽然这个 fixture 主要关注跟踪，但 Frida 的强大之处还在于可以动态地修改程序的行为。`GumStalkerTransformer` 组件就是用于实现代码转换的。虽然这个 fixture 中可能没有直接展示代码修改的例子，但它是 Frida 动态插桩能力的基础。

   **举例:**  一个逆向工程师想要绕过某个程序的安全检查。他可以使用 Frida 拦截到安全检查函数的调用，并修改其返回值，使其总是返回成功。这需要 Frida 能够动态地修改目标进程的内存中的代码或控制流。

**涉及二进制底层，Linux, Android 内核及框架的知识及举例说明：**

* **二进制底层 (ARM 指令集):**  该文件大量使用了 ARM 汇编指令相关的知识。例如，`TESTCODE` 宏用于定义原始的 ARM 指令字节码，`GumArmWriter` 用于生成 ARM 汇编指令。`invoke_arm_expecting_return_value` 和 `invoke_thumb_expecting_return_value` 区分了 ARM 和 Thumb 两种指令集模式。

   **举例:**  `TESTCODE(basic_return, 0x08, 0x47)` 定义了一个 Thumb 指令 `BX LR` (返回指令) 的字节码。理解这些字节码的含义是进行 ARM 平台逆向的基础。

* **内存管理:**  `gum_alloc_n_pages_near` 用于在内存中分配页，`gum_free_pages` 用于释放内存。`gum_memory_mark_code` 用于将分配的内存标记为可执行，这对于动态执行注入的代码至关重要。这些操作都涉及操作系统底层的内存管理机制。

   **举例:**  `test_arm_stalker_fixture_dup_code` 函数演示了如何在目标进程的地址空间中分配内存来存放要测试的代码。这模拟了 Frida 将 JavaScript 代码编译成机器码并注入到目标进程的过程。

* **函数调用约定 (ABI):**  `test_arm_stalker_fixture_follow_and_invoke` 函数中生成的汇编代码遵循了 ARM 的函数调用约定，例如使用 `push` 和 `pop` 指令来保存和恢复寄存器，通过 `blx` 指令进行函数调用等。

   **举例:**  在 `follow_and_invoke` 中，保存 `LR` 寄存器是为了在被调用的函数执行完毕后能够正确返回。这是 ARM ABI 的基本要求。

* **进程间通信 (IPC):** 虽然这个 fixture 文件本身没有直接展示 IPC，但 Frida 作为动态 instrumentation 工具，需要在宿主机器和目标进程之间进行通信。Stalker 产生的事件需要传递回 Frida 的核心进行处理。在更复杂的场景下，Frida 会使用各种 IPC 机制，例如管道、Socket 等。`StalkerDummyChannel` 看起来是一个用于测试的模拟通道。

* **Linux 特性 (`HAVE_LINUX`, `glib-unix.h`, `sys/prctl.h`):**  代码中包含了对 `HAVE_LINUX` 的条件编译，并且包含了 `glib-unix.h` 和 `sys/prctl.h` 头文件。这表明 Frida 在 Linux 平台上可能会使用一些特定的系统调用或库函数。 `prctl` 可能用于修改进程的某些属性。

   **举例:**  在 Linux 上，Frida 可能使用 `ptrace` 系统调用来实现对目标进程的控制和内存读写。

* **Android 内核和框架:**  虽然代码没有直接提及 Android 特定的 API，但 चूंकि它位于 `arch-arm` 目录下，并且 Frida 在 Android 逆向中被广泛使用，因此可以推断这个 fixture 也被用于测试在 Android 环境下的 Stalker 功能。Android 运行在 Linux 内核之上，其框架也涉及到进程管理、内存管理等方面。

**逻辑推理，假设输入与输出：**

以 `test_arm_stalker_fixture_follow_and_invoke` 函数为例：

**假设输入:**

* `fixture`: 一个已经初始化好的 `TestArmStalkerFixture` 结构体。
* `addr`:  一个有效的 ARM 代码地址，例如指向 `test_arm_stalker_fixture_dup_code` 分配的代码。

**逻辑推理:**

1. 函数会在内存中分配新的页用于存放“调用者”代码。
2. 使用 `GumArmWriter` 生成一段 ARM 汇编代码：
   - 保存 `LR` 寄存器。
   - 加载 `gum_stalker_follow_me`、`fixture->stalker`、`fixture->transformer`、`fixture->sink` 的地址到寄存器。
   - 调用 `gum_stalker_follow_me`，开始跟踪。
   - 加载 `addr` 到寄存器。
   - 使用 `blx` 指令调用 `addr` 指向的代码。
   - 将被调用函数的返回值保存到 `retval` 变量的地址。
   - 加载 `gum_stalker_unfollow_me` 和 `fixture->stalker` 的地址到寄存器。
   - 调用 `gum_stalker_unfollow_me`，停止跟踪。
   - 恢复 `LR` 寄存器。
   - 返回。
3. 将生成的“调用者”代码标记为可执行。
4. 执行“调用者”代码。
5. 释放分配的“调用者”代码内存。

**假设输出:**

* 函数的返回值是被调用地址 `addr` 处代码执行后的返回值。
* 如果 `fixture->sink->mask` 设置了相应的事件类型，`fixture->sink->events` 中会记录下 Stalker 跟踪到的事件，例如代码块的执行。

**涉及用户或者编程常见的使用错误，请举例说明:**

1. **忘记调用 `gum_stalker_unfollow_me`:** 如果用户在使用 Frida Stalker 时，调用了 `gum_stalker_follow_me` 开始跟踪，但在操作完成后忘记调用 `gum_stalker_unfollow_me` 停止跟踪，可能会导致性能问题，因为 Stalker 会持续跟踪代码执行，消耗资源。这个 fixture 中的 `follow_and_invoke` 函数确保了 `unfollow_me` 被调用，避免了这种错误。

2. **错误的事件掩码设置:**  用户可能设置了错误的 `fixture->sink->mask`，导致他们期望捕获的事件没有被记录下来，或者捕获了过多的不相关事件。例如，如果用户只想跟踪函数调用，但设置的掩码包含了所有执行事件，那么会产生大量的事件数据。

3. **内存管理错误:**  在动态 instrumentation 中，内存管理非常重要。如果用户手动分配内存用于注入代码，但忘记释放，会导致内存泄漏。这个 fixture 中的 `test_arm_stalker_fixture_dup_code` 和 `follow_and_invoke` 函数展示了正确的内存分配和释放流程。

4. **ARM/Thumb 模式混淆:**  在 ARM 架构中，代码可以在 ARM 和 Thumb 两种指令集模式下执行。如果用户错误地假设目标代码的指令集模式，可能会导致 Frida 无法正确解析和跟踪代码。`invoke_arm_expecting_return_value` 和 `invoke_thumb_expecting_return_value` 的区分强调了这种模式的重要性。

5. **对 Stalker 工作原理理解不足:** 用户可能对 Stalker 的工作原理理解不足，例如不清楚 `follow_me` 的作用范围，或者不明白 Transformer 的用途，导致无法有效地使用 Stalker 进行逆向分析。

**说明用户操作是如何一步步的到达这里，作为调试线索:**

1. **用户编写 Frida 脚本:** 用户想要使用 Frida 的 Stalker 功能来分析一个运行在 ARM 架构上的程序。他们编写了一个 Frida 脚本，使用了 `Stalker.follow()` 方法来启动代码跟踪。

2. **Frida 执行脚本:** Frida 将用户的 JavaScript 脚本转换为内部表示，并将其注入到目标进程中。

3. **`Stalker.follow()` 调用:**  在目标进程中，JavaScript 层的 `Stalker.follow()` 调用会触发 Frida-gum 库中的 C 代码执行，最终会调用到 `gum_stalker_follow_me` 函数。

4. **Stalker 开始工作:**  `gum_stalker_follow_me` 会初始化 Stalker 的内部状态，开始监控目标进程的执行流。

5. **执行到被跟踪的代码:** 当目标进程执行到用户指定的需要跟踪的代码区域时，Stalker 会捕获执行事件。

6. **事件处理和传递:** Stalker 捕获到的事件（例如代码块执行、函数调用等）会被传递到 Frida-gum 的事件处理机制。

7. **测试用例模拟:** 这个 `stalker-arm-fixture.c` 文件中的测试用例，例如调用 `test_arm_stalker_fixture_follow_and_invoke`，实际上是在模拟上述步骤。它模拟了用户启动跟踪 (`gum_stalker_follow_me`)，执行被跟踪的代码，以及停止跟踪 (`gum_stalker_unfollow_me`) 的过程。`GumFakeEventSink` 模拟了 Frida 将事件传递回用户脚本的过程。

8. **调试线索:** 如果用户在使用 Stalker 时遇到问题，例如没有捕获到预期的事件，或者程序行为异常，那么 Frida 的开发者或者用户可以通过分析相关的测试用例（如这个 fixture 中的用例）来理解 Stalker 的工作原理，并找到问题的原因。例如，他们可以查看测试用例是如何设置事件掩码、如何启动和停止跟踪的，以及如何断言捕获到的事件的。

总而言之，`stalker-arm-fixture.c` 是 Frida-gum 中用于测试 Stalker 组件在 ARM 架构上功能的关键文件。它提供了模拟代码注入、执行、跟踪和事件捕获的框架，帮助开发者验证 Stalker 的正确性，并为用户理解和调试 Frida Stalker 的行为提供了参考。

Prompt: 
```
这是目录为frida/subprojects/frida-gum/tests/core/arch-arm/stalker-arm-fixture.c的fridaDynamic instrumentation tool的源代码文件， 请列举一下它的功能, 
如果它与逆向的方法有关系，请做出对应的举例说明，
如果涉及到二进制底层，linux, android内核及框架的知识，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索。

"""
/*
 * Copyright (C) 2009-2022 Ole André Vadla Ravnås <oleavr@nowsecure.com>
 * Copyright (C) 2017 Antonio Ken Iannillo <ak.iannillo@gmail.com>
 *
 * Licence: wxWindows Library Licence, Version 3.1
 */

#include "gumstalker.h"

#include "fakeeventsink.h"
#include "gumarmwriter.h"
#include "gummemory.h"
#include "stalkerdummychannel.h"
#include "testutil.h"

#include <lzma.h>
#include <stdlib.h>
#include <string.h>
#ifdef HAVE_LINUX
# include <glib-unix.h>
# include <sys/prctl.h>
#endif

#define TESTCASE(NAME) \
    void test_arm_stalker_ ## NAME (                                      \
    TestArmStalkerFixture * fixture, gconstpointer data)
#define TESTENTRY(NAME) \
    TESTENTRY_WITH_FIXTURE ("Core/Stalker", test_arm_stalker, NAME,       \
    TestArmStalkerFixture)

#define NTH_EVENT_AS_CALL(N) \
    (gum_fake_event_sink_get_nth_event_as_call (fixture->sink, N))
#define NTH_EVENT_AS_RET(N) \
    (gum_fake_event_sink_get_nth_event_as_ret (fixture->sink, N))
#define NTH_EXEC_EVENT_LOCATION(N) \
    (gum_fake_event_sink_get_nth_event_as_exec (fixture->sink, N)->location)

#define TESTCODE(NAME, ...) static const __attribute__((__aligned__((4)))) \
    guint8 NAME[] = { __VA_ARGS__ }
#define CODE_START(NAME) ((gconstpointer) NAME)
#define CODE_SIZE(NAME) sizeof (NAME)

#define DUP_TESTCODE(NAME) \
    test_arm_stalker_fixture_dup_code (fixture, \
        CODE_START (NAME), CODE_SIZE (NAME))
#define FOLLOW_AND_INVOKE(FUNC) \
    test_arm_stalker_fixture_follow_and_invoke (fixture, FUNC)
#define INVOKE_ARM_EXPECTING(EVENTS, NAME, RETVAL) \
    invoke_arm_expecting_return_value (fixture, EVENTS, CODE_START (NAME), \
        CODE_SIZE (NAME), RETVAL)
#define INVOKE_THUMB_EXPECTING(EVENTS, NAME, RETVAL) \
    invoke_thumb_expecting_return_value (fixture, EVENTS, CODE_START (NAME), \
        CODE_SIZE (NAME), RETVAL)

#define GUM_EVENT_TYPE_exec GumExecEvent
#define GUM_EVENT_TYPE_NAME_exec GUM_EXEC

#define GUM_EVENT_TYPE_call GumCallEvent
#define GUM_EVENT_TYPE_NAME_call GUM_CALL

#define GUM_EVENT_TYPE_block GumBlockEvent
#define GUM_EVENT_TYPE_NAME_block GUM_BLOCK

#define GUM_EVENT_TYPE_ret GumRetEvent
#define GUM_EVENT_TYPE_NAME_ret GUM_RET

#define GUM_ASSERT_EVENT_ADDR(TYPE, INDEX, FIELD, VALUE)                  \
    {                                                                     \
      GUM_EVENT_TYPE_ ## TYPE * ev;                                       \
                                                                          \
      g_assert_cmpuint (fixture->sink->events->len, >, INDEX);            \
      g_assert_cmpint (g_array_index (fixture->sink->events,              \
          GumEvent, INDEX).type, ==, GUM_EVENT_TYPE_NAME_ ## TYPE);       \
                                                                          \
      ev = &g_array_index (fixture->sink->events, GumEvent, INDEX).TYPE;  \
      GUM_ASSERT_CMPADDR (ev->FIELD, ==, VALUE);                          \
    }

/*
 * Total number of instructions in the invoker built by follow_and_invoke().
 * This is counted from the first instruction after the call to follow_me()
 * up to and including the call to unfollow_me().
 */
#define INVOKER_INSN_COUNT 7

/*
 * Total number of call instructions in the invoker built by
 * follow_and_invoke().
 */
#define INVOKER_CALL_INSN_COUNT 2

/*
 * Total number of blocks in the invoker built by follow_and_invoke().
 */
#define INVOKER_BLOCK_COUNT 3

/*
 * Index of block invoked by follow_and_invoke().
 */
#define INVOKEE_BLOCK_INDEX 1

/*
 * Offset of the first instruction within the invoker which should be stalked in
 * bytes.
 */
#define INVOKER_IMPL_OFFSET 24

typedef struct _TestArmStalkerFixture TestArmStalkerFixture;
typedef struct _UnfollowTransformContext UnfollowTransformContext;
typedef struct _InvalidationTransformContext InvalidationTransformContext;
typedef struct _InvalidationTarget InvalidationTarget;

struct _TestArmStalkerFixture
{
  GumStalker * stalker;
  GumStalkerTransformer * transformer;
  GumFakeEventSink * sink;

  guint8 * code;
  guint8 * invoker;
};

struct _UnfollowTransformContext
{
  GumStalker * stalker;
  guint num_blocks_transformed;
  guint target_block;
  gint max_instructions;
};

struct _InvalidationTransformContext
{
  GumStalker * stalker;
  gconstpointer target_function;
  guint n;
};

struct _InvalidationTarget
{
  GumStalkerTransformer * transformer;
  InvalidationTransformContext ctx;

  GThread * thread;
  GumThreadId thread_id;
  StalkerDummyChannel channel;
  volatile gboolean finished;
};

static void test_arm_stalker_fixture_setup (TestArmStalkerFixture * fixture,
    gconstpointer data);
static void test_arm_stalker_fixture_teardown (TestArmStalkerFixture * fixture,
    gconstpointer data);
static GumAddress test_arm_stalker_fixture_dup_code (
    TestArmStalkerFixture * fixture, const guint32 * tpl_code, guint tpl_size);
static GumAddress invoke_arm_expecting_return_value (
    TestArmStalkerFixture * fixture, GumEventType mask, const guint32 * code,
    guint32 len, guint32 expected_return_value);
static GumAddress invoke_thumb_expecting_return_value (
    TestArmStalkerFixture * fixture, GumEventType mask, const guint32 * code,
    guint32 len, guint32 expected_return_value);
static guint32 test_arm_stalker_fixture_follow_and_invoke (
    TestArmStalkerFixture * fixture, GumAddress addr);

static void
test_arm_stalker_fixture_setup (TestArmStalkerFixture * fixture,
                                gconstpointer data)
{
  fixture->stalker = gum_stalker_new ();
  fixture->transformer = NULL;
  fixture->sink = GUM_FAKE_EVENT_SINK (gum_fake_event_sink_new ());
  fixture->sink->mask = 0;
}

static void
test_arm_stalker_fixture_teardown (TestArmStalkerFixture * fixture,
                                   gconstpointer data)
{
  while (gum_stalker_garbage_collect (fixture->stalker))
    g_usleep (10000);

  g_object_unref (fixture->sink);
  g_clear_object (&fixture->transformer);
  g_object_unref (fixture->stalker);

  if (fixture->code != NULL)
    gum_free_pages (fixture->code);
}

static GumAddress
test_arm_stalker_fixture_dup_code (TestArmStalkerFixture * fixture,
                                   const guint32 * tpl_code,
                                   guint tpl_size)
{
  GumAddressSpec spec;

  spec.near_address = gum_stalker_follow_me;
  spec.max_distance = G_MAXINT32 / 2;

  if (fixture->code != NULL)
    gum_free_pages (fixture->code);
  fixture->code = gum_alloc_n_pages_near (
      (tpl_size / gum_query_page_size ()) + 1, GUM_PAGE_RW, &spec);
  memcpy (fixture->code, tpl_code, tpl_size);
  gum_memory_mark_code (fixture->code, tpl_size);

  return GUM_ADDRESS (fixture->code);
}

static GumAddress
invoke_arm_expecting_return_value (TestArmStalkerFixture * fixture,
                                   GumEventType mask,
                                   const guint32 * code,
                                   guint32 len,
                                   guint32 expected_return_value)
{
  GumAddress func;

  func = test_arm_stalker_fixture_dup_code (fixture, code, len);

  fixture->sink->mask = mask;
  g_assert_cmpuint (FOLLOW_AND_INVOKE (func), ==, expected_return_value);

  return func;
}

static GumAddress
invoke_thumb_expecting_return_value (TestArmStalkerFixture * fixture,
                                     GumEventType mask,
                                     const guint32 * code,
                                     guint32 len,
                                     guint32 expected_return_value)
{
  GumAddress func;

  func = test_arm_stalker_fixture_dup_code (fixture, code, len);

  fixture->sink->mask = mask;
  g_assert_cmpuint (FOLLOW_AND_INVOKE (func + 1), ==, expected_return_value);

  return func;
}

static guint32
test_arm_stalker_fixture_follow_and_invoke (TestArmStalkerFixture * fixture,
                                            GumAddress addr)
{
  guint32 retval;
  GumAddressSpec spec;
  GumArmWriter cw;
  GCallback stalked_func;

  spec.near_address = gum_stalker_follow_me;
  spec.max_distance = G_MAXINT32 / 2;
  fixture->invoker = gum_alloc_n_pages_near (1, GUM_PAGE_RW, &spec);

  gum_arm_writer_init (&cw, fixture->invoker);

  /*
   * The ABI dictates that the stack here is 8 byte aligned. We need to store
   * LR, so that we can return to our caller, but we additionally push R0 as we
   * need to push an even number of registers to maintain alignment. We
   * otherwise would not need to store R0 since it is a caller rather than
   * callee saved register.
   */
  gum_arm_writer_put_push_regs (&cw, 2, ARM_REG_R0, ARM_REG_LR);

  gum_arm_writer_put_ldr_reg_address (&cw, ARM_REG_R3,
      GUM_ADDRESS (gum_stalker_follow_me));
  gum_arm_writer_put_ldr_reg_address (&cw, ARM_REG_R0,
      GUM_ADDRESS (fixture->stalker));
  gum_arm_writer_put_ldr_reg_address (&cw, ARM_REG_R1,
      GUM_ADDRESS (fixture->transformer));
  gum_arm_writer_put_ldr_reg_address (&cw, ARM_REG_R2,
      GUM_ADDRESS (fixture->sink));
  gum_arm_writer_put_blx_reg (&cw, ARM_REG_R3);

  gum_arm_writer_put_ldr_reg_u32 (&cw, ARM_REG_R0, GUM_ADDRESS (addr));
  gum_arm_writer_put_blx_reg (&cw, ARM_REG_R0);

  gum_arm_writer_put_ldr_reg_address (&cw, ARM_REG_R1, GUM_ADDRESS (&retval));
  gum_arm_writer_put_str_reg_reg_offset (&cw, ARM_REG_R0, ARM_REG_R1, 0);

  gum_arm_writer_put_ldr_reg_address (&cw, ARM_REG_R1,
      GUM_ADDRESS (gum_stalker_unfollow_me));
  gum_arm_writer_put_ldr_reg_address (&cw, ARM_REG_R0,
      GUM_ADDRESS (fixture->stalker));
  gum_arm_writer_put_blx_reg (&cw, ARM_REG_R1);

  gum_arm_writer_put_pop_regs (&cw, 2, ARM_REG_R0, ARM_REG_LR);
  gum_arm_writer_put_ret (&cw);

  gum_arm_writer_flush (&cw);
  gum_memory_mark_code (cw.base, gum_arm_writer_offset (&cw));
  gum_arm_writer_clear (&cw);

  stalked_func = GUM_POINTER_TO_FUNCPTR (GCallback, fixture->invoker);
  stalked_func ();

  gum_free_pages (fixture->invoker);

  return retval;
}

"""

```
Response:
Let's break down the thought process for analyzing this Python code.

1. **Understand the Core Purpose:** The first step is to read the initial lines and the class name: `TAPParserTests`. The name strongly suggests this code is for *testing* something related to parsing TAP (Test Anything Protocol) output. The file path `frida/subprojects/frida-gum/releng/meson/unittests/taptests.py` reinforces this, placing it within the testing framework of the Frida project.

2. **Identify Key Components:** Look for the main building blocks of the code. Immediately, `unittest.TestCase` stands out, confirming this is a standard Python unit test file. Then, the import `from mesonbuild.mtest import TAPParser, TestResult` tells us what's being tested: the `TAPParser` class. The `TestResult` enum is also important for understanding test outcomes.

3. **Analyze Helper Methods:** The code has several `assert_*` methods (`assert_test`, `assert_plan`, etc.). These are helper functions designed to make the test code more readable and less repetitive. Each one asserts a specific type of event parsed from the TAP output. This hints at the different components of the TAP format.

4. **Examine Test Methods:** The functions starting with `test_` are the actual test cases. Read through a few of them to understand the testing logic. Notice how they:
    * Call `parse_tap` (or `parse_tap_v13`) with different TAP strings as input.
    * Use the `assert_*` methods to verify the parsed events match the expected output.

5. **Infer Functionality of `TAPParser`:** Based on the tests, we can infer the functionality of the `TAPParser` class. It must:
    * Parse TAP formatted strings.
    * Recognize different TAP elements like "ok", "not ok", plans ("1..N"), directives ("# SKIP", "# TODO"), and versions.
    * Track test numbers, names, and results.
    * Handle errors and unexpected input.
    * Potentially support different TAP versions.

6. **Relate to Reverse Engineering (if applicable):**  Consider how TAP fits into reverse engineering. Frida is a dynamic instrumentation tool used extensively in reverse engineering. TAP is a common format for reporting test results. Therefore, it's likely that Frida's internal testing or some of its components might produce TAP output. This connection is indirect but important.

7. **Connect to Binary/Kernel/Framework Concepts:**  Think about where TAP might be used in a lower-level context. While the *parser* itself is high-level Python, the *tests* being run (and whose output is being parsed) could involve interaction with binaries, the Linux kernel, or Android frameworks. For example, Frida might have tests that check if it can correctly hook functions in a binary or intercept system calls. The TAP output would simply report whether these hooks succeeded or failed.

8. **Identify Logic and Assumptions:** Look for patterns in the test cases that demonstrate specific logic within the parser. For example, the tests for early and late plans show how the parser handles the plan declaration at different points. The tests for out-of-order tests and too many/few tests reveal error handling logic.

9. **Look for User/Programming Errors:** Consider common mistakes developers might make when generating TAP output. The tests for unexpected lines, invalid versions, and incorrect plan counts highlight potential errors in TAP generation.

10. **Trace User Operations:**  Imagine how a user would end up triggering this code. A developer working on Frida would likely:
    * Make changes to Frida's codebase (specifically in the `frida-gum` component, likely related to testing or internal reporting).
    * Run the unit tests using a command like `meson test` or a similar command provided by the Meson build system.
    * Meson would execute this `taptests.py` file, which would then parse the TAP output generated by other parts of Frida's test suite or internal processes.

11. **Structure the Explanation:**  Organize the findings into clear categories based on the prompt's requirements: functionality, relationship to reverse engineering, low-level details, logic/assumptions, user errors, and user operations. Use examples from the code to illustrate each point.

12. **Refine and Elaborate:** Review the explanation for clarity and completeness. Add more details where necessary and ensure the language is precise. For example, explicitly mentioning Frida's dynamic instrumentation nature helps connect the code to the larger project context.

By following these steps, we can systematically analyze the Python code and provide a comprehensive explanation that addresses all aspects of the prompt. The key is to understand the *purpose* of the code and then use the code itself as evidence to support the analysis.
这个Python源代码文件 `taptests.py` 是 Frida 动态 instrumentation 工具项目 `frida-gum` 的一部分，位于测试目录中。它的主要功能是**测试 TAPParser 类**，这个类负责解析 TAP (Test Anything Protocol) 格式的测试结果输出。

下面分别列举其功能，并根据你的要求进行说明：

**1. 功能:**

* **解析 TAP 输出:**  `TAPParser` 类的核心功能是接收 TAP 格式的字符串（通常来自测试程序的标准输出），并将其解析成结构化的数据。
* **识别 TAP 元素:** 它能够识别 TAP 协议中的各种元素，包括：
    * **测试结果:** `ok` (通过) 和 `not ok` (失败) 指示符。
    * **测试编号:** 每个测试的唯一标识符。
    * **测试名称:** 可选的测试描述。
    * **计划行:**  `1..N` 声明了测试的总数。
    * **指令:**  如 `# SKIP` (跳过) 和 `# TODO` (待办)。
    * **版本信息:** `TAP version 13` 等。
    * **Bail out!:** 表示测试提前终止。
    * **YAML 块:**  以 `---` 和 `...` 分隔的额外诊断信息。
    * **注释和诊断信息:** 以 `#` 开头的行。
* **验证 TAP 格式的正确性:**  测试用例会检查 `TAPParser` 是否能够正确处理各种合法的和非法的 TAP 输出格式，例如：
    * **早期和晚期计划:**  计划行出现在测试之前或之后。
    * **计划行中的指令:**  例如跳过某个计划内的测试。
    * **测试编号的顺序:**  测试编号是否按顺序递增。
    * **计划数量与实际测试数量的匹配:**  计划的测试数量是否与实际运行的测试数量一致。
    * **意外的行:**  不符合 TAP 格式的行。
* **提供结构化的测试结果:**  解析后的 TAP 输出被转换成 `TAPParser.Test`, `TAPParser.Plan`, `TAPParser.Version` 等对象，方便进一步处理和分析。
* **进行单元测试:** `TAPParserTests` 类本身是一个单元测试套件，使用 Python 的 `unittest` 框架来验证 `TAPParser` 类的功能是否正常。

**2. 与逆向方法的关联及举例:**

Frida 是一个用于动态分析和修改程序行为的工具，广泛应用于逆向工程。虽然这个 `taptests.py` 文件本身专注于测试 TAP 解析器，但 TAP 协议在测试 Frida 的功能时可能会被使用。

**举例说明:**

假设 Frida 的一个测试用例是测试它是否能够成功 hook (拦截) 某个特定函数的调用。这个测试用例的输出可能采用 TAP 格式：

```
1..1
ok 1 Hooked function X successfully
```

或者，如果 hook 失败：

```
1..1
not ok 1 Failed to hook function X
  ---
  message: Error during hooking: ...
  ...
```

`TAPParser` 就负责解析这些 TAP 输出，判断 Frida 的测试是否通过。在逆向过程中，Frida 的开发者或用户可能会编写针对特定场景的测试用例，使用 TAP 格式来报告测试结果，以便自动化测试和验证 Frida 功能的正确性。

**3. 涉及二进制底层、Linux、Android 内核及框架的知识及举例:**

虽然 `taptests.py` 文件本身是高层次的 Python 代码，但它所测试的 `TAPParser` 类最终服务于 Frida 这样一个与底层系统交互的工具。Frida 的测试用例可能会涉及到：

* **二进制底层:** 测试 Frida 是否能够正确地注入代码到目标进程，读取和修改内存，调用目标进程的函数等。例如，一个测试用例可能测试 Frida 是否能成功修改 Android 应用的 DEX 文件中的某个指令。
* **Linux 内核:**  Frida 依赖于 Linux 内核的特性（例如 `ptrace` 或内核模块）来实现进程注入和代码执行。一些测试用例可能会验证 Frida 在不同内核版本下的兼容性或特定内核特性的使用情况。
* **Android 内核及框架:**  Frida 在 Android 平台上广泛使用。测试用例可能涉及到与 Android 系统服务的交互、hook Android Framework 层的方法、操作 ART 虚拟机等。例如，一个测试用例可能测试 Frida 是否能够 hook `ActivityManagerService` 的某个方法。

**举例说明:**

假设 Frida 有一个测试用例，用于测试它在 Android 上 hook `System.currentTimeMillis()` 函数的功能。该测试用例的输出可能是这样的：

```
1..1
ok 1 Successfully hooked System.currentTimeMillis() and verified interception.
```

这个测试用例的背后，Frida 实际上是在 Android 系统的 ART 虚拟机层进行了底层的操作，修改了 `System.currentTimeMillis()` 的执行流程。`taptests.py` 中 `TAPParser` 的作用就是解析这个测试用例的 TAP 输出，判断 Frida 的 hook 功能是否正常工作。

**4. 逻辑推理及假设输入与输出:**

`taptests.py` 包含了大量的测试用例，每个测试用例都对 `TAPParser` 的特定逻辑进行验证。以下举例说明几个测试用例的逻辑推理：

* **`test_many_early_plan`:**
    * **假设输入:**
    ```
    1..4
    ok 1
    not ok 2
    ok 3
    not ok 4
    ```
    * **逻辑推理:**  `TAPParser` 应该首先解析到计划行 `1..4`，知道有 4 个测试。然后依次解析每个测试的结果，并验证测试编号是否正确。
    * **预期输出:**  `assert_plan` 验证计划信息，然后四个 `assert_test` 验证每个测试的结果和编号。

* **`test_out_of_order`:**
    * **假设输入:**
    ```
    ok 2
    ```
    * **逻辑推理:**  在没有计划行的情况下，`TAPParser` 遇到测试编号 2，但之前没有测试编号 1，因此认为测试编号顺序错误。
    * **预期输出:**  `assert_error` 断言解析器遇到了错误，然后 `assert_test` 验证解析了测试结果。

* **`test_too_many` (测试计划数量少于实际测试数量的情况):**
    * **假设输入:**
    ```
    ok 1
    not ok 2
    1..1
    ```
    * **逻辑推理:**  `TAPParser` 先解析两个测试结果，然后遇到计划行 `1..1`，发现计划的测试数量与实际遇到的测试数量不符。
    * **预期输出:** 两个 `assert_test` 验证测试结果，然后 `assert_plan` 验证计划信息，最后 `assert_error` 断言解析器遇到了错误。

**5. 涉及用户或编程常见的使用错误及举例:**

`taptests.py` 中的一些测试用例模拟了用户或程序在生成 TAP 输出时可能犯的错误：

* **`test_unexpected`:**
    * **错误:**  在 TAP 输出中包含了不符合 TAP 格式的行。
    * **示例输入:**
    ```
    1..1
    invalid
    ok 1
    ```
    * **结果:**  `TAPParser` 应该能够识别出 `invalid` 这一行是意外的，并报告错误。

* **`test_version`:**
    * **错误:**  使用了不支持的 TAP 版本。
    * **示例输入:**
    ```
    TAP version 12
    ```
    * **结果:**  `TAPParser` 应该能够识别出版本号，并根据其支持的版本（当前测试中似乎只支持 13）来判断是否错误。

* **`test_too_many_plans`:**
    * **错误:**  在 TAP 输出中出现了多个计划行。
    * **示例输入:**
    ```
    1..1
    1..2
    ok 1
    ```
    * **结果:** `TAPParser` 应该能够检测到第二个计划行是错误的。

**6. 用户操作是如何一步步的到达这里，作为调试线索:**

通常情况下，普通 Frida 用户不会直接接触到 `taptests.py` 文件。这个文件主要是 Frida 开发者的测试代码。用户操作到这里的步骤可能是这样的：

1. **Frida 开发者修改了 Frida 的代码:**  开发者可能修改了 `frida-gum` 组件的某些功能。
2. **运行 Frida 的测试套件:**  为了验证修改后的代码是否引入了 bug 或者新的功能是否正常工作，开发者会运行 Frida 的测试套件。这通常是通过类似 `meson test` 或其他构建系统提供的命令来完成的。
3. **Meson 构建系统执行测试:**  Meson 构建系统会找到 `frida/subprojects/frida-gum/releng/meson/unittests/taptests.py` 这个文件，并执行其中的测试用例。
4. **测试用例运行:**  `taptests.py` 中的每个 `test_*` 方法会被执行。这些方法会调用 `TAPParser` 来解析模拟的 TAP 输出。
5. **断言验证结果:**  `assert_*` 方法会检查 `TAPParser` 的解析结果是否符合预期。如果断言失败，就说明 `TAPParser` 或者 Frida 的相关功能存在问题。

**作为调试线索:**

如果 Frida 的测试失败，开发者可能会查看 `taptests.py` 中的相关测试用例，分析：

* **哪个测试用例失败了？**  这可以帮助定位问题的范围。
* **失败的测试用例的输入是什么？**  这可以帮助理解导致解析错误的 TAP 输出格式。
* **预期的输出是什么？实际的输出是什么？**  比较预期和实际的解析结果可以帮助理解 `TAPParser` 在哪里出现了错误。
* **相关的 `TAPParser` 代码逻辑是什么？**  根据失败的测试用例，开发者可以深入研究 `TAPParser` 类的实现，找出导致解析错误的具体代码。

总而言之，`taptests.py` 是 Frida 项目中用于测试 TAP 输出解析功能的关键文件，它通过大量的测试用例来确保 `TAPParser` 能够正确处理各种 TAP 格式，这对于保证 Frida 自身测试结果的可靠性至关重要。虽然普通用户不会直接操作这个文件，但它是 Frida 开发和维护过程中不可或缺的一部分。

Prompt: 
```
这是目录为frida/subprojects/frida-gum/releng/meson/unittests/taptests.py的fridaDynamic instrumentation tool的源代码文件， 请列举一下它的功能, 
如果它与逆向的方法有关系，请做出对应的举例说明，
如果涉及到二进制底层，linux, android内核及框架的知识，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索。

"""
# SPDX-License-Identifier: Apache-2.0
# Copyright 2016-2021 The Meson development team

import unittest
import io

from mesonbuild.mtest import TAPParser, TestResult


class TAPParserTests(unittest.TestCase):
    def assert_test(self, events, **kwargs):
        if 'explanation' not in kwargs:
            kwargs['explanation'] = None
        self.assertEqual(next(events), TAPParser.Test(**kwargs))

    def assert_plan(self, events, **kwargs):
        if 'skipped' not in kwargs:
            kwargs['skipped'] = False
        if 'explanation' not in kwargs:
            kwargs['explanation'] = None
        self.assertEqual(next(events), TAPParser.Plan(**kwargs))

    def assert_version(self, events, **kwargs):
        self.assertEqual(next(events), TAPParser.Version(**kwargs))

    def assert_error(self, events):
        self.assertEqual(type(next(events)), TAPParser.Error)

    def assert_unexpected(self, events, **kwargs):
        self.assertEqual(next(events), TAPParser.UnknownLine(**kwargs))

    def assert_bailout(self, events, **kwargs):
        self.assertEqual(next(events), TAPParser.Bailout(**kwargs))

    def assert_last(self, events):
        with self.assertRaises(StopIteration):
            next(events)

    def parse_tap(self, s):
        parser = TAPParser()
        return iter(parser.parse(io.StringIO(s)))

    def parse_tap_v13(self, s):
        events = self.parse_tap('TAP version 13\n' + s)
        self.assert_version(events, version=13)
        return events

    def test_empty(self):
        events = self.parse_tap('')
        self.assert_last(events)

    def test_empty_plan(self):
        events = self.parse_tap('1..0')
        self.assert_plan(events, num_tests=0, late=False, skipped=True)
        self.assert_last(events)

    def test_plan_directive(self):
        events = self.parse_tap('1..0 # skipped for some reason')
        self.assert_plan(events, num_tests=0, late=False, skipped=True,
                         explanation='for some reason')
        self.assert_last(events)

        events = self.parse_tap('1..1 # skipped for some reason\nok 1')
        self.assert_error(events)
        self.assert_plan(events, num_tests=1, late=False, skipped=True,
                         explanation='for some reason')
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_last(events)

        events = self.parse_tap('1..1 # todo not supported here\nok 1')
        self.assert_error(events)
        self.assert_plan(events, num_tests=1, late=False, skipped=False,
                         explanation='not supported here')
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_last(events)

    def test_one_test_ok(self):
        events = self.parse_tap('ok')
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_last(events)

    def test_one_test_with_number(self):
        events = self.parse_tap('ok 1')
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_last(events)

    def test_one_test_with_name(self):
        events = self.parse_tap('ok 1 abc')
        self.assert_test(events, number=1, name='abc', result=TestResult.OK)
        self.assert_last(events)

    def test_one_test_not_ok(self):
        events = self.parse_tap('not ok')
        self.assert_test(events, number=1, name='', result=TestResult.FAIL)
        self.assert_last(events)

    def test_one_test_todo(self):
        events = self.parse_tap('not ok 1 abc # TODO')
        self.assert_test(events, number=1, name='abc', result=TestResult.EXPECTEDFAIL)
        self.assert_last(events)

        events = self.parse_tap('ok 1 abc # TODO')
        self.assert_test(events, number=1, name='abc', result=TestResult.UNEXPECTEDPASS)
        self.assert_last(events)

    def test_one_test_skip(self):
        events = self.parse_tap('ok 1 abc # SKIP')
        self.assert_test(events, number=1, name='abc', result=TestResult.SKIP)
        self.assert_last(events)

    def test_one_test_skip_failure(self):
        events = self.parse_tap('not ok 1 abc # SKIP')
        self.assert_test(events, number=1, name='abc', result=TestResult.FAIL)
        self.assert_last(events)

    def test_many_early_plan(self):
        events = self.parse_tap('1..4\nok 1\nnot ok 2\nok 3\nnot ok 4')
        self.assert_plan(events, num_tests=4, late=False)
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_test(events, number=2, name='', result=TestResult.FAIL)
        self.assert_test(events, number=3, name='', result=TestResult.OK)
        self.assert_test(events, number=4, name='', result=TestResult.FAIL)
        self.assert_last(events)

    def test_many_late_plan(self):
        events = self.parse_tap('ok 1\nnot ok 2\nok 3\nnot ok 4\n1..4')
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_test(events, number=2, name='', result=TestResult.FAIL)
        self.assert_test(events, number=3, name='', result=TestResult.OK)
        self.assert_test(events, number=4, name='', result=TestResult.FAIL)
        self.assert_plan(events, num_tests=4, late=True)
        self.assert_last(events)

    def test_directive_case(self):
        events = self.parse_tap('ok 1 abc # skip')
        self.assert_test(events, number=1, name='abc', result=TestResult.SKIP)
        self.assert_last(events)

        events = self.parse_tap('ok 1 abc # ToDo')
        self.assert_test(events, number=1, name='abc', result=TestResult.UNEXPECTEDPASS)
        self.assert_last(events)

    def test_directive_explanation(self):
        events = self.parse_tap('ok 1 abc # skip why')
        self.assert_test(events, number=1, name='abc', result=TestResult.SKIP,
                         explanation='why')
        self.assert_last(events)

        events = self.parse_tap('ok 1 abc # ToDo Because')
        self.assert_test(events, number=1, name='abc', result=TestResult.UNEXPECTEDPASS,
                         explanation='Because')
        self.assert_last(events)

    def test_one_test_early_plan(self):
        events = self.parse_tap('1..1\nok')
        self.assert_plan(events, num_tests=1, late=False)
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_last(events)

    def test_one_test_late_plan(self):
        events = self.parse_tap('ok\n1..1')
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_plan(events, num_tests=1, late=True)
        self.assert_last(events)

    def test_out_of_order(self):
        events = self.parse_tap('ok 2')
        self.assert_error(events)
        self.assert_test(events, number=2, name='', result=TestResult.OK)
        self.assert_last(events)

    def test_middle_plan(self):
        events = self.parse_tap('ok 1\n1..2\nok 2')
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_plan(events, num_tests=2, late=True)
        self.assert_error(events)
        self.assert_test(events, number=2, name='', result=TestResult.OK)
        self.assert_last(events)

    def test_too_many_plans(self):
        events = self.parse_tap('1..1\n1..2\nok 1')
        self.assert_plan(events, num_tests=1, late=False)
        self.assert_error(events)
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_last(events)

    def test_too_many(self):
        events = self.parse_tap('ok 1\nnot ok 2\n1..1')
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_test(events, number=2, name='', result=TestResult.FAIL)
        self.assert_plan(events, num_tests=1, late=True)
        self.assert_error(events)
        self.assert_last(events)

        events = self.parse_tap('1..1\nok 1\nnot ok 2')
        self.assert_plan(events, num_tests=1, late=False)
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_test(events, number=2, name='', result=TestResult.FAIL)
        self.assert_error(events)
        self.assert_last(events)

    def test_too_few(self):
        events = self.parse_tap('ok 1\nnot ok 2\n1..3')
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_test(events, number=2, name='', result=TestResult.FAIL)
        self.assert_plan(events, num_tests=3, late=True)
        self.assert_error(events)
        self.assert_last(events)

        events = self.parse_tap('1..3\nok 1\nnot ok 2')
        self.assert_plan(events, num_tests=3, late=False)
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_test(events, number=2, name='', result=TestResult.FAIL)
        self.assert_error(events)
        self.assert_last(events)

    def test_too_few_bailout(self):
        events = self.parse_tap('1..3\nok 1\nnot ok 2\nBail out! no third test')
        self.assert_plan(events, num_tests=3, late=False)
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_test(events, number=2, name='', result=TestResult.FAIL)
        self.assert_bailout(events, message='no third test')
        self.assert_last(events)

    def test_diagnostics(self):
        events = self.parse_tap('1..1\n# ignored\nok 1')
        self.assert_plan(events, num_tests=1, late=False)
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_last(events)

        events = self.parse_tap('# ignored\n1..1\nok 1\n# ignored too')
        self.assert_plan(events, num_tests=1, late=False)
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_last(events)

        events = self.parse_tap('# ignored\nok 1\n1..1\n# ignored too')
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_plan(events, num_tests=1, late=True)
        self.assert_last(events)

    def test_empty_line(self):
        events = self.parse_tap('1..1\n\nok 1')
        self.assert_plan(events, num_tests=1, late=False)
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_last(events)

    def test_unexpected(self):
        events = self.parse_tap('1..1\ninvalid\nok 1')
        self.assert_plan(events, num_tests=1, late=False)
        self.assert_unexpected(events, message='invalid', lineno=2)
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_last(events)

    def test_version(self):
        events = self.parse_tap('TAP version 13\n')
        self.assert_version(events, version=13)
        self.assert_last(events)

        events = self.parse_tap('TAP version 12\n')
        self.assert_error(events)
        self.assert_last(events)

        events = self.parse_tap('1..0\nTAP version 13\n')
        self.assert_plan(events, num_tests=0, late=False, skipped=True)
        self.assert_error(events)
        self.assert_last(events)

    def test_yaml(self):
        events = self.parse_tap_v13('ok\n ---\n foo: abc\n  bar: def\n ...\nok 2')
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_test(events, number=2, name='', result=TestResult.OK)
        self.assert_last(events)

        events = self.parse_tap_v13('ok\n ---\n foo: abc\n  bar: def')
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_error(events)
        self.assert_last(events)

        events = self.parse_tap_v13('ok 1\n ---\n foo: abc\n  bar: def\nnot ok 2')
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_error(events)
        self.assert_test(events, number=2, name='', result=TestResult.FAIL)
        self.assert_last(events)

"""

```
Response:
Let's break down the thought process for analyzing this C code and generating the explanation.

1. **Understand the Goal:** The primary goal is to explain the functionality of `gumquickeventsink.c` in the context of Frida, focusing on its relationship with reverse engineering, low-level details, and potential user errors. The request also emphasizes explaining how a user might reach this code.

2. **Initial Code Scan and High-Level Understanding:**  First, I'd quickly scan the code, looking for keywords and structures that give clues about its purpose. I see:
    * Includes like `gum.h`, `gumspinlock.h`, hinting at Frida's core functionality.
    * Struct definitions: `_GumQuickJSEventSink` and `_GumQuickNativeEventSink`. These likely represent different ways of handling events.
    * Functions with names like `process`, `start`, `stop`, `flush`, suggesting a lifecycle for event handling.
    * References to JavaScript (`JSValue`, `JSContext`), indicating interaction with a JavaScript environment.
    * `GArray`, `GMainContext`, `GSource` pointing towards GLib usage for data structures and event loops.
    * `GumEventType` suggests different types of events are being handled.

3. **Identify Key Data Structures:**  The two main structs, `_GumQuickJSEventSink` and `_GumQuickNativeEventSink`, are central. I'd analyze their members:
    * `_GumQuickJSEventSink`: Contains a queue (`GArray`), a lock (`GumSpinlock`), capacity and drain interval, references to the Frida core (`GumQuickCore`), a main context (`GMainContext`), an event mask, and JavaScript values for callbacks (`on_receive`, `on_call_summary`). This suggests it's designed for queuing events and processing them in a JavaScript environment.
    * `_GumQuickNativeEventSink`: Simpler, with just an event mask, a C function pointer (`GumQuickOnEvent`), and user data. This points to a more direct, native C callback mechanism.

4. **Trace the `gum_quick_event_sink_new` Function:** This function acts as a constructor. Its logic branches based on whether `options->on_event` is NULL. This is a crucial distinction between the JS and native sinks.

5. **Analyze Interface Implementations:** The code uses `G_IMPLEMENT_INTERFACE` to implement the `GumEventSink` interface for both sink types. This means they both provide the functions defined in `GumEventSinkInterface`. I'd note the mapping of these interface functions to the specific implementations for each sink type (e.g., `query_mask`, `process`, `start`, etc.).

6. **Focus on the `gum_quick_js_event_sink_process` Function:** This is where events are actually received. It uses a spinlock to protect the queue and appends the event. This highlights the potential for multi-threading and the need for synchronization.

7. **Understand the `gum_quick_js_event_sink_drain` Function:** This function is responsible for processing the queued events. Key observations:
    * It copies the event data to a buffer.
    * It uses `JS_NewArrayBuffer` to create a JavaScript ArrayBuffer from the event data.
    * It invokes the `on_call_summary` callback (if provided) to summarize call events. This involves iterating through the events and counting calls to different addresses. This is directly relevant to reverse engineering.
    * It invokes the `on_receive` callback to deliver the raw event data to JavaScript.
    * It uses `GumQuickScope` which likely handles setting up and tearing down the JavaScript execution environment.

8. **Understand the `gum_quick_native_event_sink_process` Function:** This is simpler. It directly calls the provided C callback function (`on_event`).

9. **Connect to Reverse Engineering:**  The `on_call_summary` functionality directly relates to reverse engineering by providing a frequency count of function calls at different addresses. This allows analysts to identify hot spots in the code and understand execution flow. The raw event data also provides valuable information about program behavior.

10. **Identify Low-Level Aspects:**
    * **Binary Level:** The `on_call_summary` deals with memory addresses. The raw event data itself likely contains register values and other low-level information.
    * **Linux/Android Kernel/Framework:** Frida often operates by injecting into processes and intercepting system calls or function calls within libraries. This code manages the delivery of events generated by that interception, bridging the gap between the low-level instrumentation and the higher-level scripting environment.
    * **Memory Management:**  The use of `g_array`, `g_memdup2`, and `JS_NewArrayBuffer` highlights memory management concerns.

11. **Consider User Errors:**
    * Incorrectly setting `queue_capacity` could lead to dropped events.
    * Providing invalid JavaScript callbacks could cause errors in the JavaScript environment.
    * Not understanding the event mask could lead to missing relevant events.
    * Issues with the main context could prevent event processing.

12. **Trace User Actions to the Code:**  Think about the typical Frida workflow:
    * A user writes a Frida script (in JavaScript).
    * The script uses Frida's API to attach to a process and set up hooks.
    * When a hooked function is called, Frida generates an event.
    * This `gumquickeventsink.c` code is part of the mechanism for delivering those events back to the JavaScript script. Specifically, the `gum_quick_event_sink_new` function is likely called when the user creates an event listener in their JavaScript code.

13. **Formulate Examples and Explanations:**  Based on the analysis, create concrete examples for each of the requested points (reverse engineering, low-level details, logic, user errors). Use clear and concise language.

14. **Review and Refine:** Read through the generated explanation to ensure accuracy, clarity, and completeness. Check that all parts of the prompt have been addressed. For instance, I might initially forget to explicitly mention spinlocks and their role in thread safety, and then add that upon review.

This systematic approach, starting with a high-level overview and progressively diving deeper into the code, helps to extract the relevant information and present it in a structured and understandable manner. It also encourages thinking about the context in which this code operates within the larger Frida framework.
好的，让我们来详细分析 `frida/subprojects/frida-gum/bindings/gumjs/gumquickeventsink.c` 这个文件。

**文件功能概述**

`gumquickeventsink.c` 文件定义了 Frida-gum 中用于快速处理事件的事件接收器 (Event Sink)。它提供了两种主要的事件接收机制：

1. **JavaScript 事件接收器 (`GumQuickJSEventSink`)**:  将捕获到的事件缓冲起来，并定期或在需要时批量发送到 JavaScript 环境中执行的回调函数。这种方式适用于需要高性能且可以容忍一定延迟的场景。
2. **原生 C 事件接收器 (`GumQuickNativeEventSink`)**:  直接将捕获到的事件通过 C 函数指针回调到原生 C 代码中。这种方式适用于需要实时处理事件或者与原生代码深度集成的场景。

**与逆向方法的关系及举例说明**

这个文件是 Frida 动态插桩工具的核心组件，与逆向方法息息相关。Frida 的主要功能就是在运行时修改程序的行为，而 `gumquickeventsink.c` 负责将 Frida-gum 引擎捕获到的程序行为（例如函数调用、内存访问等）以事件的形式传递给用户定义的脚本或回调函数。

**举例说明：**

假设我们想要逆向一个 Android 应用程序，并监控特定函数的调用情况。我们可以使用 Frida 的 JavaScript API 来实现：

```javascript
// 附加到目标进程
Java.perform(function() {
  // 获取目标类
  var targetClass = Java.use("com.example.target.TargetClass");
  // Hook 目标函数
  targetClass.targetMethod.implementation = function() {
    console.log("Target method called!");
    // 获取调用栈信息
    var currentStackTrace = Java.use("android.util.Log").getStackTraceString(Java.throwable());
    console.log(currentStackTrace);
    // 调用原始函数
    this.targetMethod();
  };
});
```

当 `targetClass.targetMethod` 被调用时，Frida-gum 引擎会捕获到这个 "函数调用" 事件。`GumQuickJSEventSink` 会将这个事件（包含函数地址、参数、返回值等信息）打包，并通过 `on_receive` 或 `on_call_summary` 回调发送到我们编写的 JavaScript 代码中，从而让我们可以在控制台上看到 "Target method called!" 的消息和调用栈信息。

在这个例子中：

* **事件捕获:** Frida-gum 引擎负责在目标进程中植入代码，当 `targetMethod` 被执行时，这段代码会生成一个事件。
* **事件传递:** `GumQuickJSEventSink` 负责接收这些事件，并根据配置选择合适的时机和方式将它们传递到 JavaScript 环境。
* **逆向分析:** 我们通过分析接收到的事件信息（例如函数调用、参数、返回值、调用栈）来理解程序的运行逻辑和行为，从而达到逆向的目的。

**涉及的二进制底层、Linux、Android 内核及框架的知识及举例说明**

`gumquickeventsink.c` 虽然本身是用 C 编写，但它与底层的交互非常密切：

1. **二进制底层知识:**
   * **函数地址:**  `GumEvent` 结构体中会包含被 hook 函数的内存地址，这需要对目标程序的内存布局有一定的了解。
   * **CPU 上下文 (`GumCpuContext`):**  事件处理函数可以访问 CPU 寄存器的值，这需要理解目标架构（例如 ARM、x86）的寄存器结构和调用约定。
   * **内存操作:**  Frida-gum 引擎本身会进行内存读写操作，以实现 hook 和数据传递。

2. **Linux 知识:**
   * **进程间通信 (IPC):**  Frida 通常运行在独立的进程中，需要通过某种 IPC 机制与目标进程进行通信，例如使用管道或共享内存。
   * **线程同步:**  代码中使用了 `GumSpinlock` 来保护共享数据结构 `queue`，这是多线程编程中常见的同步机制，用于防止竞争条件。
   * **GMainContext 和 GSource:**  `GumQuickJSEventSink` 使用 GLib 的事件循环机制，将事件处理集成到主事件循环中。

3. **Android 内核及框架知识:**
   * **ART (Android Runtime):**  当 hook Java 代码时，Frida 需要与 ART 虚拟机进行交互，理解其内部结构和机制。
   * **系统调用:**  Frida 可以 hook 系统调用，从而监控应用程序与内核的交互。
   * **Binder:**  Android 中进程间通信的主要机制，Frida 可以监控 Binder 调用。

**举例说明：**

在 `gum_quick_js_event_sink_process` 函数中，当一个事件发生时，会调用 `g_array_append_val` 将事件添加到队列中。这需要理解内存分配和数组操作的基本原理。`gum_spinlock_acquire` 和 `gum_spinlock_release` 调用展示了对线程同步的考虑，因为事件可能由不同的线程生成。

在 `gum_quick_js_event_sink_drain` 函数中，如果启用了 `on_call_summary`，代码会遍历事件队列，统计不同目标地址的函数调用频率。这直接涉及对程序二进制代码的理解，以及如何识别和解析函数调用事件。

**逻辑推理、假设输入与输出**

**假设输入：**

* 启用了 JavaScript 事件接收器。
* 设置了 `queue_capacity` 为 10，`queue_drain_interval` 为 100 毫秒。
* 目标程序在短时间内触发了 15 个事件（例如 15 次函数调用）。

**逻辑推理：**

1. 前 10 个事件会被快速添加到 `queue` 中，因为队列还有空间。
2. 在第一个 100 毫秒到达时，`gum_quick_js_event_sink_drain` 函数会被 `g_timeout_source_new` 创建的定时器触发。
3. `gum_quick_js_event_sink_drain` 会将队列中的 10 个事件取出，并通过 `on_receive` 或 `on_call_summary` 回调发送到 JavaScript 环境。
4. 剩余的 5 个事件会继续被添加到队列中。
5. 如果在下一个 100 毫秒到达之前，又有新的事件发生，它们也会被添加到队列，直到队列满或定时器再次触发。
6. 如果事件产生的速度超过队列处理的速度，并且队列已满，那么新的事件可能会被丢弃（在 `gum_quick_js_event_sink_process` 中有判断 `self->queue->len != self->queue_capacity`）。

**输出：**

* JavaScript 回调函数会收到多次事件批处理，每次最多包含 10 个事件。
* 如果事件产生速度过快，可能会丢失部分事件。
* 通过 `on_call_summary` 回调，JavaScript 代码可以获得一个对象，其中包含了不同函数地址的调用次数统计。

**用户或编程常见的使用错误及举例说明**

1. **队列容量设置过小 (`queue_capacity`)**: 如果将 `queue_capacity` 设置得太小，在高频事件发生时，可能会导致事件被快速填满，后续的事件会被丢弃，从而丢失重要的监控信息。
   * **错误示例:**  用户设置 `queue_capacity` 为 1，但目标程序在极短时间内调用了同一个 hook 函数 10 次。结果是，用户只能收到第一次调用的事件，后续 9 次的事件都被丢弃了。

2. **回调函数处理缓慢 (`on_receive` 或 `on_call_summary`)**: 如果 JavaScript 回调函数执行时间过长，会导致事件队列积压，最终可能导致内存消耗过高或者事件处理不及时。
   * **错误示例:**  用户在 `on_receive` 回调中执行了大量的同步操作或者复杂的计算，导致回调函数执行时间超过了事件产生的速度。结果是，事件队列越来越长，最终可能导致 Frida 进程崩溃或目标程序性能下降。

3. **未正确处理事件类型 (`event_mask`)**: 用户可能没有正确设置 `event_mask`，导致错过了某些类型的事件或者接收了不关心的事件，影响分析效率。
   * **错误示例:**  用户只想监控函数调用事件，但 `event_mask` 设置为监听所有事件类型。结果是，回调函数会收到大量的内存访问事件，干扰了对函数调用事件的分析。

4. **在 JavaScript 回调中进行阻塞操作**: 在 JavaScript 回调函数中执行阻塞操作（例如同步网络请求）会严重影响事件处理的效率，并可能导致 Frida 连接超时。
   * **错误示例:**  用户在 `on_receive` 回调中尝试同步发送 HTTP 请求到远程服务器，如果网络延迟较高，会导致 Frida 的事件循环被阻塞，无法及时处理后续的事件。

**用户操作是如何一步步到达这里的调试线索**

要理解用户操作如何触发到 `gumquickeventsink.c` 的执行，需要了解 Frida 的工作流程：

1. **用户编写 Frida 脚本 (JavaScript):** 用户使用 Frida 的 JavaScript API 来定义他们想要监控或修改的目标程序行为。这通常涉及到使用 `Interceptor` 或 `Java.perform` 等 API 来设置 hook。

2. **Frida CLI 或 API 执行脚本:** 用户通过 Frida 的命令行工具 (`frida`) 或者编程 API (例如 Python 绑定) 将脚本注入到目标进程中。

3. **Frida-gum 引擎初始化:**  注入到目标进程的 Frida Agent 会初始化 Frida-gum 引擎。

4. **创建事件接收器:** 当用户在 JavaScript 脚本中使用 Frida 的 API 设置 hook 时，Frida-gum 引擎会根据配置创建相应的事件接收器。如果用户没有显式指定使用原生回调，那么通常会创建 `GumQuickJSEventSink`。创建 `GumQuickJSEventSink` 的过程会调用 `gum_quick_event_sink_new` 函数，这是我们分析的起点。在 `gum_quick_event_sink_new` 中，会根据 `options->on_event` 是否为空来决定创建哪种类型的事件接收器。对于 JavaScript 绑定，`options->on_receive` 和 `options->on_call_summary` 会被设置为用户提供的 JavaScript 回调函数。

5. **事件捕获与处理:** 当目标程序执行到被 hook 的代码时，Frida-gum 引擎会捕获相应的事件（例如函数调用、内存访问）。

6. **事件进入事件接收器:** 捕获到的事件会被传递到相应的事件接收器的 `process` 方法 (`gum_quick_js_event_sink_process` 或 `gum_quick_native_event_sink_process`)。对于 `GumQuickJSEventSink`，事件会被添加到队列中。

7. **事件刷新 (Drain):**
   * **定时刷新:** 如果设置了 `queue_drain_interval`，`g_timeout_source_new` 创建的定时器会定期触发 `gum_quick_js_event_sink_drain`，将队列中的事件发送到 JavaScript 回调。
   * **手动刷新:** 用户也可以通过 Frida 的 API 显式调用刷新操作。
   * **队列满刷新:** 当事件队列达到 `queue_capacity` 时，也可能触发刷新操作。

8. **JavaScript 回调执行:** `gum_quick_js_event_sink_drain` 函数会将事件数据转换为 JavaScript 可以处理的格式（例如 `ArrayBuffer`），并调用用户提供的 `on_receive` 或 `on_call_summary` 回调函数，将事件数据传递给 JavaScript 代码进行进一步处理和分析。

**调试线索:**

* **查看 Frida 脚本:**  检查用户编写的 Frida 脚本，特别是使用了哪些 Frida API 来设置 hook，以及是否定义了事件回调函数。
* **检查 Frida-gum 配置:**  查看 Frida-gum 的配置参数，例如 `queue_capacity` 和 `queue_drain_interval` 的设置。
* **使用 Frida 的日志功能:**  Frida 提供了一些日志输出，可以用来跟踪事件的捕获和传递过程。
* **在 `gumquickeventsink.c` 中添加调试信息:**  可以在关键函数（例如 `gum_quick_event_sink_new`, `gum_quick_js_event_sink_process`, `gum_quick_js_event_sink_drain`) 中添加 `printf` 或 `g_debug` 等调试语句，以便观察事件的处理流程和数据。
* **使用 GDB 调试 Frida Agent:**  如果需要深入了解 Frida-gum 的内部行为，可以使用 GDB 等调试器附加到 Frida Agent 进程，并设置断点来跟踪代码执行。

总而言之，`gumquickeventsink.c` 是 Frida-gum 中至关重要的组件，它负责将底层捕获到的程序行为以事件的形式传递给用户，为动态逆向分析提供了基础。理解其功能和工作原理，有助于我们更好地利用 Frida 进行安全研究和漏洞分析。

Prompt: 
```
这是目录为frida/subprojects/frida-gum/bindings/gumjs/gumquickeventsink.c的fridaDynamic instrumentation tool的源代码文件， 请列举一下它的功能, 
如果它与逆向的方法有关系，请做出对应的举例说明，
如果涉及到二进制底层，linux, android内核及框架的知识，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索。

"""
/*
 * Copyright (C) 2020-2024 Ole André Vadla Ravnås <oleavr@nowsecure.com>
 * Copyright (C) 2024 Alex Soler <asoler@nowsecure.com>
 * Copyright (C) 2024 Francesco Tamagni <mrmacete@protonmail.ch>
 *
 * Licence: wxWindows Library Licence, Version 3.1
 */

#include "gumquickeventsink.h"

#include "gumquickvalue.h"

#include <gum/gumspinlock.h>
#include <string.h>

struct _GumQuickJSEventSink
{
  GObject parent;

  GumSpinlock lock;
  GArray * queue;
  guint queue_capacity;
  guint queue_drain_interval;

  GumQuickCore * core;
  GMainContext * main_context;
  GumEventType event_mask;
  JSValue on_receive;
  JSValue on_call_summary;
  GSource * source;
};

struct _GumQuickNativeEventSink
{
  GObject parent;

  GumEventType event_mask;
  GumQuickOnEvent on_event;
  gpointer user_data;
};

static void gum_quick_js_event_sink_iface_init (gpointer g_iface,
    gpointer iface_data);
static void gum_quick_js_event_sink_dispose (GObject * obj);
static void gum_quick_js_event_sink_finalize (GObject * obj);
static GumEventType gum_quick_js_event_sink_query_mask (GumEventSink * sink);
static void gum_quick_js_event_sink_start (GumEventSink * sink);
static void gum_quick_js_event_sink_process (GumEventSink * sink,
    const GumEvent * event, GumCpuContext * cpu_context);
static void gum_quick_js_event_sink_flush (GumEventSink * sink);
static void gum_quick_js_event_sink_stop (GumEventSink * sink);
static gboolean gum_quick_js_event_sink_stop_when_idle (
    GumQuickJSEventSink * self);
static gboolean gum_quick_js_event_sink_drain (GumQuickJSEventSink * self);

static void gum_quick_native_event_sink_iface_init (gpointer g_iface,
    gpointer iface_data);
static GumEventType gum_quick_native_event_sink_query_mask (
    GumEventSink * sink);
static void gum_quick_native_event_sink_process (GumEventSink * sink,
    const GumEvent * event, GumCpuContext * cpu_context);

G_DEFINE_TYPE_EXTENDED (GumQuickJSEventSink,
                        gum_quick_js_event_sink,
                        G_TYPE_OBJECT,
                        0,
                        G_IMPLEMENT_INTERFACE (GUM_TYPE_EVENT_SINK,
                            gum_quick_js_event_sink_iface_init))

G_DEFINE_TYPE_EXTENDED (GumQuickNativeEventSink,
                        gum_quick_native_event_sink,
                        G_TYPE_OBJECT,
                        0,
                        G_IMPLEMENT_INTERFACE (GUM_TYPE_EVENT_SINK,
                            gum_quick_native_event_sink_iface_init))

GumEventSink *
gum_quick_event_sink_new (JSContext * ctx,
                          const GumQuickEventSinkOptions * options)
{
  if (options->on_event != NULL)
  {
    GumQuickNativeEventSink * sink;

    sink = g_object_new (GUM_QUICK_TYPE_NATIVE_EVENT_SINK, NULL);

    sink->event_mask = options->event_mask;
    sink->on_event = options->on_event;
    sink->user_data = options->user_data;

    return GUM_EVENT_SINK (sink);
  }
  else
  {
    GumQuickJSEventSink * sink;

    sink = g_object_new (GUM_QUICK_TYPE_JS_EVENT_SINK, NULL);

    sink->queue = g_array_sized_new (FALSE, FALSE, sizeof (GumEvent),
        options->queue_capacity);
    sink->queue_capacity = options->queue_capacity;
    sink->queue_drain_interval = options->queue_drain_interval;

    g_object_ref (options->core->script);
    sink->core = options->core;
    sink->main_context = options->main_context;
    sink->event_mask = options->event_mask;

    sink->on_receive = JS_DupValue (ctx, options->on_receive);
    sink->on_call_summary = JS_DupValue (ctx, options->on_call_summary);

    return GUM_EVENT_SINK (sink);
  }
}

static void
gum_quick_js_event_sink_class_init (GumQuickJSEventSinkClass * klass)
{
  GObjectClass * object_class = G_OBJECT_CLASS (klass);

  object_class->dispose = gum_quick_js_event_sink_dispose;
  object_class->finalize = gum_quick_js_event_sink_finalize;
}

static void
gum_quick_js_event_sink_iface_init (gpointer g_iface,
                                    gpointer iface_data)
{
  GumEventSinkInterface * iface = g_iface;

  iface->query_mask = gum_quick_js_event_sink_query_mask;
  iface->start = gum_quick_js_event_sink_start;
  iface->process = gum_quick_js_event_sink_process;
  iface->flush = gum_quick_js_event_sink_flush;
  iface->stop = gum_quick_js_event_sink_stop;
}

static void
gum_quick_js_event_sink_init (GumQuickJSEventSink * self)
{
  gum_spinlock_init (&self->lock);
}

static void
gum_quick_js_event_sink_release_core (GumQuickJSEventSink * self)
{
  GumQuickCore * core;

  core = g_steal_pointer (&self->core);
  if (core == NULL)
    return;

  {
    JSContext * ctx = core->ctx;
    GumQuickScope scope;

    _gum_quick_scope_enter (&scope, core);

    JS_FreeValue (ctx, self->on_receive);
    JS_FreeValue (ctx, self->on_call_summary);
    self->on_receive = JS_NULL;
    self->on_call_summary = JS_NULL;

    _gum_quick_scope_leave (&scope);
  }

  g_object_unref (core->script);
}

static void
gum_quick_js_event_sink_dispose (GObject * obj)
{
  gum_quick_js_event_sink_release_core (GUM_QUICK_JS_EVENT_SINK (obj));

  G_OBJECT_CLASS (gum_quick_js_event_sink_parent_class)->dispose (obj);
}

static void
gum_quick_js_event_sink_finalize (GObject * obj)
{
  GumQuickJSEventSink * self = GUM_QUICK_JS_EVENT_SINK (obj);

  g_assert (self->source == NULL);

  g_array_free (self->queue, TRUE);

  G_OBJECT_CLASS (gum_quick_js_event_sink_parent_class)->finalize (obj);
}

static GumEventType
gum_quick_js_event_sink_query_mask (GumEventSink * sink)
{
  return GUM_QUICK_JS_EVENT_SINK (sink)->event_mask;
}

static void
gum_quick_js_event_sink_start (GumEventSink * sink)
{
  GumQuickJSEventSink * self = GUM_QUICK_JS_EVENT_SINK (sink);

  if (self->queue_drain_interval != 0)
  {
    self->source = g_timeout_source_new (self->queue_drain_interval);
    g_source_set_callback (self->source,
        (GSourceFunc) gum_quick_js_event_sink_drain, g_object_ref (self),
        g_object_unref);
    g_source_attach (self->source, self->main_context);
  }
}

static void
gum_quick_js_event_sink_process (GumEventSink * sink,
                                 const GumEvent * event,
                                 GumCpuContext * cpu_context)
{
  GumQuickJSEventSink * self = GUM_QUICK_JS_EVENT_SINK_CAST (sink);

  gum_spinlock_acquire (&self->lock);
  if (self->queue->len != self->queue_capacity)
    g_array_append_val (self->queue, *event);
  gum_spinlock_release (&self->lock);
}

static void
gum_quick_js_event_sink_flush (GumEventSink * sink)
{
  GumQuickJSEventSink * self = GUM_QUICK_JS_EVENT_SINK (sink);

  if (self->core == NULL)
    return;

  gum_quick_js_event_sink_drain (self);
}

static void
gum_quick_js_event_sink_stop (GumEventSink * sink)
{
  GumQuickJSEventSink * self = GUM_QUICK_JS_EVENT_SINK (sink);

  if (g_main_context_is_owner (self->main_context))
  {
    gum_quick_js_event_sink_stop_when_idle (self);
  }
  else
  {
    GSource * source;

    source = g_idle_source_new ();
    g_source_set_callback (source,
        (GSourceFunc) gum_quick_js_event_sink_stop_when_idle,
        g_object_ref (self), g_object_unref);
    g_source_attach (source, self->main_context);
    g_source_unref (source);
  }
}

static gboolean
gum_quick_js_event_sink_stop_when_idle (GumQuickJSEventSink * self)
{
  gum_quick_js_event_sink_drain (self);

  g_object_ref (self);

  if (self->source != NULL)
  {
    g_source_destroy (self->source);
    g_source_unref (self->source);
    self->source = NULL;
  }

  gum_quick_js_event_sink_release_core (self);

  g_object_unref (self);

  return FALSE;
}

static gboolean
gum_quick_js_event_sink_drain (GumQuickJSEventSink * self)
{
  GumQuickCore * core = self->core;
  JSContext * ctx = core->ctx;
  gpointer buffer_data;
  JSValue buffer_val;
  guint len, size;
  GumQuickScope scope;

  if (core == NULL)
    return FALSE;

  len = self->queue->len;
  if (len == 0)
    return TRUE;
  size = len * sizeof (GumEvent);

  buffer_data = g_memdup2 (self->queue->data, size);

  gum_spinlock_acquire (&self->lock);
  g_array_remove_range (self->queue, 0, len);
  gum_spinlock_release (&self->lock);

  _gum_quick_scope_enter (&scope, core);

  buffer_val = JS_NewArrayBuffer (ctx, buffer_data, size,
      _gum_quick_array_buffer_free, buffer_data, FALSE);

  if (!JS_IsNull (self->on_call_summary))
  {
    JSValue callback;
    JSValue summary;
    GHashTable * frequencies;
    GumCallEvent * ev;
    guint i;
    GHashTableIter iter;
    gpointer target, count;
    gchar target_str[32];

    callback = JS_DupValue (ctx, self->on_call_summary);

    summary = JS_NewObject (ctx);

    frequencies = g_hash_table_new (NULL, NULL);

    ev = buffer_data;
    for (i = 0; i != len; i++)
    {
      if (ev->type == GUM_CALL)
      {
        gsize n;

        n = GPOINTER_TO_SIZE (g_hash_table_lookup (frequencies, ev->target));
        n++;
        g_hash_table_insert (frequencies, ev->target, GSIZE_TO_POINTER (n));
      }

      ev++;
    }

    g_hash_table_iter_init (&iter, frequencies);
    while (g_hash_table_iter_next (&iter, &target, &count))
    {
      sprintf (target_str, "0x%" G_GSIZE_MODIFIER "x",
          GPOINTER_TO_SIZE (target));
      JS_DefinePropertyValueStr (ctx, summary,
          target_str,
          JS_NewInt32 (ctx, GPOINTER_TO_SIZE (count)),
          JS_PROP_C_W_E);
    }

    g_hash_table_unref (frequencies);

    _gum_quick_scope_call_void (&scope, callback, JS_UNDEFINED, 1, &summary);

    JS_FreeValue (ctx, summary);
    JS_FreeValue (ctx, callback);
  }

  if (!JS_IsNull (self->on_receive))
  {
    JSValue callback = JS_DupValue (ctx, self->on_receive);

    _gum_quick_scope_call_void (&scope, callback, JS_UNDEFINED, 1, &buffer_val);

    JS_FreeValue (ctx, callback);
  }

  JS_FreeValue (ctx, buffer_val);

  _gum_quick_scope_leave (&scope);

  return TRUE;
}

static void
gum_quick_native_event_sink_class_init (GumQuickNativeEventSinkClass * klass)
{
}

static void
gum_quick_native_event_sink_iface_init (gpointer g_iface,
                                        gpointer iface_data)
{
  GumEventSinkInterface * iface = g_iface;

  iface->query_mask = gum_quick_native_event_sink_query_mask;
  iface->process = gum_quick_native_event_sink_process;
}

static void
gum_quick_native_event_sink_init (GumQuickNativeEventSink * self)
{
}

static GumEventType
gum_quick_native_event_sink_query_mask (GumEventSink * sink)
{
  return GUM_QUICK_NATIVE_EVENT_SINK (sink)->event_mask;
}

static void
gum_quick_native_event_sink_process (GumEventSink * sink,
                                     const GumEvent * event,
                                     GumCpuContext * cpu_context)
{
  GumQuickNativeEventSink * self = GUM_QUICK_NATIVE_EVENT_SINK_CAST (sink);

  self->on_event (event, cpu_context, self->user_data);
}

"""

```
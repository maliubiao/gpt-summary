Response:
Let's break down the thought process for analyzing this C code and fulfilling the request.

**1. Understanding the Goal:**

The primary goal is to understand the functionality of the `gumquickscriptbackend.c` file within the Frida dynamic instrumentation framework. This involves identifying its purpose, how it interacts with other parts of Frida, and how it might be used in reverse engineering and related contexts.

**2. Initial Code Scan and Keyword Spotting:**

The first step is a quick scan of the code, looking for key terms and patterns. This helps establish the general domain and some of the core operations. Keywords like:

* `GumQuickScriptBackend`, `GumScriptBackend`, `GumScript`
* `JSContext`, `JSRuntime`, `JSValue`, `JSModuleDef` (suggesting JavaScript execution)
* `compile`, `create`, `snapshot`, `bytes`, `source` (indicating core script manipulation functions)
* `GBytes`, `GError`, `GCancellable`, `GAsyncReadyCallback` (indicating use of GLib, likely for asynchronous operations and error handling)
* `GMutex`, `GRecMutex` (indicating thread safety and synchronization)
* `malloc`, `free`, `realloc` (related to memory management, and the `#ifndef HAVE_ASAN` block is interesting)
* `linux`, `android` (part of the prompt, so keep an eye out for relevant connections)

**3. Identifying Core Data Structures:**

The code defines several structs. Understanding these is crucial:

* `GumQuickScriptBackend`: The central object, containing mutexes and a scheduler. This likely manages the overall lifecycle of JavaScript execution.
* `GumCompileProgramOperation`, `GumCreateScriptData`, etc.: These structs seem to be used for passing data to asynchronous operations, holding information needed for compiling, creating, and snapshotting scripts.

**4. Analyzing Function Groups:**

The code is organized into logical blocks of functions related to specific actions:

* **Object Lifecycle (`_class_init`, `_iface_init`, `_init`, `_dispose`, `_finalize`):** Standard GLib object management.
* **Runtime Creation (`gum_quick_script_backend_make_runtime`):** Deals with setting up the QuickJS runtime. The ASAN block is important here.
* **Compilation (`gum_quick_script_backend_compile_program`, `gum_normalize_module_name_*`, `gum_load_module_*`, `gum_compile_module`):**  This is a significant section. It handles the process of taking JavaScript source code and turning it into an executable form. The handling of modules and "packages" within the source is a key detail.
* **Script Creation (`gum_quick_script_backend_create*`, `gum_create_script_task_*`):** Functions for creating `GumScript` objects from source code or bytecode, potentially using snapshots.
* **Compilation (Backend Interface) (`gum_quick_script_backend_compile*`, `gum_compile_script_task_*`):** Functions for compiling JavaScript source into bytecode.
* **Snapshotting (`gum_quick_script_backend_snapshot*`, `gum_snapshot_script_task_*`):** Functions for creating snapshots of the JavaScript runtime state.
* **Synchronization (`gum_quick_script_backend_with_lock_held`, `gum_quick_script_backend_is_locked`, `gum_quick_script_backend_get_scope_mutex`):** Functions for managing thread safety.
* **Utility Functions (`gum_es_program_new`, `gum_es_program_normalize_module_name`, `gum_capture_parse_error`):**  Helper functions for internal operations.

**5. Tracing Asynchronous Operations:**

Notice the consistent pattern of `*_async`, `*_finish`, and `*_sync` functions, along with `GumScriptTask`. This indicates that many operations are performed asynchronously using a task-based system. This is typical for UI frameworks or systems where blocking the main thread is undesirable.

**6. Connecting to Reverse Engineering:**

Think about how these functions could be used in a reverse engineering context:

* **`create` and `create_from_bytes`:**  Allow loading and executing JavaScript code into a target process. This is the fundamental mechanism for Frida's dynamic instrumentation.
* **`compile`:** Could be used to analyze JavaScript code without executing it, examining the generated bytecode.
* **`snapshot`:** Less directly related to typical reverse engineering, but could be useful for saving and restoring the state of a JavaScript environment.
* **Module handling:**  Understanding how Frida handles JavaScript modules is crucial for interacting with complex JavaScript applications.

**7. Identifying Low-Level and Kernel Connections:**

* **Binary Underpinnings:** The `compile` functions deal directly with the QuickJS JavaScript engine, which operates at a lower level than typical scripting. The bytecode generation and reading are direct interactions with this engine.
* **Linux/Android:** The presence of pthreads-like mutexes (`GMutex`, `GRecMutex`) suggests a multithreaded environment, common in Linux and Android. The concept of a "scheduler" also points to operating system level concerns. While the code doesn't have explicit kernel calls, it provides the *foundation* for interacting with application code running on these platforms.
* **Framework Knowledge:**  The code is part of Frida, a dynamic instrumentation *framework*. Understanding how Frida injects and executes code within a target process is essential for understanding the context of this file.

**8. Logical Reasoning and Examples:**

Consider specific scenarios and how the functions would behave:

* **`compile_program` with a package:**  Imagine a JavaScript file that `import`s other local modules. How does Frida resolve these? The package format and the module loading functions handle this.
* **`create_from_bytes`:** What if you've already compiled the script and just want to run it quickly? This function allows loading pre-compiled bytecode.
* **Error handling:**  The code uses `GError` extensively. Think about the different types of errors that could occur (parsing, module not found, etc.) and how they are reported.

**9. User Errors and Debugging:**

Consider common mistakes a user might make when using Frida:

* **Incorrect script syntax:** This would likely lead to errors during compilation.
* **Trying to use snapshots with QuickJS (not supported).**
* **Providing invalid bytecode.**

Think about how a developer would debug issues related to script loading or execution. The function names and the error messages provide clues.

**10. Step-by-Step User Interaction:**

Imagine the steps a user takes when using Frida to inject a script:

1. Write a JavaScript script using the Frida API.
2. Use the Frida client (Python, CLI) to target a process.
3. The Frida client communicates with the Frida agent running inside the target process.
4. The agent uses the `GumQuickScriptBackend` (or similar) to load and execute the provided JavaScript script.

**11. Summarization (Part 1):**

Finally, synthesize the key findings into a concise summary of the file's functionality. Focus on the core responsibilities: managing the QuickJS runtime, compiling and creating scripts from source or bytecode, and handling module loading.

**Self-Correction/Refinement During Analysis:**

* **Initial thought:**  Maybe this file directly handles injection. **Correction:**  It's a *backend* for script execution. The actual injection is handled by other parts of Frida.
* **Focusing too much on low-level details:** **Refinement:** While important, the high-level functionality (compilation, creation) is the primary focus of the request.
* **Overlooking the asynchronous nature of operations:** **Correction:** Explicitly mention the use of `GumScriptTask` and the asynchronous pattern.

By following these steps, combining code analysis with an understanding of the broader Frida architecture and common reverse engineering practices, we can arrive at a comprehensive and accurate description of the `gumquickscriptbackend.c` file's functionality.
```c
/*
 * Copyright (C) 2020-2024 Ole André Vadla Ravnås <oleavr@nowsecure.com>
 * Copyright (C) 2020 Francesco Tamagni <mrmacete@protonmail.ch>
 *
 * Licence: wxWindows Library Licence, Version 3.1
 */

#include "gumquickscriptbackend.h"

#include "gumquickscript.h"
#include "gumquickscriptbackend-priv.h"
#include "gumscripttask.h"

#include <stdlib.h>
#include <string.h>

// ... (rest of the code)
```

This is the first part of the `gumquickscriptbackend.c` source code file, which is a crucial component of Frida's dynamic instrumentation capabilities, specifically for handling JavaScript scripts using the QuickJS engine.

**Functionality of `gumquickscriptbackend.c` (Part 1):**

This part of the file primarily focuses on the **structure definition and initialization** of the `GumQuickScriptBackend` object and related data structures, along with **defining the interface** that this backend implements. It sets the stage for the core functionalities that will be detailed in the subsequent parts.

Here's a breakdown of the key functionalities evident in this section:

1. **Defines the `GumQuickScriptBackend` object:** This object is the core of this backend. It holds:
   - `GMutex mutex`: A standard mutex for thread synchronization, ensuring exclusive access to shared resources.
   - `GRecMutex scope_mutex`: A recursive mutex, likely used for managing nested locking scenarios, potentially related to JavaScript execution scopes.
   - `gboolean scope_mutex_trapped`: A flag to indicate if the `scope_mutex` is currently held.
   - `GumScriptScheduler * scheduler`: A reference to a scheduler object, responsible for managing the execution of script tasks, likely in a separate thread.

2. **Defines data structures for asynchronous operations:**  It introduces structs like `GumCompileProgramOperation`, `GumCreateScriptData`, etc. These structures are used to encapsulate the necessary data for various asynchronous operations like compiling and creating scripts. This is a common pattern in GObject-based programming for managing asynchronous tasks.

3. **Declares static functions for implementing the `GumScriptBackend` interface:** The code declares several static functions that start with `gum_quick_script_backend_`. These functions will implement the abstract methods defined in the `GumScriptBackend` interface. This includes functions for:
   - Creating scripts from source code or bytecode.
   - Compiling scripts.
   - Creating snapshots of the script's state (though later parts indicate this is not fully supported by QuickJS).
   - Managing locks.

4. **Implements the GObject type system:**  The `G_DEFINE_TYPE_EXTENDED` macro sets up the necessary infrastructure for `GumQuickScriptBackend` to be a GObject, enabling features like inheritance, signal handling, and property management within the GLib framework.

5. **Initializes the `GumScriptBackend` interface:** The `gum_quick_script_backend_iface_init` function associates the declared static functions with the methods defined in the `GumScriptBackendInterface`. This is how the concrete implementation is linked to the abstract interface.

6. **Implements basic object lifecycle management:** `gum_quick_script_backend_class_init`, `gum_quick_script_backend_init`, `gum_quick_script_backend_dispose`, and `gum_quick_script_backend_finalize` handle the creation, initialization, and destruction of `GumQuickScriptBackend` objects, including managing the mutexes and the scheduler reference.

**Relationship to Reverse Engineering:**

While this specific section doesn't directly perform reverse engineering actions, it provides the foundational building blocks for it.

* **Script Execution:** The structures and interface definitions lay the groundwork for loading and executing JavaScript code within a target process. This is a core technique in dynamic instrumentation for observing and manipulating application behavior.
* **Interception and Modification:** By executing JavaScript within the target process, reverse engineers can intercept function calls, modify data, and alter the program's control flow. The `GumQuickScriptBackend` is the engine that enables this within the Frida framework.

**Relationship to Binary 底层, Linux, Android 内核及框架知识:**

* **Binary 底层:** The concepts of memory management (through `malloc`, `free`, `realloc` hints at lower-level interactions, although these are abstracted by QuickJS). The later sections dealing with bytecode compilation and execution will be more directly related to binary operations.
* **Linux/Android:**
    * **Pthreads (via GLib):** The use of `GMutex` and `GRecMutex` indicates the need for thread synchronization, which is a fundamental concept in Linux and Android application development, often implemented using pthreads.
    * **Framework Integration:** This code integrates with the broader Frida framework. On Android, Frida often works by injecting an agent (which includes this code) into the target application's process. Understanding the Android application framework (Dalvik/ART, application lifecycle) is crucial for understanding how Frida operates within this environment.
    * **Inter-process Communication (Indirect):** While not directly visible here, the `GumScriptScheduler` likely interacts with mechanisms for scheduling tasks and potentially communicating between different parts of the Frida agent or with the Frida client. This often involves OS-level primitives.

**Logical Reasoning, Assumptions, and Potential Inputs/Outputs:**

* **Assumption:** The `GumScriptScheduler` is responsible for managing the execution of tasks in a non-blocking manner, likely on a separate thread.
* **Input (to the backend):**  JavaScript source code as a string, or compiled bytecode as a `GBytes` object.
* **Potential Output (from the backend):** A `GumScript` object representing the loaded and potentially running script, or an error if the script cannot be loaded or compiled.

**User or Programming Common Usage Errors:**

This section doesn't directly involve user interaction, but it sets the stage for potential errors:

* **Incorrect usage of the `GumScriptBackend` interface:**  A developer might try to call the interface methods with invalid arguments (e.g., `NULL` source code).
* **Thread safety issues:** If developers interacting with the `GumQuickScriptBackend` don't properly handle locking around shared resources, race conditions could occur. The presence of mutexes indicates that thread safety is a concern.

**User Operations Leading Here (Debugging Clues):**

A user would typically reach this code indirectly through the Frida API. Here's a possible sequence:

1. **User writes a Frida script in JavaScript:** This is the starting point.
2. **User uses the Frida client (Python, CLI) to attach to a target process.**
3. **User instructs Frida to load and execute the script.**  This is where the `GumScriptBackend` comes into play.
4. **The Frida client communicates with the Frida agent injected into the target process.**
5. **The Frida agent needs to load and execute the provided JavaScript.**  It will use a concrete implementation of `GumScriptBackend`, which in this case is `GumQuickScriptBackend`.
6. **The agent will call methods on the `GumScriptBackend` interface (e.g., `create`, `compile`) to handle the script.**

If a debugging session leads to this file, it likely means there's an issue with how Frida is managing or executing JavaScript scripts using the QuickJS engine. The mutexes and task scheduling mechanisms could be points of investigation for concurrency-related bugs.

**Summary of Functionality (Part 1):**

The first part of `gumquickscriptbackend.c` defines the structure and foundational elements of the `GumQuickScriptBackend`. It establishes the object model, defines the interface it implements (`GumScriptBackend`), and sets up the basic lifecycle management. It introduces the core data structures needed for asynchronous script operations and highlights the importance of thread synchronization. This section lays the groundwork for the subsequent parts of the file, which will detail the actual script loading, compilation, and execution logic.

Prompt: 
```
这是目录为frida/subprojects/frida-gum/bindings/gumjs/gumquickscriptbackend.c的fridaDynamic instrumentation tool的源代码文件， 请列举一下它的功能, 
如果它与逆向的方法有关系，请做出对应的举例说明，
如果涉及到二进制底层，linux, android内核及框架的知识，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索。
这是第1部分，共2部分，请归纳一下它的功能

"""
/*
 * Copyright (C) 2020-2024 Ole André Vadla Ravnås <oleavr@nowsecure.com>
 * Copyright (C) 2020 Francesco Tamagni <mrmacete@protonmail.ch>
 *
 * Licence: wxWindows Library Licence, Version 3.1
 */

#include "gumquickscriptbackend.h"

#include "gumquickscript.h"
#include "gumquickscriptbackend-priv.h"
#include "gumscripttask.h"

#include <stdlib.h>
#include <string.h>

typedef struct _GumCompileProgramOperation GumCompileProgramOperation;
typedef struct _GumCreateScriptData GumCreateScriptData;
typedef struct _GumCreateScriptFromBytesData GumCreateScriptFromBytesData;
typedef struct _GumCompileScriptData GumCompileScriptData;
typedef struct _GumSnapshotScriptData GumSnapshotScriptData;

struct _GumQuickScriptBackend
{
  GObject parent;

  GMutex mutex;
  GRecMutex scope_mutex;
  gboolean scope_mutex_trapped;

  GumScriptScheduler * scheduler;
};

struct _GumCompileProgramOperation
{
  GumESProgram * program;
  GError * error;
};

struct _GumCreateScriptData
{
  gchar * name;
  gchar * source;
  GBytes * snapshot;
};

struct _GumCreateScriptFromBytesData
{
  GBytes * bytes;
  GBytes * snapshot;
};

struct _GumCompileScriptData
{
  gchar * name;
  gchar * source;
};

struct _GumSnapshotScriptData
{
  gchar * embed_script;
  gchar * warmup_script;
};

static void gum_quick_script_backend_iface_init (gpointer g_iface,
    gpointer iface_data);
static void gum_quick_script_backend_dispose (GObject * object);
static void gum_quick_script_backend_finalize (GObject * object);

static char * gum_normalize_module_name_during_compilation (JSContext * ctx,
    const char * base_name, const char * name, void * opaque);
static char * gum_normalize_module_name_during_runtime (JSContext * ctx,
    const char * base_name, const char * name, void * opaque);
static JSModuleDef * gum_load_module_during_compilation (JSContext * ctx,
    const char * module_name, void * opaque);
static JSModuleDef * gum_load_module_during_runtime (JSContext * ctx,
    const char * module_name, void * opaque);
static JSValue gum_compile_module (JSContext * ctx, const GumESAsset * asset);

static void gum_quick_script_backend_create (GumScriptBackend * backend,
    const gchar * name, const gchar * source, GBytes * snapshot,
    GCancellable * cancellable, GAsyncReadyCallback callback,
    gpointer user_data);
static GumScript * gum_quick_script_backend_create_finish (
    GumScriptBackend * backend, GAsyncResult * result, GError ** error);
static GumScript * gum_quick_script_backend_create_sync (
    GumScriptBackend * backend, const gchar * name, const gchar * source,
    GBytes * snapshot, GCancellable * cancellable, GError ** error);
static GumScriptTask * gum_create_script_task_new (
    GumQuickScriptBackend * backend, const gchar * name, const gchar * source,
    GBytes * snapshot, GCancellable * cancellable, GAsyncReadyCallback callback,
    gpointer user_data);
static void gum_create_script_task_run (GumScriptTask * task,
    GumQuickScriptBackend * self, GumCreateScriptData * d,
    GCancellable * cancellable);
static void gum_create_script_data_free (GumCreateScriptData * d);
static void gum_quick_script_backend_create_from_bytes (
    GumScriptBackend * backend, GBytes * bytes, GBytes * snapshot,
    GCancellable * cancellable, GAsyncReadyCallback callback,
    gpointer user_data);
static GumScript * gum_quick_script_backend_create_from_bytes_finish (
    GumScriptBackend * backend, GAsyncResult * result, GError ** error);
static GumScript * gum_quick_script_backend_create_from_bytes_sync (
    GumScriptBackend * backend, GBytes * bytes, GBytes * snapshot,
    GCancellable * cancellable, GError ** error);
static GumScriptTask * gum_create_script_from_bytes_task_new (
    GumQuickScriptBackend * backend, GBytes * bytes, GBytes * snapshot,
    GCancellable * cancellable, GAsyncReadyCallback callback,
    gpointer user_data);
static void gum_create_script_from_bytes_task_run (GumScriptTask * task,
    GumQuickScriptBackend * self, GumCreateScriptFromBytesData * d,
    GCancellable * cancellable);
static void gum_create_script_from_bytes_data_free (
    GumCreateScriptFromBytesData * d);

static void gum_quick_script_backend_compile (GumScriptBackend * backend,
    const gchar * name, const gchar * source, GCancellable * cancellable,
    GAsyncReadyCallback callback, gpointer user_data);
static GBytes * gum_quick_script_backend_compile_finish (
    GumScriptBackend * backend, GAsyncResult * result, GError ** error);
static GBytes * gum_quick_script_backend_compile_sync (
    GumScriptBackend * backend, const gchar * name, const gchar * source,
    GCancellable * cancellable, GError ** error);
static GumScriptTask * gum_compile_script_task_new (
    GumQuickScriptBackend * backend, const gchar * name, const gchar * source,
    GCancellable * cancellable, GAsyncReadyCallback callback,
    gpointer user_data);
static void gum_compile_script_task_run (GumScriptTask * task,
    GumQuickScriptBackend * self, GumCompileScriptData * d,
    GCancellable * cancellable);
static void gum_compile_script_data_free (GumCompileScriptData * d);
static void gum_quick_script_backend_snapshot (GumScriptBackend * backend,
    const gchar * embed_script, const gchar * warmup_script,
    GCancellable * cancellable, GAsyncReadyCallback callback,
    gpointer user_data);
static GBytes * gum_quick_script_backend_snapshot_finish (
    GumScriptBackend * backend, GAsyncResult * result, GError ** error);
static GBytes * gum_quick_script_backend_snapshot_sync (
    GumScriptBackend * backend, const gchar * embed_script,
    const gchar * warmup_script, GCancellable * cancellable, GError ** error);
static GumScriptTask * gum_snapshot_script_task_new (
    GumQuickScriptBackend * backend, const gchar * embed_script,
    const gchar * warmup_script, GCancellable * cancellable,
    GAsyncReadyCallback callback, gpointer user_data);
static void gum_snapshot_script_task_run (GumScriptTask * task,
    GumQuickScriptBackend * self, GumSnapshotScriptData * d,
    GCancellable * cancellable);
static void gum_snapshot_script_data_free (GumSnapshotScriptData * d);

static void gum_quick_script_backend_with_lock_held (GumScriptBackend * backend,
    GumScriptBackendLockedFunc func, gpointer user_data);
static gboolean gum_quick_script_backend_is_locked (GumScriptBackend * backend);

static GumESProgram * gum_es_program_new (void);
static char * gum_es_program_normalize_module_name (GumESProgram * self,
    JSContext * ctx, const char * base_name, const char * name);

static GError * gum_capture_parse_error (JSContext * ctx,
    const gchar * filename);

#ifndef HAVE_ASAN
static void * gum_quick_malloc (JSMallocState * state, size_t size);
static void gum_quick_free (JSMallocState * state, void * ptr);
static void * gum_quick_realloc (JSMallocState * state, void * ptr,
    size_t size);
static size_t gum_quick_malloc_usable_size (const void * ptr);
#endif

G_DEFINE_TYPE_EXTENDED (GumQuickScriptBackend,
                        gum_quick_script_backend,
                        G_TYPE_OBJECT,
                        0,
                        G_IMPLEMENT_INTERFACE (GUM_TYPE_SCRIPT_BACKEND,
                            gum_quick_script_backend_iface_init))

static void
gum_quick_script_backend_class_init (GumQuickScriptBackendClass * klass)
{
  GObjectClass * object_class = G_OBJECT_CLASS (klass);

  object_class->dispose = gum_quick_script_backend_dispose;
  object_class->finalize = gum_quick_script_backend_finalize;
}

static void
gum_quick_script_backend_iface_init (gpointer g_iface,
                                     gpointer iface_data)
{
  GumScriptBackendInterface * iface = g_iface;

  iface->create = gum_quick_script_backend_create;
  iface->create_finish = gum_quick_script_backend_create_finish;
  iface->create_sync = gum_quick_script_backend_create_sync;
  iface->create_from_bytes = gum_quick_script_backend_create_from_bytes;
  iface->create_from_bytes_finish =
      gum_quick_script_backend_create_from_bytes_finish;
  iface->create_from_bytes_sync =
      gum_quick_script_backend_create_from_bytes_sync;

  iface->compile = gum_quick_script_backend_compile;
  iface->compile_finish = gum_quick_script_backend_compile_finish;
  iface->compile_sync = gum_quick_script_backend_compile_sync;
  iface->snapshot = gum_quick_script_backend_snapshot;
  iface->snapshot_finish = gum_quick_script_backend_snapshot_finish;
  iface->snapshot_sync = gum_quick_script_backend_snapshot_sync;

  iface->with_lock_held = gum_quick_script_backend_with_lock_held;
  iface->is_locked = gum_quick_script_backend_is_locked;
}

static void
gum_quick_script_backend_init (GumQuickScriptBackend * self)
{
  g_mutex_init (&self->mutex);
  g_rec_mutex_init (&self->scope_mutex);
  self->scope_mutex_trapped = FALSE;

  self->scheduler = g_object_ref (gum_script_backend_get_scheduler ());
}

static void
gum_quick_script_backend_dispose (GObject * object)
{
  GumQuickScriptBackend * self = GUM_QUICK_SCRIPT_BACKEND (object);

  g_clear_object (&self->scheduler);

  G_OBJECT_CLASS (gum_quick_script_backend_parent_class)->dispose (object);
}

static void
gum_quick_script_backend_finalize (GObject * object)
{
  GumQuickScriptBackend * self = GUM_QUICK_SCRIPT_BACKEND (object);

  g_mutex_clear (&self->mutex);
  g_rec_mutex_clear (&self->scope_mutex);

  G_OBJECT_CLASS (gum_quick_script_backend_parent_class)->finalize (object);
}

JSRuntime *
gum_quick_script_backend_make_runtime (GumQuickScriptBackend * self)
{
#ifndef HAVE_ASAN
  const JSMallocFunctions mf = {
    gum_quick_malloc,
    gum_quick_free,
    gum_quick_realloc,
    gum_quick_malloc_usable_size
  };

  return JS_NewRuntime2 (&mf, self);
#else
  return JS_NewRuntime ();
#endif
}

GumESProgram *
gum_quick_script_backend_compile_program (GumQuickScriptBackend * self,
                                          JSContext * ctx,
                                          const gchar * name,
                                          const gchar * source,
                                          GError ** error)
{
  GumESProgram * program;
  GumCompileProgramOperation op;
  JSRuntime * rt;
  const gchar * package_marker = "📦\n";
  const gchar * delimiter_marker = "\n✄\n";
  const gchar * alias_marker = "\n↻ ";
  GumESAsset * entrypoint = NULL;

  program = gum_es_program_new ();

  op.program = program;
  op.error = NULL;

  rt = JS_GetRuntime (ctx);

  if (g_str_has_prefix (source, package_marker))
  {
    const gchar * source_end, * header_cursor;

    JS_SetModuleLoaderFunc (rt,
        gum_normalize_module_name_during_compilation,
        gum_load_module_during_compilation,
        &op);

    source_end = source + strlen (source);
    header_cursor = source + strlen (package_marker);

    do
    {
      const gchar * asset_cursor, * header_end;
      guint i;
      JSValue val;

      entrypoint = NULL;

      asset_cursor = strstr (header_cursor, delimiter_marker);
      if (asset_cursor == NULL)
        goto malformed_package;

      header_end = asset_cursor;

      for (i = 0; header_cursor != header_end; i++)
      {
        guint64 asset_size;
        const gchar * size_end, * rest_start, * rest_end;
        gchar * asset_name, * asset_data;
        GumESAsset * asset;

        if (i != 0 && !g_str_has_prefix (asset_cursor, delimiter_marker))
          goto malformed_package;
        asset_cursor += strlen (delimiter_marker);

        asset_size = g_ascii_strtoull (header_cursor, (gchar **) &size_end, 10);
        if (asset_size == 0 || asset_size > GUM_MAX_ASSET_SIZE)
          goto malformed_package;
        if (asset_cursor + asset_size > source_end)
          goto malformed_package;

        rest_start = size_end + 1;
        rest_end = strchr (rest_start, '\n');

        asset_name = g_strndup (rest_start, rest_end - rest_start);
        if (g_hash_table_contains (program->es_assets, asset_name))
        {
          g_free (asset_name);
          goto malformed_package;
        }

        asset_data = g_strndup (asset_cursor, asset_size);

        asset = gum_es_asset_new_take (asset_name, asset_data, asset_size);
        g_hash_table_insert (program->es_assets, asset_name, asset);

        while (g_str_has_prefix (rest_end, alias_marker))
        {
          const gchar * alias_start, * alias_end;
          gchar * asset_alias;

          alias_start = rest_end + strlen (alias_marker);
          alias_end = strchr (alias_start, '\n');

          asset_alias = g_strndup (alias_start, alias_end - alias_start);
          if (g_hash_table_contains (program->es_assets, asset_alias))
          {
            g_free (asset_alias);
            goto malformed_package;
          }
          g_hash_table_insert (program->es_assets, asset_alias,
              gum_es_asset_ref (asset));

          rest_end = alias_end;
        }

        if (entrypoint == NULL && g_str_has_suffix (asset_name, ".js"))
          entrypoint = asset;

        header_cursor = rest_end;
        asset_cursor += asset_size;
      }

      if (entrypoint == NULL)
        goto malformed_package;

      val = gum_compile_module (ctx, entrypoint);
      if (JS_IsException (val))
        goto malformed_entrypoint;

      g_array_append_val (program->entrypoints, val);

      if (g_str_has_prefix (asset_cursor, delimiter_marker))
        header_cursor = asset_cursor + strlen (delimiter_marker);
      else
        header_cursor = NULL;
    }
    while (header_cursor != NULL);
  }
  else
  {
    JSValue val;

    program->global_filename = g_strconcat ("/", name, ".js", NULL);

    val = JS_Eval (ctx, source, strlen (source), program->global_filename,
        JS_EVAL_TYPE_GLOBAL | JS_EVAL_FLAG_STRICT | JS_EVAL_FLAG_COMPILE_ONLY);

    if (JS_IsException (val))
      goto malformed_code;

    g_array_append_val (program->entrypoints, val);

    program->global_source_map =
        gum_script_backend_extract_inline_source_map (source);
  }

  goto beach;

malformed_package:
  {
    op.error = g_error_new (
        GUM_ERROR,
        GUM_ERROR_INVALID_DATA,
        "Malformed package");

    goto propagate_error;
  }
malformed_entrypoint:
  {
    if (op.error == NULL)
      op.error = gum_capture_parse_error (ctx, entrypoint->name);

    goto propagate_error;
  }
malformed_code:
  {
    JSValue exception_val, line_val;
    const char * message;
    uint32_t line;

    exception_val = JS_GetException (ctx);

    message = JS_ToCString (ctx, exception_val);

    line_val = JS_GetPropertyStr (ctx, exception_val, "lineNumber");
    JS_ToUint32 (ctx, &line, line_val);

    op.error = g_error_new (
        GUM_ERROR,
        GUM_ERROR_FAILED,
        "Script(line %u): %s",
        line,
        message);

    JS_FreeValue (ctx, line_val);
    JS_FreeCString (ctx, message);
    JS_FreeValue (ctx, exception_val);

    goto propagate_error;
  }
propagate_error:
  {
    g_propagate_error (error, op.error);

    gum_es_program_free (program, ctx);
    program = NULL;

    goto beach;
  }
beach:
  {
    if (program != NULL)
    {
      JS_SetModuleLoaderFunc (rt,
          gum_normalize_module_name_during_runtime,
          gum_load_module_during_runtime,
          program);
    }
    else
    {
      JS_SetModuleLoaderFunc (rt, NULL, NULL, NULL);
    }

    return program;
  }
}

static char *
gum_normalize_module_name_during_compilation (JSContext * ctx,
                                              const char * base_name,
                                              const char * name,
                                              void * opaque)
{
  GumCompileProgramOperation * op = opaque;

  return gum_es_program_normalize_module_name (op->program, ctx, base_name,
      name);
}

static char *
gum_normalize_module_name_during_runtime (JSContext * ctx,
                                          const char * base_name,
                                          const char * name,
                                          void * opaque)
{
  GumESProgram * program = opaque;

  return gum_es_program_normalize_module_name (program, ctx, base_name, name);
}

static JSModuleDef *
gum_load_module_during_compilation (JSContext * ctx,
                                    const char * module_name,
                                    void * opaque)
{
  GumCompileProgramOperation * op = opaque;
  GumESAsset * asset;
  JSValue val;

  asset = g_hash_table_lookup (op->program->es_assets, module_name);
  if (asset == NULL)
    goto not_found;

  val = gum_compile_module (ctx, asset);
  if (JS_IsException (val))
    goto malformed_module;

  JS_FreeValue (ctx, val);

  return JS_VALUE_GET_PTR (val);

not_found:
  {
    if (op->error == NULL)
    {
      op->error = g_error_new (
          GUM_ERROR,
          GUM_ERROR_FAILED,
          "Could not load module '%s'",
          module_name);
    }

    return NULL;
  }
malformed_module:
  {
    if (op->error == NULL)
      op->error = gum_capture_parse_error (ctx, asset->name);

    return NULL;
  }
}

static JSModuleDef *
gum_load_module_during_runtime (JSContext * ctx,
                                const char * module_name,
                                void * opaque)
{
  GumESProgram * program = opaque;
  GumESAsset * asset;
  JSValue val;

  asset = g_hash_table_lookup (program->es_assets, module_name);
  if (asset == NULL)
    goto not_found;

  val = gum_compile_module (ctx, asset);
  if (JS_IsException (val))
    return NULL;

  JS_FreeValue (ctx, val);

  return JS_VALUE_GET_PTR (val);

not_found:
  {
    gchar * message;
    JSValue error;

    message = g_strdup_printf ("could not load module '%s'", module_name);

    error = JS_NewError (ctx);
    JS_SetPropertyStr (ctx, error, "message", JS_NewString (ctx, message));

    g_free (message);

    JS_Throw (ctx, error);

    return NULL;
  }
}

static JSValue
gum_compile_module (JSContext * ctx,
                    const GumESAsset * asset)
{
  JSValue val;
  JSModuleDef * mod;
  JSValue meta;
  gchar * url;

  val = JS_Eval (ctx, asset->data, asset->data_size, asset->name,
      JS_EVAL_TYPE_MODULE | JS_EVAL_FLAG_STRICT | JS_EVAL_FLAG_COMPILE_ONLY);
  if (JS_IsException (val))
    return JS_EXCEPTION;

  mod = JS_VALUE_GET_PTR (val);

  meta = JS_GetImportMeta (ctx, mod);

  url = g_strconcat ("file://", asset->name, NULL);
  JS_DefinePropertyValueStr (ctx, meta, "url", JS_NewString (ctx, url),
      JS_PROP_C_W_E);
  g_free (url);

  JS_FreeValue (ctx, meta);

  return val;
}

GumESProgram *
gum_quick_script_backend_read_program (GumQuickScriptBackend * self,
                                       JSContext * ctx,
                                       GBytes * bytecode,
                                       GError ** error)
{
  GumESProgram * program;
  JSValue val;
  gconstpointer code;
  gsize size;

  program = gum_es_program_new ();

  code = g_bytes_get_data (bytecode, &size);

  val = JS_ReadObject (ctx, code, size, JS_READ_OBJ_BYTECODE);

  if (JS_IsException (val))
    goto malformed_code;

  g_array_append_val (program->entrypoints, val);

  return program;

malformed_code:
  {
    JSValue exception_val;
    const char * message_str;

    gum_es_program_free (program, ctx);

    exception_val = JS_GetException (ctx);
    message_str = JS_ToCString (ctx, exception_val);

    g_set_error_literal (error, GUM_ERROR, GUM_ERROR_FAILED, message_str);

    JS_FreeCString (ctx, message_str);
    JS_FreeValue (ctx, exception_val);

    return NULL;
  }
}

GRecMutex *
gum_quick_script_backend_get_scope_mutex (GumQuickScriptBackend * self)
{
  return &self->scope_mutex;
}

GumScriptScheduler *
gum_quick_script_backend_get_scheduler (GumQuickScriptBackend * self)
{
  return self->scheduler;
}

static void
gum_quick_script_backend_create (GumScriptBackend * backend,
                                 const gchar * name,
                                 const gchar * source,
                                 GBytes * snapshot,
                                 GCancellable * cancellable,
                                 GAsyncReadyCallback callback,
                                 gpointer user_data)
{
  GumQuickScriptBackend * self;
  GumScriptTask * task;

  self = GUM_QUICK_SCRIPT_BACKEND (backend);

  task = gum_create_script_task_new (self, name, source, snapshot, cancellable,
      callback, user_data);
  gum_script_task_run_in_js_thread (task, self->scheduler);
  g_object_unref (task);
}

static GumScript *
gum_quick_script_backend_create_finish (GumScriptBackend * backend,
                                        GAsyncResult * result,
                                        GError ** error)
{
  return gum_script_task_propagate_pointer (GUM_SCRIPT_TASK (result), error);
}

static GumScript *
gum_quick_script_backend_create_sync (GumScriptBackend * backend,
                                      const gchar * name,
                                      const gchar * source,
                                      GBytes * snapshot,
                                      GCancellable * cancellable,
                                      GError ** error)
{
  GumScript * script;
  GumQuickScriptBackend * self;
  GumScriptTask * task;

  self = GUM_QUICK_SCRIPT_BACKEND (backend);

  task = gum_create_script_task_new (self, name, source, snapshot, cancellable,
      NULL, NULL);
  gum_script_task_run_in_js_thread_sync (task, self->scheduler);
  script = gum_script_task_propagate_pointer (task, error);
  g_object_unref (task);

  return script;
}

static GumScriptTask *
gum_create_script_task_new (GumQuickScriptBackend * backend,
                            const gchar * name,
                            const gchar * source,
                            GBytes * snapshot,
                            GCancellable * cancellable,
                            GAsyncReadyCallback callback,
                            gpointer user_data)
{
  GumScriptTask * task;
  GumCreateScriptData * d;

  d = g_slice_new (GumCreateScriptData);
  d->name = g_strdup (name);
  d->source = g_strdup (source);
  d->snapshot = (snapshot != NULL) ? g_bytes_ref (snapshot) : NULL;

  task = gum_script_task_new ((GumScriptTaskFunc) gum_create_script_task_run,
      backend, cancellable, callback, user_data);
  gum_script_task_set_task_data (task, d,
      (GDestroyNotify) gum_create_script_data_free);

  return task;
}

static void
gum_create_script_task_run (GumScriptTask * task,
                            GumQuickScriptBackend * self,
                            GumCreateScriptData * d,
                            GCancellable * cancellable)
{
  GumQuickScript * script;
  GError * error = NULL;

  if (d->snapshot != NULL)
  {
    gum_script_task_return_error (task,
        g_error_new (GUM_ERROR, GUM_ERROR_NOT_SUPPORTED,
          "snapshots are not supported by the QuickJS runtime"));
    return;
  }

  script = g_object_new (GUM_QUICK_TYPE_SCRIPT,
      "name", d->name,
      "source", d->source,
      "main-context", gum_script_task_get_context (task),
      "backend", self,
      NULL);

  gum_quick_script_create_context (script, &error);

  if (error == NULL)
  {
    gum_script_task_return_pointer (task, script, g_object_unref);
  }
  else
  {
    gum_script_task_return_error (task, error);
    g_object_unref (script);
  }
}

static void
gum_create_script_data_free (GumCreateScriptData * d)
{
  g_free (d->name);
  g_free (d->source);
  g_bytes_unref (d->snapshot);

  g_slice_free (GumCreateScriptData, d);
}

static void
gum_quick_script_backend_create_from_bytes (GumScriptBackend * backend,
                                            GBytes * bytes,
                                            GBytes * snapshot,
                                            GCancellable * cancellable,
                                            GAsyncReadyCallback callback,
                                            gpointer user_data)
{
  GumQuickScriptBackend * self = GUM_QUICK_SCRIPT_BACKEND (backend);
  GumScriptTask * task;

  task = gum_create_script_from_bytes_task_new (self, bytes, snapshot,
      cancellable, callback, user_data);
  gum_script_task_run_in_js_thread (task, self->scheduler);
  g_object_unref (task);
}

static GumScript *
gum_quick_script_backend_create_from_bytes_finish (GumScriptBackend * backend,
                                                   GAsyncResult * result,
                                                   GError ** error)
{
  return gum_script_task_propagate_pointer (GUM_SCRIPT_TASK (result), error);
}

static GumScript *
gum_quick_script_backend_create_from_bytes_sync (GumScriptBackend * backend,
                                                 GBytes * bytes,
                                                 GBytes * snapshot,
                                                 GCancellable * cancellable,
                                                 GError ** error)
{
  GumQuickScriptBackend * self = GUM_QUICK_SCRIPT_BACKEND (backend);
  GumScript * script;
  GumScriptTask * task;

  task = gum_create_script_from_bytes_task_new (self, bytes, snapshot,
      cancellable, NULL, NULL);
  gum_script_task_run_in_js_thread_sync (task, self->scheduler);
  script = GUM_SCRIPT (gum_script_task_propagate_pointer (task, error));
  g_object_unref (task);

  return script;
}

static GumScriptTask *
gum_create_script_from_bytes_task_new (GumQuickScriptBackend * backend,
                                       GBytes * bytes,
                                       GBytes * snapshot,
                                       GCancellable * cancellable,
                                       GAsyncReadyCallback callback,
                                       gpointer user_data)
{
  GumScriptTask * task;
  GumCreateScriptFromBytesData * d;

  d = g_slice_new (GumCreateScriptFromBytesData);
  d->bytes = g_bytes_ref (bytes);
  d->snapshot = (snapshot != NULL) ? g_bytes_ref (snapshot) : NULL;

  task = gum_script_task_new (
      (GumScriptTaskFunc) gum_create_script_from_bytes_task_run, backend,
      cancellable, callback, user_data);
  gum_script_task_set_task_data (task, d,
      (GDestroyNotify) gum_create_script_from_bytes_data_free);

  return task;
}

static void
gum_create_script_from_bytes_task_run (GumScriptTask * task,
                                       GumQuickScriptBackend * self,
                                       GumCreateScriptFromBytesData * d,
                                       GCancellable * cancellable)
{
  GumQuickScript * script;
  GError * error = NULL;

  if (d->snapshot != NULL)
  {
    gum_script_task_return_error (task,
        g_error_new (GUM_ERROR, GUM_ERROR_NOT_SUPPORTED,
          "snapshots are not supported by the QuickJS runtime"));
    return;
  }

  script = g_object_new (GUM_QUICK_TYPE_SCRIPT,
      "bytecode", d->bytes,
      "main-context", gum_script_task_get_context (task),
      "backend", self,
      NULL);

  gum_quick_script_create_context (script, &error);

  if (error == NULL)
  {
    gum_script_task_return_pointer (task, script, g_object_unref);
  }
  else
  {
    gum_script_task_return_error (task, error);
    g_object_unref (script);
  }
}

static void
gum_create_script_from_bytes_data_free (GumCreateScriptFromBytesData * d)
{
  g_bytes_unref (d->bytes);
  g_bytes_unref (d->snapshot);

  g_slice_free (GumCreateScriptFromBytesData, d);
}

static void
gum_quick_script_backend_compile (GumScriptBackend * backend,
                                  const gchar * name,
                                  const gchar * source,
                                  GCancellable * cancellable,
                                  GAsyncReadyCallback callback,
                                  gpointer user_data)
{
  GumQuickScriptBackend * self;
  GumScriptTask * task;

  self = GUM_QUICK_SCRIPT_BACKEND (backend);

  task = gum_compile_script_task_new (self, name, source, cancellable, callback,
      user_data);
  gum_script_task_run_in_js_thread (task, self->scheduler);
  g_object_unref (task);
}

static GBytes *
gum_quick_script_backend_compile_finish (GumScriptBackend * backend,
                                         GAsyncResult * result,
                                         GError ** error)
{
  return gum_script_task_propagate_pointer (GUM_SCRIPT_TASK (result), error);
}

static GBytes *
gum_quick_script_backend_compile_sync (GumScriptBackend * backend,
                                       const gchar * name,
                                       const gchar * source,
                                       GCancellable * cancellable,
                                       GError ** error)
{
  GBytes * bytes;
  GumQuickScriptBackend * self;
  GumScriptTask * task;

  self = GUM_QUICK_SCRIPT_BACKEND (backend);

  task = gum_compile_script_task_new (self, name, source, cancellable, NULL,
      NULL);
  gum_script_task_run_in_js_thread_sync (task, self->scheduler);
  bytes = gum_script_task_propagate_pointer (task, error);
  g_object_unref (task);

  return bytes;
}

static GumScriptTask *
gum_compile_script_task_new (GumQuickScriptBackend * backend,
                             const gchar * name,
                             const gchar * source,
                             GCancellable * cancellable,
                             GAsyncReadyCallback callback,
                             gpointer user_data)
{
  GumScriptTask * task;
  GumCompileScriptData * d;

  d = g_slice_new (GumCompileScriptData);
  d->name = g_strdup (name);
  d->source = g_strdup (source);

  task = gum_script_task_new ((GumScriptTaskFunc) gum_compile_script_task_run,
      backend, cancellable, callback, user_data);
  gum_script_task_set_task_data (task, d,
      (GDestroyNotify) gum_compile_script_data_free);

  return task;
}

static void
gum_compile_script_task_run (GumScriptTask * task,
                             GumQuickScriptBackend * self,
                             GumCompileScriptData * d,
                             GCancellable * cancellable)
{
  JSRuntime * rt;
  JSContext * ctx;
  GumESProgram * program;
  GError * error = NULL;

  rt = gum_quick_script_backend_make_runtime (self);
  ctx = JS_NewContext (rt);

  program = gum_quick_script_backend_compile_program (self, ctx, d->name,
      d->source, &error);

  if (error == NULL)
  {
    JSValue val;
    uint8_t * code;
    size_t size;
    GBytes * bytes;
    GDestroyNotify free_impl;

    /* TODO: Add support for compiling ESM-flavored scripts to bytecode. */
    val = g_array_index (program->entrypoints, JSValue, 0);

#ifndef HAVE_ASAN
    free_impl = gum_free;
#else
    free_impl = free;
#endif

    code = JS_WriteObject (ctx, &size, val, JS_WRITE_OBJ_BYTECODE);

    bytes = g_bytes_new_with_free_func (code, size, free_impl, code);

    gum_script_task_return_pointer (task, bytes,
        (GDestroyNotify) g_bytes_unref);

    gum_es_program_free (program, ctx);
  }
  else
  {
    gum_script_task_return_error (task, error);
  }

  JS_FreeContext (ctx);
  JS_FreeRuntime (rt);
}

static void
gum_compile_script_data_free (GumCompileScriptData * d)
{
  g_free (d->name);
  g_free (d->source);

  g_slice_free (GumCompileScriptData, d);
}

static void
gum_quick_script_backend_snapshot (GumScriptBackend * backend,
                                   const gchar * embed_script,
                                   const gchar * warmup_script,
                                   GCancellable * cancellable,
                                   GAsyncReadyCallback callback,
                                   gpointer user_data)
{
  GumQuickScriptBackend * self;
  GumScriptTask * task;

  self = GUM_QUICK_SCRIPT_BACKEND (backend);

  task = gum_snapshot_script_task_new (self, embed_script, warmup_script,
      cancellable, callback, user_data);
  gum_script_task_run_in_js_thread (task, self->scheduler);
  g_object_unref (task);
}

static GBytes *
gum_quick_script_backend_snapshot_finish (GumScriptBackend * backend,
                                          GAsyncResult * result,
                                          GError ** error)
{
  return gum_script_task_propagate_pointer (GUM_SCRIPT_TASK (result), error);
}

static GBytes *
gum_quick_script_backend_snapshot_sync (GumScriptBackend * backend,
                                        const gchar * embed_script,
                                        const gchar * warmup_script,
                                        GCancellable * cancellable,
                                        GError ** error)
{
  GBytes * bytes;
  GumQuickScriptBackend * self;
  GumScriptTask * task;

  self = GUM_QUICK_SCRIPT_BACKEND (backend);

  task = gum_snapshot_script_task_new (self, embed_script, warmup_script,
      cancellable, NULL, NULL);
  gum_script_task_run_in_js_thread_sync (task, self->scheduler);
  bytes = gum_script_task_propagate_pointer (
"""


```
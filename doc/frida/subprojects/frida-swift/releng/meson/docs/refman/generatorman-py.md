Response:
Let's break down the thought process for analyzing this Python script.

**1. Initial Understanding - What is the Goal?**

The first thing I do is read the docstring at the top. It clearly states this is a source file for `fridaDynamic instrumentation tool`, specifically for generating man pages for the Meson build system's reference manual. The path `frida/subprojects/frida-swift/releng/meson/docs/refman/generatorman.py` also gives context – it's part of the Frida project, likely related to Swift bindings, and deals with release engineering (`releng`) for Meson documentation.

**2. Core Functionality - What does it *do*?**

I scan the class definitions:

*   `ManPage`: This looks like a helper class to build the structure of a man page. It has methods for adding titles, sections, paragraphs, formatting text (bold, italics), and writing to a file. This is the fundamental building block.
*   `GeneratorMan`: This class seems to orchestrate the man page generation. It takes a `ReferenceManual` (likely a data model of the Meson API) and an output path. Key methods I notice are `generate_description`, `generate_function_signature`, `generate_function_arg`, `generate_function`, and `generate_object`. These suggest the script iterates through functions and objects in the `ReferenceManual` and formats them for the man page.

**3. Relationship to Reverse Engineering:**

Now I consider how this relates to reverse engineering. Frida is a dynamic instrumentation toolkit, heavily used in reverse engineering to inspect and modify the behavior of running processes. This script, while generating documentation, is *part of the ecosystem* that makes Frida usable. Understanding the documented APIs is crucial for effectively using Frida in reverse engineering tasks.

*   **Example:**  If a reverse engineer wants to use Frida to intercept a specific Swift function call, they need to know the exact syntax and arguments of the Frida API for doing so. This documentation, generated by this script, provides that information.

**4. Low-Level, Kernel, and Framework Connections:**

Frida itself interacts deeply with the target process's memory, including the kernel and frameworks. While this *specific script* primarily focuses on documentation generation, it implicitly relies on the existence of those low-level mechanisms. The documented functions and objects within the generated man pages *represent* these low-level interactions.

*   **Example:**  A function documented in the man page might describe how to attach to a process (kernel interaction) or how to interact with Objective-C or Swift runtime objects (framework knowledge). This script doesn't *do* the attaching or interaction, but it documents *how* a Frida user would use the Frida API to perform these actions.

**5. Logical Reasoning and Assumptions:**

The script uses a data model (`ReferenceManual`, `Function`, `Object`, etc.). This implies:

*   **Assumption:** There's a preceding step that parses the Meson build system's information into this data model. This script takes that model as input.
*   **Input:**  The `ReferenceManual` object contains structured information about functions (name, arguments, return types, descriptions) and objects (name, methods, properties, relationships).
*   **Output:** The script generates a text file (the man page) formatted according to standard man page conventions.

**6. Common Usage Errors:**

Looking at the code, I can imagine user errors related to the input `ReferenceManual` or the output path. However, since this script is likely part of an automated build process, direct user interaction with *this specific script* might be limited. The more relevant errors would be in *how someone uses the generated documentation*.

*   **Example:**  A user might misunderstand the documentation and try to call a function with incorrect arguments, leading to Frida errors at runtime. The documentation aims to prevent this, but misinterpretations are possible.

**7. Tracing User Operations:**

How does a user end up benefiting from this script?

1. **Developer writes Meson build files:** They define their project's structure, dependencies, etc.
2. **Meson processes the build files:**  It understands the project and generates build scripts.
3. **Documentation generation process (including this script) runs:** This script takes the information about Meson's API and creates the man page.
4. **Frida user wants to reverse engineer something built with Meson:** They need to understand how Meson works or how to interact with parts of the system that Meson configures.
5. **User consults the `meson-reference` man page:** They use `man meson-reference` in their terminal to look up functions, objects, and their usage, which was generated by this script.

**Self-Correction/Refinement:**

Initially, I might focus too much on the low-level aspects since Frida is a reverse engineering tool. However, I need to remember the *specific role* of this script – documentation generation. While indirectly related to low-level operations, its primary function is to create human-readable documentation for the Frida API related to Meson. The connection is that *understanding this documentation is crucial for using Frida effectively in low-level tasks*. I need to strike a balance between acknowledging the underlying purpose of Frida and focusing on the immediate functionality of the `generatorman.py` script. Also, considering the broader context of a build system and documentation pipeline helps understand the script's place in the overall workflow.
好的，让我们详细分析一下 `frida/subprojects/frida-swift/releng/meson/docs/refman/generatorman.py` 这个 Python 脚本的功能。

**核心功能：生成 Meson 参考手册的 Man Page**

这个脚本的主要目的是从一个表示 Meson 构建系统 API 的数据模型 (`ReferenceManual`) 中提取信息，并将其格式化为 Unix 风格的 man page（手册页）。Man page 是一种常见的在 Linux 和其他类 Unix 系统中查看软件文档的方式。

**功能拆解：**

1. **`ManPage` 类:**
    *   这是一个辅助类，负责构建 man page 的结构和内容。
    *   它提供了一系列方法，用于添加标题 (`title`)、章节 (`section`, `subsection`)、段落 (`par`)、缩进 (`indent`, `unindent`)、换行 (`br`, `nl`)、行文本 (`line`) 和内联文本 (`inline`)。
    *   它还提供了静态方法用于格式化文本，例如加粗 (`bold`) 和斜体 (`italic`)。
    *   `write` 方法将构建好的 man page 内容写入到指定的文件路径。

2. **`GeneratorMan` 类:**
    *   继承自 `GeneratorBase` (代码中未提供，但可以推测是定义了处理 `ReferenceManual` 数据的基类)。
    *   构造函数 `__init__` 接收一个 `ReferenceManual` 对象，输出路径 `out`，以及一个布尔值 `enable_modules`。
    *   `generate_description` 方法：负责处理和格式化描述文本。它使用正则表达式来识别特定的标记（例如 `[[...]]` 表示斜体，`*(...)*` 表示粗体，`[...]()` 表示链接），并将其转换为 man page 的格式。
    *   `function_name` 方法：生成函数的名称，如果该函数是某个对象的方法，则包含对象名。
    *   `generate_function_signature` 方法：生成函数的签名（包括返回类型、函数名和参数列表），并根据长度进行格式化，以提高可读性。
    *   `base_info` 方法：提取函数或对象的通用信息，例如是否已弃用 (`deprecated`) 以及引入版本 (`since`)。
    *   `generate_function_arg` 方法：格式化函数参数的信息，包括名称、类型、是否必需、默认值等。
    *   `generate_function_argument_section` 方法：生成函数参数的章节（例如 POSARGS, VARARGS, OPTARGS, KWARGS）。
    *   `generate_sub_sub_section` 方法：生成子子章节，用于展示更详细的信息，如 NOTES, WARNINGS, EXAMPLE。
    *   `generate_function` 方法：生成单个函数的 man page 内容，包括概要、描述、参数、示例等。
    *   `generate_object` 方法：生成单个对象的 man page 内容，包括描述、继承关系、相关函数等。
    *   `generate` 方法：是主要的生成方法。它创建一个 `ManPage` 对象，设置标题和章节，遍历 `ReferenceManual` 中的函数和对象，调用相应的方法生成 man page 的内容，最后写入文件。

**与逆向方法的关系及举例说明：**

虽然这个脚本本身不直接执行逆向操作，但它生成的文档对于使用 Frida 进行逆向工程至关重要。Frida 是一个动态插桩工具，允许逆向工程师在运行时检查和修改应用程序的行为。理解 Frida 提供的 API (即 Meson 构建系统相关的 API) 是使用 Frida 的基础。

**举例：**

假设逆向工程师想要使用 Frida 脚本来hook一个使用 Meson 构建的应用程序中的某个函数。为了知道如何调用 Frida 提供的用于获取函数地址或者拦截函数调用的 API，他们需要查阅 Frida 的参考手册。这个脚本生成的 man page 就提供了这些 API 的详细信息，包括函数名称、参数类型、返回值等。

例如，man page 中可能包含一个名为 `Process.getModuleByName()` 的函数，用于获取指定名称的模块的句柄。逆向工程师通过查看 man page 可以了解到这个函数的用法：

```
Process.getModuleByName(name: str) -> Module
```

这告诉他们需要传入一个字符串类型的参数 `name` (模块的名称)，并且该函数会返回一个 `Module` 对象。有了这些信息，逆向工程师才能在 Frida 脚本中正确地使用这个函数。

**涉及二进制底层、Linux、Android 内核及框架的知识及举例说明：**

虽然脚本本身主要是文本处理和格式化，但它所描述的 API 背后涉及到了大量的底层知识：

*   **二进制底层:** Frida 能够操作进程的内存，读取和修改指令，这涉及到对目标平台架构和二进制格式的理解。例如，man page 中描述的某些函数可能允许用户读取或写入特定内存地址，这直接与二进制布局相关。
*   **Linux 内核:** Frida 在 Linux 上运行时，会与 Linux 内核进行交互，例如通过 ptrace 系统调用来注入代码或监控进程。Man page 中描述的关于进程操作（如 attach, detach）的 API 就与 Linux 内核的这些机制有关。
*   **Android 内核及框架:** 当 Frida 用于 Android 逆向时，它会与 Android 的内核（基于 Linux）以及 Android Runtime (ART) 或 Dalvik 虚拟机进行交互。例如，man page 中可能包含允许用户访问 Java 对象或调用 Android 系统服务的 API，这些 API 的实现就依赖于对 Android 框架的理解。

**举例：**

man page 中可能描述了一个名为 `NativeFunction` 的对象，允许用户创建一个指向本地代码的函数指针。使用 `NativeFunction` 需要了解目标函数的地址、参数类型和返回类型，这些信息通常需要在对目标二进制文件进行分析后才能获得，涉及到对底层内存布局和调用约定的理解。

**逻辑推理、假设输入与输出：**

脚本中的逻辑主要围绕着如何将 `ReferenceManual` 中的数据转换为 man page 的格式。

**假设输入：**

假设 `ReferenceManual` 对象包含以下关于一个名为 `send` 的虚构 Frida 函数的信息：

```python
class Function:
    def __init__(self, name, description, posargs=None, varargs=None, optargs=None, kwargs=None, returns=None, notes=None, warnings=None, example=None, deprecated=None, since=None):
        self.name = name
        self.description = description
        self.posargs = posargs or []
        self.varargs = varargs
        self.optargs = optargs or []
        self.kwargs = kwargs or {}
        self.returns = returns
        self.notes = notes or []
        self.warnings = warnings or []
        self.example = example
        self.deprecated = deprecated
        self.since = since

class PosArg:
    def __init__(self, name, type, description, required=True, default=None):
        self.name = name
        self.type = type
        self.description = description
        self.required = required
        self.default = default

class ReturnType:
    def __init__(self, raw):
        self.raw = raw

reference_manual = ReferenceManual(
    functions=[
        Function(
            name="send",
            description="Sends a message to the host.",
            posargs=[
                PosArg(name="data", type=ReturnType("any"), description="The data to send.")
            ],
            kwargs={
                "destination": PosArg(name="destination", type=ReturnType("str"), description="Optional destination identifier.", required=False)
            },
            returns=ReturnType("void"),
            example="send('Hello from Frida!')"
        )
    ],
    objects=[]
)
```

**预期输出 (部分 man page 内容)：**

```
.SS send()
.P
.B SYNOPSIS
.P
void send(data)
.P
.B DESCRIPTION
.P
Sends a message to the host.
.P
.B POSARGS
.RS 4
.B data
.P
\fIany\fR, \fBrequired\fR
.br
.RS 2
The data to send.
.RE
.P
.RE
.P
.B KWARGS
.RS 4
.B destination
.P
\fIstr\fR, default: \fBNone\fR
.br
.RS 2
Optional destination identifier.
.RE
.P
.RE
.P
.B EXAMPLE
.RS 4
send('Hello from Frida!')
.br
.RE
.P
```

**涉及用户或者编程常见的使用错误及举例说明：**

这个脚本的主要使用者是 Frida 的开发者，他们需要维护和更新 Frida 的文档。常见的错误可能包括：

*   **描述不清晰或有歧义:** 如果描述文本写得不好，用户可能会误解 API 的用法。例如，对于 `send` 函数，如果描述没有明确说明 `data` 参数可以是任何 Python 对象，用户可能会认为只能发送字符串。
*   **参数类型或返回值描述错误:** 如果 `ReferenceManual` 中的类型信息不准确，生成的 man page 也会出错，导致用户在使用 API 时出现类型错误。
*   **示例代码错误或过时:** 错误的示例代码会误导用户。
*   **链接错误:** 如果描述中的链接指向不存在的章节或外部资源，用户将无法获取更多信息。

**用户操作是如何一步步的到达这里，作为调试线索：**

1. **Frida 项目开发:**  当 Frida 的开发者添加、修改或删除了 Meson 构建系统相关的 API 时，他们需要更新相应的文档。
2. **更新 `ReferenceManual` 数据:**  开发者会修改生成 `ReferenceManual` 对象的数据源（可能是手写的 YAML 或 JSON 文件，或者从代码中自动提取）。
3. **运行 `generatorman.py` 脚本:**  在 Frida 的构建过程中，会执行这个脚本来生成最新的 man page。这通常是一个自动化步骤，例如通过 Meson 的构建系统调用。
4. **用户查阅文档:**  Frida 的用户（例如逆向工程师）在需要了解 Meson 相关 API 的用法时，会使用 `man meson-reference` 命令查看生成的 man page。
5. **发现问题:**  如果 man page 中的信息有误（例如，描述不清晰、示例错误），用户可能会在使用 Frida 时遇到问题，并报告文档错误。
6. **开发者调试:**  为了修复文档错误，开发者可能会重新检查 `ReferenceManual` 的数据，以及 `generatorman.py` 脚本的逻辑，确保数据能够正确地转换为 man page 格式。他们可能会修改脚本中的正则表达式、格式化逻辑或数据处理方式。

因此，`generatorman.py` 脚本在 Frida 的文档生成流程中扮演着关键的角色，它的正确性直接影响到用户理解和使用 Frida 的能力。 当用户遇到与 Meson 构建系统相关的功能使用问题时，查看最新的 man page 是首要的步骤，而这个脚本就是生成 man page 的关键工具。如果 man page 的内容有问题，那么就需要回到修改 `ReferenceManual` 数据和调试 `generatorman.py` 脚本这两个环节。

Prompt: 
```
这是目录为frida/subprojects/frida-swift/releng/meson/docs/refman/generatorman.py的fridaDynamic instrumentation tool的源代码文件， 请列举一下它的功能, 
如果它与逆向的方法有关系，请做出对应的举例说明，
如果涉及到二进制底层，linux, android内核及框架的知识，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索。

"""
import re
from pathlib import Path

from .generatorbase import GeneratorBase
from .model import (
    ReferenceManual,
    Function,
    Object,
    PosArg,
    VarArgs,
    Kwarg,
)

import typing as T


class ManPage:
    def __init__(self, path: Path):
        self.path = path
        self.text = ""

    def reset_font(self) -> None:
        self.text += ".P\n"

    def title(self, name: str, section: int) -> None:
        import datetime

        date = datetime.date.today()
        self.reset_font()
        self.text += f'.TH "{name}" "{section}" "{date}"\n'

    def section(self, name: str) -> None:
        self.reset_font()
        self.text += f".SH {name}\n"

    def subsection(self, name: str) -> None:
        self.reset_font()
        self.text += f".SS {name}\n"

    def par(self, text: str) -> None:
        self.reset_font()
        self.text += f"{text}\n"

    def indent(self, amount: int = 4) -> None:
        self.text += f".RS {amount}\n"

    def unindent(self) -> None:
        self.text += ".RE\n"

    def br(self) -> None:
        self.text += ".br\n"

    def nl(self) -> None:
        self.text += "\n"

    def line(self, text: str) -> None:
        if text and text[0] in [".", "'"]:
            self.text += "\\"
        self.text += f"{text}\n"

    def inline(self, text: str) -> None:
        self.text += f"{text}"

    def write(self) -> None:
        self.path.write_text(self.text, encoding="utf-8")

    @staticmethod
    def bold(text: str) -> str:
        return f"\\fB{text}\\fR"

    @staticmethod
    def italic(text: str) -> str:
        return f"\\fI{text}\\fR"


class GeneratorMan(GeneratorBase):
    def __init__(
        self, manual: ReferenceManual, out: Path, enable_modules: bool
    ) -> None:
        super().__init__(manual)
        self.out = out
        self.enable_modules = enable_modules
        self.links: T.List[str] = []

    def generate_description(self, page: ManPage, desc: str) -> None:
        def italicise(match: T.Match[str]) -> str:
            v = match.group(1)
            if v[0] == "@":
                v = v[1:]

            return ManPage.italic(v)

        desc = re.sub(re.compile(r"\[\[(.*?)\]\]", re.DOTALL), italicise, desc)

        def linkify(match: T.Match[str]) -> str:
            replacement = ManPage.italic(match.group(1))

            if match.group(2)[0] != "#":
                if match.group(2) in self.links:
                    num = self.links.index(match.group(2))
                else:
                    self.links.append(match.group(2))
                    num = len(self.links)

                replacement += f"[{num}]"

            return replacement

        desc = re.sub(re.compile(r"\[(.*?)\]\((.*?)\)", re.DOTALL), linkify, desc)

        def bold(match: T.Match[str]) -> str:
            return ManPage.bold(match.group(1))

        desc = re.sub(re.compile(r"\*(.*?)\*"), bold, desc)

        isCode = False
        for chunk in desc.split("```"):
            if isCode:
                page.indent()
                lines = chunk.strip().split("\n")
                if lines[0] == "meson":
                    lines = lines[1:]

                for line in lines:
                    page.line(line)
                    page.br()
                page.unindent()
            else:
                inList = False
                for line in chunk.strip().split("\n"):
                    if len(line) == 0:
                        page.nl()
                        if inList:
                            page.nl()
                            inList = False
                    elif line[0:2] in ["- ", "* "]:
                        if inList:
                            page.nl()
                            page.br()
                        else:
                            inList = True

                        page.inline(line.strip() + " ")
                    elif inList and line[0] == " ":
                        page.inline(line.strip() + " ")
                    else:
                        inList = False
                        page.line(line)

                if inList:
                    page.nl()

            isCode = not isCode

    def function_name(self, f: Function, o: Object = None) -> str:
        name = ""
        if o is not None:
            name += f"{o.name}."

        name += f.name
        return name

    def generate_function_signature(
        self, page: ManPage, f: Function, o: Object = None
    ) -> None:
        args = []

        if f.posargs:
            args += [arg.name for arg in f.posargs]

        if f.varargs:
            args += [f.varargs.name + "..."]

        if f.optargs:
            args += [f"[{arg.name}]" for arg in f.optargs]

        for kwarg in self.sorted_and_filtered(list(f.kwargs.values())):
            kw = kwarg.name + ":"
            if kwarg.default:
                kw += " " + ManPage.bold(kwarg.default)
            args += [kw]

        ret = ManPage.italic(f.returns.raw) + " "

        prefix = f"{ret}{self.function_name(f, o)}("
        sig = ", ".join(args)
        suffix = ")"

        if len(prefix) + len(sig) + len(suffix) > 70:
            page.line(prefix)
            page.br()
            page.indent()
            for arg in args:
                page.line(arg + ",")
                page.br()
            page.unindent()
            page.line(suffix)
        else:
            page.line(prefix + sig + suffix)

    def base_info(
        self, x: T.Union[PosArg, VarArgs, Kwarg, Function, Object]
    ) -> T.List[str]:
        info = []
        if x.deprecated:
            info += [ManPage.bold("deprecated") + f" since {x.deprecated}"]
        if x.since:
            info += [f"since {x.since}"]

        return info

    def generate_function_arg(
        self,
        page: ManPage,
        arg: T.Union[PosArg, VarArgs, Kwarg],
        isOptarg: bool = False,
    ) -> None:
        required = (
            arg.required
            if isinstance(arg, Kwarg)
            else not isOptarg and not isinstance(arg, VarArgs)
        )

        page.line(ManPage.bold(arg.name))

        info = [ManPage.italic(arg.type.raw)]

        if required:
            info += [ManPage.bold("required")]
        if isinstance(arg, (PosArg, Kwarg)) and arg.default:
            info += [f"default: {arg.default}"]
        if isinstance(arg, VarArgs):
            mn = 0 if arg.min_varargs < 0 else arg.min_varargs
            mx = "N" if arg.max_varargs < 0 else arg.max_varargs
            info += [f"{mn}...{mx} times"]

        info += self.base_info(arg)

        page.line(", ".join(info))

        page.br()
        page.indent(2)
        self.generate_description(page, arg.description.strip())
        page.unindent()
        page.nl()

    def generate_function_argument_section(
        self,
        page: ManPage,
        name: str,
        args: T.Sequence[T.Union[PosArg, VarArgs, Kwarg]],
        isOptarg: bool = False,
    ) -> None:
        if not args:
            return

        page.line(ManPage.bold(name))
        page.indent()
        for arg in args:
            self.generate_function_arg(page, arg, isOptarg)
        page.unindent()

    def generate_sub_sub_section(
        self, page: ManPage, name: str, text: T.List[str], process: bool = True
    ) -> None:
        page.line(ManPage.bold(name))
        page.indent()
        if process:
            for line in text:
                self.generate_description(page, line.strip())
        else:
            page.line("\n\n".join([line.strip() for line in text]))
        page.unindent()

    def generate_function(self, page: ManPage, f: Function, obj: Object = None) -> None:
        page.subsection(self.function_name(f, obj) + "()")
        page.indent(0)

        page.line(ManPage.bold("SYNOPSIS"))
        page.indent()
        self.generate_function_signature(page, f, obj)

        info = self.base_info(f)
        if info:
            page.nl()
            page.line(", ".join(info))
        page.unindent()
        page.nl()

        self.generate_sub_sub_section(page, "DESCRIPTION", [f.description])
        page.nl()

        self.generate_function_argument_section(page, "POSARGS", f.posargs)
        if f.varargs:
            self.generate_function_argument_section(page, "VARARGS", [f.varargs])
        self.generate_function_argument_section(page, "OPTARGS", f.optargs, True)
        self.generate_function_argument_section(
            page, "KWARGS", self.sorted_and_filtered(list(f.kwargs.values()))
        )

        if f.notes:
            self.generate_sub_sub_section(page, "NOTES", f.notes)
        if f.warnings:
            self.generate_sub_sub_section(page, "WARNINGS", f.warnings)
        if f.example:
            self.generate_sub_sub_section(page, "EXAMPLE", [f.example])

        page.unindent()

    def generate_object(self, page: ManPage, obj: Object) -> None:
        page.subsection(obj.name)
        page.indent(2)

        info = self.base_info(obj)
        if info:
            page.line(", ".join(info))
            page.br()

        if obj.extends:
            page.line(ManPage.bold("extends: ") + obj.extends)
            page.br()

        ret = [x.name for x in self.sorted_and_filtered(obj.returned_by)]
        if ret:
            page.line(ManPage.bold("returned_by: ") + ", ".join(ret))
            page.br()

        ext = [x.name for x in self.sorted_and_filtered(obj.extended_by)]
        if ext:
            page.line(ManPage.bold("extended_by: ") + ", ".join(ext))
            page.br()

        page.nl()

        self.generate_description(page, obj.description.strip())
        page.nl()

        if obj.notes:
            self.generate_sub_sub_section(page, "NOTES", obj.notes)
        if obj.warnings:
            self.generate_sub_sub_section(page, "WARNINGS", obj.warnings)
        if obj.example:
            self.generate_sub_sub_section(page, "EXAMPLE", [obj.example])

        page.unindent()

    def generate(self) -> None:
        page = ManPage(self.out)

        page.title("meson-reference", 3)

        page.section("NAME")
        page.par(
            f"meson-reference v{self._extract_meson_version()}"
            + " - a reference for meson functions and objects"
        )

        page.section("DESCRIPTION")
        self.generate_description(
            page,
            """This manual is divided into two sections, *FUNCTIONS* and *OBJECTS*.  *FUNCTIONS* contains a reference for all meson functions and methods.  Methods are denoted by [[object_name]].[[method_name]]().  *OBJECTS* contains additional information about each object.""",
        )

        page.section("FUNCTIONS")
        for f in self.sorted_and_filtered(self.functions):
            self.generate_function(page, f)

        for obj in self.sorted_and_filtered(self.objects):
            for f in self.sorted_and_filtered(obj.methods):
                self.generate_function(page, f, obj)

        page.section("OBJECTS")
        for obj in self.sorted_and_filtered(self.objects):
            self.generate_object(page, obj)

        page.section("SEE ALSO")
        for i in range(len(self.links)):
            link = self.links[i]
            page.line(f"[{i + 1}] {link}")
            page.br()

        page.write()

"""

```
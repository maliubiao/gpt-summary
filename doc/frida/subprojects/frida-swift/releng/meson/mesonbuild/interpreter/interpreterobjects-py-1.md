Response:
My thinking process to analyze the provided Python code and answer the user's request goes like this:

1. **Understand the Core Purpose:** The code is part of the `frida-swift` project, specifically within the Meson build system integration (`mesonbuild`). The file `interpreterobjects.py` suggests it defines Python objects that represent various build system concepts within the Meson interpreter.

2. **Identify Key Classes and Their Roles:** I'll go through each class definition and try to understand its purpose:

    * **`Test`:** Represents a test case within the build system. It holds information like the test name, the executable to run, arguments, environment variables, and expected outcomes.
    * **`NullSubprojectInterpreter`:** A placeholder or a "null object" representing a disabled or unavailable subproject.
    * **`SubprojectHolder`:**  Holds a reference to a subproject's interpreter. It manages accessing variables and checking if the subproject is "found" (enabled).
    * **`ModuleObjectHolder`:**  Acts as a wrapper around a "module object." It handles calling methods on the module object, including resolving arguments and managing the interpreter's state.
    * **`MutableModuleObjectHolder`:** Similar to `ModuleObjectHolder` but allows deep copying, suggesting it holds mutable state.
    * **`BuildTargetHolder`:** A base class for holding different types of build targets (executables, libraries, etc.). It provides common methods for accessing information about the target (name, path, output directory) and extracting object files.
    * **`ExecutableHolder`, `StaticLibraryHolder`, `SharedLibraryHolder`, `BothLibrariesHolder`, `SharedModuleHolder`, `JarHolder`:** These are specialized `BuildTargetHolder` subclasses for specific types of build outputs.
    * **`CustomTargetIndexHolder`:** Represents a single output file from a custom build step (a `CustomTarget`).
    * **`_CustomTargetHolder`:**  Holds a `CustomTarget` (a user-defined build step) and provides methods to access its output files.
    * **`CustomTargetHolder`:**  A concrete implementation of `_CustomTargetHolder`.
    * **`RunTargetHolder`, `AliasTargetHolder`, `GeneratedListHolder`:** Represent other build system concepts like targets that execute commands, aliases for other targets, and lists of generated files.
    * **`GeneratorHolder`:**  Manages code generators, allowing them to be invoked with input files and parameters.
    * **`StructuredSourcesHolder`:** Represents structured source code.

3. **Connect to Reverse Engineering (Frida Context):**  Since this is part of Frida, a dynamic instrumentation tool, the concepts here are relevant to how Frida interacts with and modifies running processes.

    * **`Test`:**  Frida uses tests to verify its functionality. These tests likely involve running applications and using Frida to observe or modify their behavior.
    * **Build Targets (Executables, Libraries):** Frida needs to interact with compiled code. Understanding how these are built (using Meson) is crucial for Frida's operation. Frida might inject code into these binaries or hook functions within them.
    * **Custom Targets/Generators:** These allow for complex build steps, which might be used to prepare Frida gadgets or support libraries that Frida uses for instrumentation.

4. **Connect to Binary/Low-Level Concepts:**

    * **Executables and Libraries:** These are fundamental binary concepts. Understanding their structure (ELF, Mach-O, PE) is essential for reverse engineering and dynamic instrumentation.
    * **Linking:** The code distinguishes between static and shared libraries, which relates to the linking process of compiled code.
    * **Object Files:** The `extract_objects` methods directly deal with object files, the intermediate output of compilation. These are the building blocks of executables and libraries.
    * **Kernel and Frameworks (Android):** While not explicitly mentioned in *this code snippet*, Frida is heavily used on Android. The build system needs to handle building Frida components for the Android environment, potentially interacting with the Android NDK and build tools.

5. **Identify Logic and Potential Inputs/Outputs:**

    * **`SubprojectHolder.get_variable_method`:**  Input: a variable name (string). Output: the value of that variable from the subproject. Error if the subproject is disabled or the variable doesn't exist.
    * **`BuildTargetHolder.extract_objects_method`:** Input: a list of files (source files or other build outputs). Output: a representation of the extracted object files.
    * **`GeneratorHolder.process_method`:** Input: a list of input files, potentially `preserve_path_from` and `extra_args`. Output: a `GeneratedList` representing the files generated by the process.

6. **Identify Potential User Errors:**

    * **Incorrect Variable Names:** In `SubprojectHolder.get_variable_method`, using a wrong variable name will lead to an `InvalidArguments` exception.
    * **Accessing Disabled Subprojects:** Trying to get a variable from a disabled subproject will raise an `InterpreterException`.
    * **Incorrect Arguments to Methods:**  The `@typed_pos_args` and `@typed_kwargs` decorators enforce the correct types and number of arguments. Passing the wrong type or number of arguments will result in errors.
    * **Invalid Index for `CustomTarget`:**  Accessing a `CustomTarget` output with an out-of-bounds index will raise an `InvalidArguments` exception.
    * **Incorrect `preserve_path_from`:** The code currently expects an absolute path. Providing a relative path will raise an `InvalidArguments` exception.

7. **Trace User Actions (Debugging):**

    * A user interacts with the Meson build system by writing `meson.build` files.
    * These files define the project structure, dependencies, build targets, and tests.
    * When Meson is run, it parses these files and creates internal representations of the build system.
    * The classes in `interpreterobjects.py` are used to represent these internal objects within the Meson interpreter.
    * For example, when a `test()` function is encountered in `meson.build`, a `Test` object is created.
    * When a `subproject()` function is called, a `SubprojectHolder` is created.
    * When a library or executable is defined, the corresponding `BuildTargetHolder` subclass is instantiated.
    * During the build process, Meson uses these objects to determine how to compile the code, link libraries, and run tests.

8. **Synthesize the Summary:** Based on the analysis, I can now summarize the file's functions. It essentially defines Python objects that mirror build system concepts, enabling Meson to manage and manipulate them during the build process. These objects provide methods for accessing information and performing actions related to building software, which is crucial for a tool like Frida that needs to interact with compiled code.
这是 frida 动态 instrumentation 工具的源代码文件 `interpreterobjects.py` 的第二部分，该文件定义了 Meson 构建系统中用于表示各种构建目标和相关对象的 Python 类。这些类在 Meson 解释器中被使用，以便处理 `meson.build` 文件中的指令。

**功能归纳:**

总的来说，`interpreterobjects.py` 的这部分主要负责定义以下类型的对象，并在 Meson 解释器中提供对这些对象的操作和信息的访问：

* **测试 (Test):**  代表一个测试用例，包含了运行测试所需的信息，例如可执行文件、参数、环境变量等。
* **子项目 (SubprojectHolder):**  用于管理嵌套的 Meson 子项目，允许访问子项目的变量和状态。
* **模块对象 (ModuleObjectHolder, MutableModuleObjectHolder):**  用于封装 Meson 模块提供的对象，并允许调用这些对象的方法。
* **构建目标 (BuildTargetHolder 及其子类):**  代表各种类型的构建产物，例如可执行文件 (`ExecutableHolder`)、静态库 (`StaticLibraryHolder`)、共享库 (`SharedLibraryHolder`)、同时构建静态和共享库 (`BothLibrariesHolder`)、共享模块 (`SharedModuleHolder`) 和 Java 的 JAR 包 (`JarHolder`)。提供了访问构建目标属性 (如名称、路径、输出目录) 和执行操作 (如提取对象文件) 的方法。
* **自定义目标索引 (CustomTargetIndexHolder):**  代表自定义构建目标输出的单个文件。
* **自定义目标 (CustomTargetHolder):**  代表用户定义的构建步骤，可以生成一个或多个输出文件。
* **运行目标 (RunTargetHolder):**  代表一个在构建过程中需要执行的命令或脚本。
* **别名目标 (AliasTargetHolder):**  为一个或多个其他目标提供一个别名。
* **生成列表 (GeneratedListHolder):**  代表由代码生成器生成的文件的列表。
* **代码生成器 (GeneratorHolder):**  代表一个代码生成工具，可以根据输入文件生成输出文件。
* **结构化源文件 (StructuredSourcesHolder):**  代表以结构化方式组织的源文件。

**与逆向方法的关系及举例说明:**

Frida 是一个用于动态分析、监控和修改应用程序行为的工具，因此 `interpreterobjects.py` 中定义的构建目标与逆向工程密切相关：

* **可执行文件 (`ExecutableHolder`):**  逆向工程师通常需要分析可执行文件的行为。Meson 构建的可执行文件最终会被 Frida 加载并进行 instrumentation。例如，使用 Frida 可以 hook 可执行文件中的函数，查看其参数和返回值。
* **共享库 (`SharedLibraryHolder`):**  许多应用程序使用共享库来实现模块化。逆向分析共享库可以了解应用程序的功能和所使用的算法。Frida 可以注入到加载了这些共享库的进程中，并对库中的函数进行 hook 或修改。
* **代码生成器 (`GeneratorHolder`):**  在某些复杂的项目中，可能会使用代码生成器来创建特定的代码或配置文件。理解代码生成器的作用有助于逆向工程师理解最终构建产物的结构和行为。例如，某些混淆技术可能会使用代码生成器动态生成代码。
* **自定义目标 (`CustomTargetHolder`):**  自定义目标可以执行任意构建步骤，这可能包括一些与逆向相关的操作，例如对二进制文件进行后处理、生成特定的数据文件等。

**二进制底层、Linux、Android 内核及框架知识及举例说明:**

这个文件本身是 Meson 构建系统的代码，更多地关注构建流程的抽象，但它所操作的对象与底层的概念紧密相关：

* **可执行文件和库:** 这些是操作系统加载和执行的二进制文件。理解 ELF (Linux) 或 Mach-O (macOS) 等二进制文件格式对于理解如何构建和逆向这些目标至关重要。
* **静态库和共享库:**  涉及到链接器的知识。静态库在链接时被复制到可执行文件中，而共享库在运行时动态加载。这影响了 Frida 如何 attach 和 hook 这些库。
* **Android:** 虽然代码本身没有显式提到 Android 内核，但 Frida 在 Android 平台上广泛使用。Meson 构建系统需要处理交叉编译，生成适用于 Android 平台的二进制文件。`SharedLibraryHolder` 和 `ExecutableHolder` 代表的产物会被部署到 Android 设备上，并可能与 Android 的框架进行交互。
* **输出目录 (`outdir_method`):**  构建系统需要管理构建产物的输出路径，这涉及到文件系统和路径管理的基本概念。在 Android 开发中，这可能涉及到 APK 文件的结构和库的放置位置。

**逻辑推理、假设输入与输出:**

* **`SubprojectHolder.get_variable_method`:**
    * **假设输入:**  一个 `SubprojectHolder` 对象，代表一个已启用的子项目，以及一个字符串 "my_variable" 作为要获取的变量名。
    * **预期输出:**  子项目中名为 "my_variable" 的变量的值 (类型取决于变量的定义)。如果变量不存在，则会抛出 `InvalidArguments` 异常。如果子项目被禁用，则会抛出 `InterpreterException`。
* **`BuildTargetHolder.extract_objects_method`:**
    * **假设输入:** 一个 `BuildTargetHolder` 对象，代表一个已编译的目标文件 (例如可执行文件或库)，以及一个包含源文件路径的列表。
    * **预期输出:** 一个 `build.ExtractedObjects` 对象，其中包含了从指定源文件编译出的对象文件信息。

**用户或编程常见的使用错误及举例说明:**

* **在禁用子项目上调用 `get_variable`:**
    * **错误代码:**  假设 `subproj` 是一个 `SubprojectHolder` 对象，代表一个被禁用的子项目。尝试执行 `subproj.get_variable('some_var')` 将会抛出 `InterpreterException`。
    * **用户操作步骤:** 用户在 `meson.build` 文件中使用了 `subproject()` 函数定义了一个子项目，但由于某些条件 (例如缺失的依赖) 导致该子项目被禁用。然后在主项目的 `meson.build` 文件中尝试访问该子项目的变量。
* **向 `extract_objects` 传递错误的参数类型:**
    * **错误代码:** 假设 `my_target` 是一个 `BuildTargetHolder` 对象。尝试执行 `my_target.extract_objects(123)` 将会因为参数类型不匹配而导致错误 (期望的是文件路径或文件对象)。
    * **用户操作步骤:**  用户在 `meson.build` 文件中调用了某个构建目标的 `extract_objects` 方法，但传递了一个错误的参数类型，例如整数而不是字符串或文件对象。
* **访问 `CustomTarget` 超出范围的索引:**
    * **错误代码:** 假设 `my_custom_target` 是一个 `CustomTargetHolder` 对象，它生成了 2 个输出文件。尝试执行 `my_custom_target[2]` 将会抛出 `InvalidArguments` 异常，因为索引从 0 开始，最大索引为 1。
    * **用户操作步骤:** 用户在 `meson.build` 文件中定义了一个 `custom_target`，并尝试通过索引访问其输出文件，但使用了超出实际输出文件数量的索引。

**用户操作如何一步步到达这里 (调试线索):**

1. **编写 `meson.build` 文件:** 用户首先会编写 `meson.build` 文件来描述他们的项目结构、依赖关系和构建目标。
2. **运行 `meson` 命令:** 用户在项目根目录下运行 `meson <build_directory>` 命令来配置构建。Meson 会解析 `meson.build` 文件。
3. **Meson 解释器执行:** 在解析过程中，Meson 解释器会执行 `meson.build` 文件中的代码。当遇到声明构建目标 (如 `executable()`, `shared_library()`, `custom_target()`) 或子项目 (`subproject()`) 的函数时，解释器会创建相应的 `InterpreterObject` 类的实例 (例如 `ExecutableHolder`, `SharedLibraryHolder`, `CustomTargetHolder`, `SubprojectHolder`) 来表示这些构建元素。
4. **访问对象属性或方法:** 在 `meson.build` 文件中，用户可能会访问这些构建对象的属性 (例如 `.name()`, `.full_path()`) 或调用它们的方法 (例如 `.extract_objects()`, `.get_variable()`)。这些操作会调用 `interpreterobjects.py` 中定义的方法。
5. **错误发生:** 如果用户在 `meson.build` 文件中使用了错误的语法、错误的参数类型，或者尝试访问不存在的属性或方法，Meson 解释器在执行到相关的代码时就会调用到 `interpreterobjects.py` 中定义的方法，并可能在那里抛出异常。

作为调试线索，当用户报告 Meson 构建错误时，查看错误信息中的调用栈可以帮助定位问题是否发生在与 `interpreterobjects.py` 中定义的对象操作相关的部分。例如，如果错误信息显示 `SubprojectHolder.get_variable_method` 抛出了异常，那么问题可能出在用户尝试访问子项目变量的方式上。

### 提示词
```
这是目录为frida/subprojects/frida-swift/releng/meson/mesonbuild/interpreter/interpreterobjects.py的fridaDynamic instrumentation tool的源代码文件， 请列举一下它的功能, 
如果它与逆向的方法有关系，请做出对应的举例说明，
如果涉及到二进制底层，linux, android内核及框架的知识，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索。
这是第2部分，共2部分，请归纳一下它的功能
```

### 源代码
```python
super().__init__()
        self.name = name
        self.suite = listify(suite)
        self.project_name = project
        self.exe = exe
        self.depends = depends
        self.is_parallel = is_parallel
        self.cmd_args = cmd_args
        self.env = env
        self.should_fail = should_fail
        self.timeout = timeout
        self.workdir = workdir
        self.protocol = TestProtocol.from_str(protocol)
        self.priority = priority
        self.verbose = verbose

    def get_exe(self) -> T.Union[ExternalProgram, build.Executable, build.CustomTarget, build.CustomTargetIndex]:
        return self.exe

    def get_name(self) -> str:
        return self.name

class NullSubprojectInterpreter(HoldableObject):
    pass

# TODO: This should really be an `ObjectHolder`, but the additional stuff in this
#       class prevents this. Thus, this class should be split into a pure
#       `ObjectHolder` and a class specifically for storing in `Interpreter`.
class SubprojectHolder(MesonInterpreterObject):

    def __init__(self, subinterpreter: T.Union['Interpreter', NullSubprojectInterpreter],
                 subdir: str,
                 warnings: int = 0,
                 disabled_feature: T.Optional[str] = None,
                 exception: T.Optional[Exception] = None,
                 callstack: T.Optional[mesonlib.PerMachine[T.List[str]]] = None) -> None:
        super().__init__()
        self.held_object = subinterpreter
        self.warnings = warnings
        self.disabled_feature = disabled_feature
        self.exception = exception
        self.subdir = PurePath(subdir).as_posix()
        self.cm_interpreter: T.Optional[CMakeInterpreter] = None
        self.callstack = callstack.host if callstack else None
        self.methods.update({'get_variable': self.get_variable_method,
                             'found': self.found_method,
                             })

    @noPosargs
    @noKwargs
    def found_method(self, args: T.List[TYPE_var], kwargs: TYPE_kwargs) -> bool:
        return self.found()

    def found(self) -> bool:
        return not isinstance(self.held_object, NullSubprojectInterpreter)

    @noKwargs
    @noArgsFlattening
    @unholder_return
    def get_variable_method(self, args: T.List[TYPE_var], kwargs: TYPE_kwargs) -> T.Union[TYPE_var, InterpreterObject]:
        if len(args) < 1 or len(args) > 2:
            raise InterpreterException('Get_variable takes one or two arguments.')
        if isinstance(self.held_object, NullSubprojectInterpreter):  # == not self.found()
            raise InterpreterException(f'Subproject "{self.subdir}" disabled can\'t get_variable on it.')
        varname = args[0]
        if not isinstance(varname, str):
            raise InterpreterException('Get_variable first argument must be a string.')
        try:
            return self.held_object.variables[varname]
        except KeyError:
            pass

        if len(args) == 2:
            return self.held_object._holderify(args[1])

        raise InvalidArguments(f'Requested variable "{varname}" not found.')

class ModuleObjectHolder(ObjectHolder[ModuleObject]):
    def method_call(self, method_name: str, args: T.List[TYPE_var], kwargs: TYPE_kwargs) -> TYPE_var:
        modobj = self.held_object
        method = modobj.methods.get(method_name)
        if not method:
            raise InvalidCode(f'Unknown method {method_name!r} in object.')
        if not getattr(method, 'no-args-flattening', False):
            args = flatten(args)
        if not getattr(method, 'no-second-level-holder-flattening', False):
            args, kwargs = resolve_second_level_holders(args, kwargs)
        state = ModuleState(self.interpreter)
        # Many modules do for example self.interpreter.find_program_impl(),
        # so we have to ensure they use the current interpreter and not the one
        # that first imported that module, otherwise it will use outdated
        # overrides.
        if isinstance(modobj, ExtensionModule):
            modobj.interpreter = self.interpreter
        ret = method(state, args, kwargs)
        if isinstance(ret, ModuleReturnValue):
            self.interpreter.process_new_values(ret.new_objects)
            ret = ret.return_value
        return ret

class MutableModuleObjectHolder(ModuleObjectHolder, MutableInterpreterObject):
    def __deepcopy__(self, memo: T.Dict[int, T.Any]) -> 'MutableModuleObjectHolder':
        # Deepcopy only held object, not interpreter
        modobj = copy.deepcopy(self.held_object, memo)
        return MutableModuleObjectHolder(modobj, self.interpreter)


_BuildTarget = T.TypeVar('_BuildTarget', bound=T.Union[build.BuildTarget, build.BothLibraries])

class BuildTargetHolder(ObjectHolder[_BuildTarget]):
    def __init__(self, target: _BuildTarget, interp: 'Interpreter'):
        super().__init__(target, interp)
        self.methods.update({'extract_objects': self.extract_objects_method,
                             'extract_all_objects': self.extract_all_objects_method,
                             'name': self.name_method,
                             'get_id': self.get_id_method,
                             'outdir': self.outdir_method,
                             'full_path': self.full_path_method,
                             'path': self.path_method,
                             'found': self.found_method,
                             'private_dir_include': self.private_dir_include_method,
                             })

    def __repr__(self) -> str:
        r = '<{} {}: {}>'
        h = self.held_object
        assert isinstance(h, build.BuildTarget)
        return r.format(self.__class__.__name__, h.get_id(), h.filename)

    @property
    def _target_object(self) -> build.BuildTarget:
        if isinstance(self.held_object, build.BothLibraries):
            return self.held_object.get_default_object()
        assert isinstance(self.held_object, build.BuildTarget)
        return self.held_object

    def is_cross(self) -> bool:
        return not self._target_object.environment.machines.matches_build_machine(self._target_object.for_machine)

    @noPosargs
    @noKwargs
    def found_method(self, args: T.List[TYPE_var], kwargs: TYPE_kwargs) -> bool:
        if not (isinstance(self.held_object, build.Executable) and self.held_object.was_returned_by_find_program):
            FeatureNew.single_use('BuildTarget.found', '0.59.0', subproject=self.held_object.subproject)
        return True

    @noPosargs
    @noKwargs
    def private_dir_include_method(self, args: T.List[TYPE_var], kwargs: TYPE_kwargs) -> build.IncludeDirs:
        return build.IncludeDirs('', [], False, [self.interpreter.backend.get_target_private_dir(self._target_object)],
                                 self.interpreter.coredata.is_build_only)

    @noPosargs
    @noKwargs
    def full_path_method(self, args: T.List[TYPE_var], kwargs: TYPE_kwargs) -> str:
        return self.interpreter.backend.get_target_filename_abs(self._target_object)

    @noPosargs
    @noKwargs
    @FeatureDeprecated('BuildTarget.path', '0.55.0', 'Use BuildTarget.full_path instead')
    def path_method(self, args: T.List[TYPE_var], kwargs: TYPE_kwargs) -> str:
        return self.interpreter.backend.get_target_filename_abs(self._target_object)

    @noPosargs
    @noKwargs
    def outdir_method(self, args: T.List[TYPE_var], kwargs: TYPE_kwargs) -> str:
        return self.interpreter.backend.get_target_dir(self._target_object)

    @noKwargs
    @typed_pos_args('extract_objects', varargs=(mesonlib.File, str, build.CustomTarget, build.CustomTargetIndex, build.GeneratedList))
    def extract_objects_method(self, args: T.Tuple[T.List[T.Union[mesonlib.FileOrString, 'build.GeneratedTypes']]], kwargs: TYPE_nkwargs) -> build.ExtractedObjects:
        return self._target_object.extract_objects(args[0])

    @noPosargs
    @typed_kwargs(
        'extract_all_objects',
        KwargInfo(
            'recursive', bool, default=False, since='0.46.0',
            not_set_warning=textwrap.dedent('''\
                extract_all_objects called without setting recursive
                keyword argument. Meson currently defaults to
                non-recursive to maintain backward compatibility but
                the default will be changed in the future.
            ''')
        )
    )
    def extract_all_objects_method(self, args: T.List[TYPE_nvar], kwargs: 'kwargs.BuildTargeMethodExtractAllObjects') -> build.ExtractedObjects:
        return self._target_object.extract_all_objects(kwargs['recursive'])

    @noPosargs
    @noKwargs
    @FeatureDeprecated('BuildTarget.get_id', '1.2.0',
                       'This was never formally documented and does not seem to have a real world use. ' +
                       'See https://github.com/mesonbuild/meson/pull/6061')
    def get_id_method(self, args: T.List[TYPE_var], kwargs: TYPE_kwargs) -> str:
        return self._target_object.get_id()

    @FeatureNew('name', '0.54.0')
    @noPosargs
    @noKwargs
    def name_method(self, args: T.List[TYPE_var], kwargs: TYPE_kwargs) -> str:
        return self._target_object.name

class ExecutableHolder(BuildTargetHolder[build.Executable]):
    pass

class StaticLibraryHolder(BuildTargetHolder[build.StaticLibrary]):
    pass

class SharedLibraryHolder(BuildTargetHolder[build.SharedLibrary]):
    pass

class BothLibrariesHolder(BuildTargetHolder[build.BothLibraries]):
    def __init__(self, libs: build.BothLibraries, interp: 'Interpreter'):
        # FIXME: This build target always represents the shared library, but
        # that should be configurable.
        super().__init__(libs, interp)
        self.methods.update({'get_shared_lib': self.get_shared_lib_method,
                             'get_static_lib': self.get_static_lib_method,
                             })

    def __repr__(self) -> str:
        r = '<{} {}: {}, {}: {}>'
        h1 = self.held_object.shared
        h2 = self.held_object.static
        return r.format(self.__class__.__name__, h1.get_id(), h1.filename, h2.get_id(), h2.filename)

    @noPosargs
    @noKwargs
    def get_shared_lib_method(self, args: T.List[TYPE_var], kwargs: TYPE_kwargs) -> build.SharedLibrary:
        return self.held_object.shared

    @noPosargs
    @noKwargs
    def get_static_lib_method(self, args: T.List[TYPE_var], kwargs: TYPE_kwargs) -> build.StaticLibrary:
        return self.held_object.static

class SharedModuleHolder(BuildTargetHolder[build.SharedModule]):
    pass

class JarHolder(BuildTargetHolder[build.Jar]):
    pass

class CustomTargetIndexHolder(ObjectHolder[build.CustomTargetIndex]):
    def __init__(self, target: build.CustomTargetIndex, interp: 'Interpreter'):
        super().__init__(target, interp)
        self.methods.update({'full_path': self.full_path_method,
                             })

    @FeatureNew('custom_target[i].full_path', '0.54.0')
    @noPosargs
    @noKwargs
    def full_path_method(self, args: T.List[TYPE_var], kwargs: TYPE_kwargs) -> str:
        assert self.interpreter.backend is not None
        return self.interpreter.backend.get_target_filename_abs(self.held_object)

_CT = T.TypeVar('_CT', bound=build.CustomTarget)

class _CustomTargetHolder(ObjectHolder[_CT]):
    def __init__(self, target: _CT, interp: 'Interpreter'):
        super().__init__(target, interp)
        self.methods.update({'full_path': self.full_path_method,
                             'to_list': self.to_list_method,
                             })

        self.operators.update({
            MesonOperator.INDEX: self.op_index,
        })

    def __repr__(self) -> str:
        r = '<{} {}: {}>'
        h = self.held_object
        return r.format(self.__class__.__name__, h.get_id(), h.command)

    @noPosargs
    @noKwargs
    def full_path_method(self, args: T.List[TYPE_var], kwargs: TYPE_kwargs) -> str:
        return self.interpreter.backend.get_target_filename_abs(self.held_object)

    @FeatureNew('custom_target.to_list', '0.54.0')
    @noPosargs
    @noKwargs
    def to_list_method(self, args: T.List[TYPE_var], kwargs: TYPE_kwargs) -> T.List[build.CustomTargetIndex]:
        result = []
        for i in self.held_object:
            result.append(i)
        return result

    @noKwargs
    @typed_operator(MesonOperator.INDEX, int)
    def op_index(self, other: int) -> build.CustomTargetIndex:
        try:
            return self.held_object[other]
        except IndexError:
            raise InvalidArguments(f'Index {other} out of bounds of custom target {self.held_object.name} output of size {len(self.held_object)}.')

class CustomTargetHolder(_CustomTargetHolder[build.CustomTarget]):
    pass

class RunTargetHolder(ObjectHolder[build.RunTarget]):
    pass

class AliasTargetHolder(ObjectHolder[build.AliasTarget]):
    pass

class GeneratedListHolder(ObjectHolder[build.GeneratedList]):
    pass

class GeneratorHolder(ObjectHolder[build.Generator]):
    def __init__(self, gen: build.Generator, interpreter: 'Interpreter'):
        super().__init__(gen, interpreter)
        self.methods.update({'process': self.process_method})

    @typed_pos_args('generator.process', min_varargs=1, varargs=(str, mesonlib.File, build.CustomTarget, build.CustomTargetIndex, build.GeneratedList))
    @typed_kwargs(
        'generator.process',
        KwargInfo('preserve_path_from', (str, NoneType), since='0.45.0'),
        KwargInfo('extra_args', ContainerTypeInfo(list, str), listify=True, default=[]),
        ENV_KW.evolve(since='1.3.0')
    )
    def process_method(self,
                       args: T.Tuple[T.List[T.Union[str, mesonlib.File, 'build.GeneratedTypes']]],
                       kwargs: 'kwargs.GeneratorProcess') -> build.GeneratedList:
        preserve_path_from = kwargs['preserve_path_from']
        if preserve_path_from is not None:
            preserve_path_from = os.path.normpath(preserve_path_from)
            if not os.path.isabs(preserve_path_from):
                # This is a bit of a hack. Fix properly before merging.
                raise InvalidArguments('Preserve_path_from must be an absolute path for now. Sorry.')

        if any(isinstance(a, (build.CustomTarget, build.CustomTargetIndex, build.GeneratedList)) for a in args[0]):
            FeatureNew.single_use(
                'Calling generator.process with CustomTarget or Index of CustomTarget.',
                '0.57.0', self.interpreter.subproject)

        gl = self.held_object.process_files(args[0], self.interpreter,
                                            preserve_path_from, extra_args=kwargs['extra_args'], env=kwargs['env'])

        return gl


class StructuredSourcesHolder(ObjectHolder[build.StructuredSources]):

    def __init__(self, sources: build.StructuredSources, interp: 'Interpreter'):
        super().__init__(sources, interp)
```
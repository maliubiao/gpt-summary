Response:
### 功能归纳

`frida-core/src/fruity/injector.vala` 文件是 Frida 动态插桩工具的一部分，主要用于在 iOS/macOS 平台上通过 LLDB 调试器将 Frida Gadget 注入到目标进程中。以下是该文件的主要功能：

1. **注入 Frida Gadget**：
   - 该文件的核心功能是通过 LLDB 将 Frida Gadget 注入到目标进程中。Frida Gadget 是一个动态库，允许在目标进程中执行 JavaScript 代码，从而实现动态插桩。

2. **与 LLDB 交互**：
   - 该文件通过 LLDB 的 API 与目标进程进行交互，包括读取/写入内存、分配/释放内存、保存/恢复线程状态等操作。

3. **处理 Mach-O 文件**：
   - 该文件处理 Mach-O 文件（iOS/macOS 的可执行文件格式），包括解析 Mach-O 文件中的符号、重定位信息、绑定信息等。

4. **动态库加载与符号解析**：
   - 该文件负责加载动态库并解析其中的符号，确保 Frida Gadget 能够正确调用目标进程中的函数。

5. **线程管理与状态保存**：
   - 在注入过程中，该文件会保存目标进程的主线程状态，并在注入完成后恢复线程状态，以确保目标进程的正常运行。

6. **网络通信**：
   - 该文件通过 TCP 端口与 Frida Gadget 进行通信，确保 Frida 能够与目标进程进行交互。

### 二进制底层与 Linux 内核相关

虽然该文件主要针对 iOS/macOS 平台，但其中涉及的一些概念和技术在 Linux 内核中也有类似的应用：

1. **内存管理**：
   - 该文件通过 LLDB 分配和释放内存页，类似于 Linux 内核中的 `mmap` 和 `munmap` 系统调用。

2. **线程状态保存与恢复**：
   - 该文件保存和恢复线程的寄存器状态，类似于 Linux 内核中的 `ptrace` 系统调用，可以用于调试和控制进程的执行。

3. **动态库加载与符号解析**：
   - 该文件处理 Mach-O 文件中的符号和重定位信息，类似于 Linux 中的 ELF 文件格式和动态链接器（`ld.so`）的功能。

### LLDB 指令与 Python 脚本示例

以下是一个使用 LLDB 指令和 Python 脚本的示例，用于复刻该文件中的调试功能：

#### LLDB 指令示例

```lldb
# 附加到目标进程
(lldb) process attach --pid <PID>

# 分配内存页
(lldb) memory allocate --size 16384 --permissions rx

# 读取内存
(lldb) memory read --format x --size 8 <address>

# 写入内存
(lldb) memory write <address> <value>

# 保存线程状态
(lldb) thread list
(lldb) thread select <thread_id>
(lldb) register read

# 恢复线程状态
(lldb) register write <register> <value>
```

#### LLDB Python 脚本示例

```python
import lldb

def inject_gadget(debugger, command, result, internal_dict):
    target = debugger.GetSelectedTarget()
    process = target.GetProcess()
    thread = process.GetSelectedThread()

    # 分配内存页
    error = lldb.SBError()
    jit_page = process.AllocateMemory(16384, lldb.ePermissionsReadable | lldb.ePermissionsExecutable, error)
    if error.Fail():
        result.AppendMessage("Failed to allocate memory: " + error.GetCString())
        return

    # 保存线程状态
    frame = thread.GetSelectedFrame()
    registers = frame.GetRegisters()
    saved_state = {}
    for reg in registers:
        for reg_value in reg:
            saved_state[reg_value.GetName()] = reg_value.GetValue()

    # 恢复线程状态
    for reg_name, reg_value in saved_state.items():
        frame.SetRegisterValue(reg_name, reg_value)

    # 写入内存
    process.WriteMemory(jit_page, b"\x90\x90\x90\x90", error)  # NOP sled example
    if error.Fail():
        result.AppendMessage("Failed to write memory: " + error.GetCString())
        return

    result.AppendMessage("Gadget injected successfully!")

# 注册 LLDB 命令
def __lldb_init_module(debugger, internal_dict):
    debugger.HandleCommand('command script add -f inject_gadget.inject_gadget inject_gadget')
```

### 假设输入与输出

假设输入是一个目标进程的 PID，输出是成功注入 Frida Gadget 并返回一个 TCP 端口号，用于与 Frida 进行通信。

- **输入**：目标进程的 PID（例如 `1234`）。
- **输出**：成功注入后返回的 TCP 端口号（例如 `27043`）。

### 用户常见使用错误

1. **权限不足**：
   - 用户可能没有足够的权限附加到目标进程或分配内存。解决方法是以 root 权限运行 LLDB。

2. **目标进程崩溃**：
   - 如果注入过程中出现错误，目标进程可能会崩溃。解决方法是在注入前确保目标进程处于稳定状态，并在注入过程中进行错误处理。

3. **符号解析失败**：
   - 如果目标进程中的符号无法解析，Frida Gadget 可能无法正常工作。解决方法是确保目标进程的符号表可用，并在注入前进行符号解析。

### 用户操作步骤

1. **启动目标进程**：
   - 用户启动目标进程并获取其 PID。

2. **启动 LLDB 并附加到目标进程**：
   - 用户启动 LLDB 并附加到目标进程。

3. **执行注入脚本**：
   - 用户执行注入脚本，将 Frida Gadget 注入到目标进程中。

4. **与 Frida 进行交互**：
   - 用户通过返回的 TCP 端口号与 Frida 进行交互，执行 JavaScript 代码进行动态插桩。

通过这些步骤，用户可以成功地将 Frida Gadget 注入到目标进程中，并进行动态插桩操作。
Prompt: 
```
这是目录为frida/subprojects/frida-core/src/fruity/injector.vala的frida Dynamic instrumentation tool的源代码文件， 请列举一下它的功能, 
如果涉及到二进制底层，linux内核，请做出对应的举例说明，
请给出用lldb指令或者lldb python脚本，用来复刻的源代码所实现调试功能的示例，如果源代码是调试功能的实现。
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索，
请用中文回复。
这是第1部分，共3部分，请归纳一下它的功能

"""
[CCode (gir_namespace = "FridaFruityInjector", gir_version = "1.0")]
namespace Frida.Fruity.Injector {
	public static async GadgetDetails inject (owned Gum.DarwinModule module, LLDB.Client lldb, HostChannelProvider channel_provider,
			Cancellable? cancellable) throws Error, IOError {
		var session = new Session (module, lldb, channel_provider);
		return yield session.run (cancellable);
	}

	public class GadgetDetails : Object {
		public uint16 port {
			get;
			construct;
		}

		public GadgetDetails (uint16 port) {
			Object (port: port);
		}
	}

	public errordomain Error {
		UNSUPPORTED
	}

	private class Session : Object {
		public Gum.DarwinModule module {
			get;
			construct;
		}

		public LLDB.Client lldb {
			get;
			construct;
		}

		public HostChannelProvider channel_provider {
			get;
			construct;
		}

		public Gum.CpuType cpu_type {
			get;
			construct;
			default = ARM64;
		}

		public uint page_size {
			get;
			construct;
			default = 16384;
		}

		public uint pointer_size {
			get;
			construct;
			default = 8;
		}

		private LLDB.Thread? main_thread;
		private LLDB.Thread.Snapshot? saved_state;
		private LLDB.Thread.StackBounds? stack_bounds;

		private uint64 jit_page;
		private uint64 scratch_page;

		private LLDB.AppleDyldFields? dyld_fields;
		private uint64 dyld_base;

		private bool libsystem_initialized;

		private size_t module_size;

		public Session (Gum.DarwinModule module, LLDB.Client lldb, HostChannelProvider channel_provider) {
			Object (
				module: module,
				lldb: lldb,
				channel_provider: channel_provider
			);
		}

		public async GadgetDetails run (Cancellable? cancellable) throws Error, IOError {
			try {
				var existing_gadget = yield setup (cancellable);
				if (existing_gadget != null) {
					yield lldb.detach (cancellable);
					return existing_gadget;
				}

				bool is_early_instrumentation = !libsystem_initialized;

				yield ensure_libsystem_initialized (cancellable);
				var result = yield inject_module (cancellable);

				yield teardown (cancellable);

				if (is_early_instrumentation) {
					var gadget_threads = new Gee.ArrayList<LLDB.Thread> ();
					yield lldb.enumerate_threads (thread => {
						if (thread.id != main_thread.id)
							gadget_threads.add (thread);
						return true;
					}, cancellable);
					yield lldb.continue_specific_threads (gadget_threads, cancellable);
				} else {
					yield lldb.detach (cancellable);
				}

				return result;
			} catch (GLib.Error e) {
				throw new Error.UNSUPPORTED ("%s", e.message);
			}
		}

		private async GadgetDetails? setup (Cancellable? cancellable) throws GLib.Error {
			GadgetDetails? existing_gadget = null;
			yield lldb.enumerate_threads (thread => {
				if (main_thread == null)
					main_thread = thread;

				unowned string? name = thread.name;
				if (name == null)
					return true;

				MatchInfo info;
				if (/^frida-gadget-tcp-(\d+)$/.match (name, 0, out info)) {
					string raw_port = info.fetch (1);

					try {
						uint64 port;
						const uint radix = 10;
						uint64.from_string (raw_port, out port, radix, 1, uint16.MAX);

						existing_gadget = new GadgetDetails ((uint16) port);

						return false;
					} catch (NumberParserError e) {
					}
				}

				return true;
			}, cancellable);
			if (existing_gadget != null)
				return existing_gadget;
			yield save_main_thread_state (cancellable);

			jit_page = yield lldb.allocate (page_size, "rx", cancellable);
			scratch_page = yield lldb.allocate (page_size, "rw", cancellable);

			dyld_fields = yield lldb.get_apple_dyld_fields (ALLOW_CACHE, cancellable);
			libsystem_initialized = yield lldb.read_bool (dyld_fields.libsystem_initialized, cancellable);
			if (libsystem_initialized) {
				dyld_base = yield lldb.read_pointer (dyld_fields.dyld_load_address, cancellable);
			} else {
				yield lldb.enumerate_modules (m => {
					if (m.pathname == "/usr/lib/dyld" || m.pathname == "/binpack/lib/dyld") {
						dyld_base = m.load_address;
						return false;
					}

					return true;
				}, cancellable);
			}

			return null;
		}

		private async void teardown (Cancellable? cancellable) throws GLib.Error {
			yield lldb.deallocate (scratch_page, cancellable);
			yield lldb.deallocate (jit_page, cancellable);

			yield restore_main_thread_state (cancellable);
		}

		private async void save_main_thread_state (Cancellable? cancellable) throws GLib.Error {
			assert (saved_state == null);
			saved_state = yield main_thread.save_register_state (cancellable);

			stack_bounds = null;
		}

		private async void restore_main_thread_state (Cancellable? cancellable) throws GLib.Error {
			assert (saved_state != null);
			yield main_thread.restore_register_state (saved_state, cancellable);
			saved_state = null;
		}

		private async GadgetDetails inject_module (Cancellable? cancellable) throws GLib.Error {
			module_size = compute_virtual_size (module);
			module.base_address = yield lldb.allocate (module_size, "rw", cancellable);

			unowned Gum.DarwinModuleImage image = module.image;
			unowned uint8[] image_data = ((uint8[]) image.data)[0:image.size];
			var buffer = lldb.make_buffer (new Bytes.static (image_data));

			perform_rebase_operations (buffer);

			var symbols_needed = new SymbolQueryBuilder ();
			var threaded_items = new ThreadedItemsBuilder ();
			var chained_fixups = new ChainedFixupsBuilder ();

			collect_needed_symbols_and_threaded_items (buffer, symbols_needed, threaded_items);
			collect_chained_fixups (chained_fixups);
			UploadSymbols.extend_query (symbols_needed);

			var symbols = yield resolve_symbols (symbols_needed.build (), cancellable);

			if (threaded_items.is_empty)
				perform_bind_operations (buffer, symbols);

			var gadget_port = yield upload (buffer, threaded_items.build (symbols), chained_fixups.build (),
				new UploadSymbols.from_set (symbols), cancellable);

			return new GadgetDetails (gadget_port);
		}

		private void perform_rebase_operations (Buffer buffer) throws GLib.Error {
			GLib.Error? pending_error = null;

			module.enumerate_rebases (rebase => {
				switch (rebase.type) {
					case POINTER:
					case TEXT_ABSOLUTE32:
						break;
					default:
						pending_error = new Error.UNSUPPORTED ("Unsupported rebase type: %u", rebase.type);
						return false;
				}

				size_t offset = (size_t) (rebase.segment.file_offset + rebase.offset);
				uint64 address = buffer.read_pointer (offset);
				buffer.write_pointer (offset, address + rebase.slide);

				return true;
			});

			if (pending_error != null)
				throw pending_error;
		}

		private void collect_needed_symbols_and_threaded_items (Buffer buffer, SymbolQueryBuilder symbols_needed,
				ThreadedItemsBuilder threaded_items) throws GLib.Error {
			Gum.Address slide = module.slide;
			bool have_threaded_items = false;
			GLib.Error? pending_error = null;

			Gum.FoundDarwinBindFunc collect_bind = bind => {
				switch (bind.type) {
					case POINTER: {
						switch (bind.library_ordinal) {
							case SELF:
							case MAIN_EXECUTABLE:
							case FLAT_LOOKUP:
							case WEAK_LOOKUP:
								pending_error = new Error.UNSUPPORTED ("Unsupported bind ordinal: %d",
									bind.library_ordinal);
								return false;
							default:
								break;
						}

						unowned string module_name = module.get_dependency_by_ordinal (bind.library_ordinal);
						unowned string symbol_name = bind.symbol_name;

						symbols_needed.add (module_name, symbol_name);
						if (have_threaded_items)
							threaded_items.add_symbol (module_name, symbol_name);

						break;
					}
					case THREADED_TABLE:
						have_threaded_items = true;
						break;
					case THREADED_ITEMS:
						threaded_items.add_region (bind.segment.vm_address + slide + bind.offset);
						break;
					default:
						pending_error = new Error.UNSUPPORTED ("Unsupported bind type: %u", bind.type);
						return false;
				}

				return true;
			};

			module.enumerate_binds (collect_bind);
			if (pending_error != null)
				throw pending_error;

			module.enumerate_lazy_binds (collect_bind);
			if (pending_error != null)
				throw pending_error;
		}

		private void collect_chained_fixups (ChainedFixupsBuilder chained_fixups) {
			module.enumerate_chained_fixups (fixup => {
				chained_fixups.add_location (fixup.vm_address);
				return true;
			});
		}

		private void perform_bind_operations (Buffer buffer, SymbolSet symbols) throws GLib.Error {
			GLib.Error? pending_error = null;

			Gum.FoundDarwinBindFunc perform_bind = bind => {
				unowned string module_name = module.get_dependency_by_ordinal (bind.library_ordinal);
				unowned string symbol_name = bind.symbol_name;

				uint64 address;
				if (!symbols.lookup (module_name, symbol_name, out address)) {
					bool is_weak = (bind.symbol_flags & Gum.DarwinBindSymbolFlags.WEAK_IMPORT) != 0;
					if (is_weak || is_dyld_stub_binder (module_name, symbol_name))
						return true;
					pending_error = new Error.UNSUPPORTED ("Unable to resolve symbol: %s", bind.symbol_name);
					return false;
				}

				buffer.write_pointer ((size_t) (bind.segment.file_offset + bind.offset), address + bind.addend);

				return true;
			};

			module.enumerate_binds (perform_bind);
			if (pending_error != null)
				throw pending_error;

			module.enumerate_lazy_binds (perform_bind);
			if (pending_error != null)
				throw pending_error;
		}

		private async uint16 upload (Buffer buffer, ThreadedItems threaded_items, ChainedFixups chained_fixups,
				UploadSymbols symbols, Cancellable? cancellable) throws GLib.Error {
			uint64 code = jit_page;
			yield lldb.write_byte_array (code, new Bytes.static (UPLOAD_LISTENER_CODE), cancellable);

			const uint64 rx_buffer_size = 1024 * 1024;

			uint64 args = scratch_page;
			var args_builder = lldb.make_buffer_builder ();

			string range_param = ("frida_dylib_range=0x%" + uint64.FORMAT_MODIFIER + "x,0x%" + size_t.FORMAT_MODIFIER + "x")
				.printf (module.base_address, module_size);

			var config = new Json.Builder ();
			config
				.begin_object ()
					.set_member_name ("interaction")
					.begin_object ()
						.set_member_name ("type")
						.add_string_value ("listen")
						.set_member_name ("port")
						.add_int_value (27043)
						.set_member_name ("on_port_conflict")
						.add_string_value ("pick-next")
						.set_member_name ("on_load")
						.add_string_value ("resume")
					.end_object ()
					.set_member_name ("teardown")
					.add_string_value ("full")
				.end_object ();
			string raw_config = Json.to_string (config.get_root (), false);
			string config_param = "frida_gadget_config=" + Base64.encode (raw_config.data);

			var apple_strv_builder = new StringVectorBuilder (args_builder);

			apple_strv_builder
				.append_string (range_param)
				.append_string (config_param)
				.append_terminator ();
			var apple_strv_offset = apple_strv_builder.append_placeholder ();

			var api_offset = args_builder.offset;
			args_builder
				.append_pointer (symbols.socket)
				.append_pointer (symbols.setsockopt)
				.append_pointer (symbols.bind)
				.append_pointer (symbols.listen)
				.append_pointer (symbols.getsockname)
				.append_pointer (symbols.accept)
				.append_pointer (symbols.read)
				.append_pointer (symbols.write)
				.append_pointer (symbols.sys_icache_invalidate)
				.append_pointer (symbols.sys_dcache_flush)
				.append_pointer (symbols._mach_task_self)
				.append_pointer (symbols.mach_vm_allocate)
				.append_pointer (symbols.mach_vm_deallocate)
				.append_pointer (symbols.dlopen)
				.append_pointer (symbols.dlsym)
				.append_pointer (symbols.mprotect)
				.append_pointer (symbols.close)
				.append_pointer (symbols.get_errno_storage);

			apple_strv_builder.build (args);

			yield lldb.write_byte_array (args, args_builder.build (), cancellable);

			uint64 apple_strv = args + apple_strv_offset;
			uint64 upload_api = args + api_offset;

			uint64 listen_result = yield invoke_remote_function (code, {
					rx_buffer_size,
					upload_api
				}, null, cancellable);

			uint8  error_code    =  (uint8) ((listen_result >> 56) & 0xff);
			uint32 listener_fd   = (uint32) ((listen_result >> 16) & 0xffffffffU);
			uint16 listener_port = (uint16)  (listen_result        & 0xffff);

			if (error_code != 0)
				throw new Error.UNSUPPORTED ("Unable to listen on TCP (error_code=%u)", error_code);

			yield lldb.write_byte_array (code, new Bytes.static (UPLOAD_RECEIVER_CODE), cancellable);

			// The generated session ID only acts as a sanitycheck for now
			var rand = new Rand.with_seed ((uint32) dyld_base);
			uint64 session_id_top    = ((uint64) rand.next_int () << 32) | ((uint64) rand.next_int ());
			uint64 session_id_bottom = ((uint64) rand.next_int () << 32) | ((uint64) rand.next_int ());

			perform_upload.begin (buffer, threaded_items, chained_fixups, listener_port, session_id_top, session_id_bottom,
				symbols, cancellable);

			int64 receive_result = (int64) yield invoke_remote_function (code, {
					listener_fd,
					session_id_top,
					session_id_bottom,
					apple_strv,
					upload_api
				}, null, cancellable);
			if (receive_result <= 0)
				throw new Error.UNSUPPORTED ("Unable to start gadget: %" + int64.FORMAT_MODIFIER + "d", receive_result);

			return (uint16) receive_result;
		}

		private async void perform_upload (Buffer buffer, ThreadedItems threaded_items, ChainedFixups chained_fixups,
				uint16 listener_port, uint64 session_id_top, uint64 session_id_bottom, UploadSymbols symbols,
				Cancellable? cancellable) {
			try {
				var stream = yield channel_provider.open_channel (
					("tcp:%" + uint16.FORMAT_MODIFIER + "u").printf (listener_port),
					cancellable);
				var output = stream.output_stream;
				var input = stream.input_stream;
				var io_priority = Priority.DEFAULT;

				var hello = lldb.make_buffer_builder ()
					.append_uint64 (session_id_top)
					.append_uint64 (session_id_bottom)
					.build ();
				size_t bytes_written;
				size_t bytes_read;
				var check_buf = new uint8[4];

				yield output.write_all_async (hello.get_data (), io_priority, cancellable, out bytes_written);
				yield input.read_all_async (check_buf, io_priority, cancellable, out bytes_read);
				if (bytes_read != 4) {
					yield stream.close_async (io_priority, cancellable);
					return;
				}

				uint64 slide = module.slide;

				foreach (unowned Gum.DarwinSegment segment in module.segments.data) {
					uint64 address = segment.vm_address + slide;

					Bytes bytes = new Bytes.from_bytes (buffer.bytes, (size_t) segment.file_offset,
						(size_t) segment.file_size);

					var write_command_header = lldb.make_buffer_builder ()
						.append_uint8 (UploadCommandType.WRITE)
						.append_uint64 (address)
						.append_uint32 ((uint32) bytes.get_size ())
						.build ();
					yield output.write_all_async (write_command_header.get_data (), io_priority, cancellable,
						out bytes_written);
					yield output.write_all_async (bytes.get_data (), io_priority, cancellable, out bytes_written);
				}

				if (!threaded_items.is_empty) {
					var command = lldb.make_buffer_builder ()
						.append_uint8 (UploadCommandType.APPLY_THREADED)
						.append_uint64 (module.preferred_address)
						.append_uint64 (slide);

					var symbol_addrs = threaded_items.symbol_addrs;
					command.append_uint16 ((uint16) symbol_addrs.size);
					foreach (var symbol in symbol_addrs)
						command.append_uint64 (symbol);

					var region_bases = threaded_items.region_bases;
					command.append_uint16 ((uint16) region_bases.size);
					foreach (var region in region_bases)
						command.append_uint64 (region);

					yield output.write_all_async (command.build ().get_data (), io_priority, cancellable,
						out bytes_written);
				}

				foreach (uint64 fixups_header_address in chained_fixups.locations) {
					var fixup_command = lldb.make_buffer_builder ()
						.append_uint8 (UploadCommandType.PROCESS_FIXUPS)
						.append_uint64 (fixups_header_address)
						.append_uint64 (module.base_address)
						.append_uint64 (module.preferred_address)
						.build ();
					yield output.write_all_async (fixup_command.get_data (), io_priority, cancellable,
						out bytes_written);
				}

				foreach (unowned Gum.DarwinSegment segment in module.segments.data) {
					uint64 address = segment.vm_address + slide;

					var protect_command = lldb.make_buffer_builder ()
						.append_uint8 (UploadCommandType.PROTECT)
						.append_uint64 (address)
						.append_uint32 ((uint32) segment.vm_size)
						.append_uint32 ((uint32) segment.protection)
						.build ();
					yield output.write_all_async (protect_command.get_data (), io_priority, cancellable,
						out bytes_written);
				}

				var construct_commands = lldb.make_buffer_builder ();
				module.enumerate_init_pointers (ptrs => {
					construct_commands
						.append_uint8 (UploadCommandType.CONSTRUCT_FROM_POINTERS)
						.append_uint64 (ptrs.address)
						.append_uint32 ((uint32) ptrs.count);
					return true;
				});
				module.enumerate_init_offsets (offsets => {
					construct_commands
						.append_uint8 (UploadCommandType.CONSTRUCT_FROM_OFFSETS)
						.append_uint64 (offsets.address)
						.append_uint32 ((uint32) offsets.count)
						.append_uint64 (module.base_address);
					return true;
				});
				yield output.write_all_async (construct_commands.build ().get_data (), io_priority, cancellable,
					out bytes_written);

				var check_command = lldb.make_buffer_builder ()
					.append_uint8 (UploadCommandType.CHECK);
				yield output.write_all_async (check_command.build ().get_data (), io_priority, cancellable,
					out bytes_written);
				yield input.read_all_async (check_buf, io_priority, cancellable, out bytes_read);

				yield stream.close_async (io_priority, cancellable);
			} catch (GLib.Error e) {
			}
		}

		private enum UploadCommandType {
			WRITE = 1,
			APPLY_THREADED,
			PROCESS_FIXUPS,
			PROTECT,
			CONSTRUCT_FROM_POINTERS,
			CONSTRUCT_FROM_OFFSETS,
			CHECK,
		}

		private class UploadSymbols {
			public uint64 socket;
			public uint64 setsockopt;
			public uint64 bind;
			public uint64 listen;
			public uint64 getsockname;
			public uint64 accept;
			public uint64 read;
			public uint64 write;
			public uint64 sys_icache_invalidate;
			public uint64 sys_dcache_flush;
			public uint64 _mach_task_self;
			public uint64 mach_vm_allocate;
			public uint64 mach_vm_deallocate;
			public uint64 dlopen;
			public uint64 dlsym;
			public uint64 mprotect;
			public uint64 close;
			public uint64 get_errno_storage;

			private const string LIBSYSTEM = "/usr/lib/libSystem.B.dylib";

			public static void extend_query (SymbolQueryBuilder builder) {
				builder
					.add (LIBSYSTEM, "_socket")
					.add (LIBSYSTEM, "_setsockopt")
					.add (LIBSYSTEM, "_bind")
					.add (LIBSYSTEM, "_listen")
					.add (LIBSYSTEM, "_getsockname")
					.add (LIBSYSTEM, "_accept")
					.add (LIBSYSTEM, "_read")
					.add (LIBSYSTEM, "_write")
					.add (LIBSYSTEM, "_sys_icache_invalidate")
					.add (LIBSYSTEM, "_sys_dcache_flush")
					.add (LIBSYSTEM, "_mach_task_self")
					.add (LIBSYSTEM, "_mach_vm_allocate")
					.add (LIBSYSTEM, "_mach_vm_deallocate")
					.add (LIBSYSTEM, "_dlopen")
					.add (LIBSYSTEM, "_dlsym")
					.add (LIBSYSTEM, "_mprotect")
					.add (LIBSYSTEM, "_close")
					.add (LIBSYSTEM, "___error")
					;
			}

			public UploadSymbols.from_set (SymbolSet symbols) throws Error {
				socket                = symbols.get (LIBSYSTEM, "_socket");
				setsockopt            = symbols.get (LIBSYSTEM, "_setsockopt");
				bind                  = symbols.get (LIBSYSTEM, "_bind");
				listen                = symbols.get (LIBSYSTEM, "_listen");
				getsockname           = symbols.get (LIBSYSTEM, "_getsockname");
				accept                = symbols.get (LIBSYSTEM, "_accept");
				read                  = symbols.get (LIBSYSTEM, "_read");
				write                 = symbols.get (LIBSYSTEM, "_write");
				sys_icache_invalidate = symbols.get (LIBSYSTEM, "_sys_icache_invalidate");
				sys_dcache_flush      = symbols.get (LIBSYSTEM, "_sys_dcache_flush");
				_mach_task_self       = symbols.get (LIBSYSTEM, "_mach_task_self");
				mach_vm_allocate      = symbols.get (LIBSYSTEM, "_mach_vm_allocate");
				mach_vm_deallocate    = symbols.get (LIBSYSTEM, "_mach_vm_deallocate");
				dlopen                = symbols.get (LIBSYSTEM, "_dlopen");
				dlsym                 = symbols.get (LIBSYSTEM, "_dlsym");
				mprotect              = symbols.get (LIBSYSTEM, "_mprotect");
				close                 = symbols.get (LIBSYSTEM, "_close");
				get_errno_storage     = symbols.get (LIBSYSTEM, "___error");
			}
		}

		/* Compiled from helpers/upload-listener.c */
		private const uint8[] UPLOAD_LISTENER_CODE = {
			0xff, 0x83, 0x01, 0xd1, 0xf6, 0x57, 0x03, 0xa9, 0xf4, 0x4f, 0x04, 0xa9, 0xfd, 0x7b, 0x05, 0xa9, 0xfd, 0x43, 0x01,
			0x91, 0xf3, 0x03, 0x01, 0xaa, 0x08, 0x00, 0x00, 0x90, 0x08, 0xb1, 0x04, 0x91, 0xa0, 0xc3, 0x1d, 0xb8, 0x00, 0x01,
			0xc0, 0x3d, 0xe0, 0x07, 0x80, 0x3d, 0x00, 0xc1, 0xc0, 0x3c, 0xe0, 0xc3, 0x81, 0x3c, 0x28, 0x00, 0x40, 0xf9, 0xc0,
			0x03, 0x80, 0x52, 0x21, 0x00, 0x80, 0x52, 0x02, 0x00, 0x80, 0x52, 0x00, 0x01, 0x3f, 0xd6, 0x1f, 0x04, 0x00, 0x31,
			0xc0, 0x04, 0x00, 0x54, 0xf4, 0x03, 0x00, 0xaa, 0x68, 0x06, 0x40, 0xf9, 0xa3, 0x93, 0x00, 0xd1, 0xe1, 0xff, 0x9f,
			0x52, 0x42, 0x00, 0x82, 0x52, 0x84, 0x00, 0x80, 0x52, 0x00, 0x01, 0x3f, 0xd6, 0x1f, 0x04, 0x00, 0x31, 0xe0, 0x03,
			0x00, 0x54, 0x88, 0x03, 0x80, 0x52, 0xe8, 0x0f, 0x00, 0xb9, 0x68, 0x0a, 0x40, 0xf9, 0xe1, 0x43, 0x00, 0x91, 0xe0,
			0x03, 0x14, 0xaa, 0x82, 0x03, 0x80, 0x52, 0x00, 0x01, 0x3f, 0xd6, 0x1f, 0x04, 0x00, 0x31, 0x00, 0x03, 0x00, 0x54,
			0x68, 0x12, 0x40, 0xf9, 0xe1, 0x43, 0x00, 0x91, 0xe2, 0x33, 0x00, 0x91, 0xe0, 0x03, 0x14, 0xaa, 0x00, 0x01, 0x3f,
			0xd6, 0x1f, 0x04, 0x00, 0x31, 0x60, 0x02, 0x00, 0x54, 0x68, 0x0e, 0x40, 0xf9, 0xe0, 0x03, 0x14, 0xaa, 0x21, 0x00,
			0x80, 0x52, 0x00, 0x01, 0x3f, 0xd6, 0x1f, 0x04, 0x00, 0x31, 0xe0, 0x01, 0x00, 0x54, 0x88, 0x7e, 0x40, 0x93, 0xe9,
			0x27, 0x40, 0x79, 0x29, 0x09, 0xc0, 0x5a, 0x35, 0x7d, 0x10, 0x53, 0x15, 0xbd, 0x70, 0xb3, 0x0d, 0x00, 0x00, 0x14,
			0x15, 0x20, 0xe0, 0xd2, 0x0b, 0x00, 0x00, 0x14, 0x15, 0x40, 0xe0, 0xd2, 0x06, 0x00, 0x00, 0x14, 0x15, 0x60, 0xe0,
			0xd2, 0x04, 0x00, 0x00, 0x14, 0x15, 0x80, 0xe0, 0xd2, 0x02, 0x00, 0x00, 0x14, 0x15, 0xa0, 0xe0, 0xd2, 0x68, 0x42,
			0x40, 0xf9, 0xe0, 0x03, 0x14, 0xaa, 0x00, 0x01, 0x3f, 0xd6, 0xe0, 0x03, 0x15, 0xaa, 0xfd, 0x7b, 0x45, 0xa9, 0xf4,
			0x4f, 0x44, 0xa9, 0xf6, 0x57, 0x43, 0xa9, 0xff, 0x83, 0x01, 0x91, 0xc0, 0x03, 0x5f, 0xd6, 0x00, 0x1e, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00
		};

		/* Compiled from helpers/upload-receiver.c */
		private const uint8[] UPLOAD_RECEIVER_CODE = {
			0xfc, 0x6f, 0xba, 0xa9, 0xfa, 0x67, 0x01, 0xa9, 0xf8, 0x5f, 0x02, 0xa9, 0xf6, 0x57, 0x03, 0xa9, 0xf4, 0x4f, 0x04,
			0xa9, 0xfd, 0x7b, 0x05, 0xa9, 0xfd, 0x43, 0x01, 0x91, 0xff, 0x03, 0x03, 0xd1, 0xfa, 0x03, 0x04, 0xaa, 0xfb, 0x03,
			0x03, 0xaa, 0xf7, 0x03, 0x02, 0xaa, 0xf8, 0x03, 0x01, 0xaa, 0xf9, 0x03, 0x00, 0xaa, 0xbf, 0xc3, 0x19, 0xb8, 0x88,
			0x95, 0x98, 0x52, 0x48, 0x89, 0xb5, 0x72, 0xa8, 0x03, 0x18, 0xb8, 0x13, 0x02, 0x80, 0x52, 0xb3, 0x43, 0x18, 0xb8,
			0x48, 0x17, 0x40, 0xf9, 0xa1, 0xe3, 0x01, 0xd1, 0xa2, 0xf3, 0x01, 0xd1, 0xe0, 0x03, 0x19, 0xaa, 0x00, 0x01, 0x3f,
			0xd6, 0x1f, 0x04, 0x00, 0x31, 0xe1, 0x00, 0x00, 0x54, 0x48, 0x47, 0x40, 0xf9, 0x00, 0x01, 0x3f, 0xd6, 0x08, 0x00,
			0x40, 0xb9, 0x1f, 0x11, 0x00, 0x71, 0xa0, 0xfe, 0xff, 0x54, 0xd7, 0x01, 0x00, 0x14, 0xf6, 0x03, 0x00, 0xaa, 0xa1,
			0x43, 0x02, 0xd1, 0x02, 0x02, 0x80, 0x52, 0x53, 0x02, 0x00, 0x94, 0xa8, 0x27, 0x77, 0xa9, 0x1f, 0x00, 0x00, 0x71,
			0x00, 0x11, 0x58, 0xfa, 0x20, 0x01, 0x57, 0xfa, 0x60, 0x00, 0x00, 0x54, 0x65, 0x02, 0x00, 0x94, 0xe8, 0xff, 0xff,
			0x17, 0x58, 0x02, 0x00, 0x94, 0x20, 0x39, 0x00, 0x34, 0xa8, 0x23, 0x00, 0xd1, 0x1a, 0x01, 0x10, 0xf8, 0xa8, 0x33,
			0x00, 0xd1, 0x19, 0x01, 0x10, 0xb8, 0xbb, 0x83, 0x11, 0xf8, 0xa1, 0x47, 0x02, 0xd1, 0xe0, 0x03, 0x16, 0xaa, 0x22,
			0x00, 0x80, 0x52, 0x41, 0x02, 0x00, 0x94, 0xe0, 0x37, 0x00, 0x34, 0xa8, 0xf3, 0x56, 0x38, 0x10, 0x05, 0x00, 0x51,
			0x1f, 0x1a, 0x00, 0x71, 0x68, 0x37, 0x00, 0x54, 0x1f, 0x1a, 0x00, 0xf1, 0x10, 0x92, 0x9f, 0x9a, 0xb1, 0x38, 0x00,
			0x10, 0x1f, 0x20, 0x03, 0xd5, 0x30, 0x7a, 0xb0, 0xb8, 0x11, 0x00, 0x00, 0x10, 0x30, 0x02, 0x10, 0x8b, 0x00, 0x02,
			0x1f, 0xd6, 0xa1, 0x83, 0x01, 0xd1, 0xe0, 0x03, 0x16, 0xaa, 0x02, 0x01, 0x80, 0x52, 0x30, 0x02, 0x00, 0x94, 0xc0,
			0x35, 0x00, 0x34, 0xa1, 0xa3, 0x02, 0xd1, 0xe0, 0x03, 0x16, 0xaa, 0x82, 0x00, 0x80, 0x52, 0x2b, 0x02, 0x00, 0x94,
			0x20, 0x35, 0x00, 0x36, 0xa1, 0x03, 0x5a, 0xf8, 0xa2, 0x83, 0x55, 0xb8, 0xa3, 0x83, 0x02, 0xd1, 0xe0, 0x03, 0x16,
			0xaa, 0xe4, 0x03, 0x1a, 0xaa, 0xbb, 0x01, 0x00, 0x94, 0xf7, 0x03, 0x00, 0xaa, 0x48, 0x23, 0x40, 0xf9, 0x36, 0x02,
			0x00, 0x94, 0x48, 0x27, 0x40, 0xf9, 0x34, 0x02, 0x00, 0x94, 0x57, 0xfb, 0x07, 0x37, 0x9c, 0x01, 0x00, 0x14, 0xa1,
			0x83, 0x01, 0xd1, 0xe0, 0x03, 0x16, 0xaa, 0x02, 0x01, 0x80, 0x52, 0x19, 0x02, 0x00, 0x94, 0xe0, 0x32, 0x00, 0x34,
			0xa1, 0x83, 0x02, 0xd1, 0xe0, 0x03, 0x16, 0xaa, 0x02, 0x01, 0x80, 0x52, 0x14, 0x02, 0x00, 0x94, 0x40, 0x32, 0x00,
			0x34, 0xa1, 0xa3, 0x02, 0xd1, 0xe0, 0x03, 0x16, 0xaa, 0x42, 0x00, 0x80, 0x52, 0x0f, 0x02, 0x00, 0x94, 0xa0, 0x31,
			0x00, 0x34, 0xf5, 0x03, 0x00, 0x91, 0xa8, 0x83, 0x55, 0x78, 0x08, 0x71, 0x1d, 0x53, 0x08, 0x3d, 0x00, 0x11, 0x08,
			0x3d, 0x7c, 0x92, 0xe9, 0x03, 0x00, 0x91, 0x37, 0x01, 0x08, 0xcb, 0xff, 0x02, 0x00, 0x91, 0xa8, 0x83, 0x55, 0x78,
			0x02, 0xf1, 0x7d, 0xd3, 0xe0, 0x03, 0x16, 0xaa, 0xe1, 0x03, 0x17, 0xaa, 0x01, 0x02, 0x00, 0x94, 0xc0, 0x2f, 0x00,
			0x34, 0xa1, 0xc3, 0x02, 0xd1, 0xe0, 0x03, 0x16, 0xaa, 0x42, 0x00, 0x80, 0x52, 0xfc, 0x01, 0x00, 0x94, 0x20, 0x2f,
			0x00, 0x34, 0xa8, 0x03, 0x55, 0x78, 0x09, 0x71, 0x1d, 0x53, 0x29, 0x3d, 0x00, 0x11, 0x29, 0x3d, 0x7c, 0x92, 0xea,
			0x03, 0x00, 0x91, 0x58, 0x01, 0x09, 0xcb, 0x1f, 0x03, 0x00, 0x91, 0x02, 0xf1, 0x7d, 0xd3, 0xe0, 0x03, 0x16, 0xaa,
			0xe1, 0x03, 0x18, 0xaa, 0xf0, 0x01, 0x00, 0x94, 0xa0, 0x2d, 0x00, 0x34, 0x14, 0x00, 0x80, 0xd2, 0xba, 0x03, 0x5a,
			0xf8, 0xbb, 0x03, 0x56, 0xf8, 0xbc, 0x03, 0x55, 0x78, 0x9f, 0x02, 0x1c, 0xeb, 0x40, 0x27, 0x00, 0x54, 0x19, 0x7b,
			0x74, 0xf8, 0x33, 0x03, 0x40, 0xf9, 0xf3, 0x01, 0xf0, 0xb7, 0x68, 0xfe, 0x6b, 0xd3, 0x69, 0xaa, 0x40, 0x92, 0x6a,
			0xaa, 0x6a, 0x93, 0x4a, 0x31, 0x55, 0x92, 0x09, 0x1d, 0x48, 0xb3, 0x28, 0x01, 0x0a, 0xaa, 0x69, 0x7e, 0x40, 0x92,
			0x7f, 0x02, 0x41, 0xf2, 0xea, 0x03, 0x9a, 0x9a, 0x08, 0x01, 0x89, 0x9a, 0x49, 0x01, 0x1b, 0x8b, 0x20, 0x01, 0x08,
			0x8b, 0x53, 0x01, 0xf8, 0xb6, 0x04, 0x00, 0x00, 0x14, 0x68, 0x3e, 0x40, 0x92, 0xe0, 0x7a, 0x68, 0xf8, 0xd3, 0x00,
			0xf8, 0xb6, 0x61, 0xca, 0x71, 0xd3, 0x63, 0xc2, 0x70, 0xd3, 0x62, 0xbe, 0x60, 0xd3, 0xe4, 0x03, 0x19, 0xaa, 0xb6,
			0x01, 0x00, 0x94, 0x68, 0xf6, 0x73, 0xd3, 0x20, 0x03, 0x00, 0xf9, 0x39, 0x4f, 0x28, 0x8b, 0xa8, 0xfc, 0xff, 0x35,
			0x94, 0x06, 0x00, 0x91, 0xe0, 0xff, 0xff, 0x17, 0xa1, 0x83, 0x02, 0xd1, 0xe0, 0x03, 0x16, 0xaa, 0x02, 0x01, 0x80,
			0x52, 0xc6, 0x01, 0x00, 0x94, 0x80, 0x28, 0x00, 0x34, 0xa1, 0xa3, 0x02, 0xd1, 0xe0, 0x03, 0x16, 0xaa, 0x02, 0x01,
			0x80, 0x52, 0xc1, 0x01, 0x00, 0x94, 0xe0, 0x27, 0x00, 0x34, 0xa1, 0xc3, 0x02, 0xd1, 0xe0, 0x03, 0x16, 0xaa, 0x02,
			0x01, 0x80, 0x52, 0xbc, 0x01, 0x00, 0x94, 0x40, 0x27, 0x00, 0x34, 0xb9, 0xf3, 0x75, 0xa9, 0xa8, 0x03, 0x55, 0xf8,
			0xa8, 0x83, 0x10, 0xf8, 0x48, 0x2b, 0x40, 0xf9, 0x00, 0x01, 0x3f, 0xd6, 0xbf, 0x03, 0x1a, 0xf8, 0x48, 0x2f, 0x40,
			0xf9, 0xa1, 0x83, 0x01, 0xd1, 0xa9, 0x43, 0x00, 0xd1, 0x20, 0x01, 0x10, 0xb8, 0x22, 0x00, 0xa0, 0x52, 0x23, 0x00,
			0x80, 0x52, 0x00, 0x01, 0x3f, 0xd6, 0x14, 0x00, 0x80, 0x52, 0x13, 0x00, 0x80, 0xd2, 0xb8, 0x03, 0x5a, 0xf8, 0x35,
			0x83, 0x00, 0x91, 0x37, 0x00, 0x80, 0x52, 0x28, 0x13, 0x40, 0xb9, 0x9f, 0x02, 0x08, 0x6b, 0x60, 0x0c, 0x00, 0x54,
			0xa8, 0x02, 0x40, 0xb9, 0x09, 0xfd, 0x9f, 0x52, 0xe9, 0xff, 0xaf, 0x72, 0x09, 0x01, 0x09, 0x0b, 0x3f, 0x2d, 0x00,
			0x71, 0xe9, 0x22, 0xc9, 0x1a, 0x2a, 0x10, 0x81, 0x52, 0x29, 0x01, 0x0a, 0x0a, 0x24, 0x99, 0x40, 0x7a, 0x04, 0x09,
			0x4c, 0x7a, 0x01, 0x01, 0x00, 0x54, 0xa8, 0x0a, 0x40, 0xb9, 0xa0, 0x02, 0x08, 0x8b, 0x48, 0x37, 0x40, 0xf9, 0x21,
			0x01, 0x80, 0x52, 0x00, 0x01, 0x3f, 0xd6, 0x00, 0x7b, 0x33, 0xf8, 0x73, 0x06, 0x00, 0x91, 0xa8, 0x06, 0x40, 0xb9,
			0xb5, 0x02, 0x08, 0x8b, 0x94, 0x06, 0x00, 0x11, 0xe8, 0xff, 0xff, 0x17, 0xa1, 0x83, 0x01, 0xd1, 0xe0, 0x03, 0x16,
			0xaa, 0x02, 0x01, 0x80, 0x52, 0x8c, 0x01, 0x00, 0x94, 0x40, 0x21, 0x00, 0x34, 0xa1, 0x83, 0x02, 0xd1, 0xe0, 0x03,
			0x16, 0xaa, 0x82, 0x00, 0x80, 0x52, 0x87, 0x01, 0x00, 0x94, 0xa0, 0x20, 0x00, 0x34, 0xa1, 0xa3, 0x02, 0xd1, 0xe0,
			0x03, 0x16, 0xaa, 0x82, 0x00, 0x80, 0x52, 0x82, 0x01, 0x00, 0x94, 0x00, 0x20, 0x00, 0x36, 0x48, 0x3f, 0x40, 0xf9,
			0xa0, 0x03, 0x5a, 0xf8, 0xa1, 0x03, 0x56, 0xb8, 0xa2, 0x83, 0x55, 0xb8, 0x00, 0x01, 0x3f, 0xd6, 0xe0, 0xe6, 0xff,
			0x34, 0xf9, 0x00, 0x00, 0x14, 0xa1, 0x83, 0x01, 0xd1, 0xe0, 0x03, 0x16, 0xaa, 0x02, 0x01, 0x80, 0x52, 0x76, 0x01,
			0x00, 0x94, 0x80, 0x1e, 0x00, 0x34, 0xa1, 0xc3, 0x02, 0xd1, 0xe0, 0x03, 0x16, 0xaa, 0x82, 0x00, 0x80, 0x52, 0x71,
			0x01, 0x00, 0x94, 0xe0, 0x1d, 0x00, 0x34, 0x13, 0x00, 0x80, 0x52, 0xb4, 0x03, 0x5a, 0xf8, 0xa8, 0x03, 0x55, 0xb8,
			0x7f, 0x02, 0x08, 0x6b, 0xe0, 0xe4, 0xff, 0x54, 0xbf, 0xff, 0x35, 0xa9, 0x88, 0x5a, 0x73, 0xf8, 0xa1, 0x83, 0x02,
			0xd1, 0xa2, 0xa3, 0x02, 0xd1, 0x77, 0x01, 0x00, 0x94, 0x73, 0x06, 0x00, 0x11, 0xf7, 0xff, 0xff, 0x17, 0xa1, 0x83,
			0x01, 0xd1, 0xe0, 0x03, 0x16, 0xaa, 0x02, 0x01, 0x80, 0x52, 0x60, 0x01, 0x00, 0x94, 0xc0, 0x1b, 0x00, 0x34, 0xa1,
			0xd3, 0x02, 0xd1, 0xe0, 0x03, 0x16, 0xaa, 0x82, 0x00, 0x80, 0x52, 0x5b, 0x01, 0x00, 0x94, 0x20, 0x1b, 0x00, 0x34,
			0xa1, 0x83, 0x02, 0xd1, 0xe0, 0x03, 0x16, 0xaa, 0x02, 0x01, 0x80, 0x52, 0x56, 0x01, 0x00, 0x94, 0x80, 0x1a, 0x00,
			0x34, 0x13, 0x00, 0x80, 0x52, 0xb4, 0x03, 0x5a, 0xf8, 0xa8, 0xc3, 0x54, 0xb8, 0x7f, 0x02, 0x08, 0x6b, 0x80, 0xe1,
			0xff, 0x54, 0xbf, 0x7f, 0x35, 0xa9, 0xa8, 0x03, 0x56, 0xf8, 0x89, 0x5a, 0x73, 0xb8, 0x08, 0x01, 0x09, 0x8b, 0xa1,
			0xa3, 0x02, 0xd1, 0xa2, 0xc3, 0x02, 0xd1, 0x5a, 0x01, 0x00, 0x94, 0x73, 0x06, 0x00, 0x11, 0xf5, 0xff, 0xff, 0x17,
			0x53, 0x01, 0x00, 0x94, 0x20, 0xe0, 0x07, 0x37, 0xc3, 0x00, 0x00, 0x14, 0x1a, 0x0f, 0x13, 0x8b, 0x88, 0xdf, 0x41,
			0x29, 0x95, 0x03, 0x08, 0x8b, 0x88, 0x17, 0x40, 0xb9, 0x1f, 0x0d, 0x00, 0x71, 0xc0, 0x12, 0x00, 0x54, 0x1f, 0x09,
			0x00, 0x71, 0xe0, 0x14, 0x00, 0x54, 0x1f, 0x05, 0x00, 0x71, 0x21, 0x02, 0x00, 0x54, 0x88, 0x0b, 0x40, 0xb9, 0x93,
			0x03, 0x08, 0x8b, 0xf4, 0x03, 0x1a, 0xaa, 0xb7, 0x01, 0x00, 0xb4, 0x69, 0x02, 0x40, 0xb9, 0x28, 0x1d, 0x00, 0x72,
			0xa0, 0x00, 0x00, 0x54, 0xa9, 0x26, 0x49, 0x8b, 0x34, 0x01, 0x00, 0x94, 0xe0, 0x43, 0xc1, 0xda, 0x02, 0x00, 0x00,
			0x14, 0x00, 0x00, 0x80, 0xd2, 0x80, 0x86, 0x00, 0xf8, 0x73, 0x12, 0x00, 0x91, 0xf7, 0x06, 0x00, 0xd1, 0xb7, 0xfe,
			0xff, 0xb5, 0x09, 0x00, 0x80, 0xd2, 0x88, 0x07, 0x40, 0xb9, 0x88, 0x03, 0x08, 0x8b, 0xa8, 0x03, 0x10, 0xf8, 0x0a,
			0x45, 0x40, 0xb8, 0xaa, 0x03, 0x12, 0xf8, 0xa8, 0x03, 0x11, 0xf8, 0xa8, 0x03, 0x52, 0xf8, 0x3f, 0x01, 0x08, 0xeb,
			0xc0, 0x0c, 0x00, 0x54, 0xa9, 0x83, 0x12, 0xf8, 0xa8, 0x03, 0x51, 0xf8, 0x08, 0x79, 0x69, 0xb8, 0xc8, 0x0b, 0x00,
			0x34, 0x15, 0x00, 0x80, 0xd2, 0xa9, 0x03, 0x50, 0xf8, 0x3b, 0x01, 0x08, 0x8b, 0x68, 0x0f, 0x40, 0x79, 0x6a, 0x2b,
			0x40, 0x79, 0x69, 0x5b, 0x00, 0x91, 0xa9, 0xab, 0x33, 0xa9, 0x09, 0x79, 0x1d, 0x12, 0xa9, 0x43, 0x13, 0xb8, 0x1f,
			0x31, 0x00, 0x71, 0xe9, 0xff, 0x9f, 0x52, 0x0a, 0xe0, 0xbf, 0x12, 0x54, 0x01, 0x89, 0x9a, 0x1f, 0x05, 0x00, 0x71,
			0xaa, 0x83, 0x50, 0xf8, 0x49, 0x01, 0x9f, 0x9a, 0x3c, 0x03, 0x09, 0xcb, 0x1f, 0x19, 0x00, 0x71, 0xe8, 0x03, 0x8a,
			0x9a, 0x37, 0x03, 0x08, 0xcb, 0xa8, 0x03, 0x54, 0xf8, 0xbf, 0x02, 0x08, 0xeb, 0xe0, 0x08, 0x00, 0x54, 0xa8, 0x83,
			0x53, 0xf8, 0x08, 0x79, 0x75, 0x78, 0xe9, 0xff, 0x9f, 0x52, 0x1f, 0x01, 0x09, 0xeb, 0x00, 0x08, 0x00, 0x54, 0x69,
			0x07, 0x40, 0xf9, 0x29, 0x03, 0x09, 0x8b, 0x6a, 0x0b, 0x40, 0x79, 0xa9, 0x26, 0x0a, 0x9b, 0x38, 0x01, 0x08, 0x8b,
			0xa8, 0x43, 0x53, 0xb8, 0x1f, 0x09, 0x00, 0x71, 0x41, 0x02, 0x00, 0x54, 0x08, 0x03, 0x40, 0xf9, 0xe8, 0x00, 0xf8,
			0xb7, 0x09, 0xad, 0x6c, 0xd3, 0x29, 0x1d, 0x48, 0x92, 0x0a, 0x8d, 0x40, 0x92, 0xea, 0x02, 0x0a, 0x8b, 0x49, 0x01,
			0x09, 0x8b, 0x05, 0x00, 0x00, 0x14, 0x09, 0x5d, 0x40, 0x92, 0x49, 0x7b, 0x69, 0xf8, 0x0a, 0xfd, 0x58, 0xd3, 0x29,
			0x01, 0x2a, 0x8b, 0x09, 0x03, 0x00, 0xf9, 0x08, 0xf9, 0x73, 0xd3, 0x18, 0x0b, 0x08, 0x8b, 0x28, 0xfe, 0xff, 0xb5,
			0x27, 0x00, 0x00, 0x14, 0x13, 0x03, 0x40, 0xf9, 0x70, 0xfe, 0x7e, 0xd3, 0x62, 0xbe, 0x60, 0xd3, 0x63, 0xc2, 0x70,
			0xd3, 0
"""


```
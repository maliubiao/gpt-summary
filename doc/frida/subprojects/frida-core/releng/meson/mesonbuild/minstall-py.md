Response:
Let's break down the thought process for analyzing this Python script.

**1. Initial Understanding of the Context:**

The prompt clearly states this is a part of the `frida` dynamic instrumentation tool and the file path (`frida/subprojects/frida-core/releng/meson/mesonbuild/minstall.py`) strongly suggests it's related to the installation process managed by `meson`. This immediately tells us the core function is likely about copying files, creating directories, setting permissions, and handling various installation tasks.

**2. High-Level Skim and Keyword Spotting:**

A quick skim reveals important keywords and concepts:

* `install`:  This word appears frequently, confirming the core purpose.
* `copy`, `makedirs`, `symlink`, `remove`:  These are standard file system operations essential for installation.
* `permissions`, `chmod`, `chown`, `umask`: Indicate handling of file access rights.
* `destdir`: A common environment variable for staging installations.
* `strip`:  Indicates the possibility of removing debugging symbols from executables.
* `subprojects`, `tags`: Suggest features for selective installation.
* `dry_run`: A testing mode without actually making changes.
* `selinux`:  Points to handling of SELinux security contexts.
* `InstallData`:  Suggests a structured way of representing installation instructions.
* `target`, `headers`, `data`, `man`, `emptydir`, `symlinks`: These are typical categories of things to be installed.
* `run_exe`: Indicates execution of external scripts during installation.

**3. Categorizing Functionality (Mental Grouping):**

Based on the keywords, we can start grouping functionalities:

* **Core File Operations:** Copying, creating directories, deleting files, creating symlinks.
* **Permissions and Ownership:** Setting modes, ownership, handling umasks.
* **Installation Management:** Handling `destdir`, `dry_run`, skipping subprojects, filtering by tags.
* **Platform Specifics:** Handling Windows, macOS, AIX differences.
* **Script Execution:** Running custom installation scripts.
* **Error Handling and Logging:**  Printing messages, handling permissions errors.
* **Internal Data Structures:**  Working with `InstallData`.

**4. Deeper Dive into Specific Sections/Functions:**

Now, let's look at key parts more closely:

* **Argument Parsing (`add_arguments`)**:  Identify the command-line options available for controlling the installation process.
* **`Installer` Class**: This is the central class. Analyze its methods and their interactions.
* **`do_copyfile`, `do_symlink`, `do_copydir`**:  Understand how different types of files and directories are handled.
* **`install_targets`, `install_headers`, etc.**: See how the different categories of installables are processed.
* **`run_install_script`**:  Note how external scripts are invoked and the environment variables provided.
* **Platform-Specific Checks (`is_windows`, `is_osx`, `is_aix`)**: Recognize the conditional logic for different operating systems.

**5. Connecting to Reverse Engineering:**

With an understanding of the installation process, we can make connections to reverse engineering:

* **Target Installation**:  The script installs executables and libraries, which are the primary targets of reverse engineering.
* **Debugging Symbols (`strip`)**:  The ability to remove debugging symbols directly impacts the reverse engineering process. Without symbols, analysis becomes more difficult.
* **File Locations**: The installation process determines where the target binaries are placed, which is crucial for finding them during reverse engineering.
* **Custom Install Scripts**:  These scripts could potentially modify binaries or perform other actions that a reverse engineer might need to be aware of.

**6. Thinking about Binary/Kernel/Framework Aspects:**

* **Binary Installation**:  The core function is installing binary files (executables, libraries).
* **Permissions**: Setting permissions is a fundamental OS-level concept. Executable bits are directly related to the ability to run programs.
* **Shared Libraries**: The handling of shared libraries and their potential versioning (as seen in the AIX section) touches on OS linking mechanisms.
* **SELinux**: This is a Linux security feature directly operating at the kernel level.

**7. Logical Inference and Examples:**

Consider how different options would affect the output:

* **`--dry-run`**: No actual file changes, just logging.
* **`--only-changed`**:  Files are only overwritten if the source is newer.
* **`--strip`**:  Executables have debugging symbols removed.
* **Skipping subprojects/tags**: Certain components won't be installed.

Think of common errors:

* **Permissions errors**: Trying to install to a protected directory without sufficient rights.
* **File not found**:  Trying to install a target that wasn't built.
* **Conflicting files**: Trying to install something where a file or directory of the same name already exists.

**8. Tracing User Actions:**

Consider the typical workflow:

1. **Configuration**:  `meson setup` creates the build directory and configures the installation paths.
2. **Building**: `meson compile` builds the software.
3. **Installation**: `meson install` executes this script to copy files to their destination.

**9. Structuring the Answer:**

Finally, organize the findings into clear categories like:

* Core Functionality
* Relationship to Reverse Engineering
* Binary/Kernel/Framework Relevance
* Logical Inference (with examples)
* Common User Errors
* Debugging Clues (how users reach this code)
* Summary of Functionality (the final request)

This systematic approach, combining skimming, keyword spotting, categorization, deeper analysis, connecting to the target domain (reverse engineering), and considering practical scenarios, allows for a comprehensive understanding of the script's purpose and functionality.
Let's break down the functionality of the `minstall.py` script, which is part of the Meson build system used by the Frida project.

**Core Functionality of `minstall.py`:**

This script is responsible for the **installation phase** of the build process. It takes the artifacts produced by the compilation stage and copies them to their designated installation locations on the system. Think of it as the "put the finished product where it belongs" step.

Here's a breakdown of its key functions:

1. **Handles Command-Line Arguments:** It parses arguments like `--destdir`, `--dry-run`, `--strip`, `--only-changed`, `--skip-subprojects`, and `--tags` to control the installation process.

2. **Loads Installation Instructions:** It reads a pickled file (likely `install.dat`) containing instructions on what to install, where to install it, and with what permissions. This data is represented by the `InstallData` class.

3. **Manages Destination Directory (`DESTDIR`):** It supports the `DESTDIR` environment variable, allowing users to stage the installation in a temporary directory before moving it to the final location.

4. **Creates Directories:** It ensures that the necessary directories exist at the installation destination before copying files.

5. **Copies Files:** It copies various types of files, including executables, libraries, data files, and man pages, to their target locations.

6. **Handles Symbolic Links:** It creates symbolic links according to the instructions.

7. **Sets Permissions and Ownership:** It sets the correct file permissions (read, write, execute) and ownership (user, group) for the installed files.

8. **Strips Binaries (Optional):** It can remove debugging symbols from executables and libraries using the `strip` utility, if configured or explicitly requested.

9. **Runs Custom Install Scripts:** It executes any custom scripts defined in the build system for post-installation tasks.

10. **Handles Subprojects and Tags:** It allows for selectively installing components from specific subprojects or targets with certain tags.

11. **Dry Run Mode:** It supports a `--dry-run` mode to simulate the installation process without actually making any changes to the file system.

12. **Handles SELinux Contexts:**  It attempts to restore SELinux security contexts for installed files on Linux systems.

13. **Logging:** It logs the files being installed (unless the `--quiet` option is used).

**Relationship to Reverse Engineering (with Examples):**

This script has a direct relationship with reverse engineering because it's responsible for placing the **target binaries** that are the subject of reverse engineering efforts onto the system.

* **Example 1: Locating Target Binaries:** A reverse engineer needs to find the executable or library they want to analyze. This script dictates *where* those files are installed (e.g., `/usr/bin`, `/usr/lib`). Knowing how the installation paths are configured in the Meson build system and how `minstall.py` handles them is crucial for locating the target.

* **Example 2: Stripped Binaries:** The `--strip` option directly impacts reverse engineering. If a binary is stripped during installation, the debugging symbols are removed, making static analysis more challenging. A reverse engineer might need to obtain an unstripped version or employ more advanced techniques.

* **Example 3: Understanding Dependencies:**  While this script primarily copies files, the broader installation process reveals the dependencies between different components. A reverse engineer needs to understand which libraries a particular executable relies on. The installation locations of these libraries, managed by this script, provide clues about the system's linking behavior.

**Involvement of Binary Bottom, Linux, Android Kernel & Framework Knowledge (with Examples):**

* **Binary Bottom:**
    * **Executable Bits:** Setting file permissions, particularly the executable bit, is a low-level operation essential for running binaries. This script directly manipulates these bits using `os.chmod`.
    * **Stripping:** The `strip` operation modifies the binary file format by removing sections like `.debug_info`. Understanding binary file formats (like ELF on Linux) is essential to comprehend the impact of stripping.

* **Linux:**
    * **File System Hierarchy:** The script uses standard Linux file system paths (e.g., `/usr/bin`, `/usr/lib`, `/usr/share`) for installation. Knowledge of this hierarchy is necessary to understand where software components are typically placed.
    * **Symbolic Links:** The creation of symbolic links is a fundamental Linux feature. Understanding how they work (pointing to another file or directory) is important for analyzing software installations.
    * **Permissions Model (chmod, chown, umask):** The script directly interacts with the Linux permissions model. Understanding how user and group permissions, as well as the umask, affect file access is crucial.
    * **SELinux:** The script's attempt to restore SELinux contexts demonstrates awareness of this Linux security subsystem, which controls access to system resources at a very low level.

* **Android Kernel & Framework (While not explicitly Android-focused in this code snippet, the concepts apply):**
    * **Similar File System Structure:** Android, being based on Linux, shares similar file system concepts, though the specific paths may differ (e.g., `/system/bin`, `/system/lib`).
    * **Permissions and Security:** Android also relies on a permissions model, although it's more complex with application-level permissions. The underlying file system permissions managed by a similar installation script are still fundamental.
    * **Installation Locations:** Understanding where different components (executables, libraries, APKs) are installed in the Android file system is critical for reverse engineering on that platform.

**Logical Inference (with Hypothetical Input and Output):**

**Hypothetical Input:**

* `install.dat`: Contains instructions to install an executable `myprogram` to `/usr/bin`, a library `mylib.so` to `/usr/lib`, and a configuration file `myconfig.conf` to `/etc/myprogram/`.
* User runs: `meson install`

**Logical Output (assuming no errors and `--quiet` not used):**

```
Installing myprogram to /usr/bin
Installing mylib.so to /usr/lib
Installing myconfig.conf to /etc/myprogram
```

**Filesystem Changes:**

* `/usr/bin/myprogram` would be created (or overwritten).
* `/usr/lib/mylib.so` would be created (or overwritten).
* The directory `/etc/myprogram/` would be created if it didn't exist.
* `/etc/myprogram/myconfig.conf` would be created (or overwritten).

**Hypothetical Input with `--destdir`:**

* Same `install.dat` as above.
* User runs: `meson install --destdir=/tmp/stage`

**Logical Output:**

```
Installing myprogram to /tmp/stage/usr/bin
Installing mylib.so to /tmp/stage/usr/lib
Installing myconfig.conf to /tmp/stage/etc/myprogram
```

**Filesystem Changes:**

* `/tmp/stage/usr/bin/myprogram` would be created (or overwritten).
* `/tmp/stage/usr/lib/mylib.so` would be created (or overwritten).
* `/tmp/stage/etc/myprogram/myconfig.conf` would be created (or overwritten).

**Common User or Programming Errors (with Examples):**

* **Permission Denied:** If the user running `meson install` doesn't have write access to the target directories (e.g., trying to install to `/usr/bin` without root privileges), the script will likely fail with a `PermissionError`.

* **File Already Exists and is Not a File/Directory:** If the installation process tries to create a directory but a file with the same name already exists, or vice-versa, the script will raise a `MesonException`.

* **Incorrectly Specified Installation Paths:** If the `install.dat` file contains incorrect or illogical installation paths, the script might try to write to unexpected locations, potentially causing errors or unintended consequences.

* **Missing Dependencies for Custom Install Scripts:** If a custom install script relies on external tools or libraries that are not present in the system's `PATH`, the script execution might fail.

* **Typos in Command-Line Arguments:**  Typing errors in options like `--destdir` or `--skip-subprojects` will either be ignored or cause the script to behave unexpectedly.

**How User Operations Reach This Code (Debugging Clues):**

1. **Configuration Phase:** The user runs `meson setup <source_dir> <build_dir>`. During this phase, Meson reads the `meson.build` files and generates the necessary build system files, including the `install.dat` file that `minstall.py` will later use.

2. **Build Phase:** The user runs `meson compile`. This compiles the source code and creates the build artifacts (executables, libraries, etc.).

3. **Installation Phase:** The user runs `meson install`. This command triggers the execution of `minstall.py`.

   * **Internally:** Meson will locate the `minstall.py` script within its project structure. It will then execute this script, passing relevant information like the build directory and any command-line arguments provided by the user.

   * **Command-Line Arguments:**  The user's command-line arguments to `meson install` are directly passed to `minstall.py` and parsed using `argparse`.

   * **Loading `install.dat`:** `minstall.py` starts by loading the `install.dat` file, which contains the detailed instructions generated during the configuration phase about what needs to be installed and where.

**Summary of Functionality (Part 1):**

In essence, `minstall.py` is the **installation manager** for Meson-based projects like Frida. It reads the installation plan, handles user configurations (like `DESTDIR`), and performs the necessary file system operations (copying, creating directories and symlinks, setting permissions) to place the built software components in their intended locations on the system. It also provides features for selectively installing components and stripping binaries.

Prompt: 
```
这是目录为frida/subprojects/frida-core/releng/meson/mesonbuild/minstall.py的fridaDynamic instrumentation tool的源代码文件， 请列举一下它的功能, 
如果它与逆向的方法有关系，请做出对应的举例说明，
如果涉及到二进制底层，linux, android内核及框架的知识，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索。
这是第1部分，共2部分，请归纳一下它的功能

"""
# SPDX-License-Identifier: Apache-2.0
# Copyright 2013-2014 The Meson development team

from __future__ import annotations

from glob import glob
import argparse
import errno
import os
import selectors
import shlex
import shutil
import subprocess
import sys
import typing as T
import re

from . import build, environment
from .backend.backends import InstallData
from .mesonlib import (MesonException, Popen_safe, RealPathAction, is_windows,
                       is_aix, setup_vsenv, pickle_load, is_osx, OptionKey)
from .scripts import depfixer, destdir_join
from .scripts.meson_exe import run_exe
try:
    from __main__ import __file__ as main_file
except ImportError:
    # Happens when running as meson.exe which is native Windows.
    # This is only used for pkexec which is not, so this is fine.
    main_file = None

if T.TYPE_CHECKING:
    from .backend.backends import (
            InstallDataBase, InstallEmptyDir,
            InstallSymlinkData, TargetInstallData
    )
    from .mesonlib import FileMode, EnvironOrDict, ExecutableSerialisation

    try:
        from typing import Protocol
    except AttributeError:
        from typing_extensions import Protocol  # type: ignore

    class ArgumentType(Protocol):
        """Typing information for the object returned by argparse."""
        no_rebuild: bool
        only_changed: bool
        profile: bool
        quiet: bool
        wd: str
        destdir: str
        dry_run: bool
        skip_subprojects: str
        tags: str
        strip: bool


symlink_warning = '''\
Warning: trying to copy a symlink that points to a file. This currently copies
the file by default, but will be changed in a future version of Meson to copy
the link instead.  Set follow_symlinks to true to preserve current behavior, or
false to copy the link.'''

selinux_updates: T.List[str] = []

# Note: when adding arguments, please also add them to the completion
# scripts in $MESONSRC/data/shell-completions/
def add_arguments(parser: argparse.ArgumentParser) -> None:
    parser.add_argument('-C', dest='wd', action=RealPathAction,
                        help='directory to cd into before running')
    parser.add_argument('--profile-self', action='store_true', dest='profile',
                        help=argparse.SUPPRESS)
    parser.add_argument('--no-rebuild', default=False, action='store_true',
                        help='Do not rebuild before installing.')
    parser.add_argument('--only-changed', default=False, action='store_true',
                        help='Only overwrite files that are older than the copied file.')
    parser.add_argument('--quiet', default=False, action='store_true',
                        help='Do not print every file that was installed.')
    parser.add_argument('--destdir', default=None,
                        help='Sets or overrides DESTDIR environment. (Since 0.57.0)')
    parser.add_argument('--dry-run', '-n', action='store_true',
                        help='Doesn\'t actually install, but print logs. (Since 0.57.0)')
    parser.add_argument('--skip-subprojects', nargs='?', const='*', default='',
                        help='Do not install files from given subprojects. (Since 0.58.0)')
    parser.add_argument('--tags', default=None,
                        help='Install only targets having one of the given tags. (Since 0.60.0)')
    parser.add_argument('--strip', action='store_true',
                        help='Strip targets even if strip option was not set during configure. (Since 0.62.0)')

class DirMaker:
    def __init__(self, lf: T.TextIO, makedirs: T.Callable[..., None]):
        self.lf = lf
        self.dirs: T.List[str] = []
        self.all_dirs: T.Set[str] = set()
        self.makedirs_impl = makedirs

    def makedirs(self, path: str, exist_ok: bool = False) -> None:
        dirname = os.path.normpath(path)
        self.all_dirs.add(dirname)
        dirs = []
        while dirname != os.path.dirname(dirname):
            if dirname in self.dirs:
                # In dry-run mode the directory does not exist but we would have
                # created it with all its parents otherwise.
                break
            if not os.path.exists(dirname):
                dirs.append(dirname)
            dirname = os.path.dirname(dirname)
        self.makedirs_impl(path, exist_ok=exist_ok)

        # store the directories in creation order, with the parent directory
        # before the child directories. Future calls of makedir() will not
        # create the parent directories, so the last element in the list is
        # the last one to be created. That is the first one to be removed on
        # __exit__
        dirs.reverse()
        self.dirs += dirs

    def __enter__(self) -> 'DirMaker':
        return self

    def __exit__(self, exception_type: T.Type[Exception], value: T.Any, traceback: T.Any) -> None:
        self.dirs.reverse()
        for d in self.dirs:
            append_to_log(self.lf, d)


def load_install_data(fname: str) -> InstallData:
    return pickle_load(fname, 'InstallData', InstallData)

def is_executable(path: str, follow_symlinks: bool = False) -> bool:
    '''Checks whether any of the "x" bits are set in the source file mode.'''
    return bool(os.stat(path, follow_symlinks=follow_symlinks).st_mode & 0o111)


def append_to_log(lf: T.TextIO, line: str) -> None:
    lf.write(line)
    if not line.endswith('\n'):
        lf.write('\n')
    lf.flush()


def set_chown(path: str, user: T.Union[str, int, None] = None,
              group: T.Union[str, int, None] = None,
              dir_fd: T.Optional[int] = None, follow_symlinks: bool = True) -> None:
    # shutil.chown will call os.chown without passing all the parameters
    # and particularly follow_symlinks, thus we replace it temporary
    # with a lambda with all the parameters so that follow_symlinks will
    # be actually passed properly.
    # Not nice, but better than actually rewriting shutil.chown until
    # this python bug is fixed: https://bugs.python.org/issue18108
    real_os_chown = os.chown

    def chown(path: T.Union[int, str, 'os.PathLike[str]', bytes, 'os.PathLike[bytes]'],
              uid: int, gid: int, *, dir_fd: T.Optional[int] = dir_fd,
              follow_symlinks: bool = follow_symlinks) -> None:
        """Override the default behavior of os.chown

        Use a real function rather than a lambda to help mypy out. Also real
        functions are faster.
        """
        real_os_chown(path, uid, gid, dir_fd=dir_fd, follow_symlinks=follow_symlinks)

    try:
        os.chown = chown
        shutil.chown(path, user, group)
    finally:
        os.chown = real_os_chown


def set_chmod(path: str, mode: int, dir_fd: T.Optional[int] = None,
              follow_symlinks: bool = True) -> None:
    try:
        os.chmod(path, mode, dir_fd=dir_fd, follow_symlinks=follow_symlinks)
    except (NotImplementedError, OSError, SystemError):
        if not os.path.islink(path):
            os.chmod(path, mode, dir_fd=dir_fd)


def sanitize_permissions(path: str, umask: T.Union[str, int]) -> None:
    # TODO: with python 3.8 or typing_extensions we could replace this with
    # `umask: T.Union[T.Literal['preserve'], int]`, which would be more correct
    if umask == 'preserve':
        return
    assert isinstance(umask, int), 'umask should only be "preserver" or an integer'
    new_perms = 0o777 if is_executable(path, follow_symlinks=False) else 0o666
    new_perms &= ~umask
    try:
        set_chmod(path, new_perms, follow_symlinks=False)
    except PermissionError as e:
        print(f'{path!r}: Unable to set permissions {new_perms!r}: {e.strerror}, ignoring...')


def set_mode(path: str, mode: T.Optional['FileMode'], default_umask: T.Union[str, int]) -> None:
    if mode is None or all(m is None for m in [mode.perms_s, mode.owner, mode.group]):
        # Just sanitize permissions with the default umask
        sanitize_permissions(path, default_umask)
        return
    # No chown() on Windows, and must set one of owner/group
    if not is_windows() and (mode.owner is not None or mode.group is not None):
        try:
            set_chown(path, mode.owner, mode.group, follow_symlinks=False)
        except PermissionError as e:
            print(f'{path!r}: Unable to set owner {mode.owner!r} and group {mode.group!r}: {e.strerror}, ignoring...')
        except LookupError:
            print(f'{path!r}: Nonexistent owner {mode.owner!r} or group {mode.group!r}: ignoring...')
        except OSError as e:
            if e.errno == errno.EINVAL:
                print(f'{path!r}: Nonexistent numeric owner {mode.owner!r} or group {mode.group!r}: ignoring...')
            else:
                raise
    # Must set permissions *after* setting owner/group otherwise the
    # setuid/setgid bits will get wiped by chmod
    # NOTE: On Windows you can set read/write perms; the rest are ignored
    if mode.perms_s is not None:
        try:
            set_chmod(path, mode.perms, follow_symlinks=False)
        except PermissionError as e:
            print(f'{path!r}: Unable to set permissions {mode.perms_s!r}: {e.strerror}, ignoring...')
    else:
        sanitize_permissions(path, default_umask)


def restore_selinux_contexts() -> None:
    '''
    Restores the SELinux context for files in @selinux_updates

    If $DESTDIR is set, do not warn if the call fails.
    '''
    try:
        subprocess.check_call(['selinuxenabled'])
    except (FileNotFoundError, NotADirectoryError, OSError, PermissionError, subprocess.CalledProcessError):
        # If we don't have selinux or selinuxenabled returned 1, failure
        # is ignored quietly.
        return

    if not shutil.which('restorecon'):
        # If we don't have restorecon, failure is ignored quietly.
        return

    if not selinux_updates:
        # If the list of files is empty, do not try to call restorecon.
        return

    proc, out, err = Popen_safe(['restorecon', '-F', '-f-', '-0'], ('\0'.join(f for f in selinux_updates) + '\0'))
    if proc.returncode != 0:
        print('Failed to restore SELinux context of installed files...',
              'Standard output:', out,
              'Standard error:', err, sep='\n')

def get_destdir_path(destdir: str, fullprefix: str, path: str) -> str:
    if os.path.isabs(path):
        output = destdir_join(destdir, path)
    else:
        output = os.path.join(fullprefix, path)
    return output


def check_for_stampfile(fname: str) -> str:
    '''Some languages e.g. Rust have output files
    whose names are not known at configure time.
    Check if this is the case and return the real
    file instead.'''
    if fname.endswith('.so') or fname.endswith('.dll'):
        if os.stat(fname).st_size == 0:
            (base, suffix) = os.path.splitext(fname)
            files = glob(base + '-*' + suffix)
            if len(files) > 1:
                print("Stale dynamic library files in build dir. Can't install.")
                sys.exit(1)
            if len(files) == 1:
                return files[0]
    elif fname.endswith('.a') or fname.endswith('.lib'):
        if os.stat(fname).st_size == 0:
            (base, suffix) = os.path.splitext(fname)
            files = glob(base + '-*' + '.rlib')
            if len(files) > 1:
                print("Stale static library files in build dir. Can't install.")
                sys.exit(1)
            if len(files) == 1:
                return files[0]
    return fname


class Installer:

    def __init__(self, options: 'ArgumentType', lf: T.TextIO):
        self.did_install_something = False
        self.printed_symlink_error = False
        self.options = options
        self.lf = lf
        self.preserved_file_count = 0
        self.dry_run = options.dry_run
        # [''] means skip none,
        # ['*'] means skip all,
        # ['sub1', ...] means skip only those.
        self.skip_subprojects = [i.strip() for i in options.skip_subprojects.split(',')]
        self.tags = [i.strip() for i in options.tags.split(',')] if options.tags else None

    def remove(self, *args: T.Any, **kwargs: T.Any) -> None:
        if not self.dry_run:
            os.remove(*args, **kwargs)

    def symlink(self, *args: T.Any, **kwargs: T.Any) -> None:
        if not self.dry_run:
            os.symlink(*args, **kwargs)

    def makedirs(self, *args: T.Any, **kwargs: T.Any) -> None:
        if not self.dry_run:
            os.makedirs(*args, **kwargs)

    def copy(self, *args: T.Any, **kwargs: T.Any) -> None:
        if not self.dry_run:
            shutil.copy(*args, **kwargs)

    def copy2(self, *args: T.Any, **kwargs: T.Any) -> None:
        if not self.dry_run:
            shutil.copy2(*args, **kwargs)

    def copyfile(self, *args: T.Any, **kwargs: T.Any) -> None:
        if not self.dry_run:
            shutil.copyfile(*args, **kwargs)

    def copystat(self, *args: T.Any, **kwargs: T.Any) -> None:
        if not self.dry_run:
            shutil.copystat(*args, **kwargs)

    def fix_rpath(self, *args: T.Any, **kwargs: T.Any) -> None:
        if not self.dry_run:
            depfixer.fix_rpath(*args, **kwargs)

    def set_chown(self, *args: T.Any, **kwargs: T.Any) -> None:
        if not self.dry_run:
            set_chown(*args, **kwargs)

    def set_chmod(self, *args: T.Any, **kwargs: T.Any) -> None:
        if not self.dry_run:
            set_chmod(*args, **kwargs)

    def sanitize_permissions(self, *args: T.Any, **kwargs: T.Any) -> None:
        if not self.dry_run:
            sanitize_permissions(*args, **kwargs)

    def set_mode(self, *args: T.Any, **kwargs: T.Any) -> None:
        if not self.dry_run:
            set_mode(*args, **kwargs)

    def restore_selinux_contexts(self, destdir: str) -> None:
        if not self.dry_run and not destdir:
            restore_selinux_contexts()

    def Popen_safe(self, *args: T.Any, **kwargs: T.Any) -> T.Tuple[int, str, str]:
        if not self.dry_run:
            p, o, e = Popen_safe(*args, **kwargs)
            return p.returncode, o, e
        return 0, '', ''

    def run_exe(self, exe: ExecutableSerialisation, extra_env: T.Optional[T.Dict[str, str]] = None) -> int:
        if (not self.dry_run) or exe.dry_run:
            return run_exe(exe, extra_env)
        return 0

    def should_install(self, d: T.Union[TargetInstallData, InstallEmptyDir,
                                        InstallDataBase, InstallSymlinkData,
                                        ExecutableSerialisation]) -> bool:
        if d.subproject and (d.subproject in self.skip_subprojects or '*' in self.skip_subprojects):
            return False
        if self.tags and d.tag not in self.tags:
            return False
        return True

    def log(self, msg: str) -> None:
        if not self.options.quiet:
            print(msg)

    def should_preserve_existing_file(self, from_file: str, to_file: str) -> bool:
        if not self.options.only_changed:
            return False
        # Always replace danging symlinks
        if os.path.islink(from_file) and not os.path.isfile(from_file):
            return False
        from_time = os.stat(from_file).st_mtime
        to_time = os.stat(to_file).st_mtime
        return from_time <= to_time

    def do_copyfile(self, from_file: str, to_file: str,
                    makedirs: T.Optional[T.Tuple[T.Any, str]] = None,
                    follow_symlinks: T.Optional[bool] = None) -> bool:
        outdir = os.path.split(to_file)[0]
        if not os.path.isfile(from_file) and not os.path.islink(from_file):
            raise MesonException(f'Tried to install something that isn\'t a file: {from_file!r}')
        # copyfile fails if the target file already exists, so remove it to
        # allow overwriting a previous install. If the target is not a file, we
        # want to give a readable error.
        if os.path.exists(to_file):
            if not os.path.isfile(to_file):
                raise MesonException(f'Destination {to_file!r} already exists and is not a file')
            if self.should_preserve_existing_file(from_file, to_file):
                append_to_log(self.lf, f'# Preserving old file {to_file}\n')
                self.preserved_file_count += 1
                return False
            self.log(f'Installing {from_file} to {outdir}')
            self.remove(to_file)
        else:
            self.log(f'Installing {from_file} to {outdir}')
            if makedirs:
                # Unpack tuple
                dirmaker, outdir = makedirs
                # Create dirs if needed
                dirmaker.makedirs(outdir, exist_ok=True)
        if os.path.islink(from_file):
            if not os.path.exists(from_file):
                # Dangling symlink. Replicate as is.
                self.copy(from_file, outdir, follow_symlinks=False)
            else:
                if follow_symlinks is None:
                    follow_symlinks = True  # TODO: change to False when removing the warning
                    print(symlink_warning)
                self.copy2(from_file, to_file, follow_symlinks=follow_symlinks)
        else:
            self.copy2(from_file, to_file)
        selinux_updates.append(to_file)
        append_to_log(self.lf, to_file)
        return True

    def do_symlink(self, target: str, link: str, destdir: str, full_dst_dir: str, allow_missing: bool) -> bool:
        abs_target = target
        if not os.path.isabs(target):
            abs_target = os.path.join(full_dst_dir, target)
        elif not os.path.exists(abs_target) and not allow_missing:
            abs_target = destdir_join(destdir, abs_target)
        if not os.path.exists(abs_target) and not allow_missing:
            raise MesonException(f'Tried to install symlink to missing file {abs_target}')
        if os.path.exists(link):
            if not os.path.islink(link):
                raise MesonException(f'Destination {link!r} already exists and is not a symlink')
            self.remove(link)
        if not self.printed_symlink_error:
            self.log(f'Installing symlink pointing to {target} to {link}')
        try:
            self.symlink(target, link, target_is_directory=os.path.isdir(abs_target))
        except (NotImplementedError, OSError):
            if not self.printed_symlink_error:
                print("Symlink creation does not work on this platform. "
                      "Skipping all symlinking.")
                self.printed_symlink_error = True
            return False
        append_to_log(self.lf, link)
        return True

    def do_copydir(self, data: InstallData, src_dir: str, dst_dir: str,
                   exclude: T.Optional[T.Tuple[T.Set[str], T.Set[str]]],
                   install_mode: 'FileMode', dm: DirMaker, follow_symlinks: T.Optional[bool] = None) -> None:
        '''
        Copies the contents of directory @src_dir into @dst_dir.

        For directory
            /foo/
              bar/
                excluded
                foobar
              file
        do_copydir(..., '/foo', '/dst/dir', {'bar/excluded'}) creates
            /dst/
              dir/
                bar/
                  foobar
                file

        Args:
            src_dir: str, absolute path to the source directory
            dst_dir: str, absolute path to the destination directory
            exclude: (set(str), set(str)), tuple of (exclude_files, exclude_dirs),
                     each element of the set is a path relative to src_dir.
        '''
        if not os.path.isabs(src_dir):
            raise ValueError(f'src_dir must be absolute, got {src_dir}')
        if not os.path.isabs(dst_dir):
            raise ValueError(f'dst_dir must be absolute, got {dst_dir}')
        if exclude is not None:
            exclude_files, exclude_dirs = exclude
            exclude_files = {os.path.normpath(x) for x in exclude_files}
            exclude_dirs = {os.path.normpath(x) for x in exclude_dirs}
        else:
            exclude_files = exclude_dirs = set()
        for root, dirs, files in os.walk(src_dir):
            assert os.path.isabs(root)
            for d in dirs[:]:
                abs_src = os.path.join(root, d)
                filepart = os.path.relpath(abs_src, start=src_dir)
                abs_dst = os.path.join(dst_dir, filepart)
                # Remove these so they aren't visited by os.walk at all.
                if filepart in exclude_dirs:
                    dirs.remove(d)
                    continue
                if os.path.isdir(abs_dst):
                    continue
                if os.path.exists(abs_dst):
                    print(f'Tried to copy directory {abs_dst} but a file of that name already exists.')
                    sys.exit(1)
                dm.makedirs(abs_dst)
                self.copystat(abs_src, abs_dst)
                self.sanitize_permissions(abs_dst, data.install_umask)
            for f in files:
                abs_src = os.path.join(root, f)
                filepart = os.path.relpath(abs_src, start=src_dir)
                if filepart in exclude_files:
                    continue
                abs_dst = os.path.join(dst_dir, filepart)
                if os.path.isdir(abs_dst):
                    print(f'Tried to copy file {abs_dst} but a directory of that name already exists.')
                    sys.exit(1)
                parent_dir = os.path.dirname(abs_dst)
                if not os.path.isdir(parent_dir):
                    dm.makedirs(parent_dir)
                    self.copystat(os.path.dirname(abs_src), parent_dir)
                # FIXME: what about symlinks?
                self.do_copyfile(abs_src, abs_dst, follow_symlinks=follow_symlinks)
                self.set_mode(abs_dst, install_mode, data.install_umask)

    def do_install(self, datafilename: str) -> None:
        d = load_install_data(datafilename)

        destdir = self.options.destdir
        if destdir is None:
            destdir = os.environ.get('DESTDIR')
        if destdir and not os.path.isabs(destdir):
            destdir = os.path.join(d.build_dir, destdir)
        # Override in the env because some scripts could use it and require an
        # absolute path.
        if destdir is not None:
            os.environ['DESTDIR'] = destdir
        destdir = destdir or ''
        fullprefix = destdir_join(destdir, d.prefix)

        if d.install_umask != 'preserve':
            assert isinstance(d.install_umask, int)
            os.umask(d.install_umask)

        self.did_install_something = False
        try:
            with DirMaker(self.lf, self.makedirs) as dm:
                self.install_subdirs(d, dm, destdir, fullprefix) # Must be first, because it needs to delete the old subtree.
                self.install_targets(d, dm, destdir, fullprefix)
                self.install_headers(d, dm, destdir, fullprefix)
                self.install_man(d, dm, destdir, fullprefix)
                self.install_emptydir(d, dm, destdir, fullprefix)
                self.install_data(d, dm, destdir, fullprefix)
                self.install_symlinks(d, dm, destdir, fullprefix)
                self.restore_selinux_contexts(destdir)
                self.run_install_script(d, destdir, fullprefix)
                if not self.did_install_something:
                    self.log('Nothing to install.')
                if not self.options.quiet and self.preserved_file_count > 0:
                    self.log('Preserved {} unchanged files, see {} for the full list'
                             .format(self.preserved_file_count, os.path.normpath(self.lf.name)))
        except PermissionError:
            if is_windows() or destdir != '' or not os.isatty(sys.stdout.fileno()) or not os.isatty(sys.stderr.fileno()):
                # can't elevate to root except in an interactive unix environment *and* when not doing a destdir install
                raise
            rootcmd = os.environ.get('MESON_ROOT_CMD') or shutil.which('sudo') or shutil.which('doas')
            pkexec = shutil.which('pkexec')
            if rootcmd is None and pkexec is not None and 'PKEXEC_UID' not in os.environ:
                rootcmd = pkexec

            if rootcmd is not None:
                print('Installation failed due to insufficient permissions.')
                s = selectors.DefaultSelector()
                s.register(sys.stdin, selectors.EVENT_READ)
                ans = None
                for attempt in range(5):
                    print(f'Attempt to use {rootcmd} to gain elevated privileges? [y/n] ', end='', flush=True)
                    if s.select(30):
                        # we waited on sys.stdin *only*
                        ans = sys.stdin.readline().rstrip('\n')
                    else:
                        print()
                        break
                    if ans in {'y', 'n'}:
                        break
                else:
                    if ans is not None:
                        raise MesonException('Answer not one of [y/n]')
                if ans == 'y':
                    os.execlp(rootcmd, rootcmd, sys.executable, main_file, *sys.argv[1:],
                              '-C', os.getcwd(), '--no-rebuild')
            raise

    def do_strip(self, strip_bin: T.List[str], fname: str, outname: str) -> None:
        self.log(f'Stripping target {fname!r}.')
        if is_osx():
            # macOS expects dynamic objects to be stripped with -x maximum.
            # To also strip the debug info, -S must be added.
            # See: https://www.unix.com/man-page/osx/1/strip/
            returncode, stdo, stde = self.Popen_safe(strip_bin + ['-S', '-x', outname])
        else:
            returncode, stdo, stde = self.Popen_safe(strip_bin + [outname])
        if returncode != 0:
            print('Could not strip file.\n')
            print(f'Stdout:\n{stdo}\n')
            print(f'Stderr:\n{stde}\n')
            sys.exit(1)

    def install_subdirs(self, d: InstallData, dm: DirMaker, destdir: str, fullprefix: str) -> None:
        for i in d.install_subdirs:
            if not self.should_install(i):
                continue
            self.did_install_something = True
            full_dst_dir = get_destdir_path(destdir, fullprefix, i.install_path)
            self.log(f'Installing subdir {i.path} to {full_dst_dir}')
            dm.makedirs(full_dst_dir, exist_ok=True)
            self.do_copydir(d, i.path, full_dst_dir, i.exclude, i.install_mode, dm,
                            follow_symlinks=i.follow_symlinks)

    def install_data(self, d: InstallData, dm: DirMaker, destdir: str, fullprefix: str) -> None:
        for i in d.data:
            if not self.should_install(i):
                continue
            fullfilename = i.path
            outfilename = get_destdir_path(destdir, fullprefix, i.install_path)
            outdir = os.path.dirname(outfilename)
            if self.do_copyfile(fullfilename, outfilename, makedirs=(dm, outdir), follow_symlinks=i.follow_symlinks):
                self.did_install_something = True
            self.set_mode(outfilename, i.install_mode, d.install_umask)

    def install_symlinks(self, d: InstallData, dm: DirMaker, destdir: str, fullprefix: str) -> None:
        for s in d.symlinks:
            if not self.should_install(s):
                continue
            full_dst_dir = get_destdir_path(destdir, fullprefix, s.install_path)
            full_link_name = get_destdir_path(destdir, fullprefix, s.name)
            dm.makedirs(full_dst_dir, exist_ok=True)
            if self.do_symlink(s.target, full_link_name, destdir, full_dst_dir, s.allow_missing):
                self.did_install_something = True

    def install_man(self, d: InstallData, dm: DirMaker, destdir: str, fullprefix: str) -> None:
        for m in d.man:
            if not self.should_install(m):
                continue
            full_source_filename = m.path
            outfilename = get_destdir_path(destdir, fullprefix, m.install_path)
            outdir = os.path.dirname(outfilename)
            if self.do_copyfile(full_source_filename, outfilename, makedirs=(dm, outdir)):
                self.did_install_something = True
            self.set_mode(outfilename, m.install_mode, d.install_umask)

    def install_emptydir(self, d: InstallData, dm: DirMaker, destdir: str, fullprefix: str) -> None:
        for e in d.emptydir:
            if not self.should_install(e):
                continue
            self.did_install_something = True
            full_dst_dir = get_destdir_path(destdir, fullprefix, e.path)
            self.log(f'Installing new directory {full_dst_dir}')
            if os.path.isfile(full_dst_dir):
                print(f'Tried to create directory {full_dst_dir} but a file of that name already exists.')
                sys.exit(1)
            dm.makedirs(full_dst_dir, exist_ok=True)
            self.set_mode(full_dst_dir, e.install_mode, d.install_umask)

    def install_headers(self, d: InstallData, dm: DirMaker, destdir: str, fullprefix: str) -> None:
        for t in d.headers:
            if not self.should_install(t):
                continue
            fullfilename = t.path
            fname = os.path.basename(fullfilename)
            outdir = get_destdir_path(destdir, fullprefix, t.install_path)
            outfilename = os.path.join(outdir, fname)
            if self.do_copyfile(fullfilename, outfilename, makedirs=(dm, outdir),
                                follow_symlinks=t.follow_symlinks):
                self.did_install_something = True
            self.set_mode(outfilename, t.install_mode, d.install_umask)

    def run_install_script(self, d: InstallData, destdir: str, fullprefix: str) -> None:
        env = {'MESON_SOURCE_ROOT': d.source_dir,
               'MESON_BUILD_ROOT': d.build_dir,
               'MESONINTROSPECT': ' '.join([shlex.quote(x) for x in d.mesonintrospect]),
               }
        if self.options.quiet:
            env['MESON_INSTALL_QUIET'] = '1'
        if self.dry_run:
            env['MESON_INSTALL_DRY_RUN'] = '1'

        for i in d.install_scripts:
            if not self.should_install(i):
                continue

            if i.installdir_map is not None:
                mapp = i.installdir_map
            else:
                mapp = {'prefix': d.prefix}
            localenv = env.copy()
            localenv.update({'MESON_INSTALL_'+k.upper(): os.path.join(d.prefix, v) for k, v in mapp.items()})
            localenv.update({'MESON_INSTALL_DESTDIR_'+k.upper(): get_destdir_path(destdir, fullprefix, v) for k, v in mapp.items()})

            name = ' '.join(i.cmd_args)
            if i.skip_if_destdir and destdir:
                self.log(f'Skipping custom install script because DESTDIR is set {name!r}')
                continue
            self.did_install_something = True  # Custom script must report itself if it does nothing.
            self.log(f'Running custom install script {name!r}')
            try:
                rc = self.run_exe(i, localenv)
            except OSError:
                print(f'FAILED: install script \'{name}\' could not be run.')
                # POSIX shells return 127 when a command could not be found
                sys.exit(127)
            if rc != 0:
                print(f'FAILED: install script \'{name}\' failed with exit code {rc}.')
                sys.exit(rc)

    def install_targets(self, d: InstallData, dm: DirMaker, destdir: str, fullprefix: str) -> None:
        for t in d.targets:
            # In AIX, we archive our shared libraries.  When we install any package in AIX we need to
            # install the archive in which the shared library exists. The below code does the same.
            # We change the .so files having lt_version or so_version to archive file install.
            # If .so does not exist then it means it is in the archive. Otherwise it is a .so that exists.
            if is_aix():
                if not os.path.exists(t.fname) and '.so' in t.fname:
                    t.fname = re.sub('[.][a]([.]?([0-9]+))*([.]?([a-z]+))*', '.a', t.fname.replace('.so', '.a'))
            if not self.should_install(t):
                continue
            if not os.path.exists(t.fname):
                # For example, import libraries of shared modules are optional
                if t.optional:
                    self.log(f'File {t.fname!r} not found, skipping')
                    continue
                else:
                    raise MesonException(f'File {t.fname!r} could not be found')
            file_copied = False # not set when a directory is copied
            fname = check_for_stampfile(t.fname)
            outdir = get_destdir_path(destdir, fullprefix, t.outdir)
            ou
"""


```
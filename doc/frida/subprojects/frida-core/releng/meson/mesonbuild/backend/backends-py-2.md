Response:
The user wants a summary of the functionality of the Python code provided. I need to:
1. **Understand the purpose of the code:**  The code appears to be part of the build system for Frida, specifically dealing with how build artifacts are handled and installed.
2. **Identify key functions and their roles:** I will go through each method and describe its operation.
3. **Relate functionality to reverse engineering:**  Frida is a dynamic instrumentation tool, so aspects of this code likely touch on how Frida interacts with running processes, loads libraries, etc.
4. **Connect to low-level concepts:** Look for interactions with binaries, libraries, and operating system specifics (Linux, Android).
5. **Identify logic and infer inputs/outputs:** For functions with clear logic, I'll propose example inputs and their likely outputs.
6. **Point out potential user errors:**  Consider how incorrect usage of the build system or configuration might lead to issues related to this code.
7. **Trace user actions:** Think about the steps a user would take in the build process that would lead to this code being executed.
8. **Summarize the overall functionality.**

**Mental Sandbox:**

* **`get_all_dependencies`:**  This seems to be about identifying all the build targets a given target depends on. In reverse engineering, this could relate to understanding the dependency chain of libraries or executables being analyzed.
* **`get_custom_target_provided_by_generated_source` and `get_custom_target_provided_libraries`:** These are about figuring out which libraries are generated by custom build steps. This is relevant to understanding how Frida's components are built and linked.
* **`get_custom_target_sources`:**  This function retrieves the source files for a custom build target. In reverse engineering, this is less directly applicable to runtime analysis but important for building Frida itself.
* **`get_target_depend_files`:**  This retrieves files that a target depends on. This is crucial for the build system to know what needs to be rebuilt when files change.
* **`get_custom_target_output_dir` and `get_normpath_target`:** These deal with calculating and normalizing output paths, which is fundamental for any build system.
* **`get_custom_target_dirs` and `get_custom_target_dir_include_args`:** These are related to include directories for compilation, crucial for building software that relies on headers.
* **`eval_custom_target_command`:** This function constructs the actual command-line command to execute for a custom build target, including handling various placeholders and file paths. This is where the build logic is defined.
* **`get_introspect_command`:** Returns the command to introspect the build system's state. This is a developer-focused feature.
* **`get_run_target_env`:** Sets up the environment variables for running a specific build target. This is important for setting up the correct runtime environment, especially for tests.
* **`run_postconf_scripts`:** Executes scripts after the build configuration is done. These could perform tasks like generating configuration files.
* **`create_install_data` and related `generate_*_install` methods:** These are central to the installation process, defining where different types of files (binaries, libraries, headers, man pages, etc.) should be installed. This is crucial for deploying Frida.
* **`guess_install_tag`:** Tries to automatically categorize installed files (e.g., 'runtime', 'devel').
* **`get_introspection_data`:** Provides data about how targets are built, intended for tooling and introspection.
* **`get_devenv`:**  Sets up the development environment variables, which is useful for developers working on Frida itself.
* **`compiler_to_generator`:**  A helper function for generating lists of files.

**Key Takeaway:** The code primarily manages the build process, focusing on defining build steps for custom targets, managing dependencies, and orchestrating the installation of Frida's components. It interacts with low-level concepts through file paths, compiler commands, and library linking.
这是 Frida 动态 instrumentation 工具的构建系统中负责处理构建后端逻辑的一部分，主要关注于如何将构建目标（targets）转化为实际的构建操作和安装步骤。以下是该文件的功能归纳：

**核心功能：构建目标处理与安装数据生成**

这个文件的核心职责是解析 Meson 构建系统定义的各种构建目标（例如：可执行文件、库、自定义目标等），并将这些目标转化为后端构建系统（如 Ninja、Make 等）可以理解的指令，并生成用于安装的数据。

**具体功能细分：**

1. **依赖关系分析 (`get_all_dependencies`)：**
   - **功能：**  递归地查找并返回给定目标的所有依赖项（包括构建目标和自定义目标）。
   - **与逆向的关系：**  在逆向分析中，理解软件的依赖关系至关重要。这个功能在 Frida 的构建过程中帮助确保所有必要的组件都被正确构建和链接。例如，Frida Agent 可能依赖于特定的共享库。
   - **二进制底层、Linux/Android 内核及框架知识：**  理解库的链接方式、动态链接器的工作原理是理解依赖关系的基础。在 Android 上，可能涉及到对 ART 虚拟机或 Bionic libc 的依赖。
   - **逻辑推理（假设输入与输出）：**
     - **假设输入：** 一个表示 Frida Agent 构建目标的 `build.BuildTarget` 对象。
     - **输出：** 一个字典，键是依赖项的 ID，值是对应的 `build.BuildTarget` 或 `build.CustomTarget` 对象，包含了 Agent 依赖的所有库和自定义构建步骤。

2. **自定义目标提供的库 (`get_custom_target_provided_by_generated_source`, `get_custom_target_provided_libraries`)：**
   - **功能：**  识别由自定义构建目标生成的库文件。
   - **与逆向的关系：**  Frida 的某些组件可能通过自定义的构建步骤生成动态库。理解这些库是如何生成的有助于理解 Frida 的内部结构。
   - **二进制底层知识：** 涉及对库文件（如 `.so`、`.dll`）的识别。

3. **自定义目标的源文件 (`get_custom_target_sources`)：**
   - **功能：**  获取自定义构建目标的源文件列表，这些源文件可以是字符串路径、`File` 对象、甚至其他的构建目标或自定义目标。
   - **与逆向的关系：**  虽然不是直接的运行时逆向，但在理解 Frida 的构建过程和可能的代码生成逻辑时有用。
   - **逻辑推理（假设输入与输出）：**
     - **假设输入：** 一个表示自定义构建目标的 `build.CustomTarget` 对象，例如一个用于生成特定代码的脚本。
     - **输出：**  一个字符串列表，包含该自定义目标的源文件路径，可能是脚本文件、模板文件或其他生成代码所需的输入。

4. **目标的依赖文件 (`get_target_depend_files`)：**
   - **功能：**  获取构建目标依赖的非源文件列表（例如，配置文件、数据文件）。
   - **与逆向的关系：**  在逆向分析中，除了可执行代码，配置文件和数据文件也可能包含关键信息。
   - **用户或编程常见的使用错误：**  如果用户在 Meson 构建定义中错误地指定了依赖文件，可能会导致构建失败或运行时错误。例如，拼写错误的路径或不存在的文件。

5. **自定义目标的输出目录 (`get_custom_target_output_dir`)：**
   - **功能：**  获取自定义构建目标的输出目录路径。

6. **路径规范化 (`get_normpath_target`)：**
   - **功能：**  规范化文件路径。

7. **自定义目标的包含目录 (`get_custom_target_dirs`, `get_custom_target_dir_include_args`)：**
   - **功能：**  确定自定义目标生成的头文件所在的目录，并生成编译器所需的包含路径参数。
   - **与逆向的关系：**  在开发针对 Frida 的模块或扩展时，需要知道 Frida 提供的头文件在哪里。

8. **评估自定义目标的命令 (`eval_custom_target_command`)：**
   - **功能：**  构建和评估自定义构建目标的实际执行命令，包括替换占位符（如 `@SOURCE_ROOT@`, `@BUILD_ROOT@` 等）。
   - **与逆向的关系：**  理解自定义构建步骤的命令有助于理解 Frida 组件的生成过程。例如，某些组件可能需要通过特定的工具或脚本生成。
   - **逻辑推理（假设输入与输出）：**
     - **假设输入：** 一个 `build.CustomTarget` 对象，其命令定义为 `['python', 'myscript.py', '@SOURCE_ROOT@/input.txt', '@BUILD_ROOT@/output.bin']`。
     - **输出：**  一个元组，包含输入文件列表、输出文件列表以及最终的执行命令列表，例如 `(['/path/to/frida/subprojects/frida-core/releng/meson/input.txt'], ['/path/to/frida/build/output.bin'], ['python', 'myscript.py', '/path/to/frida/subprojects/frida-core/releng/meson/input.txt', '/path/to/frida/build/output.bin'])`。
   - **用户或编程常见的使用错误：**
     - 命令中使用了错误的占位符。
     - 自定义脚本或程序不存在或不可执行。
     - 依赖的文件路径不正确。
     - 缺少 `@DEPFILE@` 占位符，但定义了 `depfile`。

9. **获取内省命令 (`get_introspect_command`)：**
   - **功能：**  返回执行 Meson 内省功能的命令。

10. **获取运行目标的环境变量 (`get_run_target_env`)：**
    - **功能：**  为运行特定的构建目标（如测试）设置环境变量，例如设置 `MESON_SOURCE_ROOT` 和 `MESON_BUILD_ROOT`。
    - **与逆向的关系：**  运行测试是验证 Frida 功能的重要步骤。理解测试运行时的环境变量有助于调试测试失败或理解测试的运行环境。

11. **运行配置后脚本 (`run_postconf_scripts`)：**
    - **功能：**  执行在配置阶段之后运行的脚本，用于执行额外的配置任务。

12. **创建安装数据 (`create_install_data`) 及相关的 `generate_*_install` 方法：**
    - **功能：**  生成用于安装 Frida 组件的数据，包括目标文件、头文件、man 手册、数据文件、符号链接、自定义安装脚本和子目录。
    - **与逆向的关系：**  理解 Frida 的安装路径和文件组成是进行逆向分析的基础。例如，Frida 的核心库通常安装在特定的库目录下。
    - **二进制底层、Linux/Android 内核及框架知识：**  涉及到对不同类型的文件（可执行文件、共享库、静态库、头文件等）的处理和安装路径的规划，这与操作系统的文件系统结构和约定有关。在 Android 上，可能涉及到 APK 的打包和安装路径。
    - **用户操作是如何一步步的到达这里，作为调试线索：** 用户通常会执行 `meson install` 命令来触发安装过程。Meson 会读取 `meson.build` 文件中的安装指令，并调用 `create_install_data` 来生成安装所需的数据。如果安装过程中出现问题，例如文件没有被正确安装，可以检查 `install.dat` 文件（由 `create_install_data_files` 生成）来查看安装计划。
    - **用户或编程常见的使用错误：**
        - 在 `meson.build` 文件中错误地指定了安装路径。
        - 尝试安装未构建的目标。
        - 权限不足导致无法写入安装目录。
        - 安装路径冲突。

13. **猜测安装标签 (`guess_install_tag`)：**
    - **功能：**  根据文件路径猜测安装标签（如 'runtime', 'devel', 'i18n'）。

14. **生成目标内省数据 (`get_introspection_data`)：**
    - **功能：**  为特定的构建目标生成内省数据，包括使用的编译器、编译参数、源文件等。这主要用于开发工具和 IDE 集成。

15. **获取开发环境 (`get_devenv`)：**
    - **功能：**  设置开发环境所需的环境变量，例如将构建目录下的可执行文件和库添加到 `PATH` 和 `LD_LIBRARY_PATH`。
    - **与逆向的关系：**  在开发 Frida 的扩展或进行调试时，设置正确的开发环境非常重要。

16. **编译器到生成器转换 (`compiler_to_generator`)：**
    - **功能：**  对于不支持自定义编译器的后端，提供一种将编译器操作转换为生成器操作的便捷方法。

**作为调试线索，用户操作是如何一步步的到达这里：**

1. **配置构建系统：** 用户首先会运行 `meson setup <build_directory>` 来配置 Frida 的构建。Meson 会读取 `meson.build` 文件，解析构建目标和依赖关系。
2. **构建项目：**  用户执行 `meson compile -C <build_directory>` 或 `ninja -C <build_directory>` 来编译项目。在这个过程中，会调用此文件中的函数来确定如何构建每个目标。例如，`eval_custom_target_command` 会被调用来执行自定义构建步骤。
3. **安装项目：** 用户执行 `meson install -C <build_directory>` 或 `ninja -C <build_directory> install` 来安装 Frida。此时，`create_install_data` 会被调用来生成安装计划，而相关的 `generate_*_install` 方法会填充各种安装数据结构。

**第 3 部分功能归纳：**

这个文件的主要功能是 **定义和处理 Frida 构建过程中的各种构建目标，并生成用于安装的数据**。它负责理解 Meson 构建系统的描述，将其转化为具体的构建命令，并规划好最终的安装布局。这部分代码是 Frida 构建系统的核心组成部分，确保了 Frida 的各个组件能够被正确地构建和安装到目标系统上。它涉及到对各种文件类型、依赖关系、构建命令和安装路径的处理，是连接构建描述和实际构建/安装操作的关键桥梁。

Prompt: 
```
这是目录为frida/subprojects/frida-core/releng/meson/mesonbuild/backend/backends.py的fridaDynamic instrumentation tool的源代码文件， 请列举一下它的功能, 
如果它与逆向的方法有关系，请做出对应的举例说明，
如果涉及到二进制底层，linux, android内核及框架的知识，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索。
这是第3部分，共4部分，请归纳一下它的功能

"""
= arg
            for dep in t.depends:
                assert isinstance(dep, (build.CustomTarget, build.BuildTarget))
                result[dep.get_id()] = dep
        return result

    @lru_cache(maxsize=None)
    def get_custom_target_provided_by_generated_source(self, generated_source: build.CustomTarget) -> 'ImmutableListProtocol[str]':
        libs: T.List[str] = []
        for f in generated_source.get_outputs():
            if self.environment.is_library(f):
                libs.append(os.path.join(self.get_target_dir(generated_source), f))
        return libs

    @lru_cache(maxsize=None)
    def get_custom_target_provided_libraries(self, target: T.Union[build.BuildTarget, build.CustomTarget]) -> 'ImmutableListProtocol[str]':
        libs: T.List[str] = []
        for t in target.get_generated_sources():
            if not isinstance(t, build.CustomTarget):
                continue
            libs.extend(self.get_custom_target_provided_by_generated_source(t))
        return libs

    def get_custom_target_sources(self, target: build.CustomTarget) -> T.List[str]:
        '''
        Custom target sources can be of various object types; strings, File,
        BuildTarget, even other CustomTargets.
        Returns the path to them relative to the build root directory.
        '''
        srcs: T.List[str] = []
        for i in target.get_sources():
            if isinstance(i, str):
                fname = [os.path.join(self.build_to_src, target.get_source_subdir(), i)]
            elif isinstance(i, build.BuildTarget):
                fname = [self.get_target_filename(i)]
            elif isinstance(i, (build.CustomTarget, build.CustomTargetIndex)):
                fname = [os.path.join(self.get_custom_target_output_dir(i), p) for p in i.get_outputs()]
            elif isinstance(i, build.GeneratedList):
                fname = [os.path.join(self.get_target_private_dir(target), p) for p in i.get_outputs()]
            elif isinstance(i, build.ExtractedObjects):
                fname = self.determine_ext_objs(i)
            elif isinstance(i, programs.ExternalProgram):
                assert i.found(), "This shouldn't be possible"
                assert i.path is not None, 'for mypy'
                fname = [i.path]
            else:
                fname = [i.rel_to_builddir(self.build_to_src)]
            if target.absolute_paths:
                fname = [os.path.join(self.environment.get_build_dir(), f) for f in fname]
            srcs += fname
        return srcs

    def get_target_depend_files(self, target: T.Union[build.CustomTarget, build.BuildTarget], absolute_paths: bool = False) -> T.List[str]:
        deps: T.List[str] = []
        for i in target.depend_files:
            if isinstance(i, mesonlib.File):
                if absolute_paths:
                    deps.append(i.absolute_path(self.environment.get_source_dir(),
                                                self.environment.get_build_dir()))
                else:
                    deps.append(i.rel_to_builddir(self.build_to_src))
            else:
                if absolute_paths:
                    deps.append(os.path.join(self.environment.get_source_dir(), target.get_output_subdir(), i))
                else:
                    deps.append(os.path.join(self.build_to_src, target.get_output_subdir(), i))
        return deps

    def get_custom_target_output_dir(self, target: T.Union[build.Target, build.CustomTargetIndex]) -> str:
        # The XCode backend is special. A target foo/bar does
        # not go to ${BUILDDIR}/foo/bar but instead to
        # ${BUILDDIR}/${BUILDTYPE}/foo/bar.
        # Currently we set the include dir to be the former,
        # and not the latter. Thus we need this extra customisation
        # point. If in the future we make include dirs et al match
        # ${BUILDDIR}/${BUILDTYPE} instead, this becomes unnecessary.
        return self.get_target_dir(target)

    @lru_cache(maxsize=None)
    def get_normpath_target(self, source: str) -> str:
        return os.path.normpath(source)

    def get_custom_target_dirs(self, target: build.CustomTarget, compiler: 'Compiler', *,
                               absolute_path: bool = False) -> T.List[str]:
        custom_target_include_dirs: T.List[str] = []
        for i in target.get_generated_sources():
            # Generator output goes into the target private dir which is
            # already in the include paths list. Only custom targets have their
            # own target build dir.
            if not isinstance(i, (build.CustomTarget, build.CustomTargetIndex)):
                continue
            idir = self.get_normpath_target(self.get_custom_target_output_dir(i))
            if not idir:
                idir = '.'
            if absolute_path:
                idir = os.path.join(self.environment.get_build_dir(), idir)
            if idir not in custom_target_include_dirs:
                custom_target_include_dirs.append(idir)
        return custom_target_include_dirs

    def get_custom_target_dir_include_args(
            self, target: build.CustomTarget, compiler: 'Compiler', *,
            absolute_path: bool = False) -> T.List[str]:
        incs: T.List[str] = []
        for i in self.get_custom_target_dirs(target, compiler, absolute_path=absolute_path):
            incs += compiler.get_include_args(i, False)
        return incs

    def eval_custom_target_command(
            self, target: build.CustomTarget, absolute_outputs: bool = False) -> \
            T.Tuple[T.List[str], T.List[str], T.List[str]]:
        # We want the outputs to be absolute only when using the VS backend
        # XXX: Maybe allow the vs backend to use relative paths too?
        source_root = self.build_to_src
        build_root = '.'
        outdir = self.get_custom_target_output_dir(target)
        if absolute_outputs:
            source_root = self.environment.get_source_dir()
            build_root = self.environment.get_build_dir()
            outdir = os.path.join(self.environment.get_build_dir(), outdir)
        outputs = [os.path.join(outdir, i) for i in target.get_outputs()]
        inputs = self.get_custom_target_sources(target)
        # Evaluate the command list
        cmd: T.List[str] = []
        for i in target.command:
            if isinstance(i, build.BuildTarget):
                cmd += self.build_target_to_cmd_array(i)
                continue
            elif isinstance(i, build.CustomTarget):
                # GIR scanner will attempt to execute this binary but
                # it assumes that it is in path, so always give it a full path.
                tmp = i.get_outputs()[0]
                i = os.path.join(self.get_custom_target_output_dir(i), tmp)
            elif isinstance(i, mesonlib.File):
                i = i.rel_to_builddir(self.build_to_src)
                if target.absolute_paths or absolute_outputs:
                    i = os.path.join(self.environment.get_build_dir(), i)
            # FIXME: str types are blindly added ignoring 'target.absolute_paths'
            # because we can't know if they refer to a file or just a string
            elif isinstance(i, str):
                if '@SOURCE_ROOT@' in i:
                    i = i.replace('@SOURCE_ROOT@', source_root)
                if '@BUILD_ROOT@' in i:
                    i = i.replace('@BUILD_ROOT@', build_root)
                if '@CURRENT_SOURCE_DIR@' in i:
                    i = i.replace('@CURRENT_SOURCE_DIR@', os.path.join(source_root, target.get_source_subdir()))
                if '@DEPFILE@' in i:
                    if target.depfile is None:
                        msg = f'Custom target {target.name!r} has @DEPFILE@ but no depfile ' \
                              'keyword argument.'
                        raise MesonException(msg)
                    dfilename = os.path.join(outdir, target.depfile)
                    i = i.replace('@DEPFILE@', dfilename)
                if '@PRIVATE_DIR@' in i:
                    if target.absolute_paths:
                        pdir = self.get_target_private_dir_abs(target)
                    else:
                        pdir = self.get_target_private_dir(target)
                    i = i.replace('@PRIVATE_DIR@', pdir)
            else:
                raise RuntimeError(f'Argument {i} is of unknown type {type(i)}')
            cmd.append(i)
        # Substitute the rest of the template strings
        values = mesonlib.get_filenames_templates_dict(inputs, outputs)
        cmd = mesonlib.substitute_values(cmd, values)
        # This should not be necessary but removing it breaks
        # building GStreamer on Windows. The underlying issue
        # is problems with quoting backslashes on Windows
        # which is the seventh circle of hell. The downside is
        # that this breaks custom targets whose command lines
        # have backslashes. If you try to fix this be sure to
        # check that it does not break GST.
        #
        # The bug causes file paths such as c:\foo to get escaped
        # into c:\\foo.
        #
        # Unfortunately we have not been able to come up with an
        # isolated test case for this so unless you manage to come up
        # with one, the only way is to test the building with Gst's
        # setup. Note this in your MR or ping us and we will get it
        # fixed.
        #
        # https://github.com/mesonbuild/meson/pull/737
        cmd = [i.replace('\\', '/') for i in cmd]
        return inputs, outputs, cmd

    def get_introspect_command(self) -> str:
        return ' '.join(shlex.quote(x) for x in self.environment.get_build_command() + ['introspect'])

    def get_run_target_env(self, target: build.RunTarget) -> mesonlib.EnvironmentVariables:
        env = target.env if target.env else mesonlib.EnvironmentVariables()
        if target.default_env:
            env.set('MESON_SOURCE_ROOT', [self.environment.get_source_dir()])
            env.set('MESON_BUILD_ROOT', [self.environment.get_build_dir()])
            env.set('MESON_SUBDIR', [target.get_source_subdir()])
            env.set('MESONINTROSPECT', [self.get_introspect_command()])
        return env

    def run_postconf_scripts(self) -> None:
        from ..scripts.meson_exe import run_exe
        env = {'MESON_SOURCE_ROOT': self.environment.get_source_dir(),
               'MESON_BUILD_ROOT': self.environment.get_build_dir(),
               'MESONINTROSPECT': self.get_introspect_command(),
               }

        for s in self.build.postconf_scripts:
            name = ' '.join(s.cmd_args)
            mlog.log(f'Running postconf script {name!r}')
            rc = run_exe(s, env)
            if rc != 0:
                raise MesonException(f'Postconf script \'{name}\' failed with exit code {rc}.')

    def create_install_data(self) -> InstallData:
        strip_bin = self.environment.lookup_binary_entry(MachineChoice.HOST, 'strip')
        if strip_bin is None:
            if self.environment.is_cross_build():
                mlog.warning('Cross file does not specify strip binary, result will not be stripped.')
            else:
                # TODO go through all candidates, like others
                strip_bin = [detect.defaults['strip'][0]]

        umask = self.environment.coredata.get_option(OptionKey('install_umask'))
        assert isinstance(umask, (str, int)), 'for mypy'

        d = InstallData(self.environment.get_source_dir(),
                        self.environment.get_build_dir(),
                        self.environment.get_prefix(),
                        self.environment.get_libdir(),
                        strip_bin,
                        umask,
                        self.environment.get_build_command() + ['introspect'],
                        self.environment.coredata.version)
        self.generate_depmf_install(d)
        self.generate_target_install(d)
        self.generate_header_install(d)
        self.generate_man_install(d)
        self.generate_emptydir_install(d)
        self.generate_data_install(d)
        self.generate_symlink_install(d)
        self.generate_custom_install_script(d)
        self.generate_subdir_install(d)
        return d

    def create_install_data_files(self) -> None:
        install_data_file = os.path.join(self.environment.get_scratch_dir(), 'install.dat')
        with open(install_data_file, 'wb') as ofile:
            pickle.dump(self.create_install_data(), ofile)

    def guess_install_tag(self, fname: str, outdir: T.Optional[str] = None) -> T.Optional[str]:
        prefix = self.environment.get_prefix()
        bindir = Path(prefix, self.environment.get_bindir())
        libdir = Path(prefix, self.environment.get_libdir())
        incdir = Path(prefix, self.environment.get_includedir())
        _ldir = self.environment.coredata.get_option(mesonlib.OptionKey('localedir'))
        assert isinstance(_ldir, str), 'for mypy'
        localedir = Path(prefix, _ldir)
        dest_path = Path(prefix, outdir, Path(fname).name) if outdir else Path(prefix, fname)
        if bindir in dest_path.parents:
            return 'runtime'
        elif libdir in dest_path.parents:
            if dest_path.suffix in {'.a', '.pc'}:
                return 'devel'
            elif dest_path.suffix in {'.so', '.dll'}:
                return 'runtime'
        elif incdir in dest_path.parents:
            return 'devel'
        elif localedir in dest_path.parents:
            return 'i18n'
        elif 'installed-tests' in dest_path.parts:
            return 'tests'
        elif 'systemtap' in dest_path.parts:
            return 'systemtap'
        mlog.debug('Failed to guess install tag for', dest_path)
        return None

    def generate_target_install(self, d: InstallData) -> None:
        for t in self.build.get_targets().values():
            if not t.should_install():
                continue
            outdirs, install_dir_names, custom_install_dir = t.get_install_dir()
            # Sanity-check the outputs and install_dirs
            num_outdirs, num_out = len(outdirs), len(t.get_outputs())
            if num_outdirs not in {1, num_out}:
                m = 'Target {!r} has {} outputs: {!r}, but only {} "install_dir"s were found.\n' \
                    "Pass 'false' for outputs that should not be installed and 'true' for\n" \
                    'using the default installation directory for an output.'
                raise MesonException(m.format(t.name, num_out, t.get_outputs(), num_outdirs))
            assert len(t.install_tag) == num_out
            install_mode = t.get_custom_install_mode()
            # because mypy gets confused type narrowing in lists
            first_outdir = outdirs[0]
            first_outdir_name = install_dir_names[0]

            # Install the target output(s)
            if isinstance(t, build.BuildTarget):
                # In general, stripping static archives is tricky and full of pitfalls.
                # Wholesale stripping of static archives with a command such as
                #
                #   strip libfoo.a
                #
                # is broken, as GNU's strip will remove *every* symbol in a static
                # archive. One solution to this nonintuitive behaviour would be
                # to only strip local/debug symbols. Unfortunately, strip arguments
                # are not specified by POSIX and therefore not portable. GNU's `-g`
                # option (i.e. remove debug symbols) is equivalent to Apple's `-S`.
                #
                # TODO: Create GNUStrip/AppleStrip/etc. hierarchy for more
                #       fine-grained stripping of static archives.
                can_strip = not isinstance(t, build.StaticLibrary)
                should_strip = can_strip and t.get_option(OptionKey('strip'))
                assert isinstance(should_strip, bool), 'for mypy'
                # Install primary build output (library/executable/jar, etc)
                # Done separately because of strip/aliases/rpath
                if first_outdir is not False:
                    tag = t.install_tag[0] or ('devel' if isinstance(t, build.StaticLibrary) else 'runtime')
                    mappings = t.get_link_deps_mapping(d.prefix)
                    i = TargetInstallData(self.get_target_filename(t), first_outdir,
                                          first_outdir_name,
                                          should_strip, mappings, t.rpath_dirs_to_remove,
                                          t.install_rpath, install_mode, t.subproject,
                                          tag=tag, can_strip=can_strip)
                    d.targets.append(i)

                    for alias, to, tag in t.get_aliases():
                        alias = os.path.join(first_outdir, alias)
                        s = InstallSymlinkData(to, alias, first_outdir, t.subproject, tag, allow_missing=True)
                        d.symlinks.append(s)

                    if isinstance(t, (build.SharedLibrary, build.SharedModule, build.Executable)):
                        # On toolchains/platforms that use an import library for
                        # linking (separate from the shared library with all the
                        # code), we need to install that too (dll.a/.lib).
                        if t.get_import_filename():
                            if custom_install_dir:
                                # If the DLL is installed into a custom directory,
                                # install the import library into the same place so
                                # it doesn't go into a surprising place
                                implib_install_dir = first_outdir
                            else:
                                implib_install_dir = self.environment.get_import_lib_dir()
                            # Install the import library; may not exist for shared modules
                            i = TargetInstallData(self.get_target_filename_for_linking(t),
                                                  implib_install_dir, first_outdir_name,
                                                  False, {}, set(), '', install_mode,
                                                  t.subproject, optional=isinstance(t, build.SharedModule),
                                                  tag='devel')
                            d.targets.append(i)

                        if not should_strip and t.get_debug_filename():
                            debug_file = os.path.join(self.get_target_dir(t), t.get_debug_filename())
                            i = TargetInstallData(debug_file, first_outdir,
                                                  first_outdir_name,
                                                  False, {}, set(), '',
                                                  install_mode, t.subproject,
                                                  optional=True, tag='devel')
                            d.targets.append(i)
                # Install secondary outputs. Only used for Vala right now.
                if num_outdirs > 1:
                    for output, outdir, outdir_name, tag in zip(t.get_outputs()[1:], outdirs[1:], install_dir_names[1:], t.install_tag[1:]):
                        # User requested that we not install this output
                        if outdir is False:
                            continue
                        f = os.path.join(self.get_target_dir(t), output)
                        i = TargetInstallData(f, outdir, outdir_name, False, {}, set(), None,
                                              install_mode, t.subproject,
                                              tag=tag)
                        d.targets.append(i)
            elif isinstance(t, build.CustomTarget):
                # If only one install_dir is specified, assume that all
                # outputs will be installed into it. This is for
                # backwards-compatibility and because it makes sense to
                # avoid repetition since this is a common use-case.
                #
                # To selectively install only some outputs, pass `false` as
                # the install_dir for the corresponding output by index
                #
                # XXX: this wouldn't be needed if we just always matches outdirs
                # to the length of outputs…
                if num_outdirs == 1 and num_out > 1:
                    if first_outdir is not False:
                        for output, tag in zip(t.get_outputs(), t.install_tag):
                            tag = tag or self.guess_install_tag(output, first_outdir)
                            f = os.path.join(self.get_target_dir(t), output)
                            i = TargetInstallData(f, first_outdir, first_outdir_name,
                                                  False, {}, set(), None, install_mode,
                                                  t.subproject, optional=not t.build_by_default,
                                                  tag=tag)
                            d.targets.append(i)
                else:
                    for output, outdir, outdir_name, tag in zip(t.get_outputs(), outdirs, install_dir_names, t.install_tag):
                        # User requested that we not install this output
                        if outdir is False:
                            continue
                        tag = tag or self.guess_install_tag(output, outdir)
                        f = os.path.join(self.get_target_dir(t), output)
                        i = TargetInstallData(f, outdir, outdir_name,
                                              False, {}, set(), None, install_mode,
                                              t.subproject, optional=not t.build_by_default,
                                              tag=tag)
                        d.targets.append(i)

    def generate_custom_install_script(self, d: InstallData) -> None:
        d.install_scripts = self.build.install_scripts
        for i in d.install_scripts:
            if not i.tag:
                mlog.debug('Failed to guess install tag for install script:', ' '.join(i.cmd_args))

    def generate_header_install(self, d: InstallData) -> None:
        incroot = self.environment.get_includedir()
        headers = self.build.get_headers()

        srcdir = self.environment.get_source_dir()
        builddir = self.environment.get_build_dir()
        for h in headers:
            outdir = outdir_name = h.get_custom_install_dir()
            if outdir is None:
                subdir = h.get_install_subdir()
                if subdir is None:
                    outdir = incroot
                    outdir_name = '{includedir}'
                else:
                    outdir = os.path.join(incroot, subdir)
                    outdir_name = os.path.join('{includedir}', subdir)

            for f in h.get_sources():
                abspath = f.absolute_path(srcdir, builddir)
                i = InstallDataBase(abspath, outdir, outdir_name, h.get_custom_install_mode(), h.subproject, tag='devel', follow_symlinks=h.follow_symlinks)
                d.headers.append(i)

    def generate_man_install(self, d: InstallData) -> None:
        manroot = self.environment.get_mandir()
        man = self.build.get_man()
        for m in man:
            for f in m.get_sources():
                num = f.split('.')[-1]
                subdir = m.get_custom_install_dir()
                if subdir is None:
                    if m.locale:
                        subdir = os.path.join('{mandir}', m.locale, 'man' + num)
                    else:
                        subdir = os.path.join('{mandir}', 'man' + num)
                fname = f.fname
                if m.locale: # strip locale from file name
                    fname = fname.replace(f'.{m.locale}', '')
                srcabs = f.absolute_path(self.environment.get_source_dir(), self.environment.get_build_dir())
                dstname = os.path.join(subdir, os.path.basename(fname))
                dstabs = dstname.replace('{mandir}', manroot)
                i = InstallDataBase(srcabs, dstabs, dstname, m.get_custom_install_mode(), m.subproject, tag='man')
                d.man.append(i)

    def generate_emptydir_install(self, d: InstallData) -> None:
        emptydir: T.List[build.EmptyDir] = self.build.get_emptydir()
        for e in emptydir:
            tag = e.install_tag or self.guess_install_tag(e.path)
            i = InstallEmptyDir(e.path, e.install_mode, e.subproject, tag)
            d.emptydir.append(i)

    def generate_data_install(self, d: InstallData) -> None:
        data = self.build.get_data()
        srcdir = self.environment.get_source_dir()
        builddir = self.environment.get_build_dir()
        for de in data:
            assert isinstance(de, build.Data)
            subdir = de.install_dir
            subdir_name = de.install_dir_name
            for src_file, dst_name in zip(de.sources, de.rename):
                assert isinstance(src_file, mesonlib.File)
                dst_abs = os.path.join(subdir, dst_name)
                dstdir_name = os.path.join(subdir_name, dst_name)
                tag = de.install_tag or self.guess_install_tag(dst_abs)
                i = InstallDataBase(src_file.absolute_path(srcdir, builddir), dst_abs, dstdir_name,
                                    de.install_mode, de.subproject, tag=tag, data_type=de.data_type,
                                    follow_symlinks=de.follow_symlinks)
                d.data.append(i)

    def generate_symlink_install(self, d: InstallData) -> None:
        links: T.List[build.SymlinkData] = self.build.get_symlinks()
        for l in links:
            assert isinstance(l, build.SymlinkData)
            install_dir = l.install_dir
            name_abs = os.path.join(install_dir, l.name)
            tag = l.install_tag or self.guess_install_tag(name_abs)
            s = InstallSymlinkData(l.target, name_abs, install_dir, l.subproject, tag)
            d.symlinks.append(s)

    def generate_subdir_install(self, d: InstallData) -> None:
        for sd in self.build.get_install_subdirs():
            if sd.from_source_dir:
                from_dir = self.environment.get_source_dir()
            else:
                from_dir = self.environment.get_build_dir()
            src_dir = os.path.join(from_dir,
                                   sd.source_subdir,
                                   sd.installable_subdir).rstrip('/')
            dst_dir = os.path.join(self.environment.get_prefix(),
                                   sd.install_dir)
            dst_name = os.path.join('{prefix}', sd.install_dir)
            if sd.install_dir != sd.install_dir_name:
                dst_name = sd.install_dir_name
            if not sd.strip_directory:
                dst_dir = os.path.join(dst_dir, os.path.basename(src_dir))
                dst_name = os.path.join(dst_name, os.path.basename(src_dir))
            tag = sd.install_tag or self.guess_install_tag(os.path.join(sd.install_dir, 'dummy'))
            i = SubdirInstallData(src_dir, dst_dir, dst_name, sd.install_mode, sd.exclude, sd.subproject, tag,
                                  follow_symlinks=sd.follow_symlinks)
            d.install_subdirs.append(i)

    def get_introspection_data(self, target_id: str, target: build.Target) -> T.List['TargetIntrospectionData']:
        '''
        Returns a list of source dicts with the following format for a given target:
        [
            {
                "language": "<LANG>",
                "compiler": ["result", "of", "comp.get_exelist()"],
                "parameters": ["list", "of", "compiler", "parameters],
                "sources": ["list", "of", "all", "<LANG>", "source", "files"],
                "generated_sources": ["list", "of", "generated", "source", "files"]
            }
        ]

        This is a limited fallback / reference implementation. The backend should override this method.
        '''
        if isinstance(target, (build.CustomTarget, build.BuildTarget)):
            source_list_raw = target.sources
            source_list = []
            for j in source_list_raw:
                if isinstance(j, mesonlib.File):
                    source_list += [j.absolute_path(self.source_dir, self.build_dir)]
                elif isinstance(j, str):
                    source_list += [os.path.join(self.source_dir, j)]
                elif isinstance(j, (build.CustomTarget, build.BuildTarget)):
                    source_list += [os.path.join(self.build_dir, j.get_output_subdir(), o) for o in j.get_outputs()]
            source_list = [os.path.normpath(s) for s in source_list]

            compiler: T.List[str] = []
            if isinstance(target, build.CustomTarget):
                tmp_compiler = target.command
                for j in tmp_compiler:
                    if isinstance(j, mesonlib.File):
                        compiler += [j.absolute_path(self.source_dir, self.build_dir)]
                    elif isinstance(j, str):
                        compiler += [j]
                    elif isinstance(j, (build.BuildTarget, build.CustomTarget)):
                        compiler += j.get_outputs()
                    else:
                        raise RuntimeError(f'Type "{type(j).__name__}" is not supported in get_introspection_data. This is a bug')

            return [{
                'language': 'unknown',
                'compiler': compiler,
                'parameters': [],
                'sources': source_list,
                'generated_sources': []
            }]

        return []

    def get_devenv(self) -> mesonlib.EnvironmentVariables:
        env = mesonlib.EnvironmentVariables()
        extra_paths = set()
        library_paths = set()
        build_machine = self.environment.machines[MachineChoice.BUILD]
        host_machine = self.environment.machines[MachineChoice.HOST]
        need_wine = not build_machine.is_windows() and host_machine.is_windows()
        for t in self.build.get_targets().values():
            in_default_dir = t.should_install() and not t.get_install_dir()[2]
            if t.for_machine != MachineChoice.HOST or not in_default_dir:
                continue
            tdir = os.path.join(self.environment.get_build_dir(), self.get_target_dir(t))
            if isinstance(t, build.Executable):
                # Add binaries that are going to be installed in bindir into PATH
                # so they get used by default instead of searching on system when
                # in developer environment.
                extra_paths.add(tdir)
                if host_machine.is_windows() or host_machine.is_cygwin():
                    # On windows we cannot rely on rpath to run executables from build
                    # directory. We have to add in PATH the location of every DLL needed.
                    library_paths.update(self.determine_windows_extra_paths(t, []))
            elif isinstance(t, build.SharedLibrary):
                # Add libraries that are going to be installed in libdir into
                # LD_LIBRARY_PATH. This allows running system applications using
                # that library.
                library_paths.add(tdir)
        if need_wine:
            # Executable paths should be in both PATH and WINEPATH.
            # - Having them in PATH makes bash completion find it,
            #   and make running "foo.exe" find it when wine-binfmt is installed.
            # - Having them in WINEPATH makes "wine foo.exe" find it.
            library_paths.update(extra_paths)
        if library_paths:
            if need_wine:
                env.prepend('WINEPATH', list(library_paths), separator=';')
            elif host_machine.is_windows() or host_machine.is_cygwin():
                extra_paths.update(library_paths)
            elif host_machine.is_darwin():
                env.prepend('DYLD_LIBRARY_PATH', list(library_paths))
            else:
                env.prepend('LD_LIBRARY_PATH', list(library_paths))
        if extra_paths:
            env.prepend('PATH', list(extra_paths))
        return env

    def compiler_to_generator(self, target: build.BuildTarget,
                              compiler: 'Compiler',
                              sources: _ALL_SOURCES_TYPE,
                              output_templ: str,
                              depends: T.Optional[T.List[T.Union[build.BuildTarget, build.CustomTarget, build.CustomTargetIndex]]] = None,
                              ) -> build.GeneratedList:
        '''
        Some backends don't support custom compilers. This is a convenience
        method to conve
"""


```
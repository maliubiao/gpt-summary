Response:
Let's break down the thought process for analyzing this Python code and answering the user's request.

**1. Understanding the Core Request:**

The user wants to understand the functionality of the `taptests.py` file within the Frida project. They're specifically interested in:

* **General functionality:** What does this code do?
* **Relationship to reverse engineering:** How does it connect to the field of reverse engineering?
* **Relevance to low-level concepts:** Does it touch upon binary, Linux/Android kernels, or frameworks?
* **Logical reasoning:** Are there test cases with clear inputs and expected outputs?
* **Common user errors:** What mistakes could a user make that would lead to these tests being relevant?
* **Debugging context:** How does a user end up needing to look at this code during debugging?

**2. Initial Code Scan and Keyword Identification:**

The first step is to quickly scan the code for keywords and patterns that provide clues about its purpose. I notice:

* `unittest`:  This immediately tells me it's a unit testing file. The primary goal is to test some other code.
* `TAPParser`: This is the central class being tested. The name suggests it's parsing TAP (Test Anything Protocol) output.
* `assert_test`, `assert_plan`, `assert_version`, etc.: These are assertion methods, further confirming it's a testing framework.
* `TestResult`: This enum (likely defined elsewhere) indicates the outcome of a test (OK, FAIL, SKIP, etc.).
* `io.StringIO`: This is used for creating in-memory file-like objects, suggesting the tests are operating on strings representing TAP output.
* Example TAP strings:  Lines like `'ok'`, `'not ok 1 abc'`, `'1..4'`, etc., are clearly examples of TAP output being parsed.

**3. Inferring the High-Level Functionality:**

Based on the keywords and structure, I can conclude that `taptests.py` tests the `TAPParser` class. The `TAPParser`'s job is to read strings in the TAP format and interpret them, extracting information about test results, plans, versions, and potential errors.

**4. Connecting to Reverse Engineering (Frida Context):**

The prompt explicitly mentions Frida. Knowing that Frida is a dynamic instrumentation toolkit used for reverse engineering, I need to connect the dots. How does parsing TAP output relate to Frida?

* **Frida's Use Cases:** Frida is used for hooking into running processes, inspecting memory, modifying behavior, etc. These actions often involve running tests or scripts against the target application.
* **TAP as a Standard Reporting Format:**  It's common for testing frameworks to output results in a standardized format like TAP. This allows for easy integration with other tools and reporting systems.
* **Hypothesis:**  Frida likely uses TAP to report the results of tests or checks performed during its instrumentation process. When you write a Frida script that tests a certain condition in the target application, the results might be formatted as TAP output.

**5. Exploring Low-Level Relevance:**

Does this code directly interact with low-level concepts?

* **Direct Interaction:**  The `taptests.py` file itself *doesn't* directly manipulate binaries, kernel code, or Android frameworks. It's focused on parsing strings.
* **Indirect Relevance:**  The *output* it's parsing (TAP) is likely generated by code that *does* interact with these low-level aspects. For example, a Frida script might interact with Android's Binder framework and then report the outcome of that interaction as a TAP test.
* **Example:** A Frida script might test if a specific function in the Android framework returns a certain value. The result of this test ("ok" or "not ok") would be part of the TAP output that this parser is processing.

**6. Analyzing Logical Reasoning (Test Cases):**

The `test_*` methods are the core of the logical reasoning. I examine several examples:

* `test_empty`: Empty input, expects no events.
* `test_one_test_ok`:  Input "ok", expects a successful test event.
* `test_many_early_plan`: Input with a plan at the beginning, followed by test results. Verifies the parser handles this order.
* `test_out_of_order`: Input with a test result before a plan, expecting an error.

For each test, I identify the input TAP string and the expected sequence of `TAPParser` events. This demonstrates how the parser should behave under different input conditions.

**7. Identifying Potential User Errors:**

How could a user encounter this code due to mistakes?

* **Incorrect Frida Scripting:** A user might write a Frida script that generates malformed TAP output. For example, they might forget the "ok" or "not ok" prefix, or have incorrect numbering.
* **Misinterpreting Frida Output:** If a Frida script or tool outputs TAP, the user needs to understand the format to interpret the results correctly.
* **Debugging Test Failures:** If a Frida-based test suite fails, understanding how the TAP output is parsed can be crucial for diagnosing the root cause.

**8. Tracing the User's Path to This Code (Debugging Context):**

How does someone end up looking at `taptests.py` specifically?

* **Developing Frida Internals:** Someone contributing to the Frida project itself might be working on the TAP parsing functionality or fixing bugs in it.
* **Debugging Frida Test Infrastructure:** If the Frida test suite is failing, developers might need to examine the unit tests (like this one) to understand why.
* **Potentially Advanced Users:**  A very advanced Frida user who is deeply integrating Frida into their own testing infrastructure might need to understand the specifics of how Frida processes TAP output.

**9. Structuring the Answer:**

Finally, I organize the information into a clear and structured answer, addressing each of the user's specific questions with relevant examples from the code. I use headings and bullet points for readability. I ensure I connect the low-level concepts and reverse engineering aspects to the *context* of how Frida uses TAP, rather than claiming this specific file directly manipulates binaries.
这个文件 `taptests.py` 是 Frida 动态 instrumentation 工具中 `frida-core` 子项目的一部分，它专注于测试 TAP (Test Anything Protocol) 解析器的功能。TAP 是一种简单的文本格式，用于报告软件测试的结果。

**功能列表:**

1. **定义 TAP 事件类型:** 文件中定义了用于表示 TAP 解析结果的类，例如 `TAPParser.Test` (表示一个测试结果), `TAPParser.Plan` (表示测试计划), `TAPParser.Version` (表示 TAP 版本信息), `TAPParser.Error` (表示解析错误), `TAPParser.UnknownLine` (表示无法识别的行), 和 `TAPParser.Bailout` (表示测试提前终止)。

2. **实现 TAP 解析器的单元测试:**  核心功能是通过 `TAPParserTests` 类中的多个测试方法 (`test_empty`, `test_one_test_ok`, `test_many_early_plan` 等) 来验证 `TAPParser` 类的行为是否符合预期。这些测试方法会构造不同的 TAP 格式的字符串作为输入，然后断言 `TAPParser` 解析后产生的事件序列与预期的一致。

3. **测试各种 TAP 语法:**  测试用例覆盖了 TAP 协议的多种语法结构，例如：
    * 空输入
    * 测试计划 (带有或不带有跳过原因)
    * 单个测试用例 (成功或失败，带有或不带有编号和名称)
    * TODO 和 SKIP 指令
    * 提前或延迟声明的测试计划
    * 乱序的测试用例
    * 中途声明的测试计划
    * 测试用例数量与计划不符的情况
    * 诊断信息 (以 `#` 开头的行)
    * 空行
    * 意外的输入行
    * TAP 版本信息
    * YAML 数据块 (TAP 版本 13 支持)

4. **断言解析结果:**  每个测试方法都使用 `unittest` 框架提供的断言方法 (`assertEqual`, `assertRaises`) 来验证解析器的输出。例如，`assert_test` 断言解析出的事件是一个 `TAPParser.Test` 对象，并且其属性 (如测试编号、名称、结果) 与预期相符。

**与逆向方法的关系及举例说明:**

虽然 `taptests.py` 本身不直接进行逆向操作，但它测试的 `TAPParser` 类在 Frida 的测试和报告流程中扮演着重要角色，而 Frida 本身是一个强大的动态逆向工具。

**举例说明:**

假设你使用 Frida 写了一个脚本来测试 Android 应用程序的某个功能，并希望输出 TAP 格式的测试报告。你的 Frida 脚本可能会执行以下操作：

1. **连接到目标进程:**  使用 Frida 的 API 连接到目标 Android 应用程序的进程。
2. **Hook 函数:**  Hook 目标应用程序中的关键函数，以便在函数被调用时执行你的自定义代码。
3. **执行测试逻辑:**  调用被 hook 的函数，观察其行为和返回值。
4. **生成 TAP 输出:**  根据测试结果，你的 Frida 脚本会生成符合 TAP 格式的字符串，例如：
   ```
   ok 1 检查用户登录功能是否正常
   not ok 2 尝试使用无效密码登录
   1..2
   ```
5. **Frida 内部或外部工具解析 TAP:**  Frida 内部的测试框架或者外部的持续集成工具可能会使用类似 `TAPParser` 的组件来解析这些 TAP 输出，生成测试报告，判断测试是否通过。

`taptests.py` 的存在确保了 Frida 的 TAP 解析器能够正确理解和处理各种可能的 TAP 输出格式，这对于自动化 Frida 脚本的测试和集成至关重要。

**涉及二进制底层，linux, android内核及框架的知识及举例说明:**

`taptests.py` 自身并不直接涉及这些底层知识，它更多的是在应用层处理字符串。然而，它测试的 `TAPParser` 类所处理的 TAP 输出，往往是由与这些底层知识密切相关的代码生成的。

**举例说明:**

1. **二进制底层:**  一个 Frida 脚本可能会 hook 一个处理二进制数据的函数，例如解密算法。测试脚本会输入一些加密数据，然后断言 hook 到的函数的输出是预期的解密后的二进制数据。测试结果可能会以 TAP 格式输出：
   ```
   ok 1 测试加密算法解密特定输入
   ```

2. **Linux 内核:** 在 Linux 环境下，Frida 可以用来监控系统调用。一个测试用例可能会执行某个操作并检查是否触发了预期的系统调用。TAP 输出可能如下：
   ```
   ok 1 检查打开文件时是否调用了 open 系统调用
   ```

3. **Android 内核及框架:**  Frida 在 Android 逆向中非常常用。测试用例可能会：
    * **内核:**  监控内核驱动的行为，例如检查某个 IOCTL 是否返回了预期的结果。
    * **框架:**  测试 Android Framework 的 API，例如调用 `getSystemService` 获取某个服务，并验证返回的对象是否非空。相应的 TAP 输出可能是：
      ```
      ok 1 获取 Context.LOCATION_SERVICE 成功
      not ok 2 尝试调用受限的 Framework API (需要特定权限) # TODO 需要检查权限绕过方法
      ```

**逻辑推理及假设输入与输出:**

`taptests.py` 本身就充满了逻辑推理，因为它通过编写各种测试用例来验证 `TAPParser` 的逻辑是否正确。

**假设输入与输出示例 (基于 `test_one_test_ok`):**

* **假设输入:** 字符串 `"ok"`
* **预期输出:** 解析器应该产生一个 `TAPParser.Test` 事件，其属性为 `number=1`, `name=''`, `result=TestResult.OK`。

**假设输入与输出示例 (基于 `test_many_early_plan`):**

* **假设输入:** 字符串 `"1..4\nok 1\nnot ok 2\nok 3\nnot ok 4"`
* **预期输出:**
    1. 一个 `TAPParser.Plan` 事件，`num_tests=4`, `late=False`
    2. 一个 `TAPParser.Test` 事件，`number=1`, `name=''`, `result=TestResult.OK`
    3. 一个 `TAPParser.Test` 事件，`number=2`, `name=''`, `result=TestResult.FAIL`
    4. 一个 `TAPParser.Test` 事件，`number=3`, `name=''`, `result=TestResult.OK`
    5. 一个 `TAPParser.Test` 事件，`number=4`, `name=''`, `result=TestResult.FAIL`

**涉及用户或者编程常见的使用错误及举例说明:**

虽然 `taptests.py` 是测试代码，但它可以帮助发现和预防用户或编程中与 TAP 格式相关的错误。

**举例说明:**

1. **TAP 格式错误:**  用户编写的脚本或工具可能生成不符合 TAP 规范的输出。例如，忘记在测试结果前加上 `ok` 或 `not ok`，或者测试编号错误。`taptests.py` 中的测试用例可以覆盖这些错误情况，例如 `test_unexpected` 就测试了解析器如何处理无法识别的行。

2. **测试计划错误:**  用户可能在 TAP 输出中声明了错误的测试计划，例如实际运行了 5 个测试，但计划声明只有 3 个。`taptests.py` 中的 `test_too_many` 和 `test_too_few` 等测试用例就是为了验证解析器如何处理这种情况。

3. **指令使用错误:**  用户可能错误地使用了 `TODO` 或 `SKIP` 指令，例如在 `ok` 结果后使用了 `TODO`，或者 `SKIP` 指令后没有给出原因。`taptests.py` 中的 `test_one_test_todo` 和 `test_one_test_skip` 覆盖了这些场景。

**说明用户操作是如何一步步的到达这里，作为调试线索:**

一个用户可能在以下情况下会查看或关注 `frida/subprojects/frida-core/releng/meson/unittests/taptests.py` 文件：

1. **开发或调试 Frida 自身:** 如果用户是 Frida 的开发者或贡献者，他们可能会需要修改或添加 TAP 解析相关的代码，这时就需要理解和修改 `taptests.py` 中的测试用例，或者添加新的测试用例来验证他们的修改。

2. **调试 Frida 测试框架:** 当 Frida 的测试框架出现问题时，开发者可能会查看相关的单元测试，例如 `taptests.py`，来定位问题所在。如果 TAP 解析器本身存在 bug，那么相关的测试用例可能会失败。

3. **集成 Frida 到 CI/CD 系统:**  在将 Frida 集成到持续集成系统中时，可能会使用 TAP 格式作为测试报告的输出。如果测试报告解析出现问题，开发者可能会查看 Frida 的 TAP 解析器实现和相关的测试用例，以确保 Frida 生成的 TAP 输出是符合规范的。

4. **编写自定义的 Frida 测试工具:**  如果用户正在开发自己的工具来测试 Frida 脚本或基于 Frida 的应用程序，他们可能会参考 `taptests.py` 中如何构造和解析 TAP 输出，以便他们的工具能够与 Frida 的测试流程兼容。

5. **遇到与 TAP 报告相关的问题:**  用户在使用 Frida 或基于 Frida 的工具时，如果遇到测试报告解析错误或者格式问题，可能会被引导到 Frida 的源代码中查看 TAP 解析器的实现和测试用例，以便更好地理解问题的原因。

总而言之，`taptests.py` 虽然是测试代码，但它对于理解 Frida 如何处理测试报告，以及如何确保 Frida 的测试基础设施的正确性至关重要。对于 Frida 的开发者和高级用户来说，理解这个文件的内容可以帮助他们更深入地了解 Frida 的内部工作原理。

Prompt: 
```
这是目录为frida/subprojects/frida-core/releng/meson/unittests/taptests.py的fridaDynamic instrumentation tool的源代码文件， 请列举一下它的功能, 
如果它与逆向的方法有关系，请做出对应的举例说明，
如果涉及到二进制底层，linux, android内核及框架的知识，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索。

"""
# SPDX-License-Identifier: Apache-2.0
# Copyright 2016-2021 The Meson development team

import unittest
import io

from mesonbuild.mtest import TAPParser, TestResult


class TAPParserTests(unittest.TestCase):
    def assert_test(self, events, **kwargs):
        if 'explanation' not in kwargs:
            kwargs['explanation'] = None
        self.assertEqual(next(events), TAPParser.Test(**kwargs))

    def assert_plan(self, events, **kwargs):
        if 'skipped' not in kwargs:
            kwargs['skipped'] = False
        if 'explanation' not in kwargs:
            kwargs['explanation'] = None
        self.assertEqual(next(events), TAPParser.Plan(**kwargs))

    def assert_version(self, events, **kwargs):
        self.assertEqual(next(events), TAPParser.Version(**kwargs))

    def assert_error(self, events):
        self.assertEqual(type(next(events)), TAPParser.Error)

    def assert_unexpected(self, events, **kwargs):
        self.assertEqual(next(events), TAPParser.UnknownLine(**kwargs))

    def assert_bailout(self, events, **kwargs):
        self.assertEqual(next(events), TAPParser.Bailout(**kwargs))

    def assert_last(self, events):
        with self.assertRaises(StopIteration):
            next(events)

    def parse_tap(self, s):
        parser = TAPParser()
        return iter(parser.parse(io.StringIO(s)))

    def parse_tap_v13(self, s):
        events = self.parse_tap('TAP version 13\n' + s)
        self.assert_version(events, version=13)
        return events

    def test_empty(self):
        events = self.parse_tap('')
        self.assert_last(events)

    def test_empty_plan(self):
        events = self.parse_tap('1..0')
        self.assert_plan(events, num_tests=0, late=False, skipped=True)
        self.assert_last(events)

    def test_plan_directive(self):
        events = self.parse_tap('1..0 # skipped for some reason')
        self.assert_plan(events, num_tests=0, late=False, skipped=True,
                         explanation='for some reason')
        self.assert_last(events)

        events = self.parse_tap('1..1 # skipped for some reason\nok 1')
        self.assert_error(events)
        self.assert_plan(events, num_tests=1, late=False, skipped=True,
                         explanation='for some reason')
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_last(events)

        events = self.parse_tap('1..1 # todo not supported here\nok 1')
        self.assert_error(events)
        self.assert_plan(events, num_tests=1, late=False, skipped=False,
                         explanation='not supported here')
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_last(events)

    def test_one_test_ok(self):
        events = self.parse_tap('ok')
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_last(events)

    def test_one_test_with_number(self):
        events = self.parse_tap('ok 1')
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_last(events)

    def test_one_test_with_name(self):
        events = self.parse_tap('ok 1 abc')
        self.assert_test(events, number=1, name='abc', result=TestResult.OK)
        self.assert_last(events)

    def test_one_test_not_ok(self):
        events = self.parse_tap('not ok')
        self.assert_test(events, number=1, name='', result=TestResult.FAIL)
        self.assert_last(events)

    def test_one_test_todo(self):
        events = self.parse_tap('not ok 1 abc # TODO')
        self.assert_test(events, number=1, name='abc', result=TestResult.EXPECTEDFAIL)
        self.assert_last(events)

        events = self.parse_tap('ok 1 abc # TODO')
        self.assert_test(events, number=1, name='abc', result=TestResult.UNEXPECTEDPASS)
        self.assert_last(events)

    def test_one_test_skip(self):
        events = self.parse_tap('ok 1 abc # SKIP')
        self.assert_test(events, number=1, name='abc', result=TestResult.SKIP)
        self.assert_last(events)

    def test_one_test_skip_failure(self):
        events = self.parse_tap('not ok 1 abc # SKIP')
        self.assert_test(events, number=1, name='abc', result=TestResult.FAIL)
        self.assert_last(events)

    def test_many_early_plan(self):
        events = self.parse_tap('1..4\nok 1\nnot ok 2\nok 3\nnot ok 4')
        self.assert_plan(events, num_tests=4, late=False)
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_test(events, number=2, name='', result=TestResult.FAIL)
        self.assert_test(events, number=3, name='', result=TestResult.OK)
        self.assert_test(events, number=4, name='', result=TestResult.FAIL)
        self.assert_last(events)

    def test_many_late_plan(self):
        events = self.parse_tap('ok 1\nnot ok 2\nok 3\nnot ok 4\n1..4')
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_test(events, number=2, name='', result=TestResult.FAIL)
        self.assert_test(events, number=3, name='', result=TestResult.OK)
        self.assert_test(events, number=4, name='', result=TestResult.FAIL)
        self.assert_plan(events, num_tests=4, late=True)
        self.assert_last(events)

    def test_directive_case(self):
        events = self.parse_tap('ok 1 abc # skip')
        self.assert_test(events, number=1, name='abc', result=TestResult.SKIP)
        self.assert_last(events)

        events = self.parse_tap('ok 1 abc # ToDo')
        self.assert_test(events, number=1, name='abc', result=TestResult.UNEXPECTEDPASS)
        self.assert_last(events)

    def test_directive_explanation(self):
        events = self.parse_tap('ok 1 abc # skip why')
        self.assert_test(events, number=1, name='abc', result=TestResult.SKIP,
                         explanation='why')
        self.assert_last(events)

        events = self.parse_tap('ok 1 abc # ToDo Because')
        self.assert_test(events, number=1, name='abc', result=TestResult.UNEXPECTEDPASS,
                         explanation='Because')
        self.assert_last(events)

    def test_one_test_early_plan(self):
        events = self.parse_tap('1..1\nok')
        self.assert_plan(events, num_tests=1, late=False)
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_last(events)

    def test_one_test_late_plan(self):
        events = self.parse_tap('ok\n1..1')
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_plan(events, num_tests=1, late=True)
        self.assert_last(events)

    def test_out_of_order(self):
        events = self.parse_tap('ok 2')
        self.assert_error(events)
        self.assert_test(events, number=2, name='', result=TestResult.OK)
        self.assert_last(events)

    def test_middle_plan(self):
        events = self.parse_tap('ok 1\n1..2\nok 2')
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_plan(events, num_tests=2, late=True)
        self.assert_error(events)
        self.assert_test(events, number=2, name='', result=TestResult.OK)
        self.assert_last(events)

    def test_too_many_plans(self):
        events = self.parse_tap('1..1\n1..2\nok 1')
        self.assert_plan(events, num_tests=1, late=False)
        self.assert_error(events)
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_last(events)

    def test_too_many(self):
        events = self.parse_tap('ok 1\nnot ok 2\n1..1')
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_test(events, number=2, name='', result=TestResult.FAIL)
        self.assert_plan(events, num_tests=1, late=True)
        self.assert_error(events)
        self.assert_last(events)

        events = self.parse_tap('1..1\nok 1\nnot ok 2')
        self.assert_plan(events, num_tests=1, late=False)
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_test(events, number=2, name='', result=TestResult.FAIL)
        self.assert_error(events)
        self.assert_last(events)

    def test_too_few(self):
        events = self.parse_tap('ok 1\nnot ok 2\n1..3')
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_test(events, number=2, name='', result=TestResult.FAIL)
        self.assert_plan(events, num_tests=3, late=True)
        self.assert_error(events)
        self.assert_last(events)

        events = self.parse_tap('1..3\nok 1\nnot ok 2')
        self.assert_plan(events, num_tests=3, late=False)
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_test(events, number=2, name='', result=TestResult.FAIL)
        self.assert_error(events)
        self.assert_last(events)

    def test_too_few_bailout(self):
        events = self.parse_tap('1..3\nok 1\nnot ok 2\nBail out! no third test')
        self.assert_plan(events, num_tests=3, late=False)
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_test(events, number=2, name='', result=TestResult.FAIL)
        self.assert_bailout(events, message='no third test')
        self.assert_last(events)

    def test_diagnostics(self):
        events = self.parse_tap('1..1\n# ignored\nok 1')
        self.assert_plan(events, num_tests=1, late=False)
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_last(events)

        events = self.parse_tap('# ignored\n1..1\nok 1\n# ignored too')
        self.assert_plan(events, num_tests=1, late=False)
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_last(events)

        events = self.parse_tap('# ignored\nok 1\n1..1\n# ignored too')
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_plan(events, num_tests=1, late=True)
        self.assert_last(events)

    def test_empty_line(self):
        events = self.parse_tap('1..1\n\nok 1')
        self.assert_plan(events, num_tests=1, late=False)
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_last(events)

    def test_unexpected(self):
        events = self.parse_tap('1..1\ninvalid\nok 1')
        self.assert_plan(events, num_tests=1, late=False)
        self.assert_unexpected(events, message='invalid', lineno=2)
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_last(events)

    def test_version(self):
        events = self.parse_tap('TAP version 13\n')
        self.assert_version(events, version=13)
        self.assert_last(events)

        events = self.parse_tap('TAP version 12\n')
        self.assert_error(events)
        self.assert_last(events)

        events = self.parse_tap('1..0\nTAP version 13\n')
        self.assert_plan(events, num_tests=0, late=False, skipped=True)
        self.assert_error(events)
        self.assert_last(events)

    def test_yaml(self):
        events = self.parse_tap_v13('ok\n ---\n foo: abc\n  bar: def\n ...\nok 2')
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_test(events, number=2, name='', result=TestResult.OK)
        self.assert_last(events)

        events = self.parse_tap_v13('ok\n ---\n foo: abc\n  bar: def')
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_error(events)
        self.assert_last(events)

        events = self.parse_tap_v13('ok 1\n ---\n foo: abc\n  bar: def\nnot ok 2')
        self.assert_test(events, number=1, name='', result=TestResult.OK)
        self.assert_error(events)
        self.assert_test(events, number=2, name='', result=TestResult.FAIL)
        self.assert_last(events)

"""

```
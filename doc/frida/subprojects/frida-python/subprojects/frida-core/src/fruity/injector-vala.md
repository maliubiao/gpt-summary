Response:
### 功能归纳

`fruity/injector.vala` 文件是 Frida 工具中用于在 macOS 或 iOS 设备上动态注入代码的核心模块。它通过 LLDB（低级调试器）与目标进程进行交互，实现代码注入、内存分配、符号解析等功能。以下是该文件的主要功能：

1. **动态注入模块**：
   - 该文件的核心功能是将一个动态库（如 Frida Gadget）注入到目标进程中。注入的模块可以是 Frida 的 Gadget，用于在目标进程中运行 Frida 的脚本。
   - 注入过程包括内存分配、符号解析、重定位、绑定等操作。

2. **内存管理**：
   - 通过 LLDB 分配和释放内存页，用于存储注入的代码和数据。
   - 支持分配具有不同权限的内存页（如可读可写、可执行等）。

3. **符号解析**：
   - 解析目标进程中的符号（如 `socket`、`bind` 等系统调用），以便在注入的代码中使用这些符号。
   - 通过 LLDB 获取目标进程中的符号地址。

4. **重定位和绑定**：
   - 对注入的模块进行重定位操作，确保模块中的指针和引用能够正确指向目标进程中的地址。
   - 执行绑定操作，将模块中的符号绑定到目标进程中的实际地址。

5. **线程管理**：
   - 保存和恢复目标进程的主线程状态，确保注入操作不会破坏目标进程的正常执行。
   - 在注入完成后，可以选择继续执行特定的线程或直接分离调试器。

6. **网络通信**：
   - 注入的模块可以通过 TCP 端口与外部通信，Frida 工具可以通过该端口与注入的模块进行交互。
   - 支持在注入模块时配置网络监听端口。

7. **错误处理**：
   - 处理注入过程中可能出现的错误，如不支持的符号、内存分配失败等。

### 二进制底层与 Linux 内核

虽然该文件主要针对 macOS 和 iOS 系统（基于 Darwin 内核），但其中涉及的一些概念和技术在 Linux 系统中也有类似的应用。例如：

- **内存管理**：在 Linux 中，`mmap` 和 `mprotect` 系统调用可以用于分配和修改内存页的权限，类似于该文件中的 `mach_vm_allocate` 和 `mprotect`。
- **符号解析**：在 Linux 中，`dlopen` 和 `dlsym` 可以用于动态加载共享库并解析符号，类似于该文件中的符号解析过程。
- **线程管理**：在 Linux 中，`ptrace` 系统调用可以用于控制目标进程的线程状态，类似于该文件中的 LLDB 线程管理。

### LLDB 调试示例

假设我们想要复现该文件中的调试功能，可以使用 LLDB 的 Python 脚本接口。以下是一个简单的 LLDB Python 脚本示例，用于在目标进程中分配内存并写入数据：

```python
import lldb

def allocate_memory(debugger, command, result, internal_dict):
    target = debugger.GetSelectedTarget()
    process = target.GetProcess()
    
    # 分配内存页
    size = 0x1000  # 4KB
    error = lldb.SBError()
    address = process.AllocateMemory(size, lldb.ePermissionsReadWrite, error)
    
    if error.Success():
        print(f"Allocated memory at 0x{address:x}")
        
        # 写入数据
        data = b"\x90" * size  # NOP 指令
        process.WriteMemory(address, data, error)
        
        if error.Success():
            print(f"Data written to 0x{address:x}")
        else:
            print(f"Failed to write memory: {error}")
    else:
        print(f"Failed to allocate memory: {error}")

# 注册 LLDB 命令
def __lldb_init_module(debugger, internal_dict):
    debugger.HandleCommand('command script add -f lldb_script.allocate_memory allocate_memory')
```

在 LLDB 中加载该脚本后，可以使用 `allocate_memory` 命令在目标进程中分配内存并写入数据。

### 假设输入与输出

假设我们有一个目标进程，并且我们想要注入一个 Frida Gadget 模块。以下是可能的输入和输出：

- **输入**：
  - 目标进程的 PID。
  - 要注入的 Frida Gadget 模块路径。
  - 监听的 TCP 端口号（如 27043）。

- **输出**：
  - 注入成功，返回监听的端口号。
  - 注入失败，返回错误信息（如符号解析失败、内存分配失败等）。

### 用户常见错误

1. **符号解析失败**：
   - 用户可能尝试注入一个依赖于某些未解析符号的模块，导致注入失败。例如，模块中使用了 `socket` 系统调用，但目标进程中未找到该符号。
   - **解决方法**：确保目标进程中存在所需的符号，或者在注入前手动解析符号。

2. **内存分配失败**：
   - 目标进程的内存空间可能已经耗尽，导致无法分配新的内存页。
   - **解决方法**：尝试减少注入模块的大小，或者释放目标进程中的一些内存。

3. **线程状态恢复失败**：
   - 在注入过程中，目标进程的主线程状态可能被破坏，导致进程崩溃。
   - **解决方法**：确保在注入前后正确保存和恢复线程状态。

### 用户操作步骤

1. **启动目标进程**：用户启动一个目标进程，并获取其 PID。
2. **附加 LLDB**：用户使用 LLDB 附加到目标进程。
3. **加载注入脚本**：用户加载包含注入功能的 LLDB Python 脚本。
4. **执行注入**：用户执行注入命令，指定要注入的模块和监听端口。
5. **验证注入**：用户通过 TCP 端口与注入的模块进行交互，验证注入是否成功。

通过这些步骤，用户可以逐步完成代码注入操作，并在遇到问题时根据调试线索进行排查。
Prompt: 
```
这是目录为frida/subprojects/frida-python/subprojects/frida-core/src/fruity/injector.vala的frida Dynamic instrumentation tool的源代码文件， 请列举一下它的功能, 
如果涉及到二进制底层，linux内核，请做出对应的举例说明，
请给出用lldb指令或者lldb python脚本，用来复刻的源代码所实现调试功能的示例，如果源代码是调试功能的实现。
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索，
请用中文回复。
这是第1部分，共3部分，请归纳一下它的功能

"""
[CCode (gir_namespace = "FridaFruityInjector", gir_version = "1.0")]
namespace Frida.Fruity.Injector {
	public static async GadgetDetails inject (owned Gum.DarwinModule module, LLDB.Client lldb, HostChannelProvider channel_provider,
			Cancellable? cancellable) throws Error, IOError {
		var session = new Session (module, lldb, channel_provider);
		return yield session.run (cancellable);
	}

	public class GadgetDetails : Object {
		public uint16 port {
			get;
			construct;
		}

		public GadgetDetails (uint16 port) {
			Object (port: port);
		}
	}

	public errordomain Error {
		UNSUPPORTED
	}

	private class Session : Object {
		public Gum.DarwinModule module {
			get;
			construct;
		}

		public LLDB.Client lldb {
			get;
			construct;
		}

		public HostChannelProvider channel_provider {
			get;
			construct;
		}

		public Gum.CpuType cpu_type {
			get;
			construct;
			default = ARM64;
		}

		public uint page_size {
			get;
			construct;
			default = 16384;
		}

		public uint pointer_size {
			get;
			construct;
			default = 8;
		}

		private LLDB.Thread? main_thread;
		private LLDB.Thread.Snapshot? saved_state;
		private LLDB.Thread.StackBounds? stack_bounds;

		private uint64 jit_page;
		private uint64 scratch_page;

		private LLDB.AppleDyldFields? dyld_fields;
		private uint64 dyld_base;

		private bool libsystem_initialized;

		private size_t module_size;

		public Session (Gum.DarwinModule module, LLDB.Client lldb, HostChannelProvider channel_provider) {
			Object (
				module: module,
				lldb: lldb,
				channel_provider: channel_provider
			);
		}

		public async GadgetDetails run (Cancellable? cancellable) throws Error, IOError {
			try {
				var existing_gadget = yield setup (cancellable);
				if (existing_gadget != null) {
					yield lldb.detach (cancellable);
					return existing_gadget;
				}

				bool is_early_instrumentation = !libsystem_initialized;

				yield ensure_libsystem_initialized (cancellable);
				var result = yield inject_module (cancellable);

				yield teardown (cancellable);

				if (is_early_instrumentation) {
					var gadget_threads = new Gee.ArrayList<LLDB.Thread> ();
					yield lldb.enumerate_threads (thread => {
						if (thread.id != main_thread.id)
							gadget_threads.add (thread);
						return true;
					}, cancellable);
					yield lldb.continue_specific_threads (gadget_threads, cancellable);
				} else {
					yield lldb.detach (cancellable);
				}

				return result;
			} catch (GLib.Error e) {
				throw new Error.UNSUPPORTED ("%s", e.message);
			}
		}

		private async GadgetDetails? setup (Cancellable? cancellable) throws GLib.Error {
			GadgetDetails? existing_gadget = null;
			yield lldb.enumerate_threads (thread => {
				if (main_thread == null)
					main_thread = thread;

				unowned string? name = thread.name;
				if (name == null)
					return true;

				MatchInfo info;
				if (/^frida-gadget-tcp-(\d+)$/.match (name, 0, out info)) {
					string raw_port = info.fetch (1);

					try {
						uint64 port;
						const uint radix = 10;
						uint64.from_string (raw_port, out port, radix, 1, uint16.MAX);

						existing_gadget = new GadgetDetails ((uint16) port);

						return false;
					} catch (NumberParserError e) {
					}
				}

				return true;
			}, cancellable);
			if (existing_gadget != null)
				return existing_gadget;
			yield save_main_thread_state (cancellable);

			jit_page = yield lldb.allocate (page_size, "rx", cancellable);
			scratch_page = yield lldb.allocate (page_size, "rw", cancellable);

			dyld_fields = yield lldb.get_apple_dyld_fields (ALLOW_CACHE, cancellable);
			libsystem_initialized = yield lldb.read_bool (dyld_fields.libsystem_initialized, cancellable);
			if (libsystem_initialized) {
				dyld_base = yield lldb.read_pointer (dyld_fields.dyld_load_address, cancellable);
			} else {
				yield lldb.enumerate_modules (m => {
					if (m.pathname == "/usr/lib/dyld" || m.pathname == "/binpack/lib/dyld") {
						dyld_base = m.load_address;
						return false;
					}

					return true;
				}, cancellable);
			}

			return null;
		}

		private async void teardown (Cancellable? cancellable) throws GLib.Error {
			yield lldb.deallocate (scratch_page, cancellable);
			yield lldb.deallocate (jit_page, cancellable);

			yield restore_main_thread_state (cancellable);
		}

		private async void save_main_thread_state (Cancellable? cancellable) throws GLib.Error {
			assert (saved_state == null);
			saved_state = yield main_thread.save_register_state (cancellable);

			stack_bounds = null;
		}

		private async void restore_main_thread_state (Cancellable? cancellable) throws GLib.Error {
			assert (saved_state != null);
			yield main_thread.restore_register_state (saved_state, cancellable);
			saved_state = null;
		}

		private async GadgetDetails inject_module (Cancellable? cancellable) throws GLib.Error {
			module_size = compute_virtual_size (module);
			module.base_address = yield lldb.allocate (module_size, "rw", cancellable);

			unowned Gum.DarwinModuleImage image = module.image;
			unowned uint8[] image_data = ((uint8[]) image.data)[0:image.size];
			var buffer = lldb.make_buffer (new Bytes.static (image_data));

			perform_rebase_operations (buffer);

			var symbols_needed = new SymbolQueryBuilder ();
			var threaded_items = new ThreadedItemsBuilder ();
			var chained_fixups = new ChainedFixupsBuilder ();

			collect_needed_symbols_and_threaded_items (buffer, symbols_needed, threaded_items);
			collect_chained_fixups (chained_fixups);
			UploadSymbols.extend_query (symbols_needed);

			var symbols = yield resolve_symbols (symbols_needed.build (), cancellable);

			if (threaded_items.is_empty)
				perform_bind_operations (buffer, symbols);

			var gadget_port = yield upload (buffer, threaded_items.build (symbols), chained_fixups.build (),
				new UploadSymbols.from_set (symbols), cancellable);

			return new GadgetDetails (gadget_port);
		}

		private void perform_rebase_operations (Buffer buffer) throws GLib.Error {
			GLib.Error? pending_error = null;

			module.enumerate_rebases (rebase => {
				switch (rebase.type) {
					case POINTER:
					case TEXT_ABSOLUTE32:
						break;
					default:
						pending_error = new Error.UNSUPPORTED ("Unsupported rebase type: %u", rebase.type);
						return false;
				}

				size_t offset = (size_t) (rebase.segment.file_offset + rebase.offset);
				uint64 address = buffer.read_pointer (offset);
				buffer.write_pointer (offset, address + rebase.slide);

				return true;
			});

			if (pending_error != null)
				throw pending_error;
		}

		private void collect_needed_symbols_and_threaded_items (Buffer buffer, SymbolQueryBuilder symbols_needed,
				ThreadedItemsBuilder threaded_items) throws GLib.Error {
			Gum.Address slide = module.slide;
			bool have_threaded_items = false;
			GLib.Error? pending_error = null;

			Gum.FoundDarwinBindFunc collect_bind = bind => {
				switch (bind.type) {
					case POINTER: {
						switch (bind.library_ordinal) {
							case SELF:
							case MAIN_EXECUTABLE:
							case FLAT_LOOKUP:
							case WEAK_LOOKUP:
								pending_error = new Error.UNSUPPORTED ("Unsupported bind ordinal: %d",
									bind.library_ordinal);
								return false;
							default:
								break;
						}

						unowned string module_name = module.get_dependency_by_ordinal (bind.library_ordinal);
						unowned string symbol_name = bind.symbol_name;

						symbols_needed.add (module_name, symbol_name);
						if (have_threaded_items)
							threaded_items.add_symbol (module_name, symbol_name);

						break;
					}
					case THREADED_TABLE:
						have_threaded_items = true;
						break;
					case THREADED_ITEMS:
						threaded_items.add_region (bind.segment.vm_address + slide + bind.offset);
						break;
					default:
						pending_error = new Error.UNSUPPORTED ("Unsupported bind type: %u", bind.type);
						return false;
				}

				return true;
			};

			module.enumerate_binds (collect_bind);
			if (pending_error != null)
				throw pending_error;

			module.enumerate_lazy_binds (collect_bind);
			if (pending_error != null)
				throw pending_error;
		}

		private void collect_chained_fixups (ChainedFixupsBuilder chained_fixups) {
			module.enumerate_chained_fixups (fixup => {
				chained_fixups.add_location (fixup.vm_address);
				return true;
			});
		}

		private void perform_bind_operations (Buffer buffer, SymbolSet symbols) throws GLib.Error {
			GLib.Error? pending_error = null;

			Gum.FoundDarwinBindFunc perform_bind = bind => {
				unowned string module_name = module.get_dependency_by_ordinal (bind.library_ordinal);
				unowned string symbol_name = bind.symbol_name;

				uint64 address;
				if (!symbols.lookup (module_name, symbol_name, out address)) {
					bool is_weak = (bind.symbol_flags & Gum.DarwinBindSymbolFlags.WEAK_IMPORT) != 0;
					if (is_weak || is_dyld_stub_binder (module_name, symbol_name))
						return true;
					pending_error = new Error.UNSUPPORTED ("Unable to resolve symbol: %s", bind.symbol_name);
					return false;
				}

				buffer.write_pointer ((size_t) (bind.segment.file_offset + bind.offset), address + bind.addend);

				return true;
			};

			module.enumerate_binds (perform_bind);
			if (pending_error != null)
				throw pending_error;

			module.enumerate_lazy_binds (perform_bind);
			if (pending_error != null)
				throw pending_error;
		}

		private async uint16 upload (Buffer buffer, ThreadedItems threaded_items, ChainedFixups chained_fixups,
				UploadSymbols symbols, Cancellable? cancellable) throws GLib.Error {
			uint64 code = jit_page;
			yield lldb.write_byte_array (code, new Bytes.static (UPLOAD_LISTENER_CODE), cancellable);

			const uint64 rx_buffer_size = 1024 * 1024;

			uint64 args = scratch_page;
			var args_builder = lldb.make_buffer_builder ();

			string range_param = ("frida_dylib_range=0x%" + uint64.FORMAT_MODIFIER + "x,0x%" + size_t.FORMAT_MODIFIER + "x")
				.printf (module.base_address, module_size);

			var config = new Json.Builder ();
			config
				.begin_object ()
					.set_member_name ("interaction")
					.begin_object ()
						.set_member_name ("type")
						.add_string_value ("listen")
						.set_member_name ("port")
						.add_int_value (27043)
						.set_member_name ("on_port_conflict")
						.add_string_value ("pick-next")
						.set_member_name ("on_load")
						.add_string_value ("resume")
					.end_object ()
					.set_member_name ("teardown")
					.add_string_value ("full")
				.end_object ();
			string raw_config = Json.to_string (config.get_root (), false);
			string config_param = "frida_gadget_config=" + Base64.encode (raw_config.data);

			var apple_strv_builder = new StringVectorBuilder (args_builder);

			apple_strv_builder
				.append_string (range_param)
				.append_string (config_param)
				.append_terminator ();
			var apple_strv_offset = apple_strv_builder.append_placeholder ();

			var api_offset = args_builder.offset;
			args_builder
				.append_pointer (symbols.socket)
				.append_pointer (symbols.setsockopt)
				.append_pointer (symbols.bind)
				.append_pointer (symbols.listen)
				.append_pointer (symbols.getsockname)
				.append_pointer (symbols.accept)
				.append_pointer (symbols.read)
				.append_pointer (symbols.write)
				.append_pointer (symbols.sys_icache_invalidate)
				.append_pointer (symbols.sys_dcache_flush)
				.append_pointer (symbols._mach_task_self)
				.append_pointer (symbols.mach_vm_allocate)
				.append_pointer (symbols.mach_vm_deallocate)
				.append_pointer (symbols.dlopen)
				.append_pointer (symbols.dlsym)
				.append_pointer (symbols.mprotect)
				.append_pointer (symbols.close)
				.append_pointer (symbols.get_errno_storage);

			apple_strv_builder.build (args);

			yield lldb.write_byte_array (args, args_builder.build (), cancellable);

			uint64 apple_strv = args + apple_strv_offset;
			uint64 upload_api = args + api_offset;

			uint64 listen_result = yield invoke_remote_function (code, {
					rx_buffer_size,
					upload_api
				}, null, cancellable);

			uint8  error_code    =  (uint8) ((listen_result >> 56) & 0xff);
			uint32 listener_fd   = (uint32) ((listen_result >> 16) & 0xffffffffU);
			uint16 listener_port = (uint16)  (listen_result        & 0xffff);

			if (error_code != 0)
				throw new Error.UNSUPPORTED ("Unable to listen on TCP (error_code=%u)", error_code);

			yield lldb.write_byte_array (code, new Bytes.static (UPLOAD_RECEIVER_CODE), cancellable);

			// The generated session ID only acts as a sanitycheck for now
			var rand = new Rand.with_seed ((uint32) dyld_base);
			uint64 session_id_top    = ((uint64) rand.next_int () << 32) | ((uint64) rand.next_int ());
			uint64 session_id_bottom = ((uint64) rand.next_int () << 32) | ((uint64) rand.next_int ());

			perform_upload.begin (buffer, threaded_items, chained_fixups, listener_port, session_id_top, session_id_bottom,
				symbols, cancellable);

			int64 receive_result = (int64) yield invoke_remote_function (code, {
					listener_fd,
					session_id_top,
					session_id_bottom,
					apple_strv,
					upload_api
				}, null, cancellable);
			if (receive_result <= 0)
				throw new Error.UNSUPPORTED ("Unable to start gadget: %" + int64.FORMAT_MODIFIER + "d", receive_result);

			return (uint16) receive_result;
		}

		private async void perform_upload (Buffer buffer, ThreadedItems threaded_items, ChainedFixups chained_fixups,
				uint16 listener_port, uint64 session_id_top, uint64 session_id_bottom, UploadSymbols symbols,
				Cancellable? cancellable) {
			try {
				var stream = yield channel_provider.open_channel (
					("tcp:%" + uint16.FORMAT_MODIFIER + "u").printf (listener_port),
					cancellable);
				var output = stream.output_stream;
				var input = stream.input_stream;
				var io_priority = Priority.DEFAULT;

				var hello = lldb.make_buffer_builder ()
					.append_uint64 (session_id_top)
					.append_uint64 (session_id_bottom)
					.build ();
				size_t bytes_written;
				size_t bytes_read;
				var check_buf = new uint8[4];

				yield output.write_all_async (hello.get_data (), io_priority, cancellable, out bytes_written);
				yield input.read_all_async (check_buf, io_priority, cancellable, out bytes_read);
				if (bytes_read != 4) {
					yield stream.close_async (io_priority, cancellable);
					return;
				}

				uint64 slide = module.slide;

				foreach (unowned Gum.DarwinSegment segment in module.segments.data) {
					uint64 address = segment.vm_address + slide;

					Bytes bytes = new Bytes.from_bytes (buffer.bytes, (size_t) segment.file_offset,
						(size_t) segment.file_size);

					var write_command_header = lldb.make_buffer_builder ()
						.append_uint8 (UploadCommandType.WRITE)
						.append_uint64 (address)
						.append_uint32 ((uint32) bytes.get_size ())
						.build ();
					yield output.write_all_async (write_command_header.get_data (), io_priority, cancellable,
						out bytes_written);
					yield output.write_all_async (bytes.get_data (), io_priority, cancellable, out bytes_written);
				}

				if (!threaded_items.is_empty) {
					var command = lldb.make_buffer_builder ()
						.append_uint8 (UploadCommandType.APPLY_THREADED)
						.append_uint64 (module.preferred_address)
						.append_uint64 (slide);

					var symbol_addrs = threaded_items.symbol_addrs;
					command.append_uint16 ((uint16) symbol_addrs.size);
					foreach (var symbol in symbol_addrs)
						command.append_uint64 (symbol);

					var region_bases = threaded_items.region_bases;
					command.append_uint16 ((uint16) region_bases.size);
					foreach (var region in region_bases)
						command.append_uint64 (region);

					yield output.write_all_async (command.build ().get_data (), io_priority, cancellable,
						out bytes_written);
				}

				foreach (uint64 fixups_header_address in chained_fixups.locations) {
					var fixup_command = lldb.make_buffer_builder ()
						.append_uint8 (UploadCommandType.PROCESS_FIXUPS)
						.append_uint64 (fixups_header_address)
						.append_uint64 (module.base_address)
						.append_uint64 (module.preferred_address)
						.build ();
					yield output.write_all_async (fixup_command.get_data (), io_priority, cancellable,
						out bytes_written);
				}

				foreach (unowned Gum.DarwinSegment segment in module.segments.data) {
					uint64 address = segment.vm_address + slide;

					var protect_command = lldb.make_buffer_builder ()
						.append_uint8 (UploadCommandType.PROTECT)
						.append_uint64 (address)
						.append_uint32 ((uint32) segment.vm_size)
						.append_uint32 ((uint32) segment.protection)
						.build ();
					yield output.write_all_async (protect_command.get_data (), io_priority, cancellable,
						out bytes_written);
				}

				var construct_commands = lldb.make_buffer_builder ();
				module.enumerate_init_pointers (ptrs => {
					construct_commands
						.append_uint8 (UploadCommandType.CONSTRUCT_FROM_POINTERS)
						.append_uint64 (ptrs.address)
						.append_uint32 ((uint32) ptrs.count);
					return true;
				});
				module.enumerate_init_offsets (offsets => {
					construct_commands
						.append_uint8 (UploadCommandType.CONSTRUCT_FROM_OFFSETS)
						.append_uint64 (offsets.address)
						.append_uint32 ((uint32) offsets.count)
						.append_uint64 (module.base_address);
					return true;
				});
				yield output.write_all_async (construct_commands.build ().get_data (), io_priority, cancellable,
					out bytes_written);

				var check_command = lldb.make_buffer_builder ()
					.append_uint8 (UploadCommandType.CHECK);
				yield output.write_all_async (check_command.build ().get_data (), io_priority, cancellable,
					out bytes_written);
				yield input.read_all_async (check_buf, io_priority, cancellable, out bytes_read);

				yield stream.close_async (io_priority, cancellable);
			} catch (GLib.Error e) {
			}
		}

		private enum UploadCommandType {
			WRITE = 1,
			APPLY_THREADED,
			PROCESS_FIXUPS,
			PROTECT,
			CONSTRUCT_FROM_POINTERS,
			CONSTRUCT_FROM_OFFSETS,
			CHECK,
		}

		private class UploadSymbols {
			public uint64 socket;
			public uint64 setsockopt;
			public uint64 bind;
			public uint64 listen;
			public uint64 getsockname;
			public uint64 accept;
			public uint64 read;
			public uint64 write;
			public uint64 sys_icache_invalidate;
			public uint64 sys_dcache_flush;
			public uint64 _mach_task_self;
			public uint64 mach_vm_allocate;
			public uint64 mach_vm_deallocate;
			public uint64 dlopen;
			public uint64 dlsym;
			public uint64 mprotect;
			public uint64 close;
			public uint64 get_errno_storage;

			private const string LIBSYSTEM = "/usr/lib/libSystem.B.dylib";

			public static void extend_query (SymbolQueryBuilder builder) {
				builder
					.add (LIBSYSTEM, "_socket")
					.add (LIBSYSTEM, "_setsockopt")
					.add (LIBSYSTEM, "_bind")
					.add (LIBSYSTEM, "_listen")
					.add (LIBSYSTEM, "_getsockname")
					.add (LIBSYSTEM, "_accept")
					.add (LIBSYSTEM, "_read")
					.add (LIBSYSTEM, "_write")
					.add (LIBSYSTEM, "_sys_icache_invalidate")
					.add (LIBSYSTEM, "_sys_dcache_flush")
					.add (LIBSYSTEM, "_mach_task_self")
					.add (LIBSYSTEM, "_mach_vm_allocate")
					.add (LIBSYSTEM, "_mach_vm_deallocate")
					.add (LIBSYSTEM, "_dlopen")
					.add (LIBSYSTEM, "_dlsym")
					.add (LIBSYSTEM, "_mprotect")
					.add (LIBSYSTEM, "_close")
					.add (LIBSYSTEM, "___error")
					;
			}

			public UploadSymbols.from_set (SymbolSet symbols) throws Error {
				socket                = symbols.get (LIBSYSTEM, "_socket");
				setsockopt            = symbols.get (LIBSYSTEM, "_setsockopt");
				bind                  = symbols.get (LIBSYSTEM, "_bind");
				listen                = symbols.get (LIBSYSTEM, "_listen");
				getsockname           = symbols.get (LIBSYSTEM, "_getsockname");
				accept                = symbols.get (LIBSYSTEM, "_accept");
				read                  = symbols.get (LIBSYSTEM, "_read");
				write                 = symbols.get (LIBSYSTEM, "_write");
				sys_icache_invalidate = symbols.get (LIBSYSTEM, "_sys_icache_invalidate");
				sys_dcache_flush      = symbols.get (LIBSYSTEM, "_sys_dcache_flush");
				_mach_task_self       = symbols.get (LIBSYSTEM, "_mach_task_self");
				mach_vm_allocate      = symbols.get (LIBSYSTEM, "_mach_vm_allocate");
				mach_vm_deallocate    = symbols.get (LIBSYSTEM, "_mach_vm_deallocate");
				dlopen                = symbols.get (LIBSYSTEM, "_dlopen");
				dlsym                 = symbols.get (LIBSYSTEM, "_dlsym");
				mprotect              = symbols.get (LIBSYSTEM, "_mprotect");
				close                 = symbols.get (LIBSYSTEM, "_close");
				get_errno_storage     = symbols.get (LIBSYSTEM, "___error");
			}
		}

		/* Compiled from helpers/upload-listener.c */
		private const uint8[] UPLOAD_LISTENER_CODE = {
			0xff, 0x83, 0x01, 0xd1, 0xf6, 0x57, 0x03, 0xa9, 0xf4, 0x4f, 0x04, 0xa9, 0xfd, 0x7b, 0x05, 0xa9, 0xfd, 0x43, 0x01,
			0x91, 0xf3, 0x03, 0x01, 0xaa, 0x08, 0x00, 0x00, 0x90, 0x08, 0xb1, 0x04, 0x91, 0xa0, 0xc3, 0x1d, 0xb8, 0x00, 0x01,
			0xc0, 0x3d, 0xe0, 0x07, 0x80, 0x3d, 0x00, 0xc1, 0xc0, 0x3c, 0xe0, 0xc3, 0x81, 0x3c, 0x28, 0x00, 0x40, 0xf9, 0xc0,
			0x03, 0x80, 0x52, 0x21, 0x00, 0x80, 0x52, 0x02, 0x00, 0x80, 0x52, 0x00, 0x01, 0x3f, 0xd6, 0x1f, 0x04, 0x00, 0x31,
			0xc0, 0x04, 0x00, 0x54, 0xf4, 0x03, 0x00, 0xaa, 0x68, 0x06, 0x40, 0xf9, 0xa3, 0x93, 0x00, 0xd1, 0xe1, 0xff, 0x9f,
			0x52, 0x42, 0x00, 0x82, 0x52, 0x84, 0x00, 0x80, 0x52, 0x00, 0x01, 0x3f, 0xd6, 0x1f, 0x04, 0x00, 0x31, 0xe0, 0x03,
			0x00, 0x54, 0x88, 0x03, 0x80, 0x52, 0xe8, 0x0f, 0x00, 0xb9, 0x68, 0x0a, 0x40, 0xf9, 0xe1, 0x43, 0x00, 0x91, 0xe0,
			0x03, 0x14, 0xaa, 0x82, 0x03, 0x80, 0x52, 0x00, 0x01, 0x3f, 0xd6, 0x1f, 0x04, 0x00, 0x31, 0x00, 0x03, 0x00, 0x54,
			0x68, 0x12, 0x40, 0xf9, 0xe1, 0x43, 0x00, 0x91, 0xe2, 0x33, 0x00, 0x91, 0xe0, 0x03, 0x14, 0xaa, 0x00, 0x01, 0x3f,
			0xd6, 0x1f, 0x04, 0x00, 0x31, 0x60, 0x02, 0x00, 0x54, 0x68, 0x0e, 0x40, 0xf9, 0xe0, 0x03, 0x14, 0xaa, 0x21, 0x00,
			0x80, 0x52, 0x00, 0x01, 0x3f, 0xd6, 0x1f, 0x04, 0x00, 0x31, 0xe0, 0x01, 0x00, 0x54, 0x88, 0x7e, 0x40, 0x93, 0xe9,
			0x27, 0x40, 0x79, 0x29, 0x09, 0xc0, 0x5a, 0x35, 0x7d, 0x10, 0x53, 0x15, 0xbd, 0x70, 0xb3, 0x0d, 0x00, 0x00, 0x14,
			0x15, 0x20, 0xe0, 0xd2, 0x0b, 0x00, 0x00, 0x14, 0x15, 0x40, 0xe0, 0xd2, 0x06, 0x00, 0x00, 0x14, 0x15, 0x60, 0xe0,
			0xd2, 0x04, 0x00, 0x00, 0x14, 0x15, 0x80, 0xe0, 0xd2, 0x02, 0x00, 0x00, 0x14, 0x15, 0xa0, 0xe0, 0xd2, 0x68, 0x42,
			0x40, 0xf9, 0xe0, 0x03, 0x14, 0xaa, 0x00, 0x01, 0x3f, 0xd6, 0xe0, 0x03, 0x15, 0xaa, 0xfd, 0x7b, 0x45, 0xa9, 0xf4,
			0x4f, 0x44, 0xa9, 0xf6, 0x57, 0x43, 0xa9, 0xff, 0x83, 0x01, 0x91, 0xc0, 0x03, 0x5f, 0xd6, 0x00, 0x1e, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00
		};

		/* Compiled from helpers/upload-receiver.c */
		private const uint8[] UPLOAD_RECEIVER_CODE = {
			0xfc, 0x6f, 0xba, 0xa9, 0xfa, 0x67, 0x01, 0xa9, 0xf8, 0x5f, 0x02, 0xa9, 0xf6, 0x57, 0x03, 0xa9, 0xf4, 0x4f, 0x04,
			0xa9, 0xfd, 0x7b, 0x05, 0xa9, 0xfd, 0x43, 0x01, 0x91, 0xff, 0x03, 0x03, 0xd1, 0xfa, 0x03, 0x04, 0xaa, 0xfb, 0x03,
			0x03, 0xaa, 0xf7, 0x03, 0x02, 0xaa, 0xf8, 0x03, 0x01, 0xaa, 0xf9, 0x03, 0x00, 0xaa, 0xbf, 0xc3, 0x19, 0xb8, 0x88,
			0x95, 0x98, 0x52, 0x48, 0x89, 0xb5, 0x72, 0xa8, 0x03, 0x18, 0xb8, 0x13, 0x02, 0x80, 0x52, 0xb3, 0x43, 0x18, 0xb8,
			0x48, 0x17, 0x40, 0xf9, 0xa1, 0xe3, 0x01, 0xd1, 0xa2, 0xf3, 0x01, 0xd1, 0xe0, 0x03, 0x19, 0xaa, 0x00, 0x01, 0x3f,
			0xd6, 0x1f, 0x04, 0x00, 0x31, 0xe1, 0x00, 0x00, 0x54, 0x48, 0x47, 0x40, 0xf9, 0x00, 0x01, 0x3f, 0xd6, 0x08, 0x00,
			0x40, 0xb9, 0x1f, 0x11, 0x00, 0x71, 0xa0, 0xfe, 0xff, 0x54, 0xd7, 0x01, 0x00, 0x14, 0xf6, 0x03, 0x00, 0xaa, 0xa1,
			0x43, 0x02, 0xd1, 0x02, 0x02, 0x80, 0x52, 0x53, 0x02, 0x00, 0x94, 0xa8, 0x27, 0x77, 0xa9, 0x1f, 0x00, 0x00, 0x71,
			0x00, 0x11, 0x58, 0xfa, 0x20, 0x01, 0x57, 0xfa, 0x60, 0x00, 0x00, 0x54, 0x65, 0x02, 0x00, 0x94, 0xe8, 0xff, 0xff,
			0x17, 0x58, 0x02, 0x00, 0x94, 0x20, 0x39, 0x00, 0x34, 0xa8, 0x23, 0x00, 0xd1, 0x1a, 0x01, 0x10, 0xf8, 0xa8, 0x33,
			0x00, 0xd1, 0x19, 0x01, 0x10, 0xb8, 0xbb, 0x83, 0x11, 0xf8, 0xa1, 0x47, 0x02, 0xd1, 0xe0, 0x03, 0x16, 0xaa, 0x22,
			0x00, 0x80, 0x52, 0x41, 0x02, 0x00, 0x94, 0xe0, 0x37, 0x00, 0x34, 0xa8, 0xf3, 0x56, 0x38, 0x10, 0x05, 0x00, 0x51,
			0x1f, 0x1a, 0x00, 0x71, 0x68, 0x37, 0x00, 0x54, 0x1f, 0x1a, 0x00, 0xf1, 0x10, 0x92, 0x9f, 0x9a, 0xb1, 0x38, 0x00,
			0x10, 0x1f, 0x20, 0x03, 0xd5, 0x30, 0x7a, 0xb0, 0xb8, 0x11, 0x00, 0x00, 0x10, 0x30, 0x02, 0x10, 0x8b, 0x00, 0x02,
			0x1f, 0xd6, 0xa1, 0x83, 0x01, 0xd1, 0xe0, 0x03, 0x16, 0xaa, 0x02, 0x01, 0x80, 0x52, 0x30, 0x02, 0x00, 0x94, 0xc0,
			0x35, 0x00, 0x34, 0xa1, 0xa3, 0x02, 0xd1, 0xe0, 0x03, 0x16, 0xaa, 0x82, 0x00, 0x80, 0x52, 0x2b, 0x02, 0x00, 0x94,
			0x20, 0x35, 0x00, 0x36, 0xa1, 0x03, 0x5a, 0xf8, 0xa2, 0x83, 0x55, 0xb8, 0xa3, 0x83, 0x02, 0xd1, 0xe0, 0x03, 0x16,
			0xaa, 0xe4, 0x03, 0x1a, 0xaa, 0xbb, 0x01, 0x00, 0x94, 0xf7, 0x03, 0x00, 0xaa, 0x48, 0x23, 0x40, 0xf9, 0x36, 0x02,
			0x00, 0x94, 0x48, 0x27, 0x40, 0xf9, 0x34, 0x02, 0x00, 0x94, 0x57, 0xfb, 0x07, 0x37, 0x9c, 0x01, 0x00, 0x14, 0xa1,
			0x83, 0x01, 0xd1, 0xe0, 0x03, 0x16, 0xaa, 0x02, 0x01, 0x80, 0x52, 0x19, 0x02, 0x00, 0x94, 0xe0, 0x32, 0x00, 0x34,
			0xa1, 0x83, 0x02, 0xd1, 0xe0, 0x03, 0x16, 0xaa, 0x02, 0x01, 0x80, 0x52, 0x14, 0x02, 0x00, 0x94, 0x40, 0x32, 0x00,
			0x34, 0xa1, 0xa3, 0x02, 0xd1, 0xe0, 0x03, 0x16, 0xaa, 0x42, 0x00, 0x80, 0x52, 0x0f, 0x02, 0x00, 0x94, 0xa0, 0x31,
			0x00, 0x34, 0xf5, 0x03, 0x00, 0x91, 0xa8, 0x83, 0x55, 0x78, 0x08, 0x71, 0x1d, 0x53, 0x08, 0x3d, 0x00, 0x11, 0x08,
			0x3d, 0x7c, 0x92, 0xe9, 0x03, 0x00, 0x91, 0x37, 0x01, 0x08, 0xcb, 0xff, 0x02, 0x00, 0x91, 0xa8, 0x83, 0x55, 0x78,
			0x02, 0xf1, 0x7d, 0xd3, 0xe0, 0x03, 0x16, 0xaa, 0xe1, 0x03, 0x17, 0xaa, 0x01, 0x02, 0x00, 0x94, 0xc0, 0x2f, 0x00,
			0x34, 0xa1, 0xc3, 0x02, 0xd1, 0xe0, 0x03, 0x16, 0xaa, 0x42, 0x00, 0x80, 0x52, 0xfc, 0x01, 0x00, 0x94, 0x20, 0x2f,
			0x00, 0x34, 0xa8, 0x03, 0x55, 0x78, 0x09, 0x71, 0x1d, 0x53, 0x29, 0x3d, 0x00, 0x11, 0x29, 0x3d, 0x7c, 0x92, 0xea,
			0x03, 0x00, 0x91, 0x58, 0x01, 0x09, 0xcb, 0x1f, 0x03, 0x00, 0x91, 0x02, 0xf1, 0x7d, 0xd3, 0xe0, 0x03, 0x16, 0xaa,
			0xe1, 0x03, 0x18, 0xaa, 0xf0, 0x01, 0x00, 0x94, 0xa0, 0x2d, 0x00, 0x34, 0x14, 0x00, 0x80, 0xd2, 0xba, 0x03, 0x5a,
			0xf8, 0xbb, 0x03, 0x56, 0xf8, 0xbc, 0x03, 0x55, 0x78, 0x9f, 0x02, 0x1c, 0xeb, 0x40, 0x27, 0x00, 0x54, 0x19, 0x7b,
			0x74, 0xf8, 0x33, 0x03, 0x40, 0xf9, 0xf3, 0x01, 0xf0, 0xb7, 0x68, 0xfe, 0x6b, 0xd3, 0x69, 0xaa, 0x40, 0x92, 0x6a,
			0xaa, 0x6a, 0x93, 0x4a, 0x31, 0x55, 0x92, 0x09, 0x1d, 0x48, 0xb3, 0x28, 0x01, 0x0a, 0xaa, 0x69, 0x7e, 0x40, 0x92,
			0x7f, 0x02, 0x41, 0xf2, 0xea, 0x03, 0x9a, 0x9a, 0x08, 0x01, 0x89, 0x9a, 0x49, 0x01, 0x1b, 0x8b, 0x20, 0x01, 0x08,
			0x8b, 0x53, 0x01, 0xf8, 0xb6, 0x04, 0x00, 0x00, 0x14, 0x68, 0x3e, 0x40, 0x92, 0xe0, 0x7a, 0x68, 0xf8, 0xd3, 0x00,
			0xf8, 0xb6, 0x61, 0xca, 0x71, 0xd3, 0x63, 0xc2, 0x70, 0xd3, 0x62, 0xbe, 0x60, 0xd3, 0xe4, 0x03, 0x19, 0xaa, 0xb6,
			0x01, 0x00, 0x94, 0x68, 0xf6, 0x73, 0xd3, 0x20, 0x03, 0x00, 0xf9, 0x39, 0x4f, 0x28, 0x8b, 0xa8, 0xfc, 0xff, 0x35,
			0x94, 0x06, 0x00, 0x91, 0xe0, 0xff, 0xff, 0x17, 0xa1, 0x83, 0x02, 0xd1, 0xe0, 0x03, 0x16, 0xaa, 0x02, 0x01, 0x80,
			0x52, 0xc6, 0x01, 0x00, 0x94, 0x80, 0x28, 0x00, 0x34, 0xa1, 0xa3, 0x02, 0xd1, 0xe0, 0x03, 0x16, 0xaa, 0x02, 0x01,
			0x80, 0x52, 0xc1, 0x01, 0x00, 0x94, 0xe0, 0x27, 0x00, 0x34, 0xa1, 0xc3, 0x02, 0xd1, 0xe0, 0x03, 0x16, 0xaa, 0x02,
			0x01, 0x80, 0x52, 0xbc, 0x01, 0x00, 0x94, 0x40, 0x27, 0x00, 0x34, 0xb9, 0xf3, 0x75, 0xa9, 0xa8, 0x03, 0x55, 0xf8,
			0xa8, 0x83, 0x10, 0xf8, 0x48, 0x2b, 0x40, 0xf9, 0x00, 0x01, 0x3f, 0xd6, 0xbf, 0x03, 0x1a, 0xf8, 0x48, 0x2f, 0x40,
			0xf9, 0xa1, 0x83, 0x01, 0xd1, 0xa9, 0x43, 0x00, 0xd1, 0x20, 0x01, 0x10, 0xb8, 0x22, 0x00, 0xa0, 0x52, 0x23, 0x00,
			0x80, 0x52, 0x00, 0x01, 0x3f, 0xd6, 0x14, 0x00, 0x80, 0x52, 0x13, 0x00, 0x80, 0xd2, 0xb8, 0x03, 0x5a, 0xf8, 0x35,
			0x83, 0x00, 0x91, 0x37, 0x00, 0x80, 0x52, 0x28, 0x13, 0x40, 0xb9, 0x9f, 0x02, 0x08, 0x6b, 0x60, 0x0c, 0x00, 0x54,
			0xa8, 0x02, 0x40, 0xb9, 0x09, 0xfd, 0x9f, 0x52, 0xe9, 0xff, 0xaf, 0x72, 0x09, 0x01, 0x09, 0x0b, 0x3f, 0x2d, 0x00,
			0x71, 0xe9, 0x22, 0xc9, 0x1a, 0x2a, 0x10, 0x81, 0x52, 0x29, 0x01, 0x0a, 0x0a, 0x24, 0x99, 0x40, 0x7a, 0x04, 0x09,
			0x4c, 0x7a, 0x01, 0x01, 0x00, 0x54, 0xa8, 0x0a, 0x40, 0xb9, 0xa0, 0x02, 0x08, 0x8b, 0x48, 0x37, 0x40, 0xf9, 0x21,
			0x01, 0x80, 0x52, 0x00, 0x01, 0x3f, 0xd6, 0x00, 0x7b, 0x33, 0xf8, 0x73, 0x06, 0x00, 0x91, 0xa8, 0x06, 0x40, 0xb9,
			0xb5, 0x02, 0x08, 0x8b, 0x94, 0x06, 0x00, 0x11, 0xe8, 0xff, 0xff, 0x17, 0xa1, 0x83, 0x01, 0xd1, 0xe0, 0x03, 0x16,
			0xaa, 0x02, 0x01, 0x80, 0x52, 0x8c, 0x01, 0x00, 0x94, 0x40, 0x21, 0x00, 0x34, 0xa1, 0x83, 0x02, 0xd1, 0xe0, 0x03,
			0x16, 0xaa, 0x82, 0x00, 0x80, 0x52, 0x87, 0x01, 0x00, 0x94, 0xa0, 0x20, 0x00, 0x34, 0xa1, 0xa3, 0x02, 0xd1, 0xe0,
			0x03, 0x16, 0xaa, 0x82, 0x00, 0x80, 0x52, 0x82, 0x01, 0x00, 0x94, 0x00, 0x20, 0x00, 0x36, 0x48, 0x3f, 0x40, 0xf9,
			0xa0, 0x03, 0x5a, 0xf8, 0xa1, 0x03, 0x56, 0xb8, 0xa2, 0x83, 0x55, 0xb8, 0x00, 0x01, 0x3f, 0xd6, 0xe0, 0xe6, 0xff,
			0x34, 0xf9, 0x00, 0x00, 0x14, 0xa1, 0x83, 0x01, 0xd1, 0xe0, 0x03, 0x16, 0xaa, 0x02, 0x01, 0x80, 0x52, 0x76, 0x01,
			0x00, 0x94, 0x80, 0x1e, 0x00, 0x34, 0xa1, 0xc3, 0x02, 0xd1, 0xe0, 0x03, 0x16, 0xaa, 0x82, 0x00, 0x80, 0x52, 0x71,
			0x01, 0x00, 0x94, 0xe0, 0x1d, 0x00, 0x34, 0x13, 0x00, 0x80, 0x52, 0xb4, 0x03, 0x5a, 0xf8, 0xa8, 0x03, 0x55, 0xb8,
			0x7f, 0x02, 0x08, 0x6b, 0xe0, 0xe4, 0xff, 0x54, 0xbf, 0xff, 0x35, 0xa9, 0x88, 0x5a, 0x73, 0xf8, 0xa1, 0x83, 0x02,
			0xd1, 0xa2, 0xa3, 0x02, 0xd1, 0x77, 0x01, 0x00, 0x94, 0x73, 0x06, 0x00, 0x11, 0xf7, 0xff, 0xff, 0x17, 0xa1, 0x83,
			0x01, 0xd1, 0xe0, 0x03, 0x16, 0xaa, 0x02, 0x01, 0x80, 0x52, 0x60, 0x01, 0x00, 0x94, 0xc0, 0x1b, 0x00, 0x34, 0xa1,
			0xd3, 0x02, 0xd1, 0xe0, 0x03, 0x16, 0xaa, 0x82, 0x00, 0x80, 0x52, 0x5b, 0x01, 0x00, 0x94, 0x20, 0x1b, 0x00, 0x34,
			0xa1, 0x83, 0x02, 0xd1, 0xe0, 0x03, 0x16, 0xaa, 0x02, 0x01, 0x80, 0x52, 0x56, 0x01, 0x00, 0x94, 0x80, 0x1a, 0x00,
			0x34, 0x13, 0x00, 0x80, 0x52, 0xb4, 0x03, 0x5a, 0xf8, 0xa8, 0xc3, 0x54, 0xb8, 0x7f, 0x02, 0x08, 0x6b, 0x80, 0xe1,
			0xff, 0x54, 0xbf, 0x7f, 0x35, 0xa9, 0xa8, 0x03, 0x56, 0xf8, 0x89, 0x5a, 0x73, 0xb8, 0x08, 0x01, 0x09, 0x8b, 0xa1,
			0xa3, 0x02, 0xd1, 0xa2, 0xc3, 0x02, 0xd1, 0x5a, 0x01, 0x00, 0x94, 0x73, 0x06, 0x00, 0x11, 0xf5, 0xff, 0xff, 0x17,
			0x53, 0x01, 0x00, 0x94, 0x20, 0xe0, 0x07, 0x37, 0xc3, 0x00, 0x00, 0x14, 0x1a, 0x0f, 0x13, 0x8b, 0x88, 0xdf, 0x41,
			0x29, 0x95, 0x03, 0x08, 0x8b, 0x88, 0x17, 0x40, 0xb9, 0x1f, 0x0d, 0x00, 0x71, 0xc0, 0x12, 0x00, 0x54, 0x1f, 0x09,
			0x00, 0x71, 0xe0, 0x14, 0x00, 0x54, 0x1f, 0x05, 0x00, 0x71, 0x21, 0x02, 0x00, 0x54, 0x88, 0x0b, 0x40, 0xb9, 0x93,
			0x03, 0x08, 0x8b, 0xf4, 0x03, 0x1a, 0xaa, 0xb7, 0x01, 0x00, 0xb4, 0x69, 0x02, 0x40, 0xb9, 0x28, 0x1d, 0x00, 0x72,
			0xa0, 0x00, 0x00, 0x54, 0xa9, 0x26, 0x49, 0x8b, 0x34, 0x01, 0x00, 0x94, 0xe0, 0x43, 0xc1, 0xda, 0x02, 0x00, 0x00,
			0x14, 0x00, 0x00, 0x80, 0xd2, 0x80, 0x86, 0x00, 0xf8, 0x73, 0x12, 0x00, 0x91, 0xf7, 0x06, 0x00, 0xd1, 0xb7, 0xfe,
			0xff, 0xb5, 0x09, 0x00, 0x80, 0xd2, 0x88, 0x07, 0x40, 0xb9, 0x88, 0x03, 0x08, 0x8b, 0xa8, 0x03, 0x10, 0xf8, 0x0a,
			0x45, 0x40, 0xb8, 0xaa, 0x03, 0x12, 0xf8, 0xa8, 0x03, 0x11, 0xf8, 0xa8, 0x03, 0x52, 0xf8, 0x3f, 0x01, 0x08, 0xeb,
			0xc0, 0x0c, 0x00, 0x54, 0xa9, 0x83, 0x12, 0xf8, 0xa8, 0x03, 0x51, 0xf8, 0x08, 0x79, 0x69, 0xb8, 0xc8, 0x0b, 0x00,
			0x34, 0x15, 0x00, 0x80, 0xd2, 0xa9, 0x03, 0x50, 0xf8, 0x3b, 0x01, 0x08, 0x8b, 0x68, 0x0f, 0x40, 0x79, 0x6a, 0x2b,
			0x40, 0x79, 0x69, 0x5b, 0x00, 0x91, 0xa9, 0xab, 0x33, 0xa9, 0x09, 0x79, 0x1d, 0x12, 0xa9, 0x43, 0x13, 0xb8, 0x1f,
			0x31, 0x00, 0x71, 0xe9, 0xff, 0x9f, 0x52, 0x0a, 0xe0, 0xbf, 0x12, 0x54, 0x01, 0x89, 0x9a, 0x1f, 0x05, 0x00, 0x71,
			0xaa, 0x83, 0x50, 0xf8, 0x49, 0x01, 0x9f, 0x9a, 0x3c, 0x03, 0x09, 0xcb, 0x1f, 0x19, 0x00, 0x71, 0xe8, 0x03, 0x8a,
			0x9a, 0x37, 0x03, 0x08, 0xcb, 0xa8, 0x03, 0x54, 0xf8, 0xbf, 0x02, 0x08, 0xeb, 0xe0, 0x08, 0x00, 0x54, 0xa8, 0x83,
			0x53, 0xf8, 0x08, 0x79, 0x75, 0x78, 0xe9, 0xff, 0x9f, 0x52, 0x1f, 0x01, 0x09, 0xeb, 0x00, 0x08, 0x00, 0x54, 0x69,
			0x07, 0x40, 0xf9, 0x29, 0x03, 0x09, 0x8b, 0x6a, 0x0b, 0x40, 0x79, 0xa9, 0x26, 0x0a, 0x9b, 0x38, 0x01, 0x08, 0x8b,
			0xa8, 0x43, 0x53, 0xb8, 0x1f, 0x09, 0x00, 0x71, 0x41, 0x02, 0x00, 0x54, 0x08, 0x03, 0x40, 0xf9, 0xe8, 0x00, 0xf8,
			0xb7, 0x09, 0xad, 0x6c, 0xd3, 0x29, 0x1d, 0x48, 0x92, 0x0a, 0x8d, 0x40, 0x92, 0xea, 0x02, 0x0a, 0x8b, 0x49, 0x01,
			0x09, 0x8b, 0x05, 0x00, 0x00, 0x14, 0x09, 0x5d, 0x40, 0x92, 0x49, 0x7b, 0x69, 0xf8, 0x0a, 0xfd, 0x58, 0xd3, 0x29,
			0x01, 0x2a, 0x8b, 0x09, 0x03, 0x00, 0xf9, 0x08, 0xf9, 0x73, 0xd3, 0x18, 0x0b, 0x08, 0x8b, 0x28, 0xfe, 0xff, 0xb5,
			0x27, 0x00, 0x00, 0x14, 0x13, 0x03, 0x40, 0xf9, 0x70, 0xfe, 0x7e, 0xd3, 0x62, 0xbe, 0x60, 0xd3, 0x63, 0xc2, 0x70,
			0xd3, 0
"""


```
Response:
Let's break down the thought process for analyzing this Frida agent code and answering the user's request.

**1. Understanding the Core Request:**

The user wants to understand the functionality of the `itracer_agent.js` file, specifically how it uses Frida for dynamic instrumentation. They're interested in low-level details, interactions with the Linux kernel, and how to replicate the functionality with LLDB. They also want to understand common usage errors and how users might reach this point.

**2. Initial Code Scan and Keyword Identification (Mental or Actual):**

Quickly scan the `agent.ts`, `events.ts`, and `backend.ts` files for important keywords and patterns. I'd be looking for:

* **Core Frida Concepts:** `rpc.exports`, `send()`, `Device.spawn()`, `Session.attach()`, `Script.load()`, `Module.getExportByName()`, `Process.enumerateModules()`, `Process.enumerateThreads()`.
* **Instrumentation-Related Terms:**  `TraceBuffer`, `TraceBufferReader`, `TraceSession`, `Stalker`, `CpuContext`, `transform`, `callout`, `block`, `instruction`, `register`.
* **Data Handling:** `JSON`, `buffer`, `read`, `write`, `payload`.
* **Error Handling:** `Error`, `console.error`, `panic`.
* **Platform-Specific Details (though less evident in the JS):** Hints of architecture (ARM64 in `backend.ts`), mentions of modules, threads.

**3. Dissecting `agent.ts` (The Main Logic):**

* **Class `Agent`:** This is the core of the agent. It manages the trace session and buffer.
* **`constructor`:** Initializes the agent, setting up the `TraceSession` and `TraceBuffer`. The `drainTimer` hints at periodically processing the collected data.
* **`createBuffer` and `openBuffer`:** These methods manage the underlying `TraceBuffer`.
* **`launchBufferReader` and `stopBufferReader`:** These control the reading of data from the buffer and sending it back to the Frida host. The `setInterval` is key for periodic data transfer.
* **`launchTraceSession`:** This is where the tracing magic happens. It takes a "strategy" (likely defining what to trace), creates a `TraceSession`, and sets up event listeners (`start`, `end`, `compile`, `panic`). The logic within the `rawStrategy` processing is important for understanding how tracing targets (threads, ranges) are specified.
* **`queryProgramName` and `listThreads`:** These provide basic system information.
* **`rpc.exports`:**  Crucially, this makes the agent's methods accessible from the Frida host.

**4. Dissecting `events.ts` (Standard EventEmitter):**

Recognize this as a standard implementation of an EventEmitter. While important for the internal workings of the `TraceSession`, its specific details aren't as critical for understanding the core *tracing* functionality at a high level. Focus on the fact that it's used for asynchronous communication of events.

**5. Dissecting `backend.ts` (Native Code Stub):**

This file is a stub for native code. Note that it contains `#include` directives and defines structs and enums. This immediately tells you that the core tracing logic is likely implemented in native code for performance reasons. Recognize the mentions of `GumStalker`, `GumCpuContext`, and registers (ARM64). This confirms interaction with the Frida Stalker API, which is responsible for code rewriting.

**6. Connecting the Dots:**

* **User Interaction:** The user interacts with the agent through the exported methods exposed via `rpc.exports`. They would likely use a Frida script to call these methods (e.g., `agent.createBuffer()`, `agent.launchTraceSession(strategy)`, `agent.stopBufferReader()`).
* **Tracing Workflow:** The user defines a tracing strategy, the agent creates a buffer and session, Stalker (in the native code) intercepts and rewrites code, and the agent periodically reads the collected trace data from the buffer and sends it back.
* **Low-Level Aspects:** The `backend.ts` file highlights the use of Frida's Stalker API, allowing for instruction-level tracing and access to CPU registers. The ARM64 specifics confirm this is for a 64-bit ARM architecture.
* **Error Handling:** The `panic` event and `console.error` show basic error reporting mechanisms.

**7. Addressing Specific User Questions:**

* **Functionality Summary:** Synthesize the key functionalities based on the analysis.
* **Binary/Kernel/Linux:** Explain how Stalker interacts with the process's memory and the kernel (through system calls made by Frida). Use examples from `backend.ts` (register access, `GumStalker`).
* **LLDB Replication:**  Focus on the *effects* of the agent's actions rather than a direct line-by-line replication (which is usually impossible). Emphasize setting breakpoints, examining memory, and using watchpoints to observe the same data the agent is capturing.
* **Logic and Assumptions:** If any part of the code makes assumptions or has specific logic (like the strategy parsing), illustrate with input/output examples.
* **User Errors:** Think about common mistakes when using dynamic instrumentation: incorrect addresses, invalid thread IDs, not starting/stopping the agent correctly.
* **User Steps to Reach This Point:** Outline a typical Frida workflow that would involve loading and interacting with this agent.

**8. Structuring the Output:**

Organize the findings logically, addressing each part of the user's request. Use clear headings and bullet points for readability.

**Self-Correction/Refinement during the Process:**

* **Initial thought:** "Is `events.ts` really important to detail?" -> "Yes, it explains how the agent communicates internally, but a high-level explanation of its role as an event emitter is sufficient."
* **Initial thought:** "Can I replicate the Stalker logic directly in LLDB?" -> "No, Stalker is a Frida-specific code rewriting engine. Focus on the observable effects (memory changes, register values)."
* **Ensure clear distinction between the JavaScript agent and the native backend.**  It's important to explain that the JS controls the session and data flow, but the heavy lifting of instrumentation is in the native code.

By following these steps, combining code analysis with an understanding of Frida's core concepts, and focusing on addressing the user's specific questions, a comprehensive and helpful answer can be constructed.## Frida ITracer Agent åŠŸèƒ½å½’çº³ (ç¬¬ 1éƒ¨åˆ†)

è¿™ä¸ªFrida Agentï¼ˆä½äº `frida/build/subprojects/frida-tools/agents/itracer/itracer_agent.js`ï¼‰çš„ä¸»è¦åŠŸèƒ½æ˜¯ **å¯¹ç›®æ ‡è¿›ç¨‹è¿›è¡ŒæŒ‡ä»¤çº§åˆ«çš„è¿½è¸ª (Instruction Tracing)**ã€‚  å®ƒé€šè¿‡ Frida çš„åŠ¨æ€æ’æ¡©æŠ€æœ¯ï¼Œåœ¨ç›®æ ‡è¿›ç¨‹æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œè®°å½•æ¯ä¸ªæ‰§è¡Œåˆ°çš„æŒ‡ä»¤ä»¥åŠç›¸å…³çš„ä¸Šä¸‹æ–‡ä¿¡æ¯ã€‚

**å…·ä½“åŠŸèƒ½ç‚¹ï¼š**

1. **æŒ‡ä»¤çº§è¿½è¸ª:**  è¿™æ˜¯å…¶æ ¸å¿ƒåŠŸèƒ½ã€‚Agent ä¼šæ‹¦æˆªç›®æ ‡è¿›ç¨‹æ‰§è¡Œçš„æ¯ä¸€æ¡æŒ‡ä»¤ã€‚
2. **è®°å½•æŒ‡ä»¤æ‰§è¡Œä¸Šä¸‹æ–‡:**  é™¤äº†æŒ‡ä»¤æœ¬èº«ï¼ŒAgent è¿˜ä¼šæ•è·æŒ‡ä»¤æ‰§è¡Œæ—¶çš„ç›¸å…³ä¿¡æ¯ï¼Œä¾‹å¦‚ï¼š
    * **å¯„å­˜å™¨å€¼:**  è®°å½•æŒ‡å®š CPU å¯„å­˜å™¨çš„å€¼ï¼ŒåŒ…æ‹¬é€šç”¨å¯„å­˜å™¨ (å¦‚ X0-X28, SP, FP, LR)ã€çŠ¶æ€å¯„å­˜å™¨ (NZCV) ä»¥åŠ SIMD å¯„å­˜å™¨ (Q0-Q31)ã€‚
    * **å†…å­˜è®¿é—®:**  è®°å½•æŒ‡ä»¤å¯¹å†…å­˜çš„è¯»å†™æ“ä½œï¼ŒåŒ…æ‹¬å†…å­˜åœ°å€ã€‚
    * **ä»£ç ä½ç½®:**  è®°å½•æŒ‡ä»¤æ‰€åœ¨çš„å†…å­˜åœ°å€ï¼Œä»¥åŠæ‰€å±çš„æ¨¡å—å’Œåç§»ã€‚
3. **å¯é…ç½®çš„è¿½è¸ªç­–ç•¥:**  Agent å…è®¸ç”¨æˆ·é…ç½®è¿½è¸ªçš„èŒƒå›´å’Œç›®æ ‡ï¼š
    * **çº¿ç¨‹è¿½è¸ª:** å¯ä»¥æŒ‡å®šè¿½è¸ªç‰¹å®šçš„çº¿ç¨‹ ID æˆ–çº¿ç¨‹ç´¢å¼•ã€‚
    * **åœ°å€èŒƒå›´è¿½è¸ª:** å¯ä»¥æŒ‡å®šè¿½è¸ªç‰¹å®šçš„å†…å­˜åœ°å€èŒƒå›´ã€‚
4. **æ•°æ®ç¼“å†²å’Œä¼ è¾“:**  Agent ä½¿ç”¨ `TraceBuffer` æ¥é«˜æ•ˆåœ°å­˜å‚¨è¿½è¸ªåˆ°çš„æŒ‡ä»¤æ•°æ®ã€‚å¹¶å®šæœŸå°†è¿™äº›æ•°æ®é€šè¿‡ Frida çš„ `send()` å‡½æ•°å‘é€å› Frida ä¸»æœºã€‚
5. **ç¼–è¯‘åä»£ç ä¿¡æ¯:**  Agent è¿˜ä¼šè®°å½• Frida Stalker åŠ¨æ€ç¼–è¯‘ç”Ÿæˆçš„ä»£ç å—çš„åœ°å€å’Œå¤§å°ã€‚
6. **æ¨¡å—ä¿¡æ¯:**  Agent ä¼šè®°å½•æ‰§è¡ŒæŒ‡ä»¤æ‰€å±çš„æ¨¡å—è·¯å¾„å’ŒåŸºåœ°å€ã€‚
7. **äº‹ä»¶é€šçŸ¥:** Agent ä¼šåœ¨è¿½è¸ªå¼€å§‹ã€ç»“æŸã€ç¼–è¯‘ä»£ç å—ä»¥åŠå‘ç”Ÿé”™è¯¯æ—¶å‘é€äº‹ä»¶é€šçŸ¥ç»™ Frida ä¸»æœºã€‚
8. **é”™è¯¯å¤„ç†:**  Agent åŒ…å«åŸºç¡€çš„é”™è¯¯å¤„ç†æœºåˆ¶ï¼Œä¾‹å¦‚å½“é‡åˆ°æ— æ•ˆçš„å†…å­˜åœ°å€æˆ–æœªå¤„ç†çš„å¯„å­˜å™¨æ—¶ä¼šæŠ›å‡ºé”™è¯¯ã€‚

**æ¶‰åŠåˆ°äºŒè¿›åˆ¶åº•å±‚ï¼ŒLinuxå†…æ ¸çš„ä¸¾ä¾‹è¯´æ˜ï¼š**

* **äºŒè¿›åˆ¶åº•å±‚ (Binary Low-Level):**
    * **å¯„å­˜å™¨æ“ä½œ:**  ä»£ç ä¸­å¤§é‡æ¶‰åŠåˆ° ARM64 å¯„å­˜å™¨ (ä¾‹å¦‚ `ARM64_REG_X0`, `ARM64_REG_SP`, `ARM64_REG_NZCV`) çš„æ“ä½œï¼Œä»¥åŠå¦‚ä½•è¯»å–å’Œå­˜å‚¨è¿™äº›å¯„å­˜å™¨çš„å€¼ã€‚è¿™ç›´æ¥å…³è”åˆ°ç›®æ ‡è¿›ç¨‹çš„ CPU æ¶æ„å’ŒæŒ‡ä»¤é›†ã€‚ä¾‹å¦‚ï¼Œ`gum_arm64_writer_put_str_reg_reg_offset (cw, reg, session_reg, G_STRUCT_OFFSET (ITraceSession, scratch_regs) + SCRATCH_REG_OFFSET (reg));`  è¿™è¡Œä»£ç åœ¨åŠ¨æ€ç¼–è¯‘çš„ä»£ç ä¸­æ’å…¥æŒ‡ä»¤ï¼Œå°†å¯„å­˜å™¨ `reg` çš„å€¼å­˜å‚¨åˆ° `session` ç»“æ„ä½“çš„ `scratch_regs` æ•°ç»„çš„ç‰¹å®šåç§»å¤„ã€‚
    * **å†…å­˜åœ°å€:**  ä»£ç ä¸­é¢‘ç¹å‡ºç°å†…å­˜åœ°å€çš„å¤„ç†ï¼Œä¾‹å¦‚ `insn->address` è¡¨ç¤ºæŒ‡ä»¤çš„å†…å­˜åœ°å€ï¼Œä»¥åŠå¦‚ä½•ä»å†…å­˜ä¸­è¯»å–æ•°æ® (`e.readVolatile(1)`)ã€‚
    * **æŒ‡ä»¤ç»„ (Instruction Groups):** ä½¿ç”¨ `cs_insn_group (capstone, insn, CS_GRP_JUMP)` å’Œ `cs_insn_group (capstone, insn, CS_GRP_RET)` æ¥åˆ¤æ–­æŒ‡ä»¤æ˜¯å¦ä¸ºè·³è½¬æˆ–è¿”å›æŒ‡ä»¤ï¼Œè¿™éœ€è¦ç†è§£ ARM64 æŒ‡ä»¤é›†çš„åˆ†ç±»ã€‚

* **Linuxå†…æ ¸:**
    * **è¿›ç¨‹å’Œçº¿ç¨‹:**  Agent ä½¿ç”¨ `Process.enumerateThreads()` æ¥è·å–ç›®æ ‡è¿›ç¨‹çš„çº¿ç¨‹ä¿¡æ¯ï¼Œè¿™ä¾èµ–äº Frida ä¸ Linux å†…æ ¸çš„äº¤äº’ï¼Œé€šè¿‡ç³»ç»Ÿè°ƒç”¨è·å–è¿›ç¨‹çš„çº¿ç¨‹åˆ—è¡¨ã€‚
    * **æ¨¡å—åŠ è½½:**  `Process.enumerateModules()` ç”¨äºè·å–ç›®æ ‡è¿›ç¨‹åŠ è½½çš„æ¨¡å—ä¿¡æ¯ï¼ŒåŒæ ·éœ€è¦ Frida ä¸å†…æ ¸äº¤äº’ï¼Œè¯»å–è¿›ç¨‹çš„å†…å­˜æ˜ å°„ä¿¡æ¯ã€‚
    * **å†…å­˜ç®¡ç†:**  è™½ç„¶ä»£ç æœ¬èº«æ²¡æœ‰ç›´æ¥çš„å†…æ ¸è°ƒç”¨ï¼Œä½† Frida çš„æ’æ¡©æœºåˆ¶ (`GumStalker`)  éœ€è¦åœ¨å†…æ ¸å±‚é¢ä¿®æ”¹ç›®æ ‡è¿›ç¨‹çš„å†…å­˜å’Œæ‰§è¡Œæµç¨‹ã€‚

**å‡è®¾è¾“å…¥ä¸è¾“å‡º (é’ˆå¯¹ `parseTraceStrategy` å‡½æ•°éšå«çš„é€»è¾‘æ¨ç†):**

è™½ç„¶ `parseTraceStrategy` å‡½æ•°åœ¨æä¾›çš„ä»£ç ç‰‡æ®µä¸­æ²¡æœ‰ç›´æ¥å®ç°ï¼Œä½†æˆ‘ä»¬å¯ä»¥æ ¹æ® `launchTraceSession` å‡½æ•°ä¸­å¯¹ `strategy` çš„å¤„ç†è¿›è¡Œæ¨æ–­ã€‚

**å‡è®¾è¾“å…¥ (strategy):**

```javascript
{
  "type": "thread",
  "params": {
    "type": "id",
    "value": 12345
  }
}
```

æˆ–è€…

```javascript
{
  "type": "range",
  "params": [
    "0x7fffffffd000",
    "0x7ffffffff000"
  ]
}
```

**æ¨æ–­è¾“å‡º (ç»è¿‡ `parseTraceStrategy` å¤„ç†å `TraceSession` æ„é€ å‡½æ•°çš„å‚æ•°):**

å¯¹äºçº¿ç¨‹ ID çš„è¾“å…¥ï¼š

```javascript
{
  "type": "thread",
  "threadId": 12345
}
```

å¯¹äºåœ°å€èŒƒå›´çš„è¾“å…¥ï¼š

```javascript
{
  "type": "range",
  "start": <Frida.NativePointer to 0x7fffffffd000>,
  "end": <Frida.NativePointer to 0x7ffffffff000>
}
```

**ç”¨æˆ·æˆ–ç¼–ç¨‹å¸¸è§çš„ä½¿ç”¨é”™è¯¯ä¸¾ä¾‹è¯´æ˜:**

1. **æ— æ•ˆçš„å†…å­˜åœ°å€:**  å¦‚æœç”¨æˆ·åœ¨é…ç½®è¿½è¸ªèŒƒå›´æ—¶æä¾›äº†æ— æ•ˆçš„å†…å­˜åœ°å€ï¼ˆä¾‹å¦‚ï¼Œæœªæ˜ å°„çš„åœ°å€ï¼‰ï¼ŒAgent å¯èƒ½ä¼šåœ¨å°è¯•è¯»å–è¯¥åœ°å€æ—¶æŠ›å‡ºé”™è¯¯ï¼Œä¾‹å¦‚ `Error: invalid address: ...`ã€‚ è¿™æ˜¯å› ä¸º `parseCodeLocation` å‡½æ•°ä¼šå°è¯•è¯»å–æä¾›çš„åœ°å€ï¼Œå¦‚æœè¯»å–å¤±è´¥åˆ™ä¼šæŠ›å‡ºå¼‚å¸¸ã€‚
2. **æ— æ•ˆçš„çº¿ç¨‹ ID:**  å¦‚æœç”¨æˆ·æŒ‡å®šè¿½è¸ªçš„çº¿ç¨‹ ID åœ¨ç›®æ ‡è¿›ç¨‹ä¸­ä¸å­˜åœ¨ï¼ŒAgent å¯èƒ½ä¼šåœ¨å°è¯•å¯åŠ¨è¿½è¸ªæ—¶æŠ¥é”™ï¼Œä¾‹å¦‚ `Error("invalid thread ID")`ã€‚
3. **æœªæ­£ç¡®å¯åŠ¨/åœæ­¢è¿½è¸ª:**  ç”¨æˆ·å¯èƒ½å¿˜è®°è°ƒç”¨ `launchTraceSession` å¯åŠ¨è¿½è¸ªï¼Œæˆ–è€…åœ¨è¿½è¸ªç»“æŸåå¿˜è®°è°ƒç”¨ `stopBufferReader` æ¸…ç†èµ„æºï¼Œè¿™å¯èƒ½å¯¼è‡´æ•°æ®ä¸¢å¤±æˆ–èµ„æºæ³„æ¼ã€‚
4. **è¿½è¸ªèŒƒå›´è¿‡å¤§:**  å¦‚æœç”¨æˆ·è¿½è¸ªçš„åœ°å€èŒƒå›´è¿‡å¤§æˆ–è¿½è¸ªçš„çº¿ç¨‹æ•°è¿‡å¤šï¼Œå¯èƒ½ä¼šäº§ç”Ÿå¤§é‡çš„è¿½è¸ªæ•°æ®ï¼Œå¯¼è‡´æ€§èƒ½é—®é¢˜æˆ–è€… `TraceBuffer` æº¢å‡ºã€‚ è¿™ä¼šå¯¼è‡´ `send({type:"itrace:lost",payload:{lost:r}})` äº‹ä»¶è¢«è§¦å‘ï¼Œæç¤ºæ•°æ®ä¸¢å¤±ã€‚
5. **å°è¯•åœ¨ä¸æ”¯æŒçš„æ¶æ„ä¸Šè¿è¡Œ:** è¯¥ Agent ä»£ç ä¸­å¤§é‡ä½¿ç”¨äº† ARM64 ç›¸å…³çš„å®šä¹‰ï¼Œå¦‚æœåœ¨é ARM64 æ¶æ„çš„è¿›ç¨‹ä¸Šè¿è¡Œï¼Œå°†ä¼šå‡ºç°é”™è¯¯ã€‚

**ç”¨æˆ·æ“ä½œæ˜¯å¦‚ä½•ä¸€æ­¥æ­¥çš„åˆ°è¾¾è¿™é‡Œï¼Œä½œä¸ºè°ƒè¯•çº¿ç´¢:**

1. **ç¼–å†™ Frida è„šæœ¬:** ç”¨æˆ·é¦–å…ˆéœ€è¦ç¼–å†™ä¸€ä¸ª Frida è„šæœ¬ï¼Œç”¨äºåŠ è½½å’Œè°ƒç”¨è¯¥ Agentã€‚
2. **è¿æ¥åˆ°ç›®æ ‡è¿›ç¨‹:** ä½¿ç”¨ Frida çš„ API (ä¾‹å¦‚ `frida.attach()` æˆ– `frida.spawn()`) è¿æ¥åˆ°ç›®æ ‡è¿›ç¨‹ã€‚
3. **åŠ è½½ Agent ä»£ç :** åœ¨ Frida è„šæœ¬ä¸­ä½¿ç”¨ `script.load()` åŠ è½½ `itracer_agent.js` æ–‡ä»¶ã€‚
4. **è°ƒç”¨ Agent çš„å¯¼å‡ºæ–¹æ³•:** é€šè¿‡ `script.get_exports()` è·å– Agent å¯¼å‡ºçš„æ–¹æ³• (ä¾‹å¦‚ `createBuffer`, `launchTraceSession`)ã€‚
5. **é…ç½®è¿½è¸ªç­–ç•¥:**  ç”¨æˆ·éœ€è¦æ ¹æ®éœ€è¦é…ç½®è¿½è¸ªç­–ç•¥ï¼Œä¾‹å¦‚æŒ‡å®šè¿½è¸ªçš„çº¿ç¨‹ ID æˆ–å†…å­˜èŒƒå›´ã€‚
6. **å¯åŠ¨è¿½è¸ª:** è°ƒç”¨ `launchTraceSession` æ–¹æ³•ï¼Œå¹¶å°†é…ç½®å¥½çš„ç­–ç•¥ä½œä¸ºå‚æ•°ä¼ é€’è¿›å»ã€‚
7. **ç›®æ ‡è¿›ç¨‹æ‰§è¡Œ:**  ç›®æ ‡è¿›ç¨‹å¼€å§‹æ‰§è¡Œï¼ŒFrida Agent å¼€å§‹è¿›è¡ŒæŒ‡ä»¤çº§åˆ«çš„è¿½è¸ªã€‚
8. **æ¥æ”¶è¿½è¸ªæ•°æ®:**  Frida ä¸»æœºé€šè¿‡ `script.on('message', ...)` æ¥æ”¶ Agent å‘é€çš„è¿½è¸ªæ•°æ®ã€‚
9. **åœæ­¢è¿½è¸ª:**  åœ¨éœ€è¦åœæ­¢è¿½è¸ªæ—¶ï¼Œè°ƒç”¨ `stopBufferReader` æ–¹æ³•ã€‚

**æ€»ç»“å®ƒçš„åŠŸèƒ½:**

`itracer_agent.js` æ˜¯ä¸€ä¸ª Frida Agentï¼Œå…¶æ ¸å¿ƒåŠŸèƒ½æ˜¯å¯¹ç›®æ ‡è¿›ç¨‹è¿›è¡Œç»†ç²’åº¦çš„æŒ‡ä»¤çº§è¿½è¸ªã€‚å®ƒå…è®¸ç”¨æˆ·é…ç½®è¿½è¸ªç›®æ ‡ï¼ˆçº¿ç¨‹æˆ–åœ°å€èŒƒå›´ï¼‰ï¼Œè®°å½•æŒ‡ä»¤æ‰§è¡Œæ—¶çš„å¯„å­˜å™¨å€¼ã€å†…å­˜è®¿é—®å’Œä»£ç ä½ç½®ç­‰ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œå¹¶å°†è¿™äº›æ•°æ®å‘é€å› Frida ä¸»æœºè¿›è¡Œåˆ†æã€‚ è¯¥ Agent ä¾èµ– Frida çš„åŠ¨æ€æ’æ¡©æŠ€æœ¯å’Œ Stalker API æ¥å®ç°æŒ‡ä»¤çº§åˆ«çš„æ‹¦æˆªå’Œæ•°æ®é‡‡é›†ã€‚

### æç¤ºè¯
```
è¿™æ˜¯ç›®å½•ä¸ºfrida/build/subprojects/frida-tools/agents/itracer/itracer_agent.jsçš„frida Dynamic instrumentation toolçš„æºä»£ç æ–‡ä»¶ï¼Œ è¯·åˆ—ä¸¾ä¸€ä¸‹å®ƒçš„åŠŸèƒ½, 
å¦‚æœæ¶‰åŠåˆ°äºŒè¿›åˆ¶åº•å±‚ï¼Œlinuxå†…æ ¸ï¼Œè¯·åšå‡ºå¯¹åº”çš„ä¸¾ä¾‹è¯´æ˜ï¼Œ
è¯·ç»™å‡ºç”¨lldbæŒ‡ä»¤æˆ–è€…lldb pythonè„šæœ¬ï¼Œç”¨æ¥å¤åˆ»çš„æºä»£ç æ‰€å®ç°è°ƒè¯•åŠŸèƒ½çš„ç¤ºä¾‹ï¼Œå¦‚æœæºä»£ç æ˜¯è°ƒè¯•åŠŸèƒ½çš„å®ç°ã€‚
å¦‚æœåšäº†é€»è¾‘æ¨ç†ï¼Œè¯·ç»™å‡ºå‡è®¾è¾“å…¥ä¸è¾“å‡º,
å¦‚æœæ¶‰åŠç”¨æˆ·æˆ–è€…ç¼–ç¨‹å¸¸è§çš„ä½¿ç”¨é”™è¯¯ï¼Œè¯·ä¸¾ä¾‹è¯´æ˜,
è¯´æ˜ç”¨æˆ·æ“ä½œæ˜¯å¦‚ä½•ä¸€æ­¥æ­¥çš„åˆ°è¾¾è¿™é‡Œï¼Œä½œä¸ºè°ƒè¯•çº¿ç´¢ï¼Œ
è¯·ç”¨ä¸­æ–‡å›å¤ã€‚
è¿™æ˜¯ç¬¬1éƒ¨åˆ†ï¼Œå…±2éƒ¨åˆ†ï¼Œè¯·å½’çº³ä¸€ä¸‹å®ƒçš„åŠŸèƒ½
```

### æºä»£ç 
```javascript
ğŸ“¦
3311 /agent.js.map
2392 /agent.js
8095 /node_modules/@frida/events/events.js.map
5739 /node_modules/@frida/events/events.js
â†» events
217 /node_modules/frida-itrace/dist/backend.js.map
20955 /node_modules/frida-itrace/dist/backend.js
9287 /node_modules/frida-itrace/dist/index.js.map
5740 /node_modules/frida-itrace/dist/index.js
â†» frida-itrace
âœ„
{"version":3,"file":"agent.js","names":["TraceBuffer","TraceBufferReader","TraceSession","parseCodeLocation","location","NULL","kind","params","address","ptr","readVolatile","e","Error","Module","getExportByName","getBaseAddress","add","name","DebugSymbol","fromName","isNull","agent","constructor","this","session","buffer","reader","drainTimer","_Agent_drainBuffer","set","chunk","read","byteLength","send","type","lost","payload","createBuffer","create","openBuffer","open","launchBufferReader","setInterval","__classPrivateFieldGet","stopBufferReader","clearInterval","call","launchTraceSession","rawStrategy","strategy","thread","threads","Process","enumerateThreads","desiredId","th","find","t","id","undefined","threadId","start","end","parseTraceStrategy","events","on","regSpecs","regValues","block","message","console","error","queryProgramName","enumerateModules","listThreads","agentMethodNames","Object","getOwnPropertyNames","getPrototypeOf","filter","rpc","exports","bind"],"sourceRoot":"/root/frida/build/subprojects/frida-tools/agents/itracer/itracer_agent.js.p/","sources":["agent.ts"],"mappings":"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"}
âœ„
var e,r=this&&this.__classPrivateFieldGet||function(e,r,t,s){if("a"===t&&!s)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof r?e!==r||!s:!r.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===t?s:"a"===t?s.call(e):s?s.value:r.get(e)};import{TraceBuffer as t,TraceBufferReader as s,TraceSession as n}from"frida-itrace";function a(e){if(null===e)return NULL;const[r,t]=e;switch(r){case"address":{const e=ptr(t);try{e.readVolatile(1)}catch(r){throw new Error(`invalid address: ${e}`)}return e}case"module-export":return Module.getExportByName(t[0],t[1]);case"module-offset":return Module.getBaseAddress(t[0]).add(t[1]);case"symbol":{const e=t,{address:r}=DebugSymbol.fromName(e);return r.isNull()?Module.getExportByName(null,e):r}}}e=new WeakMap;const o=new class{constructor(){this.session=null,this.buffer=null,this.reader=null,this.drainTimer=null,e.set(this,(()=>{const e=this.reader.read();if(0===e.byteLength)return;send({type:"itrace:chunk"},e);const r=this.reader.lost;0!==r&&send({type:"itrace:lost",payload:{lost:r}})}))}createBuffer(){return this.buffer=t.create(),this.buffer.location}openBuffer(e){this.buffer=t.open(e)}launchBufferReader(){this.reader=new s(this.buffer),this.drainTimer=setInterval(r(this,e,"f"),10)}stopBufferReader(){clearInterval(this.drainTimer),this.drainTimer=null,r(this,e,"f").call(this),this.reader=null}launchTraceSession(e){const r=function(e){const[r,t]=e;switch(r){case"thread":{let e;const r=Process.enumerateThreads();switch(t[0]){case"id":{const s=t[1],n=r.find((e=>e.id===s));if(void 0===n)throw new Error("invalid thread ID");e=n;break}case"index":if(e=r[t[1]],void 0===e)throw new Error("invalid thread index")}return{type:"thread",threadId:e.id}}case"range":return{type:"range",start:a(t[0]),end:a(t[1])}}}(e),t=new n(r,this.buffer);this.session=t,t.events.on("start",((e,r)=>{send({type:"itrace:start",payload:e},r)})),t.events.on("end",(()=>{send({type:"itrace:end"})})),t.events.on("compile",(e=>{send({type:"itrace:compile",payload:e})})),t.events.on("panic",(e=>{console.error(e)})),t.open()}queryProgramName(){return Process.enumerateModules()[0].name}listThreads(){return Process.enumerateThreads()}},i=Object.getOwnPropertyNames(Object.getPrototypeOf(o)).filter((e=>"constructor"!==e));for(const e of i)rpc.exports[e]=o[e].bind(o);
âœ„
{"version":3,"file":"events.js","names":["EventEmitter","once","init","call","this","prototype","_events","undefined","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","TypeError","_getMaxListeners","that","_addListener","target","type","prepend","existing","events","Object","create","newListener","emit","unshift","push","m","length","warned","w","Error","String","name","emitter","count","warning","console","warn","onceWrapper","fired","removeListener","wrapFn","arguments","apply","_onceWrap","state","wrapped","bind","_listeners","unwrap","evlistener","arr","ret","Array","i","unwrapListeners","arrayClone","listenerCount","n","copy","Promise","resolve","reject","errorListener","err","resolver","slice","eventTargetAgnosticAddListener","handler","flags","on","addErrorHandlerIfEventEmitter","addEventListener","wrapListener","arg","removeEventListener","defineProperty","enumerable","get","set","Number","isNaN","RangeError","getPrototypeOf","setMaxListeners","getMaxListeners","args","doError","error","er","message","context","Reflect","len","listeners","addListener","prependListener","prependOnceListener","list","originalListener","position","shift","index","pop","spliceOne","off","removeAllListeners","keys","key","rawListeners","eventNames","ownKeys"],"sourceRoot":"/root/frida/build/subprojects/frida-tools/agents/itracer/itracer_agent.js.p/node_modules/@frida/events/","sources":[""],"mappings":"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"}
âœ„
export default e;export{e as EventEmitter,l as once};function e(){e.init.call(this)}e.EventEmitter=e,e.prototype._events=void 0,e.prototype._eventsCount=0,e.prototype._maxListeners=void 0;let t=10;function n(e){if("function"!=typeof e)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof e)}function r(t){return void 0===t._maxListeners?e.defaultMaxListeners:t._maxListeners}function i(e,t,i,o){let s;n(i);let u=e._events;if(void 0===u?(u=e._events=Object.create(null),e._eventsCount=0):(void 0!==u.newListener&&(e.emit("newListener",t,i.listener?i.listener:i),u=e._events),s=u[t]),void 0===s)s=u[t]=i,++e._eventsCount;else{"function"==typeof s?s=u[t]=o?[i,s]:[s,i]:o?s.unshift(i):s.push(i);const n=r(e);if(n>0&&s.length>n&&!s.warned){s.warned=!0;const n=new Error("Possible EventEmitter memory leak detected. "+s.length+" "+String(t)+" listeners added. Use emitter.setMaxListeners() to increase limit");n.name="MaxListenersExceededWarning",n.emitter=e,n.type=t,n.count=s.length,f=n,console.warn(f)}}var f;return e}function o(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,0===arguments.length?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function s(e,t,n){const r={fired:!1,wrapFn:void 0,target:e,type:t,listener:n},i=o.bind(r);return i.listener=n,r.wrapFn=i,i}function u(e,t,n){const r=e._events;if(void 0===r)return[];const i=r[t];return void 0===i?[]:"function"==typeof i?n?[i.listener||i]:[i]:n?function(e){const t=new Array(e.length);for(let n=0;n<t.length;++n)t[n]=e[n].listener||e[n];return t}(i):c(i,i.length)}function f(e){const t=this._events;if(void 0!==t){const n=t[e];if("function"==typeof n)return 1;if(void 0!==n)return n.length}return 0}function c(e,t){const n=new Array(t);for(let r=0;r<t;++r)n[r]=e[r];return n}function l(e,t){return new Promise((function(n,r){function i(n){e.removeListener(t,o),r(n)}function o(){"function"==typeof e.removeListener&&e.removeListener("error",i),n([].slice.call(arguments))}h(e,t,o,{once:!0}),"error"!==t&&function(e,t,n){"function"==typeof e.on&&h(e,"error",t,n)}(e,i,{once:!0})}))}function h(e,t,n,r){if("function"==typeof e.on)r.once?e.once(t,n):e.on(t,n);else{if("function"!=typeof e.addEventListener)throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof e);e.addEventListener(t,(function i(o){r.once&&e.removeEventListener(t,i),n(o)}))}}Object.defineProperty(e,"defaultMaxListeners",{enumerable:!0,get:function(){return t},set:function(e){if("number"!=typeof e||e<0||Number.isNaN(e))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+e+".");t=e}}),e.init=function(){void 0!==this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},e.prototype.setMaxListeners=function(e){if("number"!=typeof e||e<0||Number.isNaN(e))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+e+".");return this._maxListeners=e,this},e.prototype.getMaxListeners=function(){return r(this)},e.prototype.emit=function(e){const t=[];for(let e=1;e<arguments.length;e++)t.push(arguments[e]);let n="error"===e;const r=this._events;if(void 0!==r)n=n&&void 0===r.error;else if(!n)return!1;if(n){let e;if(t.length>0&&(e=t[0]),e instanceof Error)throw e;const n=new Error("Unhandled error."+(e?" ("+e.message+")":""));throw n.context=e,n}const i=r[e];if(void 0===i)return!1;if("function"==typeof i)Reflect.apply(i,this,t);else{const e=i.length,n=c(i,e);for(let r=0;r<e;++r)Reflect.apply(n[r],this,t)}return!0},e.prototype.addListener=function(e,t){return i(this,e,t,!1)},e.prototype.on=e.prototype.addListener,e.prototype.prependListener=function(e,t){return i(this,e,t,!0)},e.prototype.once=function(e,t){return n(t),this.on(e,s(this,e,t)),this},e.prototype.prependOnceListener=function(e,t){return n(t),this.prependListener(e,s(this,e,t)),this},e.prototype.removeListener=function(e,t){n(t);const r=this._events;if(void 0===r)return this;const i=r[e];if(void 0===i)return this;if(i===t||i.listener===t)0==--this._eventsCount?this._events=Object.create(null):(delete r[e],r.removeListener&&this.emit("removeListener",e,i.listener||t));else if("function"!=typeof i){let n,o=-1;for(let e=i.length-1;e>=0;e--)if(i[e]===t||i[e].listener===t){n=i[e].listener,o=e;break}if(o<0)return this;0===o?i.shift():function(e,t){for(;t+1<e.length;t++)e[t]=e[t+1];e.pop()}(i,o),1===i.length&&(r[e]=i[0]),void 0!==r.removeListener&&this.emit("removeListener",e,n||t)}return this},e.prototype.off=e.prototype.removeListener,e.prototype.removeAllListeners=function(e){const t=this._events;if(void 0===t)return this;if(void 0===t.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==t[e]&&(0==--this._eventsCount?this._events=Object.create(null):delete t[e]),this;if(0===arguments.length){const e=Object.keys(t);for(let t=0;t<e.length;++t){const n=e[t];"removeListener"!==n&&this.removeAllListeners(n)}return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}const n=t[e];if("function"==typeof n)this.removeListener(e,n);else if(void 0!==n)for(let t=n.length-1;t>=0;t--)this.removeListener(e,n[t]);return this},e.prototype.listeners=function(e){return u(this,e,!0)},e.prototype.rawListeners=function(e){return u(this,e,!1)},e.listenerCount=function(e,t){return"function"==typeof e.listenerCount?e.listenerCount(t):f.call(e,t)},e.prototype.listenerCount=f,e.prototype.eventNames=function(){return this._eventsCount>0?Reflect.ownKeys(this._events):[]};
âœ„
{"version":3,"file":"backend.js","names":["code"],"sourceRoot":"/root/frida/build/subprojects/frida-tools/agents/itracer/itracer_agent.js.p/node_modules/frida-itrace/dist/","sources":[""],"mappings":"OAAO,MAAMA,KAAO"}
âœ„
export const code='#line 2 "backend.ts"\n#include <string.h>\n#include <gum/gummodulemap.h>\n#include <gum/gumstalker.h>\n#include <json-glib/json-glib.h>\n\n#define RED_ZONE_SIZE 128\n\n#define SCRATCH_REG_BOTTOM ARM64_REG_X21\n#define SCRATCH_REG_TOP ARM64_REG_X28\n\n#define SCRATCH_REG_INDEX(r) ((r) - SCRATCH_REG_BOTTOM)\n#define SCRATCH_REG_OFFSET(r) (SCRATCH_REG_INDEX (r) * 8)\n\ntypedef enum _ITraceState ITraceState;\ntypedef struct _ITraceSession ITraceSession;\ntypedef struct _ITraceBuffer ITraceBuffer;\n\nenum _ITraceState\n{\n  ITRACE_STATE_CREATED,\n  ITRACE_STATE_STARTING,\n  ITRACE_STATE_STARTED,\n  ITRACE_STATE_ENDED,\n};\n\nstruct _ITraceSession\n{\n  ITraceState state;\n  ITraceBuffer * buffer;\n  guint64 pending_size;\n  guint64 saved_regs[2];\n  guint64 stack[64];\n  guint64 scratch_regs[SCRATCH_REG_TOP - SCRATCH_REG_BOTTOM + 1];\n  guint64 log_buf[1969];\n  GumAddress write_impl;\n  GumModuleMap * modules;\n};\n\nextern ITraceSession session;\nextern void * end_address;\n\nextern void on_start (const gchar * meta_json, const GumCpuContext * cpu_context, guint length);\nextern void on_end (void);\nextern void on_compile (const gchar * meta_json);\nextern void on_panic (const gchar * message);\n\nstatic void on_first_block_hit (GumCpuContext * cpu_context, gpointer user_data);\nstatic void on_end_instruction_hit (GumCpuContext * cpu_context, gpointer user_data);\nstatic void add_cpu_register_meta (JsonBuilder * meta, const gchar * name, guint size);\nstatic void add_block_write_meta (JsonBuilder * meta, guint block_offset, guint cpu_reg_index);\nstatic void add_memory_address (JsonBuilder * builder, GumAddress address);\nstatic gchar * make_json (JsonBuilder ** builder);\nstatic arm64_reg pick_scratch_register (cs_regs regs_read, uint8_t num_regs_read, cs_regs regs_written, uint8_t num_regs_written);\nstatic arm64_reg register_to_full_size_register (arm64_reg reg);\nstatic void emit_scratch_register_restore (GumArm64Writer * cw, arm64_reg reg);\nstatic void emit_buffer_write_impl (GumArm64Writer * cw);\n\nstatic void panic (const char * format, ...);\n\nvoid\ninit (void)\n{\n  session.modules = gum_module_map_new ();\n}\n\nvoid\nfinalize (void)\n{\n  g_object_unref (session.modules);\n}\n\nvoid\ntransform (GumStalkerIterator * iterator,\n           GumStalkerOutput * output,\n           gpointer user_data)\n{\n  GumArm64Writer * cw = output->writer.arm64;\n  csh capstone = gum_stalker_iterator_get_capstone (iterator);\n\n  guint num_instructions = 0;\n  GumAddress block_address = 0;\n  guint log_buf_offset = 16;\n  arm64_reg prev_session_reg = ARM64_REG_INVALID;\n\n  JsonBuilder * meta = json_builder_new_immutable ();\n  json_builder_begin_object (meta);\n\n  cs_insn * insn;\n  while (gum_stalker_iterator_next (iterator, &insn))\n  {\n    num_instructions++;\n\n    gboolean is_first_in_block = num_instructions == 1;\n    gboolean is_last_in_block = cs_insn_group (capstone, insn, CS_GRP_JUMP) || cs_insn_group (capstone, insn, CS_GRP_RET);\n\n    if (is_first_in_block)\n    {\n      block_address = insn->address;\n\n      json_builder_set_member_name (meta, "writes");\n      json_builder_begin_array (meta);\n    }\n\n    if (session.state == ITRACE_STATE_CREATED)\n    {\n      session.state = ITRACE_STATE_STARTING;\n      gum_stalker_iterator_put_callout (iterator, on_first_block_hit, NULL, NULL);\n    }\n\n    if (end_address != NULL && GUM_ADDRESS (end_address) == insn->address)\n    {\n      gum_stalker_iterator_put_callout (iterator, on_end_instruction_hit, NULL, NULL);\n    }\n\n    cs_regs regs_read, regs_written;\n    uint8_t num_regs_read, num_regs_written;\n    cs_regs_access (capstone, insn, regs_read, &num_regs_read, regs_written, &num_regs_written);\n    for (uint8_t i = 0; i != num_regs_read; i++)\n      regs_read[i] = register_to_full_size_register (regs_read[i]);\n    for (uint8_t i = 0; i != num_regs_written; i++)\n      regs_written[i] = register_to_full_size_register (regs_written[i]);\n\n    arm64_reg session_reg = is_last_in_block\n        ? SCRATCH_REG_TOP\n        : pick_scratch_register (regs_read, num_regs_read, regs_written, num_regs_written);\n\n    if (session_reg != prev_session_reg)\n    {\n      if (prev_session_reg != ARM64_REG_INVALID)\n        gum_arm64_writer_put_mov_reg_reg (cw, session_reg, prev_session_reg);\n      else\n        gum_arm64_writer_put_ldr_reg_address (cw, session_reg, GUM_ADDRESS (&session));\n    }\n\n    if (prev_session_reg != ARM64_REG_INVALID && session_reg != prev_session_reg)\n      emit_scratch_register_restore (cw, prev_session_reg);\n\n    if (is_first_in_block)\n    {\n      gum_arm64_writer_put_str_reg_reg_offset (cw, ARM64_REG_LR, session_reg, G_STRUCT_OFFSET (ITraceSession, log_buf) + 8);\n      add_block_write_meta (meta, insn->address - block_address, 33);\n    }\n\n    if (is_last_in_block)\n    {\n      gum_arm64_writer_put_stp_reg_reg_reg_offset (cw, ARM64_REG_X27, ARM64_REG_LR,\n          session_reg, G_STRUCT_OFFSET (ITraceSession, saved_regs), GUM_INDEX_SIGNED_OFFSET);\n      gum_arm64_writer_put_ldr_reg_address (cw, ARM64_REG_X27, block_address);\n      gum_arm64_writer_put_str_reg_reg_offset (cw, ARM64_REG_X27, session_reg, G_STRUCT_OFFSET (ITraceSession, log_buf));\n      gum_arm64_writer_put_ldr_reg_u64 (cw, ARM64_REG_X27, log_buf_offset);\n      gum_arm64_writer_put_str_reg_reg_offset (cw, ARM64_REG_X27, session_reg, G_STRUCT_OFFSET (ITraceSession, pending_size));\n\n      if (session.write_impl == 0 ||\n          !gum_arm64_writer_can_branch_directly_between (cw, cw->pc, session.write_impl))\n      {\n        gconstpointer after_write_impl = cw->code + 1;\n\n        gum_arm64_writer_put_b_label (cw, after_write_impl);\n\n        session.write_impl = cw->pc;\n        emit_buffer_write_impl (cw);\n\n        gum_arm64_writer_put_label (cw, after_write_impl);\n      }\n\n      gum_arm64_writer_put_bl_imm (cw, session.write_impl);\n\n      gum_arm64_writer_put_ldp_reg_reg_reg_offset (cw, ARM64_REG_X27, ARM64_REG_LR,\n          session_reg, G_STRUCT_OFFSET (ITraceSession, saved_regs), GUM_INDEX_SIGNED_OFFSET);\n\n      emit_scratch_register_restore (cw, session_reg);\n    }\n\n    gum_stalker_iterator_keep (iterator);\n\n    if (is_last_in_block)\n      continue;\n\n    guint block_offset = (insn->address + insn->size) - block_address;\n\n    for (uint8_t i = 0; i != num_regs_written; i++)\n    {\n      arm64_reg reg = regs_written[i];\n      gboolean is_scratch_reg = reg >= SCRATCH_REG_BOTTOM && reg <= SCRATCH_REG_TOP;\n      if (is_scratch_reg)\n      {\n        gum_arm64_writer_put_str_reg_reg_offset (cw, reg,\n            session_reg, G_STRUCT_OFFSET (ITraceSession, scratch_regs) + SCRATCH_REG_OFFSET (reg));\n      }\n    }\n\n    for (uint8_t i = 0; i != num_regs_written; i++)\n    {\n      arm64_reg reg = regs_written[i];\n\n      guint cpu_reg_index;\n      arm64_reg source_reg;\n      gsize size;\n      arm64_reg temp_reg = ARM64_REG_INVALID;\n\n      if (reg == ARM64_REG_SP)\n      {\n        temp_reg = ARM64_REG_X0;\n\n        cpu_reg_index = 1;\n        source_reg = temp_reg;\n        size = 8;\n      }\n      else if (reg >= ARM64_REG_X0 && reg <= ARM64_REG_X28)\n      {\n        cpu_reg_index = 3 + (reg - ARM64_REG_X0);\n        source_reg = reg;\n        size = 8;\n      }\n      else if (reg == ARM64_REG_FP)\n      {\n        cpu_reg_index = 32;\n        source_reg = reg;\n        size = 8;\n      }\n      else if (reg == ARM64_REG_LR)\n      {\n        cpu_reg_index = 33;\n        source_reg = reg;\n        size = 8;\n      }\n      else if (reg >= ARM64_REG_Q0 && reg <= ARM64_REG_Q31)\n      {\n        cpu_reg_index = 34 + (reg - ARM64_REG_Q0);\n        source_reg = reg;\n        size = 16;\n      }\n      else if (reg == ARM64_REG_NZCV)\n      {\n        temp_reg = ARM64_REG_X0;\n\n        cpu_reg_index = 2;\n        source_reg = temp_reg;\n        size = 8;\n      }\n      else if (reg == ARM64_REG_XZR || reg == ARM64_REG_WZR)\n      {\n        continue;\n      }\n      else\n      {\n        panic ("Unhandled register: %s", cs_reg_name (capstone, reg));\n        while (TRUE)\n          ;\n      }\n\n      if (temp_reg != ARM64_REG_INVALID)\n        gum_arm64_writer_put_str_reg_reg_offset (cw, temp_reg, session_reg, G_STRUCT_OFFSET (ITraceSession, saved_regs));\n\n      if (reg == ARM64_REG_SP)\n        gum_arm64_writer_put_mov_reg_reg (cw, temp_reg, ARM64_REG_SP);\n      else if (reg == ARM64_REG_NZCV)\n        gum_arm64_writer_put_mov_reg_nzcv (cw, temp_reg);\n\n      gsize offset = G_STRUCT_OFFSET (ITraceSession, log_buf) + log_buf_offset;\n      gsize alignment_delta = offset % size;\n      if (alignment_delta != 0)\n        offset += size - alignment_delta;\n      // TODO: Handle large offsets\n      gum_arm64_writer_put_str_reg_reg_offset (cw, source_reg, session_reg, offset);\n      add_block_write_meta (meta, block_offset, cpu_reg_index);\n      log_buf_offset += size;\n\n      if (temp_reg != ARM64_REG_INVALID)\n        gum_arm64_writer_put_ldr_reg_reg_offset (cw, temp_reg, session_reg, G_STRUCT_OFFSET (ITraceSession, saved_regs));\n    }\n\n    prev_session_reg = session_reg;\n  }\n\n  json_builder_end_array (meta);\n\n  json_builder_set_member_name (meta, "address");\n  add_memory_address (meta, block_address);\n\n  json_builder_set_member_name (meta, "size");\n  json_builder_add_int_value (meta, (insn->address + insn->size) - block_address);\n\n  json_builder_set_member_name (meta, "compiled");\n  json_builder_begin_object (meta);\n  {\n    guint compiled_code_size = gum_arm64_writer_offset (cw);\n\n    json_builder_set_member_name (meta, "address");\n    add_memory_address (meta, cw->pc - compiled_code_size);\n\n    json_builder_set_member_name (meta, "size");\n    json_builder_add_int_value (meta, compiled_code_size);\n  }\n  json_builder_end_object (meta);\n\n  const GumModuleDetails * m = gum_module_map_find (session.modules, block_address);\n  if (m != NULL)\n  {\n    json_builder_set_member_name (meta, "name");\n    gchar * name = g_strdup_printf ("%s!0x%x", m->name, (guint) (block_address - m->range->base_address));\n    json_builder_add_string_value (meta, name);\n    g_free (name);\n\n    json_builder_set_member_name (meta, "module");\n    json_builder_begin_object (meta);\n\n    json_builder_set_member_name (meta, "path");\n    json_builder_add_string_value (meta, m->path);\n\n    json_builder_set_member_name (meta, "base");\n    add_memory_address (meta, m->range->base_address);\n\n    json_builder_end_object (meta);\n  }\n  else\n  {\n    json_builder_set_member_name (meta, "name");\n    add_memory_address (meta, block_address);\n  }\n\n  json_builder_end_object (meta);\n\n  gchar * json = make_json (&meta);\n  on_compile (json);\n  g_free (json);\n}\n\nstatic void\non_first_block_hit (GumCpuContext * cpu_context,\n                    gpointer user_data)\n{\n  if (session.state != ITRACE_STATE_STARTING)\n    return;\n  session.state = ITRACE_STATE_STARTED;\n\n  memcpy (session.scratch_regs, cpu_context->x + (SCRATCH_REG_BOTTOM - ARM64_REG_X0), sizeof (session.scratch_regs));\n\n  JsonBuilder * meta = json_builder_new_immutable ();\n  json_builder_begin_array (meta);\n  add_cpu_register_meta (meta, "pc", sizeof (cpu_context->pc));\n  add_cpu_register_meta (meta, "sp", sizeof (cpu_context->sp));\n  add_cpu_register_meta (meta, "nzcv", sizeof (cpu_context->nzcv));\n  for (guint i = 0; i != G_N_ELEMENTS (cpu_context->x); i++)\n  {\n    gchar * name = g_strdup_printf ("x%u", i);\n    add_cpu_register_meta (meta, name, sizeof (cpu_context->x[0]));\n    g_free (name);\n  }\n  add_cpu_register_meta (meta, "fp", sizeof (cpu_context->fp));\n  add_cpu_register_meta (meta, "lr", sizeof (cpu_context->lr));\n  for (guint i = 0; i != G_N_ELEMENTS (cpu_context->v); i++)\n  {\n    gchar * name = g_strdup_printf ("v%u", i);\n    add_cpu_register_meta (meta, name, sizeof (cpu_context->v[0]));\n    g_free (name);\n  }\n  json_builder_end_array (meta);\n\n  gchar * json = make_json (&meta);\n  on_start (json, cpu_context, sizeof (GumCpuContext));\n  g_free (json);\n}\n\nstatic void\non_end_instruction_hit (GumCpuContext * cpu_context,\n                        gpointer user_data)\n{\n  if (session.state != ITRACE_STATE_STARTED)\n    return;\n  session.state = ITRACE_STATE_ENDED;\n\n  on_end ();\n}\n\nstatic void\nadd_cpu_register_meta (JsonBuilder * meta,\n                       const gchar * name,\n                       guint size)\n{\n  json_builder_begin_object (meta);\n\n  json_builder_set_member_name (meta, "name");\n  json_builder_add_string_value (meta, name);\n\n  json_builder_set_member_nam
```
Response:
Let's break down the thought process for analyzing this Frida agent code and answering the user's request.

**1. Understanding the Core Request:**

The user wants to understand the functionality of the `itracer_agent.js` file, specifically how it uses Frida for dynamic instrumentation. They're interested in low-level details, interactions with the Linux kernel, and how to replicate the functionality with LLDB. They also want to understand common usage errors and how users might reach this point.

**2. Initial Code Scan and Keyword Identification (Mental or Actual):**

Quickly scan the `agent.ts`, `events.ts`, and `backend.ts` files for important keywords and patterns. I'd be looking for:

* **Core Frida Concepts:** `rpc.exports`, `send()`, `Device.spawn()`, `Session.attach()`, `Script.load()`, `Module.getExportByName()`, `Process.enumerateModules()`, `Process.enumerateThreads()`.
* **Instrumentation-Related Terms:**  `TraceBuffer`, `TraceBufferReader`, `TraceSession`, `Stalker`, `CpuContext`, `transform`, `callout`, `block`, `instruction`, `register`.
* **Data Handling:** `JSON`, `buffer`, `read`, `write`, `payload`.
* **Error Handling:** `Error`, `console.error`, `panic`.
* **Platform-Specific Details (though less evident in the JS):** Hints of architecture (ARM64 in `backend.ts`), mentions of modules, threads.

**3. Dissecting `agent.ts` (The Main Logic):**

* **Class `Agent`:** This is the core of the agent. It manages the trace session and buffer.
* **`constructor`:** Initializes the agent, setting up the `TraceSession` and `TraceBuffer`. The `drainTimer` hints at periodically processing the collected data.
* **`createBuffer` and `openBuffer`:** These methods manage the underlying `TraceBuffer`.
* **`launchBufferReader` and `stopBufferReader`:** These control the reading of data from the buffer and sending it back to the Frida host. The `setInterval` is key for periodic data transfer.
* **`launchTraceSession`:** This is where the tracing magic happens. It takes a "strategy" (likely defining what to trace), creates a `TraceSession`, and sets up event listeners (`start`, `end`, `compile`, `panic`). The logic within the `rawStrategy` processing is important for understanding how tracing targets (threads, ranges) are specified.
* **`queryProgramName` and `listThreads`:** These provide basic system information.
* **`rpc.exports`:**  Crucially, this makes the agent's methods accessible from the Frida host.

**4. Dissecting `events.ts` (Standard EventEmitter):**

Recognize this as a standard implementation of an EventEmitter. While important for the internal workings of the `TraceSession`, its specific details aren't as critical for understanding the core *tracing* functionality at a high level. Focus on the fact that it's used for asynchronous communication of events.

**5. Dissecting `backend.ts` (Native Code Stub):**

This file is a stub for native code. Note that it contains `#include` directives and defines structs and enums. This immediately tells you that the core tracing logic is likely implemented in native code for performance reasons. Recognize the mentions of `GumStalker`, `GumCpuContext`, and registers (ARM64). This confirms interaction with the Frida Stalker API, which is responsible for code rewriting.

**6. Connecting the Dots:**

* **User Interaction:** The user interacts with the agent through the exported methods exposed via `rpc.exports`. They would likely use a Frida script to call these methods (e.g., `agent.createBuffer()`, `agent.launchTraceSession(strategy)`, `agent.stopBufferReader()`).
* **Tracing Workflow:** The user defines a tracing strategy, the agent creates a buffer and session, Stalker (in the native code) intercepts and rewrites code, and the agent periodically reads the collected trace data from the buffer and sends it back.
* **Low-Level Aspects:** The `backend.ts` file highlights the use of Frida's Stalker API, allowing for instruction-level tracing and access to CPU registers. The ARM64 specifics confirm this is for a 64-bit ARM architecture.
* **Error Handling:** The `panic` event and `console.error` show basic error reporting mechanisms.

**7. Addressing Specific User Questions:**

* **Functionality Summary:** Synthesize the key functionalities based on the analysis.
* **Binary/Kernel/Linux:** Explain how Stalker interacts with the process's memory and the kernel (through system calls made by Frida). Use examples from `backend.ts` (register access, `GumStalker`).
* **LLDB Replication:**  Focus on the *effects* of the agent's actions rather than a direct line-by-line replication (which is usually impossible). Emphasize setting breakpoints, examining memory, and using watchpoints to observe the same data the agent is capturing.
* **Logic and Assumptions:** If any part of the code makes assumptions or has specific logic (like the strategy parsing), illustrate with input/output examples.
* **User Errors:** Think about common mistakes when using dynamic instrumentation: incorrect addresses, invalid thread IDs, not starting/stopping the agent correctly.
* **User Steps to Reach This Point:** Outline a typical Frida workflow that would involve loading and interacting with this agent.

**8. Structuring the Output:**

Organize the findings logically, addressing each part of the user's request. Use clear headings and bullet points for readability.

**Self-Correction/Refinement during the Process:**

* **Initial thought:** "Is `events.ts` really important to detail?" -> "Yes, it explains how the agent communicates internally, but a high-level explanation of its role as an event emitter is sufficient."
* **Initial thought:** "Can I replicate the Stalker logic directly in LLDB?" -> "No, Stalker is a Frida-specific code rewriting engine. Focus on the observable effects (memory changes, register values)."
* **Ensure clear distinction between the JavaScript agent and the native backend.**  It's important to explain that the JS controls the session and data flow, but the heavy lifting of instrumentation is in the native code.

By following these steps, combining code analysis with an understanding of Frida's core concepts, and focusing on addressing the user's specific questions, a comprehensive and helpful answer can be constructed.## Frida ITracer Agent 功能归纳 (第 1部分)

这个Frida Agent（位于 `frida/build/subprojects/frida-tools/agents/itracer/itracer_agent.js`）的主要功能是 **对目标进程进行指令级别的追踪 (Instruction Tracing)**。  它通过 Frida 的动态插桩技术，在目标进程执行过程中，记录每个执行到的指令以及相关的上下文信息。

**具体功能点：**

1. **指令级追踪:**  这是其核心功能。Agent 会拦截目标进程执行的每一条指令。
2. **记录指令执行上下文:**  除了指令本身，Agent 还会捕获指令执行时的相关信息，例如：
    * **寄存器值:**  记录指定 CPU 寄存器的值，包括通用寄存器 (如 X0-X28, SP, FP, LR)、状态寄存器 (NZCV) 以及 SIMD 寄存器 (Q0-Q31)。
    * **内存访问:**  记录指令对内存的读写操作，包括内存地址。
    * **代码位置:**  记录指令所在的内存地址，以及所属的模块和偏移。
3. **可配置的追踪策略:**  Agent 允许用户配置追踪的范围和目标：
    * **线程追踪:** 可以指定追踪特定的线程 ID 或线程索引。
    * **地址范围追踪:** 可以指定追踪特定的内存地址范围。
4. **数据缓冲和传输:**  Agent 使用 `TraceBuffer` 来高效地存储追踪到的指令数据。并定期将这些数据通过 Frida 的 `send()` 函数发送回 Frida 主机。
5. **编译后代码信息:**  Agent 还会记录 Frida Stalker 动态编译生成的代码块的地址和大小。
6. **模块信息:**  Agent 会记录执行指令所属的模块路径和基地址。
7. **事件通知:** Agent 会在追踪开始、结束、编译代码块以及发生错误时发送事件通知给 Frida 主机。
8. **错误处理:**  Agent 包含基础的错误处理机制，例如当遇到无效的内存地址或未处理的寄存器时会抛出错误。

**涉及到二进制底层，Linux内核的举例说明：**

* **二进制底层 (Binary Low-Level):**
    * **寄存器操作:**  代码中大量涉及到 ARM64 寄存器 (例如 `ARM64_REG_X0`, `ARM64_REG_SP`, `ARM64_REG_NZCV`) 的操作，以及如何读取和存储这些寄存器的值。这直接关联到目标进程的 CPU 架构和指令集。例如，`gum_arm64_writer_put_str_reg_reg_offset (cw, reg, session_reg, G_STRUCT_OFFSET (ITraceSession, scratch_regs) + SCRATCH_REG_OFFSET (reg));`  这行代码在动态编译的代码中插入指令，将寄存器 `reg` 的值存储到 `session` 结构体的 `scratch_regs` 数组的特定偏移处。
    * **内存地址:**  代码中频繁出现内存地址的处理，例如 `insn->address` 表示指令的内存地址，以及如何从内存中读取数据 (`e.readVolatile(1)`)。
    * **指令组 (Instruction Groups):** 使用 `cs_insn_group (capstone, insn, CS_GRP_JUMP)` 和 `cs_insn_group (capstone, insn, CS_GRP_RET)` 来判断指令是否为跳转或返回指令，这需要理解 ARM64 指令集的分类。

* **Linux内核:**
    * **进程和线程:**  Agent 使用 `Process.enumerateThreads()` 来获取目标进程的线程信息，这依赖于 Frida 与 Linux 内核的交互，通过系统调用获取进程的线程列表。
    * **模块加载:**  `Process.enumerateModules()` 用于获取目标进程加载的模块信息，同样需要 Frida 与内核交互，读取进程的内存映射信息。
    * **内存管理:**  虽然代码本身没有直接的内核调用，但 Frida 的插桩机制 (`GumStalker`)  需要在内核层面修改目标进程的内存和执行流程。

**假设输入与输出 (针对 `parseTraceStrategy` 函数隐含的逻辑推理):**

虽然 `parseTraceStrategy` 函数在提供的代码片段中没有直接实现，但我们可以根据 `launchTraceSession` 函数中对 `strategy` 的处理进行推断。

**假设输入 (strategy):**

```javascript
{
  "type": "thread",
  "params": {
    "type": "id",
    "value": 12345
  }
}
```

或者

```javascript
{
  "type": "range",
  "params": [
    "0x7fffffffd000",
    "0x7ffffffff000"
  ]
}
```

**推断输出 (经过 `parseTraceStrategy` 处理后 `TraceSession` 构造函数的参数):**

对于线程 ID 的输入：

```javascript
{
  "type": "thread",
  "threadId": 12345
}
```

对于地址范围的输入：

```javascript
{
  "type": "range",
  "start": <Frida.NativePointer to 0x7fffffffd000>,
  "end": <Frida.NativePointer to 0x7ffffffff000>
}
```

**用户或编程常见的使用错误举例说明:**

1. **无效的内存地址:**  如果用户在配置追踪范围时提供了无效的内存地址（例如，未映射的地址），Agent 可能会在尝试读取该地址时抛出错误，例如 `Error: invalid address: ...`。 这是因为 `parseCodeLocation` 函数会尝试读取提供的地址，如果读取失败则会抛出异常。
2. **无效的线程 ID:**  如果用户指定追踪的线程 ID 在目标进程中不存在，Agent 可能会在尝试启动追踪时报错，例如 `Error("invalid thread ID")`。
3. **未正确启动/停止追踪:**  用户可能忘记调用 `launchTraceSession` 启动追踪，或者在追踪结束后忘记调用 `stopBufferReader` 清理资源，这可能导致数据丢失或资源泄漏。
4. **追踪范围过大:**  如果用户追踪的地址范围过大或追踪的线程数过多，可能会产生大量的追踪数据，导致性能问题或者 `TraceBuffer` 溢出。 这会导致 `send({type:"itrace:lost",payload:{lost:r}})` 事件被触发，提示数据丢失。
5. **尝试在不支持的架构上运行:** 该 Agent 代码中大量使用了 ARM64 相关的定义，如果在非 ARM64 架构的进程上运行，将会出现错误。

**用户操作是如何一步步的到达这里，作为调试线索:**

1. **编写 Frida 脚本:** 用户首先需要编写一个 Frida 脚本，用于加载和调用该 Agent。
2. **连接到目标进程:** 使用 Frida 的 API (例如 `frida.attach()` 或 `frida.spawn()`) 连接到目标进程。
3. **加载 Agent 代码:** 在 Frida 脚本中使用 `script.load()` 加载 `itracer_agent.js` 文件。
4. **调用 Agent 的导出方法:** 通过 `script.get_exports()` 获取 Agent 导出的方法 (例如 `createBuffer`, `launchTraceSession`)。
5. **配置追踪策略:**  用户需要根据需要配置追踪策略，例如指定追踪的线程 ID 或内存范围。
6. **启动追踪:** 调用 `launchTraceSession` 方法，并将配置好的策略作为参数传递进去。
7. **目标进程执行:**  目标进程开始执行，Frida Agent 开始进行指令级别的追踪。
8. **接收追踪数据:**  Frida 主机通过 `script.on('message', ...)` 接收 Agent 发送的追踪数据。
9. **停止追踪:**  在需要停止追踪时，调用 `stopBufferReader` 方法。

**总结它的功能:**

`itracer_agent.js` 是一个 Frida Agent，其核心功能是对目标进程进行细粒度的指令级追踪。它允许用户配置追踪目标（线程或地址范围），记录指令执行时的寄存器值、内存访问和代码位置等上下文信息，并将这些数据发送回 Frida 主机进行分析。 该 Agent 依赖 Frida 的动态插桩技术和 Stalker API 来实现指令级别的拦截和数据采集。

### 提示词
```
这是目录为frida/build/subprojects/frida-tools/agents/itracer/itracer_agent.js的frida Dynamic instrumentation tool的源代码文件， 请列举一下它的功能, 
如果涉及到二进制底层，linux内核，请做出对应的举例说明，
请给出用lldb指令或者lldb python脚本，用来复刻的源代码所实现调试功能的示例，如果源代码是调试功能的实现。
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索，
请用中文回复。
这是第1部分，共2部分，请归纳一下它的功能
```

### 源代码
```javascript
📦
3311 /agent.js.map
2392 /agent.js
8095 /node_modules/@frida/events/events.js.map
5739 /node_modules/@frida/events/events.js
↻ events
217 /node_modules/frida-itrace/dist/backend.js.map
20955 /node_modules/frida-itrace/dist/backend.js
9287 /node_modules/frida-itrace/dist/index.js.map
5740 /node_modules/frida-itrace/dist/index.js
↻ frida-itrace
✄
{"version":3,"file":"agent.js","names":["TraceBuffer","TraceBufferReader","TraceSession","parseCodeLocation","location","NULL","kind","params","address","ptr","readVolatile","e","Error","Module","getExportByName","getBaseAddress","add","name","DebugSymbol","fromName","isNull","agent","constructor","this","session","buffer","reader","drainTimer","_Agent_drainBuffer","set","chunk","read","byteLength","send","type","lost","payload","createBuffer","create","openBuffer","open","launchBufferReader","setInterval","__classPrivateFieldGet","stopBufferReader","clearInterval","call","launchTraceSession","rawStrategy","strategy","thread","threads","Process","enumerateThreads","desiredId","th","find","t","id","undefined","threadId","start","end","parseTraceStrategy","events","on","regSpecs","regValues","block","message","console","error","queryProgramName","enumerateModules","listThreads","agentMethodNames","Object","getOwnPropertyNames","getPrototypeOf","filter","rpc","exports","bind"],"sourceRoot":"/root/frida/build/subprojects/frida-tools/agents/itracer/itracer_agent.js.p/","sources":["agent.ts"],"mappings":"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"}
✄
var e,r=this&&this.__classPrivateFieldGet||function(e,r,t,s){if("a"===t&&!s)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof r?e!==r||!s:!r.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===t?s:"a"===t?s.call(e):s?s.value:r.get(e)};import{TraceBuffer as t,TraceBufferReader as s,TraceSession as n}from"frida-itrace";function a(e){if(null===e)return NULL;const[r,t]=e;switch(r){case"address":{const e=ptr(t);try{e.readVolatile(1)}catch(r){throw new Error(`invalid address: ${e}`)}return e}case"module-export":return Module.getExportByName(t[0],t[1]);case"module-offset":return Module.getBaseAddress(t[0]).add(t[1]);case"symbol":{const e=t,{address:r}=DebugSymbol.fromName(e);return r.isNull()?Module.getExportByName(null,e):r}}}e=new WeakMap;const o=new class{constructor(){this.session=null,this.buffer=null,this.reader=null,this.drainTimer=null,e.set(this,(()=>{const e=this.reader.read();if(0===e.byteLength)return;send({type:"itrace:chunk"},e);const r=this.reader.lost;0!==r&&send({type:"itrace:lost",payload:{lost:r}})}))}createBuffer(){return this.buffer=t.create(),this.buffer.location}openBuffer(e){this.buffer=t.open(e)}launchBufferReader(){this.reader=new s(this.buffer),this.drainTimer=setInterval(r(this,e,"f"),10)}stopBufferReader(){clearInterval(this.drainTimer),this.drainTimer=null,r(this,e,"f").call(this),this.reader=null}launchTraceSession(e){const r=function(e){const[r,t]=e;switch(r){case"thread":{let e;const r=Process.enumerateThreads();switch(t[0]){case"id":{const s=t[1],n=r.find((e=>e.id===s));if(void 0===n)throw new Error("invalid thread ID");e=n;break}case"index":if(e=r[t[1]],void 0===e)throw new Error("invalid thread index")}return{type:"thread",threadId:e.id}}case"range":return{type:"range",start:a(t[0]),end:a(t[1])}}}(e),t=new n(r,this.buffer);this.session=t,t.events.on("start",((e,r)=>{send({type:"itrace:start",payload:e},r)})),t.events.on("end",(()=>{send({type:"itrace:end"})})),t.events.on("compile",(e=>{send({type:"itrace:compile",payload:e})})),t.events.on("panic",(e=>{console.error(e)})),t.open()}queryProgramName(){return Process.enumerateModules()[0].name}listThreads(){return Process.enumerateThreads()}},i=Object.getOwnPropertyNames(Object.getPrototypeOf(o)).filter((e=>"constructor"!==e));for(const e of i)rpc.exports[e]=o[e].bind(o);
✄
{"version":3,"file":"events.js","names":["EventEmitter","once","init","call","this","prototype","_events","undefined","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","TypeError","_getMaxListeners","that","_addListener","target","type","prepend","existing","events","Object","create","newListener","emit","unshift","push","m","length","warned","w","Error","String","name","emitter","count","warning","console","warn","onceWrapper","fired","removeListener","wrapFn","arguments","apply","_onceWrap","state","wrapped","bind","_listeners","unwrap","evlistener","arr","ret","Array","i","unwrapListeners","arrayClone","listenerCount","n","copy","Promise","resolve","reject","errorListener","err","resolver","slice","eventTargetAgnosticAddListener","handler","flags","on","addErrorHandlerIfEventEmitter","addEventListener","wrapListener","arg","removeEventListener","defineProperty","enumerable","get","set","Number","isNaN","RangeError","getPrototypeOf","setMaxListeners","getMaxListeners","args","doError","error","er","message","context","Reflect","len","listeners","addListener","prependListener","prependOnceListener","list","originalListener","position","shift","index","pop","spliceOne","off","removeAllListeners","keys","key","rawListeners","eventNames","ownKeys"],"sourceRoot":"/root/frida/build/subprojects/frida-tools/agents/itracer/itracer_agent.js.p/node_modules/@frida/events/","sources":[""],"mappings":"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"}
✄
export default e;export{e as EventEmitter,l as once};function e(){e.init.call(this)}e.EventEmitter=e,e.prototype._events=void 0,e.prototype._eventsCount=0,e.prototype._maxListeners=void 0;let t=10;function n(e){if("function"!=typeof e)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof e)}function r(t){return void 0===t._maxListeners?e.defaultMaxListeners:t._maxListeners}function i(e,t,i,o){let s;n(i);let u=e._events;if(void 0===u?(u=e._events=Object.create(null),e._eventsCount=0):(void 0!==u.newListener&&(e.emit("newListener",t,i.listener?i.listener:i),u=e._events),s=u[t]),void 0===s)s=u[t]=i,++e._eventsCount;else{"function"==typeof s?s=u[t]=o?[i,s]:[s,i]:o?s.unshift(i):s.push(i);const n=r(e);if(n>0&&s.length>n&&!s.warned){s.warned=!0;const n=new Error("Possible EventEmitter memory leak detected. "+s.length+" "+String(t)+" listeners added. Use emitter.setMaxListeners() to increase limit");n.name="MaxListenersExceededWarning",n.emitter=e,n.type=t,n.count=s.length,f=n,console.warn(f)}}var f;return e}function o(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,0===arguments.length?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function s(e,t,n){const r={fired:!1,wrapFn:void 0,target:e,type:t,listener:n},i=o.bind(r);return i.listener=n,r.wrapFn=i,i}function u(e,t,n){const r=e._events;if(void 0===r)return[];const i=r[t];return void 0===i?[]:"function"==typeof i?n?[i.listener||i]:[i]:n?function(e){const t=new Array(e.length);for(let n=0;n<t.length;++n)t[n]=e[n].listener||e[n];return t}(i):c(i,i.length)}function f(e){const t=this._events;if(void 0!==t){const n=t[e];if("function"==typeof n)return 1;if(void 0!==n)return n.length}return 0}function c(e,t){const n=new Array(t);for(let r=0;r<t;++r)n[r]=e[r];return n}function l(e,t){return new Promise((function(n,r){function i(n){e.removeListener(t,o),r(n)}function o(){"function"==typeof e.removeListener&&e.removeListener("error",i),n([].slice.call(arguments))}h(e,t,o,{once:!0}),"error"!==t&&function(e,t,n){"function"==typeof e.on&&h(e,"error",t,n)}(e,i,{once:!0})}))}function h(e,t,n,r){if("function"==typeof e.on)r.once?e.once(t,n):e.on(t,n);else{if("function"!=typeof e.addEventListener)throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof e);e.addEventListener(t,(function i(o){r.once&&e.removeEventListener(t,i),n(o)}))}}Object.defineProperty(e,"defaultMaxListeners",{enumerable:!0,get:function(){return t},set:function(e){if("number"!=typeof e||e<0||Number.isNaN(e))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+e+".");t=e}}),e.init=function(){void 0!==this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},e.prototype.setMaxListeners=function(e){if("number"!=typeof e||e<0||Number.isNaN(e))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+e+".");return this._maxListeners=e,this},e.prototype.getMaxListeners=function(){return r(this)},e.prototype.emit=function(e){const t=[];for(let e=1;e<arguments.length;e++)t.push(arguments[e]);let n="error"===e;const r=this._events;if(void 0!==r)n=n&&void 0===r.error;else if(!n)return!1;if(n){let e;if(t.length>0&&(e=t[0]),e instanceof Error)throw e;const n=new Error("Unhandled error."+(e?" ("+e.message+")":""));throw n.context=e,n}const i=r[e];if(void 0===i)return!1;if("function"==typeof i)Reflect.apply(i,this,t);else{const e=i.length,n=c(i,e);for(let r=0;r<e;++r)Reflect.apply(n[r],this,t)}return!0},e.prototype.addListener=function(e,t){return i(this,e,t,!1)},e.prototype.on=e.prototype.addListener,e.prototype.prependListener=function(e,t){return i(this,e,t,!0)},e.prototype.once=function(e,t){return n(t),this.on(e,s(this,e,t)),this},e.prototype.prependOnceListener=function(e,t){return n(t),this.prependListener(e,s(this,e,t)),this},e.prototype.removeListener=function(e,t){n(t);const r=this._events;if(void 0===r)return this;const i=r[e];if(void 0===i)return this;if(i===t||i.listener===t)0==--this._eventsCount?this._events=Object.create(null):(delete r[e],r.removeListener&&this.emit("removeListener",e,i.listener||t));else if("function"!=typeof i){let n,o=-1;for(let e=i.length-1;e>=0;e--)if(i[e]===t||i[e].listener===t){n=i[e].listener,o=e;break}if(o<0)return this;0===o?i.shift():function(e,t){for(;t+1<e.length;t++)e[t]=e[t+1];e.pop()}(i,o),1===i.length&&(r[e]=i[0]),void 0!==r.removeListener&&this.emit("removeListener",e,n||t)}return this},e.prototype.off=e.prototype.removeListener,e.prototype.removeAllListeners=function(e){const t=this._events;if(void 0===t)return this;if(void 0===t.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==t[e]&&(0==--this._eventsCount?this._events=Object.create(null):delete t[e]),this;if(0===arguments.length){const e=Object.keys(t);for(let t=0;t<e.length;++t){const n=e[t];"removeListener"!==n&&this.removeAllListeners(n)}return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}const n=t[e];if("function"==typeof n)this.removeListener(e,n);else if(void 0!==n)for(let t=n.length-1;t>=0;t--)this.removeListener(e,n[t]);return this},e.prototype.listeners=function(e){return u(this,e,!0)},e.prototype.rawListeners=function(e){return u(this,e,!1)},e.listenerCount=function(e,t){return"function"==typeof e.listenerCount?e.listenerCount(t):f.call(e,t)},e.prototype.listenerCount=f,e.prototype.eventNames=function(){return this._eventsCount>0?Reflect.ownKeys(this._events):[]};
✄
{"version":3,"file":"backend.js","names":["code"],"sourceRoot":"/root/frida/build/subprojects/frida-tools/agents/itracer/itracer_agent.js.p/node_modules/frida-itrace/dist/","sources":[""],"mappings":"OAAO,MAAMA,KAAO"}
✄
export const code='#line 2 "backend.ts"\n#include <string.h>\n#include <gum/gummodulemap.h>\n#include <gum/gumstalker.h>\n#include <json-glib/json-glib.h>\n\n#define RED_ZONE_SIZE 128\n\n#define SCRATCH_REG_BOTTOM ARM64_REG_X21\n#define SCRATCH_REG_TOP ARM64_REG_X28\n\n#define SCRATCH_REG_INDEX(r) ((r) - SCRATCH_REG_BOTTOM)\n#define SCRATCH_REG_OFFSET(r) (SCRATCH_REG_INDEX (r) * 8)\n\ntypedef enum _ITraceState ITraceState;\ntypedef struct _ITraceSession ITraceSession;\ntypedef struct _ITraceBuffer ITraceBuffer;\n\nenum _ITraceState\n{\n  ITRACE_STATE_CREATED,\n  ITRACE_STATE_STARTING,\n  ITRACE_STATE_STARTED,\n  ITRACE_STATE_ENDED,\n};\n\nstruct _ITraceSession\n{\n  ITraceState state;\n  ITraceBuffer * buffer;\n  guint64 pending_size;\n  guint64 saved_regs[2];\n  guint64 stack[64];\n  guint64 scratch_regs[SCRATCH_REG_TOP - SCRATCH_REG_BOTTOM + 1];\n  guint64 log_buf[1969];\n  GumAddress write_impl;\n  GumModuleMap * modules;\n};\n\nextern ITraceSession session;\nextern void * end_address;\n\nextern void on_start (const gchar * meta_json, const GumCpuContext * cpu_context, guint length);\nextern void on_end (void);\nextern void on_compile (const gchar * meta_json);\nextern void on_panic (const gchar * message);\n\nstatic void on_first_block_hit (GumCpuContext * cpu_context, gpointer user_data);\nstatic void on_end_instruction_hit (GumCpuContext * cpu_context, gpointer user_data);\nstatic void add_cpu_register_meta (JsonBuilder * meta, const gchar * name, guint size);\nstatic void add_block_write_meta (JsonBuilder * meta, guint block_offset, guint cpu_reg_index);\nstatic void add_memory_address (JsonBuilder * builder, GumAddress address);\nstatic gchar * make_json (JsonBuilder ** builder);\nstatic arm64_reg pick_scratch_register (cs_regs regs_read, uint8_t num_regs_read, cs_regs regs_written, uint8_t num_regs_written);\nstatic arm64_reg register_to_full_size_register (arm64_reg reg);\nstatic void emit_scratch_register_restore (GumArm64Writer * cw, arm64_reg reg);\nstatic void emit_buffer_write_impl (GumArm64Writer * cw);\n\nstatic void panic (const char * format, ...);\n\nvoid\ninit (void)\n{\n  session.modules = gum_module_map_new ();\n}\n\nvoid\nfinalize (void)\n{\n  g_object_unref (session.modules);\n}\n\nvoid\ntransform (GumStalkerIterator * iterator,\n           GumStalkerOutput * output,\n           gpointer user_data)\n{\n  GumArm64Writer * cw = output->writer.arm64;\n  csh capstone = gum_stalker_iterator_get_capstone (iterator);\n\n  guint num_instructions = 0;\n  GumAddress block_address = 0;\n  guint log_buf_offset = 16;\n  arm64_reg prev_session_reg = ARM64_REG_INVALID;\n\n  JsonBuilder * meta = json_builder_new_immutable ();\n  json_builder_begin_object (meta);\n\n  cs_insn * insn;\n  while (gum_stalker_iterator_next (iterator, &insn))\n  {\n    num_instructions++;\n\n    gboolean is_first_in_block = num_instructions == 1;\n    gboolean is_last_in_block = cs_insn_group (capstone, insn, CS_GRP_JUMP) || cs_insn_group (capstone, insn, CS_GRP_RET);\n\n    if (is_first_in_block)\n    {\n      block_address = insn->address;\n\n      json_builder_set_member_name (meta, "writes");\n      json_builder_begin_array (meta);\n    }\n\n    if (session.state == ITRACE_STATE_CREATED)\n    {\n      session.state = ITRACE_STATE_STARTING;\n      gum_stalker_iterator_put_callout (iterator, on_first_block_hit, NULL, NULL);\n    }\n\n    if (end_address != NULL && GUM_ADDRESS (end_address) == insn->address)\n    {\n      gum_stalker_iterator_put_callout (iterator, on_end_instruction_hit, NULL, NULL);\n    }\n\n    cs_regs regs_read, regs_written;\n    uint8_t num_regs_read, num_regs_written;\n    cs_regs_access (capstone, insn, regs_read, &num_regs_read, regs_written, &num_regs_written);\n    for (uint8_t i = 0; i != num_regs_read; i++)\n      regs_read[i] = register_to_full_size_register (regs_read[i]);\n    for (uint8_t i = 0; i != num_regs_written; i++)\n      regs_written[i] = register_to_full_size_register (regs_written[i]);\n\n    arm64_reg session_reg = is_last_in_block\n        ? SCRATCH_REG_TOP\n        : pick_scratch_register (regs_read, num_regs_read, regs_written, num_regs_written);\n\n    if (session_reg != prev_session_reg)\n    {\n      if (prev_session_reg != ARM64_REG_INVALID)\n        gum_arm64_writer_put_mov_reg_reg (cw, session_reg, prev_session_reg);\n      else\n        gum_arm64_writer_put_ldr_reg_address (cw, session_reg, GUM_ADDRESS (&session));\n    }\n\n    if (prev_session_reg != ARM64_REG_INVALID && session_reg != prev_session_reg)\n      emit_scratch_register_restore (cw, prev_session_reg);\n\n    if (is_first_in_block)\n    {\n      gum_arm64_writer_put_str_reg_reg_offset (cw, ARM64_REG_LR, session_reg, G_STRUCT_OFFSET (ITraceSession, log_buf) + 8);\n      add_block_write_meta (meta, insn->address - block_address, 33);\n    }\n\n    if (is_last_in_block)\n    {\n      gum_arm64_writer_put_stp_reg_reg_reg_offset (cw, ARM64_REG_X27, ARM64_REG_LR,\n          session_reg, G_STRUCT_OFFSET (ITraceSession, saved_regs), GUM_INDEX_SIGNED_OFFSET);\n      gum_arm64_writer_put_ldr_reg_address (cw, ARM64_REG_X27, block_address);\n      gum_arm64_writer_put_str_reg_reg_offset (cw, ARM64_REG_X27, session_reg, G_STRUCT_OFFSET (ITraceSession, log_buf));\n      gum_arm64_writer_put_ldr_reg_u64 (cw, ARM64_REG_X27, log_buf_offset);\n      gum_arm64_writer_put_str_reg_reg_offset (cw, ARM64_REG_X27, session_reg, G_STRUCT_OFFSET (ITraceSession, pending_size));\n\n      if (session.write_impl == 0 ||\n          !gum_arm64_writer_can_branch_directly_between (cw, cw->pc, session.write_impl))\n      {\n        gconstpointer after_write_impl = cw->code + 1;\n\n        gum_arm64_writer_put_b_label (cw, after_write_impl);\n\n        session.write_impl = cw->pc;\n        emit_buffer_write_impl (cw);\n\n        gum_arm64_writer_put_label (cw, after_write_impl);\n      }\n\n      gum_arm64_writer_put_bl_imm (cw, session.write_impl);\n\n      gum_arm64_writer_put_ldp_reg_reg_reg_offset (cw, ARM64_REG_X27, ARM64_REG_LR,\n          session_reg, G_STRUCT_OFFSET (ITraceSession, saved_regs), GUM_INDEX_SIGNED_OFFSET);\n\n      emit_scratch_register_restore (cw, session_reg);\n    }\n\n    gum_stalker_iterator_keep (iterator);\n\n    if (is_last_in_block)\n      continue;\n\n    guint block_offset = (insn->address + insn->size) - block_address;\n\n    for (uint8_t i = 0; i != num_regs_written; i++)\n    {\n      arm64_reg reg = regs_written[i];\n      gboolean is_scratch_reg = reg >= SCRATCH_REG_BOTTOM && reg <= SCRATCH_REG_TOP;\n      if (is_scratch_reg)\n      {\n        gum_arm64_writer_put_str_reg_reg_offset (cw, reg,\n            session_reg, G_STRUCT_OFFSET (ITraceSession, scratch_regs) + SCRATCH_REG_OFFSET (reg));\n      }\n    }\n\n    for (uint8_t i = 0; i != num_regs_written; i++)\n    {\n      arm64_reg reg = regs_written[i];\n\n      guint cpu_reg_index;\n      arm64_reg source_reg;\n      gsize size;\n      arm64_reg temp_reg = ARM64_REG_INVALID;\n\n      if (reg == ARM64_REG_SP)\n      {\n        temp_reg = ARM64_REG_X0;\n\n        cpu_reg_index = 1;\n        source_reg = temp_reg;\n        size = 8;\n      }\n      else if (reg >= ARM64_REG_X0 && reg <= ARM64_REG_X28)\n      {\n        cpu_reg_index = 3 + (reg - ARM64_REG_X0);\n        source_reg = reg;\n        size = 8;\n      }\n      else if (reg == ARM64_REG_FP)\n      {\n        cpu_reg_index = 32;\n        source_reg = reg;\n        size = 8;\n      }\n      else if (reg == ARM64_REG_LR)\n      {\n        cpu_reg_index = 33;\n        source_reg = reg;\n        size = 8;\n      }\n      else if (reg >= ARM64_REG_Q0 && reg <= ARM64_REG_Q31)\n      {\n        cpu_reg_index = 34 + (reg - ARM64_REG_Q0);\n        source_reg = reg;\n        size = 16;\n      }\n      else if (reg == ARM64_REG_NZCV)\n      {\n        temp_reg = ARM64_REG_X0;\n\n        cpu_reg_index = 2;\n        source_reg = temp_reg;\n        size = 8;\n      }\n      else if (reg == ARM64_REG_XZR || reg == ARM64_REG_WZR)\n      {\n        continue;\n      }\n      else\n      {\n        panic ("Unhandled register: %s", cs_reg_name (capstone, reg));\n        while (TRUE)\n          ;\n      }\n\n      if (temp_reg != ARM64_REG_INVALID)\n        gum_arm64_writer_put_str_reg_reg_offset (cw, temp_reg, session_reg, G_STRUCT_OFFSET (ITraceSession, saved_regs));\n\n      if (reg == ARM64_REG_SP)\n        gum_arm64_writer_put_mov_reg_reg (cw, temp_reg, ARM64_REG_SP);\n      else if (reg == ARM64_REG_NZCV)\n        gum_arm64_writer_put_mov_reg_nzcv (cw, temp_reg);\n\n      gsize offset = G_STRUCT_OFFSET (ITraceSession, log_buf) + log_buf_offset;\n      gsize alignment_delta = offset % size;\n      if (alignment_delta != 0)\n        offset += size - alignment_delta;\n      // TODO: Handle large offsets\n      gum_arm64_writer_put_str_reg_reg_offset (cw, source_reg, session_reg, offset);\n      add_block_write_meta (meta, block_offset, cpu_reg_index);\n      log_buf_offset += size;\n\n      if (temp_reg != ARM64_REG_INVALID)\n        gum_arm64_writer_put_ldr_reg_reg_offset (cw, temp_reg, session_reg, G_STRUCT_OFFSET (ITraceSession, saved_regs));\n    }\n\n    prev_session_reg = session_reg;\n  }\n\n  json_builder_end_array (meta);\n\n  json_builder_set_member_name (meta, "address");\n  add_memory_address (meta, block_address);\n\n  json_builder_set_member_name (meta, "size");\n  json_builder_add_int_value (meta, (insn->address + insn->size) - block_address);\n\n  json_builder_set_member_name (meta, "compiled");\n  json_builder_begin_object (meta);\n  {\n    guint compiled_code_size = gum_arm64_writer_offset (cw);\n\n    json_builder_set_member_name (meta, "address");\n    add_memory_address (meta, cw->pc - compiled_code_size);\n\n    json_builder_set_member_name (meta, "size");\n    json_builder_add_int_value (meta, compiled_code_size);\n  }\n  json_builder_end_object (meta);\n\n  const GumModuleDetails * m = gum_module_map_find (session.modules, block_address);\n  if (m != NULL)\n  {\n    json_builder_set_member_name (meta, "name");\n    gchar * name = g_strdup_printf ("%s!0x%x", m->name, (guint) (block_address - m->range->base_address));\n    json_builder_add_string_value (meta, name);\n    g_free (name);\n\n    json_builder_set_member_name (meta, "module");\n    json_builder_begin_object (meta);\n\n    json_builder_set_member_name (meta, "path");\n    json_builder_add_string_value (meta, m->path);\n\n    json_builder_set_member_name (meta, "base");\n    add_memory_address (meta, m->range->base_address);\n\n    json_builder_end_object (meta);\n  }\n  else\n  {\n    json_builder_set_member_name (meta, "name");\n    add_memory_address (meta, block_address);\n  }\n\n  json_builder_end_object (meta);\n\n  gchar * json = make_json (&meta);\n  on_compile (json);\n  g_free (json);\n}\n\nstatic void\non_first_block_hit (GumCpuContext * cpu_context,\n                    gpointer user_data)\n{\n  if (session.state != ITRACE_STATE_STARTING)\n    return;\n  session.state = ITRACE_STATE_STARTED;\n\n  memcpy (session.scratch_regs, cpu_context->x + (SCRATCH_REG_BOTTOM - ARM64_REG_X0), sizeof (session.scratch_regs));\n\n  JsonBuilder * meta = json_builder_new_immutable ();\n  json_builder_begin_array (meta);\n  add_cpu_register_meta (meta, "pc", sizeof (cpu_context->pc));\n  add_cpu_register_meta (meta, "sp", sizeof (cpu_context->sp));\n  add_cpu_register_meta (meta, "nzcv", sizeof (cpu_context->nzcv));\n  for (guint i = 0; i != G_N_ELEMENTS (cpu_context->x); i++)\n  {\n    gchar * name = g_strdup_printf ("x%u", i);\n    add_cpu_register_meta (meta, name, sizeof (cpu_context->x[0]));\n    g_free (name);\n  }\n  add_cpu_register_meta (meta, "fp", sizeof (cpu_context->fp));\n  add_cpu_register_meta (meta, "lr", sizeof (cpu_context->lr));\n  for (guint i = 0; i != G_N_ELEMENTS (cpu_context->v); i++)\n  {\n    gchar * name = g_strdup_printf ("v%u", i);\n    add_cpu_register_meta (meta, name, sizeof (cpu_context->v[0]));\n    g_free (name);\n  }\n  json_builder_end_array (meta);\n\n  gchar * json = make_json (&meta);\n  on_start (json, cpu_context, sizeof (GumCpuContext));\n  g_free (json);\n}\n\nstatic void\non_end_instruction_hit (GumCpuContext * cpu_context,\n                        gpointer user_data)\n{\n  if (session.state != ITRACE_STATE_STARTED)\n    return;\n  session.state = ITRACE_STATE_ENDED;\n\n  on_end ();\n}\n\nstatic void\nadd_cpu_register_meta (JsonBuilder * meta,\n                       const gchar * name,\n                       guint size)\n{\n  json_builder_begin_object (meta);\n\n  json_builder_set_member_name (meta, "name");\n  json_builder_add_string_value (meta, name);\n\n  json_builder_set_member_nam
```
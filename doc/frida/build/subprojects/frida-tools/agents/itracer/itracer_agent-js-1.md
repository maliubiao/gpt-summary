Response:
Let's break down the thought process for analyzing this code snippet.

1. **Understand the Request:** The core request is to understand the functionality of a specific part of Frida's `itracer_agent.js`. The request emphasizes identifying debugging features, interactions with the binary/kernel level, and how to replicate some of its behavior using LLDB. The "Part 2" instruction suggests this is a continuation of a larger file.

2. **Identify the Core Purpose:** The code snippet contains several key components:
    * **`make_json`:**  This function clearly deals with creating JSON strings.
    * **`pick_scratch_register`:** This function is about selecting a temporary register in the ARM64 architecture.
    * **`register_to_full_size_register`:**  This function converts a potentially smaller register name (like `W0`) to its full-size counterpart (`X0`).
    * **`emit_scratch_register_restore`:**  This function seems to generate ARM64 assembly to restore a scratch register's value.
    * **`emit_buffer_write_impl`:** This function contains a large block of ARM64 assembly code.
    * **`panic`:** This function handles error reporting.

3. **Analyze Individual Functions and Their Interconnections:**

    * **`make_json`:**  This is straightforward. It takes a `JsonBuilder`, converts it to a JSON string, and cleans up memory. It's a utility function.

    * **`pick_scratch_register`:** This function is critical for dynamic instrumentation. It avoids corrupting existing register values when injecting code. The loops iterating through `regs_read` and `regs_written` are the core logic. The `SCRATCH_REG_TOP` and `SCRATCH_REG_BOTTOM` constants (though not defined here) are implied to define the range of usable scratch registers. This strongly suggests interaction with the CPU's register set.

    * **`register_to_full_size_register`:** This function handles the nuances of ARM64 register naming conventions (e.g., `W0` is the 32-bit version of `X0`). This is low-level and architecture-specific.

    * **`emit_scratch_register_restore`:** This function uses `gum_arm64_writer_put_ldr_reg_reg_offset`. The `gum_arm64_writer` prefix strongly indicates this is part of Frida's Gum library, which is used for code generation and manipulation. The offsets `G_STRUCT_OFFSET (ITraceSession, scratch_regs)` and `SCRATCH_REG_OFFSET (reg)` imply a data structure (`ITraceSession`) holding saved register values.

    * **`emit_buffer_write_impl`:** This is the most complex part. Recognizing the hexadecimal numbers with `U` suffixes as ARM64 instruction opcodes is key. Comments within the assembly like `add x27, x28, 0x228` provide hints about the code's purpose. The `stp` (store pair) and `ldp` (load pair) instructions suggest saving and restoring registers. The calls to `itrace_memcpy` further suggest this code is involved in writing data to a buffer. The logic with `ldaxr`, `stlxr`, and the "retry" label suggests an attempt at an atomic operation, likely for thread safety when writing to the buffer.

    * **`panic`:**  A standard error reporting function.

4. **Identify Debugging Features and Binary/Kernel Interactions:**

    * **Register manipulation:** `pick_scratch_register`, `register_to_full_size_register`, and `emit_scratch_register_restore` directly manipulate CPU registers, a core debugging concept.
    * **Code injection:** The `emit_buffer_write_impl` function generates machine code that will be injected into the target process. This is a fundamental dynamic instrumentation technique.
    * **Memory access:** The assembly code in `emit_buffer_write_impl` uses instructions like `ldr` (load register) and `str` (store register) to access memory. The function likely writes captured data (like register values or memory contents) to a buffer.
    * **Atomic operations:** The "retry" loop in `emit_buffer_write_impl` indicates an effort to ensure data is written to the buffer atomically, which is important for multi-threaded applications and avoids race conditions. This is relevant to concurrent programming and low-level synchronization.
    * **`memcpy` and `itrace_memcpy`:**  The calls to `memcpy` (or a custom `itrace_memcpy`) within the generated code indicate direct memory manipulation, a common operation when tracing or logging data.

5. **Consider LLDB Replication:**

    * **Register manipulation:** LLDB commands like `register read` and `register write` can be used to inspect and modify register values, mimicking the effect of `pick_scratch_register` and `register_to_full_size_register` in a manual fashion.
    * **Memory inspection:** LLDB commands like `x` (examine memory) allow inspection of memory regions, which can help understand what the `emit_buffer_write_impl` code is doing.
    * **Setting breakpoints:**  Breakpoints in LLDB can be used to stop execution at specific points within the injected code (if you have the address) or within the original code to observe the state before and after the injected code runs.
    * **Manual memory writes:** LLDB's `memory write` command could be used to manually write data to memory, simulating the buffer writing functionality. However, replicating the atomic operations would be more complex in raw LLDB. A Python script interacting with LLDB might be necessary for more intricate scenarios.

6. **Hypothesize Inputs and Outputs:**  For the register functions, the input is a register name (or numeric representation), and the output is either a modified register name or a chosen scratch register. For `make_json`, the input is a `JsonBuilder` object, and the output is a JSON string. For `emit_buffer_write_impl`, there isn't a direct function input/output in the JavaScript sense; it *generates* code.

7. **Identify Potential User Errors:**

    * **Incorrect Frida setup:** If Frida is not properly installed or configured, the agent won't work.
    * **Target process limitations:**  The target process might have security measures that prevent code injection.
    * **Register conflicts:**  If the scratch register selection logic is flawed, it could potentially overwrite important register values, leading to crashes.
    * **Memory access violations:** If the buffer offsets or sizes are incorrect, the injected code could attempt to access invalid memory, causing crashes.

8. **Trace User Operations (How to Reach This Code):**

    * A user would typically start by writing a Frida script that uses the `frida-trace` functionality (or directly interacts with Frida's instrumentation APIs).
    * `frida-trace` (or the custom script) would be configured to trace instructions or specific functions.
    * When the target application executes code that matches the tracing rules, Frida would inject the `itracer_agent.js` code.
    * The `emit_buffer_write_impl` function would be called to generate the machine code responsible for capturing the traced information.

9. **Structure the Response (For Part 2):** Organize the findings into clear sections based on the prompt's requirements: Functionality Summary, Binary/Kernel Interaction Examples, LLDB Replication, etc. Use clear and concise language. Since this is "Part 2," focus on summarizing the functionalities present in *this specific snippet*.

10. **Review and Refine:** Read through the analysis to ensure accuracy and completeness. Check for any unclear explanations or missing details. Make sure to explicitly state the assumptions and limitations. For instance, the exact details of `ITraceSession` and the `SCRATCH_REG_*` constants are not in this snippet, so acknowledge that.## frida-tools/agents/itracer/itracer_agent.js 源代码功能分析 (第 2 部分)

这是 frida 动态插桩工具 `itracer_agent.js` 源代码文件的第二部分，主要包含以下功能：

**1. JSON 数据构建辅助函数:**

* **`add_meta_string`，`add_meta_int`，`add_block_write_meta`:**  这些函数用于向 `JsonBuilder` 对象添加不同类型的数据，以构建 JSON 格式的元数据。
    * `add_meta_string`: 添加字符串类型的元数据，例如键值对。
    * `add_meta_int`: 添加整数类型的元数据。
    * `add_block_write_meta`: 添加表示代码块写入的元数据，可能包含块的偏移和 CPU 上下文偏移。

* **`add_memory_address`:** 将内存地址（`GumAddress` 类型）格式化为 "0x..." 形式的字符串，并添加到 `JsonBuilder` 中。

* **`make_json`:**  接收一个指向 `JsonBuilder` 的指针，将其转换为 JSON 字符串，并释放相关的内存。这是一个工具函数，用于最终生成 JSON 数据。

**2. ARM64 寄存器处理函数:**

* **`pick_scratch_register`:**  **核心功能：选择一个可用的 "scratch" 寄存器。**  在动态插桩过程中，为了避免覆盖目标程序正在使用的寄存器，需要临时使用一些寄存器来执行注入的代码。这个函数通过检查指令读取和写入的寄存器列表 (`regs_read`, `regs_written`)，从预定义的 "scratch" 寄存器列表中选择一个当前未被使用的寄存器。
    * **涉及到二进制底层：** 该函数直接操作 ARM64 架构的寄存器。 `arm64_reg` 是表示 ARM64 寄存器的类型。 `cs_regs` 可能是 Capstone 反汇编库中表示寄存器数组的类型。
    * **逻辑推理：** 假设 `SCRATCH_REG_TOP` 和 `SCRATCH_REG_BOTTOM` 定义了可作为 scratch 寄存器的范围。函数从高到低遍历这些寄存器，检查是否在 `regs_read` 或 `regs_written` 列表中出现，如果都没有出现，则认为该寄存器可用并返回。
    * **假设输入与输出：**
        * **输入：**  `regs_read` (例如: `[ARM64_REG_X0, ARM64_REG_LR]`), `num_regs_read` (2), `regs_written` (例如: `[ARM64_REG_X1]`), `num_regs_written` (1)。
        * **输出：** 如果 `ARM64_REG_X2` 不在 `regs_read` 和 `regs_written` 中，则返回 `ARM64_REG_X2` (假设 `SCRATCH_REG_TOP` 大于等于 `ARM64_REG_X2`)。

* **`register_to_full_size_register`:** **核心功能：将可能缩写的寄存器名称转换为其完整大小的寄存器名称。**  例如，将 `W0` 转换为 `X0`，`S0` 转换为 `Q0`。这是因为在 ARM64 架构中，同一个物理寄存器可以有不同大小的别名 (例如 Xn 是 64 位，Wn 是 32 位)。
    * **涉及到二进制底层：** 直接操作 ARM64 架构的寄存器。
    * **假设输入与输出：**
        * **输入：** `ARM64_REG_W10`
        * **输出：** `ARM64_REG_X10`
        * **输入：** `ARM64_REG_SP`
        * **输出：** `ARM64_REG_SP` (本身就是全尺寸寄存器)

* **`emit_scratch_register_restore`:** **核心功能：生成 ARM64 汇编指令以恢复 scratch 寄存器的值。** 在使用 scratch 寄存器执行完注入代码后，需要将其值恢复到原始状态，以避免影响目标程序的正常执行。
    * **涉及到二进制底层：**  使用 Frida 的 Gum 库 (`gum_arm64_writer_put_ldr_reg_reg_offset`) 生成 ARM64 的 `ldr` 指令。
    * **逻辑推理：** 该函数假定 scratch 寄存器的原始值被保存在 `ITraceSession` 结构体的 `scratch_regs` 成员中，并根据寄存器编号计算偏移量 (`SCRATCH_REG_OFFSET`)，生成 `ldr` 指令将值从内存中加载回寄存器。

**3. 缓冲区写入实现 (`emit_buffer_write_impl`):**

* **核心功能：生成用于将数据写入缓冲区的 ARM64 汇编代码。** 这段代码非常复杂，包含了保存和恢复寄存器、检查缓冲区空间、执行内存拷贝等操作。
    * **涉及到二进制底层，linux内核：**
        * **二进制底层：**  函数内部直接嵌入了大量的 ARM64 汇编指令的机器码 (以十六进制表示)。这些指令直接操作 CPU 寄存器和内存。 例如 `0x9108a39bU` 是 `add x27, x28, 0x228` 的机器码。
        * **linux内核 (推测)：** 代码中可能涉及到原子操作，例如 `ldaxr` (load-acquire exclusive register) 和 `stlxr` (store-release exclusive register)，这是为了在多线程环境下安全地更新共享的缓冲区状态，防止数据竞争。这些原子操作通常由 CPU 硬件支持，并与内核的同步机制配合使用。
    * **逻辑推理：**
        * 代码首先保存一系列通用寄存器 (x24, x23, ..., x0) 和状态寄存器 (nzcv) 到栈上 (相对于 x27)。
        * 然后从 `x28` 指向的内存位置加载一些控制信息，例如缓冲区头尾指针。
        * 接下来是一段复杂的逻辑，用于检查缓冲区是否有足够的空间来写入新的数据。这部分可能涉及到环形缓冲区的处理，需要判断写入是否会跨越缓冲区的末尾。
        * 如果空间足够，则使用 `memcpy` (或者自定义的 `itrace_memcpy`) 将数据拷贝到缓冲区。
        * 最后，代码恢复之前保存的寄存器和状态。
    * **lldb 指令复刻示例 (部分功能)：** 假设你想观察 `emit_buffer_write_impl` 中保存寄存器的行为：
        ```lldb
        # 假设执行到 `emit_buffer_write_impl` 生成的代码处
        register read x27  # 查看 x27 的值，它被用作栈指针的基址
        memory read -s 8 -c 16 $x27  # 查看 x27 指向的栈上的数据，应该会看到被保存的寄存器值
        ```
    * **lldb python 脚本复刻示例 (部分功能 - 假设已知 `itrace_memcpy` 的地址)：**
        ```python
        import lldb

        def memcpy_probe(frame, bp_loc, dict):
            thread = frame.GetThread()
            process = thread.GetProcess()

            dest_addr = frame.FindRegister("x0").GetValueAsUnsigned()
            src_addr = frame.FindRegister("x1").GetValueAsUnsigned()
            count = frame.FindRegister("x2").GetValueAsUnsigned()

            print(f"itrace_memcpy called: dest=0x{dest_addr:x}, src=0x{src_addr:x}, count={count}")

        def __lldb_init_module(debugger, internal_dict):
            command_script = """
            b itrace_memcpy
            breakpoint command add -F memcpy_probe
            """
            debugger.HandleCommand(command_script)
        ```
        这个 Python 脚本会在 `itrace_memcpy` 函数被调用时打印其参数。

**4. 错误处理 (`panic`):**

* **核心功能：报告错误并终止执行。** 当发生严重错误时，调用此函数来生成包含错误信息的字符串，并调用 `on_panic` 回调函数 (该回调函数在 `itracer_agent.js` 的其他部分定义)。
    * **用户或编程常见的使用错误：** 如果 Frida Agent 的配置不正确，例如无法分配足够的内存，或者在插桩过程中遇到意外情况导致程序状态异常，就可能触发 `panic`。
    * **说明用户操作是如何一步步的到达这里，作为调试线索：**
        1. 用户编写了一个 Frida 脚本，并使用 `frida -p <pid> <script.js>` 或 `frida <application_name> <script.js>` 将其附加到目标进程。
        2. 脚本中可能使用了 `Interceptor` 或 `Stalker` 等 Frida API 来监控目标程序的执行。
        3. 在监控过程中，`itracer_agent.js` 被 Frida 加载并执行。
        4. 如果 `itracer_agent.js` 在其内部逻辑中检测到不一致性或错误 (例如，内存分配失败，预期的代码模式未找到)，它会调用 `panic` 函数。
        5. `panic` 函数会调用 `on_panic`，该回调函数会将错误信息传递回用户编写的 Frida 脚本，用户可以在脚本中处理或打印错误信息。

**功能归纳 (针对第二部分):**

这部分代码主要关注以下几个方面，为 `itracer_agent.js` 提供了底层支持：

1. **数据序列化:**  提供将内部数据结构转换为 JSON 格式的工具函数，用于向外部报告跟踪结果或其他元数据。
2. **ARM64 架构适配:** 包含处理 ARM64 寄存器的函数，包括选择临时寄存器和进行寄存器名称转换，确保注入代码的正确执行。
3. **代码生成:**  实现了核心的缓冲区写入逻辑，通过生成底层的 ARM64 汇编代码，高效地将跟踪数据写入共享内存缓冲区。
4. **错误处理:**  提供基本的错误报告机制，用于在内部发生错误时通知外部。

总的来说，这部分代码是 `itracer_agent.js` 中与底层架构和数据处理密切相关的核心组件，确保了跟踪数据的准确捕获和高效存储。

### 提示词
```
这是目录为frida/build/subprojects/frida-tools/agents/itracer/itracer_agent.js的frida Dynamic instrumentation tool的源代码文件， 请列举一下它的功能, 
如果涉及到二进制底层，linux内核，请做出对应的举例说明，
请给出用lldb指令或者lldb python脚本，用来复刻的源代码所实现调试功能的示例，如果源代码是调试功能的实现。
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索，
请用中文回复。
这是第2部分，共2部分，请归纳一下它的功能
```

### 源代码
```javascript
e (meta, "size");\n  json_builder_add_int_value (meta, size);\n\n  json_builder_end_object (meta);\n}\n\nstatic void\nadd_block_write_meta (JsonBuilder * meta,\n                      guint block_offset,\n                      guint cpu_ctx_offset)\n{\n  json_builder_begin_array (meta);\n  json_builder_add_int_value (meta, block_offset);\n  json_builder_add_int_value (meta, cpu_ctx_offset);\n  json_builder_end_array (meta);\n}\n\nstatic void\nadd_memory_address (JsonBuilder * builder,\n                    GumAddress address)\n{\n  gchar * str = g_strdup_printf ("0x%" G_GINT64_MODIFIER "x", address);\n  json_builder_add_string_value (builder, str);\n  g_free (str);\n}\n\nstatic gchar *\nmake_json (JsonBuilder ** builder)\n{\n  JsonBuilder * b = *builder;\n  *builder = NULL;\n\n  JsonNode * node = json_builder_get_root (b);\n  gchar * json = json_to_string (node, FALSE);\n  json_node_unref (node);\n\n  g_object_unref (b);\n\n  return json;\n}\n\nstatic arm64_reg\npick_scratch_register (cs_regs regs_read,\n                       uint8_t num_regs_read,\n                       cs_regs regs_written,\n                       uint8_t num_regs_written)\n{\n  arm64_reg candidate;\n\n  for (candidate = SCRATCH_REG_TOP; candidate != SCRATCH_REG_BOTTOM - 1; candidate--)\n  {\n    gboolean available = TRUE;\n\n    for (uint8_t i = 0; i != num_regs_read; i++)\n    {\n      if (regs_read[i] == candidate)\n      {\n        available = FALSE;\n        break;\n      }\n    }\n    if (!available)\n      continue;\n\n    for (uint8_t i = 0; i != num_regs_written; i++)\n    {\n      if (regs_written[i] == candidate)\n      {\n        available = FALSE;\n        break;\n      }\n    }\n    if (!available)\n      continue;\n\n    break;\n  }\n\n  return candidate;\n}\n\nstatic arm64_reg\nregister_to_full_size_register (arm64_reg reg)\n{\n  switch (reg)\n  {\n    case ARM64_REG_SP:\n    case ARM64_REG_FP:\n    case ARM64_REG_LR:\n    case ARM64_REG_NZCV:\n    case ARM64_REG_XZR:\n    case ARM64_REG_WZR:\n      return reg;\n  }\n\n  if (reg >= ARM64_REG_X0 && reg <= ARM64_REG_X28)\n    return reg;\n  if (reg >= ARM64_REG_W0 && reg <= ARM64_REG_W28)\n    return ARM64_REG_X0 + (reg - ARM64_REG_W0);\n  if (reg == ARM64_REG_W29)\n    return ARM64_REG_FP;\n  if (reg == ARM64_REG_W30)\n    return ARM64_REG_LR;\n\n  if (reg >= ARM64_REG_Q0 && reg <= ARM64_REG_Q31)\n    return reg;\n  if (reg >= ARM64_REG_V0 && reg <= ARM64_REG_V31)\n    return ARM64_REG_Q0 + (reg - ARM64_REG_V0);\n  if (reg >= ARM64_REG_D0 && reg <= ARM64_REG_D31)\n    return ARM64_REG_Q0 + (reg - ARM64_REG_D0);\n  if (reg >= ARM64_REG_S0 && reg <= ARM64_REG_S31)\n    return ARM64_REG_Q0 + (reg - ARM64_REG_S0);\n  if (reg >= ARM64_REG_H0 && reg <= ARM64_REG_H31)\n    return ARM64_REG_Q0 + (reg - ARM64_REG_H0);\n  if (reg >= ARM64_REG_B0 && reg <= ARM64_REG_B31)\n    return ARM64_REG_Q0 + (reg - ARM64_REG_B0);\n\n  return reg;\n}\n\nstatic void\nemit_scratch_register_restore (GumArm64Writer * cw,\n                               arm64_reg reg)\n{\n  gum_arm64_writer_put_ldr_reg_reg_offset (cw, reg,\n      reg, G_STRUCT_OFFSET (ITraceSession, scratch_regs) + SCRATCH_REG_OFFSET (reg));\n}\n\nstatic void\nemit_buffer_write_impl (GumArm64Writer * cw)\n{\n  static const guint32 write_impl[] = {\n    0x9108a39bU, /* add x27, x28, 0x228         */\n\n    0xa9b75f78U, /* stp x24, x23, [x27, -0x90]! */\n    0xa9015776U, /* stp x22, x21, [x27, 0x10]   */\n    0xa9024f74U, /* stp x20, x19, [x27, 0x20]   */\n    0xa9032f6cU, /* stp x12, x11, [x27, 0x30]   */\n    0xa904276aU, /* stp x10, x9, [x27, 0x40]    */\n    0xa9050b68U, /* stp x8, x2, [x27, 0x50]     */\n    0xa9060361U, /* stp x1, x0, [x27, 0x60]     */\n    0xa9077b7dU, /* stp x29, x30, [x27, 0x70]   */\n    0x9101c37dU, /* add x29, x27, 0x70          */\n\n    0xd53b4200U, /* mrs x0, nzcv                */\n    0xf9004360U, /* str x0, [x27, 0x80]         */\n\n    0xf9400793U, /* ldr x19, [x28, 8]           */\n\n    0xf9400b94U, /* ldr x20, [x28, 0x10]        */\n    0x9109a395U, /* add x21, x28, 0x268         */\n\n    0xf9400668U, /* ldr x8, [x19, 8]            */\n    0xf9400e69U, /* ldr x9, [x19, 0x18]         */\n    0xc8dffe6aU, /* ldar x10, [x19]             */\n    0xeb08015fU, /* cmp x10, x8                 */\n    0x54000081U, /* b.ne not_empty              */\n    0xf9400e6aU, /* ldr x10, [x19, 0x18]        */\n    0xd100054aU, /* sub x10, x10, 1             */\n    0x14000008U, /* b check_headroom            */\n    /* not_empty:                               */\n    0x540000a2U, /* b.hs tail_has_wrapped       */\n    0xf9400e6bU, /* ldr x11, [x19, 0x18]        */\n    0xaa2803ecU, /* mvn x12, x8                 */\n    0x8b0c014aU, /* add x10, x10, x12           */\n    0x14000002U, /* b compute_final_headroom    */\n    /* tail_has_wrapped:                        */\n    0xaa2803ebU, /* mvn x11, x8                 */\n    /* compute_final_headroom:                  */\n    0x8b0b014aU, /* add x10, x10, x11           */\n    /* check_headroom:                          */\n    0xeb14015fU, /* cmp x10, x20                */\n    0x540000e2U, /* b.hs sufficient_headroom    */\n    0x91004268U, /* add x8, x19, 0x10           */\n    /* retry:                                   */\n    0xc85ffd09U, /* ldaxr x9, [x8]              */\n    0x91000529U, /* add x9, x9, 1               */\n    0xc80afd09U, /* stlxr w10, x9, [x8]         */\n    0x35ffffaaU, /* cbnz w10, retry             */\n    0x14000018U, /* b beach                     */\n    /* sufficient_headroom:                     */\n    0x8b14010aU, /* add x10, x8, x20            */\n    0x9ac9094bU, /* udiv x11, x10, x9           */\n    0x9b09a978U, /* msub x24, x11, x9, x10      */\n    0xeb08031fU, /* cmp x24, x8                 */\n    0x540000c9U, /* b.ls copy_with_wrap         */\n    0x8b080268U, /* add x8, x19, x8             */\n    0x91008100U, /* add x0, x8, 0x20            */\n    0xaa1503e1U, /* mov x1, x21                 */\n    0xaa1403e2U, /* mov x2, x20                 */\n    0x1400000bU, /* b do_memcpy                 */\n    /* copy_with_wrap:                          */\n    0xf9400e69U, /* ldr x9, [x19, 0x18]         */\n    0xcb080136U, /* sub x22, x9, x8             */\n    0x91008277U, /* add x23, x19, 0x20          */\n    0x8b0802e0U, /* add x0, x23, x8             */\n    0xaa1503e1U, /* mov x1, x21                 */\n    0xaa1603e2U, /* mov x2, x22                 */\n    0x94000012U, /* bl itrace_memcpy            */\n    0x8b1602a1U, /* add x1, x21, x22            */\n    0xcb160282U, /* sub x2, x20, x22            */\n    0xaa1703e0U, /* mov x0, x23                 */\n    /* do_memcpy:                               */\n    0x9400000eU, /* bl itrace_memcpy            */\n    0x91002268U, /* add x8, x19, 8              */\n    0xc89ffd18U, /* stlr x24, [x8]              */\n    /* beach:                                   */\n    0xf9404360U, /* ldr x0, [x27, 0x80]         */\n    0xd51b4200U, /* msr nzcv, x0                */\n\n    0xa9477b7dU, /* ldp x29, x30, [x27, 0x70]   */\n    0xa9460361U, /* ldp x1, x0, [x27, 0x60]     */\n    0xa9450b68U, /* ldp x8, x2, [x27, 0x50]     */\n    0xa944276aU, /* ldp x10, x9, [x27, 0x40]    */\n    0xa9432f6cU, /* ldp x12, x11, [x27, 0x30]   */\n    0xa9424f74U, /* ldp x20, x19, [x27, 0x20]   */\n    0xa9415776U, /* ldp x22, x21, [x27, 0x10]   */\n    0xa8c95f78U, /* ldp x24, x23, [x27], 0x90   */\n\n    0xd65f03c0U, /* ret                         */\n\n    /* itrace_memcpy:                           */\n    0xd343fc48U, /* lsr x8, x2, 3               */\n    0xb40000a8U, /* cbz x8, beach2              */\n    0xf8408429U, /* ldr x9, [x1], 8             */\n    0xf8008409U, /* str x9, [x0], 8             */\n    0xd1000508U, /* sub x8, x8, 1               */\n    0xb5ffffa8U, /* cbnz x8, again              */\n    /* beach2:                                  */\n    0xd65f03c0U, /* ret                         */\n  };\n\n  gum_arm64_writer_put_bytes (cw, (const guint8 *) write_impl, sizeof (write_impl));\n}\n\nstatic void\npanic (const char * format,\n       ...)\n{\n  va_list args;\n  va_start (args, format);\n  gchar * message = g_strdup_vprintf (format, args);\n  va_end (args);\n\n  on_panic (message);\n\n  g_free (message);\n}\n';
✄
{"version":3,"file":"index.js","names":["_TraceSession_instances","_TraceSession_cm","_TraceSession_threadId","_TraceSession_followThread","_TraceSession_onStart","_TraceSession_onEnd","_TraceSession_onCompile","_TraceSession_onPanic","_TraceBufferReader_chunkBuf","_TraceBufferReader_chunkSize","_TraceBufferReader_emptyBuffer","_TraceBufferReader_lost","__classPrivateFieldGet","this","receiver","state","kind","f","TypeError","has","call","value","get","__classPrivateFieldSet","set","backend","EventEmitter","POINTER_SIZE","Process","pointerSize","BUFFER_OFFSET_LOST","BUFFER_OFFSET_CAPACITY","_bufferRead","machineCodeTemplate","code","Memory","alloc","pageSize","patchCode","length","codeBuf","writeByteArray","add","writePointer","Module","getExportByName","read","NativeFunction","exceptions","Object","defineProperty","makeBufferReadImpl","getDarwinApi","compute","computed","args","memoize","NF","spec","port","readU32","reduce","api","entry","name","configurable","impl","resolve","Ctor","retType","argTypes","address","findExportByName","nativeOpts","addApiPlaceholder","TraceSession","constructor","strategy","buffer","events","metaJson","cpuContext","specs","JSON","parse","readUtf8String","values","readByteArray","emit","setImmediate","Stalker","unfollow","block","ptr","compiled","module","undefined","base","messagePtr","message","nativeSession","regionBase","endBuf","type","end","CModule","session","end_address","on_start","NativeCallback","on_end","on_compile","on_panic","open","threadId","Interceptor","attach","start","WeakMap","WeakSet","follow","transform","TraceBuffer","location","pid","id","regionSize","stringify","static","config","stateSize","capacity","size","offset","roundUpToPageSize","nativeBuffer","platform","Error","self","mach_task_self","taskBuf","checkKernResult","task_for_pid","task","targetAddress","curProtection","maxProtection","mach_vm_remap","uint64","localRegionBase","readU64","toString","Script","bindWeak","deallocateDarwinRegion","bind","mach_port_deallocate","TraceBufferReader","lost","readPointer","toUInt32","ArrayBuffer","chunkSize","n","mach_vm_deallocate","kr"],"sourceRoot":"/root/frida/build/subprojects/frida-tools/agents/itracer/itracer_agent.js.p/node_modules/frida-itrace/dist/","sources":[""],"mappings":"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"}
✄
var e,t,r,n,i,o,a,s,c,d,l,f,p=this&&this.__classPrivateFieldGet||function(e,t,r,n){if("a"===r&&!n)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!n:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===r?n:"a"===r?n.call(e):n?n.value:t.get(e)},h=this&&this.__classPrivateFieldSet||function(e,t,r,n,i){if("m"===n)throw new TypeError("Private method is not writable");if("a"===n&&!i)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof t?e!==t||!i:!t.has(e))throw new TypeError("Cannot write private member to an object whose class did not declare it");return"a"===n?i.call(e,r):i?i.value=r:t.set(e,r),r};import*as u from"./backend.js";import m from"events";const w=Process.pointerSize,v=2*w,_=3*w,y=function(){const e=[248,95,188,169,246,87,1,169,244,79,2,169,253,123,3,169,253,195,0,145,24,0,64,249,8,32,0,145,8,253,223,200,8,1,24,235,97,0,0,84,20,0,128,210,32,0,0,20,245,3,1,170,243,3,0,170,9,1,0,84,31,1,2,235,20,49,130,154,104,2,24,139,1,129,0,145,224,3,21,170,226,3,20,170,15,0,0,20,105,14,64,249,8,1,9,139,31,1,2,235,20,49,130,154,54,1,24,203,119,130,0,145,225,2,24,139,224,3,21,170,226,3,22,170,126,2,0,88,192,3,63,214,160,2,22,139,130,2,22,203,225,3,23,170,222,1,0,88,192,3,63,214,136,2,24,139,105,14,64,249,10,9,201,154,72,161,9,155,104,254,159,200,224,3,20,170,253,123,67,169,244,79,66,169,246,87,65,169,248,95,196,168,192,3,95,214,0,0,0,0,18,52,86,120,154,188,222,255],t=Memory.alloc(Process.pageSize);Memory.patchCode(t,e.length,(t=>{t.writeByteArray(e),t.add(e.length-w).writePointer(Module.getExportByName(null,"memcpy"))}));const r=new NativeFunction(t,"uint",["pointer","pointer","uint"],{exceptions:"propagate"});return Object.defineProperty(r,"$code",{value:t}),r}(),g=function(e){let t,r=!1;return function(...n){return r||(t=e(...n),r=!0),t}}((function(){const e=NativeFunction;return t=[["mach_task_self",()=>{const e=Module.getExportByName(null,"mach_task_self_").readU32();return()=>e}],["mach_port_deallocate",e,"int",["uint","uint"]],["task_for_pid",e,"int",["uint","int","pointer"]],["mach_vm_remap",e,"int",["uint","pointer","size_t","size_t","int","uint","uint64","uint","pointer","pointer","uint"]],["mach_vm_deallocate",e,"int",["uint","uint64","uint64"]]],t.reduce(((e,t)=>(function(e,t){const[r]=t;Object.defineProperty(e,r,{configurable:!0,get(){let n=null;if(2===t.length){const[,e]=t;n=e()}else{const[,e,i,o]=t,a=Module.findExportByName(null,r);null!==a&&(n=new e(a,i,o,M))}return Object.defineProperty(e,r,{value:n}),n}})}(e,t),e)),{});var t}));export class TraceSession{constructor(n,c){e.add(this),this.strategy=n,this.buffer=c,this.events=new m,t.set(this,void 0),r.set(this,void 0),i.set(this,((e,t,r)=>{const n=JSON.parse(e.readUtf8String()),i=t.readByteArray(r);this.events.emit("start",n,i)})),o.set(this,(()=>{setImmediate((()=>{Stalker.unfollow(p(this,r,"f")),this.events.emit("end")}))})),a.set(this,(e=>{const t=JSON.parse(e.readUtf8String());t.address=ptr(t.address);const r=t.compiled;r.address=ptr(r.address);const n=t.module;void 0!==n&&(n.base=ptr(n.base)),this.events.emit("compile",t)})),s.set(this,(e=>{const t=e.readUtf8String();this.events.emit("panic",t)}));const d=Memory.alloc(16384);d.add(w).writePointer(c.regionBase);const l=Memory.alloc(w);"range"===n.type&&l.writePointer(n.end),h(this,t,new CModule(u.code,{session:d,end_address:l,on_start:new NativeCallback(p(this,i,"f"),"void",["pointer","pointer","uint"]),on_end:new NativeCallback(p(this,o,"f"),"void",[]),on_compile:new NativeCallback(p(this,a,"f"),"void",["pointer"]),on_panic:new NativeCallback(p(this,s,"f"),"void",["pointer"])}),"f")}open(){const{strategy:t}=this;if("thread"===t.type)p(this,e,"m",n).call(this,t.threadId);else{const i=this;Interceptor.attach(t.start,(function(){void 0===p(i,r,"f")&&p(i,e,"m",n).call(i,this.threadId)}))}}}t=new WeakMap,r=new WeakMap,i=new WeakMap,o=new WeakMap,a=new WeakMap,s=new WeakMap,e=new WeakSet,n=function(e){h(this,r,e,"f"),Stalker.follow(e,{transform:p(this,t,"f").transform})};export class TraceBuffer{get location(){const e=Process.id,{regionBase:t,regionSize:r}=this;return JSON.stringify({pid:e,regionBase:t,regionSize:r})}constructor(e,t){this.regionBase=e,this.regionSize=t}static create(e={}){const t=4*w,r=e.capacity??33554432,n=function(e){const{pageSize:t}=Process,r=e%t;return 0===r?e:e+(t-r)}(t+r),i=Memory.alloc(n);return i.add(_).writePointer(ptr(r)),new TraceBuffer(i,n)}static open(e){if("darwin"!==Process.platform)throw new Error("shared memory is only supported on Darwin for now");const{pid:t,regionBase:r,regionSize:n}=JSON.parse(e),i=g(),o=i.mach_task_self(),a=Memory.alloc(4);S("task_for_pid",i.task_for_pid(o,t,a));const s=a.readU32();try{const e=Memory.alloc(16),t=e.add(8),a=t.add(4);S("mach_vm_remap",i.mach_vm_remap(o,e,n,0,1,s,uint64(r),0,t,a,2));const c=ptr(e.readU64().toString()),d=new TraceBuffer(c,n);return Script.bindWeak(d,k.bind(null,c,n)),d}finally{i.mach_port_deallocate(o,s)}}}export class TraceBufferReader{get lost(){return p(this,f,"f").readPointer().toUInt32()}constructor(e,t={}){this.buffer=e,c.set(this,void 0),d.set(this,void 0),l.set(this,new ArrayBuffer(0)),f.set(this,void 0);const r=t.chunkSize??4194304;h(this,c,Memory.alloc(r),"f"),h(this,d,r,"f"),h(this,f,e.regionBase.add(v),"f")}read(){const e=y(this.buffer.regionBase,p(this,c,"f"),p(this,d,"f"));return 0===e?p(this,l,"f"):p(this,c,"f").readByteArray(e)}}function k(e,t){const r=g();r.mach_vm_deallocate(r.mach_task_self(),uint64(e.toString()),t)}function S(e,t){if(0!==t)throw new Error(`${e}() failed (kr=${t})`)}c=new WeakMap,d=new WeakMap,l=new WeakMap,f=new WeakMap;const M={exceptions:"propagate"};
```
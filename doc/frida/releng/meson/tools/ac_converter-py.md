Response:
Let's break down the thought process for analyzing this Python script.

1. **Understanding the Goal:** The first step is to read the script's docstring and comments to grasp its primary purpose. The help message clearly states it converts `config.h.meson` files (derived from `config.h.in`) into Meson declarations by identifying header and function checks. The comment about `#undef` being replaced by `#mesondefine` is also key.

2. **Identifying Key Data Structures:**  The script uses a dictionary `function_data` which maps preprocessor macros (like `HAVE_MMAP`) to function names and the headers where those functions are declared. This is crucial for understanding how function checks are performed. The lists `headers`, `functions`, and `sizes` are where the extracted information is stored.

3. **Analyzing the Processing Logic:**  The core logic lies within the `with open(...)` block. It iterates through each line of the input file and performs three main checks:
    * **Header Checks:**  Looks for lines starting with `#mesondefine` and ending with `_H`. This pattern signifies a header availability check. It extracts the header name.
    * **Function Checks:**  Looks for lines where the second word is a key in the `function_data` dictionary or starts with `HAVE_`. It extracts information about the function and its required header (if available in `function_data`).
    * **Sizeof Checks:**  Looks for lines with two words where the second word starts with `SIZEOF_`. It parses the type name from this token.

4. **Understanding the Output Generation:** The script then prints Meson code to the standard output. This code uses Meson's `cc.has_header`, `cc.has_function`, and `cc.sizeof` functions to perform the actual checks during the Meson configuration stage. The results are stored in a `configuration_data` object.

5. **Connecting to Reverse Engineering:** Now, the connection to reverse engineering needs to be made. The key here is the concept of *feature detection*. Reverse engineers often need to understand the capabilities and dependencies of a compiled binary. This script helps *determine* those capabilities during the build process, which is valuable information. If a reverse engineer has access to the build system or the generated Meson files, they can see what features were enabled.

6. **Considering Binary/OS Level Details:**  Many of the functions listed in `function_data` are system calls or standard library functions interacting directly with the operating system kernel (Linux, Android). Examples like `mmap`, `fork`, `pthread_create`, `socket`, and file system operations clearly indicate interaction with the OS. Understanding the availability of these functions is essential for understanding the binary's OS-level interactions.

7. **Logical Inference (Input/Output):**  Thinking about input and output requires constructing a simplified example. A minimal `config.h.meson` with a header and function check is a good starting point. Then, manually trace how the script would process it and what the corresponding Meson output would be.

8. **Identifying Common Errors:**  User errors often occur due to misunderstanding the input format or the script's limitations. Not replacing `#undef` with `#mesondefine` is a prime example. Providing an incorrect file path is another common mistake.

9. **Tracing User Operations (Debugging):** To understand how a user might end up running this script, consider the typical software development/build process involving autotools or similar systems. The script's docstring itself hints at the workflow: generating `config.h.in`, running `configure`, and then using this script to convert the resulting `config.h.meson`.

10. **Refinement and Structuring:** After the initial analysis, organize the information into the requested categories: functionality, relation to reverse engineering, OS-level details, logical inference, user errors, and debugging clues. Use concrete examples where possible.

**Self-Correction/Refinement during the process:**

* **Initial thought:** "This just converts files."  **Correction:**  It's not just a simple conversion. It *interprets* the contents of `config.h.meson` to extract specific information about system capabilities.
* **Initial thought:** "Reverse engineering doesn't directly use this." **Correction:**  While reverse engineers don't *run* this script on a target binary, the *information* generated by this script (or similar build systems) is valuable for understanding the target.
* **Focus on specific examples:** Instead of just saying "OS interaction," list concrete examples of functions that interact with the OS kernel.
* **Clarity on the "why":** Explain *why* knowing about the availability of these functions is important for reverse engineering.

By following these steps and refining the analysis along the way, we can generate a comprehensive and accurate explanation of the script's functionality and its relevance to various aspects of software development and analysis.
好的，让我们来详细分析一下 `frida/releng/meson/tools/ac_converter.py` 这个 Python 脚本的功能及其与你提到的各个方面的关联。

**脚本功能概览**

`ac_converter.py` 的主要功能是将一种中间格式的配置文件 `config.h.meson` 转换成 Meson 构建系统能够理解的配置声明。  这个 `config.h.meson` 文件通常是由传统的 `configure` 脚本生成的 `config.h.in` 文件修改而来。

具体来说，该脚本会读取 `config.h.meson` 文件，从中识别出：

1. **头文件检查 (Header Checks):**  判断系统中是否存在特定的头文件。
2. **函数检查 (Function Checks):** 判断系统中是否存在特定的函数。
3. **类型大小检查 (Sizeof Checks):**  确定特定数据类型的大小。

然后，它会生成相应的 Meson 代码，这些代码在 Meson 构建过程中会被执行，以确定编译时需要使用的各种特性和配置。

**与逆向方法的关联及举例说明**

此脚本本身不是一个直接的逆向工具，但它生成的配置信息对于逆向工程非常有用。

* **了解目标程序的依赖:**  通过分析 `config.h.meson` 或脚本生成的 Meson 代码，逆向工程师可以了解目标程序依赖哪些系统头文件和库函数。这有助于理解程序的底层实现和可能使用的系统 API。
    * **举例:**  如果 `config.h.meson` 中有 `#mesondefine HAVE_SYS_MMAN_H`, 对应的 Meson 代码会检查 `sys/mman.h` 的存在。逆向工程师可以推断出目标程序可能使用了与内存管理相关的系统调用，如 `mmap` 或 `mprotect`。
    * **进一步举例:** 如果检查了 `HAVE_PTHREAD_CREATE`,  逆向工程师知道目标程序很可能使用了 POSIX 线程，需要关注线程同步和通信机制。

* **识别目标程序可能使用的系统特性:**  函数检查揭示了程序可能调用的系统函数。这对于理解程序的行为和可能的漏洞点至关重要。
    * **举例:**  如果检查了 `HAVE_SOCKET`, 逆向工程师会知道程序可能涉及网络通信，需要分析网络协议和数据包。
    * **进一步举例:** 如果检查了 `HAVE_DLOPEN`, 则表明程序可能具有动态链接库加载的能力，逆向工程师需要关注插件机制或动态加载的代码。

* **理解数据结构布局:**  `SIZEOF_` 相关的检查可以帮助逆向工程师理解目标程序中使用的数据结构的大小。这在分析二进制数据或进行内存取证时非常重要。
    * **举例:** 如果 `config.h.meson` 中有 `SIZEOF_INT`, 脚本会生成 Meson 代码来获取 `int` 类型的大小。逆向工程师可以知道程序中 `int` 类型变量占用多少字节。

**涉及二进制底层、Linux、Android 内核及框架的知识及举例说明**

脚本中涉及的很多头文件和函数都直接关联到操作系统的底层。

* **二进制底层:** `SIZEOF_` 相关的检查直接关系到不同架构下数据类型在内存中的表示大小。例如，`int` 在 32 位和 64 位系统上可能占用不同的大小。

* **Linux 内核:**  许多被检查的函数都是 Linux 系统调用或 glibc 提供的封装函数，它们直接与 Linux 内核交互。
    * **举例:**
        * `mmap` 和 `mprotect` (内存管理):  直接与 Linux 内核的虚拟内存管理子系统交互。Frida 这样的动态插桩工具在进行代码注入或 hook 时会频繁使用这些系统调用。
        * `fork` (进程创建):  是 Linux 创建新进程的基本方式。Frida 在某些场景下可能会 fork 子进程来执行某些操作。
        * `socket` (网络编程):  用于创建网络套接字，进行网络通信。Frida Agent 与 Frida Server 的通信可能就使用了 socket。
        * `epoll_create1` (I/O 多路复用):  一种高效的 I/O 事件通知机制，常用于高性能网络编程。Frida 的某些组件可能使用了 epoll 来监听事件。
        * `inotify_init1` (文件系统事件监控):  用于监控文件系统事件。Frida 可能会使用它来监控目标进程加载的库或访问的文件。

* **Android 内核及框架:** 虽然脚本本身没有明确针对 Android，但其中一些函数和概念也适用于 Android。Android 底层是基于 Linux 内核的，因此许多 Linux 系统调用在 Android 上也存在。
    * **举例:** `mmap`, `socket`, `pthread_create` 等在 Android 上同样适用。
    * **框架层面:**  虽然脚本不直接涉及 Android 框架的 Java 或 Kotlin 代码，但理解这些底层系统调用的使用对于分析 Native 代码层面的 Android 组件（例如，系统服务、HAL 层）至关重要。

**逻辑推理、假设输入与输出**

脚本进行了一些基本的逻辑推理，基于输入文件中的 `#mesondefine` 指令和 `HAVE_` 宏来判断需要进行哪些检查。

**假设输入 `config.h.meson`:**

```meson
#mesondefine HAVE_UNISTD_H
#mesondefine HAVE_SYS_SOCKET_H
#mesondefine HAVE_PTHREAD_H
#mesondefine HAVE_MMAP
#mesondefine HAVE_GETTIMEOFDAY
SIZEOF_INT
SIZEOF_VOID_P
```

**脚本输出 (部分 Meson 代码):**

```meson
cc = meson.get_compiler('c')
cdata = configuration_data()
check_headers = [
  'unistd.h',
  'sys/socket.h',
  'pthread.h',
]

foreach h : check_headers
  if cc.has_header(h)
    cdata.set('HAVE_' + h.underscorify().to_upper(), 1)
  endif
endforeach

check_functions = [
  ['HAVE_MMAP', 'mmap', '#include<sys/mman.h>'],
  ['HAVE_GETTIMEOFDAY', 'gettimeofday', '#include<sys/time.h>'],
]

foreach f : check_functions
  if cc.has_function(f.get(1), prefix : f.get(2))
    cdata.set(f.get(0), 1)
  endif
endforeach

cdata.set('SIZEOF_INT', cc.sizeof('int'))
cdata.set('SIZEOF_VOID_P', cc.sizeof('void *'))

configure_file(input : 'config.h.meson',
  output : 'config.h',
  configuration : cdata)
```

**解释:**

* 脚本识别出 `#mesondefine HAVE_UNISTD_H` 并推断需要检查 `unistd.h` 头文件是否存在。
* 类似地，它处理了 `HAVE_SYS_SOCKET_H` 和 `HAVE_PTHREAD_H`。
* 对于 `HAVE_MMAP`，它知道对应的函数是 `mmap`，并且需要包含头文件 `<sys/mman.h>`。
* 对于 `SIZEOF_INT`，它知道需要获取 `int` 类型的大小。

**涉及用户或编程常见的使用错误及举例说明**

* **未将 `#undef` 替换为 `#mesondefine`:**  脚本的帮助信息中已经明确指出，需要手动将 `config.h.in` 中的 `#undef` 替换为 `#mesondefine`。 如果用户忘记这样做，脚本将无法正确识别需要进行的检查。
    * **错误示例 `config.h.meson`:**
      ```meson
      #undef HAVE_MMAP
      ```
    * **结果:** 脚本不会识别出需要检查 `mmap` 函数，Meson 构建系统可能因此缺少对 `mmap` 的支持。

* **输入文件路径错误:**  如果在命令行中提供的 `config.h.meson` 文件路径不正确，脚本将无法找到文件并报错。
    * **错误示例命令行:**
      ```bash
      ./ac_converter.py conifg.h.meson  # 注意 "conifg" 拼写错误
      ```
    * **结果:**  脚本会抛出 `FileNotFoundError` 异常。

* **修改了 `function_data` 但未遵循格式:**  如果用户尝试扩展脚本的功能，修改了 `function_data` 字典，但提供的元组格式不正确（例如，缺少头文件信息），会导致脚本在处理时出错。

**用户操作是如何一步步到达这里的，作为调试线索**

通常，用户不会直接手动运行 `ac_converter.py`。它通常是构建系统（如 Meson）内部工具链的一部分。以下是用户操作如何间接触发此脚本执行的步骤：

1. **获取源代码:** 用户下载或克隆了 Frida 的源代码。
2. **配置构建环境:** 用户安装了 Meson 和其他必要的构建依赖。
3. **执行构建命令:** 用户在 Frida 源代码目录下运行 Meson 的配置命令，例如 `meson setup build`。
4. **Meson 构建系统运行预处理步骤:**  Meson 会检查 `meson.build` 文件，发现需要处理配置文件。这通常涉及到将 `config.h.in` (Frida 提供的模板文件) 复制或生成为 `config.h.meson`，并可能对其进行初步的替换操作（如将 `#undef` 替换为 `#mesondefine`）。
5. **Meson 调用 `ac_converter.py`:** Meson 构建系统会执行 `ac_converter.py` 脚本，将 `config.h.meson` 转换为 Meson 可以理解的配置声明。
6. **Meson 执行配置检查:**  Meson 根据 `ac_converter.py` 生成的声明，使用编译器实际执行头文件、函数和类型大小的检查。
7. **生成 `build.ninja`:** Meson 基于配置检查的结果生成 `build.ninja` 文件，其中包含了编译所需的指令。
8. **执行编译:** 用户运行 `ninja -C build` 命令，Ninja 根据 `build.ninja` 文件执行实际的编译和链接操作。

**作为调试线索:**

* **构建失败:** 如果构建过程中出现与缺少头文件或函数相关的错误，可以检查 `config.h.meson` 文件，查看是否正确定义了相应的 `#mesondefine`。
* **配置问题:**  如果程序在运行时表现异常，可能是由于构建时的配置不正确。可以检查 Meson 的构建日志，查看 `ac_converter.py` 的输出，以及 Meson 执行的配置检查结果，以确定是否存在配置错误。
* **修改构建配置:** 如果需要为特定平台或环境调整构建配置，可能需要修改 `config.h.in` 文件，然后重新运行 Meson 配置，确保 `ac_converter.py` 能够正确处理这些修改。

总而言之，`ac_converter.py` 是 Frida 构建过程中的一个关键工具，它负责将传统的配置信息转换为 Meson 构建系统能够理解的形式，从而自动化地完成编译环境的配置。理解其功能有助于理解 Frida 的构建过程以及其对底层系统特性的依赖。

Prompt: 
```
这是目录为frida/releng/meson/tools/ac_converter.py的fridaDynamic instrumentation tool的源代码文件， 请列举一下它的功能, 
如果它与逆向的方法有关系，请做出对应的举例说明，
如果涉及到二进制底层，linux, android内核及框架的知识，请做出对应的举例说明，
如果做了逻辑推理，请给出假设输入与输出,
如果涉及用户或者编程常见的使用错误，请举例说明,
说明用户操作是如何一步步的到达这里，作为调试线索。

"""
#!/usr/bin/env python3
# SPDX-License-Identifier: Apache-2.0
# Copyright 2015 The Meson development team

help_message = """Usage: {} <config.h.meson>

This script reads config.h.meson, looks for header
checks and writes the corresponding meson declaration.

Copy config.h.in to config.h.meson, replace #undef
with #mesondefine and run this. We can't do this automatically
because some configure scripts have #undef statements
that are unrelated to configure checks.
"""

import sys


# Add stuff here as it is encountered.
function_data = \
    {'HAVE_FEENABLEEXCEPT': ('feenableexcept', 'fenv.h'),
     'HAVE_FECLEAREXCEPT': ('feclearexcept', 'fenv.h'),
     'HAVE_FEDISABLEEXCEPT': ('fedisableexcept', 'fenv.h'),
     'HAVE_MMAP': ('mmap', 'sys/mman.h'),
     'HAVE_GETPAGESIZE': ('getpagesize', 'unistd.h'),
     'HAVE_GETISAX': ('getisax', 'sys/auxv.h'),
     'HAVE_GETTIMEOFDAY': ('gettimeofday', 'sys/time.h'),
     'HAVE_MPROTECT': ('mprotect', 'sys/mman.h'),
     'HAVE_POSIX_MEMALIGN': ('posix_memalign', 'stdlib.h'),
     'HAVE_SIGACTION': ('sigaction', 'signal.h'),
     'HAVE_ALARM': ('alarm', 'unistd.h'),
     'HAVE_CTIME_R': ('ctime_r', 'time.h'),
     'HAVE_DRAND48': ('drand48', 'stdlib.h'),
     'HAVE_FLOCKFILE': ('flockfile', 'stdio.h'),
     'HAVE_FORK': ('fork', 'unistd.h'),
     'HAVE_FUNLOCKFILE': ('funlockfile', 'stdio.h'),
     'HAVE_GETLINE': ('getline', 'stdio.h'),
     'HAVE_LINK': ('link', 'unistd.h'),
     'HAVE_RAISE': ('raise', 'signal.h'),
     'HAVE_STRNDUP': ('strndup', 'string.h'),
     'HAVE_SCHED_GETAFFINITY': ('sched_getaffinity', 'sched.h'),
     'HAVE_WAITPID': ('waitpid', 'sys/wait.h'),
     'HAVE_XRENDERCREATECONICALGRADIENT': ('XRenderCreateConicalGradient', 'xcb/render.h'),
     'HAVE_XRENDERCREATELINEARGRADIENT': ('XRenderCreateLinearGradient', 'xcb/render.h'),
     'HAVE_XRENDERCREATERADIALGRADIENT': ('XRenderCreateRadialGradient', 'xcb/render.h'),
     'HAVE_XRENDERCREATESOLIDFILL': ('XRenderCreateSolidFill', 'xcb/render.h'),
     'HAVE_DCGETTEXT': ('dcgettext', 'libintl.h'),
     'HAVE_ENDMNTENT': ('endmntent', 'mntent.h'),
     'HAVE_ENDSERVENT': ('endservent', 'netdb.h'),
     'HAVE_EVENTFD': ('eventfd', 'sys/eventfd.h'),
     'HAVE_FALLOCATE': ('fallocate', 'fcntl.h'),
     'HAVE_FCHMOD': ('fchmod', 'sys/stat.h'),
     'HAVE_FCHOWN': ('fchown', 'unistd.h'),
     'HAVE_FDWALK': ('fdwalk', 'stdlib.h'),
     'HAVE_FSYNC': ('fsync', 'unistd.h'),
     'HAVE_GETC_UNLOCKED': ('getc_unlocked', 'stdio.h'),
     'HAVE_GETFSSTAT': ('getfsstat', 'sys/mount.h'),
     'HAVE_GETMNTENT_R': ('getmntent_r', 'mntent.h'),
     'HAVE_GETPROTOBYNAME_R': ('getprotobyname_r', 'netdb.h'),
     'HAVE_GETRESUID': ('getresuid', 'unistd.h'),
     'HAVE_GETVFSSTAT': ('getvfsstat', 'sys/statvfs.h'),
     'HAVE_GMTIME_R': ('gmtime_r', 'time.h'),
     'HAVE_HASMNTOPT': ('hasmntopt', 'mntent.h'),
     'HAVE_IF_INDEXTONAME': ('if_indextoname', 'net/if.h'),
     'HAVE_IF_NAMETOINDEX': ('if_nametoindex', 'net/if.h'),
     'HAVE_INOTIFY_INIT1': ('inotify_init1', 'sys/inotify.h'),
     'HAVE_ISSETUGID': ('issetugid', 'unistd.h'),
     'HAVE_KEVENT': ('kevent', 'sys/event.h'),
     'HAVE_KQUEUE': ('kqueue', 'sys/event.h'),
     'HAVE_LCHMOD': ('lchmod', 'sys/stat.h'),
     'HAVE_LCHOWN': ('lchown', 'unistd.h'),
     'HAVE_LSTAT': ('lstat', 'sys/stat.h'),
     'HAVE_MEMCPY': ('memcpy', 'string.h'),
     'HAVE_MEMALIGN': ('memalign', 'stdlib.h'),
     'HAVE_MEMMEM': ('memmem', 'string.h'),
     'HAVE_NEWLOCALE': ('newlocale', 'locale.h'),
     'HAVE_PIPE2': ('pipe2', 'fcntl.h'),
     'HAVE_POLL': ('poll', 'poll.h'),
     'HAVE_PRLIMIT': ('prlimit', 'sys/resource.h'),
     'HAVE_PTHREAD_ATTR_SETSTACKSIZE': ('pthread_attr_setstacksize', 'pthread.h'),
     'HAVE_PTHREAD_CONDATTR_SETCLOCK': ('pthread_condattr_setclock', 'pthread.h'),
     'HAVE_PTHREAD_COND_TIMEDWAIT_RELATIVE_NP': ('pthread_cond_timedwait_relative_np', 'pthread.h'),
     'HAVE_READLINK': ('readlink', 'unistd.h'),
     'HAVE_RES_INIT': ('res_init', 'resolv.h'),
     'HAVE_SENDMMSG': ('sendmmsg', 'sys/socket.h'),
     'HAVE_SOCKET': ('socket', 'sys/socket.h'),
     'HAVE_GETENV': ('getenv', 'stdlib.h'),
     'HAVE_SETENV': ('setenv', 'stdlib.h'),
     'HAVE_PUTENV': ('putenv', 'stdlib.h'),
     'HAVE_UNSETENV': ('unsetenv', 'stdlib.h'),
     'HAVE_SETMNTENT': ('setmntent', 'mntent.h'),
     'HAVE_SNPRINTF': ('snprintf', 'stdio.h'),
     'HAVE_SPLICE': ('splice', 'fcntl.h'),
     'HAVE_STATFS': ('statfs', 'mount.h'),
     'HAVE_STATVFS': ('statvfs', 'sys/statvfs.h'),
     'HAVE_STPCOPY': ('stpcopy', 'string.h'),
     'HAVE_STRCASECMP': ('strcasecmp', 'strings.h'),
     'HAVE_STRLCPY': ('strlcpy', 'string.h'),
     'HAVE_STRNCASECMP': ('strncasecmp', 'strings.h'),
     'HAVE_STRSIGNAL': ('strsignal', 'signal.h'),
     'HAVE_STRTOD_L': ('strtod_l', 'stdlib.h'),
     'HAVE_STRTOLL_L': ('strtoll_l', 'stdlib.h'),
     'HAVE_STRTOULL_L': ('strtoull_l', 'stdlib.h'),
     'HAVE_SYMLINK': ('symlink', 'unistd.h'),
     'HAVE_SYSCTLBYNAME': ('sysctlbyname', 'sys/sysctl.h'),
     'HAVE_TIMEGM': ('timegm', 'time.h'),
     'HAVE_USELOCALE': ('uselocale', 'xlocale.h'),
     'HAVE_UTIMES': ('utimes', 'sys/time.h'),
     'HAVE_VALLOC': ('valloc', 'stdlib.h'),
     'HAVE_VASPRINTF': ('vasprintf', 'stdio.h'),
     'HAVE_VSNPRINTF': ('vsnprintf', 'stdio.h'),
     'HAVE_BCOPY': ('bcopy', 'strings.h'),
     'HAVE_STRERROR': ('strerror', 'string.h'),
     'HAVE_MEMMOVE': ('memmove', 'string.h'),
     'HAVE_STRTOIMAX': ('strtoimax', 'inttypes.h'),
     'HAVE_STRTOLL': ('strtoll', 'stdlib.h'),
     'HAVE_STRTOQ': ('strtoq', 'stdlib.h'),
     'HAVE_ACCEPT4': ('accept4', 'sys/socket.h'),
     'HAVE_CHMOD': ('chmod', 'sys/stat.h'),
     'HAVE_CHOWN': ('chown', 'unistd.h'),
     'HAVE_FSTAT': ('fstat', 'sys/stat.h'),
     'HAVE_GETADDRINFO': ('getaddrinfo', 'netdb.h'),
     'HAVE_GETGRGID_R': ('getgrgid_r', 'grp.h'),
     'HAVE_GETGRNAM_R': ('getgrnam_r', 'grp.h'),
     'HAVE_GETGROUPS': ('getgroups', 'grp.h'),
     'HAVE_GETOPT_LONG': ('getopt_long', 'getopt.h'),
     'HAVE_GETPWNAM_R': ('getpwnam', 'pwd.h'),
     'HAVE_GETPWUID_R': ('getpwuid_r', 'pwd.h'),
     'HAVE_GETUID': ('getuid', 'unistd.h'),
     'HAVE_LRINTF': ('lrintf', 'math.h'),
     'HAVE_DECL_ISNAN': ('isnan', 'math.h'),
     'HAVE_DECL_ISINF': ('isinf', 'math.h'),
     'HAVE_ROUND': ('round', 'math.h'),
     'HAVE_NEARBYINT': ('nearbyint', 'math.h'),
     'HAVE_RINT': ('rint', 'math.h'),
     'HAVE_MKFIFO': ('mkfifo', 'sys/stat.h'),
     'HAVE_MLOCK': ('mlock', 'sys/mman.h'),
     'HAVE_NANOSLEEP': ('nanosleep', 'time.h'),
     'HAVE_PIPE': ('pipe', 'unistd.h'),
     'HAVE_PPOLL': ('ppoll', 'poll.h'),
     'HAVE_REGEXEC': ('regexec', 'regex.h'),
     'HAVE_SETEGID': ('setegid', 'unistd.h'),
     'HAVE_SETEUID': ('seteuid', 'unistd.h'),
     'HAVE_SETPGID': ('setpgid', 'unistd.h'),
     'HAVE_SETREGID': ('setregid', 'unistd.h'),
     'HAVE_SETRESGID': ('setresgid', 'unistd.h'),
     'HAVE_SETRESUID': ('setresuid', 'unistd.h'),
     'HAVE_SHM_OPEN': ('shm_open', 'fcntl.h'),
     'HAVE_SLEEP': ('sleep', 'unistd.h'),
     'HAVE_STRERROR_R': ('strerror_r', 'string.h'),
     'HAVE_STRTOF': ('strtof', 'stdlib.h'),
     'HAVE_SYSCONF': ('sysconf', 'unistd.h'),
     'HAVE_USLEEP': ('usleep', 'unistd.h'),
     'HAVE_VFORK': ('vfork', 'unistd.h'),
     'HAVE_MALLOC': ('malloc', 'stdlib.h'),
     'HAVE_CALLOC': ('calloc', 'stdlib.h'),
     'HAVE_REALLOC': ('realloc', 'stdlib.h'),
     'HAVE_FREE': ('free', 'stdlib.h'),
     'HAVE_ALLOCA': ('alloca', 'alloca.h'),
     'HAVE_QSORT': ('qsort', 'stdlib.h'),
     'HAVE_ABS': ('abs', 'stdlib.h'),
     'HAVE_MEMSET': ('memset', 'string.h'),
     'HAVE_MEMCMP': ('memcmp', 'string.h'),
     'HAVE_STRLEN': ('strlen', 'string.h'),
     'HAVE_STRLCAT': ('strlcat', 'string.h'),
     'HAVE_STRDUP': ('strdup', 'string.h'),
     'HAVE__STRREV': ('_strrev', 'string.h'),
     'HAVE__STRUPR': ('_strupr', 'string.h'),
     'HAVE__STRLWR': ('_strlwr', 'string.h'),
     'HAVE_INDEX': ('index', 'strings.h'),
     'HAVE_RINDEX': ('rindex', 'strings.h'),
     'HAVE_STRCHR': ('strchr', 'string.h'),
     'HAVE_STRRCHR': ('strrchr', 'string.h'),
     'HAVE_STRSTR': ('strstr', 'string.h'),
     'HAVE_STRTOL': ('strtol', 'stdlib.h'),
     'HAVE_STRTOUL': ('strtoul', 'stdlib.h'),
     'HAVE_STRTOULL': ('strtoull', 'stdlib.h'),
     'HAVE_STRTOD': ('strtod', 'stdlib.h'),
     'HAVE_ATOI': ('atoi', 'stdlib.h'),
     'HAVE_ATOF': ('atof', 'stdlib.h'),
     'HAVE_STRCMP': ('strcmp', 'string.h'),
     'HAVE_STRNCMP': ('strncmp', 'string.h'),
     'HAVE_VSSCANF': ('vsscanf', 'stdio.h'),
     'HAVE_CHROOT': ('chroot', 'unistd.h'),
     'HAVE_CLOCK': ('clock', 'time.h'),
     'HAVE_CLOCK_GETRES': ('clock_getres', 'time.h'),
     'HAVE_CLOCK_GETTIME': ('clock_gettime', 'time.h'),
     'HAVE_CLOCK_SETTIME': ('clock_settime', 'time.h'),
     'HAVE_CONFSTR': ('confstr', 'time.h'),
     'HAVE_CTERMID': ('ctermid', 'stdio.h'),
     'HAVE_DIRFD': ('dirfd', 'dirent.h'),
     'HAVE_DLOPEN': ('dlopen', 'dlfcn.h'),
     'HAVE_DUP2': ('dup2', 'unistd.h'),
     'HAVE_DUP3': ('dup3', 'unistd.h'),
     'HAVE_EPOLL_CREATE1': ('epoll_create1', 'sys/epoll.h'),
     'HAVE_ERF': ('erf', 'math.h'),
     'HAVE_ERFC': ('erfc', 'math.h'),
     'HAVE_EXECV': ('execv', 'unistd.h'),
     'HAVE_FACCESSAT': ('faccessat', 'unistd.h'),
     'HAVE_FCHDIR': ('fchdir', 'unistd.h'),
     'HAVE_FCHMODAT': ('fchmodat', 'sys/stat.h'),
     'HAVE_FDATASYNC': ('fdatasync', 'unistd.h'),
     'HAVE_FDOPENDIR': ('fdopendir', 'dirent.h'),
     'HAVE_FEXECVE': ('fexecve', 'unistd.h'),
     'HAVE_FLOCK': ('flock', 'sys/file.h'),
     'HAVE_FORKPTY': ('forkpty', 'pty.h'),
     'HAVE_FPATHCONF': ('fpathconf', 'unistd.h'),
     'HAVE_FSTATAT': ('fstatat', 'unistd.h'),
     'HAVE_FSTATVFS': ('fstatvfs', 'sys/statvfs.h'),
     'HAVE_FTELLO': ('ftello', 'stdio.h'),
     'HAVE_FTIME': ('ftime', 'sys/timeb.h'),
     'HAVE_FTRUNCATE': ('ftruncate', 'unistd.h'),
     'HAVE_FUTIMENS': ('futimens', 'sys/stat.h'),
     'HAVE_FUTIMES': ('futimes', 'sys/time.h'),
     'HAVE_GAI_STRERROR': ('gai_strerror', 'netdb.h'),
     'HAVE_GETGROUPLIST': ('getgrouplist', 'grp.h'),
     'HAVE_GETHOSTBYNAME': ('gethostbyname', 'netdb.h'),
     'HAVE_GETHOSTBYNAME_R': ('gethostbyname_r', 'netdb.h'),
     'HAVE_GETITIMER': ('getitimer', 'sys/time.h'),
     'HAVE_GETLOADAVG': ('getloadavg', 'stdlib.h'),
     'HAVE_GETLOGIN': ('getlogin', 'unistd.h'),
     'HAVE_GETNAMEINFO': ('getnameinfo', 'netdb.h'),
     'HAVE_GETPEERNAME': ('getpeername', 'sys/socket.h'),
     'HAVE_GETPGID': ('getpgid', 'unistd.h'),
     'HAVE_GETPGRP': ('getpgrp', 'unistd.h'),
     'HAVE_GETPID': ('getpid', 'unistd.h'),
     'HAVE_GETPRIORITY': ('getpriority', 'sys/resource.h'),
     'HAVE_GETPWENT': ('getpwent', 'pwd.h'),
     'HAVE_GETRANDOM': ('getrandom', 'linux/random.h'),
     'HAVE_GETRESGID': ('getresgid', 'unistd.h'),
     'HAVE_GETSID': ('getsid', 'unistd.h'),
     'HAVE_GETSPENT': ('getspent', 'shadow.h'),
     'HAVE_GETSPNAM': ('getspnam', 'shadow.h'),
     'HAVE_GETWD': ('getwd', 'unistd.h'),
     'HAVE_HSTRERROR': ('hstrerror', 'netdb.h'),
     'HAVE_HTOLE64': ('htole64', 'endian.h'),
     'HAVE_IF_NAMEINDEX': ('if_nameindex', 'net/if.h'),
     'HAVE_INET_ATON': ('inet_aton', 'arpa/inet.h'),
     'HAVE_INET_PTON': ('inet_pton', 'arpa/inet.h'),
     'HAVE_INITGROUPS': ('initgroups', 'grp.h'),
     'HAVE_KILL': ('kill', 'signal.h'),
     'HAVE_KILLPG': ('killpg', 'signal.h'),
     'HAVE_LINKAT': ('linkat', 'unistd.h'),
     'HAVE_LOCKF': ('lockf', 'unistd.h'),
     'HAVE_LUTIMES': ('lutimes', 'sys/time.h'),
     'HAVE_MAKEDEV': ('makedev', 'sys/sysmacros.h'),
     'HAVE_MBRTOWC': ('mbrtowc', 'wchar.h'),
     'HAVE_MEMRCHR': ('memrchr', 'string.h'),
     'HAVE_MKDIRAT': ('mkdirat', 'sys/stat.h'),
     'HAVE_MKFIFOAT': ('mkfifoat', 'sys/stat.h'),
     'HAVE_MKNOD': ('mknod', 'unistd.h'),
     'HAVE_MKNODAT': ('mknodat', 'unistd.h'),
     'HAVE_MKTIME': ('mktime', 'unistd.h'),
     'HAVE_MKREMAP': ('mkremap', 'sys/mman.h'),
     'HAVE_NICE': ('nice', 'unistd.h'),
     'HAVE_OPENAT': ('openat', 'fcntl.h'),
     'HAVE_OPENPTY': ('openpty', 'pty.h'),
     'HAVE_PATHCONF': ('pathconf', 'unistd.h'),
     'HAVE_PAUSE': ('pause', 'unistd.h'),
     'HAVE_PREAD': ('pread', 'unistd.h'),
     'HAVE_PTHREAD_KILL': ('pthread_kill', 'signal.h'),
     'HAVE_PTHREAD_SIGMASK': ('pthread_sigmask', 'signal.h'),
     'HAVE_PWRITE': ('pwrite', 'unistd.h'),
     'HAVE_READLINKAT': ('readlinkat', 'unistd.h'),
     'HAVE_READV': ('readv', 'sys/uio.h'),
     'HAVE_RENAMEAT': ('renamat', 'stdio.h'),
     'HAVE_SCHED_GET_PRIORITY_MAX': ('sched_get_priority_max', 'sched.h'),
     'HAVE_SCHED_RR_GET_INTERVAL': ('sched_rr_get_interval', 'sched.h'),
     'HAVE_SCHED_SETAFFINITY': ('sched_setaffinity', 'sched.h'),
     'HAVE_SCHED_SETPARAM': ('sched_setparam', 'sched.h'),
     'HAVE_SCHED_SETSCHEDULER': ('sched_setscheduler', 'sched.h'),
     'HAVE_SELECT': ('select', 'sys/select.h'),
     'HAVE_SEM_GETVALUE': ('sem_getvalue', 'semaphore.h'),
     'HAVE_SEM_OPEN': ('sem_open', 'semaphore.h'),
     'HAVE_SEM_TIMEDWAIT': ('sem_timedwait', 'semaphore.h'),
     'HAVE_SEM_UNLINK': ('sem_unlink', 'semaphore.h'),
     'HAVE_SENDFILE': ('sendfile', 'sys/sendfile.h'),
     'HAVE_SETGID': ('setgid', 'unistd.h'),
     'HAVE_SETGROUPS': ('setgroups', 'grp.h'),
     'HAVE_SETHOSTNAME': ('sethostname', 'unistd.h'),
     'HAVE_SETITIMER': ('setitimer', 'sys/time.h'),
     'HAVE_SETLOCALE': ('setlocale', 'locale.h'),
     'HAVE_SETPGRP': ('setpgrp', 'unistd.h'),
     'HAVE_SETPRIORITY': ('setpriority', 'sys/resource.h'),
     'HAVE_SETREUID': ('setreuid', 'unistd.h'),
     'HAVE_SETSID': ('setsid', 'unistd.h'),
     'HAVE_SETUID': ('setuid', 'unistd.h'),
     'HAVE_SETVBUF': ('setvbuf', 'unistd.h'),
     'HAVE_SIGALTSTACK': ('sigaltstack', 'signal.h'),
     'HAVE_SIGINTERRUPT': ('siginterrupt', 'signal.h'),
     'HAVE_SIGPENDING': ('sigpending', 'signal.h'),
     'HAVE_SIGRELSE': ('sigrelse', 'signal.h'),
     'HAVE_SIGTIMEDWAIT': ('sigtimedwait', 'signal.h'),
     'HAVE_SIGWAIT': ('sigwait', 'signal.h'),
     'HAVE_SIGWAITINFO': ('sigwaitinfo', 'signal.h'),
     'HAVE_SOCKETPAIR': ('socketpair', 'sys/socket.h'),
     'HAVE_STRFTIME': ('strftime', 'time.h'),
     'HAVE_SYMLINKAT': ('symlinkat', 'unistd.h'),
     'HAVE_SYNC': ('sync', 'unistd.h'),
     'HAVE_TCGETPGRP': ('tcgetpgrp', 'unistd.h'),
     'HAVE_TCSETPGRP': ('tcsetpgrp', 'unistd.h'),
     'HAVE_TEMPNAM': ('tempnam', 'stdio.h'),
     'HAVE_TIMES': ('times', 'sys/times.h'),
     'HAVE_TEMPFILE': ('tempfile', 'stdio.h'),
     'HAVE_TMPNAM': ('tmpnam', 'stdio.h'),
     'HAVE_TMPNAM_R': ('tmpnam_r', 'stdio.h'),
     'HAVE_TRUNCATE': ('truncate', 'unistd.h'),
     'HAVE_TZNAME': ('tzname', 'time.h'),
     'HAVE_UNAME': ('uname', 'sys/utsname.h'),
     'HAVE_UNLINKAT': ('unlinkat', 'unistd.h'),
     'HAVE_UTIMENSAT': ('utimensat', 'sys/stat.h'),
     'HAVE_WAIT3': ('wait3', 'sys/wait.h'),
     'HAVE_WAIT4': ('wait4', 'sys/wait.h'),
     'HAVE_WAITID': ('waitid', 'sys/wait.h'),
     'HAVE_WRITEV': ('writev', 'sys/uio.h'),
     'HAVE_WMEMCMP': ('wmemcmp', 'wchar.h'),
     'HAVE_ATAN': ('atan', 'math.h'),
     'HAVE_ATAN2': ('atan2', 'math.h'),
     'HAVE_ACOS': ('acos', 'math.h'),
     'HAVE_ACOSH': ('acosh', 'math.h'),
     'HAVE_ASIN': ('asin', 'math.h'),
     'HAVE_ASINH': ('asinh', 'math.h'),
     'HAVE_ATANH': ('atanh', 'math.h'),
     'HAVE_CEIL': ('ceil', 'math.h'),
     'HAVE_COPYSIGN': ('copysign', 'math.h'),
     'HAVE_COS': ('cos', 'math.h'),
     'HAVE_COSH': ('cosh', 'math.h'),
     'HAVE_COSF': ('cosf', 'math.h'),
     'HAVE_EXPM1': ('expm1', 'math.h'),
     'HAVE_FABS': ('fabs', 'math.h'),
     'HAVE_FINITE': ('finite', 'math.h'),
     'HAVE_FLOOR': ('floor', 'math.h'),
     'HAVE_GAMMA': ('gamma', 'math.h'),
     'HAVE_HYPOT': ('hypot', 'math.h'),
     'HAVE_ISINF': ('isinf', 'math.h'),
     'HAVE_LOG': ('log', 'math.h'),
     'HAVE_LOG1P': ('log1p', 'math.h'),
     'HAVE_LOG2': ('log2', 'math.h'),
     'HAVE_LGAMMA': ('lgamma', 'math.h'),
     'HAVE_POW': ('pow', 'math.h'),
     'HAVE_SCALBN': ('scalbn', 'math.h'),
     'HAVE_SIN': ('sin', 'math.h'),
     'HAVE_SINF': ('sinf', 'math.h'),
     'HAVE_SINH': ('sinh', 'math.h'),
     'HAVE_SQRT': ('sqrt', 'math.h'),
     'HAVE_TGAMMA': ('tgamma', 'math.h'),
     'HAVE_FSEEKO': ('fseeko', 'stdio.h'),
     'HAVE_FSEEKO64': ('fseeko64', 'stdio.h'),
     'HAVE_SETJMP': ('setjmp', 'setjmp.h'),
     'HAVE_PTHREAD_SETNAME_NP': ('pthread_setname_np', 'pthread.h'),
     'HAVE_PTHREAD_SET_NAME_NP': ('pthread_set_name_np', 'pthread.h'),
     }

headers = []
functions = []
sizes = []

if len(sys.argv) != 2:
    print(help_message.format(sys.argv[0]))
    sys.exit(0)

with open(sys.argv[1], encoding='utf-8') as f:
    for line in f:
        line = line.strip()
        arr = line.split()

        # Check for headers.
        if line.startswith('#mesondefine') and line.endswith('_H'):
            token = line.split()[1]
            tarr = token.split('_')[1:-1]
            tarr = [x.lower() for x in tarr]
            hname = '/'.join(tarr) + '.h'
            headers.append(hname)

        # Check for functions.
        try:
            token = arr[1]
            if token in function_data:
                fdata = function_data[token]
                functions.append([token, fdata[0], fdata[1]])
            elif token.startswith('HAVE_') and not token.endswith('_H'):
                functions.append([token])
        except Exception:
            pass

        # Check for sizeof tests.
        if len(arr) != 2:
            continue
        elem = arr[1]
        if elem.startswith('SIZEOF_'):
            typename = elem.split('_', 1)[1] \
                .replace('_P', '*') \
                .replace('_', ' ') \
                .lower() \
                .replace('size t', 'size_t')
            sizes.append((elem, typename))

print('''cc = meson.get_compiler('c')
cdata = configuration_data()''')

# Convert header checks.

print('check_headers = [')
for hname in headers:
    print(f"  '{hname}',")
print(']\n')

print('''foreach h : check_headers
  if cc.has_header(h)
    cdata.set('HAVE_' + h.underscorify().to_upper(), 1)
  endif
endforeach
''')

# Convert function checks.

print('check_functions = [')
for tok in functions:
    if len(tok) == 3:
        tokstr, fdata0, fdata1 = tok
        print(f"  ['{tokstr}', '{fdata0}', '#include<{fdata1}>'],")
    else:
        print('# check token', tok)
print(']\n')

print('''foreach f : check_functions
  if cc.has_function(f.get(1), prefix : f.get(2))
    cdata.set(f.get(0), 1)
  endif
endforeach
''')

# Convert sizeof checks.

for elem, typename in sizes:
    print(f"cdata.set('{elem}', cc.sizeof('{typename}'))")

print('''
configure_file(input : 'config.h.meson',
  output : 'config.h',
  configuration : cdata)''')

"""

```
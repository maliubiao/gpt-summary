Response: The user wants a summary of the functionality of the C++ code in `v8/src/d8/d8.cc`.
Since this is the first part of a four-part file, the summary should focus on the aspects covered in this initial segment.

Looking at the included headers, the code seems to be related to:
- Core V8 functionalities (Isolate, Context, Script, Module, etc.)
- Platform integration (libplatform)
- Debugging and profiling tools
- Memory management (ArrayBuffer allocators)
- Module loading and execution
- Potentially some form of shell environment for running JavaScript

Given the name `d8.cc`, it's highly likely this file implements the `d8` command-line tool, V8's own shell.

The code defines several classes related to `ArrayBuffer` allocation, including:
- `ArrayBufferAllocatorBase`: A base class that forwards allocation to the default V8 allocator.
- `ShellArrayBufferAllocator`:  Uses virtual memory for larger allocations.
- `MockArrayBufferAllocator`:  Limits allocation size for testing.
- `MockArrayBufferAllocatiorWithLimit`:  Similar to the mock allocator but with an overall allocation limit.
- `MultiMappedAllocator` (Linux-specific):  A more specialized allocator for memory testing.

The code also includes logic for:
- Parsing JSON for trace configuration.
- Managing workers (threads).
- Caching compiled code.
- Streaming compilation.
- Handling modules, including fetching, resolving, and evaluating them.

The presence of `ExecuteString` and `ExecuteModule` suggests the core functionality is running JavaScript code.

The inclusion of `HostImportModuleDynamically` and related callbacks indicates support for dynamic `import()` in modules.

The `Shell` class seems to be a central point for managing the `d8` environment.

For the JavaScript example, it should relate to the features this part of the code enables, such as module imports or `ArrayBuffer` manipulation.
这个C++源代码文件 `v8/src/d8/d8.cc` 的主要功能是**实现 V8 JavaScript 引擎的命令行工具 `d8` 的核心部分**。 作为第一部分，它主要负责 V8 引擎的初始化、配置以及一些基础功能的实现，特别是与**内存管理、模块加载和执行**相关的部分。

以下是根据代码内容归纳的更具体的功能点：

1. **V8 引擎的初始化和配置:**  代码包含了初始化 V8 引擎所需的头文件 (`include/v8-initialization.h`)，并定义了全局的平台实例 (`g_platform`)。这暗示了 `d8.cc` 负责 V8 引擎的启动和环境设置。

2. **自定义的 ArrayBuffer 分配器:** 定义了多种 `ArrayBuffer` 的分配器，用于管理 JavaScript 中 `ArrayBuffer` 对象的内存。这些分配器包括：
    - `ArrayBufferAllocatorBase`:  基础分配器，直接使用 V8 默认的分配器。
    - `ShellArrayBufferAllocator`:  当分配较大的 `ArrayBuffer` 时使用虚拟内存以提高性能。
    - `MockArrayBufferAllocator`:  模拟 `ArrayBuffer` 的分配，限制分配大小，用于测试。
    - `MockArrayBufferAllocatiorWithLimit`:  带有分配限制的模拟分配器，用于模拟内存不足的情况。
    - `MultiMappedAllocator` (Linux only):  一个更高级的分配器，用于进行内存映射相关的测试。

3. **模块加载和管理:**  代码中包含了处理 JavaScript 模块的逻辑，包括：
    - `ResolveModuleCallback`:  用于解析模块说明符的回调函数。
    - `ResolveModuleSourceCallback`:  用于获取模块源代码的回调函数。
    - `FetchModuleSource`:  用于获取模块的源代码。
    - `FetchModuleTree`:  递归地获取和加载模块及其依赖。
    - `JSONModuleEvaluationSteps`:  用于评估 JSON 模块的步骤。
    - `HostImportModuleDynamically`:  用于处理动态 `import()` 语法的实现。
    - `DoHostImportModuleDynamically`:  实际执行动态模块导入的函数。

4. **代码缓存:** 实现了代码缓存的查找 (`LookupCodeCache`) 和存储 (`StoreInCodeCache`) 功能，用于提高脚本的执行效率。

5. **流式编译:** 支持流式编译 (`streaming_compile`)，允许在下载脚本的同时进行编译。

6. **脚本执行:**  定义了 `ExecuteString` 函数，用于执行一段 JavaScript 代码字符串。还定义了 `ExecuteModule` 函数，用于执行一个 JavaScript 模块文件。

7. **错误处理:**  包含了一些用于抛出 JavaScript 错误的辅助函数 (`ThrowError`, `ThrowException`)。

8. **多线程支持:** 代码中涉及到 `Worker` 类的管理，暗示了对 Web Workers 的支持。

9. **Tracing 支持:** 包含了与 tracing 相关的代码，允许收集 V8 引擎的运行时信息。

**与 JavaScript 功能的关系及示例：**

这个文件是 `d8` 工具的核心，因此它直接影响了你在 `d8` 中运行 JavaScript 代码的行为。特别是模块加载和 `ArrayBuffer` 的处理。

**JavaScript 示例 (与模块加载相关):**

假设你有一个名为 `moduleA.js` 的文件：

```javascript
// moduleA.js
export function hello() {
  console.log("Hello from module A!");
}
```

以及另一个名为 `main.js` 的文件：

```javascript
// main.js
import { hello } from './moduleA.js';
hello();
```

`d8.cc` 中的代码（特别是 `FetchModuleTree`, `ResolveModuleCallback` 等）负责找到 `moduleA.js` 文件，读取其内容，并将其编译和连接到 `main.js` 中。当你使用 `d8 main.js` 运行代码时，`d8.cc` 中的模块加载逻辑会确保 `hello` 函数能够被正确导入和调用。

**JavaScript 示例 (与 ArrayBuffer 相关):**

```javascript
// arrayBufferExample.js
const buffer = new ArrayBuffer(16);
const view = new Uint8Array(buffer);
view[0] = 42;
console.log(view[0]);
```

当你创建 `ArrayBuffer` 对象时，`d8.cc` 中定义的 `ArrayBufferAllocator` 类（例如 `ShellArrayBufferAllocator`）会负责分配实际的内存空间。`d8` 工具会根据配置和 `ArrayBuffer` 的大小选择合适的分配器。

总而言之，`v8/src/d8/d8.cc` 的第一部分奠定了 `d8` 工具的基础，使其能够加载、编译和执行 JavaScript 代码，并管理相关的资源，如内存和模块。

Prompt: 
```
这是目录为v8/src/d8/d8.cc的一个c++源代码文件， 请归纳一下它的功能, 如果它与javascript的功能有关系，请用javascript举例说明
这是第1部分，共4部分，请归纳一下它的功能

"""
// Copyright 2012 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>

#include <algorithm>
#include <fstream>
#include <iomanip>
#include <iterator>
#include <string>
#include <tuple>
#include <type_traits>
#include <unordered_map>
#include <utility>
#include <vector>

#ifdef ENABLE_VTUNE_JIT_INTERFACE
#include "src/third_party/vtune/v8-vtune.h"
#endif

#include "include/libplatform/libplatform.h"
#include "include/libplatform/v8-tracing.h"
#include "include/v8-function.h"
#include "include/v8-initialization.h"
#include "include/v8-inspector.h"
#include "include/v8-isolate.h"
#include "include/v8-json.h"
#include "include/v8-locker.h"
#include "include/v8-profiler.h"
#include "include/v8-wasm.h"
#include "src/api/api-inl.h"
#include "src/base/cpu.h"
#include "src/base/logging.h"
#include "src/base/platform/memory.h"
#include "src/base/platform/platform.h"
#include "src/base/platform/time.h"
#include "src/base/platform/wrappers.h"
#include "src/base/sanitizer/msan.h"
#include "src/base/sys-info.h"
#include "src/base/utils/random-number-generator.h"
#include "src/compiler-dispatcher/optimizing-compile-dispatcher.h"
#include "src/d8/d8-console.h"
#include "src/d8/d8-platforms.h"
#include "src/d8/d8.h"
#include "src/debug/debug-interface.h"
#include "src/deoptimizer/deoptimizer.h"
#include "src/diagnostics/basic-block-profiler.h"
#include "src/execution/microtask-queue.h"
#include "src/execution/v8threads.h"
#include "src/execution/vm-state-inl.h"
#include "src/flags/flags.h"
#include "src/handles/maybe-handles.h"
#include "src/heap/parked-scope-inl.h"
#include "src/init/v8.h"
#include "src/interpreter/interpreter.h"
#include "src/logging/counters.h"
#include "src/logging/log-file.h"
#include "src/objects/managed-inl.h"
#include "src/objects/objects-inl.h"
#include "src/objects/objects.h"
#include "src/parsing/parse-info.h"
#include "src/parsing/parsing.h"
#include "src/parsing/scanner-character-streams.h"
#include "src/profiler/profile-generator.h"
#include "src/snapshot/snapshot.h"
#include "src/tasks/cancelable-task.h"
#include "src/utils/ostreams.h"
#include "src/utils/utils.h"

#ifdef V8_OS_DARWIN
#include <mach/mach.h>
#include <mach/task_policy.h>
#endif

#ifdef V8_ENABLE_MAGLEV
#include "src/maglev/maglev-concurrent-dispatcher.h"
#endif  // V8_ENABLE_MAGLEV

#if V8_OS_POSIX
#include <signal.h>
#endif  // V8_OS_POSIX

#ifdef V8_FUZZILLI
#include "src/fuzzilli/cov.h"
#include "src/fuzzilli/fuzzilli.h"
#endif  // V8_FUZZILLI

#ifdef V8_USE_PERFETTO
#include "perfetto/tracing/track_event.h"
#include "perfetto/tracing/track_event_legacy.h"
#endif  // V8_USE_PERFETTO

#ifdef V8_INTL_SUPPORT
#include "unicode/locid.h"
#endif  // V8_INTL_SUPPORT

#ifdef V8_OS_LINUX
#include <sys/mman.h>  // For MultiMappedAllocator.
#endif

#if defined(V8_OS_WIN)
#include <windows.h>
#else
#include <unistd.h>
#endif  // defined(V8_OS_WIN)

#if V8_ENABLE_WEBASSEMBLY
#include "src/trap-handler/trap-handler.h"
#endif  // V8_ENABLE_WEBASSEMBLY

#ifndef DCHECK
#define DCHECK(condition) assert(condition)
#endif

#ifndef CHECK
#define CHECK(condition) assert(condition)
#endif

namespace v8 {

namespace {

// Set on worker threads to the current Worker instance.
thread_local Worker* current_worker_ = nullptr;

#ifdef V8_FUZZILLI
bool fuzzilli_reprl = true;
#else
bool fuzzilli_reprl = false;
#endif  // V8_FUZZILLI

// Base class for shell ArrayBuffer allocators. It forwards all operations to
// the default v8 allocator.
class ArrayBufferAllocatorBase : public v8::ArrayBuffer::Allocator {
 public:
  void* Allocate(size_t length) override {
    return allocator_->Allocate(length);
  }

  void* AllocateUninitialized(size_t length) override {
    return allocator_->AllocateUninitialized(length);
  }

  void Free(void* data, size_t length) override {
    allocator_->Free(data, length);
  }

 private:
  std::unique_ptr<Allocator> allocator_ =
      std::unique_ptr<Allocator>(NewDefaultAllocator());
};

// ArrayBuffer allocator that can use virtual memory to improve performance.
class ShellArrayBufferAllocator : public ArrayBufferAllocatorBase {
 public:
  void* Allocate(size_t length) override {
    if (length >= kVMThreshold) return AllocateVM(length);
    return ArrayBufferAllocatorBase::Allocate(length);
  }

  void* AllocateUninitialized(size_t length) override {
    if (length >= kVMThreshold) return AllocateVM(length);
    return ArrayBufferAllocatorBase::AllocateUninitialized(length);
  }

  void Free(void* data, size_t length) override {
    if (length >= kVMThreshold) {
      FreeVM(data, length);
    } else {
      ArrayBufferAllocatorBase::Free(data, length);
    }
  }

 private:
  static constexpr size_t kVMThreshold = 65536;

  void* AllocateVM(size_t length) {
    DCHECK_LE(kVMThreshold, length);
    v8::PageAllocator* page_allocator = i::GetArrayBufferPageAllocator();
    size_t page_size = page_allocator->AllocatePageSize();
    size_t allocated = RoundUp(length, page_size);
    return i::AllocatePages(page_allocator, nullptr, allocated, page_size,
                            PageAllocator::kReadWrite);
  }

  void FreeVM(void* data, size_t length) {
    v8::PageAllocator* page_allocator = i::GetArrayBufferPageAllocator();
    size_t page_size = page_allocator->AllocatePageSize();
    size_t allocated = RoundUp(length, page_size);
    i::FreePages(page_allocator, data, allocated);
  }
};

// ArrayBuffer allocator that never allocates over 10MB.
class MockArrayBufferAllocator : public ArrayBufferAllocatorBase {
 protected:
  void* Allocate(size_t length) override {
    return ArrayBufferAllocatorBase::Allocate(Adjust(length));
  }

  void* AllocateUninitialized(size_t length) override {
    return ArrayBufferAllocatorBase::AllocateUninitialized(Adjust(length));
  }

  void Free(void* data, size_t length) override {
    return ArrayBufferAllocatorBase::Free(data, Adjust(length));
  }

 private:
  size_t Adjust(size_t length) {
    const size_t kAllocationLimit = 10 * i::MB;
    return length > kAllocationLimit ? i::AllocatePageSize() : length;
  }
};

// ArrayBuffer allocator that can be equipped with a limit to simulate system
// OOM.
class MockArrayBufferAllocatiorWithLimit : public MockArrayBufferAllocator {
 public:
  explicit MockArrayBufferAllocatiorWithLimit(size_t allocation_limit)
      : space_left_(allocation_limit) {}

 protected:
  void* Allocate(size_t length) override {
    if (length > space_left_) {
      return nullptr;
    }
    space_left_ -= length;
    return MockArrayBufferAllocator::Allocate(length);
  }

  void* AllocateUninitialized(size_t length) override {
    if (length > space_left_) {
      return nullptr;
    }
    space_left_ -= length;
    return MockArrayBufferAllocator::AllocateUninitialized(length);
  }

  void Free(void* data, size_t length) override {
    space_left_ += length;
    return MockArrayBufferAllocator::Free(data, length);
  }

 private:
  std::atomic<size_t> space_left_;
};

#ifdef V8_OS_LINUX

// This is a mock allocator variant that provides a huge virtual allocation
// backed by a small real allocation that is repeatedly mapped. If you create an
// array on memory allocated by this allocator, you will observe that elements
// will alias each other as if their indices were modulo-divided by the real
// allocation length.
// The purpose is to allow stability-testing of huge (typed) arrays without
// actually consuming huge amounts of physical memory.
// This is currently only available on Linux because it relies on {mremap}.
class MultiMappedAllocator : public ArrayBufferAllocatorBase {
 protected:
  void* Allocate(size_t length) override {
    if (length < kChunkSize) {
      return ArrayBufferAllocatorBase::Allocate(length);
    }
    // We use mmap, which initializes pages to zero anyway.
    return AllocateUninitialized(length);
  }

  void* AllocateUninitialized(size_t length) override {
    if (length < kChunkSize) {
      return ArrayBufferAllocatorBase::AllocateUninitialized(length);
    }
    size_t rounded_length = RoundUp(length, kChunkSize);
    int prot = PROT_READ | PROT_WRITE;
    // We have to specify MAP_SHARED to make {mremap} below do what we want.
    int flags = MAP_SHARED | MAP_ANONYMOUS;
    void* real_alloc = mmap(nullptr, kChunkSize, prot, flags, -1, 0);
    if (reinterpret_cast<intptr_t>(real_alloc) == -1) {
      // If we ran into some limit (physical or virtual memory, or number
      // of mappings, etc), return {nullptr}, which callers can handle.
      if (errno == ENOMEM) {
        return nullptr;
      }
      // Other errors may be bugs which we want to learn about.
      FATAL("mmap (real) failed with error %d: %s", errno, strerror(errno));
    }
#ifdef V8_ENABLE_SANDBOX
    // The backing memory must be allocated inside the sandbox as it will be
    // used for array buffer contents.
    // Here we go into somewhat less-well-defined territory by using the
    // sandbox's virtual address space to essentially just reserve a number of
    // OS pages inside the sandbox, but then using mremap to replace these
    // pages directly afterwards. In practice, this works fine however.
    VirtualAddressSpace* vas = i::GetProcessWideSandbox()->address_space();
    i::Address in_sandbox_page_reservation = vas->AllocatePages(
        VirtualAddressSpace::kNoHint, rounded_length,
        vas->allocation_granularity(), PagePermissions::kNoAccess);
    void* virtual_alloc =
        in_sandbox_page_reservation != 0
            ? reinterpret_cast<void*>(in_sandbox_page_reservation)
            : reinterpret_cast<void*>(-1);
#else
    void* virtual_alloc =
        mmap(nullptr, rounded_length, prot, flags | MAP_NORESERVE, -1, 0);
#endif
    if (reinterpret_cast<intptr_t>(virtual_alloc) == -1) {
      if (errno == ENOMEM) {
        // Undo earlier, successful mappings.
        munmap(real_alloc, kChunkSize);
        return nullptr;
      }
      FATAL("mmap (virtual) failed with error %d: %s", errno, strerror(errno));
    }
    i::Address virtual_base = reinterpret_cast<i::Address>(virtual_alloc);
    i::Address virtual_end = virtual_base + rounded_length;
    for (i::Address to_map = virtual_base; to_map < virtual_end;
         to_map += kChunkSize) {
      // Specifying 0 as the "old size" causes the existing map entry to not
      // get deleted, which is important so that we can remap it again in the
      // next iteration of this loop.
      void* result =
          mremap(real_alloc, 0, kChunkSize, MREMAP_MAYMOVE | MREMAP_FIXED,
                 reinterpret_cast<void*>(to_map));
      if (reinterpret_cast<intptr_t>(result) == -1) {
        if (errno == ENOMEM) {
          // Undo earlier, successful mappings.
          munmap(real_alloc, kChunkSize);
#ifdef V8_ENABLE_SANDBOX
          vas->FreePages(in_sandbox_page_reservation, rounded_length);
#else
          munmap(virtual_alloc, rounded_length);
#endif
          return nullptr;
        }
        FATAL("mremap failed with error %d: %s", errno, strerror(errno));
      }
    }
    base::MutexGuard lock_guard(&regions_mutex_);
    regions_[virtual_alloc] = real_alloc;
    return virtual_alloc;
  }

  void Free(void* data, size_t length) override {
    if (length < kChunkSize) {
      return ArrayBufferAllocatorBase::Free(data, length);
    }
    base::MutexGuard lock_guard(&regions_mutex_);
    void* real_alloc = regions_[data];
    munmap(real_alloc, kChunkSize);
    size_t rounded_length = RoundUp(length, kChunkSize);
#ifdef V8_ENABLE_SANDBOX
    VirtualAddressSpace* vas = i::GetProcessWideSandbox()->address_space();
    vas->FreePages(reinterpret_cast<i::Address>(data), rounded_length);
#else
    munmap(data, rounded_length);
#endif
    regions_.erase(data);
  }

 private:
  // Aiming for a "Huge Page" (2M on Linux x64) to go easy on the TLB.
  static constexpr size_t kChunkSize = 2 * 1024 * 1024;

  std::unordered_map<void*, void*> regions_;
  base::Mutex regions_mutex_;
};

#endif  // V8_OS_LINUX

v8::Platform* g_default_platform;
std::unique_ptr<v8::Platform> g_platform;

template <int N>
void ThrowError(Isolate* isolate, const char (&message)[N]) {
  if (isolate->IsExecutionTerminating()) return;
  isolate->ThrowError(message);
}

void ThrowError(Isolate* isolate, Local<String> message) {
  if (isolate->IsExecutionTerminating()) return;
  isolate->ThrowError(message);
}

void ThrowException(Isolate* isolate, Local<Value> exception) {
  if (isolate->IsExecutionTerminating()) return;
  isolate->ThrowException(exception);
}

static MaybeLocal<Value> TryGetValue(v8::Isolate* isolate,
                                     Local<Context> context,
                                     Local<v8::Object> object,
                                     const char* property) {
  MaybeLocal<String> v8_str = String::NewFromUtf8(isolate, property);
  if (v8_str.IsEmpty()) return {};
  return object->Get(context, v8_str.ToLocalChecked());
}

static Local<Value> GetValue(v8::Isolate* isolate, Local<Context> context,
                             Local<v8::Object> object, const char* property) {
  return TryGetValue(isolate, context, object, property).ToLocalChecked();
}

std::shared_ptr<Worker> GetWorkerFromInternalField(Isolate* isolate,
                                                   Local<Object> object) {
  if (object->InternalFieldCount() != 1) {
    ThrowError(isolate, "this is not a Worker");
    return nullptr;
  }

  i::DirectHandle<i::Object> handle =
      Utils::OpenDirectHandle(*object->GetInternalField(0));
  if (IsSmi(*handle)) {
    ThrowError(isolate, "Worker is defunct because main thread is terminating");
    return nullptr;
  }
  auto managed = i::Cast<i::Managed<Worker>>(handle);
  return managed->get();
}

base::Thread::Options GetThreadOptions(const char* name) {
  // On some systems (OSX 10.6) the stack size default is 0.5Mb or less
  // which is not enough to parse the big literal expressions used in tests.
  // The stack size should be at least StackGuard::kLimitSize + some
  // OS-specific padding for thread startup code.  2Mbytes seems to be enough.
  return base::Thread::Options(name, 2 * i::MB);
}

}  // namespace

namespace tracing {

namespace {

static constexpr char kIncludedCategoriesParam[] = "included_categories";
static constexpr char kTraceConfigParam[] = "trace_config";

class TraceConfigParser {
 public:
  static void FillTraceConfig(v8::Isolate* isolate,
                              platform::tracing::TraceConfig* trace_config,
                              const char* json_str) {
    HandleScope outer_scope(isolate);
    Local<Context> context = Context::New(isolate);
    Context::Scope context_scope(context);
    HandleScope inner_scope(isolate);

    Local<String> source =
        String::NewFromUtf8(isolate, json_str).ToLocalChecked();
    Local<Value> result = JSON::Parse(context, source).ToLocalChecked();
    Local<v8::Object> trace_config_object = result.As<v8::Object>();
    // Try reading 'trace_config' property from a full chrome trace config.
    // https://chromium.googlesource.com/chromium/src/+/master/docs/memory-infra/memory_infra_startup_tracing.md#the-advanced-way
    Local<Value> maybe_trace_config_object =
        GetValue(isolate, context, trace_config_object, kTraceConfigParam);
    if (maybe_trace_config_object->IsObject()) {
      trace_config_object = maybe_trace_config_object.As<Object>();
    }

    UpdateIncludedCategoriesList(isolate, context, trace_config_object,
                                 trace_config);
  }

 private:
  static int UpdateIncludedCategoriesList(
      v8::Isolate* isolate, Local<Context> context, Local<v8::Object> object,
      platform::tracing::TraceConfig* trace_config) {
    Local<Value> value =
        GetValue(isolate, context, object, kIncludedCategoriesParam);
    if (value->IsArray()) {
      Local<Array> v8_array = value.As<Array>();
      for (int i = 0, length = v8_array->Length(); i < length; ++i) {
        Local<Value> v = v8_array->Get(context, i)
                             .ToLocalChecked()
                             ->ToString(context)
                             .ToLocalChecked();
        String::Utf8Value str(isolate, v->ToString(context).ToLocalChecked());
        trace_config->AddIncludedCategory(*str);
      }
      return v8_array->Length();
    }
    return 0;
  }
};

}  // namespace

static platform::tracing::TraceConfig* CreateTraceConfigFromJSON(
    v8::Isolate* isolate, const char* json_str) {
  platform::tracing::TraceConfig* trace_config =
      new platform::tracing::TraceConfig();
  TraceConfigParser::FillTraceConfig(isolate, trace_config, json_str);
  return trace_config;
}

}  // namespace tracing

class ExternalOwningOneByteStringResource
    : public String::ExternalOneByteStringResource {
 public:
  ExternalOwningOneByteStringResource() = default;
  ExternalOwningOneByteStringResource(
      std::unique_ptr<base::OS::MemoryMappedFile> file)
      : file_(std::move(file)) {}
  const char* data() const override {
    return static_cast<char*>(file_->memory());
  }
  size_t length() const override { return file_->size(); }

 private:
  std::unique_ptr<base::OS::MemoryMappedFile> file_;
};

// static variables:
CounterMap* Shell::counter_map_;
base::SharedMutex Shell::counter_mutex_;
base::OS::MemoryMappedFile* Shell::counters_file_ = nullptr;
CounterCollection Shell::local_counters_;
CounterCollection* Shell::counters_ = &local_counters_;
base::LazyMutex Shell::context_mutex_;
const base::TimeTicks Shell::kInitialTicks = base::TimeTicks::Now();
Global<Function> Shell::stringify_function_;
base::Mutex Shell::profiler_end_callback_lock_;
std::map<Isolate*, std::pair<Global<Function>, Global<Context>>>
    Shell::profiler_end_callback_;
base::LazyMutex Shell::workers_mutex_;
bool Shell::allow_new_workers_ = true;

std::unordered_set<std::shared_ptr<Worker>> Shell::running_workers_;
std::atomic<bool> Shell::script_executed_{false};
std::atomic<bool> Shell::valid_fuzz_script_{false};
base::LazyMutex Shell::cached_code_mutex_;
std::map<std::string, std::unique_ptr<ScriptCompiler::CachedData>>
    Shell::cached_code_map_;
std::atomic<int> Shell::unhandled_promise_rejections_{0};

Global<Context> Shell::evaluation_context_;
ArrayBuffer::Allocator* Shell::array_buffer_allocator;
bool check_d8_flag_contradictions = true;
ShellOptions Shell::options;
base::OnceType Shell::quit_once_ = V8_ONCE_INIT;

ScriptCompiler::CachedData* Shell::LookupCodeCache(Isolate* isolate,
                                                   Local<Value> source) {
  i::ParkedMutexGuard lock_guard(
      reinterpret_cast<i::Isolate*>(isolate)->main_thread_local_isolate(),
      cached_code_mutex_.Pointer());
  CHECK(source->IsString());
  v8::String::Utf8Value key(isolate, source);
  DCHECK(*key);
  auto entry = cached_code_map_.find(*key);
  if (entry != cached_code_map_.end() && entry->second) {
    int length = entry->second->length;
    uint8_t* cache = new uint8_t[length];
    memcpy(cache, entry->second->data, length);
    ScriptCompiler::CachedData* cached_data = new ScriptCompiler::CachedData(
        cache, length, ScriptCompiler::CachedData::BufferOwned);
    return cached_data;
  }
  return nullptr;
}

void Shell::StoreInCodeCache(Isolate* isolate, Local<Value> source,
                             const ScriptCompiler::CachedData* cache_data) {
  i::ParkedMutexGuard lock_guard(
      reinterpret_cast<i::Isolate*>(isolate)->main_thread_local_isolate(),
      cached_code_mutex_.Pointer());
  CHECK(source->IsString());
  if (cache_data == nullptr) return;
  v8::String::Utf8Value key(isolate, source);
  DCHECK(*key);
  int length = cache_data->length;
  uint8_t* cache = new uint8_t[length];
  memcpy(cache, cache_data->data, length);
  cached_code_map_[*key] = std::unique_ptr<ScriptCompiler::CachedData>(
      new ScriptCompiler::CachedData(cache, length,
                                     ScriptCompiler::CachedData::BufferOwned));
}

// Dummy external source stream which returns the whole source in one go.
// TODO(leszeks): Also test chunking the data.
class DummySourceStream : public v8::ScriptCompiler::ExternalSourceStream {
 public:
  DummySourceStream(Isolate* isolate, Local<String> source) : done_(false) {
    source_length_ = source->Length();
    source_buffer_ = std::make_unique<uint16_t[]>(source_length_);
    source->WriteV2(isolate, 0, source_length_, source_buffer_.get());
  }

  size_t GetMoreData(const uint8_t** src) override {
    if (done_) {
      return 0;
    }
    *src = reinterpret_cast<uint8_t*>(source_buffer_.release());
    done_ = true;

    return source_length_ * 2;
  }

 private:
  uint32_t source_length_;
  std::unique_ptr<uint16_t[]> source_buffer_;
  bool done_;
};

// Run a ScriptStreamingTask in a separate thread.
class StreamerThread : public v8::base::Thread {
 public:
  static void StartThreadForTaskAndJoin(
      v8::ScriptCompiler::ScriptStreamingTask* task) {
    StreamerThread thread(task);
    CHECK(thread.Start());
    thread.Join();
  }

  explicit StreamerThread(v8::ScriptCompiler::ScriptStreamingTask* task)
      : Thread(Thread::Options()), task_(task) {}

  void Run() override { task_->Run(); }

 private:
  v8::ScriptCompiler::ScriptStreamingTask* task_;
};

namespace {
template <class T>
MaybeLocal<T> CompileStreamed(Local<Context> context,
                              ScriptCompiler::StreamedSource* v8_source,
                              Local<String> full_source_string,
                              const ScriptOrigin& origin) {}

template <>
MaybeLocal<Script> CompileStreamed(Local<Context> context,
                                   ScriptCompiler::StreamedSource* v8_source,
                                   Local<String> full_source_string,
                                   const ScriptOrigin& origin) {
  return ScriptCompiler::Compile(context, v8_source, full_source_string,
                                 origin);
}

template <>
MaybeLocal<Module> CompileStreamed(Local<Context> context,
                                   ScriptCompiler::StreamedSource* v8_source,
                                   Local<String> full_source_string,
                                   const ScriptOrigin& origin) {
  return ScriptCompiler::CompileModule(context, v8_source, full_source_string,
                                       origin);
}

template <class T>
MaybeLocal<T> Compile(Local<Context> context, ScriptCompiler::Source* source,
                      ScriptCompiler::CompileOptions options) {}
template <>
MaybeLocal<Script> Compile(Local<Context> context,
                           ScriptCompiler::Source* source,
                           ScriptCompiler::CompileOptions options) {
  return ScriptCompiler::Compile(context, source, options);
}

template <>
MaybeLocal<Module> Compile(Local<Context> context,
                           ScriptCompiler::Source* source,
                           ScriptCompiler::CompileOptions options) {
  return ScriptCompiler::CompileModule(context->GetIsolate(), source, options);
}

}  // namespace

template <class T>
MaybeLocal<T> Shell::CompileString(Isolate* isolate, Local<Context> context,
                                   Local<String> source,
                                   const ScriptOrigin& origin) {
  if (options.streaming_compile) {
    v8::ScriptCompiler::StreamedSource streamed_source(
        std::make_unique<DummySourceStream>(isolate, source),
        v8::ScriptCompiler::StreamedSource::TWO_BYTE);
    std::unique_ptr<v8::ScriptCompiler::ScriptStreamingTask> streaming_task(
        v8::ScriptCompiler::StartStreaming(isolate, &streamed_source,
                                           std::is_same<T, Module>::value
                                               ? v8::ScriptType::kModule
                                               : v8::ScriptType::kClassic));
    StreamerThread::StartThreadForTaskAndJoin(streaming_task.get());
    return CompileStreamed<T>(context, &streamed_source, source, origin);
  }

  ScriptCompiler::CachedData* cached_code = nullptr;
  if (options.compile_options & ScriptCompiler::kConsumeCodeCache) {
    cached_code = LookupCodeCache(isolate, source);
  }
  ScriptCompiler::Source script_source(source, origin, cached_code);
  MaybeLocal<T> result =
      Compile<T>(context, &script_source,
                 cached_code ? ScriptCompiler::kConsumeCodeCache
                             : ScriptCompiler::kNoCompileOptions);
  if (cached_code) CHECK(!cached_code->rejected);
  return result;
}

namespace {
// For testing.
const int kHostDefinedOptionsLength = 2;
const uint32_t kHostDefinedOptionsMagicConstant = 0xF1F2F3F0;

const char kDataURLPrefix[] = "data:text/javascript,";

std::string ToSTLString(Isolate* isolate, Local<String> v8_str) {
  String::Utf8Value utf8(isolate, v8_str);
  // Should not be able to fail since the input is a String.
  CHECK(*utf8);
  return *utf8;
}

// Per-context Module data, allowing sharing of module maps
// across top-level module loads.
class ModuleEmbedderData {
 private:
  class ModuleGlobalHash {
   public:
    explicit ModuleGlobalHash(Isolate* isolate) : isolate_(isolate) {}
    size_t operator()(const Global<Module>& module) const {
      return module.Get(isolate_)->GetIdentityHash();
    }

   private:
    Isolate* isolate_;
  };

 public:
  static constexpr i::ExternalPointerTag kManagedTag = i::kGenericManagedTag;

  explicit ModuleEmbedderData(Isolate* isolate)
      : isolate_(isolate),
        module_to_specifier_map(10, ModuleGlobalHash(isolate)),
        json_module_to_parsed_json_map(
            10, module_to_specifier_map.hash_function()) {}

  std::string GetModuleSpecifier(Local<Module> module) {
    Global<Module> global_module(isolate_, module);
    auto specifier_it = module_to_specifier_map.find(global_module);
    CHECK(specifier_it != module_to_specifier_map.end());
    return specifier_it->second;
  }

  Local<Module> GetModule(
      std::pair<std::string, ModuleType> module_specifier_and_type) {
    auto module_it = module_map.find(module_specifier_and_type);
    CHECK(module_it != module_map.end());
    return module_it->second.Get(isolate_);
  }

  Local<Object> GetModuleSource(
      std::pair<std::string, ModuleType> module_specifier_and_type) {
    auto module_source_it = module_source_map.find(module_specifier_and_type);
    CHECK(module_source_it != module_source_map.end());
    return module_source_it->second.Get(isolate_);
  }

  Local<Value> GetJsonModuleValue(Local<Module> module) {
    auto json_value_it =
        json_module_to_parsed_json_map.find(Global<Module>(isolate_, module));
    CHECK(json_value_it != json_module_to_parsed_json_map.end());
    return json_value_it->second.Get(isolate_);
  }

  static ModuleType ModuleTypeFromImportSpecifierAndAttributes(
      Local<Context> context, const std::string& specifier,
      Local<FixedArray> import_attributes, bool hasPositions) {
    Isolate* isolate = context->GetIsolate();
    const int kV8AssertionEntrySize = hasPositions ? 3 : 2;
    for (int i = 0; i < import_attributes->Length();
         i += kV8AssertionEntrySize) {
      Local<String> v8_assertion_key =
          import_attributes->Get(context, i).As<v8::String>();
      std::string assertion_key = ToSTLString(isolate, v8_assertion_key);

      if (assertion_key == "type") {
        Local<String> v8_assertion_value =
            import_attributes->Get(context, i + 1).As<String>();
        std::string assertion_value = ToSTLString(isolate, v8_assertion_value);
        if (assertion_value == "json") {
          return ModuleType::kJSON;
        } else {
          // JSON and WebAssembly are currently the only supported non-JS types
          return ModuleType::kInvalid;
        }
      }
    }

    // If no type is asserted, check for the extension. Otherwise default to JS.
    if (specifier.ends_with(".wasm")) {
      return ModuleType::kWebAssembly;
    }
    return ModuleType::kJavaScript;
  }

  Isolate* isolate_;
  // Map from (normalized module specifier, module type) pair to Module.
  std::map<std::pair<std::string, ModuleType>, Global<Module>> module_map;
  // Map from (normalized module specifier, module type) pair to ModuleSource.
  std::map<std::pair<std::string, ModuleType>, Global<Object>>
      module_source_map;
  // Map from Module to its URL as defined in the ScriptOrigin
  std::unordered_map<Global<Module>, std::string, ModuleGlobalHash>
      module_to_specifier_map;
  // Map from JSON Module to its parsed content, for use in module
  // JSONModuleEvaluationSteps
  std::unordered_map<Global<Module>, Global<Value>, ModuleGlobalHash>
      json_module_to_parsed_json_map;

  // Origin location used for resolving modules when referrer is null.
  std::string origin;
};

enum { kModuleEmbedderDataIndex, kInspectorClientIndex };

std::shared_ptr<ModuleEmbedderData> InitializeModuleEmbedderData(
    Local<Context> context) {
  i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(context->GetIsolate());
  const size_t kModuleEmbedderDataEstimate = 4 * 1024;  // module map.
  i::Handle<i::Managed<ModuleEmbedderData>> module_data_managed =
      i::Managed<ModuleEmbedderData>::From(
          i_isolate, kModuleEmbedderDataEstimate,
          std::make_shared<ModuleEmbedderData>(context->GetIsolate()));
  v8::Local<v8::Value> module_data = Utils::ToLocal(module_data_managed);
  context->SetEmbedderData(kModuleEmbedderDataIndex, module_data);
  return module_data_managed->get();
}

std::shared_ptr<ModuleEmbedderData> GetModuleDataFromContext(
    Local<Context> context) {
  v8::Local<v8::Value> module_data =
      context->GetEmbedderData(kModuleEmbedderDataIndex);
  i::DirectHandle<i::Managed<ModuleEmbedderData>> module_data_managed =
      i::Cast<i::Managed<ModuleEmbedderData>>(
          Utils::OpenDirectHandle<Value, i::Object>(module_data));
  return module_data_managed->get();
}

ScriptOrigin CreateScriptOrigin(Isolate* isolate, Local<String> resource_name,
                                v8::ScriptType type) {
  Local<PrimitiveArray> options =
      PrimitiveArray::New(isolate, kHostDefinedOptionsLength);
  options->Set(isolate, 0,
               v8::Uint32::New(isolate, kHostDefinedOptionsMagicConstant));
  options->Set(isolate, 1, resource_name);
  return ScriptOrigin(resource_name, 0, 0, false, -1, Local<Value>(), false,
                      false, type == v8::ScriptType::kModule, options);
}

bool IsValidHostDefinedOptions(Local<Context> context, Local<Data> options,
                               Local<Value> resource_name) {
  if (!options->IsFixedArray()) return false;
  Local<FixedArray> array = options.As<FixedArray>();
  if (array->Length() != kHostDefinedOptionsLength) return false;
  uint32_t magic = 0;
  if (!array->Get(context, 0).As<Value>()->Uint32Value(context).To(&magic)) {
    return false;
  }
  if (magic != kHostDefinedOptionsMagicConstant) return false;
  return array->Get(context, 1).As<String>()->StrictEquals(resource_name);
}

class D8WasmAsyncResolvePromiseTask : public v8::Task {
 public:
  D8WasmAsyncResolvePromiseTask(v8::Isolate* isolate,
                                v8::Local<v8::Context> context,
                                v8::Local<v8::Promise::Resolver> resolver,
                                v8::Local<v8::Value> result,
                                WasmAsyncSuccess success)
      : isolate_(isolate),
        context_(isolate, context),
        resolver_(isolate, resolver),
        result_(isolate, result),
        success_(success) {}

  void Run() override {
    v8::HandleScope scope(isolate_);
    v8::Local<v8::Context> context = context_.Get(isolate_);
    v8::Context::Scope context_scope(context);
    MicrotasksScope microtasks_scope(context,
                                     MicrotasksScope::kDoNotRunMicrotasks);
    v8::Local<v8::Promise::Resolver> resolver = resolver_.Get(isolate_);
    v8::Local<v8::Value> result = result_.Get(isolate_);

    Maybe<bool> ret = success_ == WasmAsyncSuccess::kSuccess
                          ? resolver->Resolve(context, result)
                          : resolver->Reject(context, result);
    // It's guaranteed that no exceptions will be thrown by these
    // operations, but execution might be terminating.
    CHECK(ret.IsJust() ? ret.FromJust() : isolate_->IsExecutionTerminating());
  }

 private:
  v8::Isolate* isolate_;
  v8::Global<v8::Context> context_;
  v8::Global<v8::Promise::Resolver> resolver_;
  v8::Global<v8::Value> result_;
  WasmAsyncSuccess success_;
};

void D8WasmAsyncResolvePromiseCallback(
    v8::Isolate* isolate, v8::Local<v8::Context> context,
    v8::Local<v8::Promise::Resolver> resolver, v8::Local<v8::Value> result,
    WasmAsyncSuccess success) {
  // We have to resolve the promise in a separate task which is not a cancelable
  // task, to avoid a deadlock when {quit()} is called in the then-handler of
  // the result promise.
  g_platform->GetForegroundTaskRunner(isolate)->PostTask(
      std::make_unique<D8WasmAsyncResolvePromiseTask>(
          isolate, context, resolver, result, success));
}

}  // namespace

// Executes a string within the current v8 context.
bool Shell::ExecuteString(Isolate* isolate, Local<String> source,
                          Local<String> name,
                          ReportExceptions report_exceptions,
                          Global<Value>* out_result) {
  i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);
  if (i_isolate->is_execution_terminating()) return true;
  if (i::v8_flags.parse_only) {
    i::VMState<PARSER> state(i_isolate);
    i::Handle<i::String> str = Utils::OpenHandle(*(source));

    // Set up ParseInfo.
    i::UnoptimizedCompileState compile_state;
    i::ReusableUnoptimizedCompileState reusable_state(i_isolate);

    i::UnoptimizedCompileFlags flags =
        i::UnoptimizedCompileFlags::ForToplevelCompile(
            i_isolate, true, i::construct_language_mode(i::v8_flags.use_strict),
            i::REPLMode::kNo, ScriptType::kClassic, i::v8_flags.lazy);

    if (options.compile_options & v8::ScriptCompiler::kEagerCompile) {
      flags.set_is_eager(true);
    }

    i::ParseInfo parse_info(i_isolate, flags, &compile_state, &reusable_state);

    i::Handle<i::Script> script = parse_info.CreateScript(
        i_isolate, str, i::kNullMaybeHandle, ScriptOriginOptions());
    if (!i::parsing::ParseProgram(&parse_info, script, i_isolate,
                                  i::parsing::ReportStatisticsMode::kYes)) {
      parse_info.pending_error_handler()->PrepareErrors(
          i_isolate, parse_info.ast_value_factory());
      parse_info.pending_error_handler()->ReportErrors(i_isolate, script);

      fprintf(stderr, "Failed parsing\n");
      return false;
    }
    return true;
  }

  HandleScope handle_scope(isolate);
  TryCatch try_catch(isolate);
  try_catch.SetVerbose(report_exceptions == kReportExceptions);

  // Explicitly check for stack overflows. This method can be called
  // recursively, and since we consume quite some stack space for the C++
  // frames, the stack check in the called frame might be too late.
  if (i::StackLimitCheck{i_isolate}.HasOverflowed()) {
    i_isolate->StackOverflow();
    return false;
  }

  PerIsolateData* data = PerIsolateData::Get(isolate);
  Local<Context> realm =
      Local<Context>::New(isolate, data->realms_[data->realm_current_]);
  Context::Scope context_scope(realm);
  Local<Context> context(isolate->GetCurrentContext());
  ScriptOrigin origin = CreateScriptOrigin(isolate, name, ScriptType::kClassic);

  std::shared_ptr<ModuleEmbedderData> module_data =
      GetModuleDataFromContext(realm);
  module_data->origin = ToSTLString(isolate, name);

  for (int i = 1; i < options.repeat_compile; ++i) {
    HandleScope handle_scope_for_compiling(isolate);
    if (CompileString<Script>(isolate, context, source, origin).IsEmpty()) {
      return false;
    }
  }
  Local<Script> script;
  if (!CompileString<Script>(isolate, context, source, origin)
           .ToLocal(&script)) {
    return false;
  }

  if (options.code_cache_options ==
      ShellOptions::CodeCacheOptions::kProduceCache) {
    // Serialize and store it in memory for the next execution.
    ScriptCompiler::CachedData* cached_data =
        ScriptCompiler::CreateCodeCache(script->GetUnboundScript());
    StoreInCodeCache(isolate, source, cached_data);
    delete cached_data;
  }
  if (options.compile_only) return true;
  if (options.compile_options & ScriptCompiler::kConsumeCodeCache) {
    i::DirectHandle<i::Script> i_script(
        i::Cast<i::Script>(
            Utils::OpenDirectHandle(*script)->shared()->script()),
        i_isolate);
    // TODO(cbruni, chromium:1244145): remove once context-allocated.
    i_script->set_host_defined_options(i::Cast<i::FixedArray>(
        *Utils::OpenDirectHandle(*(origin.GetHostDefinedOptions()))));
  }

  MaybeLocal<Value> maybe_result = script->Run(realm);

  if (options.code_cache_options ==
      ShellOptions::CodeCacheOptions::kProduceCacheAfterExecute) {
    // Serialize and store it in memory for the next execution.
    ScriptCompiler::CachedData* cached_data =
        ScriptCompiler::CreateCodeCache(script->GetUnboundScript());
    StoreInCodeCache(isolate, source, cached_data);
    delete cached_data;
  }
  data->realm_current_ = data->realm_switch_;

  Local<Value> result;
  if (!maybe_result.ToLocal(&result)) {
    if (try_catch.HasTerminated()) return true;
    DCHECK(try_catch.HasCaught());
    return false;
  } else if (out_result != nullptr) {
    out_result->Reset(isolate, result);
  }

  // It's possible that a FinalizationRegistry cleanup task threw an error.
  return !try_catch.HasCaught();
}

namespace {

bool IsAbsolutePath(const std::string& path) {
#if defined(V8_OS_WIN)
  // This is an incorrect approximation, but should
  // work for all our test-running cases.
  return path.find(':') != std::string::npos;
#else
  return path[0] == '/';
#endif
}

std::string GetWorkingDirectory() {
#if defined(V8_OS_WIN)
  char system_buffer[MAX_PATH];
  // Unicode paths are unsupported, which is fine as long as
  // the test directory doesn't include any such paths.
  DWORD len = GetCurrentDirectoryA(MAX_PATH, system_buffer);
  CHECK_GT(len, 0);
  return system_buffer;
#else
  char curdir[PATH_MAX];
  CHECK_NOT_NULL(getcwd(curdir, PATH_MAX));
  return curdir;
#endif
}

// Returns the directory part of path, without the trailing '/'.
std::string DirName(const std::string& path) {
  DCHECK(IsAbsolutePath(path));
  size_t last_slash = path.find_last_of('/');
  DCHECK(last_slash != std::string::npos);
  return path.substr(0, last_slash);
}

// Resolves path to an absolute path if necessary, and does some
// normalization (eliding references to the current directory
// and replacing backslashes with slashes).
std::string NormalizePath(const std::string& path,
                          const std::string& dir_name) {
  std::string absolute_path;
  if (IsAbsolutePath(path)) {
    absolute_path = path;
  } else {
    absolute_path = dir_name + '/' + path;
  }
  std::replace(absolute_path.begin(), absolute_path.end(), '\\', '/');
  std::vector<std::string> segments;
  std::istringstream segment_stream(absolute_path);
  std::string segment;
  while (std::getline(segment_stream, segment, '/')) {
    if (segment == "..") {
      if (!segments.empty()) segments.pop_back();
    } else if (segment != ".") {
      segments.push_back(segment);
    }
  }
  // Join path segments.
  std::ostringstream os;
  if (segments.size() > 1) {
    std::copy(segments.begin(), segments.end() - 1,
              std::ostream_iterator<std::string>(os, "/"));
    os << *segments.rbegin();
  } else {
    os << "/";
    if (!segments.empty()) os << segments[0];
  }
  return os.str();
}

// Resolves specifier to an absolute path if necessary, and does some
// normalization (eliding references to the current directory
// and replacing backslashes with slashes).
//
// If specifier is a data url, returns it unchanged.
std::string NormalizeModuleSpecifier(const std::string& specifier,
                                     const std::string& dir_name) {
  if (specifier.starts_with(kDataURLPrefix)) return specifier;
  return NormalizePath(specifier, dir_name);
}

MaybeLocal<Module> ResolveModuleCallback(Local<Context> context,
                                         Local<String> specifier,
                                         Local<FixedArray> import_attributes,
                                         Local<Module> referrer) {
  Isolate* isolate = context->GetIsolate();
  std::shared_ptr<ModuleEmbedderData> module_data =
      GetModuleDataFromContext(context);
  std::string referrer_specifier = module_data->GetModuleSpecifier(referrer);

  std::string stl_specifier = ToSTLString(isolate, specifier);
  std::string absolute_path =
      NormalizeModuleSpecifier(stl_specifier, DirName(referrer_specifier));
  ModuleType module_type =
      ModuleEmbedderData::ModuleTypeFromImportSpecifierAndAttributes(
          context, stl_specifier, import_attributes, true);
  return module_data->GetModule(std::make_pair(absolute_path, module_type));
}

MaybeLocal<Object> ResolveModuleSourceCallback(
    Local<Context> context, Local<String> specifier,
    Local<FixedArray> import_attributes, Local<Module> referrer) {
  Isolate* isolate = context->GetIsolate();
  std::shared_ptr<ModuleEmbedderData> module_data =
      GetModuleDataFromContext(context);
  std::string referrer_specifier = module_data->GetModuleSpecifier(referrer);

  std::string stl_specifier = ToSTLString(isolate, specifier);
  std::string absolute_path =
      NormalizeModuleSpecifier(stl_specifier, DirName(referrer_specifier));
  ModuleType module_type =
      ModuleEmbedderData::ModuleTypeFromImportSpecifierAndAttributes(
          context, stl_specifier, import_attributes, true);

  return module_data->GetModuleSource(
      std::make_pair(absolute_path, module_type));
}

}  // anonymous namespace

MaybeLocal<Object> Shell::FetchModuleSource(Local<Module> referrer,
                                            Local<Context> context,
                                            const std::string& module_specifier,
                                            ModuleType module_type) {
  Isolate* isolate = context->GetIsolate();
  DCHECK(IsAbsolutePath(module_specifier));
  auto file = ReadFileData(isolate, module_specifier.c_str());

  std::shared_ptr<ModuleEmbedderData> module_data =
      GetModuleDataFromContext(context);
  if (!file) {
    std::string msg = "d8: Error reading module from " + module_specifier;
    if (!referrer.IsEmpty()) {
      std::string referrer_specifier =
          module_data->GetModuleSpecifier(referrer);
      msg += "\n    imported by " + referrer_specifier;
    }
    ThrowError(isolate,
               v8::String::NewFromUtf8(isolate, msg.c_str()).ToLocalChecked());
    return MaybeLocal<Object>();
  }

  Local<Object> module_source;
  switch (module_type) {
    case ModuleType::kWebAssembly: {
      if (!v8::WasmModuleObject::Compile(
               isolate,
               MemorySpan<const uint8_t>(static_cast<uint8_t*>(file->memory()),
                                         file->size()))
               .ToLocal(&module_source)) {
        return MaybeLocal<Object>();
      }
      break;
    }
    default:
      // https://tc39.es/proposal-source-phase-imports/#table-abstract-methods-of-module-records
      // For Module Records that do not have a source representation,
      // GetModuleSource() must always return a throw completion whose [[Value]]
      // is a ReferenceError.
      ThrowException(
          isolate, v8::Exception::SyntaxError(String::NewFromUtf8Literal(
                       isolate, "Module source can not be imported for type")));
      return MaybeLocal<Object>();
  }

  CHECK(
      module_data->module_source_map
          .insert(std::make_pair(std::make_pair(module_specifier, module_type),
                                 Global<Object>(isolate, module_source)))
          .second);
  return module_source;
}

// file_name must be either an absolute path to the filesystem or a data URL.
MaybeLocal<Module> Shell::FetchModuleTree(Local<Module> referrer,
                                          Local<Context> context,
                                          const std::string& module_specifier,
                                          ModuleType module_type) {
  Isolate* isolate = context->GetIsolate();
  const bool is_data_url = module_specifier.starts_with(kDataURLPrefix);
  MaybeLocal<String> source_text;
  if (is_data_url) {
    source_text = String::NewFromUtf8(
        isolate, module_specifier.c_str() + strlen(kDataURLPrefix));
  } else {
    DCHECK(IsAbsolutePath(module_specifier));
    source_text = ReadFile(isolate, module_specifier.c_str(), false);
    if (source_text.IsEmpty() && options.fuzzy_module_file_extensions) {
      std::string fallback_file_name = module_specifier + ".js";
      source_text = ReadFile(isolate, fallback_file_name.c_str(), false);
      if (source_text.IsEmpty()) {
        fallback_file_name = module_specifier + ".mjs";
        source_text = ReadFile(isolate, fallback_file_name.c_str());
      }
    }
  }

  std::shared_ptr<ModuleEmbedderData> module_data =
      GetModuleDataFromContext(context);
  if (source_text.IsEmpty()) {
    std::string msg = "d8: Error reading module from " + module_specifier;
    if (!referrer.IsEmpty()) {
      std::string referrer_specifier =
          module_data->GetModuleSpecifier(referrer);
      msg += "\n    imported by " + referrer_specifier;
    }
    ThrowError(isolate,
               v8::String::NewFromUtf8(isolate, msg.c_str()).ToLocalChecked());
    return MaybeLocal<Module>();
  }

  Local<String> resource_name =
      String::NewFromUtf8(isolate, module_specifier.c_str()).ToLocalChecked();
  ScriptOrigin origin =
      CreateScriptOrigin(isolate, resource_name, ScriptType::kModule);

  Local<Module> module;
  if (module_type == ModuleType::kJavaScript) {
    ScriptCompiler::Source source(source_text.ToLocalChecked(), origin);
    if (!CompileString<Module>(isolate, context, source_text.ToLocalChecked(),
                               origin)
             .ToLocal(&module)) {
      return MaybeLocal<Module>();
    }
  } else if (module_type == ModuleType::kJSON) {
    Local<Value> parsed_json;
    if (!v8::JSON::Parse(context, source_text.ToLocalChecked())
             .ToLocal(&parsed_json)) {
      return MaybeLocal<Module>();
    }

    auto export_names = v8::to_array<Local<String>>(
        {String::NewFromUtf8(isolate, "default").ToLocalChecked()});

    module = v8::Module::CreateSyntheticModule(
        isolate,
        String::NewFromUtf8(isolate, module_specifier.c_str()).ToLocalChecked(),
        export_names, Shell::JSONModuleEvaluationSteps);

    CHECK(module_data->json_module_to_parsed_json_map
              .insert(std::make_pair(Global<Module>(isolate, module),
                                     Global<Value>(isolate, parsed_json)))
              .second);
  } else {
    UNREACHABLE();
  }

  CHECK(
      module_data->module_map
          .insert(std::make_pair(std::make_pair(module_specifier, module_type),
                                 Global<Module>(isolate, module)))
          .second);
  CHECK(module_data->module_to_specifier_map
            .insert(std::make_pair(Global<Module>(isolate, module),
                                   module_specifier))
            .second);

  // data URLs don't support further imports, so we're done.
  if (is_data_url) return module;

  std::string dir_name = DirName(module_specifier);

  Local<FixedArray> module_requests = module->GetModuleRequests();
  for (int i = 0, length = module_requests->Length(); i < length; ++i) {
    Local<ModuleRequest> module_request =
        module_requests->Get(context, i).As<ModuleRequest>();
    std::string specifier =
        ToSTLString(isolate, module_request->GetSpecifier());
    std::string normalized_specifier =
        NormalizeModuleSpecifier(specifier, dir_name);
    Local<FixedArray> import_attributes = module_request->GetImportAttributes();
    ModuleType request_module_type =
        ModuleEmbedderData::ModuleTypeFromImportSpecifierAndAttributes(
            context, normalized_specifier, import_attributes, true);

    if (request_module_type == ModuleType::kInvalid) {
      ThrowError(isolate, "Invalid module type was asserted");
      return MaybeLocal<Module>();
    }

    if (module_request->GetPhase() == ModuleImportPhase::kSource) {
      if (module_data->module_source_map.count(
              std::make_pair(normalized_specifier, request_module_type))) {
        continue;
      }

      if (FetchModuleSource(module, context, normalized_specifier,
                            request_module_type)
              .IsEmpty()) {
        return MaybeLocal<Module>();
      }
    } else {
      if (module_data->module_map.count(
              std::make_pair(normalized_specifier, request_module_type))) {
        continue;
      }

      if (FetchModuleTree(module, context, normalized_specifier,
                          request_module_type)
              .IsEmpty()) {
        return MaybeLocal<Module>();
      }
    }
  }

  return module;
}

MaybeLocal<Value> Shell::JSONModuleEvaluationSteps(Local<Context> context,
                                                   Local<Module> module) {
  Isolate* isolate = context->GetIsolate();

  std::shared_ptr<ModuleEmbedderData> module_data =
      GetModuleDataFromContext(context);
  Local<Value> json_value = module_data->GetJsonModuleValue(module);

  TryCatch try_catch(isolate);
  Maybe<bool> result = module->SetSyntheticModuleExport(
      isolate,
      String::NewFromUtf8Literal(isolate, "default",
                                 NewStringType::kInternalized),
      json_value);

  // Setting the default export should never fail.
  CHECK(!try_catch.HasCaught());
  CHECK(!result.IsNothing() && result.FromJust());

  Local<Promise::Resolver> resolver =
      Promise::Resolver::New(context).ToLocalChecked();
  resolver->Resolve(context, Undefined(isolate)).ToChecked();
  return resolver->GetPromise();
}

struct DynamicImportData {
  DynamicImportData(Isolate* isolate_, Local<Context> context_,
                    Local<Value> referrer_, Local<String> specifier_,
                    ModuleImportPhase phase_,
                    Local<FixedArray> import_attributes_,
                    Local<Promise::Resolver> resolver_)
      : isolate(isolate_), phase(phase_) {
    context.Reset(isolate, context_);
    referrer.Reset(isolate, referrer_);
    specifier.Reset(isolate, specifier_);
    import_attributes.Reset(isolate, import_attributes_);
    resolver.Reset(isolate, resolver_);
  }

  Isolate* isolate;
  // The initiating context. It can be the Realm created by d8, or the context
  // created by ShadowRealm built-in.
  Global<Context> context;
  Global<Value> referrer;
  Global<String> specifier;
  ModuleImportPhase phase;
  Global<FixedArray> import_attributes;
  Global<Promise::Resolver> resolver;
};

namespace {

enum ModuleResolutionDataIndex : uint32_t {
  kResolver = 0,
  kNamespaceOrSource = 1,
};

}  // namespace

void Shell::ModuleResolutionSuccessCallback(
    const FunctionCallbackInfo<Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate(info.GetIsolate());
  HandleScope handle_scope(isolate);
  Local<Array> module_resolution_data(info.Data().As<Array>());
  Local<Context> context(isolate->GetCurrentContext());

  Local<Promise::Resolver> resolver(
      module_resolution_data->Get(context, ModuleResolutionDataIndex::kResolver)
          .ToLocalChecked()
          .As<Promise::Resolver>());
  Local<Value> namespace_or_source(
      module_resolution_data
          ->Get(context, ModuleResolutionDataIndex::kNamespaceOrSource)
          .ToLocalChecked());

  PerIsolateData* data = PerIsolateData::Get(isolate);
  Local<Context> realm = data->realms_[data->realm_current_].Get(isolate);
  Context::Scope context_scope(realm);

  resolver->Resolve(realm, namespace_or_source).ToChecked();
}

void Shell::ModuleResolutionFailureCallback(
    const FunctionCallbackInfo<Value>& info) {
  DCHECK(i::ValidateCallbackInfo(info));
  Isolate* isolate(info.GetIsolate());
  HandleScope handle_scope(isolate);
  Local<Array> module_resolution_data(info.Data().As<Array>());
  Local<Context> context(isolate->GetCurrentContext());

  Local<Promise::Resolver> resolver(
      module_resolution_data->Get(context, ModuleResolutionDataIndex::kResolver)
          .ToLocalChecked()
          .As<Promise::Resolver>());

  PerIsolateData* data = PerIsolateData::Get(isolate);
  Local<Context> realm = data->realms_[data->realm_current_].Get(isolate);
  Context::Scope context_scope(realm);

  DCHECK_EQ(info.Length(), 1);
  resolver->Reject(realm, info[0]).ToChecked();
}

MaybeLocal<Promise> Shell::HostImportModuleDynamically(
    Local<Context> context, Local<Data> host_defined_options,
    Local<Value> resource_name, Local<String> specifier,
    Local<FixedArray> import_attributes) {
  return HostImportModuleWithPhaseDynamically(
      context, host_defined_options, resource_name, specifier,
      ModuleImportPhase::kEvaluation, import_attributes);
}

MaybeLocal<Promise> Shell::HostImportModuleWithPhaseDynamically(
    Local<Context> context, Local<Data> host_defined_options,
    Local<Value> resource_name, Local<String> specifier,
    ModuleImportPhase phase, Local<FixedArray> import_attributes) {
  Isolate* isolate = context->GetIsolate();

  MaybeLocal<Promise::Resolver> maybe_resolver =
      Promise::Resolver::New(context);
  Local<Promise::Resolver> resolver;
  if (!maybe_resolver.ToLocal(&resolver)) return MaybeLocal<Promise>();

  if (!resource_name->IsNull() &&
      !IsValidHostDefinedOptions(context, host_defined_options,
                                 resource_name)) {
    resolver
        ->Reject(context, v8::Exception::TypeError(String::NewFromUtf8Literal(
                              isolate, "Invalid host defined options")))
        .ToChecked();
  } else {
    DynamicImportData* data =
        new DynamicImportData(isolate, context, resource_name, specifier, phase,
                              import_attributes, resolver);
    PerIsolateData::Get(isolate)->AddDynamicImportData(data);
    isolate->EnqueueMicrotask(Shell::DoHostImportModuleDynamically, data);
  }
  return resolver->GetPromise();
}

void Shell::HostInitializeImportMetaObject(Local<Context> context,
                                           Local<Module> module,
                                           Local<Object> meta) {
  Isolate* isolate = context->GetIsolate();
  HandleScope handle_scope(isolate);

  std::shared_ptr<ModuleEmbedderData> module_data =
      GetModuleDataFromContext(context);
  std::string specifier = module_data->GetModuleSpecifier(module);

  Local<String> url_key =
      String::NewFromUtf8Literal(isolate, "url", NewStringType::kInternalized);
  Local<String> url =
      String::NewFromUtf8(isolate, specifier.c_str()).ToLocalChecked();
  meta->CreateDataProperty(context, url_key, url).ToChecked();
}

MaybeLocal<Context> Shell::HostCreateShadowRealmContext(
    Local<Context> initiator_context) {
  Local<Context> context = v8::Context::New(initiator_context->GetIsolate());
  std::shared_ptr<ModuleEmbedderData> shadow_realm_data =
      InitializeModuleEmbedderData(context);
  std::shared_ptr<ModuleEmbedderData> initiator_data =
      GetModuleDataFromContext(initiator_context);

  // ShadowRealms are synchronously accessible and are always in the same origin
  // as the initiator context.
  context->SetSecurityToken(initiator_context->GetSecurityToken());
  shadow_realm_data->origin = initiator_data->origin;

  return context;
}

void Shell::DoHostImportModuleDynamically(void* import_data) {
  DynamicImportData* import_data_ =
      static_cast<DynamicImportData*>(import_data);

  Isolate* isolate(import_data_->isolate);
  Global<Context> global_realm;
  Global<Promise::Resolver> global_resolver;
  Global<Promise> global_result_promise;
  Global<Value> global_namespace_or_source;

  TryCatch try_catch(isolate);
  try_catch.SetVerbose(true);

  {
    HandleScope handle_scope(isolate);
    Local<Context> realm = import_data_->context.Get(isolate);
    Local<Value> referrer = import_data_->referrer.Get(isolate);
    Local<String> v8_specifier = import_data_->specifier.Get(isolate);
    ModuleImportPhase phase = import_data_->phase;
    Local<FixedArray> import_attributes =
        import_data_->import_attributes.Get(isolate);
    Local<Promise::Resolver> resolver = import_data_->resolver.Get(isolate);

    global_realm.Reset(isolate, realm);
    global_resolver.Reset(isolate, resolver);

    PerIsolateData* data = PerIsolateData::Get(isolate);
    data->DeleteDynamicImportData(import_data_);

    Context::Scope context_scope(realm);
    std::string specifier = ToSTLString(isolate, v8_specifier);

    ModuleType module_type =
        ModuleEmbedderData::ModuleTypeFromImportSpecifierAndAttributes(
            realm, specifier, import_attributes, false);

    if (module_type == ModuleType::kInvalid) {
      ThrowError(isolate, "Invalid module type was asserted");
      CHECK(try_catch.HasCaught());
      resolver->Reject(realm, try_catch.Exception()).ToChecked();
      return;
    }

    std::shared_ptr<ModuleEmbedderData> module_data =
        GetModuleDataFromContext(realm);

    std::string source_url = referrer->IsNull()
                                 ? module_data->origin
                                 : ToSTLString(isolate, referrer.As<String>());
    std::string dir_name =
        DirName(NormalizePath(source_url, GetWorkingDirectory()));
    std::string absolute_path = NormalizeModuleSpecifier(specifier, dir_name);

    switch (phase) {
      case ModuleImportPhase::kSource: {
        Local<Object> module_source;
        auto module_it = module_data->module_source_map.find(
            std::make_pair(absolute_path, module_type));
        if (module_it != module_data->module_source_map.end()) {
          module_source = module_it->second.Get(isolate);
        } else if (!FetchModuleSource(Local<Module>(), realm, absolute_path,
                                      module_type)
                        .ToLocal(&module_source)) {
          CHECK(try_catch.HasCaught());
          if (isolate->IsExecutionTerminating()) {
            Shell::ReportException(isolate, try_catch);
          } else {
            resolver->Reject(realm, try_catch.Exception()).ToChecked();
          }
          return;
        }
        Local<Promise::Resolver> module_resolver =
            Promise::Resolver::New(realm).ToLocalChecked();
        module_resolver->Resolve(realm, module_source).ToChecked();

        global_namespace_or_source.Reset(isolate, module_source);
        global_result_promise.Reset(isolate, module_resolver->GetPromise());
        break;
      }
      case v8::ModuleImportPhase::kEvaluation: {
        Local<Module> root_module;
        auto module_it = module_data->module_map.find(
            std::make_pair(absolute_path, module_type));
        if (module_it != module_data->module_map.end()) {
          root_module = module_it->second.Get(isolate);
        } else if (!FetchModuleTree(Local<Module>(), realm, absolute_path,
                                    module_type)
                        .ToLocal(&root_module)) {
          CHECK(try_catch.HasCaught());
          if (isolate->IsExecutionTerminating()) {
            Shell::ReportException(isolate, try_catch);
          } else {
            resolver->Reject(realm, try_catch.Exception()).ToChecked();
          }
          return;
        }

        if (root_module
                ->InstantiateModule(realm, ResolveModuleCallback,
                                    ResolveModuleSourceCallback)
                .FromMaybe(false)) {
          MaybeLocal<Value> maybe_result = root_module->Evaluate(realm);
          CHECK(!maybe_result.IsEmpty());
          global_result_promise.Reset(
              isolate, maybe_result.ToLocalChecked().As<Promise>());
          global_namespace_or_source.Reset(isolate,
                                           root_module->GetModuleNamespace());
        }
        break;
      }
      default: {
        UNREACHABLE();
      }
    }
  }

  if (global_result_promise.IsEmpty()) {
    DCHECK(try_catch.HasCaught());
    HandleScope handle_scope(isolate);
    Local<Context> realm = global_realm.Get(isolate);
    Local<Promise::Resolver> resolver = global_resolver.Get(isolate);
    resolver->Reject(realm, try_catch.Exception()).ToChecked();
    return;
  }

  {
    // This method is invoked from a microtask, where in general we may have
    // an non-trivial stack. Emptying the message queue below may trigger the
    // execution of a stackless GC. We need to override the embedder stack
    // state, to force scanning the stack, if this happens.
    i::Heap* heap = reinterpret_cast<i::Isolate*>(isolate)->heap();
    i::EmbedderStackStateScope scope(
        heap, i::EmbedderStackStateOrigin::kExplicitInvocation,
        StackState::kMayContainHeapPointers);
    EmptyMessageQueues(isolate);
  }

  // Setup callbacks, and then chain them to the result promise.
  HandleScope handle_scope(isolate);
  Local<Context> realm = global_realm.Get(isolate);
  Local<Promise::Resolver> resolver = global_resolver.Get(isolate);
  Local<Promise> result_promise = global_result_promise.Get(isolate);
  Local<Value> namespace_or_source = global_namespace_or_source.Get(isolate);

  Local<Array> module_resolution_data = v8::Array::New(isolate);
  module_resolution_data->SetPrototypeV2(realm, v8::Null(isolate)).ToChecked();
  module_resolution_data
      ->Set(realm, ModuleResolutionDataIndex::kResolver, resolver)
      .ToChecked();
  module_resolution_data
      ->Set(realm, ModuleResolutionDataIndex::kNamespaceOrSource,
            namespace_or_source)
      .ToChecked();
  Local<Function> callback_success;
  CHECK(Function::New(realm, ModuleResolutionSuccessCallback,
                      module_resolution_data)
            .ToLocal(&callback_success));
  Local<Function> callback_failure;
  CHECK(Function::New(realm, ModuleResolutionFailureCallback,
                      module_resolution_data)
            .ToLocal(&callback_failure));
  result_promise->Then(realm, callback_success, callback_failure)
      .ToLocalChecked();
}

bool Shell::ExecuteModule(Isolate* isolate, const char* file_name) {
  HandleScope handle_scope(isolate);
  Global<Module> global_root_module;
  Global<Promise> global_result_promise;

  // Use a non-verbose TryCatch and report exceptions manually using
  // Shell::ReportException, because some errors (such as file errors) are
  // thrown without entering JS and thus do not trigger
  // isolate->ReportPendingMessages().
  TryCatch try_catch(isolate);

  {
    PerIsolateData* data = PerIsolateData::Get(isolate);
    Local<Context> realm = data->realms_[data->realm_current_].Get(isolate);
    Context::Scope context_scope(realm);

    std::string absolute_path =
        NormalizeModuleSpecifier(file_name, GetWorkingDirectory());

    std::shared_ptr<ModuleEmbedderData> module_data =
        GetModuleDataFromContext(realm);
    Local<Module> root_module;
    auto module_it = module_data->module_map.find(
        std::make_pair(absolute_path, ModuleType::kJavaScript));
    if (module_it != module_data->module_map.end()) {
      root_module = module_it->second.Get(isolate);
    } else if (!FetchModuleTree(Local<Module>(), realm, absolute_path,
                                ModuleType::kJavaScript)
                    .ToLocal(&root_module)) {
      CHECK(try_catch.HasCaught());
      ReportException(isolate, try_catch);
      return false;
    }
    global_root_module.Reset(isolate, root_module);

    module_data->origin = absolute_path;

    MaybeLocal<Value> maybe_result;
    if (root_module
            ->InstantiateModule(realm, ResolveModuleCallback,
                                ResolveModuleSourceCallback)
            .FromMaybe(false)) {
      maybe_result = root_module->Evaluate(realm);
      CHECK(!maybe_result.IsEmpty());
      global_result_promise.Reset(isolate,
                                  maybe_result.ToLocalChecked().As<Promise>());
    }
  }

  if (!global_result_promise.IsEmpty()) {
    EmptyMessageQueues(isolate);
  } else {
    DCHECK(try_catch.HasCaught());
    ReportException(isolate, try_catch);
    return false;
  }

  // Loop until module execution finishes
  while (isolate->HasPendingBackgroundTasks() ||
         (i::ValueHelper::HandleAsValue(global_result_promise)->State() ==
              Promise::kPending &&
          reinterpret_cast<i::Isolate*>(isolate)
                  ->default_microtask_queue()
                  ->size() > 0)) {
    Shell::CompleteMessageLoop(isolate);
  }

  {
    Local<Promise> result_promise = global_result_promise.Get(isolate);
    Local<Module> root_module = global_root_module.Get(isolate);

    if (result_promise->State() == Promise::kRejected) {
      // If the exception has been caught by the promise pipeline, we rethrow
      // here in order to ReportException.
      // TODO(cbruni): Clean this up a
"""


```
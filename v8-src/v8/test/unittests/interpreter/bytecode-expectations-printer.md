Response: Let's break down the thought process for analyzing this C++ code and generating the description and JavaScript example.

1. **Initial Scan and Keywords:**  The first thing I do is skim the code for recognizable keywords and patterns. I see: `BytecodeExpectationsPrinter`, `PrintBytecode`, `CompileScript`, `GetBytecodeArray`, `interpreter`, `v8`. This immediately tells me the code is likely related to V8's interpreter and deals with bytecode generation and inspection. The "Expectations" part suggests it's used for testing or verification, checking if the generated bytecode matches expectations.

2. **Class Structure:** I identify the main class, `BytecodeExpectationsPrinter`. I note its constructor and public methods like `PrintExpectation`. This hints at the primary usage pattern: create an instance, then call `PrintExpectation` with code snippets.

3. **Core Functionality - `PrintExpectation`:** This method seems central. I examine its steps:
    * **Code Wrapping:** It conditionally wraps the input `snippet` in a function. This suggests it can analyze both standalone code and function bodies.
    * **Compilation:**  It uses `CompileScript` or `CompileModule` to convert the JavaScript-like code into something V8 understands.
    * **Bytecode Extraction:**  Crucially, it calls functions like `GetBytecodeArrayForGlobal`, `GetBytecodeArrayForModule`, or `GetBytecodeArrayOfCallee` to retrieve the generated bytecode. This confirms its purpose is bytecode inspection.
    * **Printing:** Finally, it calls a series of `Print...` methods to output the bytecode, constant pool, handlers, and the original code snippet.

4. **Helper Functions - Deeper Dive:** I now look at the helper functions called by `PrintExpectation`:
    * **`WrapCodeInFunction`:**  Simple string manipulation to create a function wrapper.
    * **`CompileScript`, `CompileModule`:** Standard V8 API calls for compilation.
    * **`GetBytecodeArray...`:** These are key. They access the internal V8 structures (`JSFunction`, `SharedFunctionInfo`, `BytecodeArray`) to get the generated bytecode. This highlights the code's interaction with V8's internals.
    * **`PrintBytecodeSequence`:** Iterates through the `BytecodeArray` and calls `PrintBytecode` for each instruction.
    * **`PrintBytecode`:**  Decodes and prints individual bytecode instructions and their operands. It handles different operand types and sizes. The logic involving `Bytecodes::GetOperandType`, `Bytecodes::GetOperandSize`, and the switch statements is important.
    * **`PrintConstantPool`:** Iterates through the constant pool and prints each constant's type and value.
    * **`PrintHandlers`:** Deals with exception handling information in the bytecode.
    * **`PrintSourcePosition`:** Prints source code offsets, helpful for debugging.
    * **`Print...String`, `PrintConstant`:** Utility functions for formatting output.

5. **Purpose and Use Case:** Based on the analysis, I can now clearly define the functionality: this C++ code is a utility within the V8 project to inspect and print the bytecode generated by the V8 JavaScript engine for a given JavaScript code snippet. It's likely used for writing unit tests that verify the correctness of the bytecode generation process.

6. **Relationship to JavaScript:** The code directly manipulates the bytecode generated *from* JavaScript code. The input to `PrintExpectation` is essentially JavaScript. The output describes the internal representation of that JavaScript.

7. **JavaScript Example - Bridging the Gap:** To illustrate the connection, I need to show a simple JavaScript example and imagine what the `BytecodeExpectationsPrinter` would output for it. A basic function with a simple operation is ideal. `function add(a, b) { return a + b; } add(1, 2);` is a good choice.

8. **Simulating Output (Conceptual):** I mentally map the JavaScript code to potential bytecode instructions. I consider:
    * Loading arguments (`Ldar`, `Star`).
    * Performing addition (`Add`).
    * Returning the result (`Return`).
    * Function call setup.
    * Handling constants (like the numbers 1 and 2).

9. **Constructing the JavaScript Explanation:** I explain that the C++ code would analyze the bytecode generated for the example. I highlight the key bytecode instructions likely to be present and their purpose in relation to the JavaScript code. I emphasize that this C++ code helps understand the *inner workings* of V8 when executing JavaScript.

10. **Refinement and Clarity:** I review the explanation for clarity and accuracy. I ensure the connection between the C++ code and JavaScript functionality is evident. I use terms like "inspect," "analyze," and "verify" to accurately describe the tool's purpose. I also point out that this is a *developer tool* within the V8 project, not something directly used in production JavaScript execution.
这个C++源代码文件 `bytecode-expectations-printer.cc` 的主要功能是**用于打印和展示V8 JavaScript引擎为给定的JavaScript代码生成的字节码（bytecode）及其相关信息，例如常量池、异常处理表等。**  它主要被用于V8的单元测试中，帮助开发者验证生成的字节码是否符合预期。

**更具体地说，它的功能包括：**

1. **编译JavaScript代码:** 它能够使用V8的API将一段JavaScript代码编译成可执行的脚本或模块。
2. **获取字节码数组:**  对于编译后的脚本或模块，它可以提取出V8解释器执行的字节码数组（`BytecodeArray`）。
3. **格式化打印字节码:** 它遍历字节码数组，将每个字节码指令及其操作数以易于阅读的格式打印出来。这包括：
    * **字节码指令的名称:** 例如 `Ldar`, `Star`, `CallRuntime` 等。
    * **操作数的类型和值:** 例如寄存器 (R(n)), 立即数 (I8(n)), 常量池索引 (U16(n)) 等。
    * **源代码位置信息:**  如果可用，还会打印出该字节码指令对应的源代码位置。
4. **打印常量池:**  它会打印出与字节码关联的常量池中的值，包括数字、字符串等。
5. **打印异常处理表:**  如果字节码中存在异常处理逻辑，它会打印出相应的处理表信息。
6. **支持将代码包装在函数中:**  为了测试函数内部的字节码，它可以将给定的代码片段包装在一个函数中。
7. **支持模块和脚本:**  它可以处理普通脚本和ES模块的字节码。

**它与JavaScript的功能的关系：**

这个C++文件本身不是JavaScript代码，而是V8引擎的内部实现的一部分。它的作用是**揭示V8如何将JavaScript代码转换为机器可以理解的指令**。  理解生成的字节码对于理解V8的执行原理、性能优化以及调试非常有帮助。

**JavaScript 举例说明：**

假设我们有以下简单的 JavaScript 代码片段：

```javascript
function add(a, b) {
  return a + b;
}
add(1, 2);
```

当我们使用 `bytecode-expectations-printer.cc` 这个工具来分析这段代码时，它可能会输出类似以下的字节码（简化表示，实际输出会更详细）：

```
---
snippet: "
function add(a, b) {
  return a + b;
}
add(1, 2);
"
frame size: 4
parameter count: 2
bytecode array length: 19
bytecodes: [
  /*    0 E> */ B(LdaSmi), U8(1),  // 加载Smi常量 1 到累加器
  /*    2 S> */ B(Star), R0(context), // 将累加器中的值存储到寄存器 R0 (context)
  /*    4 E> */ B(LdaSmi), U8(2),  // 加载Smi常量 2 到累加器
  /*    6 S> */ B(Star), R1(arg0), // 将累加器中的值存储到参数寄存器 R1 (arg0)
  /*    8 E> */ B(Ldar), R0(context), // 加载寄存器 R0 (context) 的值到累加器
  /*   10 E> */ B(Add), R1(arg0), // 将累加器中的值与寄存器 R1 (arg0) 的值相加
  /*   12 S> */ B(Return),         // 返回累加器中的值
  /*   13 E> */ B(LdaGlobal), U8(0), // 加载全局对象
  /*   15 E> */ B(PushUndefined),  // 推入 undefined
  /*   16 E> */ B(CallProperty), R0(closure), U8(1), U8(0), // 调用全局对象的属性 (add 函数)
  /*   18 S> */ B(Return),         // 返回
]
constant pool: [
  String ["add"],
]
handlers: [
]
```

**这个输出的解释：**

* **`snippet`:**  显示了被分析的 JavaScript 代码。
* **`frame size` 和 `parameter count`:**  描述了函数调用栈帧的大小和参数数量。
* **`bytecode array length`:**  指明了字节码数组的长度。
* **`bytecodes`:**  列出了字节码指令序列。例如：
    * `LdaSmi, U8(1)`:  加载小的整数常量 1 到累加器寄存器。
    * `Star, R0(context)`: 将累加器中的值存储到名为 "context" 的寄存器 (通常用于存储局部变量)。
    * `Add, R1(arg0)`: 将累加器中的值与第一个参数寄存器（`arg0`，对应 `b`）中的值相加。
    * `Return`: 返回累加器中的值。
    * `CallProperty`: 调用一个对象的属性（在这里是调用 `add` 函数）。
* **`constant pool`:**  列出了代码中用到的常量，比如字符串 "add"。
* **`handlers`:**  显示了异常处理信息，在这个简单的例子中没有。

**总结:**

`bytecode-expectations-printer.cc` 是一个V8内部的工具，用于查看JavaScript代码被编译后生成的底层字节码指令。它帮助V8开发者理解和验证代码的执行方式，对于测试和调试V8的解释器至关重要。虽然它不是直接的JavaScript代码，但它是理解JavaScript在V8引擎中如何执行的关键桥梁。

Prompt: 
```
这是目录为v8/test/unittests/interpreter/bytecode-expectations-printer.cc的一个c++源代码文件， 请归纳一下它的功能, 如果它与javascript的功能有关系，请用javascript举例说明

"""
// Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "test/unittests/interpreter/bytecode-expectations-printer.h"

#include <iomanip>
#include <iostream>
#include <vector>

#include "include/libplatform/libplatform.h"
#include "include/v8-function.h"
#include "src/api/api-inl.h"
#include "src/base/logging.h"
#include "src/codegen/source-position-table.h"
#include "src/interpreter/bytecode-array-iterator.h"
#include "src/interpreter/bytecode-generator.h"
#include "src/interpreter/bytecodes.h"
#include "src/interpreter/interpreter-intrinsics.h"
#include "src/interpreter/interpreter.h"
#include "src/objects/heap-number-inl.h"
#include "src/objects/module-inl.h"
#include "src/objects/objects-inl.h"
#include "src/runtime/runtime.h"
#include "src/utils/ostreams.h"

namespace v8 {
namespace internal {
namespace interpreter {

static const char* NameForNativeContextIntrinsicIndex(uint32_t idx) {
  switch (idx) {
    case Context::REFLECT_APPLY_INDEX:
      return "reflect_apply";
    case Context::REFLECT_CONSTRUCT_INDEX:
      return "reflect_construct";
    default:
      return "UnknownIntrinsicIndex";
  }
}

// static
const char* const BytecodeExpectationsPrinter::kDefaultTopFunctionName =
    "__genbckexp_wrapper__";
const char* const BytecodeExpectationsPrinter::kIndent = "  ";

v8::Local<v8::String> BytecodeExpectationsPrinter::V8StringFromUTF8(
    const char* data) const {
  return v8::String::NewFromUtf8(isolate_, data).ToLocalChecked();
}

std::string BytecodeExpectationsPrinter::WrapCodeInFunction(
    const char* function_name, const std::string& function_body) const {
  std::ostringstream program_stream;
  program_stream << "function " << function_name << "() {" << function_body
                 << "}\n"
                 << function_name << "();";

  return program_stream.str();
}

v8::Local<v8::Script> BytecodeExpectationsPrinter::CompileScript(
    const char* program) const {
  v8::Local<v8::String> source = V8StringFromUTF8(program);
  return v8::Script::Compile(isolate_->GetCurrentContext(), source)
      .ToLocalChecked();
}

v8::Local<v8::Module> BytecodeExpectationsPrinter::CompileModule(
    const char* program) const {
  ScriptOrigin origin(Local<v8::Value>(), 0, 0, false, -1, Local<v8::Value>(),
                      false, false, true);
  v8::ScriptCompiler::Source source(V8StringFromUTF8(program), origin);
  return v8::ScriptCompiler::CompileModule(isolate_, &source).ToLocalChecked();
}

void BytecodeExpectationsPrinter::Run(v8::Local<v8::Script> script) const {
  MaybeLocal<Value> result = script->Run(isolate_->GetCurrentContext());
  USE(result);
}

i::Handle<v8::internal::BytecodeArray>
BytecodeExpectationsPrinter::GetBytecodeArrayForGlobal(
    const char* global_name) const {
  const v8::Local<v8::Context>& context = isolate_->GetCurrentContext();
  v8::Local<v8::String> v8_global_name = V8StringFromUTF8(global_name);
  v8::Local<v8::Function> function = v8::Local<v8::Function>::Cast(
      context->Global()->Get(context, v8_global_name).ToLocalChecked());
  i::DirectHandle<i::JSFunction> js_function =
      i::Cast<i::JSFunction>(v8::Utils::OpenDirectHandle(*function));

  i::Handle<i::BytecodeArray> bytecodes = i::handle(
      js_function->shared()->GetBytecodeArray(i_isolate()), i_isolate());

  return bytecodes;
}

i::Handle<i::BytecodeArray>
BytecodeExpectationsPrinter::GetBytecodeArrayForModule(
    v8::Local<v8::Module> module) const {
  i::Handle<i::Module> i_module = v8::Utils::OpenHandle(*module);
  return i::handle(
      Cast<SharedFunctionInfo>(Cast<i::SourceTextModule>(i_module)->code())
          ->GetBytecodeArray(i_isolate()),
      i_isolate());
}

i::Handle<i::BytecodeArray>
BytecodeExpectationsPrinter::GetBytecodeArrayForScript(
    v8::Local<v8::Script> script) const {
  i::DirectHandle<i::JSFunction> js_function =
      v8::Utils::OpenDirectHandle(*script);
  return i::handle(js_function->shared()->GetBytecodeArray(i_isolate()),
                   i_isolate());
}

i::Handle<i::BytecodeArray>
BytecodeExpectationsPrinter::GetBytecodeArrayOfCallee(
    const char* source_code) const {
  Local<v8::Context> context = isolate_->GetCurrentContext();
  Local<v8::Script> script =
      v8::Script::Compile(
          context,
          v8::String::NewFromUtf8(isolate_, source_code).ToLocalChecked())
          .ToLocalChecked();
  i::Handle<i::Object> i_object =
      v8::Utils::OpenHandle(*script->Run(context).ToLocalChecked());
  i::DirectHandle<i::JSFunction> js_function = i::Cast<i::JSFunction>(i_object);
  CHECK(js_function->shared()->HasBytecodeArray());
  return i::handle(js_function->shared()->GetBytecodeArray(i_isolate()),
                   i_isolate());
}

void BytecodeExpectationsPrinter::PrintEscapedString(
    std::ostream* stream, const std::string& string) const {
  for (char c : string) {
    switch (c) {
      case '"':
        *stream << "\\\"";
        break;
      case '\\':
        *stream << "\\\\";
        break;
      default:
        *stream << c;
        break;
    }
  }
}

void BytecodeExpectationsPrinter::PrintBytecodeOperand(
    std::ostream* stream, const BytecodeArrayIterator& bytecode_iterator,
    const Bytecode& bytecode, int op_index, int parameter_count) const {
  OperandType op_type = Bytecodes::GetOperandType(bytecode, op_index);
  OperandSize op_size = Bytecodes::GetOperandSize(
      bytecode, op_index, bytecode_iterator.current_operand_scale());

  const char* size_tag;
  switch (op_size) {
    case OperandSize::kByte:
      size_tag = "8";
      break;
    case OperandSize::kShort:
      size_tag = "16";
      break;
    case OperandSize::kQuad:
      size_tag = "32";
      break;
    default:
      UNREACHABLE();
  }

  if (Bytecodes::IsRegisterOperandType(op_type)) {
    Register register_value = bytecode_iterator.GetRegisterOperand(op_index);
    *stream << 'R';
    if (op_size != OperandSize::kByte) *stream << size_tag;
    if (register_value.is_current_context()) {
      *stream << "(context)";
    } else if (register_value.is_function_closure()) {
      *stream << "(closure)";
    } else if (register_value.is_parameter()) {
      int parameter_index = register_value.ToParameterIndex();
      if (parameter_index == 0) {
        *stream << "(this)";
      } else {
        *stream << "(arg" << (parameter_index - 1) << ')';
      }
    } else {
      *stream << '(' << register_value.index() << ')';
    }
  } else {
    switch (op_type) {
      case OperandType::kFlag8:
        *stream << 'U' << size_tag << '(';
        *stream << bytecode_iterator.GetFlag8Operand(op_index);
        break;
      case OperandType::kFlag16:
        *stream << 'U' << size_tag << '(';
        *stream << bytecode_iterator.GetFlag16Operand(op_index);
        break;
      case OperandType::kIdx: {
        *stream << 'U' << size_tag << '(';
        *stream << bytecode_iterator.GetIndexOperand(op_index);
        break;
      }
      case OperandType::kUImm:
        *stream << 'U' << size_tag << '(';
        *stream << bytecode_iterator.GetUnsignedImmediateOperand(op_index);
        break;
      case OperandType::kImm:
        *stream << 'I' << size_tag << '(';
        *stream << bytecode_iterator.GetImmediateOperand(op_index);
        break;
      case OperandType::kRegCount:
        *stream << 'U' << size_tag << '(';
        *stream << bytecode_iterator.GetRegisterCountOperand(op_index);
        break;
      case OperandType::kRuntimeId: {
        *stream << 'U' << size_tag << '(';
        Runtime::FunctionId id =
            bytecode_iterator.GetRuntimeIdOperand(op_index);
        *stream << "Runtime::k" << i::Runtime::FunctionForId(id)->name;
        break;
      }
      case OperandType::kIntrinsicId: {
        *stream << 'U' << size_tag << '(';
        Runtime::FunctionId id =
            bytecode_iterator.GetIntrinsicIdOperand(op_index);
        *stream << "Runtime::k" << i::Runtime::FunctionForId(id)->name;
        break;
      }
      case OperandType::kNativeContextIndex: {
        *stream << 'U' << size_tag << '(';
        uint32_t idx = bytecode_iterator.GetNativeContextIndexOperand(op_index);
        *stream << "%" << NameForNativeContextIntrinsicIndex(idx);
        break;
      }
      default:
        UNREACHABLE();
    }

    *stream << ')';
  }
}

void BytecodeExpectationsPrinter::PrintBytecode(
    std::ostream* stream, const BytecodeArrayIterator& bytecode_iterator,
    int parameter_count) const {
  Bytecode bytecode = bytecode_iterator.current_bytecode();
  OperandScale operand_scale = bytecode_iterator.current_operand_scale();
  if (Bytecodes::OperandScaleRequiresPrefixBytecode(operand_scale)) {
    Bytecode prefix = Bytecodes::OperandScaleToPrefixBytecode(operand_scale);
    *stream << "B(" << Bytecodes::ToString(prefix) << "), ";
  }
  *stream << "B(" << Bytecodes::ToString(bytecode) << ')';
  int operands_count = Bytecodes::NumberOfOperands(bytecode);
  for (int op_index = 0; op_index < operands_count; ++op_index) {
    *stream << ", ";
    PrintBytecodeOperand(stream, bytecode_iterator, bytecode, op_index,
                         parameter_count);
  }
}

void BytecodeExpectationsPrinter::PrintSourcePosition(
    std::ostream* stream, SourcePositionTableIterator* source_iterator,
    int bytecode_offset) const {
  static const size_t kPositionWidth = 4;
  if (!source_iterator->done() &&
      source_iterator->code_offset() == bytecode_offset) {
    *stream << "/* " << std::setw(kPositionWidth)
            << source_iterator->source_position().ScriptOffset();
    if (source_iterator->is_statement()) {
      *stream << " S> */ ";
    } else {
      *stream << " E> */ ";
    }
    source_iterator->Advance();
  } else {
    *stream << "   " << std::setw(kPositionWidth) << ' ' << "       ";
  }
}

void BytecodeExpectationsPrinter::PrintV8String(
    std::ostream* stream, i::Tagged<i::String> string) const {
  *stream << '"';
  for (int i = 0, length = string->length(); i < length; ++i) {
    *stream << i::AsEscapedUC16ForJSON(string->Get(i));
  }
  *stream << '"';
}

void BytecodeExpectationsPrinter::PrintConstant(
    std::ostream* stream, i::DirectHandle<i::Object> constant) const {
  if (IsSmi(*constant)) {
    *stream << "Smi [";
    i::Smi::SmiPrint(i::Cast<i::Smi>(*constant), *stream);
    *stream << "]";
  } else {
    *stream << i::Cast<i::HeapObject>(*constant)->map()->instance_type();
    if (IsHeapNumber(*constant)) {
      *stream << " [";
      i::Cast<i::HeapNumber>(*constant)->HeapNumberShortPrint(*stream);
      *stream << "]";
    } else if (IsString(*constant)) {
      *stream << " [";
      PrintV8String(stream, i::Cast<i::String>(*constant));
      *stream << "]";
    }
  }
}

void BytecodeExpectationsPrinter::PrintFrameSize(
    std::ostream* stream,
    i::DirectHandle<i::BytecodeArray> bytecode_array) const {
  int32_t frame_size = bytecode_array->frame_size();

  DCHECK(IsAligned(frame_size, kSystemPointerSize));
  *stream << "frame size: " << frame_size / kSystemPointerSize
          << "\nparameter count: " << bytecode_array->parameter_count() << '\n';
}

void BytecodeExpectationsPrinter::PrintBytecodeSequence(
    std::ostream* stream, i::Handle<i::BytecodeArray> bytecode_array) const {
  *stream << "bytecode array length: " << bytecode_array->length()
          << "\nbytecodes: [\n";

  SourcePositionTableIterator source_iterator(
      bytecode_array->SourcePositionTable());
  BytecodeArrayIterator bytecode_iterator(bytecode_array);
  for (; !bytecode_iterator.done(); bytecode_iterator.Advance()) {
    *stream << kIndent;
    PrintSourcePosition(stream, &source_iterator,
                        bytecode_iterator.current_offset());
    PrintBytecode(stream, bytecode_iterator, bytecode_array->parameter_count());
    *stream << ",\n";
  }
  *stream << "]\n";
}

void BytecodeExpectationsPrinter::PrintConstantPool(
    std::ostream* stream, i::Tagged<i::TrustedFixedArray> constant_pool) const {
  *stream << "constant pool: [\n";
  int num_constants = constant_pool->length();
  if (num_constants > 0) {
    for (int i = 0; i < num_constants; ++i) {
      *stream << kIndent;
      PrintConstant(stream, handle(constant_pool->get(i), i_isolate()));
      *stream << ",\n";
    }
  }
  *stream << "]\n";
}

void BytecodeExpectationsPrinter::PrintCodeSnippet(
    std::ostream* stream, const std::string& body) const {
  *stream << "snippet: \"\n";
  std::stringstream body_stream(body);
  std::string body_line;
  while (std::getline(body_stream, body_line)) {
    *stream << kIndent;
    PrintEscapedString(stream, body_line);
    *stream << '\n';
  }
  *stream << "\"\n";
}

void BytecodeExpectationsPrinter::PrintHandlers(
    std::ostream* stream,
    i::DirectHandle<i::BytecodeArray> bytecode_array) const {
  *stream << "handlers: [\n";
  HandlerTable table(*bytecode_array);
  for (int i = 0, num_entries = table.NumberOfRangeEntries(); i < num_entries;
       ++i) {
    *stream << "  [" << table.GetRangeStart(i) << ", " << table.GetRangeEnd(i)
            << ", " << table.GetRangeHandler(i) << "],\n";
  }
  *stream << "]\n";
}

void BytecodeExpectationsPrinter::PrintBytecodeArray(
    std::ostream* stream, i::Handle<i::BytecodeArray> bytecode_array) const {
  PrintFrameSize(stream, bytecode_array);
  PrintBytecodeSequence(stream, bytecode_array);
  PrintConstantPool(stream, bytecode_array->constant_pool());
  PrintHandlers(stream, bytecode_array);
}

void BytecodeExpectationsPrinter::PrintExpectation(
    std::ostream* stream, const std::string& snippet) const {
  std::string source_code =
      wrap_ ? WrapCodeInFunction(test_function_name_.c_str(), snippet)
            : snippet;

  i::v8_flags.compilation_cache = false;
  i::Handle<i::BytecodeArray> bytecode_array;
  if (module_) {
    CHECK(top_level_ && !wrap_);
    v8::Local<v8::Module> module = CompileModule(source_code.c_str());
    bytecode_array = GetBytecodeArrayForModule(module);
  } else if (print_callee_) {
    bytecode_array = GetBytecodeArrayOfCallee(source_code.c_str());
  } else {
    v8::Local<v8::Script> script = CompileScript(source_code.c_str());
    if (top_level_) {
      bytecode_array = GetBytecodeArrayForScript(script);
    } else {
      Run(script);
      bytecode_array = GetBytecodeArrayForGlobal(test_function_name_.c_str());
    }
  }

  *stream << "---\n";
  PrintCodeSnippet(stream, snippet);
  PrintBytecodeArray(stream, bytecode_array);
  *stream << '\n';
}

}  // namespace interpreter
}  // namespace internal
}  // namespace v8

"""

```
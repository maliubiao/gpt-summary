Response:
Let's break down the thought process for analyzing this Go file.

1. **Initial Scan and Obvious Observations:**

   - The filename `zsysnum_openbsd_mips64.go` immediately tells us this file is related to system calls (`sysnum`), the OpenBSD operating system, and the MIPS64 architecture. The `z` prefix might indicate it's auto-generated or platform-specific.
   - The comment at the top confirms it's generated by `mksysnum.go` and shouldn't be edited manually. It also points to the source of the syscall definitions: `https://cvsweb.openbsd.org/cgi-bin/cvsweb/~checkout~/src/sys/kern/syscalls.master`.
   - The `//go:build mips64 && openbsd` line is a Go build constraint. This file is only included in builds targeting `mips64` architecture on `openbsd`.
   - The `package unix` declaration puts these constants within the `unix` package.
   - The `// Deprecated: Use libc wrappers instead of direct syscalls.` comment is a crucial piece of information. It tells us that these constants represent *direct* system call numbers, and Go prefers using the standard C library wrappers.

2. **Understanding the Content:**

   - The core of the file is a `const` block defining numerous constants with names like `SYS_EXIT`, `SYS_FORK`, `SYS_READ`, etc.
   - Each constant is assigned an integer value. These are likely the system call numbers themselves.
   - The comments next to each constant provide a brief description of the system call's function and its signature (arguments and return type) in a C-like syntax.

3. **Inferring the Purpose:**

   - Given the filename, the `// Deprecated` comment, and the content, the main purpose of this file is to provide Go programs running on OpenBSD/MIPS64 with the *numerical identifiers* for various system calls.
   - These numbers are needed if a program wants to directly invoke a system call, bypassing the higher-level abstractions provided by the standard library.

4. **Connecting to Go Functionality (and the "Deprecated" caveat):**

   -  The crucial point is the "Deprecated" comment. This immediately suggests that while these constants *exist*, you shouldn't typically use them directly.
   - Go's standard library (`syscall` package and functions within `os`, `net`, etc.) provides a platform-independent way to interact with the operating system. These higher-level functions internally use these system call numbers (or their C wrapper equivalents) as needed.

5. **Illustrative Go Code (with the "correct" approach):**

   - Since direct syscalls are discouraged, the example should demonstrate the *recommended* way to achieve the same functionality using Go's standard library.
   - For example, `SYS_OPEN` corresponds to opening a file. The `os.Open()` function in Go handles this in a portable way. Similarly, `SYS_READ` is related to `file.Read()`. `SYS_EXIT` corresponds to `os.Exit()`.

6. **Considering Command-Line Arguments and Processing:**

   - This file *itself* doesn't process command-line arguments. It's a data file (containing constants).
   - The `mksysnum.go` script mentioned in the comment *does* process command-line arguments (the URL to the syscalls.master file). It would be important to point this out if the question focused on the generation process.

7. **Identifying Potential Pitfalls:**

   - The biggest pitfall is ignoring the "Deprecated" warning and trying to use these `SYS_` constants directly with the `syscall.Syscall` family of functions. This is platform-specific and less maintainable than using the standard library.
   -  Another potential issue is misunderstanding the purpose. These constants are *numbers*, not functions. They need to be used in conjunction with syscall invocation mechanisms.

8. **Structuring the Answer:**

   - Start with a clear statement of the file's primary function.
   - Explain what system call numbers are and why they exist.
   - Emphasize the "Deprecated" status and recommend using standard library functions.
   - Provide Go code examples showing the *correct* way to perform common operations.
   - Briefly mention the code generation process if relevant (it is in this case).
   - Highlight the key mistake users might make.

9. **Refinement and Language:**

   - Use clear and concise language.
   - Avoid jargon where possible, or explain it.
   - Double-check the accuracy of the information.

By following these steps, we can arrive at a comprehensive and accurate answer that addresses all aspects of the prompt. The key is to understand the context of the file within the broader Go ecosystem and the implications of the "Deprecated" comment.
这个Go语言文件 `zsysnum_openbsd_mips64.go` 的主要功能是**定义了一系列常量，这些常量对应于 OpenBSD 操作系统在 MIPS64 架构下的系统调用号（system call numbers）**。

更具体地说，它做了以下几件事：

1. **声明了 `unix` 包:**  表示这些常量属于 `unix` 包，这个包在 Go 语言中提供了对底层操作系统 API 的访问。
2. **定义了大量的 `const` 常量:**  每个常量都以 `SYS_` 开头，后面跟着系统调用的名称，例如 `SYS_EXIT`, `SYS_FORK`, `SYS_OPEN` 等。
3. **为每个常量赋予一个整数值:**  这个整数值就是该系统调用在 OpenBSD/MIPS64 上的编号。操作系统内核通过这些编号来识别程序请求的具体系统服务。
4. **为每个常量添加了注释:** 注释中包含了该系统调用的简要描述以及在 C 语言中对应的函数签名。
5. **包含构建约束:**  `//go:build mips64 && openbsd` 确保这个文件只在编译目标为 OpenBSD 操作系统且 CPU 架构为 MIPS64 时才会被包含进构建。
6. **包含弃用说明:** `// Deprecated: Use libc wrappers instead of direct syscalls.`  这是一个重要的提示，说明**直接使用这些系统调用号已被弃用，推荐使用 Go 标准库提供的基于 C 库封装的函数。**

**它是什么 Go 语言功能的实现？**

这个文件实际上是 Go 语言中 `syscall` 包的一部分实现。 `syscall` 包允许 Go 程序直接调用底层的操作系统系统调用。在不同的操作系统和 CPU 架构下，系统调用的编号是不同的，因此 `syscall` 包需要针对每个平台提供相应的系统调用号定义。 `zsysnum_openbsd_mips64.go` 就是 `syscall` 包在 OpenBSD/MIPS64 平台上的系统调用号定义。

**Go 代码举例说明 (不推荐的直接调用方式，仅作理解)**

尽管官方推荐使用 C 库封装，为了理解这些常量的作用，我们可以看一个直接使用系统调用的例子（**再次强调，这种方式不推荐在实际开发中使用**）：

```go
package main

import (
	"fmt"
	"syscall"
	"unsafe"
)

func main() {
	// 假设我们要调用 OpenBSD/MIPS64 上的 SYS_WRITE 系统调用
	fd := 1 // 标准输出
	message := "Hello, syscall!\n"
	addr := unsafe.Pointer(&[]byte(message)[0])
	count := uintptr(len(message))

	// 直接使用 syscall.Syscall 函数调用系统调用
	// 注意：这种方式需要传递系统调用号和参数
	_, _, err := syscall.Syscall(syscall.SYS_WRITE, uintptr(fd), uintptr(addr), count)
	if err != 0 {
		fmt.Printf("syscall SYS_WRITE failed: %v\n", err)
	}
}

// 假设的输入：无
// 假设的输出：如果 syscall 成功，会在标准输出打印 "Hello, syscall!\n"
//            如果 syscall 失败，会打印错误信息。
```

**代码解释：**

* 我们导入了 `syscall` 包，这是进行底层系统调用操作的关键包。
* `syscall.SYS_WRITE` 就是来自 `zsysnum_openbsd_mips64.go` 中定义的常量。
* `syscall.Syscall` 函数允许我们指定系统调用号 (`syscall.SYS_WRITE`) 和参数 (文件描述符 `fd`，缓冲区地址 `addr`，写入字节数 `count`) 来执行系统调用。
* `unsafe.Pointer` 用于获取字符串数据的内存地址。
* `uintptr` 用于进行类型转换，因为 `syscall.Syscall` 的参数是 `uintptr` 类型。

**更推荐的 Go 代码示例 (使用标准库)**

实际上，我们应该使用 Go 标准库提供的更高级的抽象，例如 `os` 包中的函数：

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	// 使用 os.Stdout (对应文件描述符 1)
	_, err := os.Stdout.WriteString("Hello, standard library!\n")
	if err != nil {
		fmt.Printf("os.Stdout.WriteString failed: %v\n", err)
	}

	// 或者使用更通用的 os.WriteFile
	message := []byte("Hello from WriteFile!\n")
	err = os.WriteFile("output.txt", message, 0644)
	if err != nil {
		fmt.Printf("os.WriteFile failed: %v\n", err)
	}
}

// 假设的输入：无
// 假设的输出：会在标准输出打印 "Hello, standard library!\n"
//            会创建一个名为 "output.txt" 的文件，内容为 "Hello from WriteFile!\n"
```

**代码解释：**

* `os.Stdout.WriteString` 内部会调用底层的 `write` 系统调用（在 OpenBSD/MIPS64 上对应 `SYS_WRITE`），但我们不需要直接指定系统调用号。
* `os.WriteFile` 提供了更便捷的文件写入功能。

**命令行参数的具体处理:**

这个 `zsysnum_openbsd_mips64.go` 文件本身**不处理任何命令行参数**。它只是一个定义常量的 Go 源代码文件。

顶部的注释 `// go run mksysnum.go https://cvsweb.openbsd.org/cgi-bin/cvsweb/~checkout~/src/sys/kern/syscalls.master` 表明这个文件是**由另一个 Go 程序 `mksysnum.go` 自动生成的**。 `mksysnum.go` 才是负责处理命令行参数的程序。

`mksysnum.go` 的功能是：

1. **接收一个 URL 作为命令行参数:**  这个 URL 指向 OpenBSD 源代码仓库中的 `syscalls.master` 文件。
2. **解析 `syscalls.master` 文件:** 这个文件包含了 OpenBSD 系统调用的定义，包括名称和编号。
3. **生成 `zsysnum_openbsd_mips64.go` 文件:**  `mksysnum.go` 会根据解析到的信息，为 OpenBSD/MIPS64 架构生成包含系统调用号常量的 Go 代码文件。

**使用者易犯错的点:**

1. **忽略弃用警告，直接使用 `syscall.Syscall` 和这些 `SYS_` 常量:**  虽然 Go 提供了直接调用系统调用的能力，但这样做会使代码与特定操作系统和架构绑定，降低可移植性。标准库提供的封装函数通常更安全、更易用。

   ```go
   // 不推荐的做法
   syscall.Syscall(syscall.SYS_OPEN, ...)

   // 推荐的做法
   os.Open(...)
   ```

2. **混淆系统调用号和高级 API:**  初学者可能会误以为这些 `SYS_` 常量就是可以直接调用的函数。实际上，它们只是数字标识符，需要配合 `syscall.Syscall` 等函数才能发起真正的系统调用。

3. **在不适用的平台上使用这些常量:**  `zsysnum_openbsd_mips64.go` 只适用于 OpenBSD/MIPS64。在其他操作系统或架构下使用这些常量会导致错误或不可预测的行为。Go 的构建约束会帮助避免这种情况，但在跨平台开发时需要特别注意。

总而言之，`zsysnum_openbsd_mips64.go` 是 Go 语言为了支持在 OpenBSD/MIPS64 架构上进行底层系统调用而生成的一个数据文件，它定义了系统调用的编号。虽然可以直接使用这些常量进行系统调用，但官方更推荐使用 Go 标准库提供的、基于 C 库封装的更高级抽象。

Prompt: 
```
这是路径为go/src/cmd/vendor/golang.org/x/sys/unix/zsysnum_openbsd_mips64.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，

"""
// go run mksysnum.go https://cvsweb.openbsd.org/cgi-bin/cvsweb/~checkout~/src/sys/kern/syscalls.master
// Code generated by the command above; see README.md. DO NOT EDIT.

//go:build mips64 && openbsd

package unix

// Deprecated: Use libc wrappers instead of direct syscalls.
const (
	SYS_EXIT           = 1   // { void sys_exit(int rval); }
	SYS_FORK           = 2   // { int sys_fork(void); }
	SYS_READ           = 3   // { ssize_t sys_read(int fd, void *buf, size_t nbyte); }
	SYS_WRITE          = 4   // { ssize_t sys_write(int fd, const void *buf, size_t nbyte); }
	SYS_OPEN           = 5   // { int sys_open(const char *path, int flags, ... mode_t mode); }
	SYS_CLOSE          = 6   // { int sys_close(int fd); }
	SYS_GETENTROPY     = 7   // { int sys_getentropy(void *buf, size_t nbyte); }
	SYS___TFORK        = 8   // { int sys___tfork(const struct __tfork *param, size_t psize); }
	SYS_LINK           = 9   // { int sys_link(const char *path, const char *link); }
	SYS_UNLINK         = 10  // { int sys_unlink(const char *path); }
	SYS_WAIT4          = 11  // { pid_t sys_wait4(pid_t pid, int *status, int options, struct rusage *rusage); }
	SYS_CHDIR          = 12  // { int sys_chdir(const char *path); }
	SYS_FCHDIR         = 13  // { int sys_fchdir(int fd); }
	SYS_MKNOD          = 14  // { int sys_mknod(const char *path, mode_t mode, dev_t dev); }
	SYS_CHMOD          = 15  // { int sys_chmod(const char *path, mode_t mode); }
	SYS_CHOWN          = 16  // { int sys_chown(const char *path, uid_t uid, gid_t gid); }
	SYS_OBREAK         = 17  // { int sys_obreak(char *nsize); } break
	SYS_GETDTABLECOUNT = 18  // { int sys_getdtablecount(void); }
	SYS_GETRUSAGE      = 19  // { int sys_getrusage(int who, struct rusage *rusage); }
	SYS_GETPID         = 20  // { pid_t sys_getpid(void); }
	SYS_MOUNT          = 21  // { int sys_mount(const char *type, const char *path, int flags, void *data); }
	SYS_UNMOUNT        = 22  // { int sys_unmount(const char *path, int flags); }
	SYS_SETUID         = 23  // { int sys_setuid(uid_t uid); }
	SYS_GETUID         = 24  // { uid_t sys_getuid(void); }
	SYS_GETEUID        = 25  // { uid_t sys_geteuid(void); }
	SYS_PTRACE         = 26  // { int sys_ptrace(int req, pid_t pid, caddr_t addr, int data); }
	SYS_RECVMSG        = 27  // { ssize_t sys_recvmsg(int s, struct msghdr *msg, int flags); }
	SYS_SENDMSG        = 28  // { ssize_t sys_sendmsg(int s, const struct msghdr *msg, int flags); }
	SYS_RECVFROM       = 29  // { ssize_t sys_recvfrom(int s, void *buf, size_t len, int flags, struct sockaddr *from, socklen_t *fromlenaddr); }
	SYS_ACCEPT         = 30  // { int sys_accept(int s, struct sockaddr *name, socklen_t *anamelen); }
	SYS_GETPEERNAME    = 31  // { int sys_getpeername(int fdes, struct sockaddr *asa, socklen_t *alen); }
	SYS_GETSOCKNAME    = 32  // { int sys_getsockname(int fdes, struct sockaddr *asa, socklen_t *alen); }
	SYS_ACCESS         = 33  // { int sys_access(const char *path, int amode); }
	SYS_CHFLAGS        = 34  // { int sys_chflags(const char *path, u_int flags); }
	SYS_FCHFLAGS       = 35  // { int sys_fchflags(int fd, u_int flags); }
	SYS_SYNC           = 36  // { void sys_sync(void); }
	SYS_MSYSCALL       = 37  // { int sys_msyscall(void *addr, size_t len); }
	SYS_STAT           = 38  // { int sys_stat(const char *path, struct stat *ub); }
	SYS_GETPPID        = 39  // { pid_t sys_getppid(void); }
	SYS_LSTAT          = 40  // { int sys_lstat(const char *path, struct stat *ub); }
	SYS_DUP            = 41  // { int sys_dup(int fd); }
	SYS_FSTATAT        = 42  // { int sys_fstatat(int fd, const char *path, struct stat *buf, int flag); }
	SYS_GETEGID        = 43  // { gid_t sys_getegid(void); }
	SYS_PROFIL         = 44  // { int sys_profil(caddr_t samples, size_t size, u_long offset, u_int scale); }
	SYS_KTRACE         = 45  // { int sys_ktrace(const char *fname, int ops, int facs, pid_t pid); }
	SYS_SIGACTION      = 46  // { int sys_sigaction(int signum, const struct sigaction *nsa, struct sigaction *osa); }
	SYS_GETGID         = 47  // { gid_t sys_getgid(void); }
	SYS_SIGPROCMASK    = 48  // { int sys_sigprocmask(int how, sigset_t mask); }
	SYS_SETLOGIN       = 50  // { int sys_setlogin(const char *namebuf); }
	SYS_ACCT           = 51  // { int sys_acct(const char *path); }
	SYS_SIGPENDING     = 52  // { int sys_sigpending(void); }
	SYS_FSTAT          = 53  // { int sys_fstat(int fd, struct stat *sb); }
	SYS_IOCTL          = 54  // { int sys_ioctl(int fd, u_long com, ... void *data); }
	SYS_REBOOT         = 55  // { int sys_reboot(int opt); }
	SYS_REVOKE         = 56  // { int sys_revoke(const char *path); }
	SYS_SYMLINK        = 57  // { int sys_symlink(const char *path, const char *link); }
	SYS_READLINK       = 58  // { ssize_t sys_readlink(const char *path, char *buf, size_t count); }
	SYS_EXECVE         = 59  // { int sys_execve(const char *path, char * const *argp, char * const *envp); }
	SYS_UMASK          = 60  // { mode_t sys_umask(mode_t newmask); }
	SYS_CHROOT         = 61  // { int sys_chroot(const char *path); }
	SYS_GETFSSTAT      = 62  // { int sys_getfsstat(struct statfs *buf, size_t bufsize, int flags); }
	SYS_STATFS         = 63  // { int sys_statfs(const char *path, struct statfs *buf); }
	SYS_FSTATFS        = 64  // { int sys_fstatfs(int fd, struct statfs *buf); }
	SYS_FHSTATFS       = 65  // { int sys_fhstatfs(const fhandle_t *fhp, struct statfs *buf); }
	SYS_VFORK          = 66  // { int sys_vfork(void); }
	SYS_GETTIMEOFDAY   = 67  // { int sys_gettimeofday(struct timeval *tp, struct timezone *tzp); }
	SYS_SETTIMEOFDAY   = 68  // { int sys_settimeofday(const struct timeval *tv, const struct timezone *tzp); }
	SYS_SETITIMER      = 69  // { int sys_setitimer(int which, const struct itimerval *itv, struct itimerval *oitv); }
	SYS_GETITIMER      = 70  // { int sys_getitimer(int which, struct itimerval *itv); }
	SYS_SELECT         = 71  // { int sys_select(int nd, fd_set *in, fd_set *ou, fd_set *ex, struct timeval *tv); }
	SYS_KEVENT         = 72  // { int sys_kevent(int fd, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout); }
	SYS_MUNMAP         = 73  // { int sys_munmap(void *addr, size_t len); }
	SYS_MPROTECT       = 74  // { int sys_mprotect(void *addr, size_t len, int prot); }
	SYS_MADVISE        = 75  // { int sys_madvise(void *addr, size_t len, int behav); }
	SYS_UTIMES         = 76  // { int sys_utimes(const char *path, const struct timeval *tptr); }
	SYS_FUTIMES        = 77  // { int sys_futimes(int fd, const struct timeval *tptr); }
	SYS_GETGROUPS      = 79  // { int sys_getgroups(int gidsetsize, gid_t *gidset); }
	SYS_SETGROUPS      = 80  // { int sys_setgroups(int gidsetsize, const gid_t *gidset); }
	SYS_GETPGRP        = 81  // { int sys_getpgrp(void); }
	SYS_SETPGID        = 82  // { int sys_setpgid(pid_t pid, pid_t pgid); }
	SYS_FUTEX          = 83  // { int sys_futex(uint32_t *f, int op, int val, const struct timespec *timeout, uint32_t *g); }
	SYS_UTIMENSAT      = 84  // { int sys_utimensat(int fd, const char *path, const struct timespec *times, int flag); }
	SYS_FUTIMENS       = 85  // { int sys_futimens(int fd, const struct timespec *times); }
	SYS_KBIND          = 86  // { int sys_kbind(const struct __kbind *param, size_t psize, int64_t proc_cookie); }
	SYS_CLOCK_GETTIME  = 87  // { int sys_clock_gettime(clockid_t clock_id, struct timespec *tp); }
	SYS_CLOCK_SETTIME  = 88  // { int sys_clock_settime(clockid_t clock_id, const struct timespec *tp); }
	SYS_CLOCK_GETRES   = 89  // { int sys_clock_getres(clockid_t clock_id, struct timespec *tp); }
	SYS_DUP2           = 90  // { int sys_dup2(int from, int to); }
	SYS_NANOSLEEP      = 91  // { int sys_nanosleep(const struct timespec *rqtp, struct timespec *rmtp); }
	SYS_FCNTL          = 92  // { int sys_fcntl(int fd, int cmd, ... void *arg); }
	SYS_ACCEPT4        = 93  // { int sys_accept4(int s, struct sockaddr *name, socklen_t *anamelen, int flags); }
	SYS___THRSLEEP     = 94  // { int sys___thrsleep(const volatile void *ident, clockid_t clock_id, const struct timespec *tp, void *lock, const int *abort); }
	SYS_FSYNC          = 95  // { int sys_fsync(int fd); }
	SYS_SETPRIORITY    = 96  // { int sys_setpriority(int which, id_t who, int prio); }
	SYS_SOCKET         = 97  // { int sys_socket(int domain, int type, int protocol); }
	SYS_CONNECT        = 98  // { int sys_connect(int s, const struct sockaddr *name, socklen_t namelen); }
	SYS_GETDENTS       = 99  // { int sys_getdents(int fd, void *buf, size_t buflen); }
	SYS_GETPRIORITY    = 100 // { int sys_getpriority(int which, id_t who); }
	SYS_PIPE2          = 101 // { int sys_pipe2(int *fdp, int flags); }
	SYS_DUP3           = 102 // { int sys_dup3(int from, int to, int flags); }
	SYS_SIGRETURN      = 103 // { int sys_sigreturn(struct sigcontext *sigcntxp); }
	SYS_BIND           = 104 // { int sys_bind(int s, const struct sockaddr *name, socklen_t namelen); }
	SYS_SETSOCKOPT     = 105 // { int sys_setsockopt(int s, int level, int name, const void *val, socklen_t valsize); }
	SYS_LISTEN         = 106 // { int sys_listen(int s, int backlog); }
	SYS_CHFLAGSAT      = 107 // { int sys_chflagsat(int fd, const char *path, u_int flags, int atflags); }
	SYS_PLEDGE         = 108 // { int sys_pledge(const char *promises, const char *execpromises); }
	SYS_PPOLL          = 109 // { int sys_ppoll(struct pollfd *fds, u_int nfds, const struct timespec *ts, const sigset_t *mask); }
	SYS_PSELECT        = 110 // { int sys_pselect(int nd, fd_set *in, fd_set *ou, fd_set *ex, const struct timespec *ts, const sigset_t *mask); }
	SYS_SIGSUSPEND     = 111 // { int sys_sigsuspend(int mask); }
	SYS_SENDSYSLOG     = 112 // { int sys_sendsyslog(const char *buf, size_t nbyte, int flags); }
	SYS_UNVEIL         = 114 // { int sys_unveil(const char *path, const char *permissions); }
	SYS___REALPATH     = 115 // { int sys___realpath(const char *pathname, char *resolved); }
	SYS_GETSOCKOPT     = 118 // { int sys_getsockopt(int s, int level, int name, void *val, socklen_t *avalsize); }
	SYS_THRKILL        = 119 // { int sys_thrkill(pid_t tid, int signum, void *tcb); }
	SYS_READV          = 120 // { ssize_t sys_readv(int fd, const struct iovec *iovp, int iovcnt); }
	SYS_WRITEV         = 121 // { ssize_t sys_writev(int fd, const struct iovec *iovp, int iovcnt); }
	SYS_KILL           = 122 // { int sys_kill(int pid, int signum); }
	SYS_FCHOWN         = 123 // { int sys_fchown(int fd, uid_t uid, gid_t gid); }
	SYS_FCHMOD         = 124 // { int sys_fchmod(int fd, mode_t mode); }
	SYS_SETREUID       = 126 // { int sys_setreuid(uid_t ruid, uid_t euid); }
	SYS_SETREGID       = 127 // { int sys_setregid(gid_t rgid, gid_t egid); }
	SYS_RENAME         = 128 // { int sys_rename(const char *from, const char *to); }
	SYS_FLOCK          = 131 // { int sys_flock(int fd, int how); }
	SYS_MKFIFO         = 132 // { int sys_mkfifo(const char *path, mode_t mode); }
	SYS_SENDTO         = 133 // { ssize_t sys_sendto(int s, const void *buf, size_t len, int flags, const struct sockaddr *to, socklen_t tolen); }
	SYS_SHUTDOWN       = 134 // { int sys_shutdown(int s, int how); }
	SYS_SOCKETPAIR     = 135 // { int sys_socketpair(int domain, int type, int protocol, int *rsv); }
	SYS_MKDIR          = 136 // { int sys_mkdir(const char *path, mode_t mode); }
	SYS_RMDIR          = 137 // { int sys_rmdir(const char *path); }
	SYS_ADJTIME        = 140 // { int sys_adjtime(const struct timeval *delta, struct timeval *olddelta); }
	SYS_GETLOGIN_R     = 141 // { int sys_getlogin_r(char *namebuf, u_int namelen); }
	SYS_SETSID         = 147 // { int sys_setsid(void); }
	SYS_QUOTACTL       = 148 // { int sys_quotactl(const char *path, int cmd, int uid, char *arg); }
	SYS_NFSSVC         = 155 // { int sys_nfssvc(int flag, void *argp); }
	SYS_GETFH          = 161 // { int sys_getfh(const char *fname, fhandle_t *fhp); }
	SYS___TMPFD        = 164 // { int sys___tmpfd(int flags); }
	SYS_SYSARCH        = 165 // { int sys_sysarch(int op, void *parms); }
	SYS_PREAD          = 173 // { ssize_t sys_pread(int fd, void *buf, size_t nbyte, int pad, off_t offset); }
	SYS_PWRITE         = 174 // { ssize_t sys_pwrite(int fd, const void *buf, size_t nbyte, int pad, off_t offset); }
	SYS_SETGID         = 181 // { int sys_setgid(gid_t gid); }
	SYS_SETEGID        = 182 // { int sys_setegid(gid_t egid); }
	SYS_SETEUID        = 183 // { int sys_seteuid(uid_t euid); }
	SYS_PATHCONF       = 191 // { long sys_pathconf(const char *path, int name); }
	SYS_FPATHCONF      = 192 // { long sys_fpathconf(int fd, int name); }
	SYS_SWAPCTL        = 193 // { int sys_swapctl(int cmd, const void *arg, int misc); }
	SYS_GETRLIMIT      = 194 // { int sys_getrlimit(int which, struct rlimit *rlp); }
	SYS_SETRLIMIT      = 195 // { int sys_setrlimit(int which, const struct rlimit *rlp); }
	SYS_MMAP           = 197 // { void *sys_mmap(void *addr, size_t len, int prot, int flags, int fd, long pad, off_t pos); }
	SYS_LSEEK          = 199 // { off_t sys_lseek(int fd, int pad, off_t offset, int whence); }
	SYS_TRUNCATE       = 200 // { int sys_truncate(const char *path, int pad, off_t length); }
	SYS_FTRUNCATE      = 201 // { int sys_ftruncate(int fd, int pad, off_t length); }
	SYS_SYSCTL         = 202 // { int sys_sysctl(const int *name, u_int namelen, void *old, size_t *oldlenp, void *new, size_t newlen); }
	SYS_MLOCK          = 203 // { int sys_mlock(const void *addr, size_t len); }
	SYS_MUNLOCK        = 204 // { int sys_munlock(const void *addr, size_t len); }
	SYS_GETPGID        = 207 // { pid_t sys_getpgid(pid_t pid); }
	SYS_UTRACE         = 209 // { int sys_utrace(const char *label, const void *addr, size_t len); }
	SYS_SEMGET         = 221 // { int sys_semget(key_t key, int nsems, int semflg); }
	SYS_MSGGET         = 225 // { int sys_msgget(key_t key, int msgflg); }
	SYS_MSGSND         = 226 // { int sys_msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg); }
	SYS_MSGRCV         = 227 // { int sys_msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg); }
	SYS_SHMAT          = 228 // { void *sys_shmat(int shmid, const void *shmaddr, int shmflg); }
	SYS_SHMDT          = 230 // { int sys_shmdt(const void *shmaddr); }
	SYS_MINHERIT       = 250 // { int sys_minherit(void *addr, size_t len, int inherit); }
	SYS_POLL           = 252 // { int sys_poll(struct pollfd *fds, u_int nfds, int timeout); }
	SYS_ISSETUGID      = 253 // { int sys_issetugid(void); }
	SYS_LCHOWN         = 254 // { int sys_lchown(const char *path, uid_t uid, gid_t gid); }
	SYS_GETSID         = 255 // { pid_t sys_getsid(pid_t pid); }
	SYS_MSYNC          = 256 // { int sys_msync(void *addr, size_t len, int flags); }
	SYS_PIPE           = 263 // { int sys_pipe(int *fdp); }
	SYS_FHOPEN         = 264 // { int sys_fhopen(const fhandle_t *fhp, int flags); }
	SYS_PREADV         = 267 // { ssize_t sys_preadv(int fd, const struct iovec *iovp, int iovcnt, int pad, off_t offset); }
	SYS_PWRITEV        = 268 // { ssize_t sys_pwritev(int fd, const struct iovec *iovp, int iovcnt, int pad, off_t offset); }
	SYS_KQUEUE         = 269 // { int sys_kqueue(void); }
	SYS_MLOCKALL       = 271 // { int sys_mlockall(int flags); }
	SYS_MUNLOCKALL     = 272 // { int sys_munlockall(void); }
	SYS_GETRESUID      = 281 // { int sys_getresuid(uid_t *ruid, uid_t *euid, uid_t *suid); }
	SYS_SETRESUID      = 282 // { int sys_setresuid(uid_t ruid, uid_t euid, uid_t suid); }
	SYS_GETRESGID      = 283 // { int sys_getresgid(gid_t *rgid, gid_t *egid, gid_t *sgid); }
	SYS_SETRESGID      = 284 // { int sys_setresgid(gid_t rgid, gid_t egid, gid_t sgid); }
	SYS_MQUERY         = 286 // { void *sys_mquery(void *addr, size_t len, int prot, int flags, int fd, long pad, off_t pos); }
	SYS_CLOSEFROM      = 287 // { int sys_closefrom(int fd); }
	SYS_SIGALTSTACK    = 288 // { int sys_sigaltstack(const struct sigaltstack *nss, struct sigaltstack *oss); }
	SYS_SHMGET         = 289 // { int sys_shmget(key_t key, size_t size, int shmflg); }
	SYS_SEMOP          = 290 // { int sys_semop(int semid, struct sembuf *sops, size_t nsops); }
	SYS_FHSTAT         = 294 // { int sys_fhstat(const fhandle_t *fhp, struct stat *sb); }
	SYS___SEMCTL       = 295 // { int sys___semctl(int semid, int semnum, int cmd, union semun *arg); }
	SYS_SHMCTL         = 296 // { int sys_shmctl(int shmid, int cmd, struct shmid_ds *buf); }
	SYS_MSGCTL         = 297 // { int sys_msgctl(int msqid, int cmd, struct msqid_ds *buf); }
	SYS_SCHED_YIELD    = 298 // { int sys_sched_yield(void); }
	SYS_GETTHRID       = 299 // { pid_t sys_getthrid(void); }
	SYS___THRWAKEUP    = 301 // { int sys___thrwakeup(const volatile void *ident, int n); }
	SYS___THREXIT      = 302 // { void sys___threxit(pid_t *notdead); }
	SYS___THRSIGDIVERT = 303 // { int sys___thrsigdivert(sigset_t sigmask, siginfo_t *info, const struct timespec *timeout); }
	SYS___GETCWD       = 304 // { int sys___getcwd(char *buf, size_t len); }
	SYS_ADJFREQ        = 305 // { int sys_adjfreq(const int64_t *freq, int64_t *oldfreq); }
	SYS_SETRTABLE      = 310 // { int sys_setrtable(int rtableid); }
	SYS_GETRTABLE      = 311 // { int sys_getrtable(void); }
	SYS_FACCESSAT      = 313 // { int sys_faccessat(int fd, const char *path, int amode, int flag); }
	SYS_FCHMODAT       = 314 // { int sys_fchmodat(int fd, const char *path, mode_t mode, int flag); }
	SYS_FCHOWNAT       = 315 // { int sys_fchownat(int fd, const char *path, uid_t uid, gid_t gid, int flag); }
	SYS_LINKAT         = 317 // { int sys_linkat(int fd1, const char *path1, int fd2, const char *path2, int flag); }
	SYS_MKDIRAT        = 318 // { int sys_mkdirat(int fd, const char *path, mode_t mode); }
	SYS_MKFIFOAT       = 319 // { int sys_mkfifoat(int fd, const char *path, mode_t mode); }
	SYS_MKNODAT        = 320 // { int sys_mknodat(int fd, const char *path, mode_t mode, dev_t dev); }
	SYS_OPENAT         = 321 // { int sys_openat(int fd, const char *path, int flags, ... mode_t mode); }
	SYS_READLINKAT     = 322 // { ssize_t sys_readlinkat(int fd, const char *path, char *buf, size_t count); }
	SYS_RENAMEAT       = 323 // { int sys_renameat(int fromfd, const char *from, int tofd, const char *to); }
	SYS_SYMLINKAT      = 324 // { int sys_symlinkat(const char *path, int fd, const char *link); }
	SYS_UNLINKAT       = 325 // { int sys_unlinkat(int fd, const char *path, int flag); }
	SYS___SET_TCB      = 329 // { void sys___set_tcb(void *tcb); }
	SYS___GET_TCB      = 330 // { void *sys___get_tcb(void); }
)

"""



```
Response:
Let's break down the thought process for analyzing the provided Go code snippet.

**1. Understanding the Goal:**

The request asks for the functionality of the given Go code file, to infer its purpose within the larger Go ecosystem, provide illustrative Go code examples, explain command-line parameter handling (if applicable), and highlight potential pitfalls for users.

**2. Initial Code Examination and Key Observations:**

* **`// go run mksyscall_aix_ppc.go -aix -tags aix,ppc syscall_aix.go syscall_aix_ppc.go`:** This is a crucial starting point. It tells us this file is *generated* by a tool (`mksyscall_aix_ppc.go`). The flags `-aix` and `-tags aix,ppc` strongly suggest this code is specific to the AIX operating system and the PPC (PowerPC) architecture. The input files `syscall_aix.go` and `syscall_aix_ppc.go` further reinforce this.
* **`// Code generated by the command above; see README.md. DO NOT EDIT.`:**  Another clear indicator that manual modification is discouraged.
* **`//go:build aix && ppc`:** This is a Go build constraint, confirming that this code is only compiled when targeting AIX and PPC.
* **`package unix`:** This places the code within the `unix` package, which is part of the `golang.org/x/sys/unix` repository and provides low-level system call interfaces.
* **`/* ... #include <...> ... */`:**  This embedded C code is the core of the file's purpose. It declares numerous C functions like `utimes`, `getcwd`, `accept`, etc. These are standard Unix/POSIX system calls.
* **`import "C"`:** This Go import enables interaction with the embedded C code using Cgo.
* **Numerous Go functions with similar structures:**  Each function follows a pattern:
    * Takes Go types as input (often strings, byte slices, or structs).
    * Converts these Go types to C types (using `C.CString`, `C.uintptr_t`, `unsafe.Pointer`, etc.).
    * Calls the corresponding C function declared in the `/* ... */` block.
    * Handles the return value from the C function. Typically, a return value of `-1` indicates an error, and the C `errno` is converted to a Go `error`.
    * Converts C return values back to Go types.

**3. Inferring Functionality and Purpose:**

Based on the observations, the primary function of this file is to provide Go interfaces to standard Unix system calls for the AIX/PPC platform. It acts as a bridge between Go code and the operating system kernel.

**4. Illustrative Go Code Examples:**

To demonstrate the usage, it's natural to pick a few representative system calls and show how to call the corresponding Go functions. Examples chosen should cover common scenarios like file operations (`Open`, `Read`, `Write`, `Close`), process management (`Getpid`), and potentially networking (`socket`, `bind`). It's important to include error handling in these examples.

**5. Command-Line Parameter Handling:**

The initial comment `// go run mksyscall_aix_ppc.go ...` reveals how this file is *generated*, but it doesn't handle command-line parameters when the generated code is *used*. Therefore, the conclusion is that the *generated* file itself doesn't directly process command-line arguments.

**6. Identifying Potential Pitfalls:**

This is where understanding Cgo and low-level system calls is crucial. Common pitfalls include:

* **String/Byte Slice Handling:** Incorrectly converting Go strings/byte slices to C strings can lead to memory issues (e.g., forgetting to free `C.CString` allocations, though the generated code seems to handle this). Passing incorrect sizes is another risk.
* **Pointer Usage:**  System calls often involve pointers. Incorrectly using `unsafe.Pointer` or passing nil pointers can cause crashes.
* **Error Handling:**  Ignoring the returned `error` value is a major mistake. System calls can fail for various reasons.
* **Platform-Specific Behavior:**  The code is specific to AIX/PPC. Assuming it will work on other operating systems is wrong.
* **Understanding System Call Semantics:**  Users need to understand the meaning of the system call arguments and return values, which are often documented in man pages.

**7. Structuring the Answer:**

Organize the findings logically:

* Start with a high-level summary of the file's function.
* Explain the code generation process and the role of Cgo.
* Provide concrete Go code examples.
* Clearly state that this generated file doesn't handle command-line arguments directly.
* List common pitfalls with illustrative code snippets showing the wrong way to do things and explaining the consequences.

**Self-Correction/Refinement during the Thought Process:**

* **Initial thought:**  Maybe this file directly handles some system configurations.
* **Correction:**  The code structure clearly shows it's a thin wrapper around C system calls. Configuration might happen in the *generator* script or elsewhere in the `unix` package.
* **Initial thought:**  Focus on complex system calls for examples.
* **Refinement:** Start with simpler, more common system calls to make the examples easier to understand. Then, perhaps mention more advanced ones.
* **Initial thought:**  Provide very detailed explanations of each system call.
* **Refinement:**  Keep the explanations concise and focus on the Go usage and potential pitfalls. Referencing system call documentation (man pages) is more efficient.

By following these steps, combining code analysis with an understanding of the Go ecosystem and Cgo, one can arrive at a comprehensive and accurate answer to the request.
这个Go语言源文件 `zsyscall_aix_ppc.go` 的主要功能是 **为 AIX 操作系统上的 PowerPC (ppc) 架构提供 Go 语言访问底层操作系统系统调用的接口。**

具体来说，它通过 `cgo` 技术，将 Go 语言函数映射到 AIX/PPC 平台上的 C 语言系统调用。 这样，Go 程序就可以像调用普通 Go 函数一样调用这些系统调用，从而执行诸如文件操作、进程管理、网络通信等底层操作。

**更详细的功能列表：**

该文件中的每个 Go 函数都对应着一个 AIX/PPC 上的系统调用。  从代码中 `#include` 部分可以看出，它提供了以下系统调用的 Go 语言接口：

* **文件和目录操作:**
    * `utimes`, `utimensat`: 修改文件的时间戳。
    * `getcwd`: 获取当前工作目录。
    * `getdirent`: 读取目录项。
    * `mkdir`, `mkdirat`: 创建目录。
    * `mkfifo`: 创建命名管道 (FIFO)。
    * `mknod`, `mknodat`: 创建特殊文件（设备文件等）。
    * `open64`, `openat`: 打开文件。
    * `read`, `readlink`: 读取文件内容和符号链接目标。
    * `renameat`: 重命名文件或目录。
    * `unlink`, `unlinkat`: 删除文件。
    * `ustat`: 获取文件系统统计信息（已过时）。
    * `write`: 写入文件。
    * `faccessat`: 检查文件访问权限。
    * `fchdir`: 改变当前工作目录到文件描述符对应的目录。
    * `fchmod`, `fchmodat`: 修改文件的权限。
    * `fchownat`, `fchown`: 修改文件的所有者和组。
    * `fdatasync`: 将文件数据同步到磁盘。
    * `truncate`, `ftruncate`: 截断文件到指定长度。
    * `lchown`: 修改符号链接的所有者和组。
    * `lstat`: 获取符号链接的元数据。
    * `stat`, `fstat`, `fstatat`: 获取文件的元数据。
    * `statfs`, `fstatfs`: 获取文件系统统计信息。
* **进程管理:**
    * `wait4`: 等待子进程结束。
    * `exit`: 终止当前进程。
    * `getpgid`, `setpgid`: 获取和设置进程组 ID。
    * `getpgrp`: 获取当前进程组 ID。
    * `getpid`: 获取当前进程 ID。
    * `getppid`: 获取父进程 ID。
    * `getpriority`, `setpriority`: 获取和设置进程优先级。
    * `getrusage`: 获取进程资源使用情况。
    * `getsid`, `setsid`: 获取和创建会话 ID。
    * `kill`: 发送信号给进程。
    * `pause`: 暂停进程直到接收到信号。
    * `setdomainname`, `sethostname`: 设置域名和主机名。
    * `setuid`, `setgid`, `setregid`, `setreuid`: 设置用户和组 ID。
* **内存管理:**
    * `munmap`: 取消内存映射。
    * `madvise`: 向内核提供关于内存区域使用模式的建议。
    * `mprotect`: 修改内存区域的保护属性。
    * `mlock`, `mlockall`, `munlock`, `munlockall`: 锁定和解锁内存页。
    * `msync`: 将内存映射区域的数据写回存储设备。
    * `mmap`: 创建内存映射。
* **信号处理:**
    *  (虽然没有直接的信号处理系统调用，但 `kill` 函数可以发送信号)
* **时间管理:**
    * `nanosleep`: 使当前线程睡眠一段时间。
    * `settimeofday`, `gettimeofday`: 设置和获取系统时间。
    * `times`: 获取进程和子进程的 CPU 时间。
    * `time`: 获取当前时间。
    * `Utime`:  使用 `utimbuf` 结构体修改文件时间戳 (已过时，推荐使用 `utimes`)。
* **设备和文件系统:**
    * `ioctl`:  执行设备特定的控制操作。
    * `sync`: 将所有文件系统缓存刷新到磁盘。
    * `umount`: 卸载文件系统。
* **网络通信:**
    * `accept`: 接受连接。
    * `bind`: 绑定套接字到本地地址。
    * `connect`: 连接到远程地址。
    * `getgroups`, `setgroups`: 获取和设置当前进程的附属组 ID。
    * `getsockopt`, `setsockopt`: 获取和设置套接字选项。
    * `socket`, `socketpair`: 创建套接字。
    * `getpeername`, `getsockname`: 获取连接的对端地址和本地地址。
    * `recvfrom`, `sendto`: 在无连接的套接字上接收和发送数据。
    * `recvmsg`, `sendmsg`: 在套接字上接收和发送消息（支持更复杂的控制信息）。
    * `listen`: 监听连接。
    * `shutdown`: 关闭套接字的部分或全部连接。
* **其他:**
    * `fcntl`: 执行文件控制操作（例如，获取/设置文件描述符标志、文件锁）。
    * `fsync_range`: 将文件指定范围的数据同步到磁盘。
    * `acct`: 启用或禁用进程记账。
    * `chdir`: 改变当前工作目录。
    * `chroot`: 改变进程的根目录。
    * `close`: 关闭文件描述符。
    * `dup`, `dup2`: 复制文件描述符。
    * `syslog`: 向系统日志写入消息 (在这里被别名为 `Klogctl`)。
    * `umask`: 设置文件模式创建屏蔽字。
    * `uname`: 获取系统信息。
    * `ustat`: 获取文件系统统计信息 (已过时)。
    * `dup2`: 复制文件描述符到指定的文件描述符编号。
    * `posix_fadvise64`: 向内核提供关于文件访问模式的建议。
    * `splice`: 在两个文件描述符之间移动数据。
    * `poll`: 等待一组文件描述符上的事件。
    * `getrlimit64`: 获取进程资源限制。
    * `lseek64`: 移动文件偏移量。
    * `select`, `pselect`:  I/O 多路复用，等待多个文件描述符上的事件。
    * `setregid`, `setreuid`: 设置真实和有效的组/用户 ID。
    * `getsystemcfg`: 获取系统配置信息。

**它是什么Go语言功能的实现？**

这个文件是 Go 语言标准库 `syscall` (以及其扩展 `golang.org/x/sys/unix`) 中与操作系统底层交互的核心部分。 Go 语言的很多高级特性，例如文件 I/O、进程管理、网络编程等，最终都需要通过这些底层的系统调用来实现。

**Go代码举例说明:**

假设我们要获取当前进程的 ID：

```go
package main

import (
	"fmt"
	"golang.org/x/sys/unix"
)

func main() {
	pid := unix.Getpid()
	fmt.Printf("当前进程的 PID 是: %d\n", pid)
}
```

**假设的输入与输出:**

该代码没有输入。

**输出:**

```
当前进程的 PID 是: 12345
```

(实际输出的 PID 会根据你运行程序的进程而变化)

再例如，创建一个目录：

```go
package main

import (
	"fmt"
	"golang.org/x/sys/unix"
	"os"
)

func main() {
	path := "my_new_directory"
	mode := uint32(0755) // 权限为 rwxr-xr-x

	err := unix.Mkdir(unix.AT_FDCWD, path, mode)
	if err != nil {
		fmt.Printf("创建目录失败: %v\n", err)
		return
	}
	fmt.Printf("成功创建目录: %s\n", path)

	// 清理
	os.Remove(path)
}
```

**假设的输入与输出:**

该代码的输入是目录路径 "my_new_directory"。

**输出 (如果成功):**

```
成功创建目录: my_new_directory
```

**输出 (如果失败，例如权限不足):**

```
创建目录失败: permission denied
```

**命令行参数的具体处理:**

这个 `zsyscall_aix_ppc.go` 文件本身 **不处理命令行参数**。 它的作用是提供 Go 函数来调用底层的系统调用。  命令行参数的处理通常发生在 Go 应用程序的 `main` 函数中，可以使用 `os.Args` 或 `flag` 包来解析。

**使用者易犯错的点:**

1. **不理解错误处理:**  这些底层系统调用返回的错误信息通常比较简洁。使用者需要仔细检查返回的 `error` 值，并根据错误类型进行处理。例如，文件不存在、权限不足等错误都可能导致系统调用失败。

   ```go
   package main

   import (
       "fmt"
       "golang.org/x/sys/unix"
   )

   func main() {
       fd, err := unix.Open("non_existent_file.txt", unix.O_RDONLY, 0)
       if err != nil {
           fmt.Printf("打开文件失败: %v\n", err) // 正确的做法：检查 err
           // 可以根据错误类型采取不同的处理措施
       } else {
           fmt.Println("文件打开成功")
           unix.Close(fd)
       }
   }
   ```

2. **不正确的类型转换:**  `cgo` 需要在 Go 和 C 之间进行类型转换，例如将 Go 的字符串转换为 C 的 `char*`。  如果转换不正确，可能会导致内存错误或程序崩溃。 虽然这个 *生成* 的代码已经处理了大部分类型转换，但在用户编写使用这些函数的代码时仍然需要注意。

3. **资源管理不当:**  例如，打开的文件描述符需要在使用后显式关闭。忘记关闭文件描述符可能导致资源泄漏。

   ```go
   package main

   import (
       "fmt"
       "golang.org/x/sys/unix"
   )

   func main() {
       fd, err := unix.Open("my_file.txt", unix.O_RDONLY, 0)
       if err != nil {
           fmt.Printf("打开文件失败: %v\n", err)
           return
       }
       defer unix.Close(fd) // 确保在函数退出时关闭文件描述符

       // ... 使用文件描述符 fd ...
       fmt.Println("文件操作完成")
   }
   ```

4. **平台依赖性:**  这个文件是特定于 AIX/PPC 平台的。直接使用这些函数编写的代码在其他操作系统或架构上可能无法编译或运行。如果需要编写跨平台的代码，应该使用 Go 标准库中更高级别的抽象，例如 `os` 包和 `net` 包。

总而言之，`zsyscall_aix_ppc.go` 是 Go 语言与 AIX/PPC 操作系统交互的桥梁，它暴露了底层的系统调用，使得 Go 程序能够执行各种操作系统级别的任务。 使用者需要了解系统调用的语义和潜在的错误，并进行适当的错误处理和资源管理。

Prompt: 
```
这是路径为go/src/cmd/vendor/golang.org/x/sys/unix/zsyscall_aix_ppc.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，

"""
// go run mksyscall_aix_ppc.go -aix -tags aix,ppc syscall_aix.go syscall_aix_ppc.go
// Code generated by the command above; see README.md. DO NOT EDIT.

//go:build aix && ppc

package unix

/*
#include <stdint.h>
#include <stddef.h>
int utimes(uintptr_t, uintptr_t);
int utimensat(int, uintptr_t, uintptr_t, int);
int getcwd(uintptr_t, size_t);
int accept(int, uintptr_t, uintptr_t);
int getdirent(int, uintptr_t, size_t);
int wait4(int, uintptr_t, int, uintptr_t);
int ioctl(int, int, uintptr_t);
int fcntl(uintptr_t, int, uintptr_t);
int fsync_range(int, int, long long, long long);
int acct(uintptr_t);
int chdir(uintptr_t);
int chroot(uintptr_t);
int close(int);
int dup(int);
void exit(int);
int faccessat(int, uintptr_t, unsigned int, int);
int fchdir(int);
int fchmod(int, unsigned int);
int fchmodat(int, uintptr_t, unsigned int, int);
int fchownat(int, uintptr_t, int, int, int);
int fdatasync(int);
int getpgid(int);
int getpgrp();
int getpid();
int getppid();
int getpriority(int, int);
int getrusage(int, uintptr_t);
int getsid(int);
int kill(int, int);
int syslog(int, uintptr_t, size_t);
int mkdir(int, uintptr_t, unsigned int);
int mkdirat(int, uintptr_t, unsigned int);
int mkfifo(uintptr_t, unsigned int);
int mknod(uintptr_t, unsigned int, int);
int mknodat(int, uintptr_t, unsigned int, int);
int nanosleep(uintptr_t, uintptr_t);
int open64(uintptr_t, int, unsigned int);
int openat(int, uintptr_t, int, unsigned int);
int read(int, uintptr_t, size_t);
int readlink(uintptr_t, uintptr_t, size_t);
int renameat(int, uintptr_t, int, uintptr_t);
int setdomainname(uintptr_t, size_t);
int sethostname(uintptr_t, size_t);
int setpgid(int, int);
int setsid();
int settimeofday(uintptr_t);
int setuid(int);
int setgid(int);
int setpriority(int, int, int);
int statx(int, uintptr_t, int, int, uintptr_t);
int sync();
uintptr_t times(uintptr_t);
int umask(int);
int uname(uintptr_t);
int unlink(uintptr_t);
int unlinkat(int, uintptr_t, int);
int ustat(int, uintptr_t);
int write(int, uintptr_t, size_t);
int dup2(int, int);
int posix_fadvise64(int, long long, long long, int);
int fchown(int, int, int);
int fstat(int, uintptr_t);
int fstatat(int, uintptr_t, uintptr_t, int);
int fstatfs(int, uintptr_t);
int ftruncate(int, long long);
int getegid();
int geteuid();
int getgid();
int getuid();
int lchown(uintptr_t, int, int);
int listen(int, int);
int lstat(uintptr_t, uintptr_t);
int pause();
int pread64(int, uintptr_t, size_t, long long);
int pwrite64(int, uintptr_t, size_t, long long);
#define c_select select
int select(int, uintptr_t, uintptr_t, uintptr_t, uintptr_t);
int pselect(int, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t);
int setregid(int, int);
int setreuid(int, int);
int shutdown(int, int);
long long splice(int, uintptr_t, int, uintptr_t, int, int);
int stat(uintptr_t, uintptr_t);
int statfs(uintptr_t, uintptr_t);
int truncate(uintptr_t, long long);
int bind(int, uintptr_t, uintptr_t);
int connect(int, uintptr_t, uintptr_t);
int getgroups(int, uintptr_t);
int setgroups(int, uintptr_t);
int getsockopt(int, int, int, uintptr_t, uintptr_t);
int setsockopt(int, int, int, uintptr_t, uintptr_t);
int socket(int, int, int);
int socketpair(int, int, int, uintptr_t);
int getpeername(int, uintptr_t, uintptr_t);
int getsockname(int, uintptr_t, uintptr_t);
int recvfrom(int, uintptr_t, size_t, int, uintptr_t, uintptr_t);
int sendto(int, uintptr_t, size_t, int, uintptr_t, uintptr_t);
int nrecvmsg(int, uintptr_t, int);
int nsendmsg(int, uintptr_t, int);
int munmap(uintptr_t, uintptr_t);
int madvise(uintptr_t, size_t, int);
int mprotect(uintptr_t, size_t, int);
int mlock(uintptr_t, size_t);
int mlockall(int);
int msync(uintptr_t, size_t, int);
int munlock(uintptr_t, size_t);
int munlockall();
int pipe(uintptr_t);
int poll(uintptr_t, int, int);
int gettimeofday(uintptr_t, uintptr_t);
int time(uintptr_t);
int utime(uintptr_t, uintptr_t);
unsigned long long getsystemcfg(int);
int umount(uintptr_t);
int getrlimit64(int, uintptr_t);
long long lseek64(int, long long, int);
uintptr_t mmap(uintptr_t, uintptr_t, int, int, int, long long);

*/
import "C"
import (
	"unsafe"
)

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func utimes(path string, times *[2]Timeval) (err error) {
	_p0 := uintptr(unsafe.Pointer(C.CString(path)))
	r0, er := C.utimes(C.uintptr_t(_p0), C.uintptr_t(uintptr(unsafe.Pointer(times))))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func utimensat(dirfd int, path string, times *[2]Timespec, flag int) (err error) {
	_p0 := uintptr(unsafe.Pointer(C.CString(path)))
	r0, er := C.utimensat(C.int(dirfd), C.uintptr_t(_p0), C.uintptr_t(uintptr(unsafe.Pointer(times))), C.int(flag))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getcwd(buf []byte) (err error) {
	var _p0 *byte
	if len(buf) > 0 {
		_p0 = &buf[0]
	}
	var _p1 int
	_p1 = len(buf)
	r0, er := C.getcwd(C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) {
	r0, er := C.accept(C.int(s), C.uintptr_t(uintptr(unsafe.Pointer(rsa))), C.uintptr_t(uintptr(unsafe.Pointer(addrlen))))
	fd = int(r0)
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getdirent(fd int, buf []byte) (n int, err error) {
	var _p0 *byte
	if len(buf) > 0 {
		_p0 = &buf[0]
	}
	var _p1 int
	_p1 = len(buf)
	r0, er := C.getdirent(C.int(fd), C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1))
	n = int(r0)
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func wait4(pid Pid_t, status *_C_int, options int, rusage *Rusage) (wpid Pid_t, err error) {
	r0, er := C.wait4(C.int(pid), C.uintptr_t(uintptr(unsafe.Pointer(status))), C.int(options), C.uintptr_t(uintptr(unsafe.Pointer(rusage))))
	wpid = Pid_t(r0)
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func ioctl(fd int, req int, arg uintptr) (err error) {
	r0, er := C.ioctl(C.int(fd), C.int(req), C.uintptr_t(arg))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func ioctlPtr(fd int, req int, arg unsafe.Pointer) (err error) {
	r0, er := C.ioctl(C.int(fd), C.int(req), C.uintptr_t(uintptr(arg)))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func FcntlInt(fd uintptr, cmd int, arg int) (r int, err error) {
	r0, er := C.fcntl(C.uintptr_t(fd), C.int(cmd), C.uintptr_t(arg))
	r = int(r0)
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func FcntlFlock(fd uintptr, cmd int, lk *Flock_t) (err error) {
	r0, er := C.fcntl(C.uintptr_t(fd), C.int(cmd), C.uintptr_t(uintptr(unsafe.Pointer(lk))))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fcntl(fd int, cmd int, arg int) (val int, err error) {
	r0, er := C.fcntl(C.uintptr_t(fd), C.int(cmd), C.uintptr_t(arg))
	val = int(r0)
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fsyncRange(fd int, how int, start int64, length int64) (err error) {
	r0, er := C.fsync_range(C.int(fd), C.int(how), C.longlong(start), C.longlong(length))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Acct(path string) (err error) {
	_p0 := uintptr(unsafe.Pointer(C.CString(path)))
	r0, er := C.acct(C.uintptr_t(_p0))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Chdir(path string) (err error) {
	_p0 := uintptr(unsafe.Pointer(C.CString(path)))
	r0, er := C.chdir(C.uintptr_t(_p0))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Chroot(path string) (err error) {
	_p0 := uintptr(unsafe.Pointer(C.CString(path)))
	r0, er := C.chroot(C.uintptr_t(_p0))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Close(fd int) (err error) {
	r0, er := C.close(C.int(fd))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Dup(oldfd int) (fd int, err error) {
	r0, er := C.dup(C.int(oldfd))
	fd = int(r0)
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Exit(code int) {
	C.exit(C.int(code))
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Faccessat(dirfd int, path string, mode uint32, flags int) (err error) {
	_p0 := uintptr(unsafe.Pointer(C.CString(path)))
	r0, er := C.faccessat(C.int(dirfd), C.uintptr_t(_p0), C.uint(mode), C.int(flags))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fchdir(fd int) (err error) {
	r0, er := C.fchdir(C.int(fd))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fchmod(fd int, mode uint32) (err error) {
	r0, er := C.fchmod(C.int(fd), C.uint(mode))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) {
	_p0 := uintptr(unsafe.Pointer(C.CString(path)))
	r0, er := C.fchmodat(C.int(dirfd), C.uintptr_t(_p0), C.uint(mode), C.int(flags))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) {
	_p0 := uintptr(unsafe.Pointer(C.CString(path)))
	r0, er := C.fchownat(C.int(dirfd), C.uintptr_t(_p0), C.int(uid), C.int(gid), C.int(flags))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fdatasync(fd int) (err error) {
	r0, er := C.fdatasync(C.int(fd))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getpgid(pid int) (pgid int, err error) {
	r0, er := C.getpgid(C.int(pid))
	pgid = int(r0)
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getpgrp() (pid int) {
	r0, _ := C.getpgrp()
	pid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getpid() (pid int) {
	r0, _ := C.getpid()
	pid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getppid() (ppid int) {
	r0, _ := C.getppid()
	ppid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getpriority(which int, who int) (prio int, err error) {
	r0, er := C.getpriority(C.int(which), C.int(who))
	prio = int(r0)
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getrusage(who int, rusage *Rusage) (err error) {
	r0, er := C.getrusage(C.int(who), C.uintptr_t(uintptr(unsafe.Pointer(rusage))))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getsid(pid int) (sid int, err error) {
	r0, er := C.getsid(C.int(pid))
	sid = int(r0)
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Kill(pid int, sig Signal) (err error) {
	r0, er := C.kill(C.int(pid), C.int(sig))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Klogctl(typ int, buf []byte) (n int, err error) {
	var _p0 *byte
	if len(buf) > 0 {
		_p0 = &buf[0]
	}
	var _p1 int
	_p1 = len(buf)
	r0, er := C.syslog(C.int(typ), C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1))
	n = int(r0)
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Mkdir(dirfd int, path string, mode uint32) (err error) {
	_p0 := uintptr(unsafe.Pointer(C.CString(path)))
	r0, er := C.mkdir(C.int(dirfd), C.uintptr_t(_p0), C.uint(mode))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Mkdirat(dirfd int, path string, mode uint32) (err error) {
	_p0 := uintptr(unsafe.Pointer(C.CString(path)))
	r0, er := C.mkdirat(C.int(dirfd), C.uintptr_t(_p0), C.uint(mode))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Mkfifo(path string, mode uint32) (err error) {
	_p0 := uintptr(unsafe.Pointer(C.CString(path)))
	r0, er := C.mkfifo(C.uintptr_t(_p0), C.uint(mode))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Mknod(path string, mode uint32, dev int) (err error) {
	_p0 := uintptr(unsafe.Pointer(C.CString(path)))
	r0, er := C.mknod(C.uintptr_t(_p0), C.uint(mode), C.int(dev))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Mknodat(dirfd int, path string, mode uint32, dev int) (err error) {
	_p0 := uintptr(unsafe.Pointer(C.CString(path)))
	r0, er := C.mknodat(C.int(dirfd), C.uintptr_t(_p0), C.uint(mode), C.int(dev))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Nanosleep(time *Timespec, leftover *Timespec) (err error) {
	r0, er := C.nanosleep(C.uintptr_t(uintptr(unsafe.Pointer(time))), C.uintptr_t(uintptr(unsafe.Pointer(leftover))))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Open(path string, mode int, perm uint32) (fd int, err error) {
	_p0 := uintptr(unsafe.Pointer(C.CString(path)))
	r0, er := C.open64(C.uintptr_t(_p0), C.int(mode), C.uint(perm))
	fd = int(r0)
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) {
	_p0 := uintptr(unsafe.Pointer(C.CString(path)))
	r0, er := C.openat(C.int(dirfd), C.uintptr_t(_p0), C.int(flags), C.uint(mode))
	fd = int(r0)
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func read(fd int, p []byte) (n int, err error) {
	var _p0 *byte
	if len(p) > 0 {
		_p0 = &p[0]
	}
	var _p1 int
	_p1 = len(p)
	r0, er := C.read(C.int(fd), C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1))
	n = int(r0)
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Readlink(path string, buf []byte) (n int, err error) {
	_p0 := uintptr(unsafe.Pointer(C.CString(path)))
	var _p1 *byte
	if len(buf) > 0 {
		_p1 = &buf[0]
	}
	var _p2 int
	_p2 = len(buf)
	r0, er := C.readlink(C.uintptr_t(_p0), C.uintptr_t(uintptr(unsafe.Pointer(_p1))), C.size_t(_p2))
	n = int(r0)
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {
	_p0 := uintptr(unsafe.Pointer(C.CString(oldpath)))
	_p1 := uintptr(unsafe.Pointer(C.CString(newpath)))
	r0, er := C.renameat(C.int(olddirfd), C.uintptr_t(_p0), C.int(newdirfd), C.uintptr_t(_p1))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Setdomainname(p []byte) (err error) {
	var _p0 *byte
	if len(p) > 0 {
		_p0 = &p[0]
	}
	var _p1 int
	_p1 = len(p)
	r0, er := C.setdomainname(C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Sethostname(p []byte) (err error) {
	var _p0 *byte
	if len(p) > 0 {
		_p0 = &p[0]
	}
	var _p1 int
	_p1 = len(p)
	r0, er := C.sethostname(C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Setpgid(pid int, pgid int) (err error) {
	r0, er := C.setpgid(C.int(pid), C.int(pgid))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Setsid() (pid int, err error) {
	r0, er := C.setsid()
	pid = int(r0)
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Settimeofday(tv *Timeval) (err error) {
	r0, er := C.settimeofday(C.uintptr_t(uintptr(unsafe.Pointer(tv))))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Setuid(uid int) (err error) {
	r0, er := C.setuid(C.int(uid))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Setgid(uid int) (err error) {
	r0, er := C.setgid(C.int(uid))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Setpriority(which int, who int, prio int) (err error) {
	r0, er := C.setpriority(C.int(which), C.int(who), C.int(prio))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) {
	_p0 := uintptr(unsafe.Pointer(C.CString(path)))
	r0, er := C.statx(C.int(dirfd), C.uintptr_t(_p0), C.int(flags), C.int(mask), C.uintptr_t(uintptr(unsafe.Pointer(stat))))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Sync() {
	C.sync()
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Times(tms *Tms) (ticks uintptr, err error) {
	r0, er := C.times(C.uintptr_t(uintptr(unsafe.Pointer(tms))))
	ticks = uintptr(r0)
	if uintptr(r0) == ^uintptr(0) && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Umask(mask int) (oldmask int) {
	r0, _ := C.umask(C.int(mask))
	oldmask = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Uname(buf *Utsname) (err error) {
	r0, er := C.uname(C.uintptr_t(uintptr(unsafe.Pointer(buf))))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Unlink(path string) (err error) {
	_p0 := uintptr(unsafe.Pointer(C.CString(path)))
	r0, er := C.unlink(C.uintptr_t(_p0))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Unlinkat(dirfd int, path string, flags int) (err error) {
	_p0 := uintptr(unsafe.Pointer(C.CString(path)))
	r0, er := C.unlinkat(C.int(dirfd), C.uintptr_t(_p0), C.int(flags))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Ustat(dev int, ubuf *Ustat_t) (err error) {
	r0, er := C.ustat(C.int(dev), C.uintptr_t(uintptr(unsafe.Pointer(ubuf))))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func write(fd int, p []byte) (n int, err error) {
	var _p0 *byte
	if len(p) > 0 {
		_p0 = &p[0]
	}
	var _p1 int
	_p1 = len(p)
	r0, er := C.write(C.int(fd), C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1))
	n = int(r0)
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Dup2(oldfd int, newfd int) (err error) {
	r0, er := C.dup2(C.int(oldfd), C.int(newfd))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fadvise(fd int, offset int64, length int64, advice int) (err error) {
	r0, er := C.posix_fadvise64(C.int(fd), C.longlong(offset), C.longlong(length), C.int(advice))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fchown(fd int, uid int, gid int) (err error) {
	r0, er := C.fchown(C.int(fd), C.int(uid), C.int(gid))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fstat(fd int, stat *Stat_t) (err error) {
	r0, er := C.fstat(C.int(fd), C.uintptr_t(uintptr(unsafe.Pointer(stat))))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) {
	_p0 := uintptr(unsafe.Pointer(C.CString(path)))
	r0, er := C.fstatat(C.int(dirfd), C.uintptr_t(_p0), C.uintptr_t(uintptr(unsafe.Pointer(stat))), C.int(flags))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fstatfs(fd int, buf *Statfs_t) (err error) {
	r0, er := C.fstatfs(C.int(fd), C.uintptr_t(uintptr(unsafe.Pointer(buf))))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Ftruncate(fd int, length int64) (err error) {
	r0, er := C.ftruncate(C.int(fd), C.longlong(length))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getegid() (egid int) {
	r0, _ := C.getegid()
	egid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Geteuid() (euid int) {
	r0, _ := C.geteuid()
	euid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getgid() (gid int) {
	r0, _ := C.getgid()
	gid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getuid() (uid int) {
	r0, _ := C.getuid()
	uid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Lchown(path string, uid int, gid int) (err error) {
	_p0 := uintptr(unsafe.Pointer(C.CString(path)))
	r0, er := C.lchown(C.uintptr_t(_p0), C.int(uid), C.int(gid))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Listen(s int, n int) (err error) {
	r0, er := C.listen(C.int(s), C.int(n))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func lstat(path string, stat *Stat_t) (err error) {
	_p0 := uintptr(unsafe.Pointer(C.CString(path)))
	r0, er := C.lstat(C.uintptr_t(_p0), C.uintptr_t(uintptr(unsafe.Pointer(stat))))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pause() (err error) {
	r0, er := C.pause()
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func pread(fd int, p []byte, offset int64) (n int, err error) {
	var _p0 *byte
	if len(p) > 0 {
		_p0 = &p[0]
	}
	var _p1 int
	_p1 = len(p)
	r0, er := C.pread64(C.int(fd), C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1), C.longlong(offset))
	n = int(r0)
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func pwrite(fd int, p []byte, offset int64) (n int, err error) {
	var _p0 *byte
	if len(p) > 0 {
		_p0 = &p[0]
	}
	var _p1 int
	_p1 = len(p)
	r0, er := C.pwrite64(C.int(fd), C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1), C.longlong(offset))
	n = int(r0)
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) {
	r0, er := C.c_select(C.int(nfd), C.uintptr_t(uintptr(unsafe.Pointer(r))), C.uintptr_t(uintptr(unsafe.Pointer(w))), C.uintptr_t(uintptr(unsafe.Pointer(e))), C.uintptr_t(uintptr(unsafe.Pointer(timeout))))
	n = int(r0)
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pselect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *Sigset_t) (n int, err error) {
	r0, er := C.pselect(C.int(nfd), C.uintptr_t(uintptr(unsafe.Pointer(r))), C.uintptr_t(uintptr(unsafe.Pointer(w))), C.uintptr_t(uintptr(unsafe.Pointer(e))), C.uintptr_t(uintptr(unsafe.Pointer(timeout))), C.uintptr_t(uintptr(unsafe.Pointer(sigmask))))
	n = int(r0)
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Setregid(rgid int, egid int) (err error) {
	r0, er := C.setregid(C.int(rgid), C.int(egid))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Setreuid(ruid int, euid int) (err error) {
	r0, er := C.setreuid(C.int(ruid), C.int(euid))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Shutdown(fd int, how int) (err error) {
	r0, er := C.shutdown(C.int(fd), C.int(how))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error) {
	r0, er := C.splice(C.int(rfd), C.uintptr_t(uintptr(unsafe.Pointer(roff))), C.int(wfd), C.uintptr_t(uintptr(unsafe.Pointer(woff))), C.int(len), C.int(flags))
	n = int64(r0)
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func stat(path string, statptr *Stat_t) (err error) {
	_p0 := uintptr(unsafe.Pointer(C.CString(path)))
	r0, er := C.stat(C.uintptr_t(_p0), C.uintptr_t(uintptr(unsafe.Pointer(statptr))))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Statfs(path string, buf *Statfs_t) (err error) {
	_p0 := uintptr(unsafe.Pointer(C.CString(path)))
	r0, er := C.statfs(C.uintptr_t(_p0), C.uintptr_t(uintptr(unsafe.Pointer(buf))))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Truncate(path string, length int64) (err error) {
	_p0 := uintptr(unsafe.Pointer(C.CString(path)))
	r0, er := C.truncate(C.uintptr_t(_p0), C.longlong(length))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) {
	r0, er := C.bind(C.int(s), C.uintptr_t(uintptr(addr)), C.uintptr_t(uintptr(addrlen)))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) {
	r0, er := C.connect(C.int(s), C.uintptr_t(uintptr(addr)), C.uintptr_t(uintptr(addrlen)))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getgroups(n int, list *_Gid_t) (nn int, err error) {
	r0, er := C.getgroups(C.int(n), C.uintptr_t(uintptr(unsafe.Pointer(list))))
	nn = int(r0)
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func setgroups(n int, list *_Gid_t) (err error) {
	r0, er := C.setgroups(C.int(n), C.uintptr_t(uintptr(unsafe.Pointer(list))))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) {
	r0, er := C.getsockopt(C.int(s), C.int(level), C.int(name), C.uintptr_t(uintptr(val)), C.uintptr_t(uintptr(unsafe.Pointer(vallen))))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) {
	r0, er := C.setsockopt(C.int(s), C.int(level), C.int(name), C.uintptr_t(uintptr(val)), C.uintptr_t(vallen))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func socket(domain int, typ int, proto int) (fd int, err error) {
	r0, er := C.socket(C.int(domain), C.int(typ), C.int(proto))
	fd = int(r0)
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func socketpair(domain int, typ int, proto int, fd *[2]int32) (err error) {
	r0, er := C.socketpair(C.int(domain), C.int(typ), C.int(proto), C.uintptr_t(uintptr(unsafe.Pointer(fd))))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) {
	r0, er := C.getpeername(C.int(fd), C.uintptr_t(uintptr(unsafe.Pointer(rsa))), C.uintptr_t(uintptr(unsafe.Pointer(addrlen))))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) {
	r0, er := C.getsockname(C.int(fd), C.uintptr_t(uintptr(unsafe.Pointer(rsa))), C.uintptr_t(uintptr(unsafe.Pointer(addrlen))))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) {
	var _p0 *byte
	if len(p) > 0 {
		_p0 = &p[0]
	}
	var _p1 int
	_p1 = len(p)
	r0, er := C.recvfrom(C.int(fd), C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1), C.int(flags), C.uintptr_t(uintptr(unsafe.Pointer(from))), C.uintptr_t(uintptr(unsafe.Pointer(fromlen))))
	n = int(r0)
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func sendto(s int, buf []byte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) {
	var _p0 *byte
	if len(buf) > 0 {
		_p0 = &buf[0]
	}
	var _p1 int
	_p1 = len(buf)
	r0, er := C.sendto(C.int(s), C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1), C.int(flags), C.uintptr_t(uintptr(to)), C.uintptr_t(uintptr(addrlen)))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func recvmsg(s int, msg *Msghdr, flags int) (n int, err error) {
	r0, er := C.nrecvmsg(C.int(s), C.uintptr_t(uintptr(unsafe.Pointer(msg))), C.int(flags))
	n = int(r0)
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func sendmsg(s int, msg *Msghdr, flags int) (n int, err error) {
	r0, er := C.nsendmsg(C.int(s), C.uintptr_t(uintptr(unsafe.Pointer(msg))), C.int(flags))
	n = int(r0)
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func munmap(addr uintptr, length uintptr) (err error) {
	r0, er := C.munmap(C.uintptr_t(addr), C.uintptr_t(length))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Madvise(b []byte, advice int) (err error) {
	var _p0 *byte
	if len(b) > 0 {
		_p0 = &b[0]
	}
	var _p1 int
	_p1 = len(b)
	r0, er := C.madvise(C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1), C.int(advice))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Mprotect(b []byte, prot int) (err error) {
	var _p0 *byte
	if len(b) > 0 {
		_p0 = &b[0]
	}
	var _p1 int
	_p1 = len(b)
	r0, er := C.mprotect(C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1), C.int(prot))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Mlock(b []byte) (err error) {
	var _p0 *byte
	if len(b) > 0 {
		_p0 = &b[0]
	}
	var _p1 int
	_p1 = len(b)
	r0, er := C.mlock(C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Mlockall(flags int) (err error) {
	r0, er := C.mlockall(C.int(flags))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Msync(b []byte, flags int) (err error) {
	var _p0 *byte
	if len(b) > 0 {
		_p0 = &b[0]
	}
	var _p1 int
	_p1 = len(b)
	r0, er := C.msync(C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1), C.int(flags))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Munlock(b []byte) (err error) {
	var _p0 *byte
	if len(b) > 0 {
		_p0 = &b[0]
	}
	var _p1 int
	_p1 = len(b)
	r0, er := C.munlock(C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Munlockall() (err error) {
	r0, er := C.munlockall()
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func pipe(p *[2]_C_int) (err error) {
	r0, er := C.pipe(C.uintptr_t(uintptr(unsafe.Pointer(p))))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func poll(fds *PollFd, nfds int, timeout int) (n int, err error) {
	r0, er := C.poll(C.uintptr_t(uintptr(unsafe.Pointer(fds))), C.int(nfds), C.int(timeout))
	n = int(r0)
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func gettimeofday(tv *Timeval, tzp *Timezone) (err error) {
	r0, er := C.gettimeofday(C.uintptr_t(uintptr(unsafe.Pointer(tv))), C.uintptr_t(uintptr(unsafe.Pointer(tzp))))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Time(t *Time_t) (tt Time_t, err error) {
	r0, er := C.time(C.uintptr_t(uintptr(unsafe.Pointer(t))))
	tt = Time_t(r0)
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Utime(path string, buf *Utimbuf) (err error) {
	_p0 := uintptr(unsafe.Pointer(C.CString(path)))
	r0, er := C.utime(C.uintptr_t(_p0), C.uintptr_t(uintptr(unsafe.Pointer(buf))))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getsystemcfg(label int) (n uint64) {
	r0, _ := C.getsystemcfg(C.int(label))
	n = uint64(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func umount(target string) (err error) {
	_p0 := uintptr(unsafe.Pointer(C.CString(target)))
	r0, er := C.umount(C.uintptr_t(_p0))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getrlimit(resource int, rlim *Rlimit) (err error) {
	r0, er := C.getrlimit64(C.int(resource), C.uintptr_t(uintptr(unsafe.Pointer(rlim))))
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Seek(fd int, offset int64, whence int) (off int64, err error) {
	r0, er := C.lseek64(C.int(fd), C.longlong(offset), C.int(whence))
	off = int64(r0)
	if r0 == -1 && er != nil {
		err = er
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error) {
	r0, er := C.mmap(C.uintptr_t(addr), C.uintptr_t(length), C.int(prot), C.int(flags), C.int(fd), C.longlong(offset))
	xaddr = uintptr(r0)
	if uintptr(r0) == ^uintptr(0) && er != nil {
		err = er
	}
	return
}

"""



```
Response:
Let's break down the thought process for analyzing this Go code snippet.

**1. Initial Scan and Obvious Features:**

* **`// Code generated by the command above; see README.md. DO NOT EDIT.`**: This immediately tells us this is automatically generated code, likely from C headers. The `cgo -godefs` command reinforces this. It means we're dealing with low-level system structures and constants.
* **`//go:build arm && linux`**: This is a build constraint. The code is specific to the ARM architecture on Linux. This is crucial context.
* **`package unix`**:  This indicates the code is part of the `unix` package in the Go standard library (or an extended version). This package provides access to low-level operating system primitives.
* **`const ( ... )` and `type ... struct { ... }`**:  The code primarily defines constants and structs. These likely correspond to C definitions of system calls and data structures used by the Linux kernel on ARM.

**2. Categorizing the Structures (High-Level Functionality):**

Now, go through the structs and try to group them based on their purpose. Even without knowing every detail, some are quite suggestive:

* **Time-related:** `Timespec`, `Timeval`, `Timex`, `Tms`, `Utimbuf`. Clearly related to time and timestamps.
* **Resource Usage:** `Rusage`. Likely holds information about a process's resource consumption.
* **File System:** `Stat_t`, `Dirent`, `Flock_t`, `Statfs_t`. These deal with file metadata, directory entries, file locking, and file system statistics.
* **Networking:** `RawSockaddrNFCLLCP`, `RawSockaddr`, `RawSockaddrAny`, `Iovec`, `Msghdr`, `Cmsghdr`, `ifreq`. These are clearly related to networking, especially low-level socket structures. The `NFCLLCP` hints at Near-Field Communication.
* **Process Information:** `PtraceRegs`, `Sysinfo_t`, `Taskstats`. Information about processes, their registers (for debugging), system-wide info, and detailed task statistics.
* **Synchronization/Signals:** `FdSet`, `Sigset_t`, `Siginfo`. Structures for managing file descriptors, signal sets, and signal information.
* **Terminal I/O:** `Termios`. This is a classic structure for terminal settings.
* **Device/Block I/O:** `HDGeometry`, `BlkpgPartition`, `LoopInfo`. Information related to hard drives, block device partitioning, and loop devices.
* **Cryptography:** Structures starting with `CryptoUserAlg`, `CryptoStat...`, `CryptoReport...`. These are about cryptographic algorithms, statistics, and reports.
* **Inter-Process Communication (IPC):** `SysvIpcPerm`, `SysvShmDesc`. Relates to System V IPC mechanisms like shared memory.
* **Other:**  `EpollEvent`, `TpacketHdr`, `RTCPLLInfo`, `cpuMask`, `SockaddrStorage`, `TIPCSubscr`, `TIPCSIOCLNReq`, `TIPCSIOCNodeIDReq`, `PPSKInfo`. These are more specialized and require more specific knowledge to understand fully.

**3. Connecting to Go Functionality (Inference):**

Knowing the `unix` package deals with system calls, try to connect the structures to common Go functions:

* **Time:** The `Timespec` and `Timeval` structs are used by functions like `syscall.Nanosleep`, `syscall.Select`, and functions in the `time` package when interacting with the OS.
* **File System:** `Stat_t` is used by `os.Stat`. `Dirent` is used when reading directories (though not directly exposed in the higher-level `os` package, it's used internally). `Flock_t` relates to file locking (`syscall.Flock`).
* **Networking:** The `RawSockaddr...`, `Iovec`, `Msghdr` structs are used with the `syscall` package for low-level socket operations like `syscall.Socket`, `syscall.Bind`, `syscall.Recvmsg`, `syscall.Sendmsg`.
* **Process Information:** `Rusage` is returned by `syscall.Getrusage`.
* **Signals:** `Sigset_t` is used with functions like `syscall.Sigprocmask`.
* **Terminal I/O:** `Termios` is used by the `golang.org/x/term` package to interact with terminal settings.

**4. Code Examples (Illustrative):**

Based on the connections above, construct simple Go examples that use these structures. Focus on the most common and understandable cases first (like `os.Stat` and time). Don't get bogged down trying to demonstrate every single struct.

**5. Command-Line Arguments and Error Handling (Looking at the Generation Command):**

The command `cgo -godefs -objdir=/tmp/arm/cgo -- -Wall -Werror -static -I/tmp/arm/include linux/types.go` is key.

* **`cgo -godefs`**: This tells us it's using `cgo` to generate Go definitions from C.
* **`-objdir=/tmp/arm/cgo`**: Specifies the output directory for intermediate object files.
* **`--`**: Separates `cgo` options from the options passed to the C compiler.
* **`-Wall -Werror -static`**: Standard C compiler flags for warnings and static linking.
* **`-I/tmp/arm/include`**:  Crucially, this specifies the include directory where the C header file (`linux/types.h` - inferred from `linux/types.go`) is located. This is the *input* to the generation process.
* **`linux/types.go`**: This is the *input file* for `cgo`, seemingly a Go file that likely contains `import "C"` and potentially some directives for `cgo`. It's not the *output* file being analyzed.

From this, we can infer that the *process* of generating this code involves telling `cgo` where to find the necessary C header files. Users might err by not setting up the correct include paths.

**6. Potential Pitfalls (User Errors):**

Think about how someone might misuse these low-level structures:

* **Incorrect Sizeof Calculations:** The constants `SizeofPtr`, `SizeofLong`, etc., are important. Manually calculating sizes could lead to errors.
* **Endianness Issues (Though less relevant on a single architecture):** While not explicitly shown in this snippet, dealing with binary data from C structures can involve endianness concerns if data is exchanged across different architectures.
* **Pointer Arithmetic:**  Some structures contain pointers (`*byte`). Incorrectly manipulating these pointers is a classic source of bugs in low-level programming.
* **Assumptions about Structure Layout:**  The `//go:build` constraint is vital. These structures are specific to ARM Linux. Using them on other architectures will likely lead to problems due to different layouts and sizes.

**7. Refinement and Organization:**

Finally, organize the findings logically, starting with the main purpose, then diving into specific functionalities, code examples, command-line usage, and potential errors. Use clear and concise language. The "reasoning" aspect involves explicitly stating the connections between the Go code and underlying OS concepts.
这个 Go 语言文件 `ztypes_linux_arm.go` 的主要功能是**定义了一系列用于与 Linux ARM 架构操作系统进行底层交互的数据结构和常量。**  它是由 `cgo` 工具根据 C 头文件自动生成的，目的是为了让 Go 语言程序能够直接访问和操作 Linux 内核中定义的数据结构，从而进行系统调用或其他底层操作。

**更具体的功能分解：**

1. **定义常量：**  文件中定义了一些常量，例如 `SizeofPtr` 和 `SizeofLong`，这些常量表示指针和 `long` 类型在 ARM Linux 上的大小（字节数）。这些常量在进行内存布局和数据转换时非常重要。

2. **定义结构体 (Structs):**  该文件定义了大量的结构体，这些结构体直接映射了 Linux 内核中定义的 C 结构体。这些结构体用于表示各种系统级别的信息，例如：
    * **时间相关的结构体:** `Timespec`, `Timeval`, `Timex` (用于高精度时间操作)
    * **进程资源使用情况:** `Rusage` (包含 CPU 时间、内存使用等信息)
    * **文件系统相关的结构体:** `Stat_t` (文件状态信息), `Dirent` (目录项), `Flock_t` (文件锁), `Statfs_t` (文件系统统计信息)
    * **网络相关的结构体:** `RawSockaddrNFCLLCP`, `RawSockaddr`, `RawSockaddrAny`, `Iovec`, `Msghdr`, `Cmsghdr`, `ifreq` (用于底层网络编程)
    * **进程和线程相关的结构体:** `Tms` (进程时间信息), `Taskstats` (详细的任务统计信息), `PtraceRegs` (用于调试的寄存器信息)
    * **信号处理相关的结构体:** `Sigset_t`, `Siginfo`
    * **终端 I/O 相关的结构体:** `Termios` (终端设置)
    * **其他系统相关的结构体:**  例如 `Sysinfo_t` (系统信息), `Ustat_t` (文件系统使用情况), `EpollEvent` (epoll 事件),  `LoopInfo` (loop 设备信息), `Crypto*` (加密相关结构体), `SysvIpcPerm`, `SysvShmDesc` (System V IPC 相关结构体) 等。

3. **定义类型别名:**  `_C_long` 和 `Time_t` 是 C 语言中常见的类型，这里定义了它们的 Go 语言类型别名，以保持与 C 语言的兼容性。

**推断的 Go 语言功能实现及代码示例：**

这个文件本身不是一个可以直接运行的 Go 程序，而是作为 `syscall` 或 `golang.org/x/sys/unix` 包的一部分，为访问底层系统调用提供类型定义。  它支持了 Go 语言进行各种与操作系统交互的功能。

**示例 1: 获取文件状态 (使用 `Stat_t`)**

假设我们想获取一个文件的状态信息，比如大小、修改时间等。  在 Go 中，我们会使用 `os.Stat` 函数，而 `os.Stat` 底层会调用 `syscall.Stat`，后者就需要用到 `Stat_t` 结构体。

```go
package main

import (
	"fmt"
	"os"
	"syscall"
)

func main() {
	fileInfo, err := os.Stat("my_file.txt")
	if err != nil {
		fmt.Println("Error:", err)
		return
	}

	statT := fileInfo.Sys().(*syscall.Stat_t)

	fmt.Println("File Size:", statT.Size)
	fmt.Println("Last Access Time:", statT.Atim)
	fmt.Println("Last Modify Time:", statT.Mtim)
	fmt.Println("Inode:", statT.Ino)
}
```

**假设输入:**  一个名为 `my_file.txt` 的文件存在于当前目录下。

**可能的输出:**

```
File Size: 12345
Last Access Time: {1678886400 123456789}
Last Modify Time: {1678886400 987654321}
Inode: 9876543210
```

在这个例子中，`os.Stat` 返回的 `FileInfo` 接口的 `Sys()` 方法会返回一个平台相关的底层数据结构，在 Linux ARM 上，它会返回一个指向 `syscall.Stat_t` 结构体的指针。  我们可以通过类型断言将其转换为 `*syscall.Stat_t` 并访问其成员。

**示例 2: 使用 `Timespec` 进行高精度睡眠 (虽然 `time.Sleep` 更常用)**

虽然 Go 的 `time.Sleep` 函数在内部处理了时间，但如果你想直接使用系统调用进行更底层的操作，可能会用到 `Timespec`。

```go
package main

import (
	"fmt"
	"syscall"
	"time"
)

func main() {
	ts := syscall.Timespec{Sec: 1, Nsec: 500000000} // 1.5 秒
	fmt.Println("Sleeping...")
	_, err := syscall.Nanosleep(&ts, nil)
	if err != nil {
		fmt.Println("Nanosleep error:", err)
	}
	fmt.Println("Wake up!")
}
```

**假设输入:** 无。

**可能的输出:**

```
Sleeping...
Wake up!
```

这个例子展示了如何创建一个 `syscall.Timespec` 结构体来指定睡眠时间，并使用 `syscall.Nanosleep` 系统调用进行睡眠。

**命令行参数的具体处理：**

这个文件本身不处理命令行参数。 命令行参数的处理通常发生在 `main` 函数中，或者由使用了这些数据结构的函数来处理。 例如，如果一个程序使用 `getopt` 系统调用（虽然 Go 标准库通常提供更高级的 `flag` 包），那么可能涉及到解析命令行参数并将其存储到与这里定义的某些结构体相关的变量中。

**使用者易犯错的点：**

1. **平台依赖性:**  最容易犯的错误是假设这些结构体在所有操作系统和架构上都相同。  这个文件明确标记了 `//go:build arm && linux`，意味着这些定义只适用于 Linux ARM 架构。  在其他平台上使用这些结构体可能会导致内存布局错误和程序崩溃。

2. **直接操作底层结构体:** 虽然可以直接访问和修改这些结构体的字段，但这通常是不推荐的，因为它绕过了 Go 语言提供的更安全和高级的抽象。  例如，直接操作 `Stat_t` 的字段而不是使用 `os.Stat` 返回的 `FileInfo` 接口，可能会使代码更难维护和理解。

3. **大小和对齐问题:**  在进行与 C 代码的互操作时，结构体的大小和内存对齐非常重要。  手动创建或修改这些结构体时，必须确保其内存布局与 Linux 内核的期望一致。  `cgo` 工具在生成这些定义时已经处理了这些问题，但如果用户尝试手动修改或创建类似的结构体，就需要特别注意。

4. **理解底层语义:**  这些结构体中的字段通常对应于操作系统内核的特定概念。  不理解这些概念的含义可能会导致错误的使用。 例如，不了解 `Stat_t` 中 `Mode` 字段的位掩码含义，就无法正确判断文件类型或权限。

**易犯错的例子:**

```go
package main

import (
	"fmt"
	"syscall"
)

func main() {
	// 错误地假设 Stat_t 在所有平台上都一样
	var stat syscall.Stat_t // 假设在其他平台也能用

	// ... 一些操作 stat ...

	fmt.Println(stat.Size) // 在非 Linux ARM 平台上，这可能访问了错误的内存
}
```

在这个例子中，如果这段代码在非 Linux ARM 平台上运行，由于 `syscall.Stat_t` 的定义可能不同，访问 `stat.Size` 可能会读取到错误的内存地址，导致不可预测的结果甚至程序崩溃。

总而言之，`ztypes_linux_arm.go` 是 Go 语言与 Linux ARM 架构进行底层交互的基石，它定义了各种必要的类型和常量，使得 Go 程序能够进行系统调用和访问内核数据。 使用者需要理解其平台依赖性，并尽可能使用 Go 语言提供的更高级抽象来操作这些底层结构，以避免潜在的错误。

Prompt: 
```
这是路径为go/src/cmd/vendor/golang.org/x/sys/unix/ztypes_linux_arm.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，

"""
// cgo -godefs -objdir=/tmp/arm/cgo -- -Wall -Werror -static -I/tmp/arm/include linux/types.go | go run mkpost.go
// Code generated by the command above; see README.md. DO NOT EDIT.

//go:build arm && linux

package unix

const (
	SizeofPtr  = 0x4
	SizeofLong = 0x4
)

type (
	_C_long int32
)

type Timespec struct {
	Sec  int32
	Nsec int32
}

type Timeval struct {
	Sec  int32
	Usec int32
}

type Timex struct {
	Modes     uint32
	Offset    int32
	Freq      int32
	Maxerror  int32
	Esterror  int32
	Status    int32
	Constant  int32
	Precision int32
	Tolerance int32
	Time      Timeval
	Tick      int32
	Ppsfreq   int32
	Jitter    int32
	Shift     int32
	Stabil    int32
	Jitcnt    int32
	Calcnt    int32
	Errcnt    int32
	Stbcnt    int32
	Tai       int32
	_         [44]byte
}

type Time_t int32

type Tms struct {
	Utime  int32
	Stime  int32
	Cutime int32
	Cstime int32
}

type Utimbuf struct {
	Actime  int32
	Modtime int32
}

type Rusage struct {
	Utime    Timeval
	Stime    Timeval
	Maxrss   int32
	Ixrss    int32
	Idrss    int32
	Isrss    int32
	Minflt   int32
	Majflt   int32
	Nswap    int32
	Inblock  int32
	Oublock  int32
	Msgsnd   int32
	Msgrcv   int32
	Nsignals int32
	Nvcsw    int32
	Nivcsw   int32
}

type Stat_t struct {
	Dev     uint64
	_       uint16
	_       uint32
	Mode    uint32
	Nlink   uint32
	Uid     uint32
	Gid     uint32
	Rdev    uint64
	_       uint16
	_       [4]byte
	Size    int64
	Blksize int32
	_       [4]byte
	Blocks  int64
	Atim    Timespec
	Mtim    Timespec
	Ctim    Timespec
	Ino     uint64
}

type Dirent struct {
	Ino    uint64
	Off    int64
	Reclen uint16
	Type   uint8
	Name   [256]uint8
	_      [5]byte
}

type Flock_t struct {
	Type   int16
	Whence int16
	_      [4]byte
	Start  int64
	Len    int64
	Pid    int32
	_      [4]byte
}

type DmNameList struct {
	Dev  uint64
	Next uint32
	Name [0]byte
	_    [4]byte
}

const (
	FADV_DONTNEED = 0x4
	FADV_NOREUSE  = 0x5
)

type RawSockaddrNFCLLCP struct {
	Sa_family        uint16
	Dev_idx          uint32
	Target_idx       uint32
	Nfc_protocol     uint32
	Dsap             uint8
	Ssap             uint8
	Service_name     [63]uint8
	Service_name_len uint32
}

type RawSockaddr struct {
	Family uint16
	Data   [14]uint8
}

type RawSockaddrAny struct {
	Addr RawSockaddr
	Pad  [96]uint8
}

type Iovec struct {
	Base *byte
	Len  uint32
}

type Msghdr struct {
	Name       *byte
	Namelen    uint32
	Iov        *Iovec
	Iovlen     uint32
	Control    *byte
	Controllen uint32
	Flags      int32
}

type Cmsghdr struct {
	Len   uint32
	Level int32
	Type  int32
}

type ifreq struct {
	Ifrn [16]byte
	Ifru [16]byte
}

const (
	SizeofSockaddrNFCLLCP = 0x58
	SizeofIovec           = 0x8
	SizeofMsghdr          = 0x1c
	SizeofCmsghdr         = 0xc
)

const (
	SizeofSockFprog = 0x8
)

type PtraceRegs struct {
	Uregs [18]uint32
}

type FdSet struct {
	Bits [32]int32
}

type Sysinfo_t struct {
	Uptime    int32
	Loads     [3]uint32
	Totalram  uint32
	Freeram   uint32
	Sharedram uint32
	Bufferram uint32
	Totalswap uint32
	Freeswap  uint32
	Procs     uint16
	Pad       uint16
	Totalhigh uint32
	Freehigh  uint32
	Unit      uint32
	_         [8]uint8
}

type Ustat_t struct {
	Tfree  int32
	Tinode uint32
	Fname  [6]uint8
	Fpack  [6]uint8
}

type EpollEvent struct {
	Events uint32
	PadFd  int32
	Fd     int32
	Pad    int32
}

const (
	OPEN_TREE_CLOEXEC = 0x80000
)

const (
	POLLRDHUP = 0x2000
)

type Sigset_t struct {
	Val [32]uint32
}

const _C__NSIG = 0x41

const (
	SIG_BLOCK   = 0x0
	SIG_UNBLOCK = 0x1
	SIG_SETMASK = 0x2
)

type Siginfo struct {
	Signo int32
	Errno int32
	Code  int32
	_     [116]byte
}

type Termios struct {
	Iflag  uint32
	Oflag  uint32
	Cflag  uint32
	Lflag  uint32
	Line   uint8
	Cc     [19]uint8
	Ispeed uint32
	Ospeed uint32
}

type Taskstats struct {
	Version                   uint16
	Ac_exitcode               uint32
	Ac_flag                   uint8
	Ac_nice                   uint8
	_                         [4]byte
	Cpu_count                 uint64
	Cpu_delay_total           uint64
	Blkio_count               uint64
	Blkio_delay_total         uint64
	Swapin_count              uint64
	Swapin_delay_total        uint64
	Cpu_run_real_total        uint64
	Cpu_run_virtual_total     uint64
	Ac_comm                   [32]uint8
	Ac_sched                  uint8
	Ac_pad                    [3]uint8
	_                         [4]byte
	Ac_uid                    uint32
	Ac_gid                    uint32
	Ac_pid                    uint32
	Ac_ppid                   uint32
	Ac_btime                  uint32
	_                         [4]byte
	Ac_etime                  uint64
	Ac_utime                  uint64
	Ac_stime                  uint64
	Ac_minflt                 uint64
	Ac_majflt                 uint64
	Coremem                   uint64
	Virtmem                   uint64
	Hiwater_rss               uint64
	Hiwater_vm                uint64
	Read_char                 uint64
	Write_char                uint64
	Read_syscalls             uint64
	Write_syscalls            uint64
	Read_bytes                uint64
	Write_bytes               uint64
	Cancelled_write_bytes     uint64
	Nvcsw                     uint64
	Nivcsw                    uint64
	Ac_utimescaled            uint64
	Ac_stimescaled            uint64
	Cpu_scaled_run_real_total uint64
	Freepages_count           uint64
	Freepages_delay_total     uint64
	Thrashing_count           uint64
	Thrashing_delay_total     uint64
	Ac_btime64                uint64
	Compact_count             uint64
	Compact_delay_total       uint64
	Ac_tgid                   uint32
	_                         [4]byte
	Ac_tgetime                uint64
	Ac_exe_dev                uint64
	Ac_exe_inode              uint64
	Wpcopy_count              uint64
	Wpcopy_delay_total        uint64
	Irq_count                 uint64
	Irq_delay_total           uint64
}

type cpuMask uint32

const (
	_NCPUBITS = 0x20
)

const (
	CBitFieldMaskBit0  = 0x1
	CBitFieldMaskBit1  = 0x2
	CBitFieldMaskBit2  = 0x4
	CBitFieldMaskBit3  = 0x8
	CBitFieldMaskBit4  = 0x10
	CBitFieldMaskBit5  = 0x20
	CBitFieldMaskBit6  = 0x40
	CBitFieldMaskBit7  = 0x80
	CBitFieldMaskBit8  = 0x100
	CBitFieldMaskBit9  = 0x200
	CBitFieldMaskBit10 = 0x400
	CBitFieldMaskBit11 = 0x800
	CBitFieldMaskBit12 = 0x1000
	CBitFieldMaskBit13 = 0x2000
	CBitFieldMaskBit14 = 0x4000
	CBitFieldMaskBit15 = 0x8000
	CBitFieldMaskBit16 = 0x10000
	CBitFieldMaskBit17 = 0x20000
	CBitFieldMaskBit18 = 0x40000
	CBitFieldMaskBit19 = 0x80000
	CBitFieldMaskBit20 = 0x100000
	CBitFieldMaskBit21 = 0x200000
	CBitFieldMaskBit22 = 0x400000
	CBitFieldMaskBit23 = 0x800000
	CBitFieldMaskBit24 = 0x1000000
	CBitFieldMaskBit25 = 0x2000000
	CBitFieldMaskBit26 = 0x4000000
	CBitFieldMaskBit27 = 0x8000000
	CBitFieldMaskBit28 = 0x10000000
	CBitFieldMaskBit29 = 0x20000000
	CBitFieldMaskBit30 = 0x40000000
	CBitFieldMaskBit31 = 0x80000000
	CBitFieldMaskBit32 = 0x100000000
	CBitFieldMaskBit33 = 0x200000000
	CBitFieldMaskBit34 = 0x400000000
	CBitFieldMaskBit35 = 0x800000000
	CBitFieldMaskBit36 = 0x1000000000
	CBitFieldMaskBit37 = 0x2000000000
	CBitFieldMaskBit38 = 0x4000000000
	CBitFieldMaskBit39 = 0x8000000000
	CBitFieldMaskBit40 = 0x10000000000
	CBitFieldMaskBit41 = 0x20000000000
	CBitFieldMaskBit42 = 0x40000000000
	CBitFieldMaskBit43 = 0x80000000000
	CBitFieldMaskBit44 = 0x100000000000
	CBitFieldMaskBit45 = 0x200000000000
	CBitFieldMaskBit46 = 0x400000000000
	CBitFieldMaskBit47 = 0x800000000000
	CBitFieldMaskBit48 = 0x1000000000000
	CBitFieldMaskBit49 = 0x2000000000000
	CBitFieldMaskBit50 = 0x4000000000000
	CBitFieldMaskBit51 = 0x8000000000000
	CBitFieldMaskBit52 = 0x10000000000000
	CBitFieldMaskBit53 = 0x20000000000000
	CBitFieldMaskBit54 = 0x40000000000000
	CBitFieldMaskBit55 = 0x80000000000000
	CBitFieldMaskBit56 = 0x100000000000000
	CBitFieldMaskBit57 = 0x200000000000000
	CBitFieldMaskBit58 = 0x400000000000000
	CBitFieldMaskBit59 = 0x800000000000000
	CBitFieldMaskBit60 = 0x1000000000000000
	CBitFieldMaskBit61 = 0x2000000000000000
	CBitFieldMaskBit62 = 0x4000000000000000
	CBitFieldMaskBit63 = 0x8000000000000000
)

type SockaddrStorage struct {
	Family uint16
	Data   [122]byte
	_      uint32
}

type HDGeometry struct {
	Heads     uint8
	Sectors   uint8
	Cylinders uint16
	Start     uint32
}

type Statfs_t struct {
	Type    int32
	Bsize   int32
	Blocks  uint64
	Bfree   uint64
	Bavail  uint64
	Files   uint64
	Ffree   uint64
	Fsid    Fsid
	Namelen int32
	Frsize  int32
	Flags   int32
	Spare   [4]int32
	_       [4]byte
}

type TpacketHdr struct {
	Status  uint32
	Len     uint32
	Snaplen uint32
	Mac     uint16
	Net     uint16
	Sec     uint32
	Usec    uint32
}

const (
	SizeofTpacketHdr = 0x18
)

type RTCPLLInfo struct {
	Ctrl    int32
	Value   int32
	Max     int32
	Min     int32
	Posmult int32
	Negmult int32
	Clock   int32
}

type BlkpgPartition struct {
	Start   int64
	Length  int64
	Pno     int32
	Devname [64]uint8
	Volname [64]uint8
	_       [4]byte
}

const (
	BLKPG = 0x1269
)

type CryptoUserAlg struct {
	Name        [64]uint8
	Driver_name [64]uint8
	Module_name [64]uint8
	Type        uint32
	Mask        uint32
	Refcnt      uint32
	Flags       uint32
}

type CryptoStatAEAD struct {
	Type         [64]uint8
	Encrypt_cnt  uint64
	Encrypt_tlen uint64
	Decrypt_cnt  uint64
	Decrypt_tlen uint64
	Err_cnt      uint64
}

type CryptoStatAKCipher struct {
	Type         [64]uint8
	Encrypt_cnt  uint64
	Encrypt_tlen uint64
	Decrypt_cnt  uint64
	Decrypt_tlen uint64
	Verify_cnt   uint64
	Sign_cnt     uint64
	Err_cnt      uint64
}

type CryptoStatCipher struct {
	Type         [64]uint8
	Encrypt_cnt  uint64
	Encrypt_tlen uint64
	Decrypt_cnt  uint64
	Decrypt_tlen uint64
	Err_cnt      uint64
}

type CryptoStatCompress struct {
	Type            [64]uint8
	Compress_cnt    uint64
	Compress_tlen   uint64
	Decompress_cnt  uint64
	Decompress_tlen uint64
	Err_cnt         uint64
}

type CryptoStatHash struct {
	Type      [64]uint8
	Hash_cnt  uint64
	Hash_tlen uint64
	Err_cnt   uint64
}

type CryptoStatKPP struct {
	Type                      [64]uint8
	Setsecret_cnt             uint64
	Generate_public_key_cnt   uint64
	Compute_shared_secret_cnt uint64
	Err_cnt                   uint64
}

type CryptoStatRNG struct {
	Type          [64]uint8
	Generate_cnt  uint64
	Generate_tlen uint64
	Seed_cnt      uint64
	Err_cnt       uint64
}

type CryptoStatLarval struct {
	Type [64]uint8
}

type CryptoReportLarval struct {
	Type [64]uint8
}

type CryptoReportHash struct {
	Type       [64]uint8
	Blocksize  uint32
	Digestsize uint32
}

type CryptoReportCipher struct {
	Type        [64]uint8
	Blocksize   uint32
	Min_keysize uint32
	Max_keysize uint32
}

type CryptoReportBlkCipher struct {
	Type        [64]uint8
	Geniv       [64]uint8
	Blocksize   uint32
	Min_keysize uint32
	Max_keysize uint32
	Ivsize      uint32
}

type CryptoReportAEAD struct {
	Type        [64]uint8
	Geniv       [64]uint8
	Blocksize   uint32
	Maxauthsize uint32
	Ivsize      uint32
}

type CryptoReportComp struct {
	Type [64]uint8
}

type CryptoReportRNG struct {
	Type     [64]uint8
	Seedsize uint32
}

type CryptoReportAKCipher struct {
	Type [64]uint8
}

type CryptoReportKPP struct {
	Type [64]uint8
}

type CryptoReportAcomp struct {
	Type [64]uint8
}

type LoopInfo struct {
	Number           int32
	Device           uint16
	Inode            uint32
	Rdevice          uint16
	Offset           int32
	Encrypt_type     int32
	Encrypt_key_size int32
	Flags            int32
	Name             [64]uint8
	Encrypt_key      [32]uint8
	Init             [2]uint32
	Reserved         [4]uint8
}

type TIPCSubscr struct {
	Seq     TIPCServiceRange
	Timeout uint32
	Filter  uint32
	Handle  [8]uint8
}

type TIPCSIOCLNReq struct {
	Peer     uint32
	Id       uint32
	Linkname [68]uint8
}

type TIPCSIOCNodeIDReq struct {
	Peer uint32
	Id   [16]uint8
}

type PPSKInfo struct {
	Assert_sequence uint32
	Clear_sequence  uint32
	Assert_tu       PPSKTime
	Clear_tu        PPSKTime
	Current_mode    int32
	_               [4]byte
}

const (
	PPS_GETPARAMS = 0x800470a1
	PPS_SETPARAMS = 0x400470a2
	PPS_GETCAP    = 0x800470a3
	PPS_FETCH     = 0xc00470a4
)

const (
	PIDFD_NONBLOCK = 0x800
)

type SysvIpcPerm struct {
	Key  int32
	Uid  uint32
	Gid  uint32
	Cuid uint32
	Cgid uint32
	Mode uint16
	_    [2]uint8
	Seq  uint16
	_    uint16
	_    uint32
	_    uint32
}
type SysvShmDesc struct {
	Perm       SysvIpcPerm
	Segsz      uint32
	Atime      uint32
	Atime_high uint32
	Dtime      uint32
	Dtime_high uint32
	Ctime      uint32
	Ctime_high uint32
	Cpid       int32
	Lpid       int32
	Nattch     uint32
	_          uint32
	_          uint32
}

"""



```
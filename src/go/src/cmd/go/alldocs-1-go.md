Response: My thinking process to answer the request about `alldocs-1.go` goes like this:

1. **Understand the Core Request:** The user wants to know the functionality of the Go code snippet provided, which is a part of `go/src/cmd/go/alldocs-1.go`. The request emphasizes identifying the Go language feature it implements, providing Go code examples, detailing command-line argument handling, pointing out common user errors (if any), and summarizing its overall function. Crucially, it's explicitly stated this is "part 1 of 3."

2. **Initial Scan and Key Observations:**  I quickly scan the content. Several things immediately jump out:
    * **Copyright and "DO NOT EDIT":** The initial comments clearly indicate this file is auto-generated by `mkalldocs.sh`. This is a huge clue. It suggests the file itself doesn't contain core *implementation* logic but rather *documentation*.
    * **"Go is a tool for managing Go source code":** This line states the purpose of the `go` command itself.
    * **A Long List of Commands and Help Topics:** The bulk of the content is a structured listing of `go` subcommands (like `build`, `run`, `test`) and additional help topics (like `modules`, `gopath`). Each command and topic has a brief description and a "Usage:" section showing how to use it from the command line.

3. **Formulate the Central Hypothesis:** Given the "DO NOT EDIT" and the comprehensive listing of `go` commands and their usage, my primary hypothesis is that this file contains the *help text* for the `go` command-line tool. It's the documentation displayed when you run `go help` or `go help <command>`.

4. **Connect to Go Functionality:**  How does this relate to a specific Go language feature?  It's not implementing a language feature in the traditional sense (like slices or goroutines). Instead, it's documenting the *tooling* around the language. The `go` command is a fundamental part of the Go development experience.

5. **Provide a Go Code Example (Illustrative, Not Directly Related to This File):** Since the file documents command-line usage, a direct code example *within* this file isn't really applicable. However, to illustrate *how* someone might use the documented features, I'll provide an example of using a `go` subcommand. This demonstrates the *purpose* of the documentation. A simple `go build` example makes sense.

6. **Detail Command-Line Argument Handling:** This is directly addressed by the "Usage:" sections within the documentation. I need to pick a few examples (like `go build`) and highlight the flags and arguments it accepts. I should also explain how the documentation itself provides this information.

7. **Identify Common User Errors:**  Looking at the descriptions, I can infer common mistakes. For `go build`, forgetting `-o` when wanting a specific output name is a good example. For `go get`, not understanding version specifiers (`@latest`, `@v1.2.3`) is another.

8. **Summarize the Function:**  The core function is to provide comprehensive help documentation for the `go` command-line tool. This is critical for users to understand how to interact with the Go tooling.

9. **Address the "Part 1 of 3" Aspect:**  This is important. I need to explicitly state that this file is just the first part of the documentation and that other parts likely contain the documentation for the remaining commands and topics. This manages expectations and answers the specific constraint of the prompt.

10. **Refine and Structure the Answer:** I organize my findings into logical sections: Core Function, Implemented Go Language Feature (clarifying it's about the tooling), Go Code Example, Command-Line Argument Handling, Common User Errors, and Summary. I use clear and concise language, referencing the provided text where appropriate. I make sure to highlight the auto-generated nature of the file.

By following this process, I can accurately analyze the provided code snippet, address all aspects of the user's request, and provide a comprehensive and helpful answer. The key insight is recognizing that this file is *documentation* and not direct implementation code.

根据您提供的Go语言代码片段（路径为 `go/src/cmd/go/alldocs-1.go` 的一部分），我们可以归纳出以下功能：

**核心功能：提供 Go 语言命令行工具 `go` 的帮助文档。**

这个文件是 `go` 命令行工具的帮助文档的第一部分。它包含了 `go` 命令的基本用法、各个子命令的详细说明、以及一些相关主题的解释。  由于文件头部的注释说明 `// Code generated by mkalldocs.sh; DO NOT EDIT.`, 可以判断这个文件是由脚本自动生成的，其内容来源于其他地方的文档。

**更具体的功能点：**

1. **列出 `go` 命令的可用子命令:**  如 `bug`, `build`, `clean`, `doc` 等。
2. **解释每个子命令的用途和功能:**  例如，`build` 用于编译包和依赖，`clean` 用于移除对象文件和缓存文件。
3. **详细描述每个子命令的使用方法 (Usage):**  包括所需的参数、可选的 flag 等。
4. **解释 `go` 工具涉及的一些重要概念和主题:**  例如，构建约束 (buildconstraint)、构建模式 (buildmode)、模块 (modules)、GOPATH 等。
5. **对于每个子命令，详细说明其命令行参数 (flags) 的作用和用法:**  例如，`go build` 的 `-o`, `-i`, `-a`, `-n` 等 flag。

**它是什么Go语言功能的实现？**

严格来说，这个文件本身并不是某个 Go 语言功能的实现，而是 Go 语言工具链中 `go` 命令的帮助文档。  `go` 命令是 Go 语言的核心工具，它提供了编译、构建、测试、包管理等一系列功能。 这个文件是用来解释 *如何使用* 这些功能的。

**Go 代码举例说明 (并非 `alldocs-1.go` 中的代码，而是展示如何使用它文档中描述的 `go` 命令):**

假设我们要使用 `go build` 命令来编译一个名为 `main.go` 的文件。

```go
// main.go
package main

import "fmt"

func main() {
	fmt.Println("Hello, Go!")
}
```

**假设输入 (命令行):**

```bash
go build main.go
```

**预期输出 (在当前目录下生成一个可执行文件 `main` 或 `main.exe`):**

```
# (没有输出，成功编译)
```

**命令行参数的具体处理 (以 `go build` 为例):**

`go build` 命令可以接受多种命令行参数，根据文档中的描述：

* **`[-o output]`**:  指定输出文件的名称。如果 `output` 是一个已存在的目录，则可执行文件会写入该目录。
    * **示例:** `go build -o myapp main.go`  将生成名为 `myapp` 的可执行文件。
* **`[-i]`**: 安装目标包的依赖。
    * **示例:** `go build -i ./mypackage` 将会安装 `mypackage` 的所有依赖。
* **`[build flags]`**:  一系列用于控制构建过程的 flag，如：
    * `-a`: 强制重新构建已是最新的包。
    * `-n`: 打印将要执行的命令，但不实际运行。
    * `-p n`: 设置并行编译的程序数量。
    * `-race`: 启用数据竞争检测。
    * `-v`: 打印正在编译的包的名称。
    * `-tags tag,list`:  指定构建标签。
    * 更多...
* **`[packages]`**:  要编译的包的导入路径或一组 `.go` 文件。
    * **示例:** `go build mypackage` 编译名为 `mypackage` 的包。
    * **示例:** `go build file1.go file2.go` 将 `file1.go` 和 `file2.go` 当作一个包的源文件进行编译。

**使用者易犯错的点 (以 `go build` 为例):**

* **忘记 `-o` 参数导致输出文件名不符合预期:**  例如，编译单个 `main.go` 文件时，默认输出文件名可能只是 `main`，但在某些情况下可能需要指定更明确的名称。
* **不理解构建上下文和构建标签:**  例如，使用了只在特定操作系统或架构下生效的代码，但没有使用 `-tags` 参数来指定构建标签，导致编译失败或行为不一致。
    * **示例:**  一个包含 `// +build linux` 的文件，在 Windows 上直接 `go build` 会被忽略，这可能让用户感到困惑。
* **在编译多个包或非 `main` 包时，期望生成可执行文件:**  `go build` 在这种情况下默认只检查包是否可以构建，不会生成可执行文件。需要使用 `go install` 来安装这些包。
* **混淆包路径和文件路径:**  `go build` 接受包的导入路径，而不是文件系统的路径（除非是编译单个目录下的 `.go` 文件）。

**归纳一下它的功能 (针对第 1 部分):**

`go/src/cmd/go/alldocs-1.go` 的第 1 部分主要负责提供 `go` 命令行工具的基础帮助信息，包括：

* **`go` 命令的基本用法结构。**
* **一部分核心子命令的详细说明，例如 `bug`, `build`, `clean`, `doc` 等。**
* **一部分重要的 Go 工具链概念的解释，例如构建约束。**

由于这是第 1 部分，可以推测后续的 `alldocs-2.go` 和 `alldocs-3.go` 会继续提供剩余的子命令和主题的帮助文档。  整个 `alldocs` 系列文件的最终目的是为 `go help` 命令提供完整的、结构化的信息来源。

Prompt: 
```
这是路径为go/src/cmd/go/alldocs-1.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
这是第1部分，共3部分，请归纳一下它的功能

"""
// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Code generated by mkalldocs.sh; DO NOT EDIT.
// Edit the documentation in other files and rerun mkalldocs.sh to generate this one.

// Go is a tool for managing Go source code.
//
// Usage:
//
// 	go <command> [arguments]
//
// The commands are:
//
// 	bug         start a bug report
// 	build       compile packages and dependencies
// 	clean       remove object files and cached files
// 	doc         show documentation for package or symbol
// 	env         print Go environment information
// 	fix         update packages to use new APIs
// 	fmt         gofmt (reformat) package sources
// 	generate    generate Go files by processing source
// 	get         add dependencies to current module and install them
// 	install     compile and install packages and dependencies
// 	list        list packages or modules
// 	mod         module maintenance
// 	run         compile and run Go program
// 	test        test packages
// 	tool        run specified go tool
// 	version     print Go version
// 	vet         report likely mistakes in packages
//
// Use "go help <command>" for more information about a command.
//
// Additional help topics:
//
// 	buildconstraint build constraints
// 	buildmode       build modes
// 	c               calling between Go and C
// 	cache           build and test caching
// 	environment     environment variables
// 	filetype        file types
// 	go.mod          the go.mod file
// 	gopath          GOPATH environment variable
// 	gopath-get      legacy GOPATH go get
// 	goproxy         module proxy protocol
// 	importpath      import path syntax
// 	modules         modules, module versions, and more
// 	module-get      module-aware go get
// 	module-auth     module authentication using go.sum
// 	module-private  module configuration for non-public modules
// 	packages        package lists and patterns
// 	testflag        testing flags
// 	testfunc        testing functions
//
// Use "go help <topic>" for more information about that topic.
//
//
// Start a bug report
//
// Usage:
//
// 	go bug
//
// Bug opens the default browser and starts a new bug report.
// The report includes useful system information.
//
//
// Compile packages and dependencies
//
// Usage:
//
// 	go build [-o output] [-i] [build flags] [packages]
//
// Build compiles the packages named by the import paths,
// along with their dependencies, but it does not install the results.
//
// If the arguments to build are a list of .go files from a single directory,
// build treats them as a list of source files specifying a single package.
//
// When compiling packages, build ignores files that end in '_test.go'.
//
// When compiling a single main package, build writes
// the resulting executable to an output file named after
// the first source file ('go build ed.go rx.go' writes 'ed' or 'ed.exe')
// or the source code directory ('go build unix/sam' writes 'sam' or 'sam.exe').
// The '.exe' suffix is added when writing a Windows executable.
//
// When compiling multiple packages or a single non-main package,
// build compiles the packages but discards the resulting object,
// serving only as a check that the packages can be built.
//
// The -o flag forces build to write the resulting executable or object
// to the named output file or directory, instead of the default behavior described
// in the last two paragraphs. If the named output is a directory that exists,
// then any resulting executables will be written to that directory.
//
// The -i flag installs the packages that are dependencies of the target.
//
// The build flags are shared by the build, clean, get, install, list, run,
// and test commands:
//
// 	-a
// 		force rebuilding of packages that are already up-to-date.
// 	-n
// 		print the commands but do not run them.
// 	-p n
// 		the number of programs, such as build commands or
// 		test binaries, that can be run in parallel.
// 		The default is the number of CPUs available.
// 	-race
// 		enable data race detection.
// 		Supported only on linux/amd64, freebsd/amd64, darwin/amd64, windows/amd64,
// 		linux/ppc64le and linux/arm64 (only for 48-bit VMA).
// 	-msan
// 		enable interoperation with memory sanitizer.
// 		Supported only on linux/amd64, linux/arm64
// 		and only with Clang/LLVM as the host C compiler.
// 		On linux/arm64, pie build mode will be used.
// 	-v
// 		print the names of packages as they are compiled.
// 	-work
// 		print the name of the temporary work directory and
// 		do not delete it when exiting.
// 	-x
// 		print the commands.
//
// 	-asmflags '[pattern=]arg list'
// 		arguments to pass on each go tool asm invocation.
// 	-buildmode mode
// 		build mode to use. See 'go help buildmode' for more.
// 	-compiler name
// 		name of compiler to use, as in runtime.Compiler (gccgo or gc).
// 	-gccgoflags '[pattern=]arg list'
// 		arguments to pass on each gccgo compiler/linker invocation.
// 	-gcflags '[pattern=]arg list'
// 		arguments to pass on each go tool compile invocation.
// 	-installsuffix suffix
// 		a suffix to use in the name of the package installation directory,
// 		in order to keep output separate from default builds.
// 		If using the -race flag, the install suffix is automatically set to race
// 		or, if set explicitly, has _race appended to it. Likewise for the -msan
// 		flag. Using a -buildmode option that requires non-default compile flags
// 		has a similar effect.
// 	-ldflags '[pattern=]arg list'
// 		arguments to pass on each go tool link invocation.
// 	-linkshared
// 		build code that will be linked against shared libraries previously
// 		created with -buildmode=shared.
// 	-mod mode
// 		module download mode to use: readonly, vendor, or mod.
// 		See 'go help modules' for more.
// 	-modcacherw
// 		leave newly-created directories in the module cache read-write
// 		instead of making them read-only.
// 	-modfile file
// 		in module aware mode, read (and possibly write) an alternate go.mod
// 		file instead of the one in the module root directory. A file named
// 		"go.mod" must still be present in order to determine the module root
// 		directory, but it is not accessed. When -modfile is specified, an
// 		alternate go.sum file is also used: its path is derived from the
// 		-modfile flag by trimming the ".mod" extension and appending ".sum".
// 	-pkgdir dir
// 		install and load all packages from dir instead of the usual locations.
// 		For example, when building with a non-standard configuration,
// 		use -pkgdir to keep generated packages in a separate location.
// 	-tags tag,list
// 		a comma-separated list of build tags to consider satisfied during the
// 		build. For more information about build tags, see the description of
// 		build constraints in the documentation for the go/build package.
// 		(Earlier versions of Go used a space-separated list, and that form
// 		is deprecated but still recognized.)
// 	-trimpath
// 		remove all file system paths from the resulting executable.
// 		Instead of absolute file system paths, the recorded file names
// 		will begin with either "go" (for the standard library),
// 		or a module path@version (when using modules),
// 		or a plain import path (when using GOPATH).
// 	-toolexec 'cmd args'
// 		a program to use to invoke toolchain programs like vet and asm.
// 		For example, instead of running asm, the go command will run
// 		'cmd args /path/to/asm <arguments for asm>'.
//
// The -asmflags, -gccgoflags, -gcflags, and -ldflags flags accept a
// space-separated list of arguments to pass to an underlying tool
// during the build. To embed spaces in an element in the list, surround
// it with either single or double quotes. The argument list may be
// preceded by a package pattern and an equal sign, which restricts
// the use of that argument list to the building of packages matching
// that pattern (see 'go help packages' for a description of package
// patterns). Without a pattern, the argument list applies only to the
// packages named on the command line. The flags may be repeated
// with different patterns in order to specify different arguments for
// different sets of packages. If a package matches patterns given in
// multiple flags, the latest match on the command line wins.
// For example, 'go build -gcflags=-S fmt' prints the disassembly
// only for package fmt, while 'go build -gcflags=all=-S fmt'
// prints the disassembly for fmt and all its dependencies.
//
// For more about specifying packages, see 'go help packages'.
// For more about where packages and binaries are installed,
// run 'go help gopath'.
// For more about calling between Go and C/C++, run 'go help c'.
//
// Note: Build adheres to certain conventions such as those described
// by 'go help gopath'. Not all projects can follow these conventions,
// however. Installations that have their own conventions or that use
// a separate software build system may choose to use lower-level
// invocations such as 'go tool compile' and 'go tool link' to avoid
// some of the overheads and design decisions of the build tool.
//
// See also: go install, go get, go clean.
//
//
// Remove object files and cached files
//
// Usage:
//
// 	go clean [clean flags] [build flags] [packages]
//
// Clean removes object files from package source directories.
// The go command builds most objects in a temporary directory,
// so go clean is mainly concerned with object files left by other
// tools or by manual invocations of go build.
//
// If a package argument is given or the -i or -r flag is set,
// clean removes the following files from each of the
// source directories corresponding to the import paths:
//
// 	_obj/            old object directory, left from Makefiles
// 	_test/           old test directory, left from Makefiles
// 	_testmain.go     old gotest file, left from Makefiles
// 	test.out         old test log, left from Makefiles
// 	build.out        old test log, left from Makefiles
// 	*.[568ao]        object files, left from Makefiles
//
// 	DIR(.exe)        from go build
// 	DIR.test(.exe)   from go test -c
// 	MAINFILE(.exe)   from go build MAINFILE.go
// 	*.so             from SWIG
//
// In the list, DIR represents the final path element of the
// directory, and MAINFILE is the base name of any Go source
// file in the directory that is not included when building
// the package.
//
// The -i flag causes clean to remove the corresponding installed
// archive or binary (what 'go install' would create).
//
// The -n flag causes clean to print the remove commands it would execute,
// but not run them.
//
// The -r flag causes clean to be applied recursively to all the
// dependencies of the packages named by the import paths.
//
// The -x flag causes clean to print remove commands as it executes them.
//
// The -cache flag causes clean to remove the entire go build cache.
//
// The -testcache flag causes clean to expire all test results in the
// go build cache.
//
// The -modcache flag causes clean to remove the entire module
// download cache, including unpacked source code of versioned
// dependencies.
//
// For more about build flags, see 'go help build'.
//
// For more about specifying packages, see 'go help packages'.
//
//
// Show documentation for package or symbol
//
// Usage:
//
// 	go doc [-u] [-c] [package|[package.]symbol[.methodOrField]]
//
// Doc prints the documentation comments associated with the item identified by its
// arguments (a package, const, func, type, var, method, or struct field)
// followed by a one-line summary of each of the first-level items "under"
// that item (package-level declarations for a package, methods for a type,
// etc.).
//
// Doc accepts zero, one, or two arguments.
//
// Given no arguments, that is, when run as
//
// 	go doc
//
// it prints the package documentation for the package in the current directory.
// If the package is a command (package main), the exported symbols of the package
// are elided from the presentation unless the -cmd flag is provided.
//
// When run with one argument, the argument is treated as a Go-syntax-like
// representation of the item to be documented. What the argument selects depends
// on what is installed in GOROOT and GOPATH, as well as the form of the argument,
// which is schematically one of these:
//
// 	go doc <pkg>
// 	go doc <sym>[.<methodOrField>]
// 	go doc [<pkg>.]<sym>[.<methodOrField>]
// 	go doc [<pkg>.][<sym>.]<methodOrField>
//
// The first item in this list matched by the argument is the one whose documentation
// is printed. (See the examples below.) However, if the argument starts with a capital
// letter it is assumed to identify a symbol or method in the current directory.
//
// For packages, the order of scanning is determined lexically in breadth-first order.
// That is, the package presented is the one that matches the search and is nearest
// the root and lexically first at its level of the hierarchy. The GOROOT tree is
// always scanned in its entirety before GOPATH.
//
// If there is no package specified or matched, the package in the current
// directory is selected, so "go doc Foo" shows the documentation for symbol Foo in
// the current package.
//
// The package path must be either a qualified path or a proper suffix of a
// path. The go tool's usual package mechanism does not apply: package path
// elements like . and ... are not implemented by go doc.
//
// When run with two arguments, the first must be a full package path (not just a
// suffix), and the second is a symbol, or symbol with method or struct field.
// This is similar to the syntax accepted by godoc:
//
// 	go doc <pkg> <sym>[.<methodOrField>]
//
// In all forms, when matching symbols, lower-case letters in the argument match
// either case but upper-case letters match exactly. This means that there may be
// multiple matches of a lower-case argument in a package if different symbols have
// different cases. If this occurs, documentation for all matches is printed.
//
// Examples:
// 	go doc
// 		Show documentation for current package.
// 	go doc Foo
// 		Show documentation for Foo in the current package.
// 		(Foo starts with a capital letter so it cannot match
// 		a package path.)
// 	go doc encoding/json
// 		Show documentation for the encoding/json package.
// 	go doc json
// 		Shorthand for encoding/json.
// 	go doc json.Number (or go doc json.number)
// 		Show documentation and method summary for json.Number.
// 	go doc json.Number.Int64 (or go doc json.number.int64)
// 		Show documentation for json.Number's Int64 method.
// 	go doc cmd/doc
// 		Show package docs for the doc command.
// 	go doc -cmd cmd/doc
// 		Show package docs and exported symbols within the doc command.
// 	go doc template.new
// 		Show documentation for html/template's New function.
// 		(html/template is lexically before text/template)
// 	go doc text/template.new # One argument
// 		Show documentation for text/template's New function.
// 	go doc text/template new # Two arguments
// 		Show documentation for text/template's New function.
//
// 	At least in the current tree, these invocations all print the
// 	documentation for json.Decoder's Decode method:
//
// 	go doc json.Decoder.Decode
// 	go doc json.decoder.decode
// 	go doc json.decode
// 	cd go/src/encoding/json; go doc decode
//
// Flags:
// 	-all
// 		Show all the documentation for the package.
// 	-c
// 		Respect case when matching symbols.
// 	-cmd
// 		Treat a command (package main) like a regular package.
// 		Otherwise package main's exported symbols are hidden
// 		when showing the package's top-level documentation.
// 	-short
// 		One-line representation for each symbol.
// 	-src
// 		Show the full source code for the symbol. This will
// 		display the full Go source of its declaration and
// 		definition, such as a function definition (including
// 		the body), type declaration or enclosing const
// 		block. The output may therefore include unexported
// 		details.
// 	-u
// 		Show documentation for unexported as well as exported
// 		symbols, methods, and fields.
//
//
// Print Go environment information
//
// Usage:
//
// 	go env [-json] [-u] [-w] [var ...]
//
// Env prints Go environment information.
//
// By default env prints information as a shell script
// (on Windows, a batch file). If one or more variable
// names is given as arguments, env prints the value of
// each named variable on its own line.
//
// The -json flag prints the environment in JSON format
// instead of as a shell script.
//
// The -u flag requires one or more arguments and unsets
// the default setting for the named environment variables,
// if one has been set with 'go env -w'.
//
// The -w flag requires one or more arguments of the
// form NAME=VALUE and changes the default settings
// of the named environment variables to the given values.
//
// For more about environment variables, see 'go help environment'.
//
//
// Update packages to use new APIs
//
// Usage:
//
// 	go fix [packages]
//
// Fix runs the Go fix command on the packages named by the import paths.
//
// For more about fix, see 'go doc cmd/fix'.
// For more about specifying packages, see 'go help packages'.
//
// To run fix with specific options, run 'go tool fix'.
//
// See also: go fmt, go vet.
//
//
// Gofmt (reformat) package sources
//
// Usage:
//
// 	go fmt [-n] [-x] [packages]
//
// Fmt runs the command 'gofmt -l -w' on the packages named
// by the import paths. It prints the names of the files that are modified.
//
// For more about gofmt, see 'go doc cmd/gofmt'.
// For more about specifying packages, see 'go help packages'.
//
// The -n flag prints commands that would be executed.
// The -x flag prints commands as they are executed.
//
// The -mod flag's value sets which module download mode
// to use: readonly or vendor. See 'go help modules' for more.
//
// To run gofmt with specific options, run gofmt itself.
//
// See also: go fix, go vet.
//
//
// Generate Go files by processing source
//
// Usage:
//
// 	go generate [-run regexp] [-n] [-v] [-x] [build flags] [file.go... | packages]
//
// Generate runs commands described by directives within existing
// files. Those commands can run any process but the intent is to
// create or update Go source files.
//
// Go generate is never run automatically by go build, go get, go test,
// and so on. It must be run explicitly.
//
// Go generate scans the file for directives, which are lines of
// the form,
//
// 	//go:generate command argument...
//
// (note: no leading spaces and no space in "//go") where command
// is the generator to be run, corresponding to an executable file
// that can be run locally. It must either be in the shell path
// (gofmt), a fully qualified path (/usr/you/bin/mytool), or a
// command alias, described below.
//
// To convey to humans and machine tools that code is generated,
// generated source should have a line that matches the following
// regular expression (in Go syntax):
//
// 	^// Code generated .* DO NOT EDIT\.$
//
// The line may appear anywhere in the file, but is typically
// placed near the beginning so it is easy to find.
//
// Note that go generate does not parse the file, so lines that look
// like directives in comments or multiline strings will be treated
// as directives.
//
// The arguments to the directive are space-separated tokens or
// double-quoted strings passed to the generator as individual
// arguments when it is run.
//
// Quoted strings use Go syntax and are evaluated before execution; a
// quoted string appears as a single argument to the generator.
//
// Go generate sets several variables when it runs the generator:
//
// 	$GOARCH
// 		The execution architecture (arm, amd64, etc.)
// 	$GOOS
// 		The execution operating system (linux, windows, etc.)
// 	$GOFILE
// 		The base name of the file.
// 	$GOLINE
// 		The line number of the directive in the source file.
// 	$GOPACKAGE
// 		The name of the package of the file containing the directive.
// 	$DOLLAR
// 		A dollar sign.
//
// Other than variable substitution and quoted-string evaluation, no
// special processing such as "globbing" is performed on the command
// line.
//
// As a last step before running the command, any invocations of any
// environment variables with alphanumeric names, such as $GOFILE or
// $HOME, are expanded throughout the command line. The syntax for
// variable expansion is $NAME on all operating systems. Due to the
// order of evaluation, variables are expanded even inside quoted
// strings. If the variable NAME is not set, $NAME expands to the
// empty string.
//
// A directive of the form,
//
// 	//go:generate -command xxx args...
//
// specifies, for the remainder of this source file only, that the
// string xxx represents the command identified by the arguments. This
// can be used to create aliases or to handle multiword generators.
// For example,
//
// 	//go:generate -command foo go tool foo
//
// specifies that the command "foo" represents the generator
// "go tool foo".
//
// Generate processes packages in the order given on the command line,
// one at a time. If the command line lists .go files from a single directory,
// they are treated as a single package. Within a package, generate processes the
// source files in a package in file name order, one at a time. Within
// a source file, generate runs generators in the order they appear
// in the file, one at a time. The go generate tool also sets the build
// tag "generate" so that files may be examined by go generate but ignored
// during build.
//
// For packages with invalid code, generate processes only source files with a
// valid package clause.
//
// If any generator returns an error exit status, "go generate" skips
// all further processing for that package.
//
// The generator is run in the package's source directory.
//
// Go generate accepts one specific flag:
//
// 	-run=""
// 		if non-empty, specifies a regular expression to select
// 		directives whose full original source text (excluding
// 		any trailing spaces and final newline) matches the
// 		expression.
//
// It also accepts the standard build flags including -v, -n, and -x.
// The -v flag prints the names of packages and files as they are
// processed.
// The -n flag prints commands that would be executed.
// The -x flag prints commands as they are executed.
//
// For more about build flags, see 'go help build'.
//
// For more about specifying packages, see 'go help packages'.
//
//
// Add dependencies to current module and install them
//
// Usage:
//
// 	go get [-d] [-t] [-u] [-v] [-insecure] [build flags] [packages]
//
// Get resolves and adds dependencies to the current development module
// and then builds and installs them.
//
// The first step is to resolve which dependencies to add.
//
// For each named package or package pattern, get must decide which version of
// the corresponding module to use. By default, get looks up the latest tagged
// release version, such as v0.4.5 or v1.2.3. If there are no tagged release
// versions, get looks up the latest tagged pre-release version, such as
// v0.0.1-pre1. If there are no tagged versions at all, get looks up the latest
// known commit. If the module is not already required at a later version
// (for example, a pre-release newer than the latest release), get will use
// the version it looked up. Otherwise, get will use the currently
// required version.
//
// This default version selection can be overridden by adding an @version
// suffix to the package argument, as in 'go get golang.org/x/text@v0.3.0'.
// The version may be a prefix: @v1 denotes the latest available version starting
// with v1. See 'go help modules' under the heading 'Module queries' for the
// full query syntax.
//
// For modules stored in source control repositories, the version suffix can
// also be a commit hash, branch identifier, or other syntax known to the
// source control system, as in 'go get golang.org/x/text@master'. Note that
// branches with names that overlap with other module query syntax cannot be
// selected explicitly. For example, the suffix @v2 means the latest version
// starting with v2, not the branch named v2.
//
// If a module under consideration is already a dependency of the current
// development module, then get will update the required version.
// Specifying a version earlier than the current required version is valid and
// downgrades the dependency. The version suffix @none indicates that the
// dependency should be removed entirely, downgrading or removing modules
// depending on it as needed.
//
// The version suffix @latest explicitly requests the latest minor release of the
// module named by the given path. The suffix @upgrade is like @latest but
// will not downgrade a module if it is already required at a revision or
// pre-release version newer than the latest released version. The suffix
// @patch requests the latest patch release: the latest released version
// with the same major and minor version numbers as the currently required
// version. Like @upgrade, @patch will not downgrade a module already required
// at a newer version. If the path is not already required, @upgrade and @patch
// are equivalent to @latest.
//
// Although get defaults to using the latest version of the module containing
// a named package, it does not use the latest version of that module's
// dependencies. Instead it prefers to use the specific dependency versions
// requested by that module. For example, if the latest A requires module
// B v1.2.3, while B v1.2.4 and v1.3.1 are also available, then 'go get A'
// will use the latest A but then use B v1.2.3, as requested by A. (If there
// are competing requirements for a particular module, then 'go get' resolves
// those requirements by taking the maximum requested version.)
//
// The -t flag instructs get to consider modules needed to build tests of
// packages specified on the command line.
//
// The -u flag instructs get to update modules providing dependencies
// of packages named on the command line to use newer minor or patch
// releases when available. Continuing the previous example, 'go get -u A'
// will use the latest A with B v1.3.1 (not B v1.2.3). If B requires module C,
// but C does not provide any packages needed to build packages in A
// (not including tests), then C will not be updated.
//
// The -u=patch flag (not -u patch) also instructs get to update dependencies,
// but changes the default to select patch releases.
// Continuing the previous example,
// 'go get -u=patch A@latest' will use the latest A with B v1.2.4 (not B v1.2.3),
// while 'go get -u=patch A' will use a patch release of A instead.
//
// When the -t and -u flags are used together, get will update
// test dependencies as well.
//
// In general, adding a new dependency may require upgrading
// existing dependencies to keep a working build, and 'go get' does
// this automatically. Similarly, downgrading one dependency may
// require downgrading other dependencies, and 'go get' does
// this automatically as well.
//
// The -insecure flag permits fetching from repositories and resolving
// custom domains using insecure schemes such as HTTP. Use with caution. The
// GOINSECURE environment variable is usually a better alternative, since it
// provides control over which modules may be retrieved using an insecure scheme.
// See 'go help environment' for details.
//
// The second step is to download (if needed), build, and install
// the named packages.
//
// If an argument names a module but not a package (because there is no
// Go source code in the module's root directory), then the install step
// is skipped for that argument, instead of causing a build failure.
// For example 'go get golang.org/x/perf' succeeds even though there
// is no code corresponding to that import path.
//
// Note that package patterns are allowed and are expanded after resolving
// the module versions. For example, 'go get golang.org/x/perf/cmd/...'
// adds the latest golang.org/x/perf and then installs the commands in that
// latest version.
//
// The -d flag instructs get to download the source code needed to build
// the named packages, including downloading necessary dependencies,
// but not to build and install them.
//
// With no package arguments, 'go get' applies to Go package in the
// current directory, if any. In particular, 'go get -u' and
// 'go get -u=patch' update all the dependencies of that package.
// With no package arguments and also without -u, 'go get' is not much more
// than 'go install', and 'go get -d' not much more than 'go list'.
//
// For more about modules, see 'go help modules'.
//
// For more about specifying packages, see 'go help packages'.
//
// This text describes the behavior of get using modules to manage source
// code and dependencies. If instead the go command is running in GOPATH
// mode, the details of get's flags and effects change, as does 'go help get'.
// See 'go help modules' and 'go help gopath-get'.
//
// See also: go build, go install, go clean, go mod.
//
//
// Compile and install packages and dependencies
//
// Usage:
//
// 	go install [-i] [build flags] [packages]
//
// Install compiles and installs the packages named by the import paths.
//
// Executables are installed in the directory named by the GOBIN environment
// variable, which defaults to $GOPATH/bin or $HOME/go/bin if the GOPATH
// environment variable is not set. Executables in $GOROOT
// are installed in $GOROOT/bin or $GOTOOLDIR instead of $GOBIN.
//
// When module-aware mode is disabled, other packages are installed in the
// directory $GOPATH/pkg/$GOOS_$GOARCH. When module-aware mode is enabled,
// other packages are built and cached but not installed.
//
// The -i flag installs the dependencies of the named packages as well.
//
// For more about the build flags, see 'go help build'.
// For more about specifying packages, see 'go help packages'.
//
// See also: go build, go get, go clean.
//
//
// List packages or modules
//
// Usage:
//
// 	go list [-f format] [-json] [-m] [list flags] [build flags] [packages]
//
// List lists the named packages, one per line.
// The most commonly-used flags are -f and -json, which control the form
// of the output printed for each package. Other list flags, documented below,
// control more specific details.
//
// The default output shows the package import path:
//
//     bytes
//     encoding/json
//     github.com/gorilla/mux
//     golang.org/x/net/html
//
// The -f flag specifies an alternate format for the list, using the
// syntax of package template. The default output is equivalent
// to -f '{{.ImportPath}}'. The struct being passed to the template is:
//
//     type Package struct {
//         Dir           string   // directory containing package sources
//         ImportPath    string   // import path of package in dir
//         ImportComment string   // path in import comment on package statement
//         Name          string   // package name
//         Doc           string   // package documentation string
//         Target        string   // install path
//         Shlib         string   // the shared library that contains this package (only set when -linkshared)
//         Goroot        bool     // is this package in the Go root?
//         Standard      bool     // is this package part of the standard Go library?
//         Stale         bool     // would 'go install' do anything for this package?
//         StaleReason   string   // explanation for Stale==true
//         Root          string   // Go root or Go path dir containing this package
//         ConflictDir   string   // this directory shadows Dir in $GOPATH
//         BinaryOnly    bool     // binary-only package (no longer supported)
//         ForTest       string   // package is only for use in named test
//         Export        string   // file containing export data (when using -export)
//         Module        *Module  // info about package's containing module, if any (can be nil)
//         Match         []string // command-line patterns matching this package
//         DepOnly       bool     // package is only a dependency, not explicitly listed
//
//         // Source files
//         GoFiles         []string // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)
//         CgoFiles        []string // .go source files that import "C"
//         CompiledGoFiles []string // .go files presented to compiler (when using -compiled)
//         IgnoredGoFiles  []string // .go source files ignored due to build constraints
//         CFiles          []string // .c source files
//         CXXFiles        []string // .cc, .cxx and .cpp source files
//         MFiles          []string // .m source files
//         HFiles          []string // .h, .hh, .hpp and .hxx source files
//         FFiles          []string // .f, .F, .for and .f90 Fortran source files
//         SFiles          []string // .s source files
//         SwigFiles       []string // .swig files
//         SwigCXXFiles    []string // .swigcxx files
//         SysoFiles       []string // .syso object files to add to archive
//         TestGoFiles     []string // _test.go files in package
//         XTestGoFiles    []string // _test.go files outside package
//
//         // Cgo directives
//         CgoCFLAGS    []string // cgo: flags for C compiler
//         CgoCPPFLAGS  []string // cgo: flags for C preprocessor
//         CgoCXXFLAGS  []string // cgo: flags for C++ compiler
//         CgoFFLAGS    []string // cgo: flags for Fortran compiler
//         CgoLDFLAGS   []string // cgo: flags for linker
//         CgoPkgConfig []string // cgo: pkg-config names
//
//         // Dependency information
//         Imports      []string          // import paths used by this package
//         ImportMap    map[string]string // map from source import to ImportPath (identity entries omitted)
//         Deps         []string          // all (recursively) imported dependencies
//         TestImports  []string          // imports from TestGoFiles
//         XTestImports []string          // imports from XTestGoFiles
//
//         // Error information
//         Incomplete bool            // this package or a dependency has an error
//         Error      *PackageError   // error loading package
//         DepsErrors []*PackageError // errors loading dependencies
//     }
//
// Packages stored in vendor directories report an ImportPath that includes the
// path to the vendor directory (for example, "d/vendor/p" instead of "p"),
// so that the ImportPath uniquely identifies a given copy of a package.
// The Imports, Deps, TestImports, and XTestImports lists also contain these
// expanded import paths. See golang.org/s/go15vendor for more about vendoring.
//
// The error information, if any, is
//
//     type PackageError struct {
//         ImportStack   []string // shortest path from package named on command line to this one
//         Pos           string   // position of error (if present, file:line:col)
//         Err           string   // the error itself
//     }
//
// The module information is a Module struct, defined in the discussion
// of list -m below.
//
// The template function "join" calls strings.Join.
//
// The template function "context" returns the build context, defined as:
//
//     type Context struct {
//         GOARCH        string   // target architecture
//         GOOS          string   // target operating system
//         GOROOT        string   // Go root
//         GOPATH        string   // Go path
//         CgoEnabled    bool     // whether cgo can be used
//         UseAllFiles   bool     // use files regardless of +build lines, file names
//         Compiler      string   // compiler to assume when computing target paths
//         BuildTags     []string // build constraints to match in +build lines
//         ReleaseTags   []string // releases the current release is compatible with
//         InstallSuffix string   // suffix to use in the name of the install dir
//     }
//
// For more information about the meaning of these fields see the documentation
// for the go/build package's Context type.
//
// The -json flag causes the package data to be printed in JSON format
// instead of using the template format.
//
// The -compiled flag causes list to set CompiledGoFiles to the Go source
// files presented to the compiler. Typically this means that it repeats
// the files listed in GoFiles and then also adds the Go code generated
// by processing CgoFiles and SwigFiles. The Imports list contains the
// union of all imports from both GoFiles and CompiledGoFiles.
//
// The -deps flag causes list to iterate over not just the named packages
// but also all their dependencies. It visits them in a depth-first post-order
// traversal, so that a package is listed only after all its dependencies.
// Packages not explicitly listed on the command line will have the DepOnly
// field set to true.
//
// The -e flag changes the handling of erroneous packages, those that
// cannot be found or are malformed. By default, the list command
// prints an error to standard error for each erroneous package and
// omits the packages from consideration during the usual printing.
// With the -e flag, the list command never prints errors to standard
// error and instead processes the erroneous packages with the usual
// printing. Erroneous packages will have a non-empty ImportPath and
// a non-nil Error field; other information may or may not be missing
// (zeroed).
//
// The -export flag causes list to set the Export field to the name of a
// file containing up-to-date export information for the given package.
//
// The -find flag causes list to identify the named packages but not
// resolve their dependencies: the Imports and Deps lists will be empty.
//
// The -test flag causes list to report not only the named packages
// but also their test binaries (for packages with tests), to convey to
// source code analysis tools exactly how test binaries are constructed.
// The reported import path for a test binary is the import path of
// the package followed by a ".test" suffix, as in "math/rand.test".
// When building a test, it is sometimes necessary to rebuild certain
// dependencies specially for that test (most commonly the tested
// package itself). The reported import path of a package recompiled
// for a particular test binary is followed by a space and the name of
// the test binary in brackets, as in "math/rand [math/rand.test]"
// or "regexp [sort.test]". The ForTest field is also set to the name
// of the package being tested ("math/rand" or "sort" in the previous
// examples).
//
// The Dir, Target, Shlib, Root, ConflictDir, and Export file paths
// are all absolute paths.
//
// By default, the lists GoFiles, CgoFiles, and so on hold names of files in Dir
// (that is, paths relative to Dir, not absolute paths).
// The generated files added when using the -compiled and -test flags
// are absolute paths referring to cached copies of generated Go source files.
// Although they are Go source files, the paths may not end in ".go".
//
// The -m flag causes list to list modules instead of packages.
//
// When listing modules, the -f flag still specifies a format template
// applied to a Go struct, but now a Module struct:
//
//     type Module struct {
//         Path      string       // module path
//         Version   string       // module version
//         Versions  []string     // available module versions (with -versions)
//         Replace   *Module      // replaced by this module
//         Time      *time.Time   // time version was created
//         Update    *Module      // available update, if any (with -u)
//         Main      bool         // is this the main module?
//         Indirect  bool         // is this module only an indirect dependency of main module?
//         Dir       string       // directory holding files for this module, if any
//         GoMod     string       // path to go.mod file used when loading this module, if any
//         GoVersion string       // go version used in module
//         Error     *ModuleError // error loading module
//     }
//
//     type ModuleError struct {
//         Err string // the error itself
//     }
//
// The file GoMod refers to may be outside the module directory if the
// module is in the module cache or if the -modfile flag is used.
//
// The default output is to print the module path and then
// information about the version and replacement if any.
// For example, 'go list -m all' might print:
//
//     my/main/module
//     golang.org/x/text v0.3.0 => /tmp/text
//     rsc.io/pdf v0.1.1
//
// The Module struct has a String method that formats this
// line of output, so that the default format is equivalent
// to -f '{{.String}}'.
//
// Note that when a module has been replaced, its Replace field
// describes the replacement module, and its Dir field is set to
// the replacement's source code, if present. (That is, if Replace
// is non-nil, then Dir is set to Replace.Dir, with no access to
// the replaced source code.)
//
// The -u flag adds information about available upgrades.
// When the latest version of a given module is newer than
// the current one, list -u sets the Module's Update field
// to information about the newer module.
// The Module's String method indicates an available upgrade by
// formatting the newer version in brackets after the current version.
// For example, 'go list -m -u all' might print:
//
//     my/main/module
//     golang.org/x/text v0.3.0 [v0.4.0] => /tmp/text
//     rsc.io/pdf v0.1.1 [v0.1.2]
//
// (For tools, 'go list -m -u -json all' may be more convenient to parse.)
//
// The -versions flag causes list to set the Module's Versions field
// to a list of all known versions of that module, ordered according
// to semantic versioning, earliest to latest. The flag also changes
// the default output format to display the module path followed by the
// space-separated version list.
//
// The arguments to list -m are interpreted as a list of modules, not packages.
// The main module is the module containing the current directory.
// The active modules are the main module and its dependencies.
// With no arguments, list -m shows the main module.
// With arguments, list -m shows the modules specified by the arguments.
// Any of the active modules can be specified by its module path.
// The special pattern "all" specifies all the active modules, first the main
// module and then dependencies sorted by module path.
// A pattern containing "..." specifies the active modules whose
// module paths match the pattern.
// A query of the form path@version specifies the result of that query,
// which is not limited to active modules.
// See 'go help modules' for more about module queries.
//
// The template function "module" takes a single string argument
// that must be a module path or query and returns the specified
// module as a Module struct. If an error occurs, the result will
// be a Module struct with a non-nil Error field.
//
// For more about build flags, see 'go help build'.
//
// For more about specifying packages, see 'go help packages'.
//
// For more about modules, see 'go help modules'.
//
//
// Module maintenance
//
// Go mod provides access to operations on modules.
//
// Note that support for modules is built into all the go commands,
// not just 'go mod'. For example, day-to-day adding, removing, upgrading,
// and downgrading of dependencies should be done using 'go get'.
// See 'go help modules' for an overview of module functionality.
//
// Usage:
//
// 	go mod <command> [arguments]
//
// The commands are:
//
// 	download    download modules to local cache
// 	edit        edit go.mod from tools or scripts
// 	graph       print module requirement graph
// 	init        initialize new module in current directory
// 	tidy        add missing and remove unused modules
// 	vendor      make vendored copy of dependencies
// 	verify      verify dependencies have expected content
// 	why         explain why packages or modules are needed
//
// Use "go help mod <command>" for more information about a command.
//
// Download modules to local cache
//
// Usage:
//
// 	go mod download [-x] [-json] [modules]
//
// Download downloads the named modules, which can be module patterns selecting
// dependencies of the main module or module queries of the form path@version.
// With no arguments, download applies to all dependencies of the main module
// (equivalent to 'go mod download all').
//
// The go command will automatically download modules as needed during ordinary
// execution. The "go mod download" command is useful mainly for pre-filling
// the local cache or to compute the answers for a Go module proxy.
//
// By default, download writes nothing to standard output. It may print progress
// messages and errors to standard error.
//
// The -json flag causes download to print a sequence of JSON objects
// to standard output, describing each downloaded module (or failure),
// corresponding to this Go struct:
//
//     type Module struct {
//         Path     string // module path
//         Version  string // module version
//         Error    string // error loading module
//         Info     string // absolute path to cached .info file
//         GoMod    string // absolute path to cached .mod file
//         Zip      string // absolute path to cached .zip file
//         Dir      string // absolute path to cached source root directory
//         Sum      string // checksum for path, version (as in go.sum)
//         GoModSum string // checksum for go.mod (as in go.sum)
//     }
//
// The -x flag causes download to print the commands download executes.
//
// See 'go help modules' for more about module queries.
//
//
// Edit go.mod from tools or scripts
//
// Usage:
//
// 	go mod edit [editing flags] [go.mod]
//
// Edit provides a command-line interface for editing go.mod,
// for use primarily by tools or scripts. It reads only go.mod;
// it does not look up information about the modules involved.
// By default, edit reads and writes the go.mod file of the main module,
// but a different target file can be specified after the editing flags.
//
// The editing flags specify a sequence of editing operations.
//
// The -fmt flag reformats the go.mod file without making other changes.
// This reformatting is also implied by any other modifications that use or
// rewrite the go.mod file. The only time this flag is needed is if no other
// flags are specified, as in 'go mod edit -fmt'.
//
// The -module flag changes the module's path (the go.mod file's module line).
//
// The -require=path@version and -droprequire=path flags
// add and drop a requirement on the given module path and version.
// Note that -require overrides any existing requirements on path.
// These flags are mainly for tools that understand the module graph.
// Users should prefer 'go get path@version' or 'go get path@none',
// which make other go.mod adjustments as needed to satisfy
// constraints imposed by other modules.
//
// The -exclude=path@version and -dropexclude=path@version flags
// add and drop an exclusion for the given module path and version.
// Note that -exclude=path@version is a no-op if that exclusion already exists.
//
// The -replace=old[@v]=new[@v] flag adds a replacement of the given
// module path and version pair. If the @v in old@v is omitted, a
// replacement without a version on the left side is added, which applies
// to all versions of the old module path. If the @v in new@v is omitted,
// the new path should be a local module root directory, not a module
// path. Note that -replace overrides any redundant replacements for old[@v],
// so omitting @v will drop existing replacements for specific versions.
//
// The -dropreplace=old[@v] flag drops a replacement of the given
// module path and version pair. If the @v is omitted, a replacement without
// a version on the left side is dropped.
//
// The -require, -droprequire, -exclude, -dropexclude, -replace,
// and -dropreplace editing flags may be repeated, and the changes
// are applied in the order given.
//
// The -go=version flag sets the expected Go language version.
//
// The -print flag prints the final go.mod in its text format instead of
// writing it back to go.mod.
//
// The -json flag prints the final go.mod file in JSON format instead of
// writing it back to go.mod. The JSON output corresponds to these Go types:
//
// 	type Module struct {
// 		Path string
// 		Version string
// 	}
//
// 	type GoMod struct {
// 		Module  Module
// 		Go      string
// 		Require []Require
// 		Exclude []Module
// 		Replace []Replace
// 	}
//
// 	type Require struct {
// 		Path string
// 		Version string
// 		Indirect bool
// 	}
//
// 	type Replace struct {
// 		Old Module
// 		New Module
// 	}
//
// Note that this only describes the go.mod file itself, not other modules
// referred to indirectly. For the full set of modules available to a build,
// use 'go list -m -json all'.
//
// For example, a tool can obtain the go.mod as a data structure by
// parsing the output of 'go mod edit -json' and can then make changes
// by invoking 'go mod edit' with -require, -exclude, and so on.
//
//
// Print module requirement graph
//
// Usage:
//
// 	go mod graph
//
// Graph prints the module requirement graph (with replacements applied)
// in text form. Each line in the output has two space-separated fields: a module
// and one of its requirements. Each module is identified as a string of the form
// path@version, except for the main module, which has no @version suffix.
//
//
// Initialize new module in current directory
//
// Usage:
//
// 	go mod init [module]
//
// Init initializes and writes a new go.mod to the current directory,
// in effect creating a new module rooted at the current directory.
// The file go.mod must not already exist.
// If possible, init will guess the module path from import comments
// (see 'go help importpath') or from version control configuration.
// To override this guess, supply the module path as an argument.
//
//
// Add missing and remove unused modules
//
// Usage:
//
// 	go mod tidy [-v]
//
// Tidy makes sure go.mod matches the source code in the module.
// It adds any missing modules necessary to build the current module's
// packages and dependencies, and it removes unused modules that
// don't provide any relevant packages. It also adds any missing entries
// to go.sum and removes any unnecessary ones.
//
// The -v flag causes tidy to print information about removed modules
// to standard error.
//
//
// Make vendored copy of dependencies
//
// Usage:
//
// 	go mod vendor [-v]
//
// Vendor resets the main module's vendor directory to include all packages
// needed to build and test all the main module's packages.
// It does not include test code for vendored packages.
//
// The -v flag causes vendor to print the names of vendored
// modules and packages to standard error.
//
//
// Verify dependencies have expected content
//
// Usage:
//
// 	go mod verify
//
// Verify checks that the dependencies of the current module,
// which are stored in a local downloaded source cache, have not been
// modified since being downloaded. If all the modules are unmodified,
// verify prints "all modules verified." Otherwise it reports which
// modules have been changed and causes 'go mod' to exit with a
// non-zero status.
//
//
// Explain why packages or modules are needed
//
// Usage:
//
// 	go mod why [-m] [-vendor] packages...
//
// Why shows a shortest path in the import graph from the main module to
// each of the listed packages. If the -m flag is given, why treats the
// arguments as a list of modules and finds a path to any package in each
// of the modules.
//
// By default, why queries the graph of packages matched by "go list all",
// which includes tests for reachable packages. The -vendor flag causes why
// to exclude tests of dependencies.
//
// The output is a sequence of stanzas, one for each package or module
// name on the command line, separated by blank lines. Each stanza begins
// with a comment line "# package" or "# module" giving the target
// package or module. Subsequent lines give a path through the import
// graph, one package per line. If the package or module is not
// referenced from the main module, the stanza will display a single
// parenthesized note indicating that fact.
//
// For example:
//
// 	$ go mod why golang.org/x/text/language golang.org/x/text/encoding
// 	# golang.org/x/text/language
// 	rsc.io/quote
// 	rsc.io/sampler
// 	golang.org/x/text/language
//
// 	# golang.org/x/text/encoding
// 	(main module does not need package golang.org/x/text/encoding)
// 	$
//
//
// Compile and run Go program
//
// Usage:
//
// 	go run [build flags] [-exec xprog] package [arguments...]
//
// Run compiles and runs the named main Go package.
// Typically the package is specified as a list of .go source files from a single directory,
// but it may also be an import path, file system path, or pattern
// matching a single known package, as in 'go run .' or 'go run my/cmd'.
//
// By default, 'go run' runs the compiled binary directly: 'a.out arguments...'.
// If the -exec flag is given, 'go run' invokes the binary using xprog:
// 	'xprog a.out arguments...'.
// If the -exec flag is not given, GOOS or GOARCH is different from the system
// default, and a program named go_$GOOS_$GOARCH_exec can be found
// on the current search path, 'go run' invokes the binary using that program,
// for example 'go_js_wasm_exec a.out arguments...'. This allows execution of
// cross-compiled programs when a simulator or other execution method is
// available.
//
// The exit status of Run is not the exit status of the compiled binary.
//
// For more about build flags, see 'go help build'.
// For more about specifying packages, see 'go help packages'.
//
// See also: go build.
//
//
// Test packages
//
// Usage:
//
// 	go test [build/test flags] [packages] [build/test flags & test binary flags]
//
// 'Go test' automates testing the packages named by the import paths.
// It prints a summary of the test results in the format:
//
// 	ok   archive/tar   0.011s
// 	FAIL archive/zip   0.022s
// 	ok   compress/gzip 0.033s
// 	...
//
// followed by detailed output for each failed package.
//
// 'Go test' recompiles each package along with any files with names matching
// the file pattern "*_test.go".
// These additional files can contain test functions, benchmark functions, and
// example functions. See 'go help testfunc' for more.
// Each listed package causes the execution of a separate test binary.
// Files whose names begin with "_" (including "_test.go") or "." are ignored.
//
// Test files that declare a package with the suffix "_test" will be compiled as a
// separate package, and then linked and run with the main test binary.
//
// The go tool will ignore a directory named "testdata", making it available
// to hold ancillary data needed by the tests.
//
// As part of building a test binary, go test runs go vet on the package
// and its test source files to identify significant problems. If go vet
// finds any problems, go test reports those and does not run the test
// binary. Only a high-confidence subset of the default go vet checks are
// used. That subset is: 'atomic', 'bool', 'buildtags', 'nilfunc', and
// 'printf'. You can see the documentation for these and other vet tests
// via "go doc cmd/vet". To disable the running of go vet, use the
// -vet=off flag.
//
// All test output and summary lines are printed to the go command's
// standard output, even if the test printed them to its own standard
// error. (The go command's standard error is reserved for printing
// errors building the tests.)
//
// Go test runs in two different modes:
//
// The first, called local directory mode, occurs when go test is
// invoked with no package arguments (for example, 'go test' or 'go
// test -v'). In this mode, go test compiles the package sources and
// tests found in the current directory and then runs the resulting
// test binary. In this mode, caching (discussed below) is disabled.
// After the package test finishes, go test prints a summary line
// showing the test status ('ok' or 'FAIL'), package name, and elapsed
// time.
//
// The second, called package list mode, occurs when go test is invoked
// with explicit package arguments (for example 'go test math', 'go
// test ./...', and even 'go test .'). In this mode, go test compiles
// and tests each of the packages listed on the command line. If a
// package test passes, go test prints only the final 'ok' summary
// line. If a package test fails, go test prints the full test output.
// If invoked with the -bench or -v flag, go test prints the full
// output even for passing package tests, in order to display the
// requested benchmark results or verbose logging. After the package
// tests for all of the listed packages finish, and their output is
// printed, go test prints a final 'FAIL' status if any package test
// has failed.
//
// In package list mode only, go test caches successful package test
// results to avoid unnecessary repeated running of tests. When the
// result of a test can be recovered from the cache, go test will
// redisplay the previous output instead of running the test binary
// again. When this happens, go test prints '(cached)' in place of the
// elapsed time in the summary line.
//
// The rule for a match in the cache is that the run involves the same
// test binary and the flags on the command line come entirely from a
// restricted set of 'cacheable' test flags, defined as -cpu, -list,
// -parallel, -run, -short, and -v. If a run of go test has any test
// or non-test flags outside this set, the result is not cached. To
// disable test caching, use any test flag or argument other than the
// cacheable flags. The idiomatic way to disable test caching explicitly
// is to use -count=1. Tests that open files within the package's source
// root (usually $GOPATH) or that consult environment variables only
// match future runs in which the files and environment variables are unchanged.
// A cached test result is treated as executing in no time at all,
// so a successful package test result will be cached and reused
// regardless of -timeout setting.
//
// In addition to the build flags, the flags handled by 'go test' itself are:
//
// 	-args
// 	    Pass the remainder of the command line (everything after -args)
// 	    to the test binary, uninterpreted and unchanged.
// 	    Because this flag consumes the remainder of the command line,
// 	    the package list (if present) must appear before this flag.
//
// 	-c
// 	    Compile the test binary to pkg.test but do not run it
// 	    (where pkg is the last element of the package's import path).
// 	    The file name can be changed with the -o flag.
//
// 	-exec xprog
// 	    Run the test binary using xprog. The behavior is the same as
// 	    in 'go run'. See 'go help run' for details.
//
// 	-i
// 	    Install packages that are dependencies of the test.
// 	    Do not run the test.
//
// 	-json
// 	    Convert test output to JSON suitable for automated processing.
// 	    See 'go doc test2json' for the encoding details.
//
// 	-o file
// 	    Compile the test binary to the named file.
// 	    The test still runs (unless -c or -i is specified).
//
// The test binary also accepts flags that control execution of the test; these
// flags are also accessible by 'go test'. See 'go help testflag' for details.
//
// For more about build flags, see 'go help build'.
// For more about specifying packages, see 'go help packages'.
//
// See also: go build, go vet.
//
//
// Run specified go tool
//
// Usage:
//
// 	go tool [-n] command [args...]
//
// Tool runs the go tool command identified by the arguments.
// With no arguments it prints the list of known tools.
//
// The -n flag causes tool to print the command that would be
// executed but not execute it.
//
// For more about each tool command, see 'go doc cmd/<command>'.
//
//
// Print Go version
//
// Usage:
//
// 	go version [-m] [-v] [file ...]
//
// Version prints the build information for Go executables.
//
// Go version reports the Go version used to build each of the named
// executable files.
//
// If no files are named on the command line, go version prints its own
// version information.
//
// If a directory is named, go version walks that directory, recursively,
// looking for recognized Go binaries and reporting their versions.
// By default, go version does not report unrecognized files found
// during a directory scan. The -v flag causes it to report unrecognized files.
//
// The -m flag causes go version to print each executable's embedded
// module version information, when available. In the output, the module
// information consists of multiple lines following the version line, each
// indented by a leading tab character.
//
// See also: go doc runtime/debug.BuildInfo.
//
//
// Report likely mistakes in packages
//
// Usage:
//
// 	go vet [-n] [-x] [-vettool prog] [build flags] [vet flags] [packages]
//
// Vet runs the Go vet command on the packages named by the import paths.
//
// For more about vet and its flags, see 'go doc cmd/vet'.
// For more about specifying packages, see 'go help packages'.
// For a list of checkers and their flags, see 'go tool vet help'.
// For details of a specific checker such as 'printf', see 'go tool vet help printf'.
//
// The -n flag prints commands that would be executed.
// The -x flag prints commands as they are executed.
//
// The -vettool=prog flag selects a different analysis tool with alternative
// or additional checks.
// For example, the 'shadow' analyzer can be built and run using these commands:
//
//   go install golang.org/x/tools/go/analysis/passes/shadow/cmd/shadow
//   go vet -vettool=$(which shadow)
//
// The build flags supported by go vet are those that control package resolution
// and execution, such as -n, -x, -v, -tags, and -toolexec.
// For more about these flags, see 'go help build'.
//
// See also: go fmt, go fix.
//
//
// Build constraints
//
// Build constraints describe the conditions under which each source file
// should be included in the corresponding package. Build constraints
// for a given source file may be added by build constraint comments
// within the file, or by specific patterns in the file's name.
//
// A build constraint comment appears before the file's package clause and
// must be separated from the package clause by at least one blank line.
// The comment begins with:
//
// 	// +build
//
// and follows with a space-separated list of options on the same line.
// The constraint is evaluated as the OR of the options.
// Each option evaluates as the AND of its comma-separated terms.
// Each term consists of letters, digits, underscores, and dots.
// Each term may be negated with a leading exclamation point.
//
// For example, the build constraint:
//
// 	// +build linux,386 darwin,!cgo arm
//
// corresponds to boolean formula:
//
// 	(linux AND 386) OR (darwin AND NOT cgo) OR arm
//
// During a particular build, the following terms are satisfied:
// - the target operating system and architecture, as spelled by
//   runtime.GOOS and runtime.GOARCH respectively
// - the compiler being used, either "gc" or "gccgo"
// - "cgo", if the cgo command is supported
//   (see CGO_ENABLED in 'go help environment')
// - a term for each Go major release, through the current version:
//   "go1.1" from Go version 1.1 onward,
//   "go1.2" from Go version 1.2 onward, and so on
// - and any additional tags given by the '-tags' flag (see 'go help build').
//
// An additional build constraint may be derived from the source file name.
// If a file's name, after stripping the extension and a possible _test suffix,
// matches the patterns *_GOOS, *_GOARCH, or *_GOOS_GOARCH for any known
// GOOS or GOARCH value, then the file is implicitly constrained to that
// specific GOOS and/or GOARCH, in addition to any other build constraints
// declared as comments within the file.
//
// For example, the file:
//
// 	source_windows_amd64.go
//
// is implicitly constrained to windows / amd64.
//
// See 'go doc go/build' for more details.
//
//
// Build modes
//
// The 'go build' and 'go install' commands take a -buildmode argument which
// indicates which kind of object file is to be built. Currently supported values
// are:
//
// 	-buildmode=archive
// 		Build the listed non-main packages into .a files. Packages named
// 		main are ignored.
//
// 	-buildmode=c-archive
// 		Build the listed main package, plus all packages it imports,
// 		into a C archive file. The only callable symbols will be those
// 		functions exported using a cgo //export comment. Requires
// 		exactly one main package to be listed.
//
// 	-buildmode=c-shared
// 		Build the listed main package, plus all packages it imports,
// 		into a C shared library. The only callable symbols will
// 		be those functions exported using a cgo //export comment.
// 		Requires exactly one main package to be listed.
//
// 	-buildmode=default
// 		Listed main packages are built into executables and listed
// 		no
"""




```
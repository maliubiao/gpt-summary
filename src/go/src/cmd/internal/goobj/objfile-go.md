Response: The user wants to understand the functionality of the `go/src/cmd/internal/goobj/objfile.go` file. I need to analyze the provided Go code and:

1. **List the functionalities:** Identify the core purposes of the code.
2. **Infer Go language feature implementation:** Determine which Go language features this code supports or is related to.
3. **Provide Go code examples:** Illustrate the inferred features with concrete Go code, including input and output assumptions.
4. **Explain command-line parameter handling:** If the code interacts with command-line arguments, describe how.
5. **Highlight common mistakes:** Point out potential pitfalls for users of this package.

**Functionality Analysis:**

The code defines the structure and methods for reading and writing Go object files. Based on the defined structs and methods, the key functionalities are:

*   **Defining the object file format:** The `Header` struct and subsequent structs represent the different sections of a Go object file.
*   **Reading object files:** The `Reader` struct and its methods (`Read`, `BytesAt`, `StringAt`, etc.) provide ways to parse and access data within an object file.
*   **Writing object files:** The `Writer` struct and its methods (`Write`, `RawString`, `Uint32`, etc.) enable the creation and serialization of object file data.
*   **Handling different data types:** The code handles strings, integers, booleans, and custom structs (`Sym`, `Reloc`, `Aux`, etc.) within the object file.
*   **Managing symbol information:** Structures like `Sym`, `SymRef`, `HashedDefs`, etc., are used to represent and access symbol definitions and references.
*   **Handling relocations:** The `Reloc` struct and related methods manage information about code relocations needed during linking.
*   **Managing auxiliary symbol information:** The `Aux` struct and related methods handle extra information associated with symbols, such as Go type information, function information, and DWARF debugging data.

**Inferring Go Language Feature Implementation:**

This code is fundamental to the Go compilation and linking process. It's not directly implementing a single high-level Go language feature but rather provides the low-level infrastructure for representing compiled Go code. However, we can infer its role in enabling several features:

*   **Separate compilation:** The object file format allows Go packages to be compiled independently and then linked together.
*   **Code linking:** The relocation information in the object file is crucial for the linker to combine different object files into an executable.
*   **Reflection:** The `AuxGotype` and related structures suggest support for runtime reflection by storing type information.
*   **Debugging:** The presence of `AuxDwarfInfo`, `AuxDwarfLoc`, etc., indicates support for generating and storing DWARF debugging information.
*   **Interface implementation:**  Flags like `SymFlagUsedInIface` and `SymFlagItab` are related to how Go interfaces are implemented.
*   **Content addressable symbols:** The presence of `HashedDefs` and `Hash` blocks suggests support for content-addressable symbols, possibly for compiler optimizations or deduplication.

**Go Code Examples:**

Let's illustrate reading symbol information from an object file.

```go
package main

import (
	"cmd/internal/goobj"
	"debug/elf"
	"fmt"
	"os"
)

func main() {
	if len(os.Args) != 2 {
		fmt.Println("Usage: go run main.go <object_file>")
		return
	}
	objFilePath := os.Args[1]

	// Assume the input is a valid Go object file
	objFileBytes, err := os.ReadFile(objFilePath)
	if err != nil {
		fmt.Println("Error reading object file:", err)
		return
	}

	reader := goobj.NewReaderFromBytes(objFileBytes, true)
	if reader == nil {
		fmt.Println("Error creating reader, invalid Go object file format")
		return
	}

	numSymbols := reader.NSym()
	fmt.Printf("Number of symbols: %d\n", numSymbols)

	// Iterate through the defined symbols
	for i := 0; i < numSymbols; i++ {
		sym := reader.Sym(uint32(i))
		if sym != nil {
			fmt.Printf("Symbol %d: Name=%s, Type=%d, Size=%d\n", i, sym.Name(reader), sym.Type(), sym.Siz())
		}
	}
}
```

**Assumed Input:** A valid Go object file named `example.o`. This file would have been generated by compiling a Go source file.

**Expected Output:**

```
Number of symbols: <number_of_symbols>
Symbol 0: Name=go.itab.*os.File,io.Reader, Type=48, Size=24
Symbol 1: Name=os.Stdin, Type=48, Size=8
Symbol 2: Name=os.Stdout, Type=48, Size=8
...
```

**Command-line Parameter Handling:**

This specific code snippet doesn't directly handle command-line parameters. However, the comment block at the beginning mentions that this package is used by tools like `cmd/asm`, `cmd/compile`, `cmd/nm`, `cmd/objdump`, and `cmd/link`. These tools extensively use command-line flags to control their behavior.

For example, `cmd/compile` uses flags like `-o` to specify the output object file name, `-p` for the package import path, and numerous others to control optimization levels, target architecture, etc. The `goobj` package itself doesn't parse these flags, but the higher-level code in these tools would use libraries like `flag` to handle them.

**Common Mistakes:**

One potential mistake a user of a higher-level package built on `goobj` (like the tools mentioned) might make is:

*   **Incorrectly interpreting symbol indices:** The documentation for `symRef` explains the different `PkgIdx` values and how they relate to the `SymIdx`. For instance, a `SymIdx` in the `SymbolDefs` array is different from one in the `NonPkgDefs` array. A user might incorrectly assume a global, flat index for all symbols.

**Example of potential mistake (hypothetical higher-level tool):**

Imagine a tool that tries to find all symbols with a specific name. A naive implementation might iterate through all the `SymbolDefs`, `HashedDefs`, `NonPkgDefs`, and `NonPkgRefs` arrays separately, without correctly accounting for the `PkgIdx`. This would lead to missing symbols or incorrect identification if the same symbol name exists in different contexts (e.g., a local symbol and a package-level symbol with the same name).

This covers the requested aspects of the analysis. Let me generate the final response.

`go/src/cmd/internal/goobj/objfile.go` 定义了 Go 目标文件格式，并提供了用于读取和写入目标文件的 "底层" 功能。以下是它的主要功能：

**1. 定义 Go 目标文件格式:**

*   该文件定义了 Go 编译器、汇编器、链接器以及其他工具理解的目标文件结构。
*   它通过 Go 结构体 (`Header`, `Sym`, `Reloc`, `Aux` 等) 详细描述了目标文件的各个组成部分，例如：
    *   **Header:** 包含魔数、指纹、标志以及各个数据块的偏移量。
    *   **Strings:** 存储字符串数据，并使用偏移量引用。
    *   **Autolib:** 列出导入的包及其指纹。
    *   **PkgIndex:** 存储引用的包的名称。
    *   **Files:** 存储源文件名。
    *   **SymbolDefs, Hashed64Defs, HashedDefs, NonPkgDefs, NonPkgRefs:** 定义不同类型的符号 (包内符号、哈希符号、非包符号的定义和引用)。
    *   **RefFlags:** 存储引用符号的标志。
    *   **Hash64, Hash:** 存储哈希值，用于内容寻址的符号。
    *   **RelocIndex, AuxIndex, DataIndex:**  索引到 `Relocs`, `Aux`, `Data` 数据块。
    *   **Relocs:** 存储重定位信息，用于链接器调整代码和数据地址。
    *   **Aux:** 存储辅助符号信息，例如 Go 类型信息、函数信息和 DWARF 调试信息。
    *   **Data:** 存储符号的数据。
    *   **RefNames:** 存储引用符号的名称。

**2. 提供读取目标文件的功能:**

*   `Reader` 结构体及其方法提供了读取和解析目标文件的能力。
*   `NewReaderFromBytes` 函数可以从字节切片创建一个 `Reader` 实例。
*   `BytesAt`, `uint32At`, `StringAt` 等方法用于从指定偏移量读取原始字节、特定类型的数值和字符串。
*   针对目标文件各个部分的读取方法，例如 `Autolib()`, `Pkglist()`, `Sym()`, `Relocs()`, `Auxs()`, `Data()` 等，方便地访问目标文件中的数据。

**3. 提供写入目标文件的功能:**

*   `Writer` 结构体及其方法提供了创建和写入目标文件的能力。
*   `NewWriter` 函数创建一个新的 `Writer` 实例，它使用 `bio.Writer` 进行底层写入。
*   `AddString`, `StringRef`, `RawString`, `Bytes`, `Uint32` 等方法用于向目标文件写入字符串、字符串引用、原始字节和特定类型的数值。
*   `stringMap` 用于管理已写入的字符串，避免重复写入。

**推断的 Go 语言功能实现及代码示例:**

这个包本身并不直接实现一个特定的 Go 语言功能，而是作为 Go 编译和链接过程的基础设施。它为表示编译后的 Go 代码提供了底层的结构和方法。 但是，可以推断出它支持以下 Go 语言功能的实现：

*   **独立的包编译和链接:** 目标文件格式允许 Go 包被独立编译，然后链接在一起形成最终的可执行文件或库。
*   **代码重定位 (Relocation):** `Relocs` 结构体和相关方法用于存储代码重定位信息。当链接器将不同的目标文件组合在一起时，需要调整代码和数据的地址。

```go
package main

import (
	"cmd/internal/goobj"
	"encoding/binary"
	"fmt"
	"os"
)

func main() {
	// 假设我们有一个已读取的 Go 目标文件的字节切片 objBytes
	// 这里为了演示，我们创建一个简单的 Reloc 结构体并写入到模拟的字节切片中

	reloc := goobj.Reloc{}
	reloc.SetOff(10)          // 重定位发生的偏移量
	reloc.SetSiz(8)           // 重定位的大小 (字节)
	reloc.SetType(1)          // 重定位类型 (例如，指向符号的指针)
	reloc.SetAdd(0)           // 额外的加数
	reloc.SetSym(goobj.SymRef{PkgIdx: goobj.PkgIdxSelf, SymIdx: 0}) // 引用的符号

	relocBytes := make([]byte, goobj.RelocSize)
	binary.LittleEndian.PutUint32(relocBytes[0:], uint32(reloc.Off()))
	relocBytes[4] = reloc.Siz()
	binary.LittleEndian.PutUint16(relocBytes[5:], reloc.Type())
	binary.LittleEndian.PutUint64(relocBytes[7:], uint64(reloc.Add()))
	binary.LittleEndian.PutUint32(relocBytes[15:], reloc.Sym().PkgIdx)
	binary.LittleEndian.PutUint32(relocBytes[19:], reloc.Sym().SymIdx)

	fmt.Printf("Serialized Reloc: %v\n", relocBytes)

	// 假设我们从目标文件中读取到 Reloc 结构体的字节
	readRelocBytes := relocBytes // 使用上面创建的字节切片模拟读取

	readReloc := goobj.Reloc{}
	readReloc.fromBytes(readRelocBytes)

	fmt.Printf("Read Reloc Off: %d\n", readReloc.Off())
	fmt.Printf("Read Reloc Siz: %d\n", readReloc.Siz())
	fmt.Printf("Read Reloc Type: %d\n", readReloc.Type())
	fmt.Printf("Read Reloc Add: %d\n", readReloc.Add())
	fmt.Printf("Read Reloc Sym: %+v\n", readReloc.Sym())
}
```

**假设的输入与输出:**

在这个例子中，我们没有从实际的目标文件读取，而是创建了一个 `Reloc` 结构体并将其序列化为字节切片。然后，我们模拟从目标文件读取了这个字节切片，并将其反序列化回 `Reloc` 结构体。

**输出:**

```
Serialized Reloc: [10 0 0 0 8 1 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0]
Read Reloc Off: 10
Read Reloc Siz: 8
Read Reloc Type: 1
Read Reloc Add: 0
Read Reloc Sym: {PkgIdx:4294967291 SymIdx:0}
```

**命令行参数的具体处理:**

`goobj` 包本身并不直接处理命令行参数。但是，它被 `cmd/asm`, `cmd/compile`, `cmd/link` 等工具使用，这些工具会解析命令行参数。例如：

*   **`cmd/compile`:** 使用 `-o` 参数指定输出目标文件的路径，使用 `-p` 参数指定包的导入路径等等。
*   **`cmd/link`:** 使用 `-o` 参数指定最终可执行文件的路径，使用 `-L` 参数指定库文件的搜索路径等等。

这些工具使用 Go 标准库的 `flag` 包或其他参数解析库来处理命令行参数，然后使用 `goobj` 包来读取和写入目标文件。

**使用者易犯错的点:**

*   **错误地理解符号索引:**  `symRef` 结构体使用 `PkgIdx` 和 `SymIdx` 来引用符号。`PkgIdx` 的值有特殊的含义，例如 `PkgIdxSelf` 表示当前包定义的符号，`PkgIdxHashed` 表示哈希符号，而具体的包索引从 1 开始。使用者可能会错误地认为所有符号都有一个全局唯一的 `SymIdx`，而忽略了 `PkgIdx` 的作用，导致无法正确找到符号。

**示例:**

假设你正在编写一个工具来分析目标文件中的符号。你可能会尝试遍历所有的符号并打印它们的名称：

```go
// 错误的示例，假设 reader 是一个已创建的 goobj.Reader
numSymbols := reader.NSym() // 仅获取当前包的符号
for i := 0; i < numSymbols; i++ {
    sym := reader.Sym(uint32(i))
    fmt.Println(sym.Name(reader))
}

// 这段代码只能打印当前包定义的符号，而忽略了其他类型的符号，例如导入包的符号或哈希符号。
```

为了正确地遍历所有类型的符号，你需要根据 `PkgIdx` 来访问不同的符号表：

```go
// 更完善的示例
numLocalSymbols := reader.NSym()
for i := 0; i < numLocalSymbols; i++ {
    sym := reader.Sym(uint32(i))
    fmt.Printf("Local Symbol: %s\n", sym.Name(reader))
}

numHashed64 := reader.NHashed64def()
for i := 0; i < numHashed64; i++ {
    // 需要根据 PkgIdxHashed64 来处理
    // 无法直接通过索引获取，需要根据哈希值查找
    fmt.Printf("Hashed64 Symbol Index: %d\n", i)
}

// ... 需要类似地处理其他类型的符号
```

因此，理解 `PkgIdx` 的含义以及如何根据它来访问正确的符号表是使用 `goobj` 包时需要注意的关键点。

Prompt: 
```
这是路径为go/src/cmd/internal/goobj/objfile.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，

"""
// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This package defines the Go object file format, and provide "low-level" functions
// for reading and writing object files.

// The object file is understood by the compiler, assembler, linker, and tools. They
// have "high level" code that operates on object files, handling application-specific
// logics, and use this package for the actual reading and writing. Specifically, the
// code below:
//
// - cmd/internal/obj/objfile.go (used by cmd/asm and cmd/compile)
// - cmd/internal/objfile/goobj.go (used cmd/nm, cmd/objdump)
// - cmd/link/internal/loader package (used by cmd/link)
//
// If the object file format changes, they may (or may not) need to change.

package goobj

import (
	"cmd/internal/bio"
	"encoding/binary"
	"errors"
	"fmt"
	"unsafe"
)

// New object file format.
//
//    Header struct {
//       Magic       [...]byte   // "\x00go120ld"
//       Fingerprint [8]byte
//       Flags       uint32
//       Offsets     [...]uint32 // byte offset of each block below
//    }
//
//    Strings [...]struct {
//       Data [...]byte
//    }
//
//    Autolib  [...]struct { // imported packages (for file loading)
//       Pkg         string
//       Fingerprint [8]byte
//    }
//
//    PkgIndex [...]string // referenced packages by index
//
//    Files [...]string
//
//    SymbolDefs [...]struct {
//       Name  string
//       ABI   uint16
//       Type  uint8
//       Flag  uint8
//       Flag2 uint8
//       Size  uint32
//       Align uint32
//    }
//    Hashed64Defs [...]struct { // short hashed (content-addressable) symbol definitions
//       ... // same as SymbolDefs
//    }
//    HashedDefs [...]struct { // hashed (content-addressable) symbol definitions
//       ... // same as SymbolDefs
//    }
//    NonPkgDefs [...]struct { // non-pkg symbol definitions
//       ... // same as SymbolDefs
//    }
//    NonPkgRefs [...]struct { // non-pkg symbol references
//       ... // same as SymbolDefs
//    }
//
//    RefFlags [...]struct { // referenced symbol flags
//       Sym   symRef
//       Flag  uint8
//       Flag2 uint8
//    }
//
//    Hash64 [...][8]byte
//    Hash   [...][N]byte
//
//    RelocIndex [...]uint32 // index to Relocs
//    AuxIndex   [...]uint32 // index to Aux
//    DataIndex  [...]uint32 // offset to Data
//
//    Relocs [...]struct {
//       Off  int32
//       Size uint8
//       Type uint16
//       Add  int64
//       Sym  symRef
//    }
//
//    Aux [...]struct {
//       Type uint8
//       Sym  symRef
//    }
//
//    Data   [...]byte
//
//    // blocks only used by tools (objdump, nm)
//
//    RefNames [...]struct { // referenced symbol names
//       Sym  symRef
//       Name string
//       // TODO: include ABI version as well?
//    }
//
// string is encoded as is a uint32 length followed by a uint32 offset
// that points to the corresponding string bytes.
//
// symRef is struct { PkgIdx, SymIdx uint32 }.
//
// Slice type (e.g. []symRef) is encoded as a length prefix (uint32)
// followed by that number of elements.
//
// The types below correspond to the encoded data structure in the
// object file.

// Symbol indexing.
//
// Each symbol is referenced with a pair of indices, { PkgIdx, SymIdx },
// as the symRef struct above.
//
// PkgIdx is either a predeclared index (see PkgIdxNone below) or
// an index of an imported package. For the latter case, PkgIdx is the
// index of the package in the PkgIndex array. 0 is an invalid index.
//
// SymIdx is the index of the symbol in the given package.
// - If PkgIdx is PkgIdxSelf, SymIdx is the index of the symbol in the
//   SymbolDefs array.
// - If PkgIdx is PkgIdxHashed64, SymIdx is the index of the symbol in the
//   Hashed64Defs array.
// - If PkgIdx is PkgIdxHashed, SymIdx is the index of the symbol in the
//   HashedDefs array.
// - If PkgIdx is PkgIdxNone, SymIdx is the index of the symbol in the
//   NonPkgDefs array (could naturally overflow to NonPkgRefs array).
// - Otherwise, SymIdx is the index of the symbol in some other package's
//   SymbolDefs array.
//
// {0, 0} represents a nil symbol. Otherwise PkgIdx should not be 0.
//
// Hash contains the content hashes of content-addressable symbols, of
// which PkgIdx is PkgIdxHashed, in the same order of HashedDefs array.
// Hash64 is similar, for PkgIdxHashed64 symbols.
//
// RelocIndex, AuxIndex, and DataIndex contains indices/offsets to
// Relocs/Aux/Data blocks, one element per symbol, first for all the
// defined symbols, then all the defined hashed and non-package symbols,
// in the same order of SymbolDefs/Hashed64Defs/HashedDefs/NonPkgDefs
// arrays. For N total defined symbols, the array is of length N+1. The
// last element is the total number of relocations (aux symbols, data
// blocks, etc.).
//
// They can be accessed by index. For the i-th symbol, its relocations
// are the RelocIndex[i]-th (inclusive) to RelocIndex[i+1]-th (exclusive)
// elements in the Relocs array. Aux/Data are likewise. (The index is
// 0-based.)

// Auxiliary symbols.
//
// Each symbol may (or may not) be associated with a number of auxiliary
// symbols. They are described in the Aux block. See Aux struct below.
// Currently a symbol's Gotype, FuncInfo, and associated DWARF symbols
// are auxiliary symbols.

const stringRefSize = 8 // two uint32s

type FingerprintType [8]byte

func (fp FingerprintType) IsZero() bool { return fp == FingerprintType{} }

// Package Index.
const (
	PkgIdxNone     = (1<<31 - 1) - iota // Non-package symbols
	PkgIdxHashed64                      // Short hashed (content-addressable) symbols
	PkgIdxHashed                        // Hashed (content-addressable) symbols
	PkgIdxBuiltin                       // Predefined runtime symbols (ex: runtime.newobject)
	PkgIdxSelf                          // Symbols defined in the current package
	PkgIdxSpecial  = PkgIdxSelf         // Indices above it has special meanings
	PkgIdxInvalid  = 0
	// The index of other referenced packages starts from 1.
)

// Blocks
const (
	BlkAutolib = iota
	BlkPkgIdx
	BlkFile
	BlkSymdef
	BlkHashed64def
	BlkHasheddef
	BlkNonpkgdef
	BlkNonpkgref
	BlkRefFlags
	BlkHash64
	BlkHash
	BlkRelocIdx
	BlkAuxIdx
	BlkDataIdx
	BlkReloc
	BlkAux
	BlkData
	BlkRefName
	BlkEnd
	NBlk
)

// File header.
// TODO: probably no need to export this.
type Header struct {
	Magic       string
	Fingerprint FingerprintType
	Flags       uint32
	Offsets     [NBlk]uint32
}

const Magic = "\x00go120ld"

func (h *Header) Write(w *Writer) {
	w.RawString(h.Magic)
	w.Bytes(h.Fingerprint[:])
	w.Uint32(h.Flags)
	for _, x := range h.Offsets {
		w.Uint32(x)
	}
}

func (h *Header) Read(r *Reader) error {
	b := r.BytesAt(0, len(Magic))
	h.Magic = string(b)
	if h.Magic != Magic {
		return errors.New("wrong magic, not a Go object file")
	}
	off := uint32(len(h.Magic))
	copy(h.Fingerprint[:], r.BytesAt(off, len(h.Fingerprint)))
	off += 8
	h.Flags = r.uint32At(off)
	off += 4
	for i := range h.Offsets {
		h.Offsets[i] = r.uint32At(off)
		off += 4
	}
	return nil
}

func (h *Header) Size() int {
	return len(h.Magic) + len(h.Fingerprint) + 4 + 4*len(h.Offsets)
}

// Autolib
type ImportedPkg struct {
	Pkg         string
	Fingerprint FingerprintType
}

const importedPkgSize = stringRefSize + 8

func (p *ImportedPkg) Write(w *Writer) {
	w.StringRef(p.Pkg)
	w.Bytes(p.Fingerprint[:])
}

// Symbol definition.
//
// Serialized format:
//
//	Sym struct {
//	   Name  string
//	   ABI   uint16
//	   Type  uint8
//	   Flag  uint8
//	   Flag2 uint8
//	   Siz   uint32
//	   Align uint32
//	}
type Sym [SymSize]byte

const SymSize = stringRefSize + 2 + 1 + 1 + 1 + 4 + 4

const SymABIstatic = ^uint16(0)

const (
	ObjFlagShared       = 1 << iota // this object is built with -shared
	_                               // was ObjFlagNeedNameExpansion
	ObjFlagFromAssembly             // object is from asm src, not go
	ObjFlagUnlinkable               // unlinkable package (linker will emit an error)
	ObjFlagStd                      // standard library package
)

// Sym.Flag
const (
	SymFlagDupok = 1 << iota
	SymFlagLocal
	SymFlagTypelink
	SymFlagLeaf
	SymFlagNoSplit
	SymFlagReflectMethod
	SymFlagGoType
)

// Sym.Flag2
const (
	SymFlagUsedInIface = 1 << iota
	SymFlagItab
	SymFlagDict
	SymFlagPkgInit
	SymFlagLinkname
	SymFlagABIWrapper
	SymFlagWasmExport
)

// Returns the length of the name of the symbol.
func (s *Sym) NameLen(r *Reader) int {
	return int(binary.LittleEndian.Uint32(s[:]))
}

func (s *Sym) Name(r *Reader) string {
	len := binary.LittleEndian.Uint32(s[:])
	off := binary.LittleEndian.Uint32(s[4:])
	return r.StringAt(off, len)
}

func (s *Sym) ABI() uint16   { return binary.LittleEndian.Uint16(s[8:]) }
func (s *Sym) Type() uint8   { return s[10] }
func (s *Sym) Flag() uint8   { return s[11] }
func (s *Sym) Flag2() uint8  { return s[12] }
func (s *Sym) Siz() uint32   { return binary.LittleEndian.Uint32(s[13:]) }
func (s *Sym) Align() uint32 { return binary.LittleEndian.Uint32(s[17:]) }

func (s *Sym) Dupok() bool         { return s.Flag()&SymFlagDupok != 0 }
func (s *Sym) Local() bool         { return s.Flag()&SymFlagLocal != 0 }
func (s *Sym) Typelink() bool      { return s.Flag()&SymFlagTypelink != 0 }
func (s *Sym) Leaf() bool          { return s.Flag()&SymFlagLeaf != 0 }
func (s *Sym) NoSplit() bool       { return s.Flag()&SymFlagNoSplit != 0 }
func (s *Sym) ReflectMethod() bool { return s.Flag()&SymFlagReflectMethod != 0 }
func (s *Sym) IsGoType() bool      { return s.Flag()&SymFlagGoType != 0 }
func (s *Sym) UsedInIface() bool   { return s.Flag2()&SymFlagUsedInIface != 0 }
func (s *Sym) IsItab() bool        { return s.Flag2()&SymFlagItab != 0 }
func (s *Sym) IsDict() bool        { return s.Flag2()&SymFlagDict != 0 }
func (s *Sym) IsPkgInit() bool     { return s.Flag2()&SymFlagPkgInit != 0 }
func (s *Sym) IsLinkname() bool    { return s.Flag2()&SymFlagLinkname != 0 }
func (s *Sym) ABIWrapper() bool    { return s.Flag2()&SymFlagABIWrapper != 0 }
func (s *Sym) WasmExport() bool    { return s.Flag2()&SymFlagWasmExport != 0 }

func (s *Sym) SetName(x string, w *Writer) {
	binary.LittleEndian.PutUint32(s[:], uint32(len(x)))
	binary.LittleEndian.PutUint32(s[4:], w.stringOff(x))
}

func (s *Sym) SetABI(x uint16)   { binary.LittleEndian.PutUint16(s[8:], x) }
func (s *Sym) SetType(x uint8)   { s[10] = x }
func (s *Sym) SetFlag(x uint8)   { s[11] = x }
func (s *Sym) SetFlag2(x uint8)  { s[12] = x }
func (s *Sym) SetSiz(x uint32)   { binary.LittleEndian.PutUint32(s[13:], x) }
func (s *Sym) SetAlign(x uint32) { binary.LittleEndian.PutUint32(s[17:], x) }

func (s *Sym) Write(w *Writer) { w.Bytes(s[:]) }

// for testing
func (s *Sym) fromBytes(b []byte) { copy(s[:], b) }

// Symbol reference.
type SymRef struct {
	PkgIdx uint32
	SymIdx uint32
}

func (s SymRef) IsZero() bool { return s == SymRef{} }

// Hash64
type Hash64Type [Hash64Size]byte

const Hash64Size = 8

// Hash
type HashType [HashSize]byte

const HashSize = 16 // truncated SHA256

// Relocation.
//
// Serialized format:
//
//	Reloc struct {
//	   Off  int32
//	   Siz  uint8
//	   Type uint16
//	   Add  int64
//	   Sym  SymRef
//	}
type Reloc [RelocSize]byte

const RelocSize = 4 + 1 + 2 + 8 + 8

func (r *Reloc) Off() int32   { return int32(binary.LittleEndian.Uint32(r[:])) }
func (r *Reloc) Siz() uint8   { return r[4] }
func (r *Reloc) Type() uint16 { return binary.LittleEndian.Uint16(r[5:]) }
func (r *Reloc) Add() int64   { return int64(binary.LittleEndian.Uint64(r[7:])) }
func (r *Reloc) Sym() SymRef {
	return SymRef{binary.LittleEndian.Uint32(r[15:]), binary.LittleEndian.Uint32(r[19:])}
}

func (r *Reloc) SetOff(x int32)   { binary.LittleEndian.PutUint32(r[:], uint32(x)) }
func (r *Reloc) SetSiz(x uint8)   { r[4] = x }
func (r *Reloc) SetType(x uint16) { binary.LittleEndian.PutUint16(r[5:], x) }
func (r *Reloc) SetAdd(x int64)   { binary.LittleEndian.PutUint64(r[7:], uint64(x)) }
func (r *Reloc) SetSym(x SymRef) {
	binary.LittleEndian.PutUint32(r[15:], x.PkgIdx)
	binary.LittleEndian.PutUint32(r[19:], x.SymIdx)
}

func (r *Reloc) Set(off int32, size uint8, typ uint16, add int64, sym SymRef) {
	r.SetOff(off)
	r.SetSiz(size)
	r.SetType(typ)
	r.SetAdd(add)
	r.SetSym(sym)
}

func (r *Reloc) Write(w *Writer) { w.Bytes(r[:]) }

// for testing
func (r *Reloc) fromBytes(b []byte) { copy(r[:], b) }

// Aux symbol info.
//
// Serialized format:
//
//	Aux struct {
//	   Type uint8
//	   Sym  SymRef
//	}
type Aux [AuxSize]byte

const AuxSize = 1 + 8

// Aux Type
const (
	AuxGotype = iota
	AuxFuncInfo
	AuxFuncdata
	AuxDwarfInfo
	AuxDwarfLoc
	AuxDwarfRanges
	AuxDwarfLines
	AuxPcsp
	AuxPcfile
	AuxPcline
	AuxPcinline
	AuxPcdata
	AuxWasmImport
	AuxWasmType
	AuxSehUnwindInfo
)

func (a *Aux) Type() uint8 { return a[0] }
func (a *Aux) Sym() SymRef {
	return SymRef{binary.LittleEndian.Uint32(a[1:]), binary.LittleEndian.Uint32(a[5:])}
}

func (a *Aux) SetType(x uint8) { a[0] = x }
func (a *Aux) SetSym(x SymRef) {
	binary.LittleEndian.PutUint32(a[1:], x.PkgIdx)
	binary.LittleEndian.PutUint32(a[5:], x.SymIdx)
}

func (a *Aux) Write(w *Writer) { w.Bytes(a[:]) }

// for testing
func (a *Aux) fromBytes(b []byte) { copy(a[:], b) }

// Referenced symbol flags.
//
// Serialized format:
//
//	RefFlags struct {
//	   Sym   symRef
//	   Flag  uint8
//	   Flag2 uint8
//	}
type RefFlags [RefFlagsSize]byte

const RefFlagsSize = 8 + 1 + 1

func (r *RefFlags) Sym() SymRef {
	return SymRef{binary.LittleEndian.Uint32(r[:]), binary.LittleEndian.Uint32(r[4:])}
}
func (r *RefFlags) Flag() uint8  { return r[8] }
func (r *RefFlags) Flag2() uint8 { return r[9] }

func (r *RefFlags) SetSym(x SymRef) {
	binary.LittleEndian.PutUint32(r[:], x.PkgIdx)
	binary.LittleEndian.PutUint32(r[4:], x.SymIdx)
}
func (r *RefFlags) SetFlag(x uint8)  { r[8] = x }
func (r *RefFlags) SetFlag2(x uint8) { r[9] = x }

func (r *RefFlags) Write(w *Writer) { w.Bytes(r[:]) }

// Used to construct an artificially large array type when reading an
// item from the object file relocs section or aux sym section (needs
// to work on 32-bit as well as 64-bit). See issue 41621.
const huge = (1<<31 - 1) / RelocSize

// Referenced symbol name.
//
// Serialized format:
//
//	RefName struct {
//	   Sym  symRef
//	   Name string
//	}
type RefName [RefNameSize]byte

const RefNameSize = 8 + stringRefSize

func (n *RefName) Sym() SymRef {
	return SymRef{binary.LittleEndian.Uint32(n[:]), binary.LittleEndian.Uint32(n[4:])}
}
func (n *RefName) Name(r *Reader) string {
	len := binary.LittleEndian.Uint32(n[8:])
	off := binary.LittleEndian.Uint32(n[12:])
	return r.StringAt(off, len)
}

func (n *RefName) SetSym(x SymRef) {
	binary.LittleEndian.PutUint32(n[:], x.PkgIdx)
	binary.LittleEndian.PutUint32(n[4:], x.SymIdx)
}
func (n *RefName) SetName(x string, w *Writer) {
	binary.LittleEndian.PutUint32(n[8:], uint32(len(x)))
	binary.LittleEndian.PutUint32(n[12:], w.stringOff(x))
}

func (n *RefName) Write(w *Writer) { w.Bytes(n[:]) }

type Writer struct {
	wr        *bio.Writer
	stringMap map[string]uint32
	off       uint32 // running offset

	b [8]byte // scratch space for writing bytes
}

func NewWriter(wr *bio.Writer) *Writer {
	return &Writer{wr: wr, stringMap: make(map[string]uint32)}
}

func (w *Writer) AddString(s string) {
	if _, ok := w.stringMap[s]; ok {
		return
	}
	w.stringMap[s] = w.off
	w.RawString(s)
}

func (w *Writer) stringOff(s string) uint32 {
	off, ok := w.stringMap[s]
	if !ok {
		panic(fmt.Sprintf("writeStringRef: string not added: %q", s))
	}
	return off
}

func (w *Writer) StringRef(s string) {
	w.Uint32(uint32(len(s)))
	w.Uint32(w.stringOff(s))
}

func (w *Writer) RawString(s string) {
	w.wr.WriteString(s)
	w.off += uint32(len(s))
}

func (w *Writer) Bytes(s []byte) {
	w.wr.Write(s)
	w.off += uint32(len(s))
}

func (w *Writer) Uint64(x uint64) {
	binary.LittleEndian.PutUint64(w.b[:], x)
	w.wr.Write(w.b[:])
	w.off += 8
}

func (w *Writer) Uint32(x uint32) {
	binary.LittleEndian.PutUint32(w.b[:4], x)
	w.wr.Write(w.b[:4])
	w.off += 4
}

func (w *Writer) Uint16(x uint16) {
	binary.LittleEndian.PutUint16(w.b[:2], x)
	w.wr.Write(w.b[:2])
	w.off += 2
}

func (w *Writer) Uint8(x uint8) {
	w.wr.WriteByte(x)
	w.off++
}

func (w *Writer) Offset() uint32 {
	return w.off
}

type Reader struct {
	b        []byte // mmapped bytes, if not nil
	readonly bool   // whether b is backed with read-only memory

	start uint32
	h     Header // keep block offsets
}

func NewReaderFromBytes(b []byte, readonly bool) *Reader {
	r := &Reader{b: b, readonly: readonly, start: 0}
	err := r.h.Read(r)
	if err != nil {
		return nil
	}
	return r
}

func (r *Reader) BytesAt(off uint32, len int) []byte {
	if len == 0 {
		return nil
	}
	end := int(off) + len
	return r.b[int(off):end:end]
}

func (r *Reader) uint64At(off uint32) uint64 {
	b := r.BytesAt(off, 8)
	return binary.LittleEndian.Uint64(b)
}

func (r *Reader) int64At(off uint32) int64 {
	return int64(r.uint64At(off))
}

func (r *Reader) uint32At(off uint32) uint32 {
	b := r.BytesAt(off, 4)
	return binary.LittleEndian.Uint32(b)
}

func (r *Reader) int32At(off uint32) int32 {
	return int32(r.uint32At(off))
}

func (r *Reader) uint16At(off uint32) uint16 {
	b := r.BytesAt(off, 2)
	return binary.LittleEndian.Uint16(b)
}

func (r *Reader) uint8At(off uint32) uint8 {
	b := r.BytesAt(off, 1)
	return b[0]
}

func (r *Reader) StringAt(off uint32, len uint32) string {
	b := r.b[off : off+len]
	if r.readonly {
		return toString(b) // backed by RO memory, ok to make unsafe string
	}
	return string(b)
}

func toString(b []byte) string {
	if len(b) == 0 {
		return ""
	}
	return unsafe.String(&b[0], len(b))
}

func (r *Reader) StringRef(off uint32) string {
	l := r.uint32At(off)
	return r.StringAt(r.uint32At(off+4), l)
}

func (r *Reader) Fingerprint() FingerprintType {
	return r.h.Fingerprint
}

func (r *Reader) Autolib() []ImportedPkg {
	n := (r.h.Offsets[BlkAutolib+1] - r.h.Offsets[BlkAutolib]) / importedPkgSize
	s := make([]ImportedPkg, n)
	off := r.h.Offsets[BlkAutolib]
	for i := range s {
		s[i].Pkg = r.StringRef(off)
		copy(s[i].Fingerprint[:], r.BytesAt(off+stringRefSize, len(s[i].Fingerprint)))
		off += importedPkgSize
	}
	return s
}

func (r *Reader) Pkglist() []string {
	n := (r.h.Offsets[BlkPkgIdx+1] - r.h.Offsets[BlkPkgIdx]) / stringRefSize
	s := make([]string, n)
	off := r.h.Offsets[BlkPkgIdx]
	for i := range s {
		s[i] = r.StringRef(off)
		off += stringRefSize
	}
	return s
}

func (r *Reader) NPkg() int {
	return int(r.h.Offsets[BlkPkgIdx+1]-r.h.Offsets[BlkPkgIdx]) / stringRefSize
}

func (r *Reader) Pkg(i int) string {
	off := r.h.Offsets[BlkPkgIdx] + uint32(i)*stringRefSize
	return r.StringRef(off)
}

func (r *Reader) NFile() int {
	return int(r.h.Offsets[BlkFile+1]-r.h.Offsets[BlkFile]) / stringRefSize
}

func (r *Reader) File(i int) string {
	off := r.h.Offsets[BlkFile] + uint32(i)*stringRefSize
	return r.StringRef(off)
}

func (r *Reader) NSym() int {
	return int(r.h.Offsets[BlkSymdef+1]-r.h.Offsets[BlkSymdef]) / SymSize
}

func (r *Reader) NHashed64def() int {
	return int(r.h.Offsets[BlkHashed64def+1]-r.h.Offsets[BlkHashed64def]) / SymSize
}

func (r *Reader) NHasheddef() int {
	return int(r.h.Offsets[BlkHasheddef+1]-r.h.Offsets[BlkHasheddef]) / SymSize
}

func (r *Reader) NNonpkgdef() int {
	return int(r.h.Offsets[BlkNonpkgdef+1]-r.h.Offsets[BlkNonpkgdef]) / SymSize
}

func (r *Reader) NNonpkgref() int {
	return int(r.h.Offsets[BlkNonpkgref+1]-r.h.Offsets[BlkNonpkgref]) / SymSize
}

// SymOff returns the offset of the i-th symbol.
func (r *Reader) SymOff(i uint32) uint32 {
	return r.h.Offsets[BlkSymdef] + uint32(i*SymSize)
}

// Sym returns a pointer to the i-th symbol.
func (r *Reader) Sym(i uint32) *Sym {
	off := r.SymOff(i)
	return (*Sym)(unsafe.Pointer(&r.b[off]))
}

// NRefFlags returns the number of referenced symbol flags.
func (r *Reader) NRefFlags() int {
	return int(r.h.Offsets[BlkRefFlags+1]-r.h.Offsets[BlkRefFlags]) / RefFlagsSize
}

// RefFlags returns a pointer to the i-th referenced symbol flags.
// Note: here i is not a local symbol index, just a counter.
func (r *Reader) RefFlags(i int) *RefFlags {
	off := r.h.Offsets[BlkRefFlags] + uint32(i*RefFlagsSize)
	return (*RefFlags)(unsafe.Pointer(&r.b[off]))
}

// Hash64 returns the i-th short hashed symbol's hash.
// Note: here i is the index of short hashed symbols, not all symbols
// (unlike other accessors).
func (r *Reader) Hash64(i uint32) uint64 {
	off := r.h.Offsets[BlkHash64] + uint32(i*Hash64Size)
	return r.uint64At(off)
}

// Hash returns a pointer to the i-th hashed symbol's hash.
// Note: here i is the index of hashed symbols, not all symbols
// (unlike other accessors).
func (r *Reader) Hash(i uint32) *HashType {
	off := r.h.Offsets[BlkHash] + uint32(i*HashSize)
	return (*HashType)(unsafe.Pointer(&r.b[off]))
}

// NReloc returns the number of relocations of the i-th symbol.
func (r *Reader) NReloc(i uint32) int {
	relocIdxOff := r.h.Offsets[BlkRelocIdx] + uint32(i*4)
	return int(r.uint32At(relocIdxOff+4) - r.uint32At(relocIdxOff))
}

// RelocOff returns the offset of the j-th relocation of the i-th symbol.
func (r *Reader) RelocOff(i uint32, j int) uint32 {
	relocIdxOff := r.h.Offsets[BlkRelocIdx] + uint32(i*4)
	relocIdx := r.uint32At(relocIdxOff)
	return r.h.Offsets[BlkReloc] + (relocIdx+uint32(j))*uint32(RelocSize)
}

// Reloc returns a pointer to the j-th relocation of the i-th symbol.
func (r *Reader) Reloc(i uint32, j int) *Reloc {
	off := r.RelocOff(i, j)
	return (*Reloc)(unsafe.Pointer(&r.b[off]))
}

// Relocs returns a pointer to the relocations of the i-th symbol.
func (r *Reader) Relocs(i uint32) []Reloc {
	off := r.RelocOff(i, 0)
	n := r.NReloc(i)
	return (*[huge]Reloc)(unsafe.Pointer(&r.b[off]))[:n:n]
}

// NAux returns the number of aux symbols of the i-th symbol.
func (r *Reader) NAux(i uint32) int {
	auxIdxOff := r.h.Offsets[BlkAuxIdx] + i*4
	return int(r.uint32At(auxIdxOff+4) - r.uint32At(auxIdxOff))
}

// AuxOff returns the offset of the j-th aux symbol of the i-th symbol.
func (r *Reader) AuxOff(i uint32, j int) uint32 {
	auxIdxOff := r.h.Offsets[BlkAuxIdx] + i*4
	auxIdx := r.uint32At(auxIdxOff)
	return r.h.Offsets[BlkAux] + (auxIdx+uint32(j))*uint32(AuxSize)
}

// Aux returns a pointer to the j-th aux symbol of the i-th symbol.
func (r *Reader) Aux(i uint32, j int) *Aux {
	off := r.AuxOff(i, j)
	return (*Aux)(unsafe.Pointer(&r.b[off]))
}

// Auxs returns the aux symbols of the i-th symbol.
func (r *Reader) Auxs(i uint32) []Aux {
	off := r.AuxOff(i, 0)
	n := r.NAux(i)
	return (*[huge]Aux)(unsafe.Pointer(&r.b[off]))[:n:n]
}

// DataOff returns the offset of the i-th symbol's data.
func (r *Reader) DataOff(i uint32) uint32 {
	dataIdxOff := r.h.Offsets[BlkDataIdx] + i*4
	return r.h.Offsets[BlkData] + r.uint32At(dataIdxOff)
}

// DataSize returns the size of the i-th symbol's data.
func (r *Reader) DataSize(i uint32) int {
	dataIdxOff := r.h.Offsets[BlkDataIdx] + i*4
	return int(r.uint32At(dataIdxOff+4) - r.uint32At(dataIdxOff))
}

// Data returns the i-th symbol's data.
func (r *Reader) Data(i uint32) []byte {
	dataIdxOff := r.h.Offsets[BlkDataIdx] + i*4
	base := r.h.Offsets[BlkData]
	off := r.uint32At(dataIdxOff)
	end := r.uint32At(dataIdxOff + 4)
	return r.BytesAt(base+off, int(end-off))
}

// DataString returns the i-th symbol's data as a string.
func (r *Reader) DataString(i uint32) string {
	dataIdxOff := r.h.Offsets[BlkDataIdx] + i*4
	base := r.h.Offsets[BlkData]
	off := r.uint32At(dataIdxOff)
	end := r.uint32At(dataIdxOff + 4)
	return r.StringAt(base+off, end-off)
}

// NRefName returns the number of referenced symbol names.
func (r *Reader) NRefName() int {
	return int(r.h.Offsets[BlkRefName+1]-r.h.Offsets[BlkRefName]) / RefNameSize
}

// RefName returns a pointer to the i-th referenced symbol name.
// Note: here i is not a local symbol index, just a counter.
func (r *Reader) RefName(i int) *RefName {
	off := r.h.Offsets[BlkRefName] + uint32(i*RefNameSize)
	return (*RefName)(unsafe.Pointer(&r.b[off]))
}

// ReadOnly returns whether r.BytesAt returns read-only bytes.
func (r *Reader) ReadOnly() bool {
	return r.readonly
}

// Flags returns the flag bits read from the object file header.
func (r *Reader) Flags() uint32 {
	return r.h.Flags
}

func (r *Reader) Shared() bool       { return r.Flags()&ObjFlagShared != 0 }
func (r *Reader) FromAssembly() bool { return r.Flags()&ObjFlagFromAssembly != 0 }
func (r *Reader) Unlinkable() bool   { return r.Flags()&ObjFlagUnlinkable != 0 }
func (r *Reader) Std() bool          { return r.Flags()&ObjFlagStd != 0 }

"""



```
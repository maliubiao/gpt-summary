Response: The user wants to understand the functionality of the provided Go code snippet. This file seems to be part of the Go assembler for the s390x architecture.

Here's a breakdown of the thought process to answer the request:

1. **Identify the Core Purpose:** The initial comment `// Based on cmd/internal/obj/ppc64/asm9.go.` and the package name `s390x` strongly suggest this code is related to assembly for the s390x architecture within the Go compiler toolchain.

2. **Analyze Key Structures:**
    * `ctxtz`: This struct likely holds the context for assembling a single function. The fields suggest it manages the link to the object linker (`*obj.Link`), program allocation (`obj.ProgAlloc`), the current symbol being assembled (`*obj.LSym`), auto variable size (`autosize`), instruction offset (`instoffset`), and program counter (`pc`).
    * `Optab`: This struct clearly defines the structure of an opcode table entry. It includes fields for the assembly opcode (`obj.As`), a handler index (`i`), and argument types (`a1` to `a6`).
    * `optab`: This is a global variable of type `[]Optab`, which is initialized with various assembly instructions and their corresponding operand types. This is the core of the instruction set definition.

3. **Focus on Key Functions:**
    * `spanz`: This function seems crucial. The comments and the loop structure suggest it's responsible for calculating the size and layout of instructions within a function. The name "span" often implies calculating the extent or range of something. The loop with the `changed` flag hints at a process that might iterate until a stable instruction layout is achieved.
    * `aclass`: This function takes an `obj.Addr` and returns an integer representing the "class" of the address. This likely categorizes different types of operands (register, memory, constant, etc.).
    * `oplook`: This function takes a `obj.Prog` (likely representing a single assembly instruction) and tries to find a matching entry in the `optab`. It uses `aclass` to determine the classes of the operands in the instruction.
    * `buildop`: This function initializes the `oprange` array. The comments indicate it handles cases where the arch is re-initialized, which is relevant in testing scenarios. The logic within the function, especially the `opset` calls, suggests it's grouping similar instructions together for efficient lookup.

4. **Infer Functionality based on Structures and Functions:**
    * **Instruction Encoding:** The `optab` and the functions that use it (`oplook`, `buildop`) strongly indicate that this code is responsible for mapping Go assembly instructions to their binary representations for the s390x architecture. The `Optab` struct defines the valid combinations of operands for each instruction.
    * **Operand Classification:** The `aclass` function suggests that the assembler needs to classify operands to determine the correct instruction encoding. Different operand types (registers, immediate values, memory addresses) will have different encoding requirements.
    * **Code Layout and Size Calculation:** The `spanz` function is responsible for determining the size of the generated machine code for a function. This involves iterating through the assembly instructions and calculating the required bytes for each one.

5. **Formulate the Functional Summary:** Based on the analysis, the main functionalities are:
    * Defining the s390x instruction set and their valid operand types.
    * Classifying operands of assembly instructions.
    * Determining the machine code size and layout for functions.

6. **Consider Go Language Feature Implementation (Inference):**  Given that this is part of the `cmd/internal/obj` package, it's highly likely that this code is part of the **assembler** within the Go toolchain. The assembler takes the assembly code generated by the compiler and translates it into machine code.

7. **Provide a Go Code Example (Conceptual):**  Since this is low-level assembler code, a direct Go code example demonstrating its usage isn't feasible for a typical Go developer. However, a conceptual example can be given to illustrate the *purpose* of this code: taking assembly instructions and producing machine code.

8. **Address Potential User Errors (Based on the Code):**  The code itself doesn't directly expose APIs to end-users. Potential errors would be in *contributing* to the Go compiler or writing assembly directly. The `oplook` function's error handling ("illegal combination") hints at a potential issue if an invalid instruction or operand combination is encountered.

9. **Review and Refine:** Ensure the explanation is clear, concise, and accurately reflects the code's purpose.

This thought process allowed for a detailed understanding of the code's function without needing to deeply analyze every line. The key was to identify the core components and their interactions.
好的，让我们分析一下 `go/src/cmd/internal/obj/s390x/asmz.go` 这部分代码的功能。

**功能归纳:**

这段 Go 代码是 Go 编译器中 **s390x 架构的汇编器** 的一部分。它的主要功能是：

1. **定义和管理汇编过程中的上下文信息:**  `ctxtz` 结构体用于存储汇编单个函数时的状态，例如链接上下文、程序分配器、当前符号、自动变量大小、指令偏移和程序计数器等。这使得可以安全地并发汇编多个函数。

2. **定义 s390x 指令集的操作码表 (Opcode Table):** `Optab` 结构体定义了指令的格式，包括操作码 (`as`)、处理函数索引 (`i`) 以及操作数的类型 (`a1` 到 `a6`)。全局变量 `optab` 是一个 `Optab` 类型的切片，它列出了 s390x 架构支持的各种汇编指令及其允许的操作数类型组合。

3. **将汇编指令和操作数类型映射到具体的处理逻辑:** `oprange` 是一个二维切片，用于根据操作码快速查找对应的 `Optab` 条目。 `buildop` 函数负责初始化 `oprange`，它会根据 `optab` 中的信息进行组织，方便后续的指令查找和处理。

4. **确定指令的长度和布局 (Spanning):** `spanz` 函数负责计算函数中每条指令的长度，并确定它们在最终机器码中的位置。它通过循环迭代，直到指令的布局稳定为止。

5. **对操作数进行分类:** `aclass` 函数用于判断汇编指令操作数的类型（例如，寄存器、内存地址、常量等），返回一个表示操作数类别的常量。

6. **查找与汇编指令匹配的操作码表条目:** `oplook` 函数根据给定的汇编指令 (`obj.Prog`) 和其操作数的类型，在 `oprange` 中查找匹配的 `Optab` 条目。

7. **标记不安全的代码点:**  `isUnsafePoint` 函数用于判断某个指令是否是不安全的，例如使用了临时寄存器 `REGTMP`，这在进行函数调用注入时需要考虑。

**可以推理出的 Go 语言功能的实现:**

这段代码是 Go 编译器将 **汇编语言指令转换为机器码** 的核心部分。  它处理了以下关键步骤：

1. **解析汇编指令:**  编译器会将 Go 源代码编译成一种中间表示，其中一部分是与目标架构相关的汇编指令。

2. **操作数分析:**  对于每个汇编指令，都需要分析其操作数的类型和值。

3. **指令编码:**  根据指令的操作码和操作数类型，查找对应的机器码表示。

4. **布局和地址计算:**  确定每条指令在内存中的位置，并处理跳转指令的目标地址等。

**Go 代码举例说明 (概念性):**

虽然这段代码本身不直接被用户代码调用，但可以从概念上理解其作用。假设我们有以下 Go 代码：

```go
package main

func add(a, b int) int {
	return a + b
}

func main() {
	result := add(5, 3)
	println(result)
}
```

Go 编译器在编译 `add` 函数时，可能会生成类似于以下的 s390x 汇编指令 (简化表示)：

```assembly
TEXT    "".add(SB), NOSPLIT, $0-24
        MOVD    a+0(FP), R1  // 将参数 a 加载到寄存器 R1
        MOVD    b+8(FP), R2  // 将参数 b 加载到寄存器 R2
        ADD     R1, R2       // 将 R1 和 R2 的值相加，结果存储在 R1
        MOVD    R1, ret+16(FP) // 将结果存储到返回值的位置
        RET
```

`asmz.go` 中的代码会处理这些汇编指令，例如：

* 对于 `MOVD a+0(FP), R1`，`aclass` 会分析 `a+0(FP)` 和 `R1` 的类型，分别为 `C_LAUTO` (局部变量) 和 `C_REG` (通用寄存器)。 `oplook` 会在 `optab` 中查找匹配 `AMOVD` 指令和 `C_LAUTO` -> `C_REG` 操作数类型的条目。

* 对于 `ADD R1, R2`，`aclass` 会分析 `R1` 和 `R2` 的类型，均为 `C_REG`。 `oplook` 会查找匹配 `AADD` 指令和 `C_REG`, `C_REG` 操作数类型的条目。

`spanz` 函数会计算每条指令的长度，例如 `MOVD` 和 `ADD` 指令在 s390x 架构上的编码长度。最终生成 `add` 函数的机器码。

**假设的输入与输出 (`spanz` 函数):**

**假设输入:**  `spanz` 函数接收一个代表 `add` 函数的符号信息 (`cursym`)，其中包含了汇编指令序列。

**假设输出:** `spanz` 函数会更新 `cursym` 的信息，包括：

* `cursym.Size`:  计算出的 `add` 函数的机器码大小 (例如，假设是 12 字节)。
* `cursym.P`:  一个字节切片，包含 `add` 函数的实际机器码。
* 每个汇编指令 `p.Pc`:  指令在函数机器码中的偏移量。

**命令行参数的具体处理:**

这段代码本身不直接处理命令行参数。命令行参数的处理通常发生在 `cmd/compile` 包或其他更上层的工具中。但是，编译器的命令行参数可能会影响到汇编过程，例如，优化级别可能会导致生成不同的汇编指令序列。

**易犯错的点 (开发者维护此代码时):**

在 `asmz.go` 中维护 `optab` 是一个容易出错的地方。

* **指令格式定义错误:** 如果 `Optab` 中的 `a1` 到 `a6` 定义不正确，会导致指令无法正确匹配或生成错误的机器码。例如，如果将一个只接受立即数的指令定义为可以接受寄存器，就会出错。

* **操作码索引错误:** `i` 字段是处理函数的索引，如果索引错误，会导致指令执行错误的逻辑。

* **遗漏新的指令或操作数类型:** 当 s390x 架构引入新的指令或操作数类型时，需要在 `optab` 中添加相应的条目，并更新相关的处理逻辑。如果遗漏，编译器将无法处理这些新的指令。

总而言之，`go/src/cmd/internal/obj/s390x/asmz.go` 是 Go 编译器中负责将 s390x 架构的汇编指令转换为机器码的关键组成部分，它定义了指令集、操作数类型，并实现了指令编码和布局的功能。

Prompt: 
```
这是路径为go/src/cmd/internal/obj/s390x/asmz.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，
这是第1部分，共3部分，请归纳一下它的功能

"""
// Based on cmd/internal/obj/ppc64/asm9.go.
//
//    Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
//    Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
//    Portions Copyright © 1997-1999 Vita Nuova Limited
//    Portions Copyright © 2000-2008 Vita Nuova Holdings Limited (www.vitanuova.com)
//    Portions Copyright © 2004,2006 Bruce Ellis
//    Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
//    Revisions Copyright © 2000-2008 Lucent Technologies Inc. and others
//    Portions Copyright © 2009 The Go Authors. All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package s390x

import (
	"cmd/internal/obj"
	"cmd/internal/objabi"
	"fmt"
	"log"
	"math"
	"slices"
)

// ctxtz holds state while assembling a single function.
// Each function gets a fresh ctxtz.
// This allows for multiple functions to be safely concurrently assembled.
type ctxtz struct {
	ctxt       *obj.Link
	newprog    obj.ProgAlloc
	cursym     *obj.LSym
	autosize   int32
	instoffset int64
	pc         int64
}

// instruction layout.
const (
	funcAlign = 16
)

type Optab struct {
	as obj.As // opcode
	i  uint8  // handler index
	a1 uint8  // From
	a2 uint8  // Reg
	a3 uint8  // RestArgs[0]
	a4 uint8  // RestArgs[1]
	a5 uint8  // RestArgs[2]
	a6 uint8  // To
}

var optab = []Optab{
	// zero-length instructions
	{i: 0, as: obj.ATEXT, a1: C_ADDR, a6: C_TEXTSIZE},
	{i: 0, as: obj.ATEXT, a1: C_ADDR, a3: C_LCON, a6: C_TEXTSIZE},
	{i: 0, as: obj.APCDATA, a1: C_LCON, a6: C_LCON},
	{i: 0, as: obj.AFUNCDATA, a1: C_SCON, a6: C_ADDR},
	{i: 0, as: obj.ANOP},
	{i: 0, as: obj.ANOP, a1: C_SAUTO},

	// move register
	{i: 1, as: AMOVD, a1: C_REG, a6: C_REG},
	{i: 1, as: AMOVB, a1: C_REG, a6: C_REG},
	{i: 1, as: AMOVBZ, a1: C_REG, a6: C_REG},
	{i: 1, as: AMOVW, a1: C_REG, a6: C_REG},
	{i: 1, as: AMOVWZ, a1: C_REG, a6: C_REG},
	{i: 1, as: AFMOVD, a1: C_FREG, a6: C_FREG},
	{i: 1, as: AMOVDBR, a1: C_REG, a6: C_REG},

	// load constant
	{i: 26, as: AMOVD, a1: C_LACON, a6: C_REG},
	{i: 26, as: AMOVW, a1: C_LACON, a6: C_REG},
	{i: 26, as: AMOVWZ, a1: C_LACON, a6: C_REG},
	{i: 3, as: AMOVD, a1: C_DCON, a6: C_REG},
	{i: 3, as: AMOVW, a1: C_DCON, a6: C_REG},
	{i: 3, as: AMOVWZ, a1: C_DCON, a6: C_REG},
	{i: 3, as: AMOVB, a1: C_DCON, a6: C_REG},
	{i: 3, as: AMOVBZ, a1: C_DCON, a6: C_REG},

	// store constant
	{i: 72, as: AMOVD, a1: C_SCON, a6: C_LAUTO},
	{i: 72, as: AMOVD, a1: C_ADDCON, a6: C_LAUTO},
	{i: 72, as: AMOVW, a1: C_SCON, a6: C_LAUTO},
	{i: 72, as: AMOVW, a1: C_ADDCON, a6: C_LAUTO},
	{i: 72, as: AMOVWZ, a1: C_SCON, a6: C_LAUTO},
	{i: 72, as: AMOVWZ, a1: C_ADDCON, a6: C_LAUTO},
	{i: 72, as: AMOVB, a1: C_SCON, a6: C_LAUTO},
	{i: 72, as: AMOVB, a1: C_ADDCON, a6: C_LAUTO},
	{i: 72, as: AMOVBZ, a1: C_SCON, a6: C_LAUTO},
	{i: 72, as: AMOVBZ, a1: C_ADDCON, a6: C_LAUTO},
	{i: 72, as: AMOVD, a1: C_SCON, a6: C_LOREG},
	{i: 72, as: AMOVD, a1: C_ADDCON, a6: C_LOREG},
	{i: 72, as: AMOVW, a1: C_SCON, a6: C_LOREG},
	{i: 72, as: AMOVW, a1: C_ADDCON, a6: C_LOREG},
	{i: 72, as: AMOVWZ, a1: C_SCON, a6: C_LOREG},
	{i: 72, as: AMOVWZ, a1: C_ADDCON, a6: C_LOREG},
	{i: 72, as: AMOVB, a1: C_SCON, a6: C_LOREG},
	{i: 72, as: AMOVB, a1: C_ADDCON, a6: C_LOREG},
	{i: 72, as: AMOVBZ, a1: C_SCON, a6: C_LOREG},
	{i: 72, as: AMOVBZ, a1: C_ADDCON, a6: C_LOREG},

	// store
	{i: 35, as: AMOVD, a1: C_REG, a6: C_LAUTO},
	{i: 35, as: AMOVW, a1: C_REG, a6: C_LAUTO},
	{i: 35, as: AMOVWZ, a1: C_REG, a6: C_LAUTO},
	{i: 35, as: AMOVBZ, a1: C_REG, a6: C_LAUTO},
	{i: 35, as: AMOVB, a1: C_REG, a6: C_LAUTO},
	{i: 35, as: AMOVDBR, a1: C_REG, a6: C_LAUTO},
	{i: 35, as: AMOVHBR, a1: C_REG, a6: C_LAUTO},
	{i: 35, as: AMOVD, a1: C_REG, a6: C_LOREG},
	{i: 35, as: AMOVW, a1: C_REG, a6: C_LOREG},
	{i: 35, as: AMOVWZ, a1: C_REG, a6: C_LOREG},
	{i: 35, as: AMOVBZ, a1: C_REG, a6: C_LOREG},
	{i: 35, as: AMOVB, a1: C_REG, a6: C_LOREG},
	{i: 35, as: AMOVDBR, a1: C_REG, a6: C_LOREG},
	{i: 35, as: AMOVHBR, a1: C_REG, a6: C_LOREG},
	{i: 74, as: AMOVD, a1: C_REG, a6: C_ADDR},
	{i: 74, as: AMOVW, a1: C_REG, a6: C_ADDR},
	{i: 74, as: AMOVWZ, a1: C_REG, a6: C_ADDR},
	{i: 74, as: AMOVBZ, a1: C_REG, a6: C_ADDR},
	{i: 74, as: AMOVB, a1: C_REG, a6: C_ADDR},

	// load
	{i: 36, as: AMOVD, a1: C_LAUTO, a6: C_REG},
	{i: 36, as: AMOVW, a1: C_LAUTO, a6: C_REG},
	{i: 36, as: AMOVWZ, a1: C_LAUTO, a6: C_REG},
	{i: 36, as: AMOVBZ, a1: C_LAUTO, a6: C_REG},
	{i: 36, as: AMOVB, a1: C_LAUTO, a6: C_REG},
	{i: 36, as: AMOVDBR, a1: C_LAUTO, a6: C_REG},
	{i: 36, as: AMOVHBR, a1: C_LAUTO, a6: C_REG},
	{i: 36, as: AMOVD, a1: C_LOREG, a6: C_REG},
	{i: 36, as: AMOVW, a1: C_LOREG, a6: C_REG},
	{i: 36, as: AMOVWZ, a1: C_LOREG, a6: C_REG},
	{i: 36, as: AMOVBZ, a1: C_LOREG, a6: C_REG},
	{i: 36, as: AMOVB, a1: C_LOREG, a6: C_REG},
	{i: 36, as: AMOVDBR, a1: C_LOREG, a6: C_REG},
	{i: 36, as: AMOVHBR, a1: C_LOREG, a6: C_REG},
	{i: 75, as: AMOVD, a1: C_ADDR, a6: C_REG},
	{i: 75, as: AMOVW, a1: C_ADDR, a6: C_REG},
	{i: 75, as: AMOVWZ, a1: C_ADDR, a6: C_REG},
	{i: 75, as: AMOVBZ, a1: C_ADDR, a6: C_REG},
	{i: 75, as: AMOVB, a1: C_ADDR, a6: C_REG},

	// interlocked load and op
	{i: 99, as: ALAAG, a1: C_REG, a2: C_REG, a6: C_LOREG},

	// integer arithmetic
	{i: 2, as: AADD, a1: C_REG, a2: C_REG, a6: C_REG},
	{i: 2, as: AADD, a1: C_REG, a6: C_REG},
	{i: 22, as: AADD, a1: C_LCON, a2: C_REG, a6: C_REG},
	{i: 22, as: AADD, a1: C_LCON, a6: C_REG},
	{i: 12, as: AADD, a1: C_LOREG, a6: C_REG},
	{i: 12, as: AADD, a1: C_LAUTO, a6: C_REG},
	{i: 21, as: ASUB, a1: C_LCON, a2: C_REG, a6: C_REG},
	{i: 21, as: ASUB, a1: C_LCON, a6: C_REG},
	{i: 12, as: ASUB, a1: C_LOREG, a6: C_REG},
	{i: 12, as: ASUB, a1: C_LAUTO, a6: C_REG},
	{i: 4, as: AMULHD, a1: C_REG, a6: C_REG},
	{i: 4, as: AMULHD, a1: C_REG, a2: C_REG, a6: C_REG},
	{i: 62, as: AMLGR, a1: C_REG, a6: C_REG},
	{i: 2, as: ADIVW, a1: C_REG, a2: C_REG, a6: C_REG},
	{i: 2, as: ADIVW, a1: C_REG, a6: C_REG},
	{i: 10, as: ASUB, a1: C_REG, a2: C_REG, a6: C_REG},
	{i: 10, as: ASUB, a1: C_REG, a6: C_REG},
	{i: 47, as: ANEG, a1: C_REG, a6: C_REG},
	{i: 47, as: ANEG, a6: C_REG},

	// integer logical
	{i: 6, as: AAND, a1: C_REG, a2: C_REG, a6: C_REG},
	{i: 6, as: AAND, a1: C_REG, a6: C_REG},
	{i: 23, as: AAND, a1: C_LCON, a6: C_REG},
	{i: 12, as: AAND, a1: C_LOREG, a6: C_REG},
	{i: 12, as: AAND, a1: C_LAUTO, a6: C_REG},
	{i: 6, as: AANDW, a1: C_REG, a2: C_REG, a6: C_REG},
	{i: 6, as: AANDW, a1: C_REG, a6: C_REG},
	{i: 24, as: AANDW, a1: C_LCON, a6: C_REG},
	{i: 12, as: AANDW, a1: C_LOREG, a6: C_REG},
	{i: 12, as: AANDW, a1: C_LAUTO, a6: C_REG},
	{i: 7, as: ASLD, a1: C_REG, a6: C_REG},
	{i: 7, as: ASLD, a1: C_REG, a2: C_REG, a6: C_REG},
	{i: 7, as: ASLD, a1: C_SCON, a2: C_REG, a6: C_REG},
	{i: 7, as: ASLD, a1: C_SCON, a6: C_REG},
	{i: 13, as: ARNSBG, a1: C_SCON, a3: C_SCON, a4: C_SCON, a5: C_REG, a6: C_REG},

	// compare and swap
	{i: 79, as: ACSG, a1: C_REG, a2: C_REG, a6: C_SOREG},

	// floating point
	{i: 32, as: AFADD, a1: C_FREG, a6: C_FREG},
	{i: 33, as: AFABS, a1: C_FREG, a6: C_FREG},
	{i: 33, as: AFABS, a6: C_FREG},
	{i: 34, as: AFMADD, a1: C_FREG, a2: C_FREG, a6: C_FREG},
	{i: 32, as: AFMUL, a1: C_FREG, a6: C_FREG},
	{i: 36, as: AFMOVD, a1: C_LAUTO, a6: C_FREG},
	{i: 36, as: AFMOVD, a1: C_LOREG, a6: C_FREG},
	{i: 75, as: AFMOVD, a1: C_ADDR, a6: C_FREG},
	{i: 35, as: AFMOVD, a1: C_FREG, a6: C_LAUTO},
	{i: 35, as: AFMOVD, a1: C_FREG, a6: C_LOREG},
	{i: 74, as: AFMOVD, a1: C_FREG, a6: C_ADDR},
	{i: 67, as: AFMOVD, a1: C_ZCON, a6: C_FREG},
	{i: 81, as: ALDGR, a1: C_REG, a6: C_FREG},
	{i: 81, as: ALGDR, a1: C_FREG, a6: C_REG},
	{i: 82, as: ACEFBRA, a1: C_REG, a6: C_FREG},
	{i: 83, as: ACFEBRA, a1: C_FREG, a6: C_REG},
	{i: 48, as: AFIEBR, a1: C_SCON, a2: C_FREG, a6: C_FREG},
	{i: 49, as: ACPSDR, a1: C_FREG, a2: C_FREG, a6: C_FREG},
	{i: 50, as: ALTDBR, a1: C_FREG, a6: C_FREG},
	{i: 51, as: ATCDB, a1: C_FREG, a6: C_SCON},

	// load symbol address (plus offset)
	{i: 19, as: AMOVD, a1: C_SYMADDR, a6: C_REG},
	{i: 93, as: AMOVD, a1: C_GOTADDR, a6: C_REG},
	{i: 94, as: AMOVD, a1: C_TLS_LE, a6: C_REG},
	{i: 95, as: AMOVD, a1: C_TLS_IE, a6: C_REG},

	// system call
	{i: 5, as: ASYSCALL},
	{i: 77, as: ASYSCALL, a1: C_SCON},

	// branch
	{i: 16, as: ABEQ, a6: C_SBRA},
	{i: 16, as: ABRC, a1: C_SCON, a6: C_SBRA},
	{i: 11, as: ABR, a6: C_LBRA},
	{i: 16, as: ABC, a1: C_SCON, a2: C_REG, a6: C_LBRA},
	{i: 18, as: ABR, a6: C_REG},
	{i: 18, as: ABR, a1: C_REG, a6: C_REG},
	{i: 15, as: ABR, a6: C_ZOREG},
	{i: 15, as: ABC, a6: C_ZOREG},

	// compare and branch
	{i: 89, as: ACGRJ, a1: C_SCON, a2: C_REG, a3: C_REG, a6: C_SBRA},
	{i: 89, as: ACMPBEQ, a1: C_REG, a2: C_REG, a6: C_SBRA},
	{i: 89, as: ACLGRJ, a1: C_SCON, a2: C_REG, a3: C_REG, a6: C_SBRA},
	{i: 89, as: ACMPUBEQ, a1: C_REG, a2: C_REG, a6: C_SBRA},
	{i: 90, as: ACGIJ, a1: C_SCON, a2: C_REG, a3: C_ADDCON, a6: C_SBRA},
	{i: 90, as: ACGIJ, a1: C_SCON, a2: C_REG, a3: C_SCON, a6: C_SBRA},
	{i: 90, as: ACMPBEQ, a1: C_REG, a3: C_ADDCON, a6: C_SBRA},
	{i: 90, as: ACMPBEQ, a1: C_REG, a3: C_SCON, a6: C_SBRA},
	{i: 90, as: ACLGIJ, a1: C_SCON, a2: C_REG, a3: C_ADDCON, a6: C_SBRA},
	{i: 90, as: ACMPUBEQ, a1: C_REG, a3: C_ANDCON, a6: C_SBRA},

	// branch on count
	{i: 41, as: ABRCT, a1: C_REG, a6: C_SBRA},
	{i: 41, as: ABRCTG, a1: C_REG, a6: C_SBRA},

	// move on condition
	{i: 17, as: AMOVDEQ, a1: C_REG, a6: C_REG},

	// load on condition
	{i: 25, as: ALOCGR, a1: C_SCON, a2: C_REG, a6: C_REG},

	// find leftmost one
	{i: 8, as: AFLOGR, a1: C_REG, a6: C_REG},

	// population count
	{i: 9, as: APOPCNT, a1: C_REG, a6: C_REG},

	// compare
	{i: 70, as: ACMP, a1: C_REG, a6: C_REG},
	{i: 71, as: ACMP, a1: C_REG, a6: C_LCON},
	{i: 70, as: ACMPU, a1: C_REG, a6: C_REG},
	{i: 71, as: ACMPU, a1: C_REG, a6: C_LCON},
	{i: 70, as: AFCMPO, a1: C_FREG, a6: C_FREG},
	{i: 70, as: AFCMPO, a1: C_FREG, a2: C_REG, a6: C_FREG},

	// test under mask
	{i: 91, as: ATMHH, a1: C_REG, a6: C_ANDCON},

	// insert program mask
	{i: 92, as: AIPM, a1: C_REG},

	// set program mask
	{i: 76, as: ASPM, a1: C_REG},

	// 32-bit access registers
	{i: 68, as: AMOVW, a1: C_AREG, a6: C_REG},
	{i: 68, as: AMOVWZ, a1: C_AREG, a6: C_REG},
	{i: 69, as: AMOVW, a1: C_REG, a6: C_AREG},
	{i: 69, as: AMOVWZ, a1: C_REG, a6: C_AREG},

	// macros
	{i: 96, as: ACLEAR, a1: C_LCON, a6: C_LOREG},
	{i: 96, as: ACLEAR, a1: C_LCON, a6: C_LAUTO},

	// load/store multiple
	{i: 97, as: ASTMG, a1: C_REG, a2: C_REG, a6: C_LOREG},
	{i: 97, as: ASTMG, a1: C_REG, a2: C_REG, a6: C_LAUTO},
	{i: 98, as: ALMG, a1: C_LOREG, a2: C_REG, a6: C_REG},
	{i: 98, as: ALMG, a1: C_LAUTO, a2: C_REG, a6: C_REG},

	// bytes
	{i: 40, as: ABYTE, a1: C_SCON},
	{i: 40, as: AWORD, a1: C_LCON},
	{i: 31, as: ADWORD, a1: C_LCON},
	{i: 31, as: ADWORD, a1: C_DCON},

	// fast synchronization
	{i: 80, as: ASYNC},

	// store clock
	{i: 88, as: ASTCK, a6: C_SAUTO},
	{i: 88, as: ASTCK, a6: C_SOREG},

	// storage and storage
	{i: 84, as: AMVC, a1: C_SCON, a3: C_LOREG, a6: C_LOREG},
	{i: 84, as: AMVC, a1: C_SCON, a3: C_LOREG, a6: C_LAUTO},
	{i: 84, as: AMVC, a1: C_SCON, a3: C_LAUTO, a6: C_LAUTO},

	// address
	{i: 85, as: ALARL, a1: C_LCON, a6: C_REG},
	{i: 85, as: ALARL, a1: C_SYMADDR, a6: C_REG},
	{i: 86, as: ALA, a1: C_SOREG, a6: C_REG},
	{i: 86, as: ALA, a1: C_SAUTO, a6: C_REG},
	{i: 87, as: AEXRL, a1: C_SYMADDR, a6: C_REG},

	// undefined (deliberate illegal instruction)
	{i: 78, as: obj.AUNDEF},

	// Break point instruction(0x0001 opcode)
	{i: 73, as: ABRRK},

	// 2 byte no-operation
	{i: 66, as: ANOPH},

	// crypto instructions

	// KM
	{i: 124, as: AKM, a1: C_REG, a6: C_REG},

	// KDSA
	{i: 125, as: AKDSA, a1: C_REG, a6: C_REG},

	// KMA
	{i: 126, as: AKMA, a1: C_REG, a2: C_REG, a6: C_REG},

	// vector instructions

	// VRX store
	{i: 100, as: AVST, a1: C_VREG, a6: C_SOREG},
	{i: 100, as: AVST, a1: C_VREG, a6: C_SAUTO},
	{i: 100, as: AVSTEG, a1: C_SCON, a2: C_VREG, a6: C_SOREG},
	{i: 100, as: AVSTEG, a1: C_SCON, a2: C_VREG, a6: C_SAUTO},

	// VRX load
	{i: 101, as: AVL, a1: C_SOREG, a6: C_VREG},
	{i: 101, as: AVL, a1: C_SAUTO, a6: C_VREG},
	{i: 101, as: AVLEG, a1: C_SCON, a3: C_SOREG, a6: C_VREG},
	{i: 101, as: AVLEG, a1: C_SCON, a3: C_SAUTO, a6: C_VREG},

	// VRV scatter
	{i: 102, as: AVSCEG, a1: C_SCON, a2: C_VREG, a6: C_SOREG},
	{i: 102, as: AVSCEG, a1: C_SCON, a2: C_VREG, a6: C_SAUTO},

	// VRV gather
	{i: 103, as: AVGEG, a1: C_SCON, a3: C_SOREG, a6: C_VREG},
	{i: 103, as: AVGEG, a1: C_SCON, a3: C_SAUTO, a6: C_VREG},

	// VRS element shift/rotate and load gr to/from vr element
	{i: 104, as: AVESLG, a1: C_SCON, a2: C_VREG, a6: C_VREG},
	{i: 104, as: AVESLG, a1: C_REG, a2: C_VREG, a6: C_VREG},
	{i: 104, as: AVESLG, a1: C_SCON, a6: C_VREG},
	{i: 104, as: AVESLG, a1: C_REG, a6: C_VREG},
	{i: 104, as: AVLGVG, a1: C_SCON, a2: C_VREG, a6: C_REG},
	{i: 104, as: AVLGVG, a1: C_REG, a2: C_VREG, a6: C_REG},
	{i: 104, as: AVLVGG, a1: C_SCON, a2: C_REG, a6: C_VREG},
	{i: 104, as: AVLVGG, a1: C_REG, a2: C_REG, a6: C_VREG},

	// VRS store multiple
	{i: 105, as: AVSTM, a1: C_VREG, a2: C_VREG, a6: C_SOREG},
	{i: 105, as: AVSTM, a1: C_VREG, a2: C_VREG, a6: C_SAUTO},

	// VRS load multiple
	{i: 106, as: AVLM, a1: C_SOREG, a2: C_VREG, a6: C_VREG},
	{i: 106, as: AVLM, a1: C_SAUTO, a2: C_VREG, a6: C_VREG},

	// VRS store with length
	{i: 107, as: AVSTL, a1: C_REG, a2: C_VREG, a6: C_SOREG},
	{i: 107, as: AVSTL, a1: C_REG, a2: C_VREG, a6: C_SAUTO},

	// VRS load with length
	{i: 108, as: AVLL, a1: C_REG, a3: C_SOREG, a6: C_VREG},
	{i: 108, as: AVLL, a1: C_REG, a3: C_SAUTO, a6: C_VREG},

	// VRI-a
	{i: 109, as: AVGBM, a1: C_ANDCON, a6: C_VREG},
	{i: 109, as: AVZERO, a6: C_VREG},
	{i: 109, as: AVREPIG, a1: C_ADDCON, a6: C_VREG},
	{i: 109, as: AVREPIG, a1: C_SCON, a6: C_VREG},
	{i: 109, as: AVLEIG, a1: C_SCON, a3: C_ADDCON, a6: C_VREG},
	{i: 109, as: AVLEIG, a1: C_SCON, a3: C_SCON, a6: C_VREG},

	// VRI-b generate mask
	{i: 110, as: AVGMG, a1: C_SCON, a3: C_SCON, a6: C_VREG},

	// VRI-c replicate
	{i: 111, as: AVREPG, a1: C_UCON, a2: C_VREG, a6: C_VREG},

	// VRI-d element rotate and insert under mask and
	// shift left double by byte
	{i: 112, as: AVERIMG, a1: C_SCON, a2: C_VREG, a3: C_VREG, a6: C_VREG},
	{i: 112, as: AVSLDB, a1: C_SCON, a2: C_VREG, a3: C_VREG, a6: C_VREG},

	// VRI-d fp test data class immediate
	{i: 113, as: AVFTCIDB, a1: C_SCON, a2: C_VREG, a6: C_VREG},

	// VRR-a load reg
	{i: 114, as: AVLR, a1: C_VREG, a6: C_VREG},

	// VRR-a compare
	{i: 115, as: AVECG, a1: C_VREG, a6: C_VREG},

	// VRR-b
	{i: 117, as: AVCEQG, a1: C_VREG, a2: C_VREG, a6: C_VREG},
	{i: 117, as: AVFAEF, a1: C_VREG, a2: C_VREG, a6: C_VREG},
	{i: 117, as: AVPKSG, a1: C_VREG, a2: C_VREG, a6: C_VREG},

	// VRR-c
	{i: 118, as: AVAQ, a1: C_VREG, a2: C_VREG, a6: C_VREG},
	{i: 118, as: AVAQ, a1: C_VREG, a6: C_VREG},
	{i: 118, as: AVNOT, a1: C_VREG, a6: C_VREG},
	{i: 123, as: AVPDI, a1: C_SCON, a2: C_VREG, a3: C_VREG, a6: C_VREG},

	// VRR-c shifts
	{i: 119, as: AVERLLVG, a1: C_VREG, a2: C_VREG, a6: C_VREG},
	{i: 119, as: AVERLLVG, a1: C_VREG, a6: C_VREG},

	// VRR-d
	{i: 120, as: AVACQ, a1: C_VREG, a2: C_VREG, a3: C_VREG, a6: C_VREG},

	// VRR-e
	{i: 121, as: AVSEL, a1: C_VREG, a2: C_VREG, a3: C_VREG, a6: C_VREG},

	// VRR-f
	{i: 122, as: AVLVGP, a1: C_REG, a2: C_REG, a6: C_VREG},
}

var oprange [ALAST & obj.AMask][]Optab

var xcmp [C_NCLASS][C_NCLASS]bool

func spanz(ctxt *obj.Link, cursym *obj.LSym, newprog obj.ProgAlloc) {
	if ctxt.Retpoline {
		ctxt.Diag("-spectre=ret not supported on s390x")
		ctxt.Retpoline = false // don't keep printing
	}

	p := cursym.Func().Text
	if p == nil || p.Link == nil { // handle external functions and ELF section symbols
		return
	}

	if oprange[AORW&obj.AMask] == nil {
		ctxt.Diag("s390x ops not initialized, call s390x.buildop first")
	}

	c := ctxtz{ctxt: ctxt, newprog: newprog, cursym: cursym, autosize: int32(p.To.Offset)}

	buffer := make([]byte, 0)
	changed := true
	loop := 0
	nrelocs0 := len(c.cursym.R)
	for changed {
		if loop > 100 {
			c.ctxt.Diag("stuck in spanz loop")
			break
		}
		changed = false
		buffer = buffer[:0]
		for i := range c.cursym.R[nrelocs0:] {
			c.cursym.R[nrelocs0+i] = obj.Reloc{}
		}
		c.cursym.R = c.cursym.R[:nrelocs0] // preserve marker relocations generated by the compiler
		for p := c.cursym.Func().Text; p != nil; p = p.Link {
			pc := int64(len(buffer))
			if pc != p.Pc {
				changed = true
			}
			p.Pc = pc
			c.pc = p.Pc
			c.asmout(p, &buffer)
			if pc == int64(len(buffer)) {
				switch p.As {
				case obj.ANOP, obj.AFUNCDATA, obj.APCDATA, obj.ATEXT:
					// ok
				default:
					c.ctxt.Diag("zero-width instruction\n%v", p)
				}
			}
		}
		loop++
	}

	c.cursym.Size = int64(len(buffer))
	if c.cursym.Size%funcAlign != 0 {
		c.cursym.Size += funcAlign - (c.cursym.Size % funcAlign)
	}
	c.cursym.Grow(c.cursym.Size)
	copy(c.cursym.P, buffer)

	// Mark nonpreemptible instruction sequences.
	// We use REGTMP as a scratch register during call injection,
	// so instruction sequences that use REGTMP are unsafe to
	// preempt asynchronously.
	obj.MarkUnsafePoints(c.ctxt, c.cursym.Func().Text, c.newprog, c.isUnsafePoint, nil)
}

// Return whether p is an unsafe point.
func (c *ctxtz) isUnsafePoint(p *obj.Prog) bool {
	if p.From.Reg == REGTMP || p.To.Reg == REGTMP || p.Reg == REGTMP {
		return true
	}
	for _, a := range p.RestArgs {
		if a.Reg == REGTMP {
			return true
		}
	}
	return p.Mark&USETMP != 0
}

func isint32(v int64) bool {
	return int64(int32(v)) == v
}

func isuint32(v uint64) bool {
	return uint64(uint32(v)) == v
}

func (c *ctxtz) aclass(a *obj.Addr) int {
	switch a.Type {
	case obj.TYPE_NONE:
		return C_NONE

	case obj.TYPE_REG:
		if REG_R0 <= a.Reg && a.Reg <= REG_R15 {
			return C_REG
		}
		if REG_F0 <= a.Reg && a.Reg <= REG_F15 {
			return C_FREG
		}
		if REG_AR0 <= a.Reg && a.Reg <= REG_AR15 {
			return C_AREG
		}
		if REG_V0 <= a.Reg && a.Reg <= REG_V31 {
			return C_VREG
		}
		return C_GOK

	case obj.TYPE_MEM:
		switch a.Name {
		case obj.NAME_EXTERN,
			obj.NAME_STATIC:
			if a.Sym == nil {
				// must have a symbol
				break
			}
			c.instoffset = a.Offset
			if a.Sym.Type == objabi.STLSBSS {
				if c.ctxt.Flag_shared {
					return C_TLS_IE // initial exec model
				}
				return C_TLS_LE // local exec model
			}
			return C_ADDR

		case obj.NAME_GOTREF:
			return C_GOTADDR

		case obj.NAME_AUTO:
			if a.Reg == REGSP {
				// unset base register for better printing, since
				// a.Offset is still relative to pseudo-SP.
				a.Reg = obj.REG_NONE
			}
			c.instoffset = int64(c.autosize) + a.Offset
			if c.instoffset >= -BIG && c.instoffset < BIG {
				return C_SAUTO
			}
			return C_LAUTO

		case obj.NAME_PARAM:
			if a.Reg == REGSP {
				// unset base register for better printing, since
				// a.Offset is still relative to pseudo-FP.
				a.Reg = obj.REG_NONE
			}
			c.instoffset = int64(c.autosize) + a.Offset + c.ctxt.Arch.FixedFrameSize
			if c.instoffset >= -BIG && c.instoffset < BIG {
				return C_SAUTO
			}
			return C_LAUTO

		case obj.NAME_NONE:
			c.instoffset = a.Offset
			if c.instoffset == 0 {
				return C_ZOREG
			}
			if c.instoffset >= -BIG && c.instoffset < BIG {
				return C_SOREG
			}
			return C_LOREG
		}

		return C_GOK

	case obj.TYPE_TEXTSIZE:
		return C_TEXTSIZE

	case obj.TYPE_FCONST:
		if f64, ok := a.Val.(float64); ok && math.Float64bits(f64) == 0 {
			return C_ZCON
		}
		c.ctxt.Diag("cannot handle the floating point constant %v", a.Val)

	case obj.TYPE_CONST,
		obj.TYPE_ADDR:
		switch a.Name {
		case obj.NAME_NONE:
			c.instoffset = a.Offset
			if a.Reg != 0 {
				if -BIG <= c.instoffset && c.instoffset <= BIG {
					return C_SACON
				}
				if isint32(c.instoffset) {
					return C_LACON
				}
				return C_DACON
			}

		case obj.NAME_EXTERN,
			obj.NAME_STATIC:
			s := a.Sym
			if s == nil {
				return C_GOK
			}
			c.instoffset = a.Offset

			return C_SYMADDR

		case obj.NAME_AUTO:
			if a.Reg == REGSP {
				// unset base register for better printing, since
				// a.Offset is still relative to pseudo-SP.
				a.Reg = obj.REG_NONE
			}
			c.instoffset = int64(c.autosize) + a.Offset
			if c.instoffset >= -BIG && c.instoffset < BIG {
				return C_SACON
			}
			return C_LACON

		case obj.NAME_PARAM:
			if a.Reg == REGSP {
				// unset base register for better printing, since
				// a.Offset is still relative to pseudo-FP.
				a.Reg = obj.REG_NONE
			}
			c.instoffset = int64(c.autosize) + a.Offset + c.ctxt.Arch.FixedFrameSize
			if c.instoffset >= -BIG && c.instoffset < BIG {
				return C_SACON
			}
			return C_LACON

		default:
			return C_GOK
		}

		if c.instoffset == 0 {
			return C_ZCON
		}
		if c.instoffset >= 0 {
			if c.instoffset <= 0x7fff {
				return C_SCON
			}
			if c.instoffset <= 0xffff {
				return C_ANDCON
			}
			if c.instoffset&0xffff == 0 && isuint32(uint64(c.instoffset)) { /* && ((instoffset & (1<<31)) == 0) */
				return C_UCON
			}
			if isint32(c.instoffset) || isuint32(uint64(c.instoffset)) {
				return C_LCON
			}
			return C_DCON
		}

		if c.instoffset >= -0x8000 {
			return C_ADDCON
		}
		if c.instoffset&0xffff == 0 && isint32(c.instoffset) {
			return C_UCON
		}
		if isint32(c.instoffset) {
			return C_LCON
		}
		return C_DCON

	case obj.TYPE_BRANCH:
		return C_SBRA
	}

	return C_GOK
}

func (c *ctxtz) oplook(p *obj.Prog) *Optab {
	// Return cached optab entry if available.
	if p.Optab != 0 {
		return &optab[p.Optab-1]
	}
	if len(p.RestArgs) > 3 {
		c.ctxt.Diag("too many RestArgs: got %v, maximum is 3\n", len(p.RestArgs))
		return nil
	}

	// Initialize classes for all arguments.
	p.From.Class = int8(c.aclass(&p.From) + 1)
	p.To.Class = int8(c.aclass(&p.To) + 1)
	for i := range p.RestArgs {
		p.RestArgs[i].Addr.Class = int8(c.aclass(&p.RestArgs[i].Addr) + 1)
	}

	// Mirrors the argument list in Optab.
	args := [...]int8{
		p.From.Class - 1,
		C_NONE, // p.Reg
		C_NONE, // p.RestArgs[0]
		C_NONE, // p.RestArgs[1]
		C_NONE, // p.RestArgs[2]
		p.To.Class - 1,
	}
	// Fill in argument class for p.Reg.
	switch {
	case REG_R0 <= p.Reg && p.Reg <= REG_R15:
		args[1] = C_REG
	case REG_V0 <= p.Reg && p.Reg <= REG_V31:
		args[1] = C_VREG
	case REG_F0 <= p.Reg && p.Reg <= REG_F15:
		args[1] = C_FREG
	case REG_AR0 <= p.Reg && p.Reg <= REG_AR15:
		args[1] = C_AREG
	}
	// Fill in argument classes for p.RestArgs.
	for i, a := range p.RestArgs {
		args[2+i] = a.Class - 1
	}

	// Lookup op in optab.
	ops := oprange[p.As&obj.AMask]
	cmp := [len(args)]*[C_NCLASS]bool{}
	for i := range cmp {
		cmp[i] = &xcmp[args[i]]
	}
	for i := range ops {
		op := &ops[i]
		if cmp[0][op.a1] && cmp[1][op.a2] &&
			cmp[2][op.a3] && cmp[3][op.a4] &&
			cmp[4][op.a5] && cmp[5][op.a6] {
			p.Optab = uint16(cap(optab) - cap(ops) + i + 1)
			return op
		}
	}

	// Cannot find a case; abort.
	s := ""
	for _, a := range args {
		s += fmt.Sprintf(" %v", DRconv(int(a)))
	}
	c.ctxt.Diag("illegal combination %v%v\n", p.As, s)
	c.ctxt.Diag("prog: %v\n", p)
	return nil
}

func cmp(a int, b int) bool {
	if a == b {
		return true
	}
	switch a {
	case C_DCON:
		if b == C_LCON {
			return true
		}
		fallthrough
	case C_LCON:
		if b == C_ZCON || b == C_SCON || b == C_UCON || b == C_ADDCON || b == C_ANDCON {
			return true
		}

	case C_ADDCON:
		if b == C_ZCON || b == C_SCON {
			return true
		}

	case C_ANDCON:
		if b == C_ZCON || b == C_SCON {
			return true
		}

	case C_UCON:
		if b == C_ZCON || b == C_SCON {
			return true
		}

	case C_SCON:
		if b == C_ZCON {
			return true
		}

	case C_LACON:
		if b == C_SACON {
			return true
		}

	case C_LBRA:
		if b == C_SBRA {
			return true
		}

	case C_LAUTO:
		if b == C_SAUTO {
			return true
		}

	case C_LOREG:
		if b == C_ZOREG || b == C_SOREG {
			return true
		}

	case C_SOREG:
		if b == C_ZOREG {
			return true
		}

	case C_ANY:
		return true
	}

	return false
}

func ocmp(p1, p2 Optab) int {
	if p1.as != p2.as {
		return int(p1.as) - int(p2.as)
	}
	if p1.a1 != p2.a1 {
		return int(p1.a1) - int(p2.a1)
	}
	if p1.a2 != p2.a2 {
		return int(p1.a2) - int(p2.a2)
	}
	if p1.a3 != p2.a3 {
		return int(p1.a3) - int(p2.a3)
	}
	if p1.a4 != p2.a4 {
		return int(p1.a4) - int(p2.a4)
	}
	return 0
}
func opset(a, b obj.As) {
	oprange[a&obj.AMask] = oprange[b&obj.AMask]
}

func buildop(ctxt *obj.Link) {
	if oprange[AORW&obj.AMask] != nil {
		// Already initialized; stop now.
		// This happens in the cmd/asm tests,
		// each of which re-initializes the arch.
		return
	}

	for i := 0; i < C_NCLASS; i++ {
		for n := 0; n < C_NCLASS; n++ {
			if cmp(n, i) {
				xcmp[i][n] = true
			}
		}
	}
	slices.SortFunc(optab, ocmp)
	for i := 0; i < len(optab); i++ {
		r := optab[i].as
		start := i
		for ; i+1 < len(optab); i++ {
			if optab[i+1].as != r {
				break
			}
		}
		oprange[r&obj.AMask] = optab[start : i+1]

		// opset() aliases optab ranges for similar instructions, to reduce the number of optabs in the array.
		// oprange[] is used by oplook() to find the Optab entry that applies to a given Prog.
		switch r {
		case AADD:
			opset(AADDC, r)
			opset(AADDW, r)
			opset(AADDE, r)
			opset(AMULLD, r)
			opset(AMULLW, r)
		case ADIVW:
			opset(ADIVD, r)
			opset(ADIVDU, r)
			opset(ADIVWU, r)
			opset(AMODD, r)
			opset(AMODDU, r)
			opset(AMODW, r)
			opset(AMODWU, r)
		case AMULHD:
			opset(AMULHDU, r)
		case AMOVBZ:
			opset(AMOVH, r)
			opset(AMOVHZ, r)
		case ALA:
			opset(ALAY, r)
		case AMVC:
			opset(AMVCIN, r)
			opset(ACLC, r)
			opset(AXC, r)
			opset(AOC, r)
			opset(ANC, r)
		case ASTCK:
			opset(ASTCKC, r)
			opset(ASTCKE, r)
			opset(ASTCKF, r)
		case ALAAG:
			opset(ALAA, r)
			opset(ALAAL, r)
			opset(ALAALG, r)
			opset(ALAN, r)
			opset(ALANG, r)
			opset(ALAX, r)
			opset(ALAXG, r)
			opset(ALAO, r)
			opset(ALAOG, r)
		case ASTMG:
			opset(ASTMY, r)
		case ALMG:
			opset(ALMY, r)
		case ABEQ:
			opset(ABGE, r)
			opset(ABGT, r)
			opset(ABLE, r)
			opset(ABLT, r)
			opset(ABNE, r)
			opset(ABVC, r)
			opset(ABVS, r)
			opset(ABLEU, r)
			opset(ABLTU, r)
		case ABR:
			opset(ABL, r)
		case ABC:
			opset(ABCL, r)
		case AFABS:
			opset(AFNABS, r)
			opset(ALPDFR, r)
			opset(ALNDFR, r)
			opset(AFNEG, r)
			opset(AFNEGS, r)
			opset(ALEDBR, r)
			opset(ALDEBR, r)
			opset(AFSQRT, r)
			opset(AFSQRTS, r)
		case AFADD:
			opset(AFADDS, r)
			opset(AFDIV, r)
			opset(AFDIVS, r)
			opset(AFSUB, r)
			opset(AFSUBS, r)
		case AFMADD:
			opset(AFMADDS, r)
			opset(AFMSUB, r)
			opset(AFMSUBS, r)
		case AFMUL:
			opset(AFMULS, r)
		case AFCMPO:
			opset(AFCMPU, r)
			opset(ACEBR, r)
		case AAND:
			opset(AOR, r)
			opset(AXOR, r)
		case AANDW:
			opset(AORW, r)
			opset(AXORW, r)
		case ASLD:
			opset(ASRD, r)
			opset(ASLW, r)
			opset(ASRW, r)
			opset(ASRAD, r)
			opset(ASRAW, r)
			opset(ARLL, r)
			opset(ARLLG, r)
		case ARNSBG:
			opset(ARXSBG, r)
			opset(AROSBG, r)
			opset(ARNSBGT, r)
			opset(ARXSBGT, r)
			opset(AROSBGT, r)
			opset(ARISBG, r)
			opset(ARISBGN, r)
			opset(ARISBGZ, r)
			opset(ARISBGNZ, r)
			opset(ARISBHG, r)
			opset(ARISBLG, r)
			opset(ARISBHGZ, r)
			opset(ARISBLGZ, r)
		case ACSG:
			opset(ACS, r)
		case ASUB:
			opset(ASUBC, r)
			opset(ASUBE, r)
			opset(ASUBW, r)
		case ANEG:
			opset(ANEGW, r)
		case AFMOVD:
			opset(AFMOVS, r)
		case AMOVDBR:
			opset(AMOVWBR, r)
		case ACMP:
			opset(ACMPW, r)
		case ACMPU:
			opset(ACMPWU, r)
		case ATMHH:
			opset(ATMHL, r)
			opset(ATMLH, r)
			opset(ATMLL, r)
		case ACEFBRA:
			opset(ACDFBRA, r)
			opset(ACEGBRA, r)
			opset(ACDGBRA, r)
			opset(ACELFBR, r)
			opset(ACDLFBR, r)
			opset(ACELGBR, r)
			opset(ACDLGBR, r)
		case ACFEBRA:
			opset(ACFDBRA, r)
			opset(ACGEBRA, r)
			opset(ACGDBRA, r)
			opset(ACLFEBR, r)
			opset(ACLFDBR, r)
			opset(ACLGEBR, r)
			opset(ACLGDBR, r)
		case AFIEBR:
			opset(AFIDBR, r)
		case ACMPBEQ:
			opset(ACMPBGE, r)
			opset(ACMPBGT, r)
			opset(ACMPBLE, r)
			opset(ACMPBLT, r)
			opset(ACMPBNE, r)
		case ACMPUBEQ:
			opset(ACMPUBGE, r)
			opset(ACMPUBGT, r)
			opset(ACMPUBLE, r)
			opset(ACMPUBLT, r)
			opset(ACMPUBNE, r)
		case ACGRJ:
			opset(ACRJ, r)
		case ACLGRJ:
			opset(ACLRJ, r)
		case ACGIJ:
			opset(ACIJ, r)
		case ACLGIJ:
			opset(ACLIJ, r)
		case AMOVDEQ:
			opset(AMOVDGE, r)
			opset(AMOVDGT, r)
			opset(AMOVDLE, r)
			opset(AMOVDLT, r)
			opset(AMOVDNE, r)
		case ALOCGR:
			opset(ALOCR, r)
		case ALTDBR:
			opset(ALTEBR, r)
		case ATCDB:
			opset(ATCEB, r)
		case AVL:
			opset(AVLLEZB, r)
			opset(AVLLEZH, r)
			opset(AVLLEZF, r)
			opset(AVLLEZG, r)
			opset(AVLREPB, r)
			opset(AVLREPH, r)
			opset(AVLREPF, r)
			opset(AVLREPG, r)
		case AVLEG:
			opset(AVLBB, r)
			opset(AVLEB, r)
			opset(AVLEH, r)
			opset(AVLEF, r)
			opset(AVLEG, r)
			opset(AVLREP, r)
		case AVSTEG:
			opset(AVSTEB, r)
			opset(AVSTEH, r)
			opset(AVSTEF, r)
		case AVSCEG:
			opset(AVSCEF, r)
		case AVGEG:
			opset(AVGEF, r)
		case AVESLG:
			opset(AVESLB, r)
			opset(AVESLH, r)
			opset(AVESLF, r)
			opset(AVERLLB, r)
			opset(AVERLLH, r)
			opset(AVERLLF, r)
			opset(AVERLLG, r)
			opset(AVESRAB, r)
			opset(AVESRAH, r)
			opset(AVESRAF, r)
			opset(AVESRAG, r)
			opset(AVESRLB, r)
			opset(AVESRLH, r)
			opset(AVESRLF, r)
			opset(AVESRLG, r)
		case AVLGVG:
			opset(AVLGVB, r)
			opset(AVLGVH, r)
			opset(AVLGVF, r)
		case AVLVGG:
			opset(AVLVGB, r)
			opset(AVLVGH, r)
			opset(AVLVGF, r)
		case AVZERO:
			opset(AVONE, r)
		case AVREPIG:
			opset(AVREPIB, r)
			opset(AVREPIH, r)
			opset(AVREPIF, r)
		case AVLEIG:
			opset(AVLEIB, r)
			opset(AVLEIH, r)
			opset(AVLEIF, r)
		case AVGMG:
			opset(AVGMB, r)
			opset(AVGMH, r)
			opset(AVGMF, r)
		case AVREPG:
			opset(AVREPB, r)
			opset(AVREPH, r)
			opset(AVREPF, r)
		case AVERIMG:
			opset(AVERIMB, r)
			opset(AVERIMH, r)
			opset(AVERIMF, r)
		case AVFTCIDB:
			opset(AWFTCIDB, r)
		case AVLR:
			opset(AVUPHB, r)
			opset(AVUPHH, r)
			opset(AVUPHF, r)
			opset(AVUPLHB, r)
			opset(AVUPLHH, r)
			opset(AVUPLHF, r)
			opset(AVUPLB, r)
			opset(AVUPLHW, r)
			opset(AVUPLF, r)
			opset(AVUPLLB, r)
			opset(AVUPLLH, r)
			opset(AVUPLLF, r)
			opset(AVCLZB, r)
			opset(AVCLZH, r)
			opset(AVCLZF, r)
			opset(AVCLZG, r)
			opset(AVCTZB, r)
			opset(AVCTZH, r)
			opset(AVCTZF, r)
			opset(AVCTZG, r)
			opset(AVLDEB, r)
			opset(AWLDEB, r)
			opset(AVFLCDB, r)
			opset(AWFLCDB, r)
			opset(AVFLNDB, r)
			opset(AWFLNDB, r)
			opset(AVFLPDB, r)
			opset(AWFLPDB, r)
			opset(AVFSQDB, r)
			opset(AWFSQDB, r)
			opset(AVISTRB, r)
			opset(AVISTRH, r)
			opset(AVISTRF, r)
			opset(AVISTRBS, r)
			opset(AVISTRHS, r)
			opset(AVISTRFS, r)
			opset(AVLCB, r)
			opset(AVLCH, r)
			opset(AVLCF, r)
			opset(AVLCG, r)
			opset(AVLPB, r)
			opset(AVLPH, r)
			opset(AVLPF, r)
			opset(AVLPG, r)
			opset(AVPOPCT, r)
			opset(AVSEGB, r)
			opset(AVSEGH, r)
			opset(AVSEGF, r)
		case AVECG:
			opset(AVECB, r)
			opset(AVECH, r)
			opset(AVECF, r)
			opset(AVECLB, r)
			opset(AVECLH, r)
			opset(AVECLF, r)
			opset(AVECLG, r)
			opset(AWFCDB, r)
			opset(AWFKDB, r)
		case AVCEQG:
			opset(AVCEQB, r)
			opset(AVCEQH, r)
			opset(AVCEQF, r)
			opset(AVCEQBS, r)
			opset(AVCEQHS, r)
			opset(AVCEQFS, r)
			opset(AVCEQGS, r)
			opset(AVCHB, r)
			opset(AVCHH, r)
			opset(AVCHF, r)
			opset(AVCHG, r)
			opset(AVCHBS, r)
			opset(AVCHHS, r)
			opset(AVCHFS, r)
			opset(AVCHGS, r)
			opset(AVCHLB, r)
			opset(AVCHLH, r)
			opset(AVCHLF, r)
			opset(AVCHLG, r)
			opset(AVCHLBS, r)
			opset(AVCHLHS, r)
			opset(AVCHLFS, r)
			opset(AVCHLGS, r)
		case AVFAEF:
			opset(AVFAEB, r)
			opset(AVFAEH, r)
			opset(AVFAEBS, r)
			opset(AVFAEHS, r)
			opset(AVFAEFS, r)
			opset(AVFAEZB, r)
			opset(AVFAEZH, r)
			opset(AVFAEZF, r)
			opset(AVFAEZBS, r)
			opset(AVFAEZHS, r)
			opset(AVFAEZFS, r)
			opset(AVFEEB, r)
			opset(AVFEEH, r)
			opset(AVFEEF, r)
			opset(AVFEEBS, r)
			opset(AVFEEHS, r)
			opset(AVFEEFS, r)
			opset(AVFEEZB, r)
			opset(AVFEEZH, r)
			opset(AVFEEZF, r)
			opset(AVFEEZBS, r)
			opset(AVFEEZHS, r)
			opset(AVFEEZFS, r)
			opset(AVFENEB, r)
			opset(AVFENEH, r)
			opset(AVFENEF, r)
			opset(AVFENEBS, r)
			opset(AVFENEHS, r)
			opset(AVFENEFS, r)
			opset(AVFENEZB, r)
			opset(AVFENEZH, r)
			opset(AVFENEZF, r)
			opset(AVFENEZBS, r)
			opset(AVFENEZHS, r)
			opset(AVFENEZFS, r)
		case AVPKSG:
			opset(AVPKSH, r)
			opset(AVPKSF, r)
			opset(AVPKSHS, r)
			opset(AVPKSFS, r)
			opset(AVPKSGS, r)
			opset(AVPKLSH, r)
			opset(AVPKLSF, r)
			opset(AVPKLSG, r)
			opset(AVPKLSHS, r)
			opset(AVPKLSFS, r)
			opset(AVPKLSGS, r)
		case AVAQ:
			opset(AVAB, r)
			opset(AVAH, r)
			opset(AVAF, r)
			opset(AVAG, r)
			opset(AVACCB, r)
			opset(AVACCH, r)
			opset(AVACCF, r)
			opset(AVACCG, r)
			opset(AVACCQ, r)
			opset(AVN, r)
			opset(AVNC, r)
			opset(AVAVGB, r)
			opset(AVAVGH, r)
			opset(AVAVGF, r)
			opset(AVAVGG, r)
			opset(AVAVGLB, r)
			opset(AVAVGLH, r)
			opset(AVAVGLF, r)
			opset(AVAVGLG, r)
			opset(AVCKSM, r)
			opset(AVX, r)
			opset(AVFADB, r)
			opset(AWFADB, r)
			opset(AVFCEDB, r)
			opset(AVFCEDBS, r)
			opset(AWFCEDB, r)
			opset(AWFCEDBS, r)
			opset(AVFCHDB, r)
			opset(AVFCHDBS, r)
			opset(AWFCHDB, r)
			opset(AWFCHDBS, r)
			opset(AVFCHEDB, r)
			opset(AVFCHEDBS, r)
			opset(AWFCHEDB, r)
			opset(AWFCHEDBS, r)
			opset(AVFMDB, r)
			opset(AWFMDB, r)
			opset(AVGFMB, r)
			opset(AVGFMH, r)
			opset(AVGFMF, r)
			opset(AVGFMG, r)
			opset(AVMXB, r)
			opset(AVMXH, r)
			opset(AVMXF, r)
			opset(AVMXG, r)
			opset(AVMXLB, r)
			opset(AVMXLH, r)
			opset(AVMXLF, r)
			opset(AVMXLG, r)
			opset(AVMNB, r)
			opset(AVMNH, r)
			opset(AVMNF, r)
			opset(AVMNG, r)
			opset(AVMNLB, r)
			opset(AVMNLH, r)
			opset(AVMNLF, r)
			opset(AVMNLG, r)
			opset(AVMRHB, r)
			opset(AVMRHH, r)
			opset(AVMRHF, r)
			opset(AVMRHG, r)
			opset(AVMRLB, r)
			opset(AVMRLH, r)
			opset(AVMRLF, r)
			opset(AVMRLG, r)
			opset(AVMEB, r)
			opset(AVMEH, r)
			opset(AVMEF, r)
			opset(AVMLEB, r)
			opset(AVMLEH, r)
			opset(AVMLEF, r)
			opset(AVMOB, r)
			opset(AVMOH, r)
			opset(AVMOF, r)
			opset(AVMLOB, r)
			opset(AVMLOH, r)
			opset(AVMLOF, r)
			opset(AVMHB, r)
			opset(AVMHH, r)
			opset(AVMHF, r)
			opset(AVMLHB, r)
			opset(AVMLHH, r)
			opset(AVMLHF, r)
			opset(AVMLH, r)
			opset(AVMLHW, r)
			opset(AVMLF, r)
			opset(AVNO, r)
			opset(AVO, r)
			opset(AVPKH, r)
			opset(AVPKF, r)
			opset(AVPKG, r)
			opset(AVSUMGH, r)
			opset(AVSUMGF, r)
			opset(AVSUMQF, r)
			opset(AVSUMQG, r)
			opset(AVSUMB, r)
			opset(AVSUMH, r)
		case AVERLLVG:
			opset(AVERLLVB, r)
			opset(AVERLLVH, r)
			opset(AVERLLVF, r)
			opset(AVESLVB, r)
			opset(AVESLVH, r)
			opset(AVESLVF, r)
			opset(AVESLVG, r)
			opset(AVESRAVB, r)
			opset(AVESRAVH, r)
			opset(AVESRAVF, r)
			opset(AVESRAVG, r)
			opset(AVESRLVB, r)
			opset(AVESRLVH, r)
			opset(AVESRLVF, r)
			opset(AVESRLVG, r)
			opset(AVFDDB, r)
			opset(AWFDDB, r)
			opset(AVFSDB, r)
			opset(AWFSDB, r)
			opset(AVSL, r)
			opset(AVSLB, r)
			opset(AVSRA, r)
			opset(AVSRAB, r)
			opset(AVSRL, r)
			opset(AVSRLB, r)
			opset(AVSB, r)
			opset(AVSH, r)
			opset(AVSF, r)
			opset(AVSG, r)
			opset(AVSQ, r)
			opset(AVSCBIB, r)
			opset(AVSCBIH, r)
			opset(AVSCBIF, r)
			opset(AVSCBIG, r)
			opset(AVSCBIQ, r)
		case AVACQ:
			opset(AVACCCQ, r)
			opset(AVGFMAB, r)
			opset(AVGFMAH, r)
			opset(AVGFMAF, r)
			opset(AVGFMAG, r)
			opset(AVMALB, r)
			opset(AVMALHW, r)
			opset(AVMALF, r)
			opset(AVMAHB, r)
			opset(AVMAHH, r)
			opset(AVMAHF, r)
			opset(AVMALHB, r)
			opset(AVMALHH, r)
			opset(AVMALHF, r)
			opset(AVMAEB, r)
			opset(AVMAEH, r)
			opset(AVMAEF, r)
			opset(AVMALEB, r)
			opset(AVMALEH, r)
			opset(AVMALEF, r)
			opset(AVMAOB, r)
			opset(AVMAOH, r)
			opset(AVMAOF, r)
			opset(AVMALOB, r)
			opset(AVMALOH, r)
			opset(AVMALOF, r)
			opset(AVSTRC, r)
			opset(AVSTRCB, r)
			opset(AVSTRCH, r)
			opset(AVSTRCF, r)
			opset(AVSTRCBS, r)
			opset(AVSTRCHS, r)
			opset(AVSTRCFS, r)
			opset(AVSTRCZB, r)
			opset(AVSTRCZH, r)
			opset(AVSTRCZF, r)
			opset(AVSTRCZBS, r)
			opset(AVSTRCZHS, r)
			opset(AVSTRCZFS, r)
			opset(AVSBCBIQ, r)
			opset(AVSBIQ, r)
			opset(AVMSLG, r)
			opset(AVMSLEG, r)
			opset(AVMSLOG, r)
			opset(AVMSLEOG, r)
		case AVSEL:
			opset(AVFMADB, r)
			opset(AWFMADB, r)
			opset(AVFMSDB, r)
			opset(AWFMSDB, r)
			opset(AVPERM, r)
		case AKM:
			opset(AKMC, r)
			opset(AKLMD, r)
			opset(AKIMD, r)
		case AKMA:
			opset(AKMCTR, r)
		}
	}
}

const (
	op_A       uint32 = 0x5A00 // FORMAT_RX1        ADD (32)
	op_AD      uint32 = 0x6A00 // FORMAT_RX1        ADD NORMALIZED (long HFP)
	op_ADB     uint32 = 0xED1A // FORMAT_RXE        ADD (long BFP)
	op_ADBR    uint32 = 0xB31A // FORMAT_RRE        ADD (long BFP)
	op_ADR     uint32 = 0x2A00 // FORMAT_RR         ADD NORMALIZED (long HFP)
	op_ADTR    uint32 = 0xB3D2 // FORMAT_RRF1       ADD (long DFP)
	op_ADTRA   uint32 = 0xB3D2 // FORMAT_RRF1       ADD (long DFP)
	op_AE      uint32 = 0x7A00 // FORMAT_RX1        ADD NORMALIZED (short HFP)
	op_AEB     uint32 = 0xED0A // FORMAT_RXE        ADD (short BFP)
	op_AEBR    uint32 = 0xB30A // FORMAT_RRE        ADD (short BFP)
	op_AER     uint32 = 0x3A00 // FORMAT_RR         ADD NORMALIZED (short HFP)
	op_AFI     uint32 = 0xC209 // FORMAT_RIL1       ADD IMMEDIATE (32)
	op_AG      uint32 = 0xE308 // FORMAT_RXY1       ADD (64)
	op_AGF     uint32 = 0xE318 // FORMAT_RXY1       ADD (64<-32)
	op_AGFI    uint32 = 0xC208 // FORMAT_RIL1       ADD IMMEDIATE (64<-32)
	op_AGFR    uint32 = 0xB918 // FORMAT_RRE        ADD (64<-32)
	op_AGHI    uint32 = 0xA70B // FORMAT_RI1        ADD HALFWORD IMMEDIATE (64)
	op_AGHIK   uint32 = 0xECD9 // FORMAT_RIE4       ADD IMMEDIATE (64<-16)
	op_AGR     uint32 = 0xB908 // FORMAT_RRE        ADD (64)
	op_AGRK    uint32 = 0xB9E8 // FORMAT_RRF1       ADD (64)
	op_AGSI    uint32 = 0xEB7A // FORMAT_SIY        ADD IMMEDIATE (64<-8)
	op_AH      uint32 = 0x4A00 // FORMAT_RX1        ADD HALFWORD
	op_AHHHR   uint32 = 0xB9C8 // FORMAT_RRF1       ADD HIGH (32)
	op_AHHLR   uint32 = 0xB9D8 // FORMAT_RRF1       ADD HIGH (32)
	op_AHI     uint32 = 0xA70A // FORMAT_RI1        ADD HALFWORD IMMEDIATE (32)
	op_AHIK    uint32 = 0xECD8 // FORMAT_RIE4       ADD IMMEDIATE (32<-16)
	op_AHY     uint32 = 0xE37A // FORMAT_RXY1       ADD HALFWORD
	op_AIH     uint32 = 0xCC08 // FORMAT_RIL1       ADD IMMEDIATE HIGH (32)
	op_AL      uint32 = 0x5E00 // FORMAT_RX1        ADD LOGICAL (32)
	op_ALC     uint32 = 0xE398 // FORMAT_RXY1       ADD LOGICAL WITH CARRY (32)
	op_ALCG    uint32 = 0xE388 // FORMAT_RXY1       ADD LOGICAL WITH CARRY (64)
	op_ALCGR   uint32 = 0xB988 // FORMAT_RRE        ADD LOGICAL WITH CARRY (64)
	op_ALCR    uint32 = 0xB998 // FORMAT_RRE        ADD LOGICAL WITH CARRY (32)
	op_ALFI    uint32 = 0xC20B // FORMAT_RIL1       ADD LOGICAL IMMEDIATE (32)
	op_ALG     uint32 = 0xE30A // FORMAT_RXY1       ADD LOGICAL (64)
	op_ALGF    uint32 = 0xE31A // FORMAT_RXY1       ADD LOGICAL (64<-32)
	op_ALGFI   uint32 = 0xC20A // FORMAT_RIL1       ADD LOGICAL IMMEDIATE (64<-32)
	op_ALGFR   uint32 = 0xB91A // FORMAT_RRE        ADD LOGICAL (64<-32)
	op_ALGHSIK uint32 = 0xECDB // FORMAT_RIE4       ADD LOGICAL WITH SIGNED IMMEDIATE (64<-16)
	op_ALGR    uint32 = 0xB90A // FORMAT_RRE        ADD LOGICAL (64)
	op_ALGRK   uint32 = 0xB9EA // FORMAT_RRF1       ADD LOGICAL (64)
	op_ALGSI   uint32 = 0xEB7E // FORMAT_SIY        ADD LOGICAL WITH SIGNED IMMEDIATE (64<-8)
	op_ALHHHR  uint32 = 0xB9CA // FORMAT_RRF1       ADD LOGICAL HIGH (32)
	op_ALHHLR  uint32 = 0xB9DA // FORMAT_RRF1       ADD LOGICAL HIGH (32)
	op_ALHSIK  uint32 = 0xECDA // FORMAT_RIE4       ADD LOGICAL WITH SIGNED IMMEDIATE (32<-16)
	op_ALR     uint32 = 0x1E00 // FORMAT_RR         ADD LOGICAL (32)
	op_ALRK    uint32 = 0xB9FA // FORMAT_RRF1       ADD LOGICAL (32)
	op_ALSI    uint32 = 0xEB6E // FORMAT_SIY        ADD LOGICAL WITH SIGNED IMMEDIATE (32<-8)
	op_ALSIH   uint32 = 0xCC0A // FORMAT_RIL1       ADD LOGICAL WITH SIGNED IMMEDIATE HIGH (32)
	op_ALSIHN  uint32 = 0xCC0B // FORMAT_RIL1       ADD LOGICAL WITH SIGNED IMMEDIATE HIGH (32)
	op_ALY     uint32 = 0xE35E // FORMAT_RXY1       ADD LOGICAL (32)
	op_AP      uint32 = 0xFA00 // FORMAT_SS2        ADD DECIMAL
	op_AR      uint32 = 0x1A00 // FORMAT_RR         ADD (32)
	op_ARK     uint32 = 0xB9F8 // FORMAT_RRF1       ADD (32)
	op_ASI     uint32 = 0xEB6A // FORMAT_SIY        ADD IMMEDIATE (32<-8)
	op_AU      uint32 = 0x7E00 // FORMAT_RX1        ADD UNNORMALIZED (short HFP)
	op_AUR     uint32 = 0x3E00 // FORMAT_RR         ADD UNNORMALIZED (short HFP)
	op_AW      uint32 = 0x6E00 // FORMAT_RX1        ADD UNNORMALIZED (long HFP)
	op_AWR     uint32 = 0x2E00 // FORMAT_RR         ADD UNNORMALIZED (long HFP)
	op_AXBR    uint32 = 0xB34A // FORMAT_RRE        ADD (extended BFP)
	op_AXR     uint32 = 0x3600 // FORMAT_RR         ADD NORMALIZED (extended HFP)
	op_AXTR    uint32 = 0xB3DA // FORMAT_RRF1       ADD (extended DFP)
	op_AXTRA   uint32 = 0xB3DA // FORMAT_RRF1       ADD (extended DFP)
	op_AY      uint32 = 0xE35A // FORMAT_RXY1       ADD (32)
	op_BAKR    uint32 = 0xB240 // FORMAT_RRE        BRANCH AND STACK
	op_BAL     uint32 = 0x4500 // FORMAT_RX1        BRANCH AND LINK
	op_BALR    uint32 = 0x0500 // FORMAT_RR         BRANCH AND LINK
	op_BAS     uint32 = 0x4D00 // FORMAT_RX1        BRANCH AND SAVE
	op_BASR    uint32 = 0x0D00 // FORMAT_RR         BRANCH AND SAVE
	op_BASSM   uint32 = 0x0C00 // FORMAT_RR         BRANCH AND SAVE AND SET MODE
	op_BC      uint32 = 0x4700 // FORMAT_RX2        BRANCH ON CONDITION
	op_BCR     uint32 = 0x0700 // FORMAT_RR         BRANCH ON CONDITION
	op_BCT     uint32 = 0x4600 // FORMAT_RX1        BRANCH ON COUNT (32)
	op_BCTG    uint32 = 0xE346 // FORMAT_RXY1       BRANCH ON COUNT (64)
	op_BCTGR   uint32 = 0xB946 // FORMAT_RRE        BRANCH ON COUNT (64)
	op_BCTR    uint32 = 0x0600 // FORMAT_RR         BRANCH ON COUNT (32)
	op_BPP     uint32 = 0xC700 // FORMAT_SMI        BRANCH PREDICTION PRELOAD
	op_BPRP    uint32 = 0xC500 // FORMAT_MII        BRANCH PREDICTION RELATIVE PRELOAD
	op_BRAS    uint32 = 0xA705 // FORMAT_RI2        BRANCH RELATIVE AND SAVE
	op_BRASL   uint32 = 0xC005 // FORMAT_RIL2       BRANCH RELATIVE AND SAVE LONG
	op_BRC     uint32 = 0xA704 // FORMAT_RI3        BRANCH RELATIVE ON CONDITION
	op_BRCL    uint32 = 0xC004 // FORMAT_RIL3       BRANCH RELATIVE ON CONDITION LONG
	op_BRCT    uint32 = 0xA706 // FORMAT_RI2        BRANCH RELATIVE ON COUNT (32)
	op_BRCTG   uint32 = 0xA707 // FORMAT_RI2        BRANCH RELATIVE ON COUNT (64)
	op_BRCTH   uint32 = 0xCC06 // FORMAT_RIL2       BRANCH RELATIVE ON COUNT HIGH (32)
	op_BRXH    uint32 = 0x8400 // FORMAT_RSI        BRANCH RELATIVE ON INDEX HIGH (32)
	op_BRXHG   uint32 = 0xEC44 // FORMAT_RIE5       BRANCH RELATIVE ON INDEX HIGH (64)
	op_BRXLE   uint32 = 0x8500 // FORMAT_RSI        BRANCH RELATIVE ON INDEX LOW OR EQ. (32)
	op_BRXLG   uint32 = 0xEC45 // FORMAT_RIE5       BRANCH RELATIVE ON INDEX LOW OR EQ. (64)
	op_BSA     uint32 = 0xB25A // FORMAT_RRE        BRANCH AND SET AUTHORITY
	op_BSG     uint32 = 0xB258 // FORMAT_RRE        BRANCH IN SUBSPACE GROUP
	op_BSM     uint32 = 0x0B00 // FORMAT_RR         BRANCH AND SET MODE
	op_BXH     uint32 = 0x8600 // FORMAT_RS1        BRANCH ON INDEX HIGH (32)
	op_BXHG    uint32 = 0xEB44 // FORMAT_RSY1       BRANCH ON INDEX HIGH (64)
	op_BXLE    uint32 = 0x8700 // FORMAT_RS1        BRANCH ON INDEX LOW OR EQUAL (32)
	op_BXLEG   uint32 = 0xEB45 // FORMAT_RSY1       BRANCH ON INDEX LOW OR EQUAL (64)
	op_C       uint32 = 0x5900 // FORMAT_RX1        COMPARE (32)
	op_CD      uint32 = 0x6900 // FORMAT_RX1        COMPARE (long HFP)
	op_CDB     uint32 = 0xED19 // FORMAT_RXE        COMPARE (long BFP)
	op_CDBR    uint32 = 0xB319 // FORMAT_RRE        COMPARE (long BFP)
	op_CDFBR   uint32 = 0xB395 // FORMAT_RRE        CONVERT FROM FIXED (32 to long BFP)
	op_CDFBRA  uint32 = 0xB395 // FORMAT_RRF5       CONVERT FROM FIXED (32 to long BFP)
	op_CDFR    uint32 = 0xB3B5 // FORMAT_RRE        CONVERT FROM FIXED (32 to long HFP)
	op_CDFTR   uint32 = 0xB951 // FORMAT_RRE        CONVERT FROM FIXED (32 to long DFP)
	op_CDGBR   uint32 = 0xB3A5 // FORMAT_RRE        CONVERT FROM FIXED (64 to long BFP)
	op_CDGBRA  uint32 = 0xB3A5 // FORMAT_RRF5       CONVERT FROM FIXED (64 to long BFP)
	op_CDGR    uint32 = 0xB3C5 // FORMAT_RRE        CONVERT FROM FIXED (64 to long HFP)
	op_CDGTR   uint32 = 0xB3F1 // FORMAT_RRE        CONVERT FROM FIXED (64 to long DFP)
	op_CDGTRA  uint32 = 0xB3F1 // FORMAT_RRF5       CONVERT FROM FIXED (64 to long DFP)
	op_CDLFBR  uint32 = 0xB391 // FORMAT_RRF5       CONVERT FROM LOGICAL (32 to long BFP)
	op_CDLFTR  uint32 = 0xB953 // FORMAT_RRF5       CONVERT FROM LOGICAL (32 to long DFP)
	op_CDLGBR  uint32 = 0xB3A1 // FORMAT_RRF5       CONVERT FROM LOGICAL (64 to long BFP)
	op_CDLGTR  uint32 = 0xB952 // FORMAT_RRF5       CONVERT FROM LOGICAL (64 to long DFP)
	op_CDR     uint32 = 0x2900 // FORMAT_RR         COMPARE (long HFP)
	op_CDS     uint32 = 0xBB00 // FORMAT_RS1        COMPARE DOUBLE AND SWAP (32)
	op_CDSG    uint32 = 0xEB3E // FORMAT_RSY1       COMPARE DOUBLE AND SWAP (64)
	op_CDSTR   uint32 = 0xB3F3 // FORMAT_RRE        CONVERT FROM SIGNED PACKED (64 to long DFP)
	op_CDSY    uint32 = 0xEB31 // FORMAT_RSY1       COMPARE DOUBLE AND SWAP (32)
	op_CDTR    uint32 = 0xB3E4 // FORMAT_RRE        COMPARE (long DFP)
	op_CDUTR   uint32 = 0xB3F2 // FORMAT_RRE        CONVERT FROM UNSIGNED PACKED (64 to long DFP)
	op_CDZT    uint32 = 0xEDAA // FORMAT_RSL        CONVERT FROM ZONED (to long DFP)
	op_CE      uint32 = 0x7900 // FORMAT_RX1        COMPARE (short HFP)
	op_CEB     uint32 = 0xED09 // FORMAT_RXE        COMPARE (short BFP)
	op_CEBR    uint32 = 0xB309 // FORMAT_RRE        COMPARE (short BFP)
	op_CEDTR   uint32 = 0xB3F4 // FORMAT_RRE        COMPARE BIASED EXPONENT (long DFP)
	op_CEFBR   uint32 = 0xB394 // FORMAT_RRE        CONVERT FROM FIXED (32 to short BFP)
	op_CEFBRA  uint32 = 0xB394 // FORMAT_RRF5       CONVERT FROM FIXED (32 to short BFP)
	op_CEFR    uint32 = 0xB3B4 // FORMAT_RRE        CONVERT FROM FIXED (32 to short HFP)
	op_CEGBR   uint32 = 0xB3A4 // FORMAT_RRE        CONVERT FROM FIXED (64 to short BFP)
	op_CEGBRA  uint32 = 0xB3A4 // FORMAT_RRF5       CONVERT FROM FIXED (64 to short BFP)
	op_CEGR    uint32 = 0xB3C4 // FORMAT_RRE        CONVERT FROM FIXED (64 to short HFP)
	op_CELFBR  uint32 = 0xB390 // FORMAT_RRF5       CONVERT FROM LOGICAL (32 to short BFP)
	op_CELGBR  uint32 = 0xB3A0 // FORMAT_RRF5       CONVERT FROM LOGICAL (64 to short BFP)
	op_CER     uint32 = 0x3900 // FORMAT_RR         COMPARE (short HFP)
	op_CEXTR   uint32 = 0xB3FC // FORMAT_RRE        COMPARE BIASED EXPONENT (extended DFP)
	op_CFC     uint32 = 0xB21A // FORMAT_S          COMPARE AND FORM CODEWORD
	op_CFDBR   uint32 = 0xB399 // FORMAT_RRF5       CONVERT TO FIXED (long BFP to 32)
	op_CFDBRA  uint32 = 0xB399 // FORMAT_RRF5       CONVERT TO FIXED (long BFP to 32)
	op_CFDR    uint32 = 0xB3B9 // FORMAT_RRF5       CONVERT TO FIXED (long HFP to 32)
	op_CFDTR   uint32 = 0xB941 // FORMAT_RRF5       CONVERT TO FIXED (long DFP to 32)
	op_CFEBR   uint32 = 0xB398 // FORMAT_RRF5       CONVERT TO FIXED (short BFP to 32)
	op_CFEBRA  uint32 = 0xB398 // FORMAT_RRF5       CONVERT TO FIXED (short BFP to 32)
	op_CFER    uint32 = 0xB3B8 // FORMAT_RRF5       CONVERT TO FIXED (short HFP to 32)
	op_CFI     uint32 = 0xC20D // FORMAT_RIL1       COMPARE IMMEDIATE (32)
	op_CFXBR   uint32 = 0xB39A // FORMAT_RRF5       CONVERT TO FIXED (extended BFP to 32)
	op_CFXBRA  uint32 = 0xB39A // FORMAT_RRF5       CONVERT TO FIXED (extended BFP to 32)
	op_CFXR    uint32 = 0xB3BA // FORMAT_RRF5       CONVERT TO FIXED (extended HFP to 32)
	op_CFXTR   uint32 = 0xB949 // FORMAT_RRF5       CONVERT TO FIXED (extended DFP to 32)
	op_CG      uint32 = 0xE320 // FORMAT_RXY1       COMPARE (64)
	op_CGDBR   uint32 = 0xB3A9 // FORMAT_RRF5       CONVERT TO FIXED (long BFP to 64)
	op_CGDBRA  uint32 = 0xB3A9 // FORMAT_RRF5       CONVERT TO FIXED (long BFP to 64)
	op_CGDR    uint32 = 0xB3C9 // FORMAT_RRF5       CONVERT TO FIXED (long HFP to 64)
	op_CGDTR   uint32 = 0xB3E1 // FORMAT_RRF5       CONVERT TO FIXED (long DFP to 64)
	op_CGDTRA  uint32 = 0xB3E1 // FORMAT_RRF5       CONVERT TO FIXED (long DFP to 64)
	op_CGEBR   uint32 = 0xB3A8 // FORMAT_RRF5       CONVERT TO FIXED (short BFP to 64)
	op_CGEBRA  uint32 = 0xB3A8 // FORMAT_RRF5       CONVERT TO FIXED (short BFP to 64)
	op_CGER    uint32 = 0xB3C8 // FORMAT_RRF5       CONVERT TO FIXED (short HFP to 64)
	op_CGF     uint32 = 0xE330 // FORMAT_RXY1       COMPARE (64<-32)
	op_CGFI    uint32 = 0xC20C // FORMAT_RIL1       COMPARE IMMEDIATE (64<-32)
	op_CGFR    uint32 = 0xB930 // FORMAT_RRE        COMPARE (64<-32)
	op_CGFRL   uint32 = 0xC60C // FORMAT_RIL2       COMPARE RELATIVE LONG (64<-32)
	op_CGH     uint32 = 0xE334 // FORMAT_RXY1       COMPARE HALFWORD (64<-16)
	op_CGHI    uint32 = 0xA70F // FORMAT_RI1        COMPARE HALFWORD IMMEDIATE (64<-16)
	op_CGHRL   uint32 = 0xC604 // FORMAT_RIL2       COMPARE HALFWORD RELATIVE LONG (64<-16)
	op_CGHSI   uint32 = 0xE558 // FORMAT_SIL        COMPARE HALFWORD IMMEDIATE (64<-16)
	op_CGIB    uint32 = 0xECFC // FORMAT_RIS        COMPARE IMMEDIATE AND BRANCH (64<-8)
	op_CGIJ    uint32 = 0xEC7C // FORMAT_RIE3       COMPARE IMMEDIATE AND BRANCH RELATIVE (64<-8)
	op_CGIT    uint32 = 0xEC70 // FORMAT_RIE1       COMPARE IMMEDIATE AND TRAP (64<-16)
	op_CGR     uint32 = 0xB920 // FORMAT_RRE        COMPARE (64)
	op_CGRB    uint32 = 0xECE4 // FORMAT_RRS        COMPARE AND BRANCH (64)
	op_CGRJ    uint32 = 0xEC64 // FORMAT_RIE2       COMPARE AND BRANCH RELATIVE (64)
	op_CGRL    uint32 = 0xC608 // FORMAT_RIL2       COMPARE RELATIVE LONG (64)
	op_CGRT    uint32 = 0xB960 // FORMAT_RRF3       COMPARE AND TRAP (64)
	op_CGXBR   uint32 = 0xB3AA // FORMAT_RRF5       CONVERT TO FIXED (extended BFP to 64)
	op_CGXBRA  uint32 = 0xB3AA // FORMAT_RRF5       CONVERT TO FIXED (extended BFP to 64)
	op_CGXR    uint32 = 0xB3CA // FORMAT_RRF5       CONVERT TO FIXED (extended HFP to 64)
	op_CGXTR   uint32 = 0xB3E9 // FORMAT_RRF5       CONVERT TO FIXED (extended DFP to 64)
	op_CGXTRA  uint32 = 0xB3E9 // FORMAT_RRF5       CONVERT TO FIXED (extended DFP to 64)
	op_CH      uint32 = 0x4900 // FORMAT_RX1        COMPARE HALFWORD (32<-16)
	op_CHF     uint32 = 0xE3CD // FORMAT_RXY1       COMPARE HIGH (32)
	op_CHHR    uint32 = 0xB9CD // FORMAT_RRE        COMPARE HIGH (32)
	op_CHHSI   uint32 = 0xE554 // FORMAT_SIL        COMPARE HALFWORD IMMEDIATE (16)
	op_CHI     uint32 = 0xA70E // FORMAT_RI1        COMPARE HALFWORD IMMEDIATE (32<-16)
	op_CHLR    uint32 = 0xB9DD // FORMAT_RRE        COMPARE HIGH (32)
	op_CHRL    uint32 = 0xC605 // FORMAT_RIL2       COMPARE HALFWORD RELATIVE LONG (32<-16)
	op_CHSI    uint32 = 0xE55C // FORMAT_SIL        COMPARE HALFWORD IMMEDIATE (32<-16)
	op_CHY     uint32 = 0xE379 // FORMAT_RXY1       COMPARE HALFWORD (32<-16)
	op_CIB     uint32 = 0xECFE // FORMAT_RIS        COMPARE IMMEDIATE AND BRANCH (32<-8)
	op_CIH     uint32 = 0xCC0D // FORMAT_RIL1       COMPARE IMMEDIATE HIGH (32)
	op_CIJ     uint32 = 0xEC7E // FORMAT_RIE3       COMPARE IMMEDIATE AND BRANCH RELATIVE (32<-8)
	op_CIT     uint32 = 0xEC72 // FORMAT_RIE1       COMPARE IMMEDIATE AND TRAP (32<-16)
	op_CKSM    uint32 = 0xB241 // FORMAT_RRE        CHECKSUM
	op_CL      uint32 = 0x5500 // FORMAT_RX1        COMPARE LOGICAL (32)
	op_CLC     uint32 = 0xD500 // FORMAT_SS1        COMPARE LOGICAL (character)
	op_CLCL    uint32 = 0x0F00 // FORMAT_RR         COMPARE LOGICAL LONG
	op_CLCLE   uint32 = 0xA900 // FORMAT_RS1        COMPARE LOGICAL LONG EXTENDED
	op_CLCLU   uint32 = 0xEB8F // FORMAT_RSY1       COMPARE LOGICAL LONG UNICODE
	op_CLFDBR  uint32 = 0xB39D // FORMAT_RRF5       CONVERT TO LOGICAL (long BFP to 32)
	op_CLFDTR  uint32 = 0xB943 // FORMAT_RRF5       CONVERT TO LOGICAL (long DFP to 32)
	op_CLFEBR  uint32 = 0xB39C // FORMAT_RRF5       CONVERT TO LOGICAL (short BFP to 32)
	op_CLFHSI  uint32 = 0xE55D // FORMAT_SIL        COMPARE LOGICAL IMMEDIATE (32<-16)
	op_CLFI    uint32 = 0xC20F // FORMAT_RIL1       COMPARE LOGICAL IMMEDIATE (32)
	op_CLFIT   uint32 = 0xEC73 // FORMAT_RIE1       COMPARE LOGICAL IMMEDIATE AND TRAP (32<-16)
	op_CLFXBR  uint32 = 0xB39E // FORMAT_RRF5       CONVERT TO LOGICAL (extended BFP to 32)
	op_CLFXTR  uint32 = 0xB94B // FORMAT_RRF5       CONVERT TO LOGICAL (extended DFP to 32)
	op_CLG     uint32 = 0xE321 // FORMAT_RXY1       COMPARE LOGICAL (64)
	op_CLGDBR  uint32 = 0xB3AD // FORMAT_RRF5       CONVERT TO LOGICAL (long BFP to 64)
	op_CLGDTR  uint32 = 0xB942 // FORMAT_RRF5       CONVERT TO LOGICAL (long DFP to 64)
	op_CLGEBR  uint32 = 0xB3AC // FORMAT_RRF5       CONVERT TO LOGICAL (short BFP to 64)
	op_CLGF    uint32 = 0xE331 // FORMAT_RXY1       COMPARE LOGICAL (64<-32)
	op_CLGFI   uint32 = 0xC20E // FORMAT_RIL1       COMPARE LOGICAL IMMEDIATE (64<-32)
	op_CLGFR   uint32 = 0xB931 // FORMAT_RRE        COMPARE LOGICAL (64<-32)
	op_CLGFRL  uint32 = 0xC60E // FORMAT_RIL2       COMPARE LOGICAL RELATIVE LONG (64<-32)
	op_CLGHRL  uint32 = 0xC606 // FORMAT_RIL2       COMPARE LOGICAL RELATIVE LONG (64<-16)
	op_CLGHSI  uint32 = 0xE559 // FORMAT_SIL        COMPARE LOGICAL IMMEDIATE (64<-16)
	op_CLGIB   uint32 = 0xECFD // FORMAT_RIS        COMPARE LOGICAL IMMEDIATE AND BRANCH (64<-8)
	op_CLGIJ   uint32 = 0xEC7D // FORMAT_RIE3       COMPARE LOGICAL IMMEDIATE AND BRANCH RELATIVE (64<-8)
	op_CLGIT   uint32 = 0xEC71 // FORMAT_RIE1       COMPARE LOGICAL IMMEDIATE AND TRAP (64<-16)
	op_CLGR    uint32 = 0xB921 // FORMAT_RRE        COMPARE LOGICAL (64)
	op_CLGRB   uint32 = 0xECE5 // FORMAT_RRS        COMPARE LOGICAL AND BRANCH (64)
	op_CLGRJ   uint32 = 0xEC65 // FORMAT_RIE2       COMPARE LOGICAL AND BRANCH RELATIVE (64)
	op_CLGRL   uint32 = 0xC60A // FORMAT_RIL2       COMPARE LOGICAL RELATIVE LONG (64)
	op_CLGRT   uint32 = 0xB961 // FORMAT_RRF3       COMPARE LOGICAL AND TRAP (64)
	op_CLGT    uint32 = 0xEB2B // FORMAT_RSY2       COMPARE LOGICAL AND TRAP (64)
	op_CLGXBR  uint32 = 0xB3AE // FORMAT_RRF5       CONVERT TO LOGICAL (extended BFP to 64)
	op_CLGXTR  uint32 = 0xB94A // FORMAT_RRF5       CONVERT TO LOGICAL (extended DFP to 64)
	op_CLHF    uint32 = 0xE3CF // FORMAT_RXY1       COMPARE LOGICAL HIGH (32)
	op_CLHHR   uint32 = 0xB9CF // FORMAT_RRE        COMPARE LOGICAL HIGH (32)
	op_CLHHSI  uint32 = 0xE555 // FORMAT_SIL        COMPARE LOGICAL IMMEDIATE (16)
	op_CLHLR   uint32 = 0xB9DF // FORMAT_RRE        COMPARE LOGICAL HIGH (32)
	op_CLHRL   uint32 = 0xC607 // FORMAT_RIL2       COMPARE LOGICAL RELATIVE LONG (32<-16)
	op_CLI     uint32 = 0x9500 // FORMAT_SI         COMPARE LOGICAL (immediate)
	op_CLIB    uint32 = 0xECFF // FORMAT_RIS        COMPARE LOGICAL IMMEDIATE AND BRANCH (32<-8)
	op_CLIH    uint32 = 0xCC0F // FORMAT_RIL1       COMPARE LOGICAL IMMEDIATE HIGH (32)
	op_CLIJ    uint32 = 0xEC7F // FORMAT_RIE3       COMPARE LOGICAL IMMEDIATE AND BRANCH RELATIVE (32<-8)
	op_CLIY    uint32 = 0xEB55 // FORMAT_SIY        COMPARE LOGICAL (immediate)
	op_CLM     uint32 = 0xBD00 // FORMAT_RS2        COMPARE LOGICAL CHAR. UNDER MASK (low)
	op_CLMH    uint32 = 0xEB20 // FORMAT_RSY2       COMPARE LOGICAL CHAR. UNDER MASK (high)
	op_CLMY    uint32 = 0xEB21 // FORMAT_RSY2       COMPARE LOGICAL CHAR. UNDER MASK (low)
	op_CLR     uint32 = 0x1500 // FORMAT_RR         COMPARE LOGICAL (32)
	op_CLRB    uint32 = 0xECF7 // FORMAT_RRS        COMPARE LOGICAL AND BRANCH (32)
	op_CLRJ    uint32 = 0xEC77 // FORMAT_RIE2       COMPARE LOGICAL AND BRANCH RELATIVE (32)
	op_CLRL    uint32 = 0xC60F // FORMAT_RIL2       COMPARE LOGICAL RELATIVE LONG (32)
	op_CLRT    uint32 = 0xB973 // FORMAT_RRF3       COMPARE LOGICAL AND TRAP (32)
	op_CLST    uint32 = 0xB25D // FORMAT_RRE        COMPARE LOGICAL STRING
	op_CLT     uint32 = 0xEB23 // FORMAT_RSY2       COMPARE LOGICAL AND TRAP (32)
	op_CLY     uint32 = 0xE355 // FORMAT_RXY1       COMPARE LOGICAL (32)
	op_CMPSC   uint32 = 0xB263 // FORMAT_RRE        COMPRESSION CALL
	op_CP      uint32 = 0xF900 // FORMAT_SS2        COMPARE DECIMAL
	op_CPSDR   uint32 = 0xB372 // FORMAT_RRF2       COPY SIGN (long)
	op_CPYA    uint32 = 0xB24D // FORMAT_RRE        COPY ACCESS
	op_CR      uint32 = 0x1900 // FORMAT_RR         COMPARE (32)
	op_CRB     uint32 = 0xECF6 // FORMAT_RRS        COMPARE AND BRANCH (32)
	op_CRDTE   uint32 = 0xB98F // FORMAT_RRF2       COMPARE AND REPLACE DAT TABLE ENTRY
	op_CRJ     uint32 = 0xEC76 // FORMAT_RIE2       COMPARE AND BRANCH RELATIVE (32)
	op_CRL     uint32 = 0xC60D // FORMAT_RIL2       COMPARE RELATIVE LONG (32)
	op_CRT     uint32 = 0xB972 // FORMAT_RRF3       COMPARE AND TRAP (32)
	op_CS      uint32 = 0xBA00 // FORMAT_RS1        COMPARE AND SWAP (32)
	op_CSCH    uint32 = 0xB230 // FORMAT_S          CLEAR SUBCHANNEL
	op_CSDTR   uint32 = 0xB3E3 // FORMAT_RRF4       CONVERT TO SIGNED PACKED (long DFP to 64)
	op_CSG     uint32 = 0xEB30 // FORMAT_RSY1       COMPARE AND SWAP (64)
	op_CSP     uint32 = 0xB250 // FORMAT_RRE        COMPARE AND SWAP AND PURGE
	op_CSPG    uint32 = 0xB98A // FORMAT_RRE        COMPARE AND SWAP AND PURGE
	op_CSST    uint32 = 0xC802 // FORMAT_SSF        COMPARE AND SWAP AND STORE
	op_CSXTR   uint32 = 0xB3EB // FORMAT_RRF4       CONVERT TO SIGNED PACKED (extended DFP to 128)
	op_CSY     uint32 = 0xEB14 // FORMAT_RSY1       COMPARE AND SWAP (32)
	op_CU12    uint32 = 0xB2A7 // FORMAT_RRF3       CONVERT UTF-8 TO UTF-16
	op_CU14    uint32 = 0xB9B0 // FORMAT_RRF3       CONVERT UTF-8 TO UTF-32
	op_CU21    uint32 = 0xB2A6 // FORMAT_RRF3       CONVERT UTF-16 TO UTF-8
	op_CU24    uint32 = 0xB9B1 // FORMAT_RRF3       CONVERT UTF-16 TO UTF-32
	op_CU41    uint32 = 0xB9B2 // FORMAT_RRE        CONVERT UTF-32 TO UTF-8
	op_CU42    uint32 = 0xB9B3 // FORMAT_RRE        CONVERT UTF-32 TO UTF-16
	op_CUDTR   uint32 = 0xB3E2 // FORMAT_RRE        CONVERT TO UNSIGNED PACKED (long DFP to 64)
	op_CUSE    uint32 = 0xB257 // FORMAT_RRE        COMPARE UNTIL SUBSTRING EQUAL
	op_CUTFU   uint32 = 0xB2A7 // FORMAT_RRF3       CONVERT UTF-8 TO UNICODE
	op_CUUTF   uint32 = 0xB2A6 // FORMAT_RRF3       CONVERT UNICODE TO UTF-8
	op_CUXTR   uint32 = 0xB3EA // FORMAT_RRE        CONVERT TO UNSIGNED PACKED (extended DFP to 128)
	op_CVB     uint32 = 0x4F00 // FORMAT_RX1        CONVERT TO BINARY (32)
	op_CVBG    uint32 = 0xE30E // FORMAT_RXY1       CONVERT TO BINARY (64)
	op_CVBY    uint32 = 0xE306 // FORMAT_RXY1       CONVERT TO BINARY (32)
	op_CVD     uint32 = 0x4E00 // FORMAT_RX1        CONVERT TO DECIMAL (32)
	op_CVDG    uint32 = 0xE32E // FORMAT_RXY1       CONVERT TO DECIMAL (64)
	op_CVDY    uint32 = 0xE326 // FORMAT_RXY1       CONVERT TO DECIMAL (32)
	op_CXBR    uint32 = 0xB349 // FORMAT_RRE        COMPARE (extended BFP)
	op_CXFBR   uint32 = 0xB396 // FORMAT_RRE        CONVERT FROM FIXED (32 to extended BFP)
	op_CXFBRA  uint32 = 0xB396 // FORMAT_RRF5       CONVERT FROM FIXED (32 to extended BFP)
	op_CXFR    uint32 = 0xB3B6 // FORMAT_RRE        CONVERT FROM FIXED (32 to extended HFP)
	op_CXFTR   uint32 = 0xB959 // FORMAT_RRE        CONVERT FROM FIXED (32 to extended DFP)
	op_CXGBR   uint32 = 0xB3A6 // FORMAT_RRE        CONVERT FROM FIXED (64 to extended BFP)
	op_CXGBRA  uint32 = 0xB3A6 // FORMAT_RRF5       CONVERT FROM FIXED (64 to extended BFP)
	op_CXGR    uint32 = 0xB3C6 // FORMAT_RRE        CONVERT FROM FIXED (64 to extended HFP)
	op_CXGTR   uint32 = 0xB3F9 // FORMAT_RRE        CONVERT FROM FIXED (64 to extended DFP)
	op_CXGTRA  uint32 = 0xB3F9 // FORMAT_RRF5       CONVERT FROM FIXED (64 to extended DFP)
	op_CXLFBR  uint32 = 0xB392 // FORMAT_RRF5       CONVERT FROM LOGICAL (32 to extended BFP)
	op_CXLFTR  uint32 = 0xB95B // FORMAT_RRF5       CONVERT FROM LOGICAL (32 to extended DFP)
	op_CXLGBR  uint32 = 0xB3A2 // FORMAT_RRF5       CONVERT FROM LOGICAL (64 to extended BFP)
	op_CXLGTR  uint32 = 0xB95A // FORMAT_RRF5       CONVERT FROM LOGICAL (64 to extended DFP)
	op_CXR     uint32 = 0xB369 // FORMAT_RRE        COMPARE (extended HFP)
	op_CXSTR   uint32 = 0xB3FB // FORMAT_RRE        CONVERT FROM SIGNED PACKED (128 to extended DFP)
	op_CXTR    uint32 = 0xB3EC // FORMAT_RRE        COMPARE (extended DFP)
	op_CXUTR   uint32 = 0xB3FA // FORMAT_RRE        CONVERT FROM UNSIGNED PACKED (128 to ext. DFP)
	op_CXZT    uint32 = 0xEDAB // FORMAT_RSL        CONVERT FROM ZONED (to extended DFP)
	op_CY      uint32 = 0xE359 // FORMAT_RXY1       COMPARE (32)
	op_CZDT    uint32 = 0xEDA8 // FORMAT_RSL        CONVERT TO ZONED (from long DFP)
	op_CZXT    uint32 = 0xEDA9 // FORMAT_RSL        CONVERT TO ZONED (from extended DFP)
	op_D       uint32 = 0x5D00 // FORMAT_RX1        DIVIDE (32<-64)
	op_DD      uint32 = 0x6D00 // FORMAT_RX1        DIVIDE (long HFP)
	op_DDB     uint32 = 0xED1D // FORMAT_RXE        DIVIDE (long BFP)
	op_DDBR    uint32 = 0xB31D // FORMAT_RRE        DIVIDE (long BFP)
	op_DDR     uint32 = 0x2D00 // FORMAT_RR         DIVIDE (long HFP)
	op_DDTR    uint32 = 0xB3D1 // FORMAT_RRF1       DIVIDE (long DFP)
	op_DDTRA   uint32 = 0xB3D1 // FORMAT_RRF1       DIVIDE (long DFP)
	op_DE      uint32 = 0x7D00 // FORMAT_RX1        DIVIDE (short HFP)
	op_DEB     uint32 = 0xED0D // FORMAT_RXE        DIVIDE (short BFP)
	op_DEBR    uint32 = 0xB30D // FORMAT_RRE        DIVIDE (short BFP)
	op_DER     uint32 = 0x3D00 // FORMAT_RR         DIVIDE (short HFP)
	op_DIDBR   uint32 = 0xB35B // FORMAT_RRF2       DIVIDE TO INTEGER (long BFP)
	op_DIEBR   uint32 = 0xB353 // FORMAT_RRF2       DIVIDE TO INTEGER (short BFP)
	op_DL      uint32 = 0xE397 // FORMAT_RXY1       DIVIDE LOGICAL (32<-64)
	op_DLG     uint32 = 0xE387 // FORMAT_RXY1       DIVIDE LOGICAL (64<-128)
	op_DLGR    uint32 = 0xB987 // FORMAT_RRE        DIVIDE LOGICAL (64<-128)
	op_DLR     uint32 = 0xB997 // FORMAT_RRE        DIVIDE LOGICAL (32<-64)
	op_DP      uint32 = 0xFD00 // FORMAT_SS2        DIVIDE DECIMAL
	op_DR      uint32 = 0x1D00 // FORMAT_RR         DIVIDE (32<-64)
	op_DSG     uint32 = 0xE30D // FORMAT_RXY1       DIVIDE SINGLE (64)
	op_DSGF    uint32 = 0xE31D // FORMAT_RXY1       DIVIDE SINGLE (64<-32)
	op_DSGFR   uint32 = 0xB91D // FORMAT_RRE        DIVIDE SINGLE (64<-32)
	op_DSGR    uint32 = 0xB90D // FORMAT_RRE        DIVIDE SINGLE (64)
	op_DXBR    uint32 = 0xB34D // FORMAT_RRE        DIVIDE (extended BFP)
	op_DXR     uint32 = 0xB22D // FORMAT_RRE        DIVIDE (extended HFP)
	op_DXTR    uint32 = 0xB3D9 // FORMAT_RRF1       DIVIDE (extended DFP)
	op_DXTRA   uint32 = 0xB3D9 // FORMAT_RRF1       DIVIDE (extended DFP)
	op_EAR     uint32 = 0xB24F // FORMAT_RRE        EXTRACT ACCESS
	op_ECAG    uint32 = 0xEB4C // FORMAT_RSY1       EXTRACT CACHE ATTRIBUTE
	op_ECTG    uint32 = 0xC801 // FORMAT_SSF        EXTRACT CPU TIME
	op_ED      uint32 = 0xDE00 // FORMAT_SS1        EDIT
	op_EDMK    uint32 = 0xDF00 // FORMAT_SS1        EDIT AND MARK
	op_EEDTR   uint32 = 0xB3E5 // FORMAT_RRE        EXTRACT BIASED EXPONENT (long DFP to 64)
	op_EEXTR   uint32 = 0xB3ED // FORMAT_RRE        EXTRACT BIASED EXPONENT (extended DFP to 64)
	op_EFPC    uint32 = 0xB38C // FORMAT_RRE        EXTRACT FPC
	op_EPAIR   uint32 = 0xB99A // FORMAT_RRE        EXTRACT PRIMARY ASN AND INSTANCE
	op_EPAR    uint32 = 0xB226 // FORMAT_RRE        EXTRACT PRIMARY ASN
	op_EPSW    uint32 = 0xB98D // FORMAT_RRE        EXTRACT PSW
	op_EREG    uint32 = 0xB249 // FORMAT_RRE        EXTRACT STACKED REGISTERS (32)
	op_EREGG   uint32 = 0xB90E // FORMAT_RRE        EXTRACT STACKED REGISTERS (64)
	op_ESAIR   uint32 = 0xB99B // FORMAT_RRE        EXTRACT SECONDARY ASN AND INSTANCE
	op_ESAR    uint32 = 0xB227 // FORMAT_RRE        EXTRACT SECONDARY ASN
	op_ESDTR   uint32 = 0xB3E7 // FORMAT_RRE        EXTRACT SIGNIFICANCE (long DFP)
	op_ESEA    uint32 = 0xB99D // FORMAT_RRE        EXTRACT AND SET EXTENDED AUTHORITY
	op_ESTA    uint32 = 0xB24A // FORMAT_RRE        EXTRACT STACKED STATE
	op_ESXTR   uint32 = 0xB3EF // FORMAT_RRE        EXTRACT SIGNIFICANCE (extended DFP)
	op_ETND    uint32 = 0xB2EC // FORMAT_RRE        EXTRACT TRANSACTION NESTING DEPTH
	op_EX      uint32 = 0x4400 // FORMAT_RX1        EXECUTE
	op_EXRL    uint32 = 0xC600 // FORMAT_RIL2       EXECUTE RELATIVE LONG
	op_FIDBR   uint32 = 0xB35F // FORMAT_RRF5       LOAD FP INTEGER (long BFP)
	op_FIDBRA  uint32 = 0xB35F // FORMAT_RRF5       LOAD FP INTEGER (long BFP)
	op_FIDR    uint32 = 0xB37F // FORMAT_RRE        LOAD FP INTEGER (long HFP)
	op_FIDTR   uint32 = 0xB3D7 // FORMAT_RRF5       LOAD FP INTEGER (long DFP)
	op_FIEBR   uint32 = 0xB357 // FORMAT_RRF5       LOAD FP INTEGER (short BFP)
	op_FIEBRA  uint32 = 0xB357 // FORMAT_RRF5       LOAD FP INTEGER (short BFP)
	op_FIER    uint32 = 0xB377 // FORMAT_RRE        LOAD FP INTEGER (short HFP)
	op_FIXBR   uint32 = 0xB347 // FORMAT_RRF5       LOAD FP INTEGER (extended BFP)
	op_FIXBRA  uint32 = 0xB347 // FORMAT_RRF5       LOAD FP INTEGER (extended BFP)
	op_FIXR    uint32 = 0xB367 // FORMAT_RRE        LOAD FP INTEGER (extended HFP)
	op_FIXTR   uint32 = 0xB3DF // FORMAT_RRF5       LOAD FP INTEGER (extended DFP)
	op_FLOGR   uint32 = 0xB983 // FORMAT_RRE        FIND LEFTMOST ONE
	op_HDR     uint32 = 0x2400 // FORMAT_RR         HALVE (long HFP)
	op_HER     uint32 = 0x3400 // FORMAT_RR         HALVE (short HFP)
	op_HSCH    uint32 = 0xB231 // FORMAT_S          HALT SUBCHANNEL
	op_IAC     uint32 = 0xB224 // FORMAT_RRE        INSERT ADDRE
"""




```
Response:
My thinking process to answer the request goes like this:

1. **Understand the Goal:** The request asks for a breakdown of the provided Go code snippet. Specifically, it wants to know the functionality, the corresponding Go language features implemented, example usage, command-line argument handling (if applicable), and potential pitfalls.

2. **Initial Scan and Identify the Core Purpose:** The first few lines are crucial:
   - `// go run mksyscall.go -tags linux,mips64le syscall_linux.go syscall_linux_mips64x.go`: This immediately tells me this file is *generated* and likely deals with system calls. The `-tags linux,mips64le` is a big hint about the target platform.
   - `// Code generated by the command above; see README.md. DO NOT EDIT.`: Reinforces the generated nature.
   - `//go:build linux && mips64le`:  Confirms the operating system and architecture.
   - `package unix`:  Indicates this is part of the `unix` package, dealing with low-level OS interactions.
   - `import ("syscall", "unsafe")`: These imports are standard for system call interactions in Go. `syscall` provides the basic mechanisms, and `unsafe` is often needed to work with raw memory addresses.

3. **Analyze Individual Functions:**  I'll go through each function definition, looking for patterns and understanding its purpose.

   - **Naming Convention:**  Function names like `fanotifyMark`, `Fallocate`, `Tee`, `EpollWait`, etc., strongly suggest they are wrappers around Linux system calls. The uppercase first letter is a Go convention for exported functions.
   - **`Syscall`, `Syscall6`, `RawSyscall`, `RawSyscallNoError`:** These are the core functions from the `syscall` package used to make system calls. The number in `SyscallN` indicates the number of arguments passed to the underlying system call. `RawSyscall` and `RawSyscallNoError` likely provide slightly different error handling or calling conventions.
   - **`SYS_*` Constants:**  Constants like `SYS_FANOTIFY_MARK`, `SYS_FALLOCATE`, etc., are standard Linux system call numbers.
   - **`unsafe.Pointer`:**  The frequent use of `unsafe.Pointer` signifies direct memory manipulation, which is common when interacting with system calls that expect pointers to data structures.
   - **Error Handling:** The pattern `_, _, e1 := ...; if e1 != 0 { err = errnoErr(e1) }` is the standard way to handle errors returned by system calls in Go. `errnoErr` is a helper function (likely defined elsewhere in the `unix` package) to convert the raw error number to a Go `error`.
   - **Parameter Types:** The parameter types often reflect the types expected by the underlying system calls (e.g., `int` for file descriptors, `uintptr` for generic pointers, slices for buffers).

4. **Infer Go Language Feature Implementation:** Based on the function names and their interactions with the `syscall` package, I can deduce the corresponding Go language features being implemented:

   - **File System Operations:** `Fallocate`, `Ftruncate`, `Truncate`, `Renameat`, `Fstatfs`, `Statfs`, `fstat`, `lstat`, `fstatat`, `Utime`, `utimes`, `futimesat`, `SyncFileRange`. These clearly map to file system related operations in Go's `os` package (or lower-level `syscall` usage).
   - **Inter-Process Communication/File Transfer:** `Tee`, `Splice`, `sendfile`. These are advanced I/O techniques for efficient data transfer.
   - **Polling/Event Notification:** `EpollWait`, `fanotifyMark`. These relate to I/O multiplexing and file system event notification.
   - **Process/User/Group IDs:** `Getegid`, `Geteuid`, `Getgid`, `Getuid`, `Setfsgid`, `Setfsuid`, `Getrlimit`, `Getgroups`, `Setgroups`, `Lchown`, `Fchown`. These deal with process credentials and resource limits.
   - **Networking:** `Listen`, `accept4`, `bind`, `connect`, `getsockopt`, `setsockopt`, `socket`, `socketpair`, `getpeername`, `getsockname`, `recvfrom`, `sendto`, `recvmsg`, `sendmsg`, `Shutdown`. These are fundamental networking primitives.
   - **Memory Management:** `mmap`. This deals with memory mapping.
   - **Time:** `Gettimeofday`. This gets the current time.
   - **Pausing:** `Pause`. This suspends the process.
   - **Low-level I/O:** `pread`, `pwrite`, `Seek`. These are for direct file I/O at specific offsets.

5. **Construct Example Usage:** For each inferred Go feature, I can write a simple Go code snippet that utilizes the corresponding function from the `unix` package. I'll focus on common use cases and keep the examples concise. For inputs and outputs, I'll use simple, illustrative values.

6. **Address Command-Line Arguments:** The provided code snippet itself doesn't process command-line arguments. The `go run` command at the beginning is used for generating the file, not for the functionality of the generated code. So, I'll state that no command-line arguments are directly handled by the *generated* code.

7. **Identify Potential Pitfalls:**  I'll think about common mistakes developers make when working with low-level system calls:

   - **Incorrect Pointer Usage:**  `unsafe.Pointer` is powerful but dangerous. Incorrect usage can lead to crashes or memory corruption.
   - **Incorrect Size Calculations:** When passing buffers or structures, ensuring the sizes are correct is critical.
   - **Ignoring Error Codes:** System calls return error codes for a reason. Not checking them can lead to unexpected behavior.
   - **Platform Dependence:**  This code is specific to Linux/mips64le. It won't work on other operating systems or architectures without modification.
   - **Understanding System Call Semantics:**  Developers need to understand the nuances of the underlying system calls, as the Go wrappers are often thin.

8. **Structure the Answer:** I'll organize the answer into clear sections based on the request's points: Functionality, Go Language Feature Implementation (with examples), Command-line Arguments, and Potential Pitfalls. This makes the information easy to read and understand.

9. **Review and Refine:** Finally, I'll review my answer for accuracy, clarity, and completeness. I'll make sure the examples are correct and the explanations are easy to follow. I'll double-check that I've addressed all parts of the original request.
`go/src/cmd/vendor/golang.org/x/sys/unix/zsyscall_linux_mips64le.go` 是 Go 语言标准库 `syscall` 包的一部分，专门为 Linux 操作系统且 CPU 架构为 MIPS64 Little Endian (mips64le) 平台生成的一组系统调用接口。

**功能列举:**

这个文件定义了一系列 Go 函数，这些函数是对底层 Linux 系统调用的直接封装。每个函数对应一个特定的 Linux 系统调用，允许 Go 程序执行底层的操作系统操作。  具体来说，文件中定义的函数包括但不限于：

* **文件和目录操作:**
    * `fanotifyMark`:  用于管理 fanotify 监控标记，允许程序监听文件系统事件。
    * `Fallocate`:  为一个打开的文件预分配磁盘空间。
    * `Ftruncate`, `Truncate`:  截断文件到指定长度。
    * `Renameat`:  原子地重命名一个文件或目录。
    * `Fstatfs`, `Statfs`:  获取文件系统的统计信息。
    * `Fchown`, `Lchown`:  修改文件的所有者和组。
    * `Utime`, `utimes`, `futimesat`:  修改文件的访问和修改时间。
    * `fstat`, `lstat`, `stat`, `fstatat`:  获取文件的状态信息（例如，大小，权限，时间戳）。
    * `SyncFileRange`: 将文件指定范围的数据同步到磁盘。
* **进程和用户管理:**
    * `Getegid`, `Geteuid`, `Getgid`, `Getuid`:  获取有效的和实际的用户/组 ID。
    * `Getrlimit`: 获取进程的资源限制。
    * `Setfsgid`, `Setfsuid`: 设置用于文件系统访问的用户/组 ID。
    * `Getgroups`, `Setgroups`: 获取和设置进程的附属组 ID。
* **网络操作:**
    * `Listen`:  在一个 socket 上监听连接。
    * `accept4`: 接受一个 socket 连接，并可以设置一些标志。
    * `bind`:  将一个 socket 绑定到特定的地址和端口。
    * `connect`:  连接到一个 socket 地址。
    * `getsockopt`, `setsockopt`:  获取和设置 socket 选项。
    * `socket`:  创建一个 socket。
    * `socketpair`:  创建一对连接的 socket。
    * `getpeername`, `getsockname`: 获取连接的 socket 的对端和本地地址。
    * `recvfrom`, `sendto`:  在无连接的 socket 上发送和接收数据。
    * `recvmsg`, `sendmsg`:  在 socket 上发送和接收消息，支持更高级的选项。
    * `Shutdown`:  关闭 socket 的发送或接收方向，或两者都关闭。
* **内存管理:**
    * `mmap`:  将文件或设备映射到内存。
* **进程间通信:**
    * `Tee`:  在两个文件描述符之间复制数据。
    * `Splice`:  在两个文件描述符之间移动数据，不需要在用户空间进行缓冲。
    * `sendfile`:  在两个文件描述符之间直接复制数据。
* **事件处理:**
    * `EpollWait`:  等待 epoll 事件。
* **其他:**
    * `Pause`:  暂停进程直到接收到信号。
    * `Seek`:  设置文件偏移量。
    * `Ustat`:  返回文件系统状态信息 (已废弃)。

**Go 语言功能实现推理及代码示例:**

这个文件是 Go 语言 `syscall` 包中用于特定平台（linux/mips64le）的系统调用实现。它使用了 `syscall` 包提供的底层机制来调用 Linux 内核的系统调用接口。

例如，`Fallocate` 函数是对 Linux 的 `fallocate` 系统调用的封装。在 Go 中，你可以使用 `unix.Fallocate` 来预分配文件空间，这在需要确保写入空间连续性的场景下很有用。

```go
package main

import (
	"fmt"
	"os"
	"syscall"
	"unsafe"

	"golang.org/x/sys/unix"
)

func main() {
	filename := "test_fallocate.txt"
	file, err := os.Create(filename)
	if err != nil {
		fmt.Println("Error creating file:", err)
		return
	}
	defer file.Close()

	fd := int(file.Fd())
	mode := uint32(0) // 默认模式
	offset := int64(0)
	length := int64(1024 * 1024) // 预分配 1MB

	err = unix.Fallocate(fd, mode, offset, length)
	if err != nil {
		fmt.Println("Error calling fallocate:", err)
		return
	}

	fmt.Printf("Successfully pre-allocated %d bytes to file '%s'\n", length, filename)
}
```

**假设的输入与输出:**

对于上面的 `Fallocate` 示例：

* **假设输入:**
    * `filename`: "test_fallocate.txt" (文件不存在或存在)
    * `mode`: 0
    * `offset`: 0
    * `length`: 1048576 (1MB)
* **可能输出:**
    * 如果成功：`Successfully pre-allocated 1048576 bytes to file 'test_fallocate.txt'`
    * 如果失败：`Error calling fallocate: ... (具体的错误信息)`

**代码推理:**

每个函数的核心逻辑都是调用 `syscall.Syscall`, `syscall.Syscall6`, `syscall.RawSyscall` 或 `syscall.RawSyscallNoError` 这些底层函数。 这些函数会将 Go 的参数转换为系统调用所需的格式，并执行实际的系统调用。返回值会被转换回 Go 的类型，并处理可能的错误。

例如，对于 `EpollWait` 函数：

```go
func EpollWait(epfd int, events []EpollEvent, msec int) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(events) > 0 {
		_p0 = unsafe.Pointer(&events[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec), 0, 0)
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}
```

* `epfd`: epoll 文件描述符。
* `events`: 一个 `EpollEvent` 类型的切片，用于接收就绪的事件。
* `msec`: 超时时间，单位是毫秒。

该函数首先获取 `events` 切片的底层数组指针（如果切片不为空），然后调用 `syscall.Syscall6` 来执行 `SYS_EPOLL_WAIT` 系统调用。 系统调用完成后，返回值 `r0` 被转换为就绪事件的数量，`e1` 包含了错误信息。

**命令行参数的具体处理:**

这个文件本身是被 `go run mksyscall.go` 命令生成的，它并不直接处理用户传递的命令行参数。 `mksyscall.go` 是一个 Go 程序，它读取 `syscall_linux.go` 和 `syscall_linux_mips64x.go` 文件中的定义，并根据 `-tags linux,mips64le` 参数，生成特定平台的系统调用实现代码。

在实际使用这些系统调用时，命令行参数的处理发生在调用这些函数的 Go 程序中，而不是在这个生成的文件中。 例如，如果一个程序需要使用 `fanotifyMark` 来监控某个目录，它会在自己的代码中处理目录路径等参数，然后传递给 `unix.FanotifyMark` 函数。

**使用者易犯错的点:**

1. **不正确的参数类型和值:**  系统调用对参数的类型和值有严格的要求。传递不正确的参数类型（例如，将普通的 `int` 直接转换为指针，而不是使用 `unsafe.Pointer`）或者超出有效范围的值会导致系统调用失败，甚至程序崩溃。

   ```go
   // 错误示例
   fd := 10
   var buf syscall.Statfs_t
   // 错误地将 buf 的地址直接转换为 uintptr
   err := unix.Fstatfs(fd, (*unix.Statfs_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&buf))))) // 错误！

   // 正确示例
   fd := 10
   var buf unix.Statfs_t
   err := unix.Fstatfs(fd, &buf) // 正确，Go 会处理指针传递
   ```

2. **忽略错误返回值:**  几乎所有的系统调用都会返回一个错误值。忽略这个错误值会导致程序在遇到问题时无法正确处理，可能导致未知的行为。

   ```go
   fd, _ := unix.Socket(syscall.AF_INET, syscall.SOCK_STREAM, 0) // 忽略了可能发生的错误
   // ... 后续使用 fd，如果 socket 创建失败，fd 的值可能是无效的
   ```

3. **不理解系统调用的语义:**  每个系统调用都有其特定的功能和行为。不理解其语义可能会导致错误的使用。例如，`mmap` 用于内存映射，如果不了解其使用限制和同步机制，可能会导致数据不一致或其他问题。

4. **平台依赖性:**  这些系统调用是特定于 Linux 和 mips64le 架构的。直接使用这些函数编写的程序将不具备跨平台性。如果需要编写跨平台的程序，应该使用 Go 标准库中更高级的抽象，例如 `os` 包和 `net` 包，它们会在底层处理不同平台的差异。

5. **不正确的内存管理:**  某些系统调用需要传递指向内存缓冲区的指针。使用者需要确保缓冲区的生命周期足够长，并且在不再使用时进行适当的释放（例如，对于 `mmap` 分配的内存，需要调用 `munmap`）。

总而言之，这个文件是 Go 语言与 Linux/mips64le 操作系统交互的桥梁。它提供了对底层系统调用的直接访问，但也要求使用者具备一定的操作系统和底层编程知识，以避免常见的错误。

Prompt: 
```
这是路径为go/src/cmd/vendor/golang.org/x/sys/unix/zsyscall_linux_mips64le.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，

"""
// go run mksyscall.go -tags linux,mips64le syscall_linux.go syscall_linux_mips64x.go
// Code generated by the command above; see README.md. DO NOT EDIT.

//go:build linux && mips64le

package unix

import (
	"syscall"
	"unsafe"
)

var _ syscall.Errno

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fanotifyMark(fd int, flags uint, mask uint64, dirFd int, pathname *byte) (err error) {
	_, _, e1 := Syscall6(SYS_FANOTIFY_MARK, uintptr(fd), uintptr(flags), uintptr(mask), uintptr(dirFd), uintptr(unsafe.Pointer(pathname)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fallocate(fd int, mode uint32, off int64, len int64) (err error) {
	_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(len), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Tee(rfd int, wfd int, len int, flags int) (n int64, err error) {
	r0, _, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)
	n = int64(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func EpollWait(epfd int, events []EpollEvent, msec int) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(events) > 0 {
		_p0 = unsafe.Pointer(&events[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec), 0, 0)
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fadvise(fd int, offset int64, length int64, advice int) (err error) {
	_, _, e1 := Syscall6(SYS_FADVISE64, uintptr(fd), uintptr(offset), uintptr(length), uintptr(advice), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fchown(fd int, uid int, gid int) (err error) {
	_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Fstatfs(fd int, buf *Statfs_t) (err error) {
	_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(buf)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Ftruncate(fd int, length int64) (err error) {
	_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getegid() (egid int) {
	r0, _ := RawSyscallNoError(SYS_GETEGID, 0, 0, 0)
	egid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Geteuid() (euid int) {
	r0, _ := RawSyscallNoError(SYS_GETEUID, 0, 0, 0)
	euid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getgid() (gid int) {
	r0, _ := RawSyscallNoError(SYS_GETGID, 0, 0, 0)
	gid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getrlimit(resource int, rlim *Rlimit) (err error) {
	_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Getuid() (uid int) {
	r0, _ := RawSyscallNoError(SYS_GETUID, 0, 0, 0)
	uid = int(r0)
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Lchown(path string, uid int, gid int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Listen(s int, n int) (err error) {
	_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(n), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Pause() (err error) {
	_, _, e1 := Syscall(SYS_PAUSE, 0, 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func pread(fd int, p []byte, offset int64) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func pwrite(fd int, p []byte, offset int64) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(oldpath)
	if err != nil {
		return
	}
	var _p1 *byte
	_p1, err = BytePtrFromString(newpath)
	if err != nil {
		return
	}
	_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Seek(fd int, offset int64, whence int) (off int64, err error) {
	r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))
	off = int64(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) {
	r0, _, e1 := Syscall6(SYS_SENDFILE, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)
	written = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func setfsgid(gid int) (prev int, err error) {
	r0, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)
	prev = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func setfsuid(uid int) (prev int, err error) {
	r0, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)
	prev = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Shutdown(fd int, how int) (err error) {
	_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(fd), uintptr(how), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error) {
	r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))
	n = int64(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Statfs(path string, buf *Statfs_t) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func SyncFileRange(fd int, off int64, n int64, flags int) (err error) {
	_, _, e1 := Syscall6(SYS_SYNC_FILE_RANGE, uintptr(fd), uintptr(off), uintptr(n), uintptr(flags), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Truncate(path string, length int64) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Ustat(dev int, ubuf *Ustat_t) (err error) {
	_, _, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) {
	r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)
	fd = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) {
	_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) {
	_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getgroups(n int, list *_Gid_t) (nn int, err error) {
	r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)
	nn = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func setgroups(n int, list *_Gid_t) (err error) {
	_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) {
	_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) {
	_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func socket(domain int, typ int, proto int) (fd int, err error) {
	r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))
	fd = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func socketpair(domain int, typ int, proto int, fd *[2]int32) (err error) {
	_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) {
	_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) {
	_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) {
	var _p0 unsafe.Pointer
	if len(p) > 0 {
		_p0 = unsafe.Pointer(&p[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func sendto(s int, buf []byte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) {
	var _p0 unsafe.Pointer
	if len(buf) > 0 {
		_p0 = unsafe.Pointer(&buf[0])
	} else {
		_p0 = unsafe.Pointer(&_zero)
	}
	_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func recvmsg(s int, msg *Msghdr, flags int) (n int, err error) {
	r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func sendmsg(s int, msg *Msghdr, flags int) (n int, err error) {
	r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))
	n = int(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error) {
	r0, _, e1 := Syscall6(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flags), uintptr(fd), uintptr(offset))
	xaddr = uintptr(r0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func futimesat(dirfd int, path string, times *[2]Timeval) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)))
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Gettimeofday(tv *Timeval) (err error) {
	_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func Utime(path string, buf *Utimbuf) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_UTIME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func utimes(path string, times *[2]Timeval) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fstat(fd int, st *stat_t) (err error) {
	_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(st)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func fstatat(dirfd int, path string, st *stat_t, flags int) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall6(SYS_NEWFSTATAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(st)), uintptr(flags), 0, 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func lstat(path string, st *stat_t) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(st)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

func stat(path string, st *stat_t) (err error) {
	var _p0 *byte
	_p0, err = BytePtrFromString(path)
	if err != nil {
		return
	}
	_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(st)), 0)
	if e1 != 0 {
		err = errnoErr(e1)
	}
	return
}

"""



```
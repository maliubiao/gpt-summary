Response:
Let's break down the thought process for analyzing this Go code snippet.

**1. Initial Understanding - Context is Key:**

The very first line, `// Code generated by mkbuiltin.go. DO NOT EDIT.`, is a massive clue. It immediately tells us that this file isn't written by hand, but generated programmatically. This means we should focus on *what* is being generated rather than the intricate details of the generation process itself. The package name `typecheck` within `cmd/compile/internal` further suggests its role in the Go compiler's type checking phase. The filename `builtin.go` strongly indicates this file defines built-in functions or types.

**2. Dissecting the Structure:**

* **Helper Functions:** The code starts with `newSig` and `params`. These are clearly utility functions to help create `types.Type` objects, specifically function signatures. `newSig` creates a function signature, and `params` simplifies the creation of a list of parameters (fields with types).

* **`runtimeDecls`:** This is a crucial data structure. It's an array of structs, each holding `name`, `tag`, and `typ`. The `name` is clearly a string, likely the name of a built-in function. The `tag` and `typ` are integers. The comment "Not inlining this function removes a significant chunk of init code" for `newSig` also hints that this structure is used during compiler initialization.

* **`runtimeTypes()`:** This function creates an array of `types.Type`. The code within this function uses the indices from the `runtimeDecls` array's `typ` field to access and construct specific types. This strongly suggests a connection between `runtimeDecls` and `runtimeTypes`.

* **`coverageDecls` and `coverageTypes()`:**  These follow a similar pattern to `runtimeDecls` and `runtimeTypes`, hinting at a separate set of declarations, possibly related to code coverage.

**3. Inferring Functionality - Connecting the Dots:**

* **Built-in Functions:** The `runtimeDecls` array contains names like "newobject", "panicdivide", "printbool", "concatstring2", "makemap", "closechan", "memmove", "int64div", etc. These are all very familiar Go built-in functions or low-level runtime operations. This confirms the initial intuition.

* **Type Representation:** The `runtimeTypes` function is building `types.Type` objects. This implies that the `typ` integer in `runtimeDecls` acts as an index into the `typs` array in `runtimeTypes`, providing the type information for the corresponding built-in function.

* **`funcTag` and `varTag`:** The `tag` field in `runtimeDecls` seems to distinguish between functions and variables. This is a common way to categorize symbols in a compiler.

* **Code Generation:** The "Code generated by mkbuiltin.go" comment means that `mkbuiltin.go` likely reads some definition of built-in functions (perhaps in a separate file or data structure) and generates this `builtin.go` file. This is a common technique for managing generated code.

**4. Constructing Examples and Explanations:**

Based on the inferred functionality:

* **`new`:**  "newobject" strongly suggests the implementation of the `new` built-in. The signature in `runtimeTypes` for "newobject" (`newSig(params(typs[1]), params(typs[3]))`) translates to `func(arg *byte) *any`, which aligns with how `new` works.

* **`panic`:**  The various "panic..." entries in `runtimeDecls` clearly relate to different panic scenarios.

* **`print`:** The "print..." entries handle printing different data types.

* **String Operations:** "concatstring...", "slicebytetostring", etc., show the implementation of common string manipulation functions.

* **Maps and Channels:**  "makemap", "mapaccess", "makechan", "chanrecv", etc., relate to the implementation of maps and channels.

* **Low-level Operations:** "memmove", "memclr", "memequal" are low-level memory manipulation primitives used by the Go runtime.

**5. Considering Potential Misunderstandings:**

Since this is generated code, direct manual modification is a big no-no. The "DO NOT EDIT" comment is the most important point. Users shouldn't be trying to tweak this file.

**6. Refining the Explanation:**

Review the initial analysis and structure it logically. Start with the overall purpose, then delve into the key data structures and functions. Provide concrete examples to illustrate the inferred functionality. Address the "easy mistakes" based on the "DO NOT EDIT" directive.

This systematic approach, starting with understanding the context and structure, then inferring functionality based on naming conventions and patterns, and finally constructing examples and explanations, allows for a comprehensive analysis of even generated code like this.
这段代码是 Go 编译器 `cmd/compile/internal/typecheck` 包中的 `builtin.go` 文件的一部分。它的主要功能是**定义和声明 Go 语言的内置函数和一些运行时（runtime）支持的函数及变量的类型信息**。由于它是通过 `mkbuiltin.go` 自动生成的，因此它包含了编译器在类型检查阶段需要了解的关于这些内置符号的所有信息。

让我们分解一下它的功能：

**1. 定义辅助函数：**

*   **`newSig(params, results []*types.Field) *types.Type`**:  这个函数用于创建一个新的函数签名类型 (`*types.Type`)。它接收参数列表 `params` 和返回值列表 `results`，这两个都是 `*types.Field` 的切片。`types.NewSignature` 实际上是 `cmd/compile/internal/types` 包中用于创建函数签名类型的方法。`//go:noinline` 指示编译器不要内联这个函数，这可能是为了减少初始化代码的大小。

*   **`params(tlist ...*types.Type) []*types.Field`**:  这个函数是一个辅助函数，用于方便地创建一个参数列表 (`[]*types.Field`)。它接收一个可变参数列表 `tlist`，其中包含参数的类型 (`*types.Type`)。它会遍历这些类型，为每个类型创建一个新的字段 (`types.NewField`)，字段名为空，并将这些字段组成一个切片返回。

**2. 定义 `runtimeDecls` 数组：**

*   **`var runtimeDecls = [...]struct { ... }`**:  这是该文件的核心部分。它定义了一个结构体类型的数组 `runtimeDecls`，数组中的每个元素都描述了一个运行时函数或变量。
    *   **`name string`**:  运行时函数或变量的名称，例如 "newobject", "panicdivide", "printbool" 等。
    *   **`tag int`**:  一个整数标签，用于区分不同的运行时符号。根据代码的上下文，`funcTag` 和 `varTag` 可能是枚举值，用于区分函数和变量。
    *   **`typ int`**:  一个整数索引，用于在 `runtimeTypes()` 函数返回的类型数组中查找该运行时符号的类型信息。

   `runtimeDecls` 数组包含了 Go 语言运行时环境中许多重要的函数，例如：
    *   **内存分配**: `newobject`, `mallocgc`
    *   **panic 处理**: `panicdivide`, `gopanic`, `gorecover`
    *   **切片操作**: `goPanicIndex`, `makeslice`, `growslice`
    *   **打印**: `printbool`, `printint`, `printstring`
    *   **字符串操作**: `concatstring2`, `slicebytetostring`
    *   **类型转换**: `convT`, `assertE2I`
    *   **Map 操作**: `makemap`, `mapaccess1`, `mapassign`
    *   **Channel 操作**: `makechan`, `chanrecv1`, `chansend1`
    *   **内存操作**: `memmove`, `memclr`, `memequal`
    *   **哈希**: `memhash`, `strhash`
    *   **原子操作 (间接体现，例如与 race detection 相关的函数)**
    *   **与 unsafe 包相关的操作**
    *   **与代码覆盖率和模糊测试相关的函数**
    *   **与 CPU 特性检测相关的变量**

**3. 定义 `runtimeTypes()` 函数：**

*   **`func runtimeTypes() []*types.Type`**:  这个函数返回一个 `*types.Type` 类型的切片，包含了所有运行时函数和变量的类型信息。
    *   它首先定义了一个固定大小的类型数组 `typs`。
    *   然后，它使用 `types` 包中预定义的类型（如 `types.ByteType`, `types.Types[types.TANY]`）和之前定义的 `newSig` 和 `params` 函数来构建更复杂的类型，例如指针、函数签名、切片、数组、Map 和 Channel 类型。
    *   关键在于 `runtimeDecls` 数组中的 `typ` 字段作为索引来访问 `typs` 数组，从而将运行时符号的名称与其具体的类型关联起来。例如，`runtimeDecls` 中 `"newobject"` 的 `typ` 是 4，那么 `runtimeTypes()` 返回的 `typs[4]` 就是 `newobject` 函数的类型。

**4. 定义 `coverageDecls` 和 `coverageTypes()`：**

*   这部分与代码覆盖率相关。`coverageDecls` 数组定义了与覆盖率相关的运行时符号，例如 `initHook`。`coverageTypes()` 函数则提供了这些符号的类型信息。

**可以推理出它是什么 Go 语言功能的实现：**

这个文件是 Go 语言编译器在类型检查阶段用于识别和处理内置函数以及一些核心运行时函数的关键组成部分。它确保了编译器能够正确地理解这些函数的参数类型、返回值类型以及它们在语言中的语义。

**Go 代码示例：**

假设 `runtimeDecls` 中定义了 `printint` 函数，并且其 `typ` 对应 `runtimeTypes()` 返回的类型切片中的索引 23，而 `typs[23]` 定义了 `func(int64)` 的签名。

```go
package main

func main() {
	var num int64 = 10
	// 编译器在类型检查时，会查找 builtin.go 中的 runtimeDecls
	// 找到 "printint" 的定义，并根据其 typ 值找到对应的类型信息。
	println(num) // println 实际上会调用 runtime.printint
}
```

**假设的输入与输出（代码推理）：**

假设 `runtimeDecls` 中有以下条目：

```go
{"add", funcTag, 0},
{"subtract", funcTag, 1},
```

并且 `runtimeTypes()` 函数返回的 `typs` 数组如下：

```go
typs[0] = newSig(params(types.Types[types.TINT], types.Types[types.TINT]), params(types.Types[types.TINT])) // func(int, int) int
typs[1] = newSig(params(types.Types[types.TINT], types.Types[types.TINT]), params(types.Types[types.TINT])) // func(int, int) int
```

那么，当编译器遇到以下代码时：

```go
package main

func main() {
	result := add(5, 3) // 假设 add 是一个内置函数
	println(result)
}
```

编译器会：

1. 在 `runtimeDecls` 中找到 "add"。
2. 获取其 `typ` 值，这里是 0。
3. 使用 `typ` 值 0 在 `runtimeTypes()` 返回的 `typs` 数组中查找类型信息，得到 `func(int, int) int`。
4. 检查 `add(5, 3)` 的参数类型是否与定义的类型匹配（`int` 和 `int` 匹配）。
5. 推断表达式 `add(5, 3)` 的类型为 `int`。

**命令行参数的具体处理：**

这段代码本身不直接处理命令行参数。它是在 Go 编译器的内部使用的。Go 编译器的命令行参数（例如 `-o`, `-gcflags`, `-ldflags` 等）会影响编译过程的各个阶段，包括类型检查，但 `builtin.go` 文件只是提供了类型检查所需的数据。

**使用者易犯错的点：**

由于 `builtin.go` 是自动生成的，**开发者不应该手动修改这个文件**。任何手动修改都会在下次编译时被覆盖，并且可能导致编译器内部错误或不一致的行为。

错误示例：

假设开发者出于某种原因，尝试修改 `builtin.go`，例如修改 `printint` 函数的类型定义。这样做是错误的，因为：

1. **修改会被覆盖：**  下次运行 `go build` 时，`mkbuiltin.go` 会重新生成 `builtin.go`，覆盖之前的修改。
2. **导致不一致：**  如果手动修改与实际的运行时实现不符，可能会导致程序在编译时通过类型检查，但在运行时出现意想不到的错误。

**总结：**

`go/src/cmd/compile/internal/typecheck/builtin.go` 是 Go 编译器类型检查阶段的关键数据来源，它定义了内置函数和一些运行时支持的函数的类型信息。它的主要作用是确保编译器能够正确理解和处理这些特殊的语言构造。由于它是自动生成的，开发者不应该手动修改它。

Prompt: 
```
这是路径为go/src/cmd/compile/internal/typecheck/builtin.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，

"""
// Code generated by mkbuiltin.go. DO NOT EDIT.

package typecheck

import (
	"cmd/compile/internal/types"
	"cmd/internal/src"
)

// Not inlining this function removes a significant chunk of init code.
//
//go:noinline
func newSig(params, results []*types.Field) *types.Type {
	return types.NewSignature(nil, params, results)
}

func params(tlist ...*types.Type) []*types.Field {
	flist := make([]*types.Field, len(tlist))
	for i, typ := range tlist {
		flist[i] = types.NewField(src.NoXPos, nil, typ)
	}
	return flist
}

var runtimeDecls = [...]struct {
	name string
	tag  int
	typ  int
}{
	{"newobject", funcTag, 4},
	{"mallocgc", funcTag, 8},
	{"panicdivide", funcTag, 9},
	{"panicshift", funcTag, 9},
	{"panicmakeslicelen", funcTag, 9},
	{"panicmakeslicecap", funcTag, 9},
	{"throwinit", funcTag, 9},
	{"panicwrap", funcTag, 9},
	{"gopanic", funcTag, 11},
	{"gorecover", funcTag, 14},
	{"goschedguarded", funcTag, 9},
	{"goPanicIndex", funcTag, 16},
	{"goPanicIndexU", funcTag, 18},
	{"goPanicSliceAlen", funcTag, 16},
	{"goPanicSliceAlenU", funcTag, 18},
	{"goPanicSliceAcap", funcTag, 16},
	{"goPanicSliceAcapU", funcTag, 18},
	{"goPanicSliceB", funcTag, 16},
	{"goPanicSliceBU", funcTag, 18},
	{"goPanicSlice3Alen", funcTag, 16},
	{"goPanicSlice3AlenU", funcTag, 18},
	{"goPanicSlice3Acap", funcTag, 16},
	{"goPanicSlice3AcapU", funcTag, 18},
	{"goPanicSlice3B", funcTag, 16},
	{"goPanicSlice3BU", funcTag, 18},
	{"goPanicSlice3C", funcTag, 16},
	{"goPanicSlice3CU", funcTag, 18},
	{"goPanicSliceConvert", funcTag, 16},
	{"printbool", funcTag, 19},
	{"printfloat", funcTag, 21},
	{"printint", funcTag, 23},
	{"printhex", funcTag, 25},
	{"printuint", funcTag, 25},
	{"printcomplex", funcTag, 27},
	{"printstring", funcTag, 29},
	{"printpointer", funcTag, 30},
	{"printuintptr", funcTag, 31},
	{"printiface", funcTag, 30},
	{"printeface", funcTag, 30},
	{"printslice", funcTag, 30},
	{"printnl", funcTag, 9},
	{"printsp", funcTag, 9},
	{"printlock", funcTag, 9},
	{"printunlock", funcTag, 9},
	{"concatstring2", funcTag, 34},
	{"concatstring3", funcTag, 35},
	{"concatstring4", funcTag, 36},
	{"concatstring5", funcTag, 37},
	{"concatstrings", funcTag, 39},
	{"concatbyte2", funcTag, 41},
	{"concatbyte3", funcTag, 42},
	{"concatbyte4", funcTag, 43},
	{"concatbyte5", funcTag, 44},
	{"concatbytes", funcTag, 45},
	{"cmpstring", funcTag, 46},
	{"intstring", funcTag, 49},
	{"slicebytetostring", funcTag, 50},
	{"slicebytetostringtmp", funcTag, 51},
	{"slicerunetostring", funcTag, 54},
	{"stringtoslicebyte", funcTag, 55},
	{"stringtoslicerune", funcTag, 58},
	{"slicecopy", funcTag, 59},
	{"decoderune", funcTag, 60},
	{"countrunes", funcTag, 61},
	{"convT", funcTag, 62},
	{"convTnoptr", funcTag, 62},
	{"convT16", funcTag, 64},
	{"convT32", funcTag, 66},
	{"convT64", funcTag, 67},
	{"convTstring", funcTag, 68},
	{"convTslice", funcTag, 71},
	{"assertE2I", funcTag, 72},
	{"assertE2I2", funcTag, 72},
	{"panicdottypeE", funcTag, 73},
	{"panicdottypeI", funcTag, 73},
	{"panicnildottype", funcTag, 74},
	{"typeAssert", funcTag, 72},
	{"interfaceSwitch", funcTag, 75},
	{"ifaceeq", funcTag, 77},
	{"efaceeq", funcTag, 77},
	{"panicrangestate", funcTag, 78},
	{"deferrangefunc", funcTag, 79},
	{"rand", funcTag, 80},
	{"rand32", funcTag, 81},
	{"makemap64", funcTag, 83},
	{"makemap", funcTag, 84},
	{"makemap_small", funcTag, 85},
	{"mapaccess1", funcTag, 86},
	{"mapaccess1_fast32", funcTag, 87},
	{"mapaccess1_fast64", funcTag, 88},
	{"mapaccess1_faststr", funcTag, 89},
	{"mapaccess1_fat", funcTag, 90},
	{"mapaccess2", funcTag, 91},
	{"mapaccess2_fast32", funcTag, 92},
	{"mapaccess2_fast64", funcTag, 93},
	{"mapaccess2_faststr", funcTag, 94},
	{"mapaccess2_fat", funcTag, 95},
	{"mapassign", funcTag, 86},
	{"mapassign_fast32", funcTag, 87},
	{"mapassign_fast32ptr", funcTag, 96},
	{"mapassign_fast64", funcTag, 88},
	{"mapassign_fast64ptr", funcTag, 96},
	{"mapassign_faststr", funcTag, 89},
	{"mapiterinit", funcTag, 97},
	{"mapdelete", funcTag, 97},
	{"mapdelete_fast32", funcTag, 98},
	{"mapdelete_fast64", funcTag, 99},
	{"mapdelete_faststr", funcTag, 100},
	{"mapiternext", funcTag, 101},
	{"mapclear", funcTag, 102},
	{"makechan64", funcTag, 104},
	{"makechan", funcTag, 105},
	{"chanrecv1", funcTag, 107},
	{"chanrecv2", funcTag, 108},
	{"chansend1", funcTag, 110},
	{"closechan", funcTag, 111},
	{"chanlen", funcTag, 112},
	{"chancap", funcTag, 112},
	{"writeBarrier", varTag, 114},
	{"typedmemmove", funcTag, 115},
	{"typedmemclr", funcTag, 116},
	{"typedslicecopy", funcTag, 117},
	{"selectnbsend", funcTag, 118},
	{"selectnbrecv", funcTag, 119},
	{"selectsetpc", funcTag, 120},
	{"selectgo", funcTag, 121},
	{"block", funcTag, 9},
	{"makeslice", funcTag, 122},
	{"makeslice64", funcTag, 123},
	{"makeslicecopy", funcTag, 124},
	{"growslice", funcTag, 126},
	{"unsafeslicecheckptr", funcTag, 127},
	{"panicunsafeslicelen", funcTag, 9},
	{"panicunsafeslicenilptr", funcTag, 9},
	{"unsafestringcheckptr", funcTag, 128},
	{"panicunsafestringlen", funcTag, 9},
	{"panicunsafestringnilptr", funcTag, 9},
	{"memmove", funcTag, 129},
	{"memclrNoHeapPointers", funcTag, 130},
	{"memclrHasPointers", funcTag, 130},
	{"memequal", funcTag, 131},
	{"memequal0", funcTag, 132},
	{"memequal8", funcTag, 132},
	{"memequal16", funcTag, 132},
	{"memequal32", funcTag, 132},
	{"memequal64", funcTag, 132},
	{"memequal128", funcTag, 132},
	{"f32equal", funcTag, 133},
	{"f64equal", funcTag, 133},
	{"c64equal", funcTag, 133},
	{"c128equal", funcTag, 133},
	{"strequal", funcTag, 133},
	{"interequal", funcTag, 133},
	{"nilinterequal", funcTag, 133},
	{"memhash", funcTag, 134},
	{"memhash0", funcTag, 135},
	{"memhash8", funcTag, 135},
	{"memhash16", funcTag, 135},
	{"memhash32", funcTag, 135},
	{"memhash64", funcTag, 135},
	{"memhash128", funcTag, 135},
	{"f32hash", funcTag, 136},
	{"f64hash", funcTag, 136},
	{"c64hash", funcTag, 136},
	{"c128hash", funcTag, 136},
	{"strhash", funcTag, 136},
	{"interhash", funcTag, 136},
	{"nilinterhash", funcTag, 136},
	{"int64div", funcTag, 137},
	{"uint64div", funcTag, 138},
	{"int64mod", funcTag, 137},
	{"uint64mod", funcTag, 138},
	{"float64toint64", funcTag, 139},
	{"float64touint64", funcTag, 140},
	{"float64touint32", funcTag, 141},
	{"int64tofloat64", funcTag, 142},
	{"int64tofloat32", funcTag, 144},
	{"uint64tofloat64", funcTag, 145},
	{"uint64tofloat32", funcTag, 146},
	{"uint32tofloat64", funcTag, 147},
	{"complex128div", funcTag, 148},
	{"racefuncenter", funcTag, 31},
	{"racefuncexit", funcTag, 9},
	{"raceread", funcTag, 31},
	{"racewrite", funcTag, 31},
	{"racereadrange", funcTag, 149},
	{"racewriterange", funcTag, 149},
	{"msanread", funcTag, 149},
	{"msanwrite", funcTag, 149},
	{"msanmove", funcTag, 150},
	{"asanread", funcTag, 149},
	{"asanwrite", funcTag, 149},
	{"checkptrAlignment", funcTag, 151},
	{"checkptrArithmetic", funcTag, 153},
	{"libfuzzerTraceCmp1", funcTag, 154},
	{"libfuzzerTraceCmp2", funcTag, 155},
	{"libfuzzerTraceCmp4", funcTag, 156},
	{"libfuzzerTraceCmp8", funcTag, 157},
	{"libfuzzerTraceConstCmp1", funcTag, 154},
	{"libfuzzerTraceConstCmp2", funcTag, 155},
	{"libfuzzerTraceConstCmp4", funcTag, 156},
	{"libfuzzerTraceConstCmp8", funcTag, 157},
	{"libfuzzerHookStrCmp", funcTag, 158},
	{"libfuzzerHookEqualFold", funcTag, 158},
	{"addCovMeta", funcTag, 160},
	{"x86HasPOPCNT", varTag, 6},
	{"x86HasSSE41", varTag, 6},
	{"x86HasFMA", varTag, 6},
	{"armHasVFPv4", varTag, 6},
	{"arm64HasATOMICS", varTag, 6},
	{"loong64HasLAMCAS", varTag, 6},
	{"loong64HasLAM_BH", varTag, 6},
	{"loong64HasLSX", varTag, 6},
	{"asanregisterglobals", funcTag, 130},
}

func runtimeTypes() []*types.Type {
	var typs [161]*types.Type
	typs[0] = types.ByteType
	typs[1] = types.NewPtr(typs[0])
	typs[2] = types.Types[types.TANY]
	typs[3] = types.NewPtr(typs[2])
	typs[4] = newSig(params(typs[1]), params(typs[3]))
	typs[5] = types.Types[types.TUINTPTR]
	typs[6] = types.Types[types.TBOOL]
	typs[7] = types.Types[types.TUNSAFEPTR]
	typs[8] = newSig(params(typs[5], typs[1], typs[6]), params(typs[7]))
	typs[9] = newSig(nil, nil)
	typs[10] = types.Types[types.TINTER]
	typs[11] = newSig(params(typs[10]), nil)
	typs[12] = types.Types[types.TINT32]
	typs[13] = types.NewPtr(typs[12])
	typs[14] = newSig(params(typs[13]), params(typs[10]))
	typs[15] = types.Types[types.TINT]
	typs[16] = newSig(params(typs[15], typs[15]), nil)
	typs[17] = types.Types[types.TUINT]
	typs[18] = newSig(params(typs[17], typs[15]), nil)
	typs[19] = newSig(params(typs[6]), nil)
	typs[20] = types.Types[types.TFLOAT64]
	typs[21] = newSig(params(typs[20]), nil)
	typs[22] = types.Types[types.TINT64]
	typs[23] = newSig(params(typs[22]), nil)
	typs[24] = types.Types[types.TUINT64]
	typs[25] = newSig(params(typs[24]), nil)
	typs[26] = types.Types[types.TCOMPLEX128]
	typs[27] = newSig(params(typs[26]), nil)
	typs[28] = types.Types[types.TSTRING]
	typs[29] = newSig(params(typs[28]), nil)
	typs[30] = newSig(params(typs[2]), nil)
	typs[31] = newSig(params(typs[5]), nil)
	typs[32] = types.NewArray(typs[0], 32)
	typs[33] = types.NewPtr(typs[32])
	typs[34] = newSig(params(typs[33], typs[28], typs[28]), params(typs[28]))
	typs[35] = newSig(params(typs[33], typs[28], typs[28], typs[28]), params(typs[28]))
	typs[36] = newSig(params(typs[33], typs[28], typs[28], typs[28], typs[28]), params(typs[28]))
	typs[37] = newSig(params(typs[33], typs[28], typs[28], typs[28], typs[28], typs[28]), params(typs[28]))
	typs[38] = types.NewSlice(typs[28])
	typs[39] = newSig(params(typs[33], typs[38]), params(typs[28]))
	typs[40] = types.NewSlice(typs[0])
	typs[41] = newSig(params(typs[28], typs[28]), params(typs[40]))
	typs[42] = newSig(params(typs[28], typs[28], typs[28]), params(typs[40]))
	typs[43] = newSig(params(typs[28], typs[28], typs[28], typs[28]), params(typs[40]))
	typs[44] = newSig(params(typs[28], typs[28], typs[28], typs[28], typs[28]), params(typs[40]))
	typs[45] = newSig(params(typs[38]), params(typs[40]))
	typs[46] = newSig(params(typs[28], typs[28]), params(typs[15]))
	typs[47] = types.NewArray(typs[0], 4)
	typs[48] = types.NewPtr(typs[47])
	typs[49] = newSig(params(typs[48], typs[22]), params(typs[28]))
	typs[50] = newSig(params(typs[33], typs[1], typs[15]), params(typs[28]))
	typs[51] = newSig(params(typs[1], typs[15]), params(typs[28]))
	typs[52] = types.RuneType
	typs[53] = types.NewSlice(typs[52])
	typs[54] = newSig(params(typs[33], typs[53]), params(typs[28]))
	typs[55] = newSig(params(typs[33], typs[28]), params(typs[40]))
	typs[56] = types.NewArray(typs[52], 32)
	typs[57] = types.NewPtr(typs[56])
	typs[58] = newSig(params(typs[57], typs[28]), params(typs[53]))
	typs[59] = newSig(params(typs[3], typs[15], typs[3], typs[15], typs[5]), params(typs[15]))
	typs[60] = newSig(params(typs[28], typs[15]), params(typs[52], typs[15]))
	typs[61] = newSig(params(typs[28]), params(typs[15]))
	typs[62] = newSig(params(typs[1], typs[3]), params(typs[7]))
	typs[63] = types.Types[types.TUINT16]
	typs[64] = newSig(params(typs[63]), params(typs[7]))
	typs[65] = types.Types[types.TUINT32]
	typs[66] = newSig(params(typs[65]), params(typs[7]))
	typs[67] = newSig(params(typs[24]), params(typs[7]))
	typs[68] = newSig(params(typs[28]), params(typs[7]))
	typs[69] = types.Types[types.TUINT8]
	typs[70] = types.NewSlice(typs[69])
	typs[71] = newSig(params(typs[70]), params(typs[7]))
	typs[72] = newSig(params(typs[1], typs[1]), params(typs[1]))
	typs[73] = newSig(params(typs[1], typs[1], typs[1]), nil)
	typs[74] = newSig(params(typs[1]), nil)
	typs[75] = newSig(params(typs[1], typs[1]), params(typs[15], typs[1]))
	typs[76] = types.NewPtr(typs[5])
	typs[77] = newSig(params(typs[76], typs[7], typs[7]), params(typs[6]))
	typs[78] = newSig(params(typs[15]), nil)
	typs[79] = newSig(nil, params(typs[10]))
	typs[80] = newSig(nil, params(typs[24]))
	typs[81] = newSig(nil, params(typs[65]))
	typs[82] = types.NewMap(typs[2], typs[2])
	typs[83] = newSig(params(typs[1], typs[22], typs[3]), params(typs[82]))
	typs[84] = newSig(params(typs[1], typs[15], typs[3]), params(typs[82]))
	typs[85] = newSig(nil, params(typs[82]))
	typs[86] = newSig(params(typs[1], typs[82], typs[3]), params(typs[3]))
	typs[87] = newSig(params(typs[1], typs[82], typs[65]), params(typs[3]))
	typs[88] = newSig(params(typs[1], typs[82], typs[24]), params(typs[3]))
	typs[89] = newSig(params(typs[1], typs[82], typs[28]), params(typs[3]))
	typs[90] = newSig(params(typs[1], typs[82], typs[3], typs[1]), params(typs[3]))
	typs[91] = newSig(params(typs[1], typs[82], typs[3]), params(typs[3], typs[6]))
	typs[92] = newSig(params(typs[1], typs[82], typs[65]), params(typs[3], typs[6]))
	typs[93] = newSig(params(typs[1], typs[82], typs[24]), params(typs[3], typs[6]))
	typs[94] = newSig(params(typs[1], typs[82], typs[28]), params(typs[3], typs[6]))
	typs[95] = newSig(params(typs[1], typs[82], typs[3], typs[1]), params(typs[3], typs[6]))
	typs[96] = newSig(params(typs[1], typs[82], typs[7]), params(typs[3]))
	typs[97] = newSig(params(typs[1], typs[82], typs[3]), nil)
	typs[98] = newSig(params(typs[1], typs[82], typs[65]), nil)
	typs[99] = newSig(params(typs[1], typs[82], typs[24]), nil)
	typs[100] = newSig(params(typs[1], typs[82], typs[28]), nil)
	typs[101] = newSig(params(typs[3]), nil)
	typs[102] = newSig(params(typs[1], typs[82]), nil)
	typs[103] = types.NewChan(typs[2], types.Cboth)
	typs[104] = newSig(params(typs[1], typs[22]), params(typs[103]))
	typs[105] = newSig(params(typs[1], typs[15]), params(typs[103]))
	typs[106] = types.NewChan(typs[2], types.Crecv)
	typs[107] = newSig(params(typs[106], typs[3]), nil)
	typs[108] = newSig(params(typs[106], typs[3]), params(typs[6]))
	typs[109] = types.NewChan(typs[2], types.Csend)
	typs[110] = newSig(params(typs[109], typs[3]), nil)
	typs[111] = newSig(params(typs[109]), nil)
	typs[112] = newSig(params(typs[2]), params(typs[15]))
	typs[113] = types.NewArray(typs[0], 3)
	typs[114] = types.NewStruct([]*types.Field{types.NewField(src.NoXPos, Lookup("enabled"), typs[6]), types.NewField(src.NoXPos, Lookup("pad"), typs[113]), types.NewField(src.NoXPos, Lookup("cgo"), typs[6]), types.NewField(src.NoXPos, Lookup("alignme"), typs[24])})
	typs[115] = newSig(params(typs[1], typs[3], typs[3]), nil)
	typs[116] = newSig(params(typs[1], typs[3]), nil)
	typs[117] = newSig(params(typs[1], typs[3], typs[15], typs[3], typs[15]), params(typs[15]))
	typs[118] = newSig(params(typs[109], typs[3]), params(typs[6]))
	typs[119] = newSig(params(typs[3], typs[106]), params(typs[6], typs[6]))
	typs[120] = newSig(params(typs[76]), nil)
	typs[121] = newSig(params(typs[1], typs[1], typs[76], typs[15], typs[15], typs[6]), params(typs[15], typs[6]))
	typs[122] = newSig(params(typs[1], typs[15], typs[15]), params(typs[7]))
	typs[123] = newSig(params(typs[1], typs[22], typs[22]), params(typs[7]))
	typs[124] = newSig(params(typs[1], typs[15], typs[15], typs[7]), params(typs[7]))
	typs[125] = types.NewSlice(typs[2])
	typs[126] = newSig(params(typs[3], typs[15], typs[15], typs[15], typs[1]), params(typs[125]))
	typs[127] = newSig(params(typs[1], typs[7], typs[22]), nil)
	typs[128] = newSig(params(typs[7], typs[22]), nil)
	typs[129] = newSig(params(typs[3], typs[3], typs[5]), nil)
	typs[130] = newSig(params(typs[7], typs[5]), nil)
	typs[131] = newSig(params(typs[3], typs[3], typs[5]), params(typs[6]))
	typs[132] = newSig(params(typs[3], typs[3]), params(typs[6]))
	typs[133] = newSig(params(typs[7], typs[7]), params(typs[6]))
	typs[134] = newSig(params(typs[3], typs[5], typs[5]), params(typs[5]))
	typs[135] = newSig(params(typs[7], typs[5]), params(typs[5]))
	typs[136] = newSig(params(typs[3], typs[5]), params(typs[5]))
	typs[137] = newSig(params(typs[22], typs[22]), params(typs[22]))
	typs[138] = newSig(params(typs[24], typs[24]), params(typs[24]))
	typs[139] = newSig(params(typs[20]), params(typs[22]))
	typs[140] = newSig(params(typs[20]), params(typs[24]))
	typs[141] = newSig(params(typs[20]), params(typs[65]))
	typs[142] = newSig(params(typs[22]), params(typs[20]))
	typs[143] = types.Types[types.TFLOAT32]
	typs[144] = newSig(params(typs[22]), params(typs[143]))
	typs[145] = newSig(params(typs[24]), params(typs[20]))
	typs[146] = newSig(params(typs[24]), params(typs[143]))
	typs[147] = newSig(params(typs[65]), params(typs[20]))
	typs[148] = newSig(params(typs[26], typs[26]), params(typs[26]))
	typs[149] = newSig(params(typs[5], typs[5]), nil)
	typs[150] = newSig(params(typs[5], typs[5], typs[5]), nil)
	typs[151] = newSig(params(typs[7], typs[1], typs[5]), nil)
	typs[152] = types.NewSlice(typs[7])
	typs[153] = newSig(params(typs[7], typs[152]), nil)
	typs[154] = newSig(params(typs[69], typs[69], typs[17]), nil)
	typs[155] = newSig(params(typs[63], typs[63], typs[17]), nil)
	typs[156] = newSig(params(typs[65], typs[65], typs[17]), nil)
	typs[157] = newSig(params(typs[24], typs[24], typs[17]), nil)
	typs[158] = newSig(params(typs[28], typs[28], typs[17]), nil)
	typs[159] = types.NewArray(typs[0], 16)
	typs[160] = newSig(params(typs[7], typs[65], typs[159], typs[28], typs[15], typs[69], typs[69]), params(typs[65]))
	return typs[:]
}

var coverageDecls = [...]struct {
	name string
	tag  int
	typ  int
}{
	{"initHook", funcTag, 1},
}

func coverageTypes() []*types.Type {
	var typs [2]*types.Type
	typs[0] = types.Types[types.TBOOL]
	typs[1] = newSig(params(typs[0]), nil)
	return typs[:]
}

"""



```
Response: Let's break down the thought process for analyzing this Go code snippet.

1. **Initial Reading and High-Level Understanding:** The first step is to read through the code and comments to get a general idea of its purpose. The comments clearly state it's for testing division and modulus operations, especially for software implementations. The `long` constant and the `main` function's logic hint at different testing intensities. The function names like `checkdiv`, `gen`, `udiv`, and `idiv` are also strong indicators.

2. **Identifying Core Functionality:**  After the initial reading, the core functionality seems to revolve around generating test cases and then verifying the correctness of division and modulus operations. The `gen1` and `gen2` functions likely generate pairs of numbers. The `checkdiv` family of functions appears to perform the actual testing.

3. **Dissecting the Test Case Generation (`gen1`, `gen2`, `checkdiv1`, `checkdiv2`, `checkdiv3`):**
    * **`gen1(n, w, f)`:** This function seems to generate numbers with a limited number of bits set. The recursive nature of `gen` is key here. It explores all combinations of setting bits up to `n` bits within the lowest `w` bits.
    * **`gen2(n1, w1, n2, w2, f)`:** This function simply calls `gen1` twice to generate pairs of numbers, applying the function `f` to each pair.
    * **`checkdiv1(x, y)`:** This function takes two generated numbers and checks not just the numbers themselves but also values slightly above and below them (x +/- 1, y +/- 1), aiming to test boundary conditions. It also avoids redundant calls by checking the least significant bit.
    * **`checkdiv2(x, y)`:** This function extends the testing by also checking the bitwise inversions of `x` and `y`. This is important for testing how the division and modulo operations handle negative numbers (when interpreted as signed).
    * **`checkdiv3(x, y)`:** This function is the heart of the testing. It calls the type-specific `checkuint` and `checkint` functions for various integer sizes (8, 16, 32, 64 bits) and their signed/unsigned counterparts. It also has the `ntest` counter to track the number of tests performed.

4. **Analyzing the Verification Logic (`checkuint*`, `checkint*`):**
    * These functions all follow a similar pattern:
        * **Handle Division by Zero:** They explicitly check if the divisor `y` is zero and call `divzero*` and `modzero*` functions.
        * **Compute Expected Result:** They call `udiv` (unsigned) or `idiv` (signed) to calculate the *correct* quotient and remainder using a bitwise shift and subtract algorithm. This is the ground truth.
        * **Compute Actual Result:** They perform the standard Go division (`/`) and modulo (`%`) operations.
        * **Compare Results:** They compare the expected and actual results. If there's a mismatch, they print an error message.

5. **Understanding the `udiv` and `idiv` Functions:**
    * **`udiv(x, y)`:**  This implements unsigned division using a shift-and-subtract algorithm. This is crucial as it provides an independent, known-correct way to calculate the division and modulo, against which the built-in operators are tested.
    * **`idiv(x, y)`:**  This handles signed division by converting the operands to unsigned, performing unsigned division using `udiv`, and then adjusting the sign of the quotient and remainder based on the signs of the original operands. The special case for `minint / -1` is important due to the asymmetry of the range of signed integers.

6. **Identifying the Role of Panic Handling (`divzero*`, `modzero*`, `checkdivzero`, `checkumodzero`):**
    * These functions are designed to verify that division and modulo by zero cause a panic. The `defer recover()` mechanism is the standard way to catch panics in Go.

7. **Inferring the Overall Purpose:** Combining these observations, the primary purpose of this code is to rigorously test the correctness of Go's division and modulo operators for various integer types and edge cases. It uses a brute-force approach to generate a large number of test cases and compares the results against a known-correct implementation.

8. **Considering Command-Line Arguments and Usage:**  The code doesn't explicitly use `os.Args` or the `flag` package. The `long` constant is a compile-time switch. Therefore, there are no command-line arguments to discuss.

9. **Identifying Potential Pitfalls:**  The most obvious potential pitfall is related to the `long` constant. If someone modifies this to `true` without realizing the significant increase in test cases, the program will take a very long time to run. Another potential issue is understanding the range of test cases generated by `gen1` and `gen2`. Incorrectly understanding the `n` and `w` parameters could lead to a false sense of thoroughness in testing.

10. **Structuring the Output:** Finally, organize the findings into the requested categories: functionality, example usage, code reasoning (with assumptions), command-line arguments, and common mistakes. Use clear and concise language. Provide code examples that demonstrate the core functionality, like how the testing is triggered.

This structured approach, starting from a high-level overview and progressively diving into details, is essential for understanding and explaining complex code like this. The focus is not just on *what* the code does but also *why* it does it that way.
Let's break down the functionality of the Go code step-by-step.

**Functionality:**

This Go code is designed for **rigorous testing of integer division and modulo operations** in Go. It aims to verify the correctness of the `/` and `%` operators for various integer types (signed and unsigned, with different bit sizes).

Here's a breakdown of its key functions:

1. **Test Case Generation:**
   - `gen1(n, w int, f func(uint64))`: Generates unsigned 64-bit integers (`uint64`) with at most `n` bits set within the lowest `w` bits. It then calls the provided function `f` with each generated value. This function uses a recursive helper function `gen`.
   - `gen2(n1, w1, n2, w2 int, f func(uint64, uint64))`: Generates pairs of `uint64` values. The first value has at most `n1` bits set in the low `w1` bits, and the second has at most `n2` bits set in the low `w2` bits. It calls the function `f` with each generated pair.
   - The `main` function uses `gen2` to initiate the test case generation. It has a `long` constant that determines the number of test cases. When `long` is `true`, it generates a significantly larger number of test cases.

2. **Test Execution and Verification:**
   - `checkdiv1(x, y uint64)`: Takes two `uint64` values and calls `checkdiv2` with these values, and also with values slightly above and below (x +/- 1, y +/- 1) to test boundary conditions. It avoids redundant checks based on the least significant bit.
   - `checkdiv2(x, y uint64)`: Calls `checkdiv3` with the original values, and also with bitwise inversions of `x` and `y` to test the behavior with different bit patterns and effectively cover negative numbers when interpreted as signed integers.
   - `checkdiv3(x, y uint64)`: This is the core testing function. It increments a counter `ntest`. It then calls type-specific `checkuint` and `checkint` functions for `uint64`, `uint32`, `uint16`, `uint8`, `int64`, `int32`, `int16`, and `int8`. This ensures the division and modulo operations are tested across various integer sizes.

3. **Individual Type Checks:**
   - `checkuint*(x, y <type>)` and `checkint*(x, y <type>)`: These functions perform the actual division and modulo operations for specific integer types.
     - They first check for division by zero. If the divisor `y` is zero, they call `divzero*` and `modzero*` functions, which are expected to panic.
     - They then calculate the correct quotient (`q`) and remainder (`r`) using the `udiv` (for unsigned) or `idiv` (for signed) functions, which implement division using shift and subtract.
     - They compare these correct results with the results obtained using Go's built-in `/` and `%` operators. If there's a mismatch, they print an error message.

4. **Division by Zero Handling:**
   - `divzerouint*(x, y <type>)`, `modzerouint*(x, y <type>)`, `divzeroint*(x, y <type>)`, `modzeroint*(x, y <type>)`: These functions are called when a division or modulo by zero is detected. They use `defer recover()` to check if a panic occurs, which is the expected behavior in Go for division by zero.
   - `checkudivzero`, `checkdivzero`, `checkumodzero`, `checkmodzero`: These are helper functions used within the `defer recover()` blocks to print an error message if a panic did not occur as expected.

5. **Software Division Implementation:**
   - `udiv(x, y uint64) (q, r uint64)`: Implements unsigned division using a shift-and-subtract algorithm. This serves as the ground truth against which the built-in division operator is compared.
   - `idiv(x, y int64) (q, r int64)`: Implements signed division by converting the operands to unsigned, using `udiv`, and then adjusting the signs of the quotient and remainder.

**Inference of Go Language Feature:**

This code is primarily testing the correctness and robustness of Go's **integer division (`/`) and modulo (`%`) operators**. It ensures that these operators function correctly across different integer types and handle edge cases like division by zero appropriately.

**Go Code Example Illustrating the Tested Feature:**

```go
package main

import "fmt"

func main() {
	// Basic integer division and modulo
	a := 10
	b := 3
	quotient := a / b
	remainder := a % b
	fmt.Printf("%d / %d = %d, %d %% %d = %d\n", a, b, quotient, a, b, remainder) // Output: 10 / 3 = 3, 10 % 3 = 1

	// Division and modulo with different integer types
	var c int32 = 25
	var d int16 = 7
	quotient32 := c / int32(d)
	remainder16 := c % int32(d)
	fmt.Printf("%d / %d = %d, %d %% %d = %d\n", c, d, quotient32, c, d, remainder16) // Output: 25 / 7 = 3, 25 % 7 = 4

	// Division by zero (will cause a panic if not handled)
	e := 5
	f := 0
	// quotientZero := e / f // This line will cause a runtime panic
	// fmt.Println(quotientZero)

	// Demonstrating the 'udiv' and 'idiv' logic (similar to what the test uses)
	ux := uint64(15)
	uy := uint64(4)
	uq, ur := udiv(ux, uy)
	fmt.Printf("udiv(%d, %d) = quotient: %d, remainder: %d\n", ux, uy, uq, ur) // Output: udiv(15, 4) = quotient: 3, remainder: 3

	sx := int64(-17)
	sy := int64(5)
	sq, sr := idiv(sx, sy)
	fmt.Printf("idiv(%d, %d) = quotient: %d, remainder: %d\n", sx, sy, sq, sr) // Output: idiv(-17, 5) = quotient: -3, remainder: -2
}

// ... (udiv and idiv functions from the original code) ...

// unsigned divide and mod using shift and subtract.
func udiv(x, y uint64) (q, r uint64) {
	sh := 0
	for y+y > y && y+y <= x {
		sh++
		y <<= 1
	}
	for ; sh >= 0; sh-- {
		q <<= 1
		if x >= y {
			x -= y
			q |= 1
		}
		y >>= 1
	}
	return q, x
}

// signed divide and mod: do unsigned and adjust signs.
func idiv(x, y int64) (q, r int64) {
	// special case for minint / -1 = minint
	if x-1 > x && y == -1 {
		return x, 0
	}
	ux := uint64(x)
	uy := uint64(y)
	if x < 0 {
		ux = -ux
	}
	if y < 0 {
		uy = -uy
	}
	uq, ur := udiv(ux, uy)
	q = int64(uq)
	r = int64(ur)
	if x < 0 {
		r = -r
	}
	if (x < 0) != (y < 0) {
		q = -q
	}
	return q, r
}
```

**Code Reasoning with Assumptions:**

The code assumes that:

1. **The `udiv` and `idiv` functions provide a correct implementation of division and modulo.** This is the basis for comparing the results of the built-in operators.
2. **Generating various combinations of numbers, especially around powers of 2 and with different bit patterns, is crucial for thorough testing.** The `gen1` and `gen2` functions are designed to cover a significant range of input values.
3. **Testing the operations with slightly modified values (in `checkdiv1`) helps catch boundary condition errors.**

**Assumptions for Input and Output of `udiv` and `idiv`:**

* **`udiv(x, y uint64)`:**
    * **Input:** `x` (dividend), `y` (divisor) are unsigned 64-bit integers.
    * **Output:** `q` (quotient), `r` (remainder) are unsigned 64-bit integers, such that `x = q*y + r` and `0 <= r < y`.
    * **Example:** `udiv(15, 4)` would return `q=3`, `r=3`.

* **`idiv(x, y int64)`:**
    * **Input:** `x` (dividend), `y` (divisor) are signed 64-bit integers.
    * **Output:** `q` (quotient), `r` (remainder) are signed 64-bit integers. The sign of the remainder follows the sign of the dividend (Go's convention).
    * **Example:** `idiv(-17, 5)` would return `q=-3`, `r=-2`.

**Command-Line Parameter Handling:**

This specific code snippet **does not handle any command-line parameters directly**. The behavior is controlled by the `long` constant defined at the top of the file.

To change the number of test cases, you would need to modify the `long` constant in the source code and recompile the program:

```go
const long = true // To run the more extensive test suite
```

**User Mistakes:**

One common mistake a user might make when dealing with division and modulo is **forgetting to handle division by zero**. Go will panic at runtime if you attempt to divide by zero. The provided test code explicitly checks for this and verifies that a panic occurs.

**Example of a potential mistake:**

```go
package main

import "fmt"

func main() {
	numerator := 10
	denominator := 0
	// result := numerator / denominator // This will cause a panic

	// Correct way to handle potential division by zero
	if denominator != 0 {
		result := numerator / denominator
		fmt.Println("Result:", result)
	} else {
		fmt.Println("Error: Cannot divide by zero")
	}
}
```

In summary, the `go/test/divmod.go` code is a comprehensive test suite for Go's integer division and modulo operators. It generates a large number of test cases, compares the results against a software implementation of division, and verifies the correct handling of division by zero. It doesn't use command-line arguments but relies on a constant to control the test intensity. A common user mistake it implicitly highlights is the need to handle division by zero to prevent runtime panics.

Prompt: 
```
这是路径为go/test/divmod.go的go语言实现的一部分， 请列举一下它的功能, 　
如果你能推理出它是什么go语言功能的实现，请用go代码举例说明, 
如果涉及代码推理，需要带上假设的输入与输出，
如果涉及命令行参数的具体处理，请详细介绍一下，
如果有哪些使用者易犯错的点，请举例说明，没有则不必说明，

"""
// run

// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test division of variables. Generate many test cases,
// compute correct answer using shift and subtract,
// and then compare against results from division and
// modulus operators.
//
// Primarily useful for testing software div/mod.

package main

const long = false

func main() {
	if long {
		// About 3e9 test cases (calls to checkdiv3).
		// Too long for everyday testing.
		gen2(3, 64, 2, 64, checkdiv1)
		println(ntest)
	} else {
		// About 4e6 test cases (calls to checkdiv3).
		// Runs for 8 seconds on ARM chromebook, much faster elsewhere.
		gen2(2, 64, 1, 64, checkdiv1)
	}
}

// generate all uint64 values x where x has at most n bits set in the low w
// and call f(x) for each.
func gen1(n, w int, f func(uint64)) {
	gen(0, 0, n, w-1, f)
}

func gen(val uint64, nbits, maxbits, pos int, f func(uint64)) {
	if pos < 0 {
		f(val)
		return
	}
	gen(val, nbits, maxbits, pos-1, f)
	if nbits < maxbits {
		gen(val|1<<uint(pos), nbits+1, maxbits, pos-1, f)
	}
}

// generate all uint64 values x, y where x has at most n1 bits set in the low w1
// and y has at most n2 bits set in the low w2 and call f(x, y) for each.
func gen2(n1, w1, n2, w2 int, f func(uint64, uint64)) {
	gen1(n1, w1, func(x uint64) {
		gen1(n2, w2, func(y uint64) {
			f(x, y)
		})
	})
}

// x and y are uint64s with at most 2 bits set.
// Check those values and values above and below,
// along with bitwise inversions of the same (done in checkdiv2).
func checkdiv1(x, y uint64) {
	checkdiv2(x, y)
	// If the low bit is set in x or y, adding or subtracting 1
	// produces a number that checkdiv1 is going to be called
	// with anyway, so don't duplicate effort.
	if x&1 == 0 {
		checkdiv2(x+1, y)
		checkdiv2(x-1, y)
	}
	if y&1 == 0 {
		checkdiv2(x, y-1)
		checkdiv2(x, y+1)
		if x&1 == 0 {
			checkdiv2(x+1, y-1)
			checkdiv2(x-1, y-1)
			checkdiv2(x-1, y+1)
			checkdiv2(x+1, y+1)
		}
	}
}

func checkdiv2(x, y uint64) {
	checkdiv3(x, y)
	checkdiv3(^x, y)
	checkdiv3(x, ^y)
	checkdiv3(^x, ^y)
}

var ntest int64 = 0

func checkdiv3(x, y uint64) {
	ntest++
	if ntest&(ntest-1) == 0 && long {
		println(ntest, "...")
	}
	checkuint64(x, y)
	if (uint64(uint32(x)) == x || uint64(uint32(^x)) == ^x) && (uint64(uint32(y)) == y || uint64(uint32(^y)) == ^y) {
		checkuint32(uint32(x), uint32(y))
	}
	if (uint64(uint16(x)) == x || uint64(uint16(^x)) == ^x) && (uint64(uint16(y)) == y || uint64(uint16(^y)) == ^y) {
		checkuint16(uint16(x), uint16(y))
	}
	if (uint64(uint8(x)) == x || uint64(uint8(^x)) == ^x) && (uint64(uint8(y)) == y || uint64(uint8(^y)) == ^y) {
		checkuint8(uint8(x), uint8(y))
	}
	
	
	sx := int64(x)
	sy := int64(y)
	checkint64(sx, sy)
	if (int64(int32(sx)) == sx || int64(int32(^sx)) == ^sx) && (int64(int32(sy)) == sy || int64(int32(^sy)) == ^sy) {
		checkint32(int32(sx), int32(sy))
	}
	if (int64(int16(sx)) == sx || int64(int16(^sx)) == ^sx) && (int64(int16(sy)) == sy || int64(int16(^sy)) == ^sy) {
		checkint16(int16(sx), int16(sy))
	}
	if (int64(int8(sx)) == sx || int64(int8(^sx)) == ^sx) && (int64(int8(sy)) == sy || int64(int8(^sy)) == ^sy) {
		checkint8(int8(sx), int8(sy))
	}
}

// Check result of x/y, x%y for various types.

func checkuint(x, y uint) {
	if y == 0 {
		divzerouint(x, y)
		modzerouint(x, y)
		return
	}
	q, r := udiv(uint64(x), uint64(y))
	q1 := x/y
	r1 := x%y
	if q1 != uint(q) {
		print("uint(", x, "/", y, ") = ", q1, ", want ", q, "\n")
	}
	if r1 != uint(r) {
		print("uint(", x, "%", y, ") = ", r1, ", want ", r, "\n")
	}
}

func checkuint64(x, y uint64) {
	if y == 0 {
		divzerouint64(x, y)
		modzerouint64(x, y)
		return
	}
	q, r := udiv(x, y)
	q1 := x/y
	r1 := x%y
	if q1 != q {
		print("uint64(", x, "/", y, ") = ", q1, ", want ", q, "\n")
	}
	if r1 != r {
		print("uint64(", x, "%", y, ") = ", r1, ", want ", r, "\n")
	}
}

func checkuint32(x, y uint32) {
	if y == 0 {
		divzerouint32(x, y)
		modzerouint32(x, y)
		return
	}
	q, r := udiv(uint64(x), uint64(y))
	q1 := x/y
	r1 := x%y
	if q1 != uint32(q) {
		print("uint32(", x, "/", y, ") = ", q1, ", want ", q, "\n")
	}
	if r1 != uint32(r) {
		print("uint32(", x, "%", y, ") = ", r1, ", want ", r, "\n")
	}
}

func checkuint16(x, y uint16) {
	if y == 0 {
		divzerouint16(x, y)
		modzerouint16(x, y)
		return
	}
	q, r := udiv(uint64(x), uint64(y))
	q1 := x/y
	r1 := x%y
	if q1 != uint16(q) {
		print("uint16(", x, "/", y, ") = ", q1, ", want ", q, "\n")
	}
	if r1 != uint16(r) {
		print("uint16(", x, "%", y, ") = ", r1, ", want ", r, "\n")
	}
}

func checkuint8(x, y uint8) {
	if y == 0 {
		divzerouint8(x, y)
		modzerouint8(x, y)
		return
	}
	q, r := udiv(uint64(x), uint64(y))
	q1 := x/y
	r1 := x%y
	if q1 != uint8(q) {
		print("uint8(", x, "/", y, ") = ", q1, ", want ", q, "\n")
	}
	if r1 != uint8(r) {
		print("uint8(", x, "%", y, ") = ", r1, ", want ", r, "\n")
	}
}

func checkint(x, y int) {
	if y == 0 {
		divzeroint(x, y)
		modzeroint(x, y)
		return
	}
	q, r := idiv(int64(x), int64(y))
	q1 := x/y
	r1 := x%y
	if q1 != int(q) {
		print("int(", x, "/", y, ") = ", q1, ", want ", q, "\n")
	}
	if r1 != int(r) {
		print("int(", x, "%", y, ") = ", r1, ", want ", r, "\n")
	}
}

func checkint64(x, y int64) {
	if y == 0 {
		divzeroint64(x, y)
		modzeroint64(x, y)
		return
	}
	q, r := idiv(x, y)
	q1 := x/y
	r1 := x%y
	if q1 != q {
		print("int64(", x, "/", y, ") = ", q1, ", want ", q, "\n")
	}
	if r1 != r {
		print("int64(", x, "%", y, ") = ", r1, ", want ", r, "\n")
	}
}

func checkint32(x, y int32) {
	if y == 0 {
		divzeroint32(x, y)
		modzeroint32(x, y)
		return
	}
	q, r := idiv(int64(x), int64(y))
	q1 := x/y
	r1 := x%y
	if q1 != int32(q) {
		print("int32(", x, "/", y, ") = ", q1, ", want ", q, "\n")
	}
	if r1 != int32(r) {
		print("int32(", x, "%", y, ") = ", r1, ", want ", r, "\n")
	}
}

func checkint16(x, y int16) {
	if y == 0 {
		divzeroint16(x, y)
		modzeroint16(x, y)
		return
	}
	q, r := idiv(int64(x), int64(y))
	q1 := x/y
	r1 := x%y
	if q1 != int16(q) {
		print("int16(", x, "/", y, ") = ", q1, ", want ", q, "\n")
	}
	if r1 != int16(r) {
		print("int16(", x, "%", y, ") = ", r1, ", want ", r, "\n")
	}
}

func checkint8(x, y int8) {
	if y == 0 {
		divzeroint8(x, y)
		modzeroint8(x, y)
		return
	}
	q, r := idiv(int64(x), int64(y))
	q1 := x/y
	r1 := x%y
	if q1 != int8(q) {
		print("int8(", x, "/", y, ") = ", q1, ", want ", q, "\n")
	}
	if r1 != int8(r) {
		print("int8(", x, "%", y, ") = ", r1, ", want ", r, "\n")
	}
}

func divzerouint(x, y uint) uint {
	defer checkudivzero("uint", uint64(x))
	return x / y
}

func divzerouint64(x, y uint64) uint64 {
	defer checkudivzero("uint64", uint64(x))
	return x / y
}

func divzerouint32(x, y uint32) uint32 {
	defer checkudivzero("uint32", uint64(x))
	return x / y
}

func divzerouint16(x, y uint16) uint16 {
	defer checkudivzero("uint16", uint64(x))
	return x / y
}

func divzerouint8(x, y uint8) uint8 {
	defer checkudivzero("uint8", uint64(x))
	return x / y
}

func checkudivzero(typ string, x uint64) {
	if recover() == nil {
		print(typ, "(", x, " / 0) did not panic")
	}
}

func divzeroint(x, y int) int {
	defer checkdivzero("int", int64(x))
	return x / y
}

func divzeroint64(x, y int64) int64 {
	defer checkdivzero("int64", int64(x))
	return x / y
}

func divzeroint32(x, y int32) int32 {
	defer checkdivzero("int32", int64(x))
	return x / y
}

func divzeroint16(x, y int16) int16 {
	defer checkdivzero("int16", int64(x))
	return x / y
}

func divzeroint8(x, y int8) int8 {
	defer checkdivzero("int8", int64(x))
	return x / y
}

func checkdivzero(typ string, x int64) {
	if recover() == nil {
		print(typ, "(", x, " / 0) did not panic")
	}
}

func modzerouint(x, y uint) uint {
	defer checkumodzero("uint", uint64(x))
	return x % y
}

func modzerouint64(x, y uint64) uint64 {
	defer checkumodzero("uint64", uint64(x))
	return x % y
}

func modzerouint32(x, y uint32) uint32 {
	defer checkumodzero("uint32", uint64(x))
	return x % y
}

func modzerouint16(x, y uint16) uint16 {
	defer checkumodzero("uint16", uint64(x))
	return x % y
}

func modzerouint8(x, y uint8) uint8 {
	defer checkumodzero("uint8", uint64(x))
	return x % y
}

func checkumodzero(typ string, x uint64) {
	if recover() == nil {
		print(typ, "(", x, " % 0) did not panic")
	}
}

func modzeroint(x, y int) int {
	defer checkmodzero("int", int64(x))
	return x % y
}

func modzeroint64(x, y int64) int64 {
	defer checkmodzero("int64", int64(x))
	return x % y
}

func modzeroint32(x, y int32) int32 {
	defer checkmodzero("int32", int64(x))
	return x % y
}

func modzeroint16(x, y int16) int16 {
	defer checkmodzero("int16", int64(x))
	return x % y
}

func modzeroint8(x, y int8) int8 {
	defer checkmodzero("int8", int64(x))
	return x % y
}

func checkmodzero(typ string, x int64) {
	if recover() == nil {
		print(typ, "(", x, " % 0) did not panic")
	}
}

// unsigned divide and mod using shift and subtract.
func udiv(x, y uint64) (q, r uint64) {
	sh := 0
	for y+y > y && y+y <= x {
		sh++
		y <<= 1
	}
	for ; sh >= 0; sh-- {
		q <<= 1
		if x >= y {
			x -= y
			q |= 1
		}
		y >>= 1
	}
	return q, x	
}

// signed divide and mod: do unsigned and adjust signs.
func idiv(x, y int64) (q, r int64) {
	// special case for minint / -1 = minint
	if x-1 > x && y == -1 {
		return x, 0
	}
	ux := uint64(x)
	uy := uint64(y)
	if x < 0 {
		ux = -ux
	}
	if y < 0 {
		uy = -uy
	}
	uq, ur := udiv(ux, uy)
	q = int64(uq)
	r = int64(ur)
	if x < 0 {
		r = -r
	}
	if (x < 0) != (y < 0) {
		q = -q
	}
	return q, r
}

"""



```